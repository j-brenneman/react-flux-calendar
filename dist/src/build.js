(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/lib/_empty.js":[function(require,module,exports){

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/path-browserify/index.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/CldrPluralRule.js":[function(require,module,exports){
(function (__dirname){
var fs = require('fs'),
    Path = require('path'),
    PEG = require('pegjs'),
    parser = PEG.buildParser(fs.readFileSync(Path.resolve(__dirname, 'cldrPluralRule.pegjs'), 'utf-8'));

function rangeListToJavaScriptAst(rangeListNode, lhsJavaScriptAst, withinSemantics) {
    var javaScriptAst,
        seenRange = false;
    for (var i = rangeListNode.ranges.length - 1 ; i >= 0 ; i -= 1) {
        var range = rangeListNode.ranges[i],
            itemJavaScriptAst;
        if (range.type === 'number') {
            itemJavaScriptAst = ['binary', '===', lhsJavaScriptAst, ['num', range.value]];
        } else {
            // range.type === 'range'
            seenRange = true;
            itemJavaScriptAst = ['binary', '&&', ['binary', '>=', lhsJavaScriptAst, ['num', range.min.value]],
                                                 ['binary', '<=', lhsJavaScriptAst, ['num', range.max.value]]];
        }
        if (javaScriptAst) {
            javaScriptAst = ['binary', '||', itemJavaScriptAst, javaScriptAst];
        } else {
            javaScriptAst = itemJavaScriptAst;
        }
    }
    if (seenRange && !withinSemantics) {
        javaScriptAst = ['binary', '&&', ['binary', '===', lhsJavaScriptAst,
                                                           ['call', ['dot', ['name', 'Math'], 'floor'], [lhsJavaScriptAst]]],
                                         javaScriptAst];
    }
    return javaScriptAst;
}

function nodeToJavaScriptAst(node) {
    switch (node.type) {
    case 'number':
        return ['num', node.value];
    case 'n':
    case 'i':
    case 'v':
    case 'w':
    case 'f':
    case 't':
        return ['name', node.type];
    case 'is':
        return ['binary', '==='].concat(node.operands.map(nodeToJavaScriptAst));
    case 'isnot':
        return ['binary', '!=='].concat(node.operands.map(nodeToJavaScriptAst));
    case 'mod':
        return ['binary', '%'].concat(node.operands.map(nodeToJavaScriptAst));
    case 'and':
        return ['binary', '&&'].concat(node.operands.map(nodeToJavaScriptAst));
    case 'or':
        return ['binary', '||'].concat(node.operands.map(nodeToJavaScriptAst));
    case 'not':
        return ['unary-prefix', '!', nodeToJavaScriptAst(node.operands)];
    case 'isnot':
        return ['binary', '!=='].concat(node.operands.map(nodeToJavaScriptAst));
    case 'within':
        return rangeListToJavaScriptAst(node.operands[1], nodeToJavaScriptAst(node.operands[0]), true);
    case 'notwithin':
        return ['unary-prefix', '!', rangeListToJavaScriptAst(node.operands[1], nodeToJavaScriptAst(node.operands[0]), true)];
    case 'in':
        return rangeListToJavaScriptAst(node.operands[1], nodeToJavaScriptAst(node.operands[0]), false);
    case 'notin':
        return ['unary-prefix', '!', rangeListToJavaScriptAst(node.operands[1], nodeToJavaScriptAst(node.operands[0]), false)];
    default:
        throw new Error('nodeToJavaScriptAst: Unknown node type: ' + node.type);
    }
}

function traverse(node, lambda) {
    lambda(node);
    if (node.operands) {
        node.operands.forEach(function (operand) {
            traverse(operand, lambda);
        });
    }
}

function CldrPluralRule(src) {
    this.topLevelNode = parser.parse(src.replace(/^\s+|\s+$/g, '').replace(/\s{2,}/g, ' '));
}

CldrPluralRule.prototype = {
    toJavaScriptAst: function () {
        return nodeToJavaScriptAst(this.topLevelNode);
    },

    eachNode: function (lambda) {
        traverse(this.topLevelNode, lambda);
    },

    updateIsUsedByTerm: function (isUsedByTerm) {
        this.eachNode(function (node) {
            if (['i', 'v', 'w', 'f', 't', 'n'].indexOf(node.type) !== -1) {
                isUsedByTerm[node.type] = true;
            }
        });
        return isUsedByTerm;
    }
};

module.exports = CldrPluralRule;

}).call(this,"/node_modules/cldr/lib")

},{"fs":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/lib/_empty.js","path":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/path-browserify/index.js","pegjs":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/pegjs/lib/peg.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/CldrPluralRuleSet.js":[function(require,module,exports){
var CldrPluralRule = require('./CldrPluralRule'),
    cldrPluralRuleTermFunctionByName = require('./cldrPluralRuleTermFunctionByName'),
    uglifyJs = require('uglify-js');

function CldrPluralRuleSet() {
    this.cldrPluralRuleByCount = {};
}

CldrPluralRuleSet.prototype = {
    addRule: function (cldrPluralRule, count) {
        if (typeof cldrPluralRule === 'string') {
            cldrPluralRule = cldrPluralRule.replace(/\s*@(?:decimal|integer).*$/, '');
            // Some count="other" nodes in CLDR 24+ consist purely of sample text.
            // Don't add those.
            if (cldrPluralRule.length === 0) {
                return;
            }
            cldrPluralRule = new CldrPluralRule(cldrPluralRule);
        }
        this.cldrPluralRuleByCount[count] = cldrPluralRule;
    },

    toJavaScriptFunctionBodyAst: function () {
        var statementAsts = [],
            isUsedByTerm = {};
        Object.keys(this.cldrPluralRuleByCount).forEach(function (count) {
            var cldrPluralRule = this.cldrPluralRuleByCount[count];
            cldrPluralRule.updateIsUsedByTerm(isUsedByTerm);
            statementAsts.push(
                [
                    'if',
                    cldrPluralRule.toJavaScriptAst(),
                    ['return', ['string', count]]
                ]
            );
        }, this);
        statementAsts.push(['return', ['string', 'other']]);
        var varAsts = [];

        ['i', 'v', 'w', 'f', 't'].forEach(function (term) {
            if (isUsedByTerm[term]) {
                varAsts.push([term, uglifyJs.parser.parse(cldrPluralRuleTermFunctionByName[term].toString())[1][0][3][0][1]]);
            }
        });

        if (Object.keys(isUsedByTerm).length !== 0) {
            statementAsts.unshift(
                // if (typeof n === 'string') n = parseInt(n, 10);
                [ 'if',
                      [ 'binary',
                        '===',
                        [ 'unary-prefix', 'typeof', [ 'name', 'n' ] ],
                        [ 'string', 'string' ] ],
                      [ 'stat',
                        [ 'assign',
                          true,
                          [ 'name', 'n' ],
                          [ 'call',
                            [ 'name', 'parseInt' ],
                            [ [ 'name', 'n' ], [ 'num', 10 ] ] ] ] ],
                      undefined ]
            );
        }

        if (varAsts.length > 0) {
            statementAsts.unshift(['var', varAsts]);
        }
        return statementAsts;
    }
};

module.exports = CldrPluralRuleSet;

},{"./CldrPluralRule":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/CldrPluralRule.js","./cldrPluralRuleTermFunctionByName":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/cldrPluralRuleTermFunctionByName.js","uglify-js":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/uglify-js.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/CldrRbnfRuleSet.js":[function(require,module,exports){
var _ = require('underscore');

function CldrRbnfRuleSet(config) {
    _.extend(this, config);
    this.ruleByValue = {};
}

CldrRbnfRuleSet.getSafeRendererName = function (rendererName) {
    return (
        ("render-" + rendererName)
        .replace(/[^\w-]/g, '-')
        .replace(/[-_]+([0-9a-z])/gi, function ($0, ch) {
            return ch.toUpperCase();
        })
        .replace('GREEKNUMERALMAJUSCULES', 'GreekNumeralMajuscules')
    );
};

CldrRbnfRuleSet.prototype = {
    toFunctionAst: function () {
        var that = this,
            isSeenByRuleSetType = {};

        function ruleToExpressionAst(rule) {
            var expressionAsts = [],
                rbnf = rule.rbnf;

            // "If a rule body begins with an apostrophe, the apostrophe is ignored, but all text after it becomes
            // significant (this is how you can have a rule's rule text begin with whitespace)."
            // -- http://www.icu-project.org/apiref/icu4c/classRuleBasedNumberFormat.html
            rbnf = rbnf.replace(/^'/, '');

            var radix = rule.radix || 10;

            function getDivisor() {
                var divisor = 1;
                while (10 * divisor <= parseInt(rule.value, 10)) { // Inefficient, but won't suffer from Math.log rounding errors
                    divisor *= 10;
                }
                return divisor;
            }

            // Replace is used for tokenization, the return value isn't used:
            rbnf.replace(/(?:([\<\>\=])(?:(%%?[\w\-]+)|([#,0.]+))?\1)|(?:\[([^\]]+)\])|([\x7f-\uffff:'\.\s\w\d\-]+)/gi, function ($0, specialChar, otherFormat, decimalFormat, optional, literal) {
                // The meanings of the substitution token characters are as follows:
                if (specialChar) {
                    var expr;
                    if (specialChar === '<') { // <<
                        if (/^\d+$/.test(rule.value)) {
                            // In normal rule: Divide the number by the rule's divisor and format the quotient
                            expr = ['call', ['dot', ['name', 'Math'], 'floor'], [['binary', '/', ['name', 'n'], ['num', getDivisor()]]]];
                        } else if (rule.value === '-x') {
                            throw new Error('<< not allowed in negative number rule');
                        } else {
                            // In fraction or master rule: Isolate the number's integral part and format it.
                            expr = ['call', ['dot', ['name', 'Math'], 'floor'], [['name', 'n']]];
                        }
                    } else if (specialChar === '>') { // >>
                        if (/\./.test(rule.value)) {
                            // Fraction or master rule => parseInt(String(n).replace(/\d*\./, ''), 10)
                            expr = ['call', ['name', 'parseInt'], [['call', ['dot', ['call', ['name', 'String'], [['name', 'n']]], 'replace'], [['regexp', '\\d*\\.', ''], ['string', '']]], ['num', 10]]];
                        } else if (rule.value === '-x') {
                            expr = ['unary-prefix', '-', ['name', 'n']];
                        } else {
                            expr = ['binary', '%', ['name', 'n'], ['num', getDivisor()]];
                        }
                    } else if (specialChar === '=') { // ==
                        expr = ['name', 'n'];
                    }
                    // FIXME: >>> not supported

                    // The substitution descriptor (i.e., the text between the token characters) may take one of three forms:
                    if (otherFormat) {
                        // A rule set name:
                        // Perform the mathematical operation on the number, and format the result using the named rule set.
                        var otherFormatName = CldrRbnfRuleSet.getSafeRendererName(otherFormat);
                        isSeenByRuleSetType[otherFormatName] = true;
                        // Turn into this.<otherFormatName>(<expr>)
                        expressionAsts.push(['call', ['dot', ['name', 'this'], otherFormatName], [expr]]);
                    } else if (decimalFormat) {
                        // A DecimalFormat pattern:
                        // Perform the mathematical operation on the number, and format the result using a DecimalFormat
                        // with the specified pattern. The pattern must begin with 0 or #.
                        expressionAsts.push(['call', ['dot', ['name', 'this'], 'renderNumber'], [expr, ['string', decimalFormat]]]);
                    } else {
                        // Nothing:
                        if (specialChar === '>') {
                            // If you omit the substitution descriptor in a >> substitution in a fraction rule, format the result one digit at a time using the rule set containing the current rule.
                            expressionAsts.push(['call', ['dot', ['name', 'this'], that.type], [expr]]);
                        } else if (specialChar === '<') {
                            // If you omit the substitution descriptor in a << substitution in a rule in a fraction rule set, format the result using the default rule set for this renderer.
                            // FIXME: Should be the default rule set for this renderer!
                            expressionAsts.push(['call', ['dot', ['name', 'this'], that.type], [expr]]);
                        } else {
                            throw new Error('== not supported!');
                        }
                   }
                } else if (optional) { // [ ... ]
                    var optionalRuleExpressionAst = ruleToExpressionAst({radix: rule.radix, rbnf: optional, value: rule.value});
                    expressionAsts.push(['conditional', ['binary', '===', ['name', 'n'], ['num', parseInt(rule.value, 10)]], ['string', ''], optionalRuleExpressionAst]);
                } else if (literal) {
                    expressionAsts.push(['string', literal]);
                } else {
                    throw new Error("Unknown token in " + rule.rbnf);
                }
            });
            if (expressionAsts.length === 0) {
                expressionAsts = [['string', '']];
            }
            var expressionAst = expressionAsts.shift();
            while (expressionAsts.length > 0) {
                expressionAst = ['binary', '+', expressionAst, expressionAsts.shift()];
            }
            return expressionAst;
        }

        function conditionToStatementAst(conditionAst, rule) {
            return ['if', conditionAst, ['return', ruleToExpressionAst(rule)], null];
        }

        var statementAsts = [];
        if (this.ruleByValue['x.0'] || this.ruleByValue['x.x']) {
            // var isFractional = n !== Math.floor(n);
            statementAsts.push(['var', [['isFractional', ['binary', '!==', ['name', 'n'], ['call', ['dot', ['name', 'Math'], 'floor'], [['name', 'n']]]]]]]);
        }
        if (this.ruleByValue['x.0']) {
            statementAsts.push(conditionToStatementAst(['name', 'isFractional'], this.ruleByValue['x.0']));
        }
        if (this.ruleByValue['-x']) {
            statementAsts.push(conditionToStatementAst(['binary', '<', ['name', 'n'], ['num', 0]], this.ruleByValue['-x']));
        }
        if (this.ruleByValue['x.x']) {
            statementAsts.push(conditionToStatementAst(['binary', '&&', ['name', 'isFractional'], ['binary', '>', ['name', 'n'], ['num', 1]]], this.ruleByValue['x.x']));
        }
        if (this.ruleByValue['0.x']) {
            statementAsts.push(conditionToStatementAst(['binary', '&&', ['binary', '>', ['name', 'n'], ['num', 0]], ['binary', '<', ['name', 'n'], ['num', 1]]], this.ruleByValue['0.x']));
        }

        Object.keys(this.ruleByValue).filter(function (value) {
            return /^\d+$/.test(value);
        }).map(function (value) {
            return parseInt(value, 10);
        }).sort(function (a, b) {
            return b - a;
        }).forEach(function (numericalValue) {
            statementAsts.push(conditionToStatementAst(['binary', '>=', ['name', 'n'], ['num', numericalValue]], this.ruleByValue[numericalValue]));
        }, this);

        return {functionAst: ['function', null, ['n'], statementAsts], dependencies: Object.keys(isSeenByRuleSetType)};
    }
};

module.exports = CldrRbnfRuleSet;

},{"underscore":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/underscore/underscore.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/cldr.js":[function(require,module,exports){
(function (process,__dirname){
var Path = require('path'),
    fs = require('fs'),
    _ = require('underscore'),
    passError = require('passerror'),
    memoizeAsync = require('./memoizeAsync'),
    dom = require('xmldom').DOMParser,
    xpath = require('xpath'),
    seq = require('seq'),
    normalizeLocaleId = require('./normalizeLocaleId'),
    normalizeProperty = require('./normalizeProperty'),
    convertObjectsWithIntegerKeysToArrays = require('./convertObjectsWithIntegerKeysToArrays'),
    CldrPluralRuleSet = require('./CldrPluralRuleSet'),
    CldrRbnfRuleSet = require('./CldrRbnfRuleSet'),
    uglifyJs = require('uglify-js'),
    unicoderegexp = require('unicoderegexp');

function normalizeXPathQuery(xpathQuery) {
    var xpathQueryFragments = xpathQuery.split('/');
    for (var i = 0 ; i < xpathQueryFragments.length ; i += 1) {
        if (i > 0 && xpathQueryFragments[i] === '..' && xpathQueryFragments[i - 1] !== '..') {
            xpathQueryFragments.splice(i - 1, 2);
            i -= 2;
        }
    }
    return xpathQueryFragments.join('/');
}

function expandLocaleIdToPrioritizedList(localeId) {
    localeId = normalizeLocaleId(localeId);
    if (!localeId) {
        return [];
    }
    var localeIds = [localeId];
    while (/_[^_]+$/.test(localeId)) {
        localeId = localeId.replace(/_[^_]+$/, '');
        localeIds.push(localeId);
    }
    return localeIds;
}

function Cldr(cldrPath) {
    // Support instantiation without the 'new' operator:
    if (!(this instanceof Cldr)) {
        return new Cldr(cldrPath);
    }
    this.cldrPath = cldrPath;
    this.documentByFileName = {};
    this.memoizerByFileName = {};
}

Cldr.prototype = {
    get fileNamesByTypeAndNormalizedLocaleId() {
        if (!this._fileNamesByTypeAndNormalizedLocaleId) {
            this._fileNamesByTypeAndNormalizedLocaleId = {};
            ['main', 'rbnf'].forEach(function (type) {
                this._fileNamesByTypeAndNormalizedLocaleId[type] = {};
                var fileNames;
                try {
                    fileNames = fs.readdirSync(Path.resolve(this.cldrPath, "common", type));
                } catch (e) {
                    if (e.code === 'ENOENT') {
                        // Directory doesn't exist, just pretend it's empty.
                        return;
                    }
                }
                fileNames.forEach(function (fileName) {
                    var matchFileName = fileName.match(/^(.*)\.xml$/);
                    if (matchFileName) {
                        this._fileNamesByTypeAndNormalizedLocaleId[type][normalizeLocaleId(matchFileName[1])] =
                            Path.resolve(this.cldrPath, "common", type, fileName);
                    }
                }, this);
            }, this);
        }
        return this._fileNamesByTypeAndNormalizedLocaleId;
    },

    get localeIds() {
        if (!this._localeIds) {
            this._localeIds = Object.keys(this.fileNamesByTypeAndNormalizedLocaleId.main);
        }
        return this._localeIds;
    },

    get calendarIds() {
        if (!this._calendarIds) {
            this._calendarIds = [];
            xpath.select('/ldmlBCP47/keyword/key[@name="ca"]/type', this.getDocument(Path.resolve(this.cldrPath, 'common', 'bcp47', 'calendar.xml'))).forEach(function (keyNode) {
                var calendarId = keyNode.getAttribute('name');
                if (calendarId === 'gregory') {
                    calendarId = 'gregorian';
                }
                this._calendarIds.push(calendarId);
            }, this);
        }
        return this._calendarIds;
    },

    get numberSystemIds() {
        if (!this._numberSystemIds) {
            this._numberSystemIds = [];
            xpath.select('/ldmlBCP47/keyword/key[@name="nu"]/type', this.getDocument(Path.resolve(this.cldrPath, 'common', 'bcp47', 'number.xml'))).forEach(function (keyNode) {
                this._numberSystemIds.push(keyNode.getAttribute('name'));
            }, this);
        }
        return this._numberSystemIds;
    },

    // Works both async and sync (omit cb):
    getDocument: function (fileName, cb) {
        var that = this;
        if (that.documentByFileName[fileName]) {
            if (cb) {
                process.nextTick(function () {
                    cb(null, that.documentByFileName[fileName]);
                });
            } else {
                return that.documentByFileName[fileName];
            }
        } else {
            if (cb) {
                // Make sure not to load file more than once if it's being loaded when getDocument is called for the second time:
                that.memoizerByFileName[fileName] = that.memoizerByFileName[fileName] || memoizeAsync(function (cb) {
                    fs.readFile(fileName, 'utf-8', passError(cb, function (xmlString) {
                        var document = new dom().parseFromString(xmlString);
                        that.documentByFileName[fileName] = document;
                        cb(null, document);
                    }));
                });
                that.memoizerByFileName[fileName](cb);
            } else {
                return that.documentByFileName[fileName] = new dom().parseFromString(fs.readFileSync(fileName, 'utf-8'));
            }
        }
    },

    getPrioritizedDocumentsForLocale: function (localeId, type) {
        var that = this;
        return expandLocaleIdToPrioritizedList(localeId).concat('root').map(function (subLocaleId) {
            return that.fileNamesByTypeAndNormalizedLocaleId[type][normalizeLocaleId(subLocaleId)];
        }).filter(function (fileName) {
            return !!fileName;
        }).map(function (fileName) {
            return that.getDocument(fileName);
        });
    },

    preload: function (localeIds, cb) {
        var that = this;
        if (typeof localeIds === 'function') {
            cb = localeIds;
            localeIds = that.localeIds;
        }
        localeIds = (Array.isArray(localeIds) ? localeIds : [localeIds]).map(normalizeLocaleId);
        var neededLocaleById = {root: true};
        localeIds.forEach(function (localeId) {
            expandLocaleIdToPrioritizedList(localeId).forEach(function (subLocaleId) {
                neededLocaleById[subLocaleId] = true;
            });
        });
        var fileNames = [
            Path.resolve(that.cldrPath, 'common', 'supplemental', 'plurals.xml'),
            Path.resolve(that.cldrPath, 'common', 'supplemental', 'numberingSystems.xml')
        ];
        Object.keys(neededLocaleById).forEach(function (localeId) {
            ['main', 'rbnf'].forEach(function (type) {
                var fileName = that.fileNamesByTypeAndNormalizedLocaleId[type][localeId];
                if (fileName) {
                    fileNames.push(fileName);
                }
            });
        });
        seq(fileNames)
            .parEach(20, function (fileName) {
                that.getDocument(fileName, this);
            })
            .seq(function () {
                cb();
            })
            .catch(cb);
    },

    createFinder: function (prioritizedDocuments) {
        return function finder(xpathQuery) {
            var prioritizedResults = [];
            prioritizedDocuments.forEach(function (document, i) {
                var resultsForLocaleDocument = xpath.select(xpathQuery, document);
                if (resultsForLocaleDocument.length === 0 && i === (prioritizedDocuments.length - 1)) {
                    // We're in root and there were no results, look for alias elements in path:
                    var queryFragments = xpathQuery.split('/'),
                        poppedQueryFragments = [];
                    while (queryFragments.length > 1) {
                        var aliasNodes = xpath.select(queryFragments.join('/') + '/alias', document);
                        if (aliasNodes.length > 0) {
                            var aliasSpecifiedQuery = normalizeXPathQuery(queryFragments.join('/') + '/' + aliasNodes[0].getAttribute('path') + '/' + poppedQueryFragments.join('/'));
                            Array.prototype.push.apply(prioritizedResults, finder(aliasSpecifiedQuery));
                            break;
                        }
                        poppedQueryFragments.unshift(queryFragments.pop());
                    }
                } else {
                    Array.prototype.push.apply(prioritizedResults, resultsForLocaleDocument);
                }
            });
            return prioritizedResults;
        };
    },

    extractLocaleDisplayPattern: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            localeDisplayPattern = {};
        finder("/ldml/localeDisplayNames/localeDisplayPattern/*").forEach(function (node) {
            localeDisplayPattern[node.nodeName] = node.textContent;
        });
        return localeDisplayPattern;
    },

    extractLanguageDisplayNames: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            languageDisplayNames = {};
        finder('/ldml/localeDisplayNames/languages/language').forEach(function (node) {
            var id = normalizeLocaleId(node.getAttribute('type'));
            languageDisplayNames[id] = languageDisplayNames[id] || node.textContent;
        });
        return languageDisplayNames;
    },

    extractTimeZoneDisplayNames: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            timeZoneDisplayNames = {};
        finder("/ldml/dates/timeZoneNames/zone").forEach(function (zoneNode) {
            var timeZoneId = zoneNode.getAttribute('type'),
                exemplarCityNodes = xpath.select("exemplarCity", zoneNode),
                tzNameLocale;
            if (exemplarCityNodes.length > 0) {
                tzNameLocale = exemplarCityNodes[0].textContent;
            } else {
                var genericDisplayNameNodes = xpath.select("long/generic", zoneNode);
                if (genericDisplayNameNodes.length > 0) {
                    tzNameLocale = genericDisplayNameNodes[0].textContent;
                } else {
                    var longDisplayNameNodes = xpath.select("long/standard", zoneNode);
                    if (longDisplayNameNodes.length > 0) {
                        tzNameLocale = longDisplayNameNodes[0].textContent;
                    }
                }
            }
            if (tzNameLocale) {
                timeZoneDisplayNames[timeZoneId] = timeZoneDisplayNames[timeZoneId] || tzNameLocale;
            }
        });
        return timeZoneDisplayNames;
    },

    extractTimeZoneFormats: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            timeZoneFormats = {};
        ['hourFormat', 'gmtFormat', 'gmtZeroFormat', 'regionFormat', 'fallbackFormat', 'fallbackRegionFormat'].forEach(function (tagName) {
            finder("/ldml/dates/timeZoneNames/" + tagName).forEach(function (node) {
                var formatName = node.nodeName.replace(/Format$/, ''),
                    value = node.textContent;
                if (formatName === 'hour') {
                    value = value.split(';');
                }
                timeZoneFormats[formatName] = timeZoneFormats[formatName] || value;
            });
        });
        finder("/ldml/dates/timeZoneNames/regionFormat[@type]").forEach(function (node) {
            var type = node.getAttribute('type');
            timeZoneFormats.regions = timeZoneFormats.regions || {};
            timeZoneFormats.regions[type] = timeZoneFormats.regions[type] || node.textContent;
        });
        return timeZoneFormats;
    },

    extractTerritoryDisplayNames: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            territoryDisplayNames = {};
        finder("/ldml/localeDisplayNames/territories/territory").forEach(function (territoryNode) {
            var territoryId = territoryNode.getAttribute('type');
            territoryDisplayNames[territoryId] = territoryDisplayNames[territoryId] || territoryNode.textContent;
        });
        return territoryDisplayNames;
    },

    extractCurrencyInfoById: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            currencyDisplayNameByCurrencyId = {},
            currencyDisplayNameByCurrencyIdAndCount = {},
            currencySymbolByCurrencyId = {};

        finder("/ldml/numbers/currencies/currency/displayName").forEach(function (displayNameNode) {
            var currencyId = displayNameNode.parentNode.getAttribute('type'),
                countAttribute = displayNameNode.getAttribute('count');
            if (countAttribute) {
                currencyDisplayNameByCurrencyIdAndCount[currencyId] = currencyDisplayNameByCurrencyIdAndCount[currencyId] || {};
                currencyDisplayNameByCurrencyIdAndCount[currencyId][countAttribute] = displayNameNode.textContent;
            } else {
                currencyDisplayNameByCurrencyId[currencyId] = currencyDisplayNameByCurrencyId[currencyId] || displayNameNode.textContent;
            }
        });

        finder("/ldml/numbers/currencies/currency/symbol").forEach(function (symbolNode) {
            var currencyId = symbolNode.parentNode.getAttribute('type');
            currencySymbolByCurrencyId[currencyId] = currencySymbolByCurrencyId[currencyId] || symbolNode.textContent;
        });

        var currencyInfoById = {};
        Object.keys(currencyDisplayNameByCurrencyId).forEach(function (currencyId) {
            currencyInfoById[currencyId] = _.extend({
                displayName: currencyDisplayNameByCurrencyId[currencyId],
                symbol: currencySymbolByCurrencyId[currencyId]
            }, currencyDisplayNameByCurrencyIdAndCount[currencyId]);
        });
        return currencyInfoById;
    },

    extractScriptDisplayNames: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            scriptDisplayNames = {};
        finder("/ldml/localeDisplayNames/scripts/script").forEach(function (scriptNode) {
            var id = scriptNode.getAttribute('type');
            scriptDisplayNames[id] = scriptDisplayNames[id] || scriptNode.textContent;
        });
        return scriptDisplayNames;
    },

    extractKeyTypes: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            keyTypes = {};
        finder('/ldml/localeDisplayNames/keys/key').forEach(function (keyNode) {
            var type = keyNode.getAttribute('type');
            keyTypes[type] = { displayName: keyNode.textContent };
        });
        finder('/ldml/localeDisplayNames/types/type').forEach(function (typeNode) {
            var key = typeNode.getAttribute('key'),
                type = normalizeProperty(typeNode.getAttribute('type'));
            keyTypes[key] = keyTypes[key] || {};
            keyTypes[key].types = keyTypes[key].types || {};
            keyTypes[key].types[type] = typeNode.textContent;
        });
        return keyTypes;
    },

    extractTransformNames: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            transformNames = {};
        finder("/ldml/localeDisplayNames/transformNames/transformName").forEach(function (transformNameNode) {
            var id = transformNameNode.getAttribute('type');
            transformNames[id] = transformNames[id] || transformNameNode.textContent;
        });
        return transformNames;
    },

    extractMeasurementSystemNames: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            measurementSystemNames = {};
        finder("/ldml/localeDisplayNames/measurementSystemNames/measurementSystemName").forEach(function (measurementSystemNameNode) {
            var id = measurementSystemNameNode.getAttribute('type');
            measurementSystemNames[id] = measurementSystemNames[id] || measurementSystemNameNode.textContent;
        });
        return measurementSystemNames;
    },

    extractCodePatterns: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            codePatterns = {};
        finder("/ldml/localeDisplayNames/codePatterns/codePattern").forEach(function (codePatternNode) {
            var id = codePatternNode.getAttribute('type');
            codePatterns[id] = codePatterns[id] || codePatternNode.textContent;
        });
        return codePatterns;
    },

    // Calendar extraction methods:

    extractEraNames: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            eraNames;
        ['eraNames', 'eraAbbr'].forEach(function (eraType) {
            var typeInOutput = {eraNames: 'wide', eraAbbr: 'abbreviated'}[eraType];
            finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/eras/" + eraType + "/era").forEach(function (eraNode) {
                var type = parseInt(eraNode.getAttribute('type'), 10);
                eraNames = eraNames || {};
                eraNames[typeInOutput] = eraNames[typeInOutput] || {};
                eraNames[typeInOutput][type] = eraNames[typeInOutput][type] || eraNode.textContent;
            });
        });
        return convertObjectsWithIntegerKeysToArrays(eraNames);
    },

    extractQuarterNames: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            quarterNames;
        ['format', 'stand-alone'].forEach(function (quarterContext) {
            var quarterContextCamelCase = normalizeProperty(quarterContext); // stand-alone => standAlone
            ['abbreviated', 'narrow', 'wide'].forEach(function (quarterWidth) {
                finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/quarters/quarterContext[@type='" + quarterContext + "']/quarterWidth[@type='" + quarterWidth + "']/quarter").forEach(function (quarterNode) {
                    var quarterNo = parseInt(quarterNode.getAttribute('type'), 10) - 1;

                    quarterNames = quarterNames || {};
                    quarterNames[quarterContextCamelCase] = quarterNames[quarterContextCamelCase] || {};
                    quarterNames[quarterContextCamelCase][quarterWidth] = quarterNames[quarterContextCamelCase][quarterWidth] || {};
                    quarterNames[quarterContextCamelCase][quarterWidth][quarterNo] = quarterNames[quarterContextCamelCase][quarterWidth][quarterNo] || quarterNode.textContent;
                });
            });
        });
        return convertObjectsWithIntegerKeysToArrays(quarterNames);
    },

    extractDayPeriods: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            dayPeriods;
        ['format', 'stand-alone'].forEach(function (dayPeriodContext) {
            var dayPeriodContextCamelCase = normalizeProperty(dayPeriodContext); // stand-alone => standAlone
            ['abbreviated', 'narrow', 'wide', 'short'].forEach(function (dayPeriodWidth) {
                finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/dayPeriods/dayPeriodContext[@type='" + dayPeriodContext + "']/dayPeriodWidth[@type='" + dayPeriodWidth + "']/dayPeriod").forEach(function (dayPeriodNode) {
                    var type = dayPeriodNode.getAttribute('type');

                    dayPeriods = dayPeriods || {};
                    dayPeriods[dayPeriodContextCamelCase] = dayPeriods[dayPeriodContextCamelCase] || {};
                    dayPeriods[dayPeriodContextCamelCase][dayPeriodWidth] =
                        dayPeriods[dayPeriodContextCamelCase][dayPeriodWidth] || {};
                    dayPeriods[dayPeriodContextCamelCase][dayPeriodWidth][type] =
                        dayPeriods[dayPeriodContextCamelCase][dayPeriodWidth][type] || dayPeriodNode.textContent;
                });
            });
        });
        return dayPeriods;
    },

    extractCyclicNames: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            cyclicNames;
        ['dayParts', 'days', 'months', 'years', 'zodiacs'].forEach(function (cyclicNameSet) {
            ['format'].forEach(function (cyclicNameContext) {
                ['abbreviated', 'narrow', 'wide'].forEach(function (cyclicNameWidth) {
                    finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/cyclicNameSets/cyclicNameSet[@type='" + cyclicNameSet + "']/cyclicNameContext[@type='" + cyclicNameContext + "']/cyclicNameWidth[@type='" + cyclicNameWidth + "']/cyclicName").forEach(function (cyclicNameNode) {
                        var type = cyclicNameNode.getAttribute('type');
                        cyclicNames = cyclicNames || {};
                        cyclicNames[cyclicNameSet] = cyclicNames[cyclicNameSet] || {};
                        cyclicNames[cyclicNameSet][cyclicNameContext] = cyclicNames[cyclicNameSet][cyclicNameContext] || {};
                        cyclicNames[cyclicNameSet][cyclicNameContext][cyclicNameWidth] = cyclicNames[cyclicNameSet][cyclicNameContext][cyclicNameWidth] || {};
                        cyclicNames[cyclicNameSet][cyclicNameContext][cyclicNameWidth][type] = cyclicNames[cyclicNameSet][cyclicNameContext][cyclicNameWidth][type] || cyclicNameNode.textContent;
                    });
                });
            });
        });
        return convertObjectsWithIntegerKeysToArrays(cyclicNames);
    },

    extractMonthNames: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            monthNames;
        ['format', 'stand-alone'].forEach(function (monthContext) {
            var monthContextCamelCase = normalizeProperty(monthContext); // stand-alone => standAlone
            ['abbreviated', 'narrow', 'wide'].forEach(function (monthWidth) {
                finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/months/monthContext[@type='" + monthContext + "']/monthWidth[@type='" + monthWidth + "']/month").forEach(function (monthNode) {
                    var monthNo = parseInt(monthNode.getAttribute('type'), 10) - 1;
                    monthNames = monthNames || {};
                    monthNames[monthContextCamelCase] = monthNames[monthContextCamelCase] || {};
                    monthNames[monthContextCamelCase][monthWidth] = monthNames[monthContextCamelCase][monthWidth] || {};
                    monthNames[monthContextCamelCase][monthWidth][monthNo] =
                        monthNames[monthContextCamelCase][monthWidth][monthNo] || monthNode.textContent;
                });
            });
        });
        return convertObjectsWithIntegerKeysToArrays(monthNames);
    },

    extractMonthPatterns: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            monthPatterns;
        ['format', 'numeric', 'stand-alone'].forEach(function (monthPatternContext) {
            var monthPatternContextCamelCase = normalizeProperty(monthPatternContext); // stand-alone => standAlone
            ['abbreviated', 'narrow', 'wide', 'all'].forEach(function (monthPatternWidth) {
                finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/monthPatterns/monthPatternContext[@type='" + monthPatternContext + "']/monthPatternWidth[@type='" + monthPatternWidth + "']/monthPattern").forEach(function (monthPatternNode) {
                    var type = monthPatternNode.getAttribute('type');
                    monthPatterns = monthPatterns || {};
                    monthPatterns[monthPatternContextCamelCase] = monthPatterns[monthPatternContextCamelCase] || {};
                    monthPatterns[monthPatternContextCamelCase][monthPatternWidth] =
                        monthPatterns[monthPatternContextCamelCase][monthPatternWidth] || {};
                    monthPatterns[monthPatternContextCamelCase][monthPatternWidth][type] =
                        monthPatterns[monthPatternContextCamelCase][monthPatternWidth][type] || monthPatternNode.textContent;
                });
            });
        });
        return monthPatterns;
    },

    extractDayNames: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            dayNoByCldrId = {sun: 0, mon: 1, tue: 2, wed: 3, thu: 4, fri: 5, sat: 6},
            dayNames;
        ['format', 'numeric', 'stand-alone'].forEach(function (dayContext) {
            var dayContextCamelCase = normalizeProperty(dayContext); // stand-alone => standAlone
            ['abbreviated', 'narrow', 'wide', 'short'].forEach(function (dayWidth) {
                finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/days/dayContext[@type='" + dayContext + "']/dayWidth[@type='" + dayWidth + "']/day").forEach(function (dayNode) {
                    var dayNo = dayNoByCldrId[dayNode.getAttribute('type')];
                    dayNames = dayNames || {};
                    dayNames[dayContextCamelCase] = dayNames[dayContextCamelCase] || {};
                    dayNames[dayContextCamelCase][dayWidth] = dayNames[dayContextCamelCase][dayWidth] || {};
                    dayNames[dayContextCamelCase][dayWidth][dayNo] = dayNames[dayContextCamelCase][dayWidth][dayNo] || dayNode.textContent;
                });
            });
        });
        return convertObjectsWithIntegerKeysToArrays(dayNames);
    },

    extractFields: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            fields;
        finder("/ldml/dates/fields/field/displayName").forEach(function (fieldDisplayNameNode) {
            var fieldName = fieldDisplayNameNode.parentNode.getAttribute('type');
            fields = fields || {};
            fields[fieldName] = fields[fieldName] || {};
            fields[fieldName].displayName = fields[fieldName].displayName || fieldDisplayNameNode.textContent;
        });

        finder("/ldml/dates/fields/field/relative").forEach(function (fieldRelativeNode) {
            var fieldName = fieldRelativeNode.parentNode.getAttribute('type'),
                type = fieldRelativeNode.getAttribute('type');
            fields = fields || {};
            fields[fieldName] = fields[fieldName] || {};
            fields[fieldName].relative = fields[fieldName].relative || {};
            fields[fieldName].relative[type] = fields[fieldName].relative[type] || fieldRelativeNode.textContent;
        });

        finder("/ldml/dates/fields/field/relativeTime/relativeTimePattern").forEach(function (relativeTimePatternNode) {
            var relativeTimeNode = relativeTimePatternNode.parentNode,
                fieldName = relativeTimeNode.parentNode.getAttribute('type'),
                type = relativeTimeNode.getAttribute('type'),
                count = relativeTimePatternNode.getAttribute('count');
            fields = fields || {};
            fields[fieldName] = fields[fieldName] || {};
            fields[fieldName].relativeTime = fields[fieldName].relativeTime || {};
            fields[fieldName].relativeTime[type] = fields[fieldName].relativeTime[type] || {};
            fields[fieldName].relativeTime[type][count] = fields[fieldName].relativeTime[type][count] || relativeTimePatternNode.textContent
        });
        return fields;
    },

    extractDateTimePatterns: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            dateTimePatterns;
        finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/dateTimeFormats/dateTimeFormatLength/dateTimeFormat").forEach(function (dateTimeFormatNode) {
            var dateTimeFormatLengthType = dateTimeFormatNode.parentNode.getAttribute('type'),
                patternNodes = xpath.select("pattern", dateTimeFormatNode);
            if (patternNodes.length !== 1) {
                throw new Error('Expected exactly one pattern in dateTimeFormatNode');
            }
            dateTimePatterns = dateTimePatterns || {};
            dateTimePatterns[dateTimeFormatLengthType] = dateTimePatterns[dateTimeFormatLengthType] || patternNodes[0].textContent;
        });
        return dateTimePatterns;
    },

    extractDateOrTimeFormats: function (localeId, calendarId, dateOrTime) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            formats;
        finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/" + dateOrTime + "Formats/" + dateOrTime + "FormatLength/" + dateOrTime + "Format/*").forEach(function (patternNode) {
            var type = patternNode.parentNode.parentNode.getAttribute('type');
            formats = formats || {};
            formats[type] = formats[type] || patternNode.textContent;
        });
        return formats;
    },

    extractDateFormats: function (localeId, calendarId) {
        return this.extractDateOrTimeFormats(localeId, calendarId, 'date');
    },

    extractTimeFormats: function (localeId, calendarId) {
        return this.extractDateOrTimeFormats(localeId, calendarId, 'time');
    },

    extractDateFormatItems: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            dateFormatItems;
        finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/dateTimeFormats/availableFormats/dateFormatItem").forEach(function (dateFormatItemNode) {
            var id = dateFormatItemNode.getAttribute('id');
            dateFormatItems = dateFormatItems || {};
            dateFormatItems[id] = dateFormatItems[id] || dateFormatItemNode.textContent;
        });
        return dateFormatItems;
    },

    extractDateIntervalFormats: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            dateIntervalFormats;
        finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/dateTimeFormats/intervalFormats/intervalFormatItem").forEach(function (intervalFormatItemNode) {
            var dateIntervalFormat = {};
            for (var i = 0 ; i < intervalFormatItemNode.childNodes.length ; i += 1) {
                var greatestDifferenceNode = intervalFormatItemNode.childNodes[i];
                if (greatestDifferenceNode.nodeType !== 1) {
                    // Skip whitespace node
                    continue;
                }
                var greatestDifferenceIdAttribute = greatestDifferenceNode.getAttribute('id');
                var greatestDifferenceId = greatestDifferenceIdAttribute;
                dateIntervalFormat[greatestDifferenceId] = dateIntervalFormat[greatestDifferenceId] || greatestDifferenceNode.textContent;
            }
            var id = intervalFormatItemNode.getAttribute('id');
            dateIntervalFormats = dateIntervalFormats || {};
            dateIntervalFormats[id] = dateIntervalFormats[id] || dateIntervalFormat;
        });
        return dateIntervalFormats;
    },

    extractDateIntervalFallbackFormat: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            dateIntervalFallbackFormat;
        finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/dateTimeFormats/intervalFormats/intervalFormatFallback").forEach(function (intervalFormatFallbackNode) {
            dateIntervalFallbackFormat = dateIntervalFallbackFormat || intervalFormatFallbackNode.textContent;
        });
        return dateIntervalFallbackFormat;
    },

    // Number extraction code:

    extractNumberSymbols: function (localeId, numberSystemId) {
        numberSystemId = numberSystemId || 'latn';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            numberSymbols;
        finder("/ldml/numbers/symbols[@numberSystem = '" + numberSystemId + "']/*[name() != 'alias']").concat(finder("/ldml/numbers/symbols/*[name() != 'alias']")).forEach(function (numberSymbolNode) {
            var symbolId = numberSymbolNode.nodeName;
            numberSymbols = numberSymbols || {};
            numberSymbols[symbolId] = numberSymbols[symbolId] || numberSymbolNode.textContent;
        });
        return numberSymbols;
    },

    extractNumberFormats: function (localeId, numberSystemId) {
        numberSystemId = numberSystemId || 'latn';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            numberFormats;
        ['scientific', 'decimal', 'currency', 'percent'].forEach(function (formatType) {
            ['full', 'long', 'medium', 'short'].forEach(function (length) {
                finder("/ldml/numbers/" + formatType + "Formats[@numberSystem = '" + numberSystemId + "']/" + formatType + "FormatLength[@type='" + length + "']/" + formatType + "Format/pattern").forEach(function (patternNode) {
                    var type = patternNode.getAttribute('type'),
                        count = patternNode.getAttribute('count');
                    numberFormats = numberFormats || {};
                    numberFormats[formatType] = numberFormats[formatType] || {};
                    numberFormats[formatType][length] = numberFormats[formatType][length] || {};
                    numberFormats[formatType][length][type] = numberFormats[formatType][length][type] || {};
                    numberFormats[formatType][length][type][count] = numberFormats[formatType][length][type][count] || patternNode.textContent;
                });
            });
            finder("/ldml/numbers/" + formatType + "Formats[@numberSystem = '" + numberSystemId + "']/" + formatType + "FormatLength[not(@type)]/" + formatType + "Format/pattern").forEach(function (patternNode) {
                numberFormats = numberFormats || {};
                numberFormats[formatType] = numberFormats[formatType] || {};
                numberFormats[formatType].default = numberFormats[formatType].default || patternNode.textContent;
            });
            finder("/ldml/numbers/" + formatType + "Formats[@numberSystem = '" + numberSystemId + "']/unitPattern").forEach(function (unitPatternNode) {
                var count = unitPatternNode.getAttribute('count');
                numberFormats = numberFormats || {};
                numberFormats[formatType] = numberFormats[formatType] || {};
                numberFormats[formatType][count] = numberFormats[formatType][count] || unitPatternNode.textContent;
            });
        });

        finder("/ldml/numbers/currencyFormats[@numberSystem = '" + numberSystemId + "']/currencySpacing").forEach(function (currencySpacingNode) {
            numberFormats = numberFormats || {};
            numberFormats.currency = numberFormats.currency || {};
            numberFormats.currency.currencySpacing = numberFormats.currency.currencySpacing || {};

            ['before', 'after'].forEach(function (place) {
                var placeData = numberFormats.currency.currencySpacing[place + 'Currency'] = numberFormats.currency.currencySpacing[place + 'Currency'] || {};

                ['currencyMatch', 'surroundingMatch', 'insertBetween'].forEach(function (spacingPropertyName) {
                    var match = xpath.select(place + "Currency/" + spacingPropertyName, currencySpacingNode);
                    if (match.length > 0) {
                        numberFormats.currency.currencySpacing[place + 'Currency'][spacingPropertyName] = match[0].textContent;
                    }
                });

                ['currencyMatch', 'surroundingMatch'].forEach(function (spacingPropertyName) {
                    if (placeData[spacingPropertyName]) {
                        placeData[spacingPropertyName] = unicoderegexp.expandCldrUnicodeSetIdToCharacterClass(placeData[spacingPropertyName]);
                    }
                });
            });
        });

        return numberFormats;
    },

    extractDefaultNumberSystemId: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            defaultNumberSystemId;
        finder('/ldml/numbers/defaultNumberingSystem').forEach(function (defaultNumberingSystemNode) {
            defaultNumberSystemId = defaultNumberSystemId || defaultNumberingSystemNode.textContent;
        });
        return defaultNumberSystemId;
    },

    extractUnitPatterns: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            unitPatterns = {};
        finder("/ldml/units/unitLength/unit/unitPattern").forEach(function (unitPatternNode) {
            var unitNode = unitPatternNode.parentNode,
                unitLength = unitNode.parentNode.getAttribute('type'),
                unitId = normalizeProperty(unitNode.getAttribute('type'));
            unitPatterns[unitLength] = unitPatterns[unitLength] || {};
            unitPatterns[unitLength].unit = unitPatterns[unitLength].unit || {};
            unitPatterns[unitLength].unit[unitId] = unitPatterns[unitLength].unit[unitId] || {};
            var count = unitPatternNode.getAttribute('count');
            unitPatterns[unitLength].unit[unitId][count] = unitPatterns[unitLength].unit[unitId][count] || unitPatternNode.textContent;
        });
        finder("/ldml/units/unitLength/compoundUnit/compoundUnitPattern").forEach(function (compoundUnitPatternNode) {
            var compoundUnitNode = compoundUnitPatternNode.parentNode,
                unitLength = compoundUnitNode.parentNode.getAttribute('type'),
                compoundUnitId = compoundUnitNode.getAttribute('type');

            unitPatterns[unitLength].compoundUnit = unitPatterns[unitLength].compoundUnit || {};
            unitPatterns[unitLength].compoundUnit[compoundUnitId] = compoundUnitPatternNode.textContent;
        });
        return unitPatterns;
    },

    extractDelimiters: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            delimiters = {};
        finder("/ldml/delimiters/*").forEach(function (delimiterNode) {
            var type = delimiterNode.nodeName;
            delimiters[type] = delimiters[type] || delimiterNode.textContent;
        });
        return delimiters;
    },

    extractListPatterns: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            listPatterns = {};
        finder("/ldml/listPatterns/listPattern/listPatternPart").forEach(function (listPatternPartNode) {
            var listPatternTypeAttribute = listPatternPartNode.parentNode.getAttribute('type'),
                type = listPatternTypeAttribute ? normalizeProperty(listPatternTypeAttribute) : 'default',
                part = listPatternPartNode.getAttribute('type');
            listPatterns[type] = listPatterns[type] || {};
            listPatterns[type][part] = listPatterns[type][part] || listPatternPartNode.textContent;
        });
        return listPatterns;
    },

    extractCharacters: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            characters = {
                exemplar: {},
                ellipsis: {}
            };
        finder("/ldml/characters/exemplarCharacters").forEach(function (exemplarCharactersNode) {
            var typeAttr = exemplarCharactersNode.getAttribute('type'),
                type = typeAttr || 'default';
            characters.exemplar[type] = characters.exemplar[type] || exemplarCharactersNode.textContent.replace(/^\[|\]$/g, '').split(" ");
        });
        finder("/ldml/characters/ellipsis").forEach(function (ellipsisNode) {
            var type = ellipsisNode.getAttribute('type');
            characters.ellipsis[type] = characters.ellipsis[type] || ellipsisNode.textContent;
        });
        finder("/ldml/characters/moreInformation").forEach(function (moreInformationNode) {
            characters.moreInformation = characters.moreInformation || moreInformationNode.textContent;
        });
        return characters;
    },

    extractPluralRuleFunction: function (localeId) {
        var that = this,
            document = that.getDocument(Path.resolve(that.cldrPath, 'common', 'supplemental', 'plurals.xml')),
            subLocaleIds = expandLocaleIdToPrioritizedList(localeId),
            statementAsts = [];
        for (var i = 0 ; i < subLocaleIds.length ; i += 1) {
            var subLocaleId = subLocaleIds[i],
                matchLocalesXPathExpr =
                    "@locales = '" + subLocaleId + "' or " +
                    "starts-with(@locales, '" + subLocaleId + "') or " +
                    "contains(@locales, ' " + subLocaleId + " ') or " +
                    "substring(@locales, string-length(@locales) - string-length(' " + subLocaleId + "') + 1) = ' " + subLocaleId + "'",
                pluralRulesNodes = xpath.select("/supplementalData/plurals/pluralRules[" + matchLocalesXPathExpr + "]", document),
                cldrPluralRuleSet = new CldrPluralRuleSet();
            if (pluralRulesNodes.length > 0) {
                xpath.select("pluralRule", pluralRulesNodes[0]).forEach(function (pluralRuleNode) {
                    cldrPluralRuleSet.addRule(pluralRuleNode.textContent, pluralRuleNode.getAttribute('count'));
                });
                statementAsts = cldrPluralRuleSet.toJavaScriptFunctionBodyAst();
                break;
            }
        }
        return new Function("n", uglifyJs.uglify.gen_code(['toplevel', statementAsts]));
    },

    // 'types' is optional, defaults to all available
    extractRbnfFunctionByType: function (localeId, types) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'rbnf')),
            cldrRbnfRuleSetByType = {};
        finder('/ldml/rbnf/rulesetGrouping/ruleset/rbnfrule').forEach(function (rbnfRuleNode) {
            var type = CldrRbnfRuleSet.getSafeRendererName(rbnfRuleNode.parentNode.getAttribute('type')),
                value = rbnfRuleNode.getAttribute('value');
            cldrRbnfRuleSetByType[type] = cldrRbnfRuleSetByType[type] || new CldrRbnfRuleSet({type: type});
            if (!cldrRbnfRuleSetByType[type].ruleByValue[value]) {
                var radixAttribute = rbnfRuleNode.getAttribute('radix');
                cldrRbnfRuleSetByType[type].ruleByValue[value] = {
                    value: value,
                    rbnf: rbnfRuleNode.textContent.replace(/;$/, '').replace(//g, '<').replace(//g, '>'),
                    radix: radixAttribute
                };
            }
        });
        var isAddedByType = {},
            typesToAdd = types ? [].concat(types) : Object.keys(cldrRbnfRuleSetByType),
            rbnfFunctionByType = {
                renderNumber: String // Provide a (bad) default number rendering implementation to avoid #13
            };
        while (typesToAdd.length > 0) {
            var type = typesToAdd.shift();
            if (!(type in isAddedByType)) {
                isAddedByType[type] = true;
                var cldrRbnfRuleSet = cldrRbnfRuleSetByType[type];
                // Some rules aren't available in some locales (such as spellout-cardinal-financial).
                // The easiest thing is just to skip the missing ones here, even though it can produce
                // some broken function sets:
                if (cldrRbnfRuleSet) {
                    var result = cldrRbnfRuleSet.toFunctionAst();

                    rbnfFunctionByType[type] = new Function("n", uglifyJs.uglify.gen_code(['toplevel', result.functionAst[3]]));
                    Array.prototype.push.apply(typesToAdd, result.dependencies);
                }
            }
        }
        return rbnfFunctionByType;
    },

    extractDigitsByNumberSystemId: function () {
        var document = this.getDocument(Path.resolve(this.cldrPath, 'common', 'supplemental', 'numberingSystems.xml')),
            digitsByNumberSystemId = {};

        xpath.select('/supplementalData/numberingSystems/numberingSystem', document).forEach(function (numberingSystemNode) {
            var numberSystemId = numberingSystemNode.getAttribute('id');
            if (numberingSystemNode.getAttribute('type') === 'numeric') {
                digitsByNumberSystemId[numberSystemId] = numberingSystemNode.getAttribute('digits').split(/(?:)/);
            } else {
                // type='algorithmic'
                var rulesAttributeFragments = numberingSystemNode.getAttribute('rules').split('/'),
                    sourceLocaleId = rulesAttributeFragments.length === 3 ? normalizeLocaleId(rulesAttributeFragments[0]) : 'root',
                    ruleType = CldrRbnfRuleSet.getSafeRendererName(rulesAttributeFragments[rulesAttributeFragments.length - 1]);
                digitsByNumberSystemId[numberSystemId] = ruleType; // A string value means "use this rbnf renderer for the digits"
            }
        }, this);
        return digitsByNumberSystemId;
    },

    extractLayout: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            layout = {};
        finder("/ldml/layout/*/*").forEach(function (leafNode) {
            var type = leafNode.nodeName,
                parentType = leafNode.parentNode.nodeName;
            layout[parentType] = layout[parentType] || {};
            layout[parentType][type] = layout[parentType][type] || leafNode.textContent;
        });
        return layout;
    }
};

module.exports = new Cldr(Path.resolve(__dirname, '../3rdparty/cldr/'));
module.exports.load = function (cldrPath) {
    return new Cldr(cldrPath);
};

}).call(this,require('_process'),"/node_modules/cldr/lib")

},{"./CldrPluralRuleSet":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/CldrPluralRuleSet.js","./CldrRbnfRuleSet":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/CldrRbnfRuleSet.js","./convertObjectsWithIntegerKeysToArrays":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/convertObjectsWithIntegerKeysToArrays.js","./memoizeAsync":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/memoizeAsync.js","./normalizeLocaleId":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/normalizeLocaleId.js","./normalizeProperty":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/normalizeProperty.js","_process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js","fs":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/lib/_empty.js","passerror":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/passerror/lib/index.js","path":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/path-browserify/index.js","seq":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/index.js","uglify-js":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/uglify-js.js","underscore":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/underscore/underscore.js","unicoderegexp":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/unicoderegexp/lib/unicodeRegExp.js","xmldom":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xmldom/dom-parser.js","xpath":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xpath/xpath.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/cldrPluralRuleTermFunctionByName.js":[function(require,module,exports){
exports.i = function i(n) {
    return Math.floor(Math.abs(n));
};

exports.v = function v(n) {
    return n.toString().replace(/^[^.]*\.?/, '').length;
};

exports.w = function w(n) {
    return n.toString().replace(/^[^.]*\.?|0+$/g, '').length;
};

exports.f = function f(n) {
    return parseInt(n.toString().replace(/^[^.]*\.?/, ''), 10) || 0;
};

exports.t = function t(n) {
    return parseInt(n.toString().replace(/^[^.]*\.?|0+$/g, ''), 10) || 0;
};

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/convertObjectsWithIntegerKeysToArrays.js":[function(require,module,exports){
// Convert objects with all integer keys starting from 0 to arrays and remove undefined values:
module.exports = function convertObjectsWithIntegerKeysToArrays(obj) {
    if (Array.isArray(obj)) {
        return obj.map(convertObjectsWithIntegerKeysToArrays);
    } else if (typeof obj === 'object' && obj !== null) {
        var keys = Object.keys(obj);
        if (0 in obj || 1 in obj) {
            var firstNumericKeyNumber = 0 in obj ? 0 : 1,
                nextNumericKeyNumber = firstNumericKeyNumber + 1;
            while (nextNumericKeyNumber in obj) {
                nextNumericKeyNumber += 1;
            }
            if (keys.length > 0 && nextNumericKeyNumber === keys.length + firstNumericKeyNumber) {
                var array = [],
                    i;
                for (i = 0 ; i < firstNumericKeyNumber ; i += 1) {
                    array.push(undefined);
                }
                for (i = firstNumericKeyNumber ; i < keys.length ; i += 1) {
                    array.push(convertObjectsWithIntegerKeysToArrays(obj[i]));
                }
                return array;
            }
        }
        var resultObj = {};
        keys.forEach(function (key) {
            if (typeof obj[key] !== 'undefined') {
                resultObj[key] = convertObjectsWithIntegerKeysToArrays(obj[key]);
            }
        });
        return resultObj;
    } else {
        return obj;
    }
};

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/memoizeAsync.js":[function(require,module,exports){
(function (process){
// Create a memoizer for an async function
module.exports = function memoizeAsync(fn) {
    var resultArguments,
        waitingCallbacks;
    return function (cb) {
        var that = this;
        if (resultArguments) {
            process.nextTick(function () {
                cb.apply(this, resultArguments);
            });
        } else {
            if (waitingCallbacks) {
                waitingCallbacks.push(cb);
            } else {
                waitingCallbacks = [cb];
                fn(function () { // ...
                    var resultArguments = arguments;
                    waitingCallbacks.forEach(function (waitingCallback) {
                        waitingCallback.apply(this, resultArguments);
                    });
                    waitingCallbacks = null;
                });
            }
        }
    };
};

}).call(this,require('_process'))

},{"_process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/normalizeLocaleId.js":[function(require,module,exports){
/*
 * Replace - with _ and convert to lower case: en-GB => en_gb
 */
module.exports = function normalizeLocaleId(localeId) {
    return localeId && localeId.replace(/-/g, '_').toLowerCase();
};

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/normalizeProperty.js":[function(require,module,exports){
/*
 * Convert foo-bar attribute values to fooBar JavaScript keys
 */
module.exports = function normalizeProperty(str) {
	return str.replace(/-([a-z])/g, function ($0, ch) {
        return ch.toUpperCase();
    });
};

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/passerror/lib/index.js":[function(require,module,exports){
module.exports = function passError(errorCallback, successCallback) {
    return function (err) { // ...
        if (err) {
            errorCallback(err);
        } else if (successCallback) {
            successCallback.apply(this, [].slice.call(arguments, 1));
        }
    };
};

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/pegjs/lib/peg.js":[function(require,module,exports){
/*
 * PEG.js 0.7.0
 *
 * http://pegjs.majda.cz/
 *
 * Copyright (c) 2010-2012 David Majda
 * Licensend under the MIT license.
 */
var PEG = (function(undefined) {

var PEG = {
  /* PEG.js version (uses semantic versioning). */
  VERSION: "0.7.0",

  /*
   * Generates a parser from a specified grammar and returns it.
   *
   * The grammar must be a string in the format described by the metagramar in
   * the parser.pegjs file.
   *
   * Throws |PEG.parser.SyntaxError| if the grammar contains a syntax error or
   * |PEG.GrammarError| if it contains a semantic error. Note that not all
   * errors are detected during the generation and some may protrude to the
   * generated parser and cause its malfunction.
   */
  buildParser: function(grammar, options) {
    return PEG.compiler.compile(PEG.parser.parse(grammar), options);
  }
};

/* Thrown when the grammar contains an error. */

PEG.GrammarError = function(message) {
  this.name = "PEG.GrammarError";
  this.message = message;
};

PEG.GrammarError.prototype = Error.prototype;

/* Like Python's |range|, but without |step|. */
function range(start, stop) {
  if (stop === undefined) {
    stop = start;
    start = 0;
  }

  var result = new Array(Math.max(0, stop - start));
  for (var i = 0, j = start; j < stop; i++, j++) {
    result[i] = j;
  }
  return result;
}

function find(array, callback) {
  var length = array.length;
  for (var i = 0; i < length; i++) {
    if (callback(array[i])) {
      return array[i];
    }
  }
}

function contains(array, value) {
  /*
   * Stupid IE does not have Array.prototype.indexOf, otherwise this function
   * would be a one-liner.
   */
  var length = array.length;
  for (var i = 0; i < length; i++) {
    if (array[i] === value) {
      return true;
    }
  }
  return false;
}

function each(array, callback) {
  var length = array.length;
  for (var i = 0; i < length; i++) {
    callback(array[i], i);
  }
}

function map(array, callback) {
  var result = [];
  var length = array.length;
  for (var i = 0; i < length; i++) {
    result[i] = callback(array[i], i);
  }
  return result;
}

function pluck(array, key) {
  return map(array, function (e) { return e[key]; });
}

function keys(object) {
  var result = [];
  for (var key in object) {
    result.push(key);
  }
  return result;
}

function values(object) {
  var result = [];
  for (var key in object) {
    result.push(object[key]);
  }
  return result;
}

/*
 * Returns a string padded on the left to a desired length with a character.
 *
 * The code needs to be in sync with the code template in the compilation
 * function for "action" nodes.
 */
function padLeft(input, padding, length) {
  var result = input;

  var padLength = length - input.length;
  for (var i = 0; i < padLength; i++) {
    result = padding + result;
  }

  return result;
}

/*
 * Returns an escape sequence for given character. Uses \x for characters <=
 * 0xFF to save space, \u for the rest.
 *
 * The code needs to be in sync with the code template in the compilation
 * function for "action" nodes.
 */
function escape(ch) {
  var charCode = ch.charCodeAt(0);
  var escapeChar;
  var length;

  if (charCode <= 0xFF) {
    escapeChar = 'x';
    length = 2;
  } else {
    escapeChar = 'u';
    length = 4;
  }

  return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
}

/*
 * Surrounds the string with quotes and escapes characters inside so that the
 * result is a valid JavaScript string.
 *
 * The code needs to be in sync with the code template in the compilation
 * function for "action" nodes.
 */
function quote(s) {
  /*
   * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a string
   * literal except for the closing quote character, backslash, carriage return,
   * line separator, paragraph separator, and line feed. Any character may
   * appear in the form of an escape sequence.
   *
   * For portability, we also escape escape all control and non-ASCII
   * characters. Note that "\0" and "\v" escape sequences are not used because
   * JSHint does not like the first and IE the second.
   */
  return '"' + s
    .replace(/\\/g, '\\\\')  // backslash
    .replace(/"/g, '\\"')    // closing quote character
    .replace(/\x08/g, '\\b') // backspace
    .replace(/\t/g, '\\t')   // horizontal tab
    .replace(/\n/g, '\\n')   // line feed
    .replace(/\f/g, '\\f')   // form feed
    .replace(/\r/g, '\\r')   // carriage return
    .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
    + '"';
}

/*
 * Escapes characters inside the string so that it can be used as a list of
 * characters in a character class of a regular expression.
 */
function quoteForRegexpClass(s) {
  /*
   * Based on ECMA-262, 5th ed., 7.8.5 & 15.10.1.
   *
   * For portability, we also escape escape all control and non-ASCII
   * characters.
   */
  return s
    .replace(/\\/g, '\\\\')  // backslash
    .replace(/\//g, '\\/')   // closing slash
    .replace(/\]/g, '\\]')   // closing bracket
    .replace(/-/g, '\\-')    // dash
    .replace(/\0/g, '\\0')   // null
    .replace(/\t/g, '\\t')   // horizontal tab
    .replace(/\n/g, '\\n')   // line feed
    .replace(/\v/g, '\\x0B') // vertical tab
    .replace(/\f/g, '\\f')   // form feed
    .replace(/\r/g, '\\r')   // carriage return
    .replace(/[\x01-\x08\x0E-\x1F\x80-\uFFFF]/g, escape);
}

/*
 * Builds a node visitor -- a function which takes a node and any number of
 * other parameters, calls an appropriate function according to the node type,
 * passes it all its parameters and returns its value. The functions for various
 * node types are passed in a parameter to |buildNodeVisitor| as a hash.
 */
function buildNodeVisitor(functions) {
  return function(node) {
    return functions[node.type].apply(null, arguments);
  };
}

function findRuleByName(ast, name) {
  return find(ast.rules, function(r) { return r.name === name; });
}
PEG.parser = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "grammar": parse_grammar,
        "initializer": parse_initializer,
        "rule": parse_rule,
        "choice": parse_choice,
        "sequence": parse_sequence,
        "labeled": parse_labeled,
        "prefixed": parse_prefixed,
        "suffixed": parse_suffixed,
        "primary": parse_primary,
        "action": parse_action,
        "braced": parse_braced,
        "nonBraceCharacters": parse_nonBraceCharacters,
        "nonBraceCharacter": parse_nonBraceCharacter,
        "equals": parse_equals,
        "colon": parse_colon,
        "semicolon": parse_semicolon,
        "slash": parse_slash,
        "and": parse_and,
        "not": parse_not,
        "question": parse_question,
        "star": parse_star,
        "plus": parse_plus,
        "lparen": parse_lparen,
        "rparen": parse_rparen,
        "dot": parse_dot,
        "identifier": parse_identifier,
        "literal": parse_literal,
        "string": parse_string,
        "doubleQuotedString": parse_doubleQuotedString,
        "doubleQuotedCharacter": parse_doubleQuotedCharacter,
        "simpleDoubleQuotedCharacter": parse_simpleDoubleQuotedCharacter,
        "singleQuotedString": parse_singleQuotedString,
        "singleQuotedCharacter": parse_singleQuotedCharacter,
        "simpleSingleQuotedCharacter": parse_simpleSingleQuotedCharacter,
        "class": parse_class,
        "classCharacterRange": parse_classCharacterRange,
        "classCharacter": parse_classCharacter,
        "bracketDelimitedCharacter": parse_bracketDelimitedCharacter,
        "simpleBracketDelimitedCharacter": parse_simpleBracketDelimitedCharacter,
        "simpleEscapeSequence": parse_simpleEscapeSequence,
        "zeroEscapeSequence": parse_zeroEscapeSequence,
        "hexEscapeSequence": parse_hexEscapeSequence,
        "unicodeEscapeSequence": parse_unicodeEscapeSequence,
        "eolEscapeSequence": parse_eolEscapeSequence,
        "digit": parse_digit,
        "hexDigit": parse_hexDigit,
        "letter": parse_letter,
        "lowerCaseLetter": parse_lowerCaseLetter,
        "upperCaseLetter": parse_upperCaseLetter,
        "__": parse___,
        "comment": parse_comment,
        "singleLineComment": parse_singleLineComment,
        "multiLineComment": parse_multiLineComment,
        "eol": parse_eol,
        "eolChar": parse_eolChar,
        "whitespace": parse_whitespace
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "grammar";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_grammar() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse___();
        if (result0 !== null) {
          result1 = parse_initializer();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result3 = parse_rule();
            if (result3 !== null) {
              result2 = [];
              while (result3 !== null) {
                result2.push(result3);
                result3 = parse_rule();
              }
            } else {
              result2 = null;
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, initializer, rules) {
              return {
                type:        "grammar",
                initializer: initializer !== "" ? initializer : null,
                rules:       rules,
                startRule:   rules[0].name
              };
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_initializer() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_action();
        if (result0 !== null) {
          result1 = parse_semicolon();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, code) {
              return {
                type: "initializer",
                code: code
              };
            })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_rule() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_identifier();
        if (result0 !== null) {
          result1 = parse_string();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_equals();
            if (result2 !== null) {
              result3 = parse_choice();
              if (result3 !== null) {
                result4 = parse_semicolon();
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, name, displayName, expression) {
              return {
                type:        "rule",
                name:        name,
                displayName: displayName !== "" ? displayName : null,
                expression:  expression
              };
            })(pos0, result0[0], result0[1], result0[3]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_choice() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_sequence();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_slash();
          if (result2 !== null) {
            result3 = parse_sequence();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_slash();
            if (result2 !== null) {
              result3 = parse_sequence();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) {
              if (tail.length > 0) {
                var alternatives = [head].concat(map(
                    tail,
                    function(element) { return element[1]; }
                ));
                return {
                  type:         "choice",
                  alternatives: alternatives
                };
              } else {
                return head;
              }
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_sequence() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        result1 = parse_labeled();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_labeled();
        }
        if (result0 !== null) {
          result1 = parse_action();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, elements, code) {
              var expression = elements.length !== 1
                ? {
                    type:     "sequence",
                    elements: elements
                  }
                : elements[0];
              return {
                type:       "action",
                expression: expression,
                code:       code
              };
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = [];
          result1 = parse_labeled();
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_labeled();
          }
          if (result0 !== null) {
            result0 = (function(offset, elements) {
                return elements.length !== 1
                  ? {
                      type:     "sequence",
                      elements: elements
                    }
                  : elements[0];
              })(pos0, result0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_labeled() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_identifier();
        if (result0 !== null) {
          result1 = parse_colon();
          if (result1 !== null) {
            result2 = parse_prefixed();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, label, expression) {
              return {
                type:       "labeled",
                label:      label,
                expression: expression
              };
            })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_prefixed();
        }
        return result0;
      }
      
      function parse_prefixed() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_and();
        if (result0 !== null) {
          result1 = parse_action();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, code) {
              return {
                type: "semantic_and",
                code: code
              };
            })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_and();
          if (result0 !== null) {
            result1 = parse_suffixed();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, expression) {
                return {
                  type:       "simple_and",
                  expression: expression
                };
              })(pos0, result0[1]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            result0 = parse_not();
            if (result0 !== null) {
              result1 = parse_action();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, code) {
                  return {
                    type: "semantic_not",
                    code: code
                  };
                })(pos0, result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              pos1 = pos;
              result0 = parse_not();
              if (result0 !== null) {
                result1 = parse_suffixed();
                if (result1 !== null) {
                  result0 = [result0, result1];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 !== null) {
                result0 = (function(offset, expression) {
                    return {
                      type:       "simple_not",
                      expression: expression
                    };
                  })(pos0, result0[1]);
              }
              if (result0 === null) {
                pos = pos0;
              }
              if (result0 === null) {
                result0 = parse_suffixed();
              }
            }
          }
        }
        return result0;
      }
      
      function parse_suffixed() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_primary();
        if (result0 !== null) {
          result1 = parse_question();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, expression) {
              return {
                type:       "optional",
                expression: expression
              };
            })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_primary();
          if (result0 !== null) {
            result1 = parse_star();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, expression) {
                return {
                  type:       "zero_or_more",
                  expression: expression
                };
              })(pos0, result0[0]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            result0 = parse_primary();
            if (result0 !== null) {
              result1 = parse_plus();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, expression) {
                  return {
                    type:       "one_or_more",
                    expression: expression
                  };
                })(pos0, result0[0]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              result0 = parse_primary();
            }
          }
        }
        return result0;
      }
      
      function parse_primary() {
        var result0, result1, result2;
        var pos0, pos1, pos2, pos3;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_identifier();
        if (result0 !== null) {
          pos2 = pos;
          reportFailures++;
          pos3 = pos;
          result1 = parse_string();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_equals();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos3;
            }
          } else {
            result1 = null;
            pos = pos3;
          }
          reportFailures--;
          if (result1 === null) {
            result1 = "";
          } else {
            result1 = null;
            pos = pos2;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, name) {
              return {
                type: "rule_ref",
                name: name
              };
            })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_literal();
          if (result0 === null) {
            pos0 = pos;
            result0 = parse_dot();
            if (result0 !== null) {
              result0 = (function(offset) { return { type: "any" }; })(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              result0 = parse_class();
              if (result0 === null) {
                pos0 = pos;
                pos1 = pos;
                result0 = parse_lparen();
                if (result0 !== null) {
                  result1 = parse_choice();
                  if (result1 !== null) {
                    result2 = parse_rparen();
                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
                if (result0 !== null) {
                  result0 = (function(offset, expression) { return expression; })(pos0, result0[1]);
                }
                if (result0 === null) {
                  pos = pos0;
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_action() {
        var result0, result1;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_braced();
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, braced) { return braced.substr(1, braced.length - 2); })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("action");
        }
        return result0;
      }
      
      function parse_braced() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 123) {
          result0 = "{";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"{\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_braced();
          if (result2 === null) {
            result2 = parse_nonBraceCharacter();
          }
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_braced();
            if (result2 === null) {
              result2 = parse_nonBraceCharacter();
            }
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 125) {
              result2 = "}";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"}\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, parts) {
              return "{" + parts.join("") + "}";
            })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_nonBraceCharacters() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_nonBraceCharacter();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_nonBraceCharacter();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, chars) { return chars.join(""); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_nonBraceCharacter() {
        var result0;
        
        if (/^[^{}]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[^{}]");
          }
        }
        return result0;
      }
      
      function parse_equals() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 61) {
          result0 = "=";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"=\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "="; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_colon() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 58) {
          result0 = ":";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\":\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return ":"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_semicolon() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 59) {
          result0 = ";";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\";\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return ";"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_slash() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 47) {
          result0 = "/";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "/"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_and() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 38) {
          result0 = "&";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"&\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "&"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_not() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 33) {
          result0 = "!";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"!\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "!"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_question() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 63) {
          result0 = "?";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"?\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "?"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_star() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 42) {
          result0 = "*";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"*\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "*"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_plus() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 43) {
          result0 = "+";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"+\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "+"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_lparen() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 40) {
          result0 = "(";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "("; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_rparen() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 41) {
          result0 = ")";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\")\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return ")"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_dot() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 46) {
          result0 = ".";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\".\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "."; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_identifier() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_letter();
        if (result0 === null) {
          if (input.charCodeAt(pos) === 95) {
            result0 = "_";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"_\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 36) {
              result0 = "$";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"$\"");
              }
            }
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_letter();
          if (result2 === null) {
            result2 = parse_digit();
            if (result2 === null) {
              if (input.charCodeAt(pos) === 95) {
                result2 = "_";
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"_\"");
                }
              }
              if (result2 === null) {
                if (input.charCodeAt(pos) === 36) {
                  result2 = "$";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"$\"");
                  }
                }
              }
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_letter();
            if (result2 === null) {
              result2 = parse_digit();
              if (result2 === null) {
                if (input.charCodeAt(pos) === 95) {
                  result2 = "_";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"_\"");
                  }
                }
                if (result2 === null) {
                  if (input.charCodeAt(pos) === 36) {
                    result2 = "$";
                    pos++;
                  } else {
                    result2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"$\"");
                    }
                  }
                }
              }
            }
          }
          if (result1 !== null) {
            result2 = parse___();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) {
              return head + tail.join("");
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("identifier");
        }
        return result0;
      }
      
      function parse_literal() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_doubleQuotedString();
        if (result0 === null) {
          result0 = parse_singleQuotedString();
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 105) {
            result1 = "i";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"i\"");
            }
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse___();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, value, flags) {
              return {
                type:       "literal",
                value:      value,
                ignoreCase: flags === "i"
              };
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("literal");
        }
        return result0;
      }
      
      function parse_string() {
        var result0, result1;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_doubleQuotedString();
        if (result0 === null) {
          result0 = parse_singleQuotedString();
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, string) { return string; })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("string");
        }
        return result0;
      }
      
      function parse_doubleQuotedString() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 34) {
          result0 = "\"";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\"\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_doubleQuotedCharacter();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_doubleQuotedCharacter();
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 34) {
              result2 = "\"";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\\"\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, chars) { return chars.join(""); })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_doubleQuotedCharacter() {
        var result0;
        
        result0 = parse_simpleDoubleQuotedCharacter();
        if (result0 === null) {
          result0 = parse_simpleEscapeSequence();
          if (result0 === null) {
            result0 = parse_zeroEscapeSequence();
            if (result0 === null) {
              result0 = parse_hexEscapeSequence();
              if (result0 === null) {
                result0 = parse_unicodeEscapeSequence();
                if (result0 === null) {
                  result0 = parse_eolEscapeSequence();
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_simpleDoubleQuotedCharacter() {
        var result0, result1;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        pos2 = pos;
        reportFailures++;
        if (input.charCodeAt(pos) === 34) {
          result0 = "\"";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\"\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 92) {
            result0 = "\\";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\\\"");
            }
          }
          if (result0 === null) {
            result0 = parse_eolChar();
          }
        }
        reportFailures--;
        if (result0 === null) {
          result0 = "";
        } else {
          result0 = null;
          pos = pos2;
        }
        if (result0 !== null) {
          if (input.length > pos) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("any character");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, char_) { return char_; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_singleQuotedString() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 39) {
          result0 = "'";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"'\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_singleQuotedCharacter();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_singleQuotedCharacter();
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 39) {
              result2 = "'";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"'\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, chars) { return chars.join(""); })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_singleQuotedCharacter() {
        var result0;
        
        result0 = parse_simpleSingleQuotedCharacter();
        if (result0 === null) {
          result0 = parse_simpleEscapeSequence();
          if (result0 === null) {
            result0 = parse_zeroEscapeSequence();
            if (result0 === null) {
              result0 = parse_hexEscapeSequence();
              if (result0 === null) {
                result0 = parse_unicodeEscapeSequence();
                if (result0 === null) {
                  result0 = parse_eolEscapeSequence();
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_simpleSingleQuotedCharacter() {
        var result0, result1;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        pos2 = pos;
        reportFailures++;
        if (input.charCodeAt(pos) === 39) {
          result0 = "'";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"'\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 92) {
            result0 = "\\";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\\\"");
            }
          }
          if (result0 === null) {
            result0 = parse_eolChar();
          }
        }
        reportFailures--;
        if (result0 === null) {
          result0 = "";
        } else {
          result0 = null;
          pos = pos2;
        }
        if (result0 !== null) {
          if (input.length > pos) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("any character");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, char_) { return char_; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_class() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 94) {
            result1 = "^";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"^\"");
            }
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = [];
            result3 = parse_classCharacterRange();
            if (result3 === null) {
              result3 = parse_classCharacter();
            }
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_classCharacterRange();
              if (result3 === null) {
                result3 = parse_classCharacter();
              }
            }
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 93) {
                result3 = "]";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"]\"");
                }
              }
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 105) {
                  result4 = "i";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"i\"");
                  }
                }
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result5 = parse___();
                  if (result5 !== null) {
                    result0 = [result0, result1, result2, result3, result4, result5];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, inverted, parts, flags) {
              var partsConverted = map(parts, function(part) { return part.data; });
              var rawText = "["
                + inverted
                + map(parts, function(part) { return part.rawText; }).join("")
                + "]"
                + flags;
        
              return {
                type:       "class",
                inverted:   inverted === "^",
                ignoreCase: flags === "i",
                parts:      partsConverted,
                // FIXME: Get the raw text from the input directly.
                rawText:    rawText
              };
            })(pos0, result0[1], result0[2], result0[4]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("character class");
        }
        return result0;
      }
      
      function parse_classCharacterRange() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_classCharacter();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 45) {
            result1 = "-";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_classCharacter();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, begin, end) {
              if (begin.data.charCodeAt(0) > end.data.charCodeAt(0)) {
                throw new this.SyntaxError(
                  "Invalid character range: " + begin.rawText + "-" + end.rawText + "."
                );
              }
        
              return {
                data:    [begin.data, end.data],
                // FIXME: Get the raw text from the input directly.
                rawText: begin.rawText + "-" + end.rawText
              };
            })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_classCharacter() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_bracketDelimitedCharacter();
        if (result0 !== null) {
          result0 = (function(offset, char_) {
              return {
                data:    char_,
                // FIXME: Get the raw text from the input directly.
                rawText: quoteForRegexpClass(char_)
              };
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_bracketDelimitedCharacter() {
        var result0;
        
        result0 = parse_simpleBracketDelimitedCharacter();
        if (result0 === null) {
          result0 = parse_simpleEscapeSequence();
          if (result0 === null) {
            result0 = parse_zeroEscapeSequence();
            if (result0 === null) {
              result0 = parse_hexEscapeSequence();
              if (result0 === null) {
                result0 = parse_unicodeEscapeSequence();
                if (result0 === null) {
                  result0 = parse_eolEscapeSequence();
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_simpleBracketDelimitedCharacter() {
        var result0, result1;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        pos2 = pos;
        reportFailures++;
        if (input.charCodeAt(pos) === 93) {
          result0 = "]";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"]\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 92) {
            result0 = "\\";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\\\"");
            }
          }
          if (result0 === null) {
            result0 = parse_eolChar();
          }
        }
        reportFailures--;
        if (result0 === null) {
          result0 = "";
        } else {
          result0 = null;
          pos = pos2;
        }
        if (result0 !== null) {
          if (input.length > pos) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("any character");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, char_) { return char_; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_simpleEscapeSequence() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 92) {
          result0 = "\\";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\\"");
          }
        }
        if (result0 !== null) {
          pos2 = pos;
          reportFailures++;
          result1 = parse_digit();
          if (result1 === null) {
            if (input.charCodeAt(pos) === 120) {
              result1 = "x";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"x\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 117) {
                result1 = "u";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"u\"");
                }
              }
              if (result1 === null) {
                result1 = parse_eolChar();
              }
            }
          }
          reportFailures--;
          if (result1 === null) {
            result1 = "";
          } else {
            result1 = null;
            pos = pos2;
          }
          if (result1 !== null) {
            if (input.length > pos) {
              result2 = input.charAt(pos);
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("any character");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, char_) {
              return char_
                .replace("b", "\b")
                .replace("f", "\f")
                .replace("n", "\n")
                .replace("r", "\r")
                .replace("t", "\t")
                .replace("v", "\x0B"); // IE does not recognize "\v".
            })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_zeroEscapeSequence() {
        var result0, result1;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2) === "\\0") {
          result0 = "\\0";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\0\"");
          }
        }
        if (result0 !== null) {
          pos2 = pos;
          reportFailures++;
          result1 = parse_digit();
          reportFailures--;
          if (result1 === null) {
            result1 = "";
          } else {
            result1 = null;
            pos = pos2;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "\x00"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hexEscapeSequence() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2) === "\\x") {
          result0 = "\\x";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\x\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_hexDigit();
          if (result1 !== null) {
            result2 = parse_hexDigit();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, h1, h2) {
              return String.fromCharCode(parseInt(h1 + h2, 16));
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_unicodeEscapeSequence() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2) === "\\u") {
          result0 = "\\u";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\u\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_hexDigit();
          if (result1 !== null) {
            result2 = parse_hexDigit();
            if (result2 !== null) {
              result3 = parse_hexDigit();
              if (result3 !== null) {
                result4 = parse_hexDigit();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, h1, h2, h3, h4) {
              return String.fromCharCode(parseInt(h1 + h2 + h3 + h4, 16));
            })(pos0, result0[1], result0[2], result0[3], result0[4]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_eolEscapeSequence() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 92) {
          result0 = "\\";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_eol();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, eol) { return eol; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_digit() {
        var result0;
        
        if (/^[0-9]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9]");
          }
        }
        return result0;
      }
      
      function parse_hexDigit() {
        var result0;
        
        if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9a-fA-F]");
          }
        }
        return result0;
      }
      
      function parse_letter() {
        var result0;
        
        result0 = parse_lowerCaseLetter();
        if (result0 === null) {
          result0 = parse_upperCaseLetter();
        }
        return result0;
      }
      
      function parse_lowerCaseLetter() {
        var result0;
        
        if (/^[a-z]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-z]");
          }
        }
        return result0;
      }
      
      function parse_upperCaseLetter() {
        var result0;
        
        if (/^[A-Z]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[A-Z]");
          }
        }
        return result0;
      }
      
      function parse___() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_whitespace();
        if (result1 === null) {
          result1 = parse_eol();
          if (result1 === null) {
            result1 = parse_comment();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_whitespace();
          if (result1 === null) {
            result1 = parse_eol();
            if (result1 === null) {
              result1 = parse_comment();
            }
          }
        }
        return result0;
      }
      
      function parse_comment() {
        var result0;
        
        reportFailures++;
        result0 = parse_singleLineComment();
        if (result0 === null) {
          result0 = parse_multiLineComment();
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("comment");
        }
        return result0;
      }
      
      function parse_singleLineComment() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "//") {
          result0 = "//";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"//\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          pos2 = pos;
          reportFailures++;
          result2 = parse_eolChar();
          reportFailures--;
          if (result2 === null) {
            result2 = "";
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            if (input.length > pos) {
              result3 = input.charAt(pos);
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("any character");
              }
            }
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            result2 = parse_eolChar();
            reportFailures--;
            if (result2 === null) {
              result2 = "";
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              if (input.length > pos) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("any character");
                }
              }
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_multiLineComment() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "/*") {
          result0 = "/*";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/*\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          pos2 = pos;
          reportFailures++;
          if (input.substr(pos, 2) === "*/") {
            result2 = "*/";
            pos += 2;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\"*/\"");
            }
          }
          reportFailures--;
          if (result2 === null) {
            result2 = "";
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            if (input.length > pos) {
              result3 = input.charAt(pos);
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("any character");
              }
            }
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            reportFailures--;
            if (result2 === null) {
              result2 = "";
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              if (input.length > pos) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("any character");
                }
              }
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_eol() {
        var result0;
        
        reportFailures++;
        if (input.charCodeAt(pos) === 10) {
          result0 = "\n";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\n\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 2) === "\r\n") {
            result0 = "\r\n";
            pos += 2;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\r\\n\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 13) {
              result0 = "\r";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\r\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 8232) {
                result0 = "\u2028";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\u2028\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 8233) {
                  result0 = "\u2029";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\u2029\"");
                  }
                }
              }
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("end of line");
        }
        return result0;
      }
      
      function parse_eolChar() {
        var result0;
        
        if (/^[\n\r\u2028\u2029]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\n\\r\\u2028\\u2029]");
          }
        }
        return result0;
      }
      
      function parse_whitespace() {
        var result0;
        
        reportFailures++;
        if (/^[ \t\x0B\f\xA0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[ \\t\\x0B\\f\\xA0\\uFEFF\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000]");
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("whitespace");
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();
PEG.compiler = {
  /*
   * Names of passes that will get run during the compilation (in the specified
   * order).
   */
  appliedPassNames: [
    "reportMissingRules",
    "reportLeftRecursion",
    "removeProxyRules",
    "computeVarNames",
    "computeParams"
  ],

  /*
   * Generates a parser from a specified grammar AST. Throws |PEG.GrammarError|
   * if the AST contains a semantic error. Note that not all errors are detected
   * during the generation and some may protrude to the generated parser and
   * cause its malfunction.
   */
  compile: function(ast, options) {
    var that = this;

    each(this.appliedPassNames, function(passName) {
      that.passes[passName](ast);
    });

    var source = this.emitter(ast, options);
    var result = eval(source);
    result._source = source;

    return result;
  }
};

/*
 * Compiler passes.
 *
 * Each pass is a function that is passed the AST. It can perform checks on it
 * or modify it as needed. If the pass encounters a semantic error, it throws
 * |PEG.GrammarError|.
 */
PEG.compiler.passes = {
  /* Checks that all referenced rules exist. */
  reportMissingRules: function(ast) {
    function nop() {}

    function checkExpression(node) { check(node.expression); }

    function checkSubnodes(propertyName) {
      return function(node) { each(node[propertyName], check); };
    }

    var check = buildNodeVisitor({
      grammar:      checkSubnodes("rules"),
      rule:         checkExpression,
      choice:       checkSubnodes("alternatives"),
      sequence:     checkSubnodes("elements"),
      labeled:      checkExpression,
      simple_and:   checkExpression,
      simple_not:   checkExpression,
      semantic_and: nop,
      semantic_not: nop,
      optional:     checkExpression,
      zero_or_more: checkExpression,
      one_or_more:  checkExpression,
      action:       checkExpression,

      rule_ref:
        function(node) {
          if (!findRuleByName(ast, node.name)) {
            throw new PEG.GrammarError(
              "Referenced rule \"" + node.name + "\" does not exist."
            );
          }
        },

      literal:      nop,
      any:          nop,
      "class":      nop
    });

    check(ast);
  },

  /* Checks that no left recursion is present. */
  reportLeftRecursion: function(ast) {
    function nop() {}

    function checkExpression(node, appliedRules) {
      check(node.expression, appliedRules);
    }

    function checkSubnodes(propertyName) {
      return function(node, appliedRules) {
        each(node[propertyName], function(subnode) {
          check(subnode, appliedRules);
        });
      };
    }

    var check = buildNodeVisitor({
      grammar:     checkSubnodes("rules"),

      rule:
        function(node, appliedRules) {
          check(node.expression, appliedRules.concat(node.name));
        },

      choice:      checkSubnodes("alternatives"),

      sequence:
        function(node, appliedRules) {
          if (node.elements.length > 0) {
            check(node.elements[0], appliedRules);
          }
        },

      labeled:      checkExpression,
      simple_and:   checkExpression,
      simple_not:   checkExpression,
      semantic_and: nop,
      semantic_not: nop,
      optional:     checkExpression,
      zero_or_more: checkExpression,
      one_or_more:  checkExpression,
      action:       checkExpression,

      rule_ref:
        function(node, appliedRules) {
          if (contains(appliedRules, node.name)) {
            throw new PEG.GrammarError(
              "Left recursion detected for rule \"" + node.name + "\"."
            );
          }
          check(findRuleByName(ast, node.name), appliedRules);
        },

      literal:      nop,
      any:          nop,
      "class":      nop
    });

    check(ast, []);
  },

  /*
   * Removes proxy rules -- that is, rules that only delegate to other rule.
   */
  removeProxyRules: function(ast) {
    function isProxyRule(node) {
      return node.type === "rule" && node.expression.type === "rule_ref";
    }

    function replaceRuleRefs(ast, from, to) {
      function nop() {}

      function replaceInExpression(node, from, to) {
        replace(node.expression, from, to);
      }

      function replaceInSubnodes(propertyName) {
        return function(node, from, to) {
          each(node[propertyName], function(subnode) {
            replace(subnode, from, to);
          });
        };
      }

      var replace = buildNodeVisitor({
        grammar:      replaceInSubnodes("rules"),
        rule:         replaceInExpression,
        choice:       replaceInSubnodes("alternatives"),
        sequence:     replaceInSubnodes("elements"),
        labeled:      replaceInExpression,
        simple_and:   replaceInExpression,
        simple_not:   replaceInExpression,
        semantic_and: nop,
        semantic_not: nop,
        optional:     replaceInExpression,
        zero_or_more: replaceInExpression,
        one_or_more:  replaceInExpression,
        action:       replaceInExpression,

        rule_ref:
          function(node, from, to) {
            if (node.name === from) {
              node.name = to;
            }
          },

        literal:      nop,
        any:          nop,
        "class":      nop
      });

      replace(ast, from, to);
    }

    var indices = [];

    each(ast.rules, function(rule, i) {
      if (isProxyRule(rule)) {
        replaceRuleRefs(ast, rule.name, rule.expression.name);
        if (rule.name === ast.startRule) {
          ast.startRule = rule.expression.name;
        }
        indices.push(i);
      }
    });

    indices.reverse();

    each(indices, function(index) {
      ast.rules.splice(index, 1);
    });
  },

  /*
   * Computes names of variables used for storing match results and parse
   * positions in generated code. These variables are organized as two stacks.
   * The following will hold after running this pass:
   *
   *   * All nodes except "grammar" and "rule" nodes will have a |resultVar|
   *     property. It will contain a name of the variable that will store a
   *     match result of the expression represented by the node in generated
   *     code.
   *
   *   * Some nodes will have a |posVar| property. It will contain a name of the
   *     variable that will store a parse position in generated code.
   *
   *   * All "rule" nodes will contain |resultVars| and |posVars| properties.
   *     They will contain a list of values of |resultVar| and |posVar|
   *     properties used in rule's subnodes. (This is useful to declare
   *     variables in generated code.)
   */
  computeVarNames: function(ast) {
    function resultVar(index) { return "result" + index; }
    function posVar(index)    { return "pos"    + index; }

    function computeLeaf(node, index) {
      node.resultVar = resultVar(index.result);

      return { result: 0, pos: 0 };
    }

    function computeFromExpression(delta) {
      return function(node, index) {
        var depth = compute(
              node.expression,
              {
                result: index.result + delta.result,
                pos:    index.pos    + delta.pos
              }
            );

        node.resultVar = resultVar(index.result);
        if (delta.pos !== 0) {
          node.posVar = posVar(index.pos);
        }

        return {
          result: depth.result + delta.result,
          pos:    depth.pos    + delta.pos
        };
      };
    }

    var compute = buildNodeVisitor({
      grammar:
        function(node, index) {
          each(node.rules, function(node) {
            compute(node, index);
          });
        },

      rule:
        function(node, index) {
          var depth = compute(node.expression, index);

          node.resultVar  = resultVar(index.result);
          node.resultVars = map(range(depth.result + 1), resultVar);
          node.posVars    = map(range(depth.pos),        posVar);
        },

      choice:
        function(node, index) {
          var depths = map(node.alternatives, function(alternative) {
            return compute(alternative, index);
          });

          node.resultVar = resultVar(index.result);

          return {
            result: Math.max.apply(null, pluck(depths, "result")),
            pos:    Math.max.apply(null, pluck(depths, "pos"))
          };
        },

      sequence:
        function(node, index) {
          var depths = map(node.elements, function(element, i) {
            return compute(
              element,
              { result: index.result + i, pos: index.pos + 1 }
            );
          });

          node.resultVar = resultVar(index.result);
          node.posVar    = posVar(index.pos);

          return {
            result:
              node.elements.length > 0
                ? Math.max.apply(
                    null,
                    map(depths, function(d, i) { return i + d.result; })
                  )
                : 0,

            pos:
              node.elements.length > 0
                ? 1 + Math.max.apply(null, pluck(depths, "pos"))
                : 1
          };
        },

      labeled:      computeFromExpression({ result: 0, pos: 0 }),
      simple_and:   computeFromExpression({ result: 0, pos: 1 }),
      simple_not:   computeFromExpression({ result: 0, pos: 1 }),
      semantic_and: computeLeaf,
      semantic_not: computeLeaf,
      optional:     computeFromExpression({ result: 0, pos: 0 }),
      zero_or_more: computeFromExpression({ result: 1, pos: 0 }),
      one_or_more:  computeFromExpression({ result: 1, pos: 0 }),
      action:       computeFromExpression({ result: 0, pos: 1 }),
      rule_ref:     computeLeaf,
      literal:      computeLeaf,
      any:          computeLeaf,
      "class":      computeLeaf
    });

    compute(ast, { result: 0, pos: 0 });
  },

  /*
   * This pass walks through the AST and tracks what labels are visible at each
   * point. For "action", "semantic_and" and "semantic_or" nodes it computes
   * parameter names and values for the function used in generated code. (In the
   * emitter, user's code is wrapped into a function that is immediately
   * executed. Its parameter names correspond to visible labels and its
   * parameter values to their captured values). Implicitly, this pass defines
   * scoping rules for labels.
   *
   * After running this pass, all "action", "semantic_and" and "semantic_or"
   * nodes will have a |params| property containing an object mapping parameter
   * names to the expressions that will be used as their values.
   */
  computeParams: function(ast) {
    var envs = [];

    function scoped(f) {
      envs.push({});
      f();
      envs.pop();
    }

    function nop() {}

    function computeForScopedExpression(node) {
      scoped(function() { compute(node.expression); });
    }

    function computeParams(node) {
      var env = envs[envs.length - 1], params = {}, name;

      for (name in env) {
        params[name] = env[name];
      }
      node.params = params;
    }

    var compute = buildNodeVisitor({
      grammar:
        function(node) {
          each(node.rules, compute);
        },

      rule:         computeForScopedExpression,

      choice:
        function(node) {
          scoped(function() { each(node.alternatives, compute); });
        },

      sequence:
        function(node) {
          var env = envs[envs.length - 1], name;

          function fixup(name) {
            each(pluck(node.elements, "resultVar"), function(resultVar, i) {
              if ((new RegExp("^" + resultVar + "(\\[\\d+\\])*$")).test(env[name])) {
                env[name] = node.resultVar + "[" + i + "]"
                          + env[name].substr(resultVar.length);
              }
            });
          }

          each(node.elements, compute);

          for (name in env) {
            fixup(name);
          }
        },

      labeled:
        function(node) {
          envs[envs.length - 1][node.label] = node.resultVar;

          scoped(function() { compute(node.expression); });
        },

      simple_and:   computeForScopedExpression,
      simple_not:   computeForScopedExpression,
      semantic_and: computeParams,
      semantic_not: computeParams,
      optional:     computeForScopedExpression,
      zero_or_more: computeForScopedExpression,
      one_or_more:  computeForScopedExpression,

      action:
        function(node) {
          scoped(function() {
            compute(node.expression);
            computeParams(node);
          });
        },

      rule_ref:     nop,
      literal:      nop,
      any:          nop,
      "class":      nop
    });

    compute(ast);
  }
};
/* Emits the generated code for the AST. */
PEG.compiler.emitter = function(ast, options) {
  options = options || {};
  if (options.cache === undefined) {
    options.cache = false;
  }
  if (options.trackLineAndColumn === undefined) {
    options.trackLineAndColumn = false;
  }

  /*
   * Codie 1.1.0
   *
   * https://github.com/dmajda/codie
   *
   * Copyright (c) 2011-2012 David Majda
   * Licensend under the MIT license.
   */
  var Codie = (function(undefined) {

  function stringEscape(s) {
    function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
    return s
      .replace(/\\/g,   '\\\\') // backslash
      .replace(/"/g,    '\\"')  // closing double quote
      .replace(/\x08/g, '\\b')  // backspace
      .replace(/\t/g,   '\\t')  // horizontal tab
      .replace(/\n/g,   '\\n')  // line feed
      .replace(/\f/g,   '\\f')  // form feed
      .replace(/\r/g,   '\\r')  // carriage return
      .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
      .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
      .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
  }

  function push(s) { return '__p.push(' + s + ');'; }

  function pushRaw(template, length, state) {
    function unindent(code, level, unindentFirst) {
      return code.replace(
        new RegExp('^.{' + level +'}', "gm"),
        function(str, offset) {
          if (offset === 0) {
            return unindentFirst ? '' : str;
          } else {
            return "";
          }
        }
      );
    }

    var escaped = stringEscape(unindent(
          template.substring(0, length),
          state.indentLevel(),
          state.atBOL
        ));

    return escaped.length > 0 ? push('"' + escaped + '"') : '';
  }


  var Codie = {
    /* Codie version (uses semantic versioning). */
    VERSION: "1.1.0",

    /*
     * Specifies by how many characters do #if/#else and #for unindent their
     * content in the generated code.
     */
    indentStep: 2,

    /* Description of #-commands. Extend to define your own commands. */
    commands: {
      "if":   {
        params:  /^(.*)$/,
        compile: function(state, prefix, params) {
          return ['if(' + params[0] + '){', []];
        },
        stackOp: "push"
      },
      "else": {
        params:  /^$/,
        compile: function(state) {
          var stack = state.commandStack,
              insideElse = stack[stack.length - 1] === "else",
              insideIf   = stack[stack.length - 1] === "if";

          if (insideElse) { throw new Error("Multiple #elses."); }
          if (!insideIf)  { throw new Error("Using #else outside of #if."); }

          return ['}else{', []];
        },
        stackOp: "replace"
      },
      "for":  {
        params:  /^([a-zA-Z_][a-zA-Z0-9_]*)[ \t]+in[ \t]+(.*)$/,
        init:    function(state) {
          state.forCurrLevel = 0;  // current level of #for loop nesting
          state.forMaxLevel  = 0;  // maximum level of #for loop nesting
        },
        compile: function(state, prefix, params) {
          var c = '__c' + state.forCurrLevel, // __c for "collection"
              l = '__l' + state.forCurrLevel, // __l for "length"
              i = '__i' + state.forCurrLevel; // __i for "index"

          state.forCurrLevel++;
          if (state.forMaxLevel < state.forCurrLevel) {
            state.forMaxLevel = state.forCurrLevel;
          }

          return [
            c + '=' + params[1] + ';'
              + l + '=' + c + '.length;'
              + 'for(' + i + '=0;' + i + '<' + l + ';' + i + '++){'
              + params[0] + '=' + c + '[' + i + '];',
            [params[0], c, l, i]
          ];
        },
        exit:    function(state) { state.forCurrLevel--; },
        stackOp: "push"
      },
      "end":  {
        params:  /^$/,
        compile: function(state) {
          var stack = state.commandStack, exit;

          if (stack.length === 0) { throw new Error("Too many #ends."); }

          exit = Codie.commands[stack[stack.length - 1]].exit;
          if (exit) { exit(state); }

          return ['}', []];
        },
        stackOp: "pop"
      },
      "block": {
        params: /^(.*)$/,
        compile: function(state, prefix, params) {
          var x = '__x', // __x for "prefix",
              n = '__n', // __n for "lines"
              l = '__l', // __l for "length"
              i = '__i'; // __i for "index"

          /*
           * Originally, the generated code used |String.prototype.replace|, but
           * it is buggy in certain versions of V8 so it was rewritten. See the
           * tests for details.
           */
          return [
            x + '="' + stringEscape(prefix.substring(state.indentLevel())) + '";'
              + n + '=(' + params[0] + ').toString().split("\\n");'
              + l + '=' + n + '.length;'
              + 'for(' + i + '=0;' + i + '<' + l + ';' + i + '++){'
              + n + '[' + i +']=' + x + '+' + n + '[' + i + ']+"\\n";'
              + '}'
              + push(n + '.join("")'),
            [x, n, l, i]
          ];
        },
        stackOp: "nop"
      }
    },

    /*
     * Compiles a template into a function. When called, this function will
     * execute the template in the context of an object passed in a parameter and
     * return the result.
     */
    template: function(template) {
      var stackOps = {
        push:    function(stack, name) { stack.push(name); },
        replace: function(stack, name) { stack[stack.length - 1] = name; },
        pop:     function(stack)       { stack.pop(); },
        nop:     function()            { }
      };

      function compileExpr(state, expr) {
        state.atBOL = false;
        return [push(expr), []];
      }

      function compileCommand(state, prefix, name, params) {
        var command, match, result;

        command = Codie.commands[name];
        if (!command) { throw new Error("Unknown command: #" + name + "."); }

        match = command.params.exec(params);
        if (match === null) {
          throw new Error(
            "Invalid params for command #" + name + ": " + params + "."
          );
        }

        result = command.compile(state, prefix, match.slice(1));
        stackOps[command.stackOp](state.commandStack, name);
        state.atBOL = true;
        return result;
      }

      var state = {               // compilation state
            commandStack: [],     //   stack of commands as they were nested
            atBOL:        true,   //   is the next character to process at BOL?
            indentLevel:  function() {
              return Codie.indentStep * this.commandStack.length;
            }
          },
          code = '',              // generated template function code
          vars = ['__p=[]'],      // variables used by generated code
          name, match, result, i;

      /* Initialize state. */
      for (name in Codie.commands) {
        if (Codie.commands[name].init) { Codie.commands[name].init(state); }
      }

      /* Compile the template. */
      while ((match = /^([ \t]*)#([a-zA-Z_][a-zA-Z0-9_]*)(?:[ \t]+([^ \t\n][^\n]*))?[ \t]*(?:\n|$)|#\{([^}]*)\}/m.exec(template)) !== null) {
        code += pushRaw(template, match.index, state);
        result = match[2] !== undefined && match[2] !== ""
          ? compileCommand(state, match[1], match[2], match[3] || "") // #-command
          : compileExpr(state, match[4]);                             // #{...}
        code += result[0];
        vars = vars.concat(result[1]);
        template = template.substring(match.index + match[0].length);
      }
      code += pushRaw(template, template.length, state);

      /* Check the final state. */
      if (state.commandStack.length > 0) { throw new Error("Missing #end."); }

      /* Sanitize the list of variables used by commands. */
      vars.sort();
      for (i = 0; i < vars.length; i++) {
        if (vars[i] === vars[i - 1]) { vars.splice(i--, 1); }
      }

      /* Create the resulting function. */
      return new Function("__v", [
        '__v=__v||{};',
        'var ' + vars.join(',') + ';',
        'with(__v){',
        code,
        'return __p.join("").replace(/^\\n+|\\n+$/g,"");};'
      ].join(''));
    }
  };

  return Codie;

  })();

  var templates = (function() {
    var name,
        templates = {},
        sources = {
          grammar: [
            '(function(){',
            '  /*',
            '   * Generated by PEG.js 0.7.0.',
            '   *',
            '   * http://pegjs.majda.cz/',
            '   */',
            '  ',
            /* This needs to be in sync with |quote| in utils.js. */
            '  function quote(s) {',
            '    /*',
            '     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a',
            '     * string literal except for the closing quote character, backslash,',
            '     * carriage return, line separator, paragraph separator, and line feed.',
            '     * Any character may appear in the form of an escape sequence.',
            '     *',
            '     * For portability, we also escape escape all control and non-ASCII',
            '     * characters. Note that "\\0" and "\\v" escape sequences are not used',
            '     * because JSHint does not like the first and IE the second.',
            '     */',
            '     return \'"\' + s',
            '      .replace(/\\\\/g, \'\\\\\\\\\')  // backslash',
            '      .replace(/"/g, \'\\\\"\')    // closing quote character',
            '      .replace(/\\x08/g, \'\\\\b\') // backspace',
            '      .replace(/\\t/g, \'\\\\t\')   // horizontal tab',
            '      .replace(/\\n/g, \'\\\\n\')   // line feed',
            '      .replace(/\\f/g, \'\\\\f\')   // form feed',
            '      .replace(/\\r/g, \'\\\\r\')   // carriage return',
            '      .replace(/[\\x00-\\x07\\x0B\\x0E-\\x1F\\x80-\\uFFFF]/g, escape)',
            '      + \'"\';',
            '  }',
            '  ',
            '  var result = {',
            '    /*',
            '     * Parses the input with a generated parser. If the parsing is successfull,',
            '     * returns a value explicitly or implicitly specified by the grammar from',
            '     * which the parser was generated (see |PEG.buildParser|). If the parsing is',
            '     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.',
            '     */',
            '    parse: function(input, startRule) {',
            '      var parseFunctions = {',
            '        #for rule in node.rules',
            '          #{string(rule.name) + ": parse_" + rule.name + (rule !== node.rules[node.rules.length - 1] ? "," : "")}',
            '        #end',
            '      };',
            '      ',
            '      if (startRule !== undefined) {',
            '        if (parseFunctions[startRule] === undefined) {',
            '          throw new Error("Invalid rule name: " + quote(startRule) + ".");',
            '        }',
            '      } else {',
            '        startRule = #{string(node.startRule)};',
            '      }',
            '      ',
            '      #{posInit("pos")};',
            '      var reportFailures = 0;', // 0 = report, anything > 0 = do not report
            '      #{posInit("rightmostFailuresPos")};',
            '      var rightmostFailuresExpected = [];',
            '      #if options.cache',
            '        var cache = {};',
            '      #end',
            '      ',
            /* This needs to be in sync with |padLeft| in utils.js. */
            '      function padLeft(input, padding, length) {',
            '        var result = input;',
            '        ',
            '        var padLength = length - input.length;',
            '        for (var i = 0; i < padLength; i++) {',
            '          result = padding + result;',
            '        }',
            '        ',
            '        return result;',
            '      }',
            '      ',
            /* This needs to be in sync with |escape| in utils.js. */
            '      function escape(ch) {',
            '        var charCode = ch.charCodeAt(0);',
            '        var escapeChar;',
            '        var length;',
            '        ',
            '        if (charCode <= 0xFF) {',
            '          escapeChar = \'x\';',
            '          length = 2;',
            '        } else {',
            '          escapeChar = \'u\';',
            '          length = 4;',
            '        }',
            '        ',
            '        return \'\\\\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), \'0\', length);',
            '      }',
            '      ',
            '      #if options.trackLineAndColumn',
            '        function clone(object) {',
            '          var result = {};',
            '          for (var key in object) {',
            '            result[key] = object[key];',
            '          }',
            '          return result;',
            '        }',
            '        ',
            '        function advance(pos, n) {',
            '          var endOffset = pos.offset + n;',
            '          ',
            '          for (var offset = pos.offset; offset < endOffset; offset++) {',
            '            var ch = input.charAt(offset);',
            '            if (ch === "\\n") {',
            '              if (!pos.seenCR) { pos.line++; }',
            '              pos.column = 1;',
            '              pos.seenCR = false;',
            '            } else if (ch === "\\r" || ch === "\\u2028" || ch === "\\u2029") {',
            '              pos.line++;',
            '              pos.column = 1;',
            '              pos.seenCR = true;',
            '            } else {',
            '              pos.column++;',
            '              pos.seenCR = false;',
            '            }',
            '          }',
            '          ',
            '          pos.offset += n;',
            '        }',
            '        ',
            '      #end',
            '      function matchFailed(failure) {',
            '        if (#{posOffset("pos")} < #{posOffset("rightmostFailuresPos")}) {',
            '          return;',
            '        }',
            '        ',
            '        if (#{posOffset("pos")} > #{posOffset("rightmostFailuresPos")}) {',
            '          rightmostFailuresPos = #{posClone("pos")};',
            '          rightmostFailuresExpected = [];',
            '        }',
            '        ',
            '        rightmostFailuresExpected.push(failure);',
            '      }',
            '      ',
            '      #for rule in node.rules',
            '        #block emit(rule)',
            '        ',
            '      #end',
            '      ',
            '      function cleanupExpected(expected) {',
            '        expected.sort();',
            '        ',
            '        var lastExpected = null;',
            '        var cleanExpected = [];',
            '        for (var i = 0; i < expected.length; i++) {',
            '          if (expected[i] !== lastExpected) {',
            '            cleanExpected.push(expected[i]);',
            '            lastExpected = expected[i];',
            '          }',
            '        }',
            '        return cleanExpected;',
            '      }',
            '      ',
            '      #if !options.trackLineAndColumn',
            '        function computeErrorPosition() {',
            '          /*',
            '           * The first idea was to use |String.split| to break the input up to the',
            '           * error position along newlines and derive the line and column from',
            '           * there. However IE\'s |split| implementation is so broken that it was',
            '           * enough to prevent it.',
            '           */',
            '          ',
            '          var line = 1;',
            '          var column = 1;',
            '          var seenCR = false;',
            '          ',
            '          for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {',
            '            var ch = input.charAt(i);',
            '            if (ch === "\\n") {',
            '              if (!seenCR) { line++; }',
            '              column = 1;',
            '              seenCR = false;',
            '            } else if (ch === "\\r" || ch === "\\u2028" || ch === "\\u2029") {',
            '              line++;',
            '              column = 1;',
            '              seenCR = true;',
            '            } else {',
            '              column++;',
            '              seenCR = false;',
            '            }',
            '          }',
            '          ',
            '          return { line: line, column: column };',
            '        }',
            '      #end',
            '      ',
            '      #if node.initializer',
            '        #block emit(node.initializer)',
            '      #end',
            '      ',
            '      var result = parseFunctions[startRule]();',
            '      ',
            '      /*',
            '       * The parser is now in one of the following three states:',
            '       *',
            '       * 1. The parser successfully parsed the whole input.',
            '       *',
            '       *    - |result !== null|',
            '       *    - |#{posOffset("pos")} === input.length|',
            '       *    - |rightmostFailuresExpected| may or may not contain something',
            '       *',
            '       * 2. The parser successfully parsed only a part of the input.',
            '       *',
            '       *    - |result !== null|',
            '       *    - |#{posOffset("pos")} < input.length|',
            '       *    - |rightmostFailuresExpected| may or may not contain something',
            '       *',
            '       * 3. The parser did not successfully parse any part of the input.',
            '       *',
            '       *   - |result === null|',
            '       *   - |#{posOffset("pos")} === 0|',
            '       *   - |rightmostFailuresExpected| contains at least one failure',
            '       *',
            '       * All code following this comment (including called functions) must',
            '       * handle these states.',
            '       */',
            '      if (result === null || #{posOffset("pos")} !== input.length) {',
            '        var offset = Math.max(#{posOffset("pos")}, #{posOffset("rightmostFailuresPos")});',
            '        var found = offset < input.length ? input.charAt(offset) : null;',
            '        #if options.trackLineAndColumn',
            '          var errorPosition = #{posOffset("pos")} > #{posOffset("rightmostFailuresPos")} ? pos : rightmostFailuresPos;',
            '        #else',
            '          var errorPosition = computeErrorPosition();',
            '        #end',
            '        ',
            '        throw new this.SyntaxError(',
            '          cleanupExpected(rightmostFailuresExpected),',
            '          found,',
            '          offset,',
            '          errorPosition.line,',
            '          errorPosition.column',
            '        );',
            '      }',
            '      ',
            '      return result;',
            '    },',
            '    ',
            '    /* Returns the parser source code. */',
            '    toSource: function() { return this._source; }',
            '  };',
            '  ',
            '  /* Thrown when a parser encounters a syntax error. */',
            '  ',
            '  result.SyntaxError = function(expected, found, offset, line, column) {',
            '    function buildMessage(expected, found) {',
            '      var expectedHumanized, foundHumanized;',
            '      ',
            '      switch (expected.length) {',
            '        case 0:',
            '          expectedHumanized = "end of input";',
            '          break;',
            '        case 1:',
            '          expectedHumanized = expected[0];',
            '          break;',
            '        default:',
            '          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")',
            '            + " or "',
            '            + expected[expected.length - 1];',
            '      }',
            '      ',
            '      foundHumanized = found ? quote(found) : "end of input";',
            '      ',
            '      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";',
            '    }',
            '    ',
            '    this.name = "SyntaxError";',
            '    this.expected = expected;',
            '    this.found = found;',
            '    this.message = buildMessage(expected, found);',
            '    this.offset = offset;',
            '    this.line = line;',
            '    this.column = column;',
            '  };',
            '  ',
            '  result.SyntaxError.prototype = Error.prototype;',
            '  ',
            '  return result;',
            '})()'
          ],
          rule: [
            'function parse_#{node.name}() {',
            '  #if options.cache',
            '    var cacheKey = "#{node.name}@" + #{posOffset("pos")};',
            '    var cachedResult = cache[cacheKey];',
            '    if (cachedResult) {',
            '      pos = #{posClone("cachedResult.nextPos")};',
            '      return cachedResult.result;',
            '    }',
            '    ',
            '  #end',
            '  #if node.resultVars.length > 0',
            '    var #{node.resultVars.join(", ")};',
            '  #end',
            '  #if node.posVars.length > 0',
            '    var #{node.posVars.join(", ")};',
            '  #end',
            '  ',
            '  #if node.displayName !== null',
            '    reportFailures++;',
            '  #end',
            '  #block emit(node.expression)',
            '  #if node.displayName !== null',
            '    reportFailures--;',
            '    if (reportFailures === 0 && #{node.resultVar} === null) {',
            '      matchFailed(#{string(node.displayName)});',
            '    }',
            '  #end',
            '  #if options.cache',
            '    ',
            '    cache[cacheKey] = {',
            '      nextPos: #{posClone("pos")},',
            '      result:  #{node.resultVar}',
            '    };',
            '  #end',
            '  return #{node.resultVar};',
            '}'
          ],
          choice: [
            '#block emit(alternative)',
            '#block nextAlternativesCode'
          ],
          "choice.next": [
            'if (#{node.resultVar} === null) {',
            '  #block code',
            '}'
          ],
          sequence: [
            '#{posSave(node)};',
            '#block code'
          ],
          "sequence.iteration": [
            '#block emit(element)',
            'if (#{element.resultVar} !== null) {',
            '  #block code',
            '} else {',
            '  #{node.resultVar} = null;',
            '  #{posRestore(node)};',
            '}'
          ],
          "sequence.inner": [
            '#{node.resultVar} = [#{pluck(node.elements, "resultVar").join(", ")}];'
          ],
          simple_and: [
            '#{posSave(node)};',
            'reportFailures++;',
            '#block emit(node.expression)',
            'reportFailures--;',
            'if (#{node.resultVar} !== null) {',
            '  #{node.resultVar} = "";',
            '  #{posRestore(node)};',
            '} else {',
            '  #{node.resultVar} = null;',
            '}'
          ],
          simple_not: [
            '#{posSave(node)};',
            'reportFailures++;',
            '#block emit(node.expression)',
            'reportFailures--;',
            'if (#{node.resultVar} === null) {',
            '  #{node.resultVar} = "";',
            '} else {',
            '  #{node.resultVar} = null;',
            '  #{posRestore(node)};',
            '}'
          ],
          semantic_and: [
            '#{node.resultVar} = (function(#{(options.trackLineAndColumn ? ["offset", "line", "column"] : ["offset"]).concat(keys(node.params)).join(", ")}) {#{node.code}})(#{(options.trackLineAndColumn ? ["pos.offset", "pos.line", "pos.column"] : ["pos"]).concat(values(node.params)).join(", ")}) ? "" : null;'
          ],
          semantic_not: [
            '#{node.resultVar} = (function(#{(options.trackLineAndColumn ? ["offset", "line", "column"] : ["offset"]).concat(keys(node.params)).join(", ")}) {#{node.code}})(#{(options.trackLineAndColumn ? ["pos.offset", "pos.line", "pos.column"] : ["pos"]).concat(values(node.params)).join(", ")}) ? null : "";'
          ],
          optional: [
            '#block emit(node.expression)',
            '#{node.resultVar} = #{node.resultVar} !== null ? #{node.resultVar} : "";'
          ],
          zero_or_more: [
            '#{node.resultVar} = [];',
            '#block emit(node.expression)',
            'while (#{node.expression.resultVar} !== null) {',
            '  #{node.resultVar}.push(#{node.expression.resultVar});',
            '  #block emit(node.expression)',
            '}'
          ],
          one_or_more: [
            '#block emit(node.expression)',
            'if (#{node.expression.resultVar} !== null) {',
            '  #{node.resultVar} = [];',
            '  while (#{node.expression.resultVar} !== null) {',
            '    #{node.resultVar}.push(#{node.expression.resultVar});',
            '    #block emit(node.expression)',
            '  }',
            '} else {',
            '  #{node.resultVar} = null;',
            '}'
          ],
          action: [
            '#{posSave(node)};',
            '#block emit(node.expression)',
            'if (#{node.resultVar} !== null) {',
            '  #{node.resultVar} = (function(#{(options.trackLineAndColumn ? ["offset", "line", "column"] : ["offset"]).concat(keys(node.params)).join(", ")}) {#{node.code}})(#{(options.trackLineAndColumn ? [node.posVar + ".offset", node.posVar + ".line", node.posVar + ".column"] : [node.posVar]).concat(values(node.params)).join(", ")});',
            '}',
            'if (#{node.resultVar} === null) {',
            '  #{posRestore(node)};',
            '}'
          ],
          rule_ref: [
            '#{node.resultVar} = parse_#{node.name}();'
          ],
          literal: [
            '#if node.value.length === 0',
            '  #{node.resultVar} = "";',
            '#else',
            '  #if !node.ignoreCase',
            '    #if node.value.length === 1',
            '      if (input.charCodeAt(#{posOffset("pos")}) === #{node.value.charCodeAt(0)}) {',
            '    #else',
            '      if (input.substr(#{posOffset("pos")}, #{node.value.length}) === #{string(node.value)}) {',
            '    #end',
            '  #else',
            /*
             * One-char literals are not optimized when case-insensitive
             * matching is enabled. This is because there is no simple way to
             * lowercase a character code that works for character outside ASCII
             * letters. Moreover, |toLowerCase| can change string length,
             * meaning the result of lowercasing a character can be more
             * characters.
             */
            '    if (input.substr(#{posOffset("pos")}, #{node.value.length}).toLowerCase() === #{string(node.value.toLowerCase())}) {',
            '  #end',
            '    #if !node.ignoreCase',
            '      #{node.resultVar} = #{string(node.value)};',
            '    #else',
            '      #{node.resultVar} = input.substr(#{posOffset("pos")}, #{node.value.length});',
            '    #end',
            '    #{posAdvance(node.value.length)};',
            '  } else {',
            '    #{node.resultVar} = null;',
            '    if (reportFailures === 0) {',
            '      matchFailed(#{string(string(node.value))});',
            '    }',
            '  }',
            '#end'
          ],
          any: [
            'if (input.length > #{posOffset("pos")}) {',
            '  #{node.resultVar} = input.charAt(#{posOffset("pos")});',
            '  #{posAdvance(1)};',
            '} else {',
            '  #{node.resultVar} = null;',
            '  if (reportFailures === 0) {',
            '    matchFailed("any character");',
            '  }',
            '}'
          ],
          "class": [
            'if (#{regexp}.test(input.charAt(#{posOffset("pos")}))) {',
            '  #{node.resultVar} = input.charAt(#{posOffset("pos")});',
            '  #{posAdvance(1)};',
            '} else {',
            '  #{node.resultVar} = null;',
            '  if (reportFailures === 0) {',
            '    matchFailed(#{string(node.rawText)});',
            '  }',
            '}'
          ]
        };

    for (name in sources) {
      templates[name] = Codie.template(sources[name].join('\n'));
    }

    return templates;
  })();

  function fill(name, vars) {
    vars.string  = quote;
    vars.pluck   = pluck;
    vars.keys    = keys;
    vars.values  = values;
    vars.emit    = emit;
    vars.options = options;

    /* Position-handling macros */
    if (options.trackLineAndColumn) {
      vars.posInit    = function(name) {
        return "var "
             + name
             + " = "
             + "{ offset: 0, line: 1, column: 1, seenCR: false }";
      };
      vars.posClone   = function(name) { return "clone(" + name + ")"; };
      vars.posOffset  = function(name) { return name + ".offset"; };

      vars.posAdvance = function(n)    { return "advance(pos, " + n + ")"; };
    } else {
      vars.posInit    = function(name) { return "var " + name + " = 0"; };
      vars.posClone   = function(name) { return name; };
      vars.posOffset  = function(name) { return name; };

      vars.posAdvance = function(n) {
        return n === 1 ? "pos++" : "pos += " + n;
      };
    }
    vars.posSave    = function(node) {
      return node.posVar + " = " + vars.posClone("pos");
    };
    vars.posRestore = function(node) {
      return "pos" + " = " + vars.posClone(node.posVar);
    };

    return templates[name](vars);
  }

  function emitSimple(name) {
    return function(node) { return fill(name, { node: node }); };
  }

  var emit = buildNodeVisitor({
    grammar: emitSimple("grammar"),

    initializer: function(node) { return node.code; },

    rule: emitSimple("rule"),

    /*
     * The contract for all code fragments generated by the following functions
     * is as follows.
     *
     * The code fragment tries to match a part of the input starting with the
     * position indicated in |pos|. That position may point past the end of the
     * input.
     *
     * * If the code fragment matches the input, it advances |pos| to point to
     *   the first chracter following the matched part of the input and sets
     *   variable with a name stored in |node.resultVar| to an appropriate
     *   value. This value is always non-|null|.
     *
     * * If the code fragment does not match the input, it returns with |pos|
     *   set to the original value and it sets a variable with a name stored in
     *   |node.resultVar| to |null|.
     *
     * The code can use variables with names stored in |resultVar| and |posVar|
     * properties of the current node's subnodes. It can't use any other
     * variables.
     */

    choice: function(node) {
      var code, nextAlternativesCode;

      for (var i = node.alternatives.length - 1; i >= 0; i--) {
        nextAlternativesCode = i !== node.alternatives.length - 1
          ? fill("choice.next", { node: node, code: code })
          : '';
        code = fill("choice", {
          alternative:          node.alternatives[i],
          nextAlternativesCode: nextAlternativesCode
        });
      }

      return code;
    },

    sequence: function(node) {
      var code = fill("sequence.inner", { node: node });

      for (var i = node.elements.length - 1; i >= 0; i--) {
        code = fill("sequence.iteration", {
          node:    node,
          element: node.elements[i],
          code:    code
        });
      }

      return fill("sequence", { node: node, code: code });
    },

    labeled: function(node) { return emit(node.expression); },

    simple_and:   emitSimple("simple_and"),
    simple_not:   emitSimple("simple_not"),
    semantic_and: emitSimple("semantic_and"),
    semantic_not: emitSimple("semantic_not"),
    optional:     emitSimple("optional"),
    zero_or_more: emitSimple("zero_or_more"),
    one_or_more:  emitSimple("one_or_more"),
    action:       emitSimple("action"),
    rule_ref:     emitSimple("rule_ref"),
    literal:      emitSimple("literal"),
    any:          emitSimple("any"),

    "class": function(node) {
      var regexp;

      if (node.parts.length > 0) {
        regexp = '/^['
          + (node.inverted ? '^' : '')
          + map(node.parts, function(part) {
              return part instanceof Array
                ? quoteForRegexpClass(part[0])
                  + '-'
                  + quoteForRegexpClass(part[1])
                : quoteForRegexpClass(part);
            }).join('')
          + ']/' + (node.ignoreCase ? 'i' : '');
      } else {
        /*
         * Stupid IE considers regexps /[]/ and /[^]/ syntactically invalid, so
         * we translate them into euqivalents it can handle.
         */
        regexp = node.inverted ? '/^[\\S\\s]/' : '/^(?!)/';
      }

      return fill("class", { node: node, regexp: regexp });
    }
  });

  return emit(ast);
};

return PEG;

})();

if (typeof module !== "undefined") {
  module.exports = PEG;
}

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/index.js":[function(require,module,exports){
(function (process){
var EventEmitter = require('events').EventEmitter;
var Hash = require('hashish');
var Chainsaw = require('chainsaw');

module.exports = Seq;
function Seq (xs) {
    if (xs && !Array.isArray(xs) || arguments.length > 1) {
        throw new Error('Optional argument to Seq() is exactly one Array');
    }
    
    var ch = Chainsaw(function (saw) {
        builder.call(this, saw, xs || []);
    });
    
    process.nextTick(function () {
        ch['catch'](function (err) {
            console.error(err.stack ? err.stack : err)
        });
    });
    return ch;
}

Seq.ap = Seq; // for compatability with versions <0.3

function builder (saw, xs) {
    var context = {
        vars : {},
        args : {},
        stack : xs,
        error : null
    };
    context.stack_ = context.stack;
    
    function action (step, key, f, g) {
        var cb = function (err) {
            var args = [].slice.call(arguments, 1);
            if (err) {
                context.error = { message : err, key : key };
                saw.jump(lastPar);
                saw.down('catch');
                g();
            }
            else {
                if (typeof key == 'number') {
                    context.stack_[key] = args[0];
                    context.args[key] = args;
                }
                else {
                    context.stack_.push.apply(context.stack_, args);
                    if (key !== undefined) {
                        context.vars[key] = args[0];
                        context.args[key] = args;
                    }
                }
                if (g) g(args, key);
            }
        };
        Hash(context).forEach(function (v,k) { cb[k] = v });
        
        cb.into = function (k) {
            key = k;
            return cb;
        };
        
        cb.next = function (err, xs) {
            context.stack_.push.apply(context.stack_, xs);
            cb.apply(cb, [err].concat(context.stack));
        };
        
        cb.pass = function (err) {
            cb.apply(cb, [err].concat(context.stack));
        };
        
        cb.ok = cb.bind(cb, null);
        
        f.apply(cb, context.stack);
    }
    
    var running = 0;
    var errors = 0;
    
    this.seq = function (key, cb) {
        var bound = [].slice.call(arguments, 2);
        
        if (typeof key === 'function') {
            if (arguments.length > 1) bound.unshift(cb);
            cb = key;
            key = undefined;
        }
        
        if (context.error) saw.next()
        else if (running === 0) {
            action(saw.step, key,
                function () {
                    context.stack_ = [];
                    var args = [].slice.call(arguments);
                    args.unshift.apply(args, bound.map(function (arg) {
                        return arg === Seq ? this : arg
                    }, this));
                    
                    cb.apply(this, args);
                }, function () {
                    context.stack = context.stack_;
                    saw.next()
                }
            );
        }
    };
    
    var lastPar = null;
    this.par = function (key, cb) {
        lastPar = saw.step;
        
        if (running == 0) {
            // empty the active stack for the first par() in a chain
            context.stack_ = [];
        }
        
        var bound = [].slice.call(arguments, 2);
        if (typeof key === 'function') {
            if (arguments.length > 1) bound.unshift(cb);
            cb = key;
            key = context.stack_.length;
            context.stack_.push(null);
        }
        var cb_ = function () {
            var args = [].slice.call(arguments);
            args.unshift.apply(args, bound.map(function (arg) {
                return arg === Seq ? this : arg
            }, this));
            
            cb.apply(this, args);
        };
        
        running ++;
        
        var step = saw.step;
        process.nextTick(function () {
            action(step, key, cb_, function (args) {
                if (!args) errors ++;
                
                running --;
                if (running == 0) {
                    context.stack = context.stack_.slice();
                    saw.step = lastPar;
                    if (errors > 0) saw.down('catch');
                    errors = 0;
                    saw.next();
                }
            });
        });
        saw.next();
    };
    
    [ 'seq', 'par' ].forEach(function (name) {
        this[name + '_'] = function (key) {
            var args = [].slice.call(arguments);
            
            var cb = typeof key === 'function'
                ? args[0] : args[1];
            
            var fn = function () {
                var argv = [].slice.call(arguments);
                argv.unshift(this);
                cb.apply(this, argv);
            };
            
            if (typeof key === 'function') {
                args[0] = fn;
            }
            else {
                args[1] = fn;
            }
            
            this[name].apply(this, args);
        };
    }, this);
    
    this['catch'] = function (cb) {
        if (context.error) {
            cb.call(context, context.error.message, context.error.key);
            context.error = null;
        }
        saw.next();
    };
    
    this.forEach = function (cb) {
        this.seq(function () {
            context.stack_ = context.stack.slice();
            var end = context.stack.length;
            
            if (end === 0) this(null)
            else context.stack.forEach(function (x, i) {
                action(saw.step, i, function () {
                    cb.call(this, x, i);
                    if (i == end - 1) saw.next();
                });
            });
        });
    };
    
    this.seqEach = function (cb) {
        this.seq(function () {
            context.stack_ = context.stack.slice();
            var xs = context.stack.slice();
            if (xs.length === 0) this(null);
            else (function next (i) {
                action(
                    saw.step, i,
                    function () { cb.call(this, xs[i], i) },
                    function (args) {
                        if (!args || i === xs.length - 1) saw.next();
                        else next(i + 1);
                    }
                );
            }).bind(this)(0);
        });
    };
    
    this.parEach = function (limit, cb) {
        var xs = context.stack.slice();
        if (cb === undefined) { cb = limit; limit = xs.length }
        context.stack_ = [];
        
        var active = 0;
        var finished = 0;
        var queue = [];
        
        if (xs.length === 0) saw.next()
        else xs.forEach(function call (x, i) {
            if (active >= limit) {
                queue.push(call.bind(this, x, i));
            }
            else {
                active ++;
                action(saw.step, i,
                    function () {
                        cb.call(this, x, i);
                    },
                    function () {
                        active --;
                        finished ++;
                        if (queue.length > 0) queue.shift()();
                        else if (finished === xs.length) {
                            saw.next();
                        }
                    }
                );
            }
        });
    };
    
    this.parMap = function (limit, cb) {
        var res = [];
        var len = context.stack.length;
        if (cb === undefined) { cb = limit; limit = len }
        var res = [];
        
        Seq()
            .extend(context.stack)
            .parEach(limit, function (x, i) {
                var self = this;
                
                var next = function () {
                    res[i] = arguments[1];
                    self.apply(self, arguments);
                };
                
                next.stack = self.stack;
                next.stack_ = self.stack_;
                next.vars = self.vars;
                next.args = self.args;
                next.error = self.error;
                
                next.into = function (key) {
                    return function () {
                        res[key] = arguments[1];
                        self.apply(self, arguments);
                    };
                };
                
                next.ok = function () {
                    var args = [].slice.call(arguments);
                    args.unshift(null);
                    return next.apply(next, args);
                };
                
                cb.apply(next, arguments);
            })
            .seq(function () {
                context.stack = res;
                saw.next();
            })
        ;
    };
    
    this.seqMap = function (cb) {
        var res = [];
        var lastIdx = context.stack.length - 1;
        
        this.seqEach(function (x, i) {
            var self = this;
            
            var next = function () {
                res[i] = arguments[1];
                if (i === lastIdx)
                    context.stack = res;
                self.apply(self, arguments);
            };
            
            next.stack = self.stack;
            next.stack_ = self.stack_;
            next.vars = self.vars;
            next.args = self.args;
            next.error = self.error;
            
            next.into = function (key) {
                return function () {
                    res[key] = arguments[1];
                    if (i === lastIdx)
                        context.stack = res;
                    self.apply(self, arguments);
                };
            };
            
            next.ok = function () {
                var args = [].slice.call(arguments);
                args.unshift(null);
                return next.apply(next, args);
            };
            
            cb.apply(next, arguments);
        });
    };
    
    /**
     * Consumes any errors that occur in `cb`. Calls to `this.into(i)` will place
     * that value, if accepted by the filter, at the index in the results as
     * if it were the i-th index before filtering. (This means it will never 
     * override another value, and will only actually appear at i if the filter
     * accepts all values before i.)
     */
    this.parFilter = function (limit, cb) {
        var res = [];
        var len = context.stack.length;
        if (cb === undefined) { cb = limit; limit = len }
        var res = [];
        
        Seq()
            .extend(context.stack)
            .parEach(limit, function (x, i) {
                var self = this;
                
                var next = function (err, ok) {
                    if (!err && ok)
                        res.push([i, x]);
                    arguments[0] = null; // discard errors
                    self.apply(self, arguments);
                };
                
                next.stack = self.stack;
                next.stack_ = self.stack_;
                next.vars = self.vars;
                next.args = self.args;
                next.error = self.error;
                
                next.into = function (key) {
                    return function (err, ok) {
                        if (!err && ok)
                            res.push([key, x]);
                        arguments[0] = null; // discard errors
                        self.apply(self, arguments);
                    };
                };
                
                next.ok = function () {
                    var args = [].slice.call(arguments);
                    args.unshift(null);
                    return next.apply(next, args);
                };
                
                cb.apply(next, arguments);
            })
            .seq(function () {
                context.stack = res.sort().map(function(pair){ return pair[1]; });
                saw.next();
            })
        ;
    };
    
    /**
     * Consumes any errors that occur in `cb`. Calls to `this.into(i)` will place
     * that value, if accepted by the filter, at the index in the results as
     * if it were the i-th index before filtering. (This means it will never 
     * override another value, and will only actually appear at i if the filter
     * accepts all values before i.)
     */
    this.seqFilter = function (cb) {
        var res = [];
        var lastIdx = context.stack.length - 1;
        
        this.seqEach(function (x, i) {
            var self = this;
            
            var next = function (err, ok) {
                if (!err && ok)
                    res.push([i, x]);
                if (i === lastIdx)
                    context.stack = res.sort().map(function(pair){ return pair[1]; });
                arguments[0] = null; // discard errors
                self.apply(self, arguments);
            };
            
            next.stack = self.stack;
            next.stack_ = self.stack_;
            next.vars = self.vars;
            next.args = self.args;
            next.error = self.error;
            
            next.into = function (key) {
                return function (err, ok) {
                    if (!err && ok)
                        res.push([key, x]);
                    if (i === lastIdx)
                        context.stack = res.sort().map(function(pair){ return pair[1]; });
                    arguments[0] = null; // discard errors
                    self.apply(self, arguments);
                };
            };
            
            next.ok = function () {
                var args = [].slice.call(arguments);
                args.unshift(null);
                return next.apply(next, args);
            };
            
            cb.apply(next, arguments);
        });
    };
    
    [ 'forEach', 'seqEach', 'parEach', 'seqMap', 'parMap', 'seqFilter', 'parFilter' ]
        .forEach(function (name) {
            this[name + '_'] = function (cb) {
                this[name].call(this, function () {
                    var args = [].slice.call(arguments);
                    args.unshift(this);
                    cb.apply(this, args);
                });
            };
        }, this)
    ;
    
    ['push','pop','shift','unshift','splice','reverse']
        .forEach(function (name) {
            this[name] = function () {
                context.stack[name].apply(
                    context.stack,
                    [].slice.call(arguments)
                );
                saw.next();
                return this;
            };
        }, this)
    ;
    
    [ 'map', 'filter', 'reduce' ]
        .forEach(function (name) {
            this[name] = function () {
                var res = context.stack[name].apply(
                    context.stack,
                    [].slice.call(arguments)
                );
                // stack must be an array, or bad things happen
                context.stack = (Array.isArray(res) ? res : [res]);
                saw.next();
                return this;
            };
        }, this)
    ;
    
    this.extend = function (xs) {
        if (!Array.isArray(xs)) {
            throw new Error('argument to .extend() is not an Array');
        }
        context.stack.push.apply(context.stack, xs);
        saw.next();
    };
    
    this.flatten = function (pancake) {
        var xs = [];
        // should we fully flatten this array? (default: true)
        if (pancake === undefined) { pancake = true; }
        context.stack.forEach(function f (x) {
            if (Array.isArray(x) && pancake) x.forEach(f);
            else if (Array.isArray(x)) xs = xs.concat(x);
            else xs.push(x);
        });
        context.stack = xs;
        saw.next();
    };
    
    this.unflatten = function () {
        context.stack = [context.stack];
        saw.next();
    };
    
    this.empty = function () {
        context.stack = [];
        saw.next();
    };
    
    this.set = function (stack) {
        context.stack = stack;
        saw.next();
    };
    
    this['do'] = function (cb) {
        saw.nest(cb, context);
    };
}

}).call(this,require('_process'))

},{"_process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js","chainsaw":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/chainsaw/index.js","events":"/Users/Jacob/workspace/scheduler/front-end/node_modules/events/events.js","hashish":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/hashish/index.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/chainsaw/index.js":[function(require,module,exports){
(function (process){
var Traverse = require('traverse');
var EventEmitter = require('events').EventEmitter;

module.exports = Chainsaw;
function Chainsaw (builder) {
    var saw = Chainsaw.saw(builder, {});
    var r = builder.call(saw.handlers, saw);
    if (r !== undefined) saw.handlers = r;
    return saw.chain();
};

Chainsaw.saw = function (builder, handlers) {
    var saw = new EventEmitter;
    saw.handlers = handlers;
    saw.actions = [];
    saw.step = 0;
    
    saw.chain = function () {
        var ch = Traverse(saw.handlers).map(function (node) {
            if (this.isRoot) return node;
            var ps = this.path;
            
            if (typeof node === 'function') {
                this.update(function () {
                    saw.actions.push({
                        path : ps,
                        args : [].slice.call(arguments)
                    });
                    return ch;
                });
            }
        });
        
        process.nextTick(function () {
            saw.emit('begin');
            saw.next();
        });
        
        return ch;
    };
    
    saw.next = function () {
        var action = saw.actions[saw.step];
        saw.step ++;
        
        if (!action) {
            saw.emit('end');
        }
        else if (!action.trap) {
            var node = saw.handlers;
            action.path.forEach(function (key) { node = node[key] });
            node.apply(saw.handlers, action.args);
        }
    };
    
    saw.nest = function (cb) {
        var args = [].slice.call(arguments, 1);
        var autonext = true;
        
        if (typeof cb === 'boolean') {
            var autonext = cb;
            cb = args.shift();
        }
        
        var s = Chainsaw.saw(builder, {});
        var r = builder.call(s.handlers, s);
        
        if (r !== undefined) s.handlers = r;
        cb.apply(s.chain(), args);
        if (autonext !== false) s.on('end', saw.next);
    };
    
    saw.trap = function (name, cb) {
        var ps = Array.isArray(name) ? name : [name];
        saw.actions.push({
            path : ps,
            step : saw.step,
            cb : cb,
            trap : true
        });
    };
    
    saw.down = function (name) {
        var ps = (Array.isArray(name) ? name : [name]).join('/');
        var i = saw.actions.slice(saw.step).map(function (x) {
            if (x.trap && x.step <= saw.step) return false;
            return x.path.join('/') == ps;
        }).indexOf(true);
        
        if (i >= 0) saw.step += i;
        else saw.step = saw.actions.length;
        
        var act = saw.actions[saw.step - 1];
        if (act && act.trap) {
            // It's a trap!
            saw.step = act.step;
            act.cb();
        }
        else saw.next();
    };
    
    saw.jump = function (step) {
        saw.step = step;
        saw.next();
    };
    
    return saw;
}; 

}).call(this,require('_process'))

},{"_process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js","events":"/Users/Jacob/workspace/scheduler/front-end/node_modules/events/events.js","traverse":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/chainsaw/node_modules/traverse/index.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/chainsaw/node_modules/traverse/index.js":[function(require,module,exports){
module.exports = Traverse;
function Traverse (obj) {
    if (!(this instanceof Traverse)) return new Traverse(obj);
    this.value = obj;
}

Traverse.prototype.get = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key)) {
            node = undefined;
            break;
        }
        node = node[key];
    }
    return node;
};

Traverse.prototype.set = function (ps, value) {
    var node = this.value;
    for (var i = 0; i < ps.length - 1; i ++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key)) node[key] = {};
        node = node[key];
    }
    node[ps[i]] = value;
    return value;
};

Traverse.prototype.map = function (cb) {
    return walk(this.value, cb, true);
};

Traverse.prototype.forEach = function (cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
};

Traverse.prototype.reduce = function (cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function (x) {
        if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x);
        }
    });
    return acc;
};

Traverse.prototype.deepEqual = function (obj) {
    if (arguments.length !== 1) {
        throw new Error(
            'deepEqual requires exactly one object to compare against'
        );
    }
    
    var equal = true;
    var node = obj;
    
    this.forEach(function (y) {
        var notEqual = (function () {
            equal = false;
            //this.stop();
            return undefined;
        }).bind(this);
        
        //if (node === undefined || node === null) return notEqual();
        
        if (!this.isRoot) {
        /*
            if (!Object.hasOwnProperty.call(node, this.key)) {
                return notEqual();
            }
        */
            if (typeof node !== 'object') return notEqual();
            node = node[this.key];
        }
        
        var x = node;
        
        this.post(function () {
            node = x;
        });
        
        var toS = function (o) {
            return Object.prototype.toString.call(o);
        };
        
        if (this.circular) {
            if (Traverse(obj).get(this.circular.path) !== x) notEqual();
        }
        else if (typeof x !== typeof y) {
            notEqual();
        }
        else if (x === null || y === null || x === undefined || y === undefined) {
            if (x !== y) notEqual();
        }
        else if (x.__proto__ !== y.__proto__) {
            notEqual();
        }
        else if (x === y) {
            // nop
        }
        else if (typeof x === 'function') {
            if (x instanceof RegExp) {
                // both regexps on account of the __proto__ check
                if (x.toString() != y.toString()) notEqual();
            }
            else if (x !== y) notEqual();
        }
        else if (typeof x === 'object') {
            if (toS(y) === '[object Arguments]'
            || toS(x) === '[object Arguments]') {
                if (toS(x) !== toS(y)) {
                    notEqual();
                }
            }
            else if (x instanceof Date || y instanceof Date) {
                if (!(x instanceof Date) || !(y instanceof Date)
                || x.getTime() !== y.getTime()) {
                    notEqual();
                }
            }
            else {
                var kx = Object.keys(x);
                var ky = Object.keys(y);
                if (kx.length !== ky.length) return notEqual();
                for (var i = 0; i < kx.length; i++) {
                    var k = kx[i];
                    if (!Object.hasOwnProperty.call(y, k)) {
                        notEqual();
                    }
                }
            }
        }
    });
    
    return equal;
};

Traverse.prototype.paths = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.path); 
    });
    return acc;
};

Traverse.prototype.nodes = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.node);
    });
    return acc;
};

Traverse.prototype.clone = function () {
    var parents = [], nodes = [];
    
    return (function clone (src) {
        for (var i = 0; i < parents.length; i++) {
            if (parents[i] === src) {
                return nodes[i];
            }
        }
        
        if (typeof src === 'object' && src !== null) {
            var dst = copy(src);
            
            parents.push(src);
            nodes.push(dst);
            
            Object.keys(src).forEach(function (key) {
                dst[key] = clone(src[key]);
            });
            
            parents.pop();
            nodes.pop();
            return dst;
        }
        else {
            return src;
        }
    })(this.value);
};

function walk (root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    
    return (function walker (node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        
        var state = {
            node : node,
            node_ : node_,
            path : [].concat(path),
            parent : parents.slice(-1)[0],
            key : path.slice(-1)[0],
            isRoot : path.length === 0,
            level : path.length,
            circular : null,
            update : function (x) {
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
            },
            'delete' : function () {
                delete state.parent.node[state.key];
            },
            remove : function () {
                if (Array.isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                }
                else {
                    delete state.parent.node[state.key];
                }
            },
            before : function (f) { modifiers.before = f },
            after : function (f) { modifiers.after = f },
            pre : function (f) { modifiers.pre = f },
            post : function (f) { modifiers.post = f },
            stop : function () { alive = false }
        };
        
        if (!alive) return state;
        
        if (typeof node === 'object' && node !== null) {
            state.isLeaf = Object.keys(node).length == 0;
            
            for (var i = 0; i < parents.length; i++) {
                if (parents[i].node_ === node_) {
                    state.circular = parents[i];
                    break;
                }
            }
        }
        else {
            state.isLeaf = true;
        }
        
        state.notLeaf = !state.isLeaf;
        state.notRoot = !state.isRoot;
        
        // use return values to update if defined
        var ret = cb.call(state, state.node);
        if (ret !== undefined && state.update) state.update(ret);
        if (modifiers.before) modifiers.before.call(state, state.node);
        
        if (typeof state.node == 'object'
        && state.node !== null && !state.circular) {
            parents.push(state);
            
            var keys = Object.keys(state.node);
            keys.forEach(function (key, i) {
                path.push(key);
                
                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
                
                var child = walker(state.node[key]);
                if (immutable && Object.hasOwnProperty.call(state.node, key)) {
                    state.node[key] = child.node;
                }
                
                child.isLast = i == keys.length - 1;
                child.isFirst = i == 0;
                
                if (modifiers.post) modifiers.post.call(state, child);
                
                path.pop();
            });
            parents.pop();
        }
        
        if (modifiers.after) modifiers.after.call(state, state.node);
        
        return state;
    })(root).node;
}

Object.keys(Traverse.prototype).forEach(function (key) {
    Traverse[key] = function (obj) {
        var args = [].slice.call(arguments, 1);
        var t = Traverse(obj);
        return t[key].apply(t, args);
    };
});

function copy (src) {
    if (typeof src === 'object' && src !== null) {
        var dst;
        
        if (Array.isArray(src)) {
            dst = [];
        }
        else if (src instanceof Date) {
            dst = new Date(src);
        }
        else if (src instanceof Boolean) {
            dst = new Boolean(src);
        }
        else if (src instanceof Number) {
            dst = new Number(src);
        }
        else if (src instanceof String) {
            dst = new String(src);
        }
        else {
            dst = Object.create(Object.getPrototypeOf(src));
        }
        
        Object.keys(src).forEach(function (key) {
            dst[key] = src[key];
        });
        return dst;
    }
    else return src;
}

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/hashish/index.js":[function(require,module,exports){
module.exports = Hash;
var Traverse = require('traverse');

function Hash (hash, xs) {
    if (Array.isArray(hash) && Array.isArray(xs)) {
        var to = Math.min(hash.length, xs.length);
        var acc = {};
        for (var i = 0; i < to; i++) {
            acc[hash[i]] = xs[i];
        }
        return Hash(acc);
    }
    
    if (hash === undefined) return Hash({});
    
    var self = {
        map : function (f) {
            var acc = { __proto__ : hash.__proto__ };
            Object.keys(hash).forEach(function (key) {
                acc[key] = f.call(self, hash[key], key);
            });
            return Hash(acc);
        },
        forEach : function (f) {
            Object.keys(hash).forEach(function (key) {
                f.call(self, hash[key], key);
            });
            return self;
        },
        filter : function (f) {
            var acc = { __proto__ : hash.__proto__ };
            Object.keys(hash).forEach(function (key) {
                if (f.call(self, hash[key], key)) {
                    acc[key] = hash[key];
                }
            });
            return Hash(acc);
        },
        detect : function (f) {
            for (var key in hash) {
                if (f.call(self, hash[key], key)) {
                    return hash[key];
                }
            }
            return undefined;
        },
        reduce : function (f, acc) {
            var keys = Object.keys(hash);
            if (acc === undefined) acc = keys.shift();
            keys.forEach(function (key) {
                acc = f.call(self, acc, hash[key], key);
            });
            return acc;
        },
        some : function (f) {
            for (var key in hash) {
                if (f.call(self, hash[key], key)) return true;
            }
            return false;
        },
        update : function (obj) {
            if (arguments.length > 1) {
                self.updateAll([].slice.call(arguments));
            }
            else {
                Object.keys(obj).forEach(function (key) {
                    hash[key] = obj[key];
                });
            }
            return self;
        },
        updateAll : function (xs) {
            xs.filter(Boolean).forEach(function (x) {
                self.update(x);
            });
            return self;
        },
        merge : function (obj) {
            if (arguments.length > 1) {
                return self.copy.updateAll([].slice.call(arguments));
            }
            else {
                return self.copy.update(obj);
            }
        },
        mergeAll : function (xs) {
            return self.copy.updateAll(xs);
        },
        has : function (key) { // only operates on enumerables
            return Array.isArray(key)
                ? key.every(function (k) { return self.has(k) })
                : self.keys.indexOf(key.toString()) >= 0;
        },
        valuesAt : function (keys) {
            return Array.isArray(keys)
                ? keys.map(function (key) { return hash[key] })
                : hash[keys]
            ;
        },
        tap : function (f) {
            f.call(self, hash);
            return self;
        },
        extract : function (keys) {
            var acc = {};
            keys.forEach(function (key) {
                acc[key] = hash[key];
            });
            return Hash(acc);
        },
        exclude : function (keys) {
            return self.filter(function (_, key) {
                return keys.indexOf(key) < 0
            });
        },
        end : hash,
        items : hash
    };
    
    var props = {
        keys : function () { return Object.keys(hash) },
        values : function () {
            return Object.keys(hash).map(function (key) { return hash[key] });
        },
        compact : function () {
            return self.filter(function (x) { return x !== undefined });
        },
        clone : function () { return Hash(Hash.clone(hash)) },
        copy : function () { return Hash(Hash.copy(hash)) },
        length : function () { return Object.keys(hash).length },
        size : function () { return self.length }
    };
    
    if (Object.defineProperty) {
        // es5-shim has an Object.defineProperty but it throws for getters
        try {
            for (var key in props) {
                Object.defineProperty(self, key, { get : props[key] });
            }
        }
        catch (err) {
            for (var key in props) {
                if (key !== 'clone' && key !== 'copy' && key !== 'compact') {
                    // ^ those keys use Hash() so can't call them without
                    // a stack overflow
                    self[key] = props[key]();
                }
            }
        }
    }
    else if (self.__defineGetter__) {
        for (var key in props) {
            self.__defineGetter__(key, props[key]);
        }
    }
    else {
        // non-lazy version for browsers that suck >_<
        for (var key in props) {
            self[key] = props[key]();
        }
    }
    
    return self;
};

// deep copy
Hash.clone = function (ref) {
    return Traverse.clone(ref);
};

// shallow copy
Hash.copy = function (ref) {
    var hash = { __proto__ : ref.__proto__ };
    Object.keys(ref).forEach(function (key) {
        hash[key] = ref[key];
    });
    return hash;
};

Hash.map = function (ref, f) {
    return Hash(ref).map(f).items;
};

Hash.forEach = function (ref, f) {
    Hash(ref).forEach(f);
};

Hash.filter = function (ref, f) {
    return Hash(ref).filter(f).items;
};

Hash.detect = function (ref, f) {
    return Hash(ref).detect(f);
};

Hash.reduce = function (ref, f, acc) {
    return Hash(ref).reduce(f, acc);
};

Hash.some = function (ref, f) {
    return Hash(ref).some(f);
};

Hash.update = function (a /*, b, c, ... */) {
    var args = Array.prototype.slice.call(arguments, 1);
    var hash = Hash(a);
    return hash.update.apply(hash, args).items;
};

Hash.merge = function (a /*, b, c, ... */) {
    var args = Array.prototype.slice.call(arguments, 1);
    var hash = Hash(a);
    return hash.merge.apply(hash, args).items;
};

Hash.has = function (ref, key) {
    return Hash(ref).has(key);
};

Hash.valuesAt = function (ref, keys) {
    return Hash(ref).valuesAt(keys);
};

Hash.tap = function (ref, f) {
    return Hash(ref).tap(f).items;
};

Hash.extract = function (ref, keys) {
    return Hash(ref).extract(keys).items;
};

Hash.exclude = function (ref, keys) {
    return Hash(ref).exclude(keys).items;
};

Hash.concat = function (xs) {
    var hash = Hash({});
    xs.forEach(function (x) { hash.update(x) });
    return hash.items;
};

Hash.zip = function (xs, ys) {
    return Hash(xs, ys).items;
};

// .length is already defined for function prototypes
Hash.size = function (ref) {
    return Hash(ref).size;
};

Hash.compact = function (ref) {
    return Hash(ref).compact.items;
};

},{"traverse":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/hashish/node_modules/traverse/index.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/hashish/node_modules/traverse/index.js":[function(require,module,exports){
var traverse = module.exports = function (obj) {
    return new Traverse(obj);
};

function Traverse (obj) {
    this.value = obj;
}

Traverse.prototype.get = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            node = undefined;
            break;
        }
        node = node[key];
    }
    return node;
};

Traverse.prototype.has = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            return false;
        }
        node = node[key];
    }
    return true;
};

Traverse.prototype.set = function (ps, value) {
    var node = this.value;
    for (var i = 0; i < ps.length - 1; i ++) {
        var key = ps[i];
        if (!hasOwnProperty.call(node, key)) node[key] = {};
        node = node[key];
    }
    node[ps[i]] = value;
    return value;
};

Traverse.prototype.map = function (cb) {
    return walk(this.value, cb, true);
};

Traverse.prototype.forEach = function (cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
};

Traverse.prototype.reduce = function (cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function (x) {
        if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x);
        }
    });
    return acc;
};

Traverse.prototype.paths = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.path); 
    });
    return acc;
};

Traverse.prototype.nodes = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.node);
    });
    return acc;
};

Traverse.prototype.clone = function () {
    var parents = [], nodes = [];
    
    return (function clone (src) {
        for (var i = 0; i < parents.length; i++) {
            if (parents[i] === src) {
                return nodes[i];
            }
        }
        
        if (typeof src === 'object' && src !== null) {
            var dst = copy(src);
            
            parents.push(src);
            nodes.push(dst);
            
            forEach(objectKeys(src), function (key) {
                dst[key] = clone(src[key]);
            });
            
            parents.pop();
            nodes.pop();
            return dst;
        }
        else {
            return src;
        }
    })(this.value);
};

function walk (root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    
    return (function walker (node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        
        var keepGoing = true;
        
        var state = {
            node : node,
            node_ : node_,
            path : [].concat(path),
            parent : parents[parents.length - 1],
            parents : parents,
            key : path.slice(-1)[0],
            isRoot : path.length === 0,
            level : path.length,
            circular : null,
            update : function (x, stopHere) {
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
                if (stopHere) keepGoing = false;
            },
            'delete' : function (stopHere) {
                delete state.parent.node[state.key];
                if (stopHere) keepGoing = false;
            },
            remove : function (stopHere) {
                if (isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                }
                else {
                    delete state.parent.node[state.key];
                }
                if (stopHere) keepGoing = false;
            },
            keys : null,
            before : function (f) { modifiers.before = f },
            after : function (f) { modifiers.after = f },
            pre : function (f) { modifiers.pre = f },
            post : function (f) { modifiers.post = f },
            stop : function () { alive = false },
            block : function () { keepGoing = false }
        };
        
        if (!alive) return state;
        
        function updateState() {
            if (typeof state.node === 'object' && state.node !== null) {
                if (!state.keys || state.node_ !== state.node) {
                    state.keys = objectKeys(state.node)
                }
                
                state.isLeaf = state.keys.length == 0;
                
                for (var i = 0; i < parents.length; i++) {
                    if (parents[i].node_ === node_) {
                        state.circular = parents[i];
                        break;
                    }
                }
            }
            else {
                state.isLeaf = true;
                state.keys = null;
            }
            
            state.notLeaf = !state.isLeaf;
            state.notRoot = !state.isRoot;
        }
        
        updateState();
        
        // use return values to update if defined
        var ret = cb.call(state, state.node);
        if (ret !== undefined && state.update) state.update(ret);
        
        if (modifiers.before) modifiers.before.call(state, state.node);
        
        if (!keepGoing) return state;
        
        if (typeof state.node == 'object'
        && state.node !== null && !state.circular) {
            parents.push(state);
            
            updateState();
            
            forEach(state.keys, function (key, i) {
                path.push(key);
                
                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
                
                var child = walker(state.node[key]);
                if (immutable && hasOwnProperty.call(state.node, key)) {
                    state.node[key] = child.node;
                }
                
                child.isLast = i == state.keys.length - 1;
                child.isFirst = i == 0;
                
                if (modifiers.post) modifiers.post.call(state, child);
                
                path.pop();
            });
            parents.pop();
        }
        
        if (modifiers.after) modifiers.after.call(state, state.node);
        
        return state;
    })(root).node;
}

function copy (src) {
    if (typeof src === 'object' && src !== null) {
        var dst;
        
        if (isArray(src)) {
            dst = [];
        }
        else if (isDate(src)) {
            dst = new Date(src.getTime ? src.getTime() : src);
        }
        else if (isRegExp(src)) {
            dst = new RegExp(src);
        }
        else if (isError(src)) {
            dst = { message: src.message };
        }
        else if (isBoolean(src)) {
            dst = new Boolean(src);
        }
        else if (isNumber(src)) {
            dst = new Number(src);
        }
        else if (isString(src)) {
            dst = new String(src);
        }
        else if (Object.create && Object.getPrototypeOf) {
            dst = Object.create(Object.getPrototypeOf(src));
        }
        else if (src.constructor === Object) {
            dst = {};
        }
        else {
            var proto =
                (src.constructor && src.constructor.prototype)
                || src.__proto__
                || {}
            ;
            var T = function () {};
            T.prototype = proto;
            dst = new T;
        }
        
        forEach(objectKeys(src), function (key) {
            dst[key] = src[key];
        });
        return dst;
    }
    else return src;
}

var objectKeys = Object.keys || function keys (obj) {
    var res = [];
    for (var key in obj) res.push(key)
    return res;
};

function toS (obj) { return Object.prototype.toString.call(obj) }
function isDate (obj) { return toS(obj) === '[object Date]' }
function isRegExp (obj) { return toS(obj) === '[object RegExp]' }
function isError (obj) { return toS(obj) === '[object Error]' }
function isBoolean (obj) { return toS(obj) === '[object Boolean]' }
function isNumber (obj) { return toS(obj) === '[object Number]' }
function isString (obj) { return toS(obj) === '[object String]' }

var isArray = Array.isArray || function isArray (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

forEach(objectKeys(Traverse.prototype), function (key) {
    traverse[key] = function (obj) {
        var args = [].slice.call(arguments, 1);
        var t = new Traverse(obj);
        return t[key].apply(t, args);
    };
});

var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
    return key in obj;
};

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/consolidator.js":[function(require,module,exports){
/**
 * @preserve Copyright 2012 Robert Gust-Bardon <http://robert.gust-bardon.org/>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *     * Redistributions of source code must retain the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/**
 * @fileoverview Enhances <a href="https://github.com/mishoo/UglifyJS/"
 * >UglifyJS</a> with consolidation of null, Boolean, and String values.
 * <p>Also known as aliasing, this feature has been deprecated in <a href=
 * "http://closure-compiler.googlecode.com/">the Closure Compiler</a> since its
 * initial release, where it is unavailable from the <abbr title=
 * "command line interface">CLI</a>. The Closure Compiler allows one to log and
 * influence this process. In contrast, this implementation does not introduce
 * any variable declarations in global code and derives String values from
 * identifier names used as property accessors.</p>
 * <p>Consolidating literals may worsen the data compression ratio when an <a
 * href="http://tools.ietf.org/html/rfc2616#section-3.5">encoding
 * transformation</a> is applied. For instance, <a href=
 * "http://code.jquery.com/jquery-1.7.1.js">jQuery 1.7.1</a> takes 248235 bytes.
 * Building it with <a href="https://github.com/mishoo/UglifyJS/tarball/v1.2.5">
 * UglifyJS v1.2.5</a> results in 93647 bytes (37.73% of the original) which are
 * then compressed to 33154 bytes (13.36% of the original) using <a href=
 * "http://linux.die.net/man/1/gzip">gzip(1)</a>. Building it with the same
 * version of UglifyJS 1.2.5 patched with the implementation of consolidation
 * results in 80784 bytes (a decrease of 12863 bytes, i.e. 13.74%, in comparison
 * to the aforementioned 93647 bytes) which are then compressed to 34013 bytes
 * (an increase of 859 bytes, i.e. 2.59%, in comparison to the aforementioned
 * 33154 bytes).</p>
 * <p>Written in <a href="http://es5.github.com/#x4.2.2">the strict variant</a>
 * of <a href="http://es5.github.com/">ECMA-262 5.1 Edition</a>. Encoded in <a
 * href="http://tools.ietf.org/html/rfc3629">UTF-8</a>. Follows <a href=
 * "http://google-styleguide.googlecode.com/svn-history/r76/trunk/javascriptguide.xml"
 * >Revision 2.28 of the Google JavaScript Style Guide</a> (except for the
 * discouraged use of the {@code function} tag and the {@code namespace} tag).
 * 100% typed for the <a href=
 * "http://closure-compiler.googlecode.com/files/compiler-20120123.tar.gz"
 * >Closure Compiler Version 1741</a>.</p>
 * <p>Should you find this software useful, please consider <a href=
 * "https://paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=JZLW72X8FD4WG"
 * >a donation</a>.</p>
 * @author follow.me@RGustBardon (Robert Gust-Bardon)
 * @supported Tested with:
 *     <ul>
 *     <li><a href="http://nodejs.org/dist/v0.6.10/">Node v0.6.10</a>,</li>
 *     <li><a href="https://github.com/mishoo/UglifyJS/tarball/v1.2.5">UglifyJS
 *       v1.2.5</a>.</li>
 *     </ul>
 */

/*global console:false, exports:true, module:false, require:false */
/*jshint sub:true */
/**
 * Consolidates null, Boolean, and String values found inside an <abbr title=
 * "abstract syntax tree">AST</abbr>.
 * @param {!TSyntacticCodeUnit} oAbstractSyntaxTree An array-like object
 *     representing an <abbr title="abstract syntax tree">AST</abbr>.
 * @return {!TSyntacticCodeUnit} An array-like object representing an <abbr
 *     title="abstract syntax tree">AST</abbr> with its null, Boolean, and
 *     String values consolidated.
 */
// TODO(user) Consolidation of mathematical values found in numeric literals.
// TODO(user) Unconsolidation.
// TODO(user) Consolidation of ECMA-262 6th Edition programs.
// TODO(user) Rewrite in ECMA-262 6th Edition.
exports['ast_consolidate'] = function(oAbstractSyntaxTree) {
  'use strict';
  /*jshint bitwise:true, curly:true, eqeqeq:true, forin:true, immed:true,
        latedef:true, newcap:true, noarge:true, noempty:true, nonew:true,
        onevar:true, plusplus:true, regexp:true, undef:true, strict:true,
        sub:false, trailing:true */

  var _,
      /**
       * A record consisting of data about one or more source elements.
       * @constructor
       * @nosideeffects
       */
      TSourceElementsData = function() {
        /**
         * The category of the elements.
         * @type {number}
         * @see ESourceElementCategories
         */
        this.nCategory = ESourceElementCategories.N_OTHER;
        /**
         * The number of occurrences (within the elements) of each primitive
         * value that could be consolidated.
         * @type {!Array.<!Object.<string, number>>}
         */
        this.aCount = [];
        this.aCount[EPrimaryExpressionCategories.N_IDENTIFIER_NAMES] = {};
        this.aCount[EPrimaryExpressionCategories.N_STRING_LITERALS] = {};
        this.aCount[EPrimaryExpressionCategories.N_NULL_AND_BOOLEAN_LITERALS] =
            {};
        /**
         * Identifier names found within the elements.
         * @type {!Array.<string>}
         */
        this.aIdentifiers = [];
        /**
         * Prefixed representation Strings of each primitive value that could be
         * consolidated within the elements.
         * @type {!Array.<string>}
         */
        this.aPrimitiveValues = [];
      },
      /**
       * A record consisting of data about a primitive value that could be
       * consolidated.
       * @constructor
       * @nosideeffects
       */
      TPrimitiveValue = function() {
        /**
         * The difference in the number of terminal symbols between the original
         * source text and the one with the primitive value consolidated. If the
         * difference is positive, the primitive value is considered worthwhile.
         * @type {number}
         */
        this.nSaving = 0;
        /**
         * An identifier name of the variable that will be declared and assigned
         * the primitive value if the primitive value is consolidated.
         * @type {string}
         */
        this.sName = '';
      },
      /**
       * A record consisting of data on what to consolidate within the range of
       * source elements that is currently being considered.
       * @constructor
       * @nosideeffects
       */
      TSolution = function() {
        /**
         * An object whose keys are prefixed representation Strings of each
         * primitive value that could be consolidated within the elements and
         * whose values are corresponding data about those primitive values.
         * @type {!Object.<string, {nSaving: number, sName: string}>}
         * @see TPrimitiveValue
         */
        this.oPrimitiveValues = {};
        /**
         * The difference in the number of terminal symbols between the original
         * source text and the one with all the worthwhile primitive values
         * consolidated.
         * @type {number}
         * @see TPrimitiveValue#nSaving
         */
        this.nSavings = 0;
      },
      /**
       * The processor of <abbr title="abstract syntax tree">AST</abbr>s found
       * in UglifyJS.
       * @namespace
       * @type {!TProcessor}
       */
      oProcessor = (/** @type {!TProcessor} */ require('./process')),
      /**
       * A record consisting of a number of constants that represent the
       * difference in the number of terminal symbols between a source text with
       * a modified syntactic code unit and the original one.
       * @namespace
       * @type {!Object.<string, number>}
       */
      oWeights = {
        /**
         * The difference in the number of punctuators required by the bracket
         * notation and the dot notation.
         * <p><code>'[]'.length - '.'.length</code></p>
         * @const
         * @type {number}
         */
        N_PROPERTY_ACCESSOR: 1,
        /**
         * The number of punctuators required by a variable declaration with an
         * initialiser.
         * <p><code>':'.length + ';'.length</code></p>
         * @const
         * @type {number}
         */
        N_VARIABLE_DECLARATION: 2,
        /**
         * The number of terminal symbols required to introduce a variable
         * statement (excluding its variable declaration list).
         * <p><code>'var '.length</code></p>
         * @const
         * @type {number}
         */
        N_VARIABLE_STATEMENT_AFFIXATION: 4,
        /**
         * The number of terminal symbols needed to enclose source elements
         * within a function call with no argument values to a function with an
         * empty parameter list.
         * <p><code>'(function(){}());'.length</code></p>
         * @const
         * @type {number}
         */
        N_CLOSURE: 17
      },
      /**
       * Categories of primary expressions from which primitive values that
       * could be consolidated are derivable.
       * @namespace
       * @enum {number}
       */
      EPrimaryExpressionCategories = {
        /**
         * Identifier names used as property accessors.
         * @type {number}
         */
        N_IDENTIFIER_NAMES: 0,
        /**
         * String literals.
         * @type {number}
         */
        N_STRING_LITERALS: 1,
        /**
         * Null and Boolean literals.
         * @type {number}
         */
        N_NULL_AND_BOOLEAN_LITERALS: 2
      },
      /**
       * Prefixes of primitive values that could be consolidated.
       * The String values of the prefixes must have same number of characters.
       * The prefixes must not be used in any properties defined in any version
       * of <a href=
       * "http://www.ecma-international.org/publications/standards/Ecma-262.htm"
       * >ECMA-262</a>.
       * @namespace
       * @enum {string}
       */
      EValuePrefixes = {
        /**
         * Identifies String values.
         * @type {string}
         */
        S_STRING: '#S',
        /**
         * Identifies null and Boolean values.
         * @type {string}
         */
        S_SYMBOLIC: '#O'
      },
      /**
       * Categories of source elements in terms of their appropriateness of
       * having their primitive values consolidated.
       * @namespace
       * @enum {number}
       */
      ESourceElementCategories = {
        /**
         * Identifies a source element that includes the <a href=
         * "http://es5.github.com/#x12.10">{@code with}</a> statement.
         * @type {number}
         */
        N_WITH: 0,
        /**
         * Identifies a source element that includes the <a href=
         * "http://es5.github.com/#x15.1.2.1">{@code eval}</a> identifier name.
         * @type {number}
         */
        N_EVAL: 1,
        /**
         * Identifies a source element that must be excluded from the process
         * unless its whole scope is examined.
         * @type {number}
         */
        N_EXCLUDABLE: 2,
        /**
         * Identifies source elements not posing any problems.
         * @type {number}
         */
        N_OTHER: 3
      },
      /**
       * The list of literals (other than the String ones) whose primitive
       * values can be consolidated.
       * @const
       * @type {!Array.<string>}
       */
      A_OTHER_SUBSTITUTABLE_LITERALS = [
        'null',   // The null literal.
        'false',  // The Boolean literal {@code false}.
        'true'    // The Boolean literal {@code true}.
      ];

  (/**
    * Consolidates all worthwhile primitive values in a syntactic code unit.
    * @param {!TSyntacticCodeUnit} oSyntacticCodeUnit An array-like object
    *     representing the branch of the abstract syntax tree representing the
    *     syntactic code unit along with its scope.
    * @see TPrimitiveValue#nSaving
    */
   function fExamineSyntacticCodeUnit(oSyntacticCodeUnit) {
     var _,
         /**
          * Indicates whether the syntactic code unit represents global code.
          * @type {boolean}
          */
         bIsGlobal = 'toplevel' === oSyntacticCodeUnit[0],
         /**
          * Indicates whether the whole scope is being examined.
          * @type {boolean}
          */
         bIsWhollyExaminable = !bIsGlobal,
         /**
          * An array-like object representing source elements that constitute a
          * syntactic code unit.
          * @type {!TSyntacticCodeUnit}
          */
         oSourceElements,
         /**
          * A record consisting of data about the source element that is
          * currently being examined.
          * @type {!TSourceElementsData}
          */
         oSourceElementData,
         /**
          * The scope of the syntactic code unit.
          * @type {!TScope}
          */
         oScope,
         /**
          * An instance of an object that allows the traversal of an <abbr
          * title="abstract syntax tree">AST</abbr>.
          * @type {!TWalker}
          */
         oWalker,
         /**
          * An object encompassing collections of functions used during the
          * traversal of an <abbr title="abstract syntax tree">AST</abbr>.
          * @namespace
          * @type {!Object.<string, !Object.<string, function(...[*])>>}
          */
         oWalkers = {
           /**
            * A collection of functions used during the surveyance of source
            * elements.
            * @namespace
            * @type {!Object.<string, function(...[*])>}
            */
           oSurveySourceElement: {
             /**#nocode+*/  // JsDoc Toolkit 2.4.0 hides some of the keys.
             /**
              * Classifies the source element as excludable if it does not
              * contain a {@code with} statement or the {@code eval} identifier
              * name. Adds the identifier of the function and its formal
              * parameters to the list of identifier names found.
              * @param {string} sIdentifier The identifier of the function.
              * @param {!Array.<string>} aFormalParameterList Formal parameters.
              * @param {!TSyntacticCodeUnit} oFunctionBody Function code.
              */
             'defun': function(
                 sIdentifier,
                 aFormalParameterList,
                 oFunctionBody) {
               fClassifyAsExcludable();
               fAddIdentifier(sIdentifier);
               aFormalParameterList.forEach(fAddIdentifier);
             },
             /**
              * Increments the count of the number of occurrences of the String
              * value that is equivalent to the sequence of terminal symbols
              * that constitute the encountered identifier name.
              * @param {!TSyntacticCodeUnit} oExpression The nonterminal
              *     MemberExpression.
              * @param {string} sIdentifierName The identifier name used as the
              *     property accessor.
              * @return {!Array} The encountered branch of an <abbr title=
              *     "abstract syntax tree">AST</abbr> with its nonterminal
              *     MemberExpression traversed.
              */
             'dot': function(oExpression, sIdentifierName) {
               fCountPrimaryExpression(
                   EPrimaryExpressionCategories.N_IDENTIFIER_NAMES,
                   EValuePrefixes.S_STRING + sIdentifierName);
               return ['dot', oWalker.walk(oExpression), sIdentifierName];
             },
             /**
              * Adds the optional identifier of the function and its formal
              * parameters to the list of identifier names found.
              * @param {?string} sIdentifier The optional identifier of the
              *     function.
              * @param {!Array.<string>} aFormalParameterList Formal parameters.
              * @param {!TSyntacticCodeUnit} oFunctionBody Function code.
              */
             'function': function(
                 sIdentifier,
                 aFormalParameterList,
                 oFunctionBody) {
               if ('string' === typeof sIdentifier) {
                 fAddIdentifier(sIdentifier);
               }
               aFormalParameterList.forEach(fAddIdentifier);
             },
             /**
              * Either increments the count of the number of occurrences of the
              * encountered null or Boolean value or classifies a source element
              * as containing the {@code eval} identifier name.
              * @param {string} sIdentifier The identifier encountered.
              */
             'name': function(sIdentifier) {
               if (-1 !== A_OTHER_SUBSTITUTABLE_LITERALS.indexOf(sIdentifier)) {
                 fCountPrimaryExpression(
                     EPrimaryExpressionCategories.N_NULL_AND_BOOLEAN_LITERALS,
                     EValuePrefixes.S_SYMBOLIC + sIdentifier);
               } else {
                 if ('eval' === sIdentifier) {
                   oSourceElementData.nCategory =
                       ESourceElementCategories.N_EVAL;
                 }
                 fAddIdentifier(sIdentifier);
               }
             },
             /**
              * Classifies the source element as excludable if it does not
              * contain a {@code with} statement or the {@code eval} identifier
              * name.
              * @param {TSyntacticCodeUnit} oExpression The expression whose
              *     value is to be returned.
              */
             'return': function(oExpression) {
               fClassifyAsExcludable();
             },
             /**
              * Increments the count of the number of occurrences of the
              * encountered String value.
              * @param {string} sStringValue The String value of the string
              *     literal encountered.
              */
             'string': function(sStringValue) {
               if (sStringValue.length > 0) {
                 fCountPrimaryExpression(
                     EPrimaryExpressionCategories.N_STRING_LITERALS,
                     EValuePrefixes.S_STRING + sStringValue);
               }
             },
             /**
              * Adds the identifier reserved for an exception to the list of
              * identifier names found.
              * @param {!TSyntacticCodeUnit} oTry A block of code in which an
              *     exception can occur.
              * @param {Array} aCatch The identifier reserved for an exception
              *     and a block of code to handle the exception.
              * @param {TSyntacticCodeUnit} oFinally An optional block of code
              *     to be evaluated regardless of whether an exception occurs.
              */
             'try': function(oTry, aCatch, oFinally) {
               if (Array.isArray(aCatch)) {
                 fAddIdentifier(aCatch[0]);
               }
             },
             /**
              * Classifies the source element as excludable if it does not
              * contain a {@code with} statement or the {@code eval} identifier
              * name. Adds the identifier of each declared variable to the list
              * of identifier names found.
              * @param {!Array.<!Array>} aVariableDeclarationList Variable
              *     declarations.
              */
             'var': function(aVariableDeclarationList) {
               fClassifyAsExcludable();
               aVariableDeclarationList.forEach(fAddVariable);
             },
             /**
              * Classifies a source element as containing the {@code with}
              * statement.
              * @param {!TSyntacticCodeUnit} oExpression An expression whose
              *     value is to be converted to a value of type Object and
              *     become the binding object of a new object environment
              *     record of a new lexical environment in which the statement
              *     is to be executed.
              * @param {!TSyntacticCodeUnit} oStatement The statement to be
              *     executed in the augmented lexical environment.
              * @return {!Array} An empty array to stop the traversal.
              */
             'with': function(oExpression, oStatement) {
               oSourceElementData.nCategory = ESourceElementCategories.N_WITH;
               return [];
             }
             /**#nocode-*/  // JsDoc Toolkit 2.4.0 hides some of the keys.
           },
           /**
            * A collection of functions used while looking for nested functions.
            * @namespace
            * @type {!Object.<string, function(...[*])>}
            */
           oExamineFunctions: {
             /**#nocode+*/  // JsDoc Toolkit 2.4.0 hides some of the keys.
             /**
              * Orders an examination of a nested function declaration.
              * @this {!TSyntacticCodeUnit} An array-like object representing
              *     the branch of an <abbr title="abstract syntax tree"
              *     >AST</abbr> representing the syntactic code unit along with
              *     its scope.
              * @return {!Array} An empty array to stop the traversal.
              */
             'defun': function() {
               fExamineSyntacticCodeUnit(this);
               return [];
             },
             /**
              * Orders an examination of a nested function expression.
              * @this {!TSyntacticCodeUnit} An array-like object representing
              *     the branch of an <abbr title="abstract syntax tree"
              *     >AST</abbr> representing the syntactic code unit along with
              *     its scope.
              * @return {!Array} An empty array to stop the traversal.
              */
             'function': function() {
               fExamineSyntacticCodeUnit(this);
               return [];
             }
             /**#nocode-*/  // JsDoc Toolkit 2.4.0 hides some of the keys.
           }
         },
         /**
          * Records containing data about source elements.
          * @type {Array.<TSourceElementsData>}
          */
         aSourceElementsData = [],
         /**
          * The index (in the source text order) of the source element
          * immediately following a <a href="http://es5.github.com/#x14.1"
          * >Directive Prologue</a>.
          * @type {number}
          */
         nAfterDirectivePrologue = 0,
         /**
          * The index (in the source text order) of the source element that is
          * currently being considered.
          * @type {number}
          */
         nPosition,
         /**
          * The index (in the source text order) of the source element that is
          * the last element of the range of source elements that is currently
          * being considered.
          * @type {(undefined|number)}
          */
         nTo,
         /**
          * Initiates the traversal of a source element.
          * @param {!TWalker} oWalker An instance of an object that allows the
          *     traversal of an abstract syntax tree.
          * @param {!TSyntacticCodeUnit} oSourceElement A source element from
          *     which the traversal should commence.
          * @return {function(): !TSyntacticCodeUnit} A function that is able to
          *     initiate the traversal from a given source element.
          */
         cContext = function(oWalker, oSourceElement) {
           /**
            * @return {!TSyntacticCodeUnit} A function that is able to
            *     initiate the traversal from a given source element.
            */
           var fLambda = function() {
             return oWalker.walk(oSourceElement);
           };

           return fLambda;
         },
         /**
          * Classifies the source element as excludable if it does not
          * contain a {@code with} statement or the {@code eval} identifier
          * name.
          */
         fClassifyAsExcludable = function() {
           if (oSourceElementData.nCategory ===
               ESourceElementCategories.N_OTHER) {
             oSourceElementData.nCategory =
                 ESourceElementCategories.N_EXCLUDABLE;
           }
         },
         /**
          * Adds an identifier to the list of identifier names found.
          * @param {string} sIdentifier The identifier to be added.
          */
         fAddIdentifier = function(sIdentifier) {
           if (-1 === oSourceElementData.aIdentifiers.indexOf(sIdentifier)) {
             oSourceElementData.aIdentifiers.push(sIdentifier);
           }
         },
         /**
          * Adds the identifier of a variable to the list of identifier names
          * found.
          * @param {!Array} aVariableDeclaration A variable declaration.
          */
         fAddVariable = function(aVariableDeclaration) {
           fAddIdentifier(/** @type {string} */ aVariableDeclaration[0]);
         },
         /**
          * Increments the count of the number of occurrences of the prefixed
          * String representation attributed to the primary expression.
          * @param {number} nCategory The category of the primary expression.
          * @param {string} sName The prefixed String representation attributed
          *     to the primary expression.
          */
         fCountPrimaryExpression = function(nCategory, sName) {
           if (!oSourceElementData.aCount[nCategory].hasOwnProperty(sName)) {
             oSourceElementData.aCount[nCategory][sName] = 0;
             if (-1 === oSourceElementData.aPrimitiveValues.indexOf(sName)) {
               oSourceElementData.aPrimitiveValues.push(sName);
             }
           }
           oSourceElementData.aCount[nCategory][sName] += 1;
         },
         /**
          * Consolidates all worthwhile primitive values in a range of source
          *     elements.
          * @param {number} nFrom The index (in the source text order) of the
          *     source element that is the first element of the range.
          * @param {number} nTo The index (in the source text order) of the
          *     source element that is the last element of the range.
          * @param {boolean} bEnclose Indicates whether the range should be
          *     enclosed within a function call with no argument values to a
          *     function with an empty parameter list if any primitive values
          *     are consolidated.
          * @see TPrimitiveValue#nSaving
          */
         fExamineSourceElements = function(nFrom, nTo, bEnclose) {
           var _,
               /**
                * The index of the last mangled name.
                * @type {number}
                */
               nIndex = oScope.cname,
               /**
                * The index of the source element that is currently being
                * considered.
                * @type {number}
                */
               nPosition,
               /**
                * A collection of functions used during the consolidation of
                * primitive values and identifier names used as property
                * accessors.
                * @namespace
                * @type {!Object.<string, function(...[*])>}
                */
               oWalkersTransformers = {
                 /**
                  * If the String value that is equivalent to the sequence of
                  * terminal symbols that constitute the encountered identifier
                  * name is worthwhile, a syntactic conversion from the dot
                  * notation to the bracket notation ensues with that sequence
                  * being substituted by an identifier name to which the value
                  * is assigned.
                  * Applies to property accessors that use the dot notation.
                  * @param {!TSyntacticCodeUnit} oExpression The nonterminal
                  *     MemberExpression.
                  * @param {string} sIdentifierName The identifier name used as
                  *     the property accessor.
                  * @return {!Array} A syntactic code unit that is equivalent to
                  *     the one encountered.
                  * @see TPrimitiveValue#nSaving
                  */
                 'dot': function(oExpression, sIdentifierName) {
                   /**
                    * The prefixed String value that is equivalent to the
                    * sequence of terminal symbols that constitute the
                    * encountered identifier name.
                    * @type {string}
                    */
                   var sPrefixed = EValuePrefixes.S_STRING + sIdentifierName;

                   return oSolutionBest.oPrimitiveValues.hasOwnProperty(
                       sPrefixed) &&
                       oSolutionBest.oPrimitiveValues[sPrefixed].nSaving > 0 ?
                       ['sub',
                        oWalker.walk(oExpression),
                        ['name',
                         oSolutionBest.oPrimitiveValues[sPrefixed].sName]] :
                       ['dot', oWalker.walk(oExpression), sIdentifierName];
                 },
                 /**
                  * If the encountered identifier is a null or Boolean literal
                  * and its value is worthwhile, the identifier is substituted
                  * by an identifier name to which that value is assigned.
                  * Applies to identifier names.
                  * @param {string} sIdentifier The identifier encountered.
                  * @return {!Array} A syntactic code unit that is equivalent to
                  *     the one encountered.
                  * @see TPrimitiveValue#nSaving
                  */
                 'name': function(sIdentifier) {
                   /**
                    * The prefixed representation String of the identifier.
                    * @type {string}
                    */
                   var sPrefixed = EValuePrefixes.S_SYMBOLIC + sIdentifier;

                   return [
                     'name',
                     oSolutionBest.oPrimitiveValues.hasOwnProperty(sPrefixed) &&
                     oSolutionBest.oPrimitiveValues[sPrefixed].nSaving > 0 ?
                     oSolutionBest.oPrimitiveValues[sPrefixed].sName :
                     sIdentifier
                   ];
                 },
                 /**
                  * If the encountered String value is worthwhile, it is
                  * substituted by an identifier name to which that value is
                  * assigned.
                  * Applies to String values.
                  * @param {string} sStringValue The String value of the string
                  *     literal encountered.
                  * @return {!Array} A syntactic code unit that is equivalent to
                  *     the one encountered.
                  * @see TPrimitiveValue#nSaving
                  */
                 'string': function(sStringValue) {
                   /**
                    * The prefixed representation String of the primitive value
                    * of the literal.
                    * @type {string}
                    */
                   var sPrefixed =
                       EValuePrefixes.S_STRING + sStringValue;

                   return oSolutionBest.oPrimitiveValues.hasOwnProperty(
                       sPrefixed) &&
                       oSolutionBest.oPrimitiveValues[sPrefixed].nSaving > 0 ?
                       ['name',
                        oSolutionBest.oPrimitiveValues[sPrefixed].sName] :
                       ['string', sStringValue];
                 }
               },
               /**
                * Such data on what to consolidate within the range of source
                * elements that is currently being considered that lead to the
                * greatest known reduction of the number of the terminal symbols
                * in comparison to the original source text.
                * @type {!TSolution}
                */
               oSolutionBest = new TSolution(),
               /**
                * Data representing an ongoing attempt to find a better
                * reduction of the number of the terminal symbols in comparison
                * to the original source text than the best one that is
                * currently known.
                * @type {!TSolution}
                * @see oSolutionBest
                */
               oSolutionCandidate = new TSolution(),
               /**
                * A record consisting of data about the range of source elements
                * that is currently being examined.
                * @type {!TSourceElementsData}
                */
               oSourceElementsData = new TSourceElementsData(),
               /**
                * Variable declarations for each primitive value that is to be
                * consolidated within the elements.
                * @type {!Array.<!Array>}
                */
               aVariableDeclarations = [],
               /**
                * Augments a list with a prefixed representation String.
                * @param {!Array.<string>} aList A list that is to be augmented.
                * @return {function(string)} A function that augments a list
                *     with a prefixed representation String.
                */
               cAugmentList = function(aList) {
                 /**
                  * @param {string} sPrefixed Prefixed representation String of
                  *     a primitive value that could be consolidated within the
                  *     elements.
                  */
                 var fLambda = function(sPrefixed) {
                   if (-1 === aList.indexOf(sPrefixed)) {
                     aList.push(sPrefixed);
                   }
                 };

                 return fLambda;
               },
               /**
                * Adds the number of occurrences of a primitive value of a given
                * category that could be consolidated in the source element with
                * a given index to the count of occurrences of that primitive
                * value within the range of source elements that is currently
                * being considered.
                * @param {number} nPosition The index (in the source text order)
                *     of a source element.
                * @param {number} nCategory The category of the primary
                *     expression from which the primitive value is derived.
                * @return {function(string)} A function that performs the
                *     addition.
                * @see cAddOccurrencesInCategory
                */
               cAddOccurrences = function(nPosition, nCategory) {
                 /**
                  * @param {string} sPrefixed The prefixed representation String
                  *     of a primitive value.
                  */
                 var fLambda = function(sPrefixed) {
                   if (!oSourceElementsData.aCount[nCategory].hasOwnProperty(
                           sPrefixed)) {
                     oSourceElementsData.aCount[nCategory][sPrefixed] = 0;
                   }
                   oSourceElementsData.aCount[nCategory][sPrefixed] +=
                       aSourceElementsData[nPosition].aCount[nCategory][
                           sPrefixed];
                 };

                 return fLambda;
               },
               /**
                * Adds the number of occurrences of each primitive value of a
                * given category that could be consolidated in the source
                * element with a given index to the count of occurrences of that
                * primitive values within the range of source elements that is
                * currently being considered.
                * @param {number} nPosition The index (in the source text order)
                *     of a source element.
                * @return {function(number)} A function that performs the
                *     addition.
                * @see fAddOccurrences
                */
               cAddOccurrencesInCategory = function(nPosition) {
                 /**
                  * @param {number} nCategory The category of the primary
                  *     expression from which the primitive value is derived.
                  */
                 var fLambda = function(nCategory) {
                   Object.keys(
                       aSourceElementsData[nPosition].aCount[nCategory]
                   ).forEach(cAddOccurrences(nPosition, nCategory));
                 };

                 return fLambda;
               },
               /**
                * Adds the number of occurrences of each primitive value that
                * could be consolidated in the source element with a given index
                * to the count of occurrences of that primitive values within
                * the range of source elements that is currently being
                * considered.
                * @param {number} nPosition The index (in the source text order)
                *     of a source element.
                */
               fAddOccurrences = function(nPosition) {
                 Object.keys(aSourceElementsData[nPosition].aCount).forEach(
                     cAddOccurrencesInCategory(nPosition));
               },
               /**
                * Creates a variable declaration for a primitive value if that
                * primitive value is to be consolidated within the elements.
                * @param {string} sPrefixed Prefixed representation String of a
                *     primitive value that could be consolidated within the
                *     elements.
                * @see aVariableDeclarations
                */
               cAugmentVariableDeclarations = function(sPrefixed) {
                 if (oSolutionBest.oPrimitiveValues[sPrefixed].nSaving > 0) {
                   aVariableDeclarations.push([
                     oSolutionBest.oPrimitiveValues[sPrefixed].sName,
                     [0 === sPrefixed.indexOf(EValuePrefixes.S_SYMBOLIC) ?
                      'name' : 'string',
                      sPrefixed.substring(EValuePrefixes.S_SYMBOLIC.length)]
                   ]);
                 }
               },
               /**
                * Sorts primitive values with regard to the difference in the
                * number of terminal symbols between the original source text
                * and the one with those primitive values consolidated.
                * @param {string} sPrefixed0 The prefixed representation String
                *     of the first of the two primitive values that are being
                *     compared.
                * @param {string} sPrefixed1 The prefixed representation String
                *     of the second of the two primitive values that are being
                *     compared.
                * @return {number}
                *     <dl>
                *         <dt>-1</dt>
                *         <dd>if the first primitive value must be placed before
                *              the other one,</dd>
                *         <dt>0</dt>
                *         <dd>if the first primitive value may be placed before
                *              the other one,</dd>
                *         <dt>1</dt>
                *         <dd>if the first primitive value must not be placed
                *              before the other one.</dd>
                *     </dl>
                * @see TSolution.oPrimitiveValues
                */
               cSortPrimitiveValues = function(sPrefixed0, sPrefixed1) {
                 /**
                  * The difference between:
                  * <ol>
                  * <li>the difference in the number of terminal symbols
                  *     between the original source text and the one with the
                  *     first primitive value consolidated, and</li>
                  * <li>the difference in the number of terminal symbols
                  *     between the original source text and the one with the
                  *     second primitive value consolidated.</li>
                  * </ol>
                  * @type {number}
                  */
                 var nDifference =
                     oSolutionCandidate.oPrimitiveValues[sPrefixed0].nSaving -
                     oSolutionCandidate.oPrimitiveValues[sPrefixed1].nSaving;

                 return nDifference > 0 ? -1 : nDifference < 0 ? 1 : 0;
               },
               /**
                * Assigns an identifier name to a primitive value and calculates
                * whether instances of that primitive value are worth
                * consolidating.
                * @param {string} sPrefixed The prefixed representation String
                *     of a primitive value that is being evaluated.
                */
               fEvaluatePrimitiveValue = function(sPrefixed) {
                 var _,
                     /**
                      * The index of the last mangled name.
                      * @type {number}
                      */
                     nIndex,
                     /**
                      * The representation String of the primitive value that is
                      * being evaluated.
                      * @type {string}
                      */
                     sName =
                         sPrefixed.substring(EValuePrefixes.S_SYMBOLIC.length),
                     /**
                      * The number of source characters taken up by the
                      * representation String of the primitive value that is
                      * being evaluated.
                      * @type {number}
                      */
                     nLengthOriginal = sName.length,
                     /**
                      * The number of source characters taken up by the
                      * identifier name that could substitute the primitive
                      * value that is being evaluated.
                      * substituted.
                      * @type {number}
                      */
                     nLengthSubstitution,
                     /**
                      * The number of source characters taken up by by the
                      * representation String of the primitive value that is
                      * being evaluated when it is represented by a string
                      * literal.
                      * @type {number}
                      */
                     nLengthString = oProcessor.make_string(sName).length;

                 oSolutionCandidate.oPrimitiveValues[sPrefixed] =
                     new TPrimitiveValue();
                 do {  // Find an identifier unused in this or any nested scope.
                   nIndex = oScope.cname;
                   oSolutionCandidate.oPrimitiveValues[sPrefixed].sName =
                       oScope.next_mangled();
                 } while (-1 !== oSourceElementsData.aIdentifiers.indexOf(
                     oSolutionCandidate.oPrimitiveValues[sPrefixed].sName));
                 nLengthSubstitution = oSolutionCandidate.oPrimitiveValues[
                     sPrefixed].sName.length;
                 if (0 === sPrefixed.indexOf(EValuePrefixes.S_SYMBOLIC)) {
                   // foo:null, or foo:null;
                   oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving -=
                       nLengthSubstitution + nLengthOriginal +
                       oWeights.N_VARIABLE_DECLARATION;
                   // null vs foo
                   oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving +=
                       oSourceElementsData.aCount[
                           EPrimaryExpressionCategories.
                               N_NULL_AND_BOOLEAN_LITERALS][sPrefixed] *
                       (nLengthOriginal - nLengthSubstitution);
                 } else {
                   // foo:'fromCharCode';
                   oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving -=
                       nLengthSubstitution + nLengthString +
                       oWeights.N_VARIABLE_DECLARATION;
                   // .fromCharCode vs [foo]
                   if (oSourceElementsData.aCount[
                           EPrimaryExpressionCategories.N_IDENTIFIER_NAMES
                       ].hasOwnProperty(sPrefixed)) {
                     oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving +=
                         oSourceElementsData.aCount[
                             EPrimaryExpressionCategories.N_IDENTIFIER_NAMES
                         ][sPrefixed] *
                         (nLengthOriginal - nLengthSubstitution -
                          oWeights.N_PROPERTY_ACCESSOR);
                   }
                   // 'fromCharCode' vs foo
                   if (oSourceElementsData.aCount[
                           EPrimaryExpressionCategories.N_STRING_LITERALS
                       ].hasOwnProperty(sPrefixed)) {
                     oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving +=
                         oSourceElementsData.aCount[
                             EPrimaryExpressionCategories.N_STRING_LITERALS
                         ][sPrefixed] *
                         (nLengthString - nLengthSubstitution);
                   }
                 }
                 if (oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving >
                     0) {
                   oSolutionCandidate.nSavings +=
                       oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving;
                 } else {
                   oScope.cname = nIndex; // Free the identifier name.
                 }
               },
               /**
                * Adds a variable declaration to an existing variable statement.
                * @param {!Array} aVariableDeclaration A variable declaration
                *     with an initialiser.
                */
               cAddVariableDeclaration = function(aVariableDeclaration) {
                 (/** @type {!Array} */ oSourceElements[nFrom][1]).unshift(
                     aVariableDeclaration);
               };

           if (nFrom > nTo) {
             return;
           }
           // If the range is a closure, reuse the closure.
           if (nFrom === nTo &&
               'stat' === oSourceElements[nFrom][0] &&
               'call' === oSourceElements[nFrom][1][0] &&
               'function' === oSourceElements[nFrom][1][1][0]) {
             fExamineSyntacticCodeUnit(oSourceElements[nFrom][1][1]);
             return;
           }
           // Create a list of all derived primitive values within the range.
           for (nPosition = nFrom; nPosition <= nTo; nPosition += 1) {
             aSourceElementsData[nPosition].aPrimitiveValues.forEach(
                 cAugmentList(oSourceElementsData.aPrimitiveValues));
           }
           if (0 === oSourceElementsData.aPrimitiveValues.length) {
             return;
           }
           for (nPosition = nFrom; nPosition <= nTo; nPosition += 1) {
             // Add the number of occurrences to the total count.
             fAddOccurrences(nPosition);
             // Add identifiers of this or any nested scope to the list.
             aSourceElementsData[nPosition].aIdentifiers.forEach(
                 cAugmentList(oSourceElementsData.aIdentifiers));
           }
           // Distribute identifier names among derived primitive values.
           do {  // If there was any progress, find a better distribution.
             oSolutionBest = oSolutionCandidate;
             if (Object.keys(oSolutionCandidate.oPrimitiveValues).length > 0) {
               // Sort primitive values descending by their worthwhileness.
               oSourceElementsData.aPrimitiveValues.sort(cSortPrimitiveValues);
             }
             oSolutionCandidate = new TSolution();
             oSourceElementsData.aPrimitiveValues.forEach(
                 fEvaluatePrimitiveValue);
             oScope.cname = nIndex;
           } while (oSolutionCandidate.nSavings > oSolutionBest.nSavings);
           // Take the necessity of adding a variable statement into account.
           if ('var' !== oSourceElements[nFrom][0]) {
             oSolutionBest.nSavings -= oWeights.N_VARIABLE_STATEMENT_AFFIXATION;
           }
           if (bEnclose) {
             // Take the necessity of forming a closure into account.
             oSolutionBest.nSavings -= oWeights.N_CLOSURE;
           }
           if (oSolutionBest.nSavings > 0) {
             // Create variable declarations suitable for UglifyJS.
             Object.keys(oSolutionBest.oPrimitiveValues).forEach(
                 cAugmentVariableDeclarations);
             // Rewrite expressions that contain worthwhile primitive values.
             for (nPosition = nFrom; nPosition <= nTo; nPosition += 1) {
               oWalker = oProcessor.ast_walker();
               oSourceElements[nPosition] =
                   oWalker.with_walkers(
                       oWalkersTransformers,
                       cContext(oWalker, oSourceElements[nPosition]));
             }
             if ('var' === oSourceElements[nFrom][0]) {  // Reuse the statement.
               (/** @type {!Array.<!Array>} */ aVariableDeclarations.reverse(
                   )).forEach(cAddVariableDeclaration);
             } else {  // Add a variable statement.
               Array.prototype.splice.call(
                   oSourceElements,
                   nFrom,
                   0,
                   ['var', aVariableDeclarations]);
               nTo += 1;
             }
             if (bEnclose) {
               // Add a closure.
               Array.prototype.splice.call(
                   oSourceElements,
                   nFrom,
                   0,
                   ['stat', ['call', ['function', null, [], []], []]]);
               // Copy source elements into the closure.
               for (nPosition = nTo + 1; nPosition > nFrom; nPosition -= 1) {
                 Array.prototype.unshift.call(
                     oSourceElements[nFrom][1][1][3],
                     oSourceElements[nPosition]);
               }
               // Remove source elements outside the closure.
               Array.prototype.splice.call(
                   oSourceElements,
                   nFrom + 1,
                   nTo - nFrom + 1);
             }
           }
           if (bEnclose) {
             // Restore the availability of identifier names.
             oScope.cname = nIndex;
           }
         };

     oSourceElements = (/** @type {!TSyntacticCodeUnit} */
         oSyntacticCodeUnit[bIsGlobal ? 1 : 3]);
     if (0 === oSourceElements.length) {
       return;
     }
     oScope = bIsGlobal ? oSyntacticCodeUnit.scope : oSourceElements.scope;
     // Skip a Directive Prologue.
     while (nAfterDirectivePrologue < oSourceElements.length &&
            'directive' === oSourceElements[nAfterDirectivePrologue][0]) {
       nAfterDirectivePrologue += 1;
       aSourceElementsData.push(null);
     }
     if (oSourceElements.length === nAfterDirectivePrologue) {
       return;
     }
     for (nPosition = nAfterDirectivePrologue;
          nPosition < oSourceElements.length;
          nPosition += 1) {
       oSourceElementData = new TSourceElementsData();
       oWalker = oProcessor.ast_walker();
       // Classify a source element.
       // Find its derived primitive values and count their occurrences.
       // Find all identifiers used (including nested scopes).
       oWalker.with_walkers(
           oWalkers.oSurveySourceElement,
           cContext(oWalker, oSourceElements[nPosition]));
       // Establish whether the scope is still wholly examinable.
       bIsWhollyExaminable = bIsWhollyExaminable &&
           ESourceElementCategories.N_WITH !== oSourceElementData.nCategory &&
           ESourceElementCategories.N_EVAL !== oSourceElementData.nCategory;
       aSourceElementsData.push(oSourceElementData);
     }
     if (bIsWhollyExaminable) {  // Examine the whole scope.
       fExamineSourceElements(
           nAfterDirectivePrologue,
           oSourceElements.length - 1,
           false);
     } else {  // Examine unexcluded ranges of source elements.
       for (nPosition = oSourceElements.length - 1;
            nPosition >= nAfterDirectivePrologue;
            nPosition -= 1) {
         oSourceElementData = (/** @type {!TSourceElementsData} */
             aSourceElementsData[nPosition]);
         if (ESourceElementCategories.N_OTHER ===
             oSourceElementData.nCategory) {
           if ('undefined' === typeof nTo) {
             nTo = nPosition;  // Indicate the end of a range.
           }
           // Examine the range if it immediately follows a Directive Prologue.
           if (nPosition === nAfterDirectivePrologue) {
             fExamineSourceElements(nPosition, nTo, true);
           }
         } else {
           if ('undefined' !== typeof nTo) {
             // Examine the range that immediately follows this source element.
             fExamineSourceElements(nPosition + 1, nTo, true);
             nTo = void 0;  // Obliterate the range.
           }
           // Examine nested functions.
           oWalker = oProcessor.ast_walker();
           oWalker.with_walkers(
               oWalkers.oExamineFunctions,
               cContext(oWalker, oSourceElements[nPosition]));
         }
       }
     }
   }(oAbstractSyntaxTree = oProcessor.ast_add_scope(oAbstractSyntaxTree)));
  return oAbstractSyntaxTree;
};
/*jshint sub:false */

/* Local Variables:      */
/* mode: js              */
/* coding: utf-8         */
/* indent-tabs-mode: nil */
/* tab-width: 2          */
/* End:                  */
/* vim: set ft=javascript fenc=utf-8 et ts=2 sts=2 sw=2: */
/* :mode=javascript:noTabs=true:tabSize=2:indentSize=2:deepIndent=true: */


},{"./process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/process.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/parse-js.js":[function(require,module,exports){
/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.

  This version is suitable for Node.js.  With minimal changes (the
  exports stuff) it should work on any JS platform.

  This file contains the tokenizer/parser.  It is a port to JavaScript
  of parse-js [1], a JavaScript parser library written in Common Lisp
  by Marijn Haverbeke.  Thank you Marijn!

  [1] http://marijn.haverbeke.nl/parse-js/

  Exported functions:

    - tokenizer(code) -- returns a function.  Call the returned
      function to fetch the next token.

    - parse(code) -- returns an AST of the given JavaScript code.

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2010 (c) Mihai Bazon <mihai.bazon@gmail.com>
    Based on parse-js (http://marijn.haverbeke.nl/parse-js/).

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

/* -----[ Tokenizer (constants) ]----- */

var KEYWORDS = array_to_hash([
        "break",
        "case",
        "catch",
        "const",
        "continue",
        "debugger",
        "default",
        "delete",
        "do",
        "else",
        "finally",
        "for",
        "function",
        "if",
        "in",
        "instanceof",
        "new",
        "return",
        "switch",
        "throw",
        "try",
        "typeof",
        "var",
        "void",
        "while",
        "with"
]);

var RESERVED_WORDS = array_to_hash([
        "abstract",
        "boolean",
        "byte",
        "char",
        "class",
        "double",
        "enum",
        "export",
        "extends",
        "final",
        "float",
        "goto",
        "implements",
        "import",
        "int",
        "interface",
        "long",
        "native",
        "package",
        "private",
        "protected",
        "public",
        "short",
        "static",
        "super",
        "synchronized",
        "throws",
        "transient",
        "volatile"
]);

var KEYWORDS_BEFORE_EXPRESSION = array_to_hash([
        "return",
        "new",
        "delete",
        "throw",
        "else",
        "case"
]);

var KEYWORDS_ATOM = array_to_hash([
        "false",
        "null",
        "true",
        "undefined"
]);

var OPERATOR_CHARS = array_to_hash(characters("+-*&%=<>!?|~^"));

var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;
var RE_OCT_NUMBER = /^0[0-7]+$/;
var RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i;

var OPERATORS = array_to_hash([
        "in",
        "instanceof",
        "typeof",
        "new",
        "void",
        "delete",
        "++",
        "--",
        "+",
        "-",
        "!",
        "~",
        "&",
        "|",
        "^",
        "*",
        "/",
        "%",
        ">>",
        "<<",
        ">>>",
        "<",
        ">",
        "<=",
        ">=",
        "==",
        "===",
        "!=",
        "!==",
        "?",
        "=",
        "+=",
        "-=",
        "/=",
        "*=",
        "%=",
        ">>=",
        "<<=",
        ">>>=",
        "|=",
        "^=",
        "&=",
        "&&",
        "||"
]);

var WHITESPACE_CHARS = array_to_hash(characters(" \u00a0\n\r\t\f\u000b\u200b\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000"));

var PUNC_BEFORE_EXPRESSION = array_to_hash(characters("[{(,.;:"));

var PUNC_CHARS = array_to_hash(characters("[]{}(),;:"));

var REGEXP_MODIFIERS = array_to_hash(characters("gmsiy"));

/* -----[ Tokenizer ]----- */

var UNICODE = {  // Unicode 6.1
        letter: new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
        combining_mark: new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08E4-\\u08FE\\u0900-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C01-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C82\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D02\\u0D03\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F\\u109A-\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF2-\\u1CF4\\u1DC0-\\u1DE6\\u1DFC-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA674-\\uA67D\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA7B\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),
        connector_punctuation: new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]"),
        digit: new RegExp("[\\u0030-\\u0039\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]")
};

function is_letter(ch) {
        return UNICODE.letter.test(ch);
};

function is_digit(ch) {
        ch = ch.charCodeAt(0);
        return ch >= 48 && ch <= 57;
};

function is_unicode_digit(ch) {
        return UNICODE.digit.test(ch);
}

function is_alphanumeric_char(ch) {
        return is_digit(ch) || is_letter(ch);
};

function is_unicode_combining_mark(ch) {
        return UNICODE.combining_mark.test(ch);
};

function is_unicode_connector_punctuation(ch) {
        return UNICODE.connector_punctuation.test(ch);
};

function is_identifier_start(ch) {
        return ch == "$" || ch == "_" || is_letter(ch);
};

function is_identifier_char(ch) {
        return is_identifier_start(ch)
                || is_unicode_combining_mark(ch)
                || is_unicode_digit(ch)
                || is_unicode_connector_punctuation(ch)
                || ch == "\u200c" // zero-width non-joiner <ZWNJ>
                || ch == "\u200d" // zero-width joiner <ZWJ> (in my ECMA-262 PDF, this is also 200c)
        ;
};

function parse_js_number(num) {
        if (RE_HEX_NUMBER.test(num)) {
                return parseInt(num.substr(2), 16);
        } else if (RE_OCT_NUMBER.test(num)) {
                return parseInt(num.substr(1), 8);
        } else if (RE_DEC_NUMBER.test(num)) {
                return parseFloat(num);
        }
};

function JS_Parse_Error(message, line, col, pos) {
        this.message = message;
        this.line = line + 1;
        this.col = col + 1;
        this.pos = pos + 1;
        this.stack = new Error().stack;
};

JS_Parse_Error.prototype.toString = function() {
        return this.message + " (line: " + this.line + ", col: " + this.col + ", pos: " + this.pos + ")" + "\n\n" + this.stack;
};

function js_error(message, line, col, pos) {
        throw new JS_Parse_Error(message, line, col, pos);
};

function is_token(token, type, val) {
        return token.type == type && (val == null || token.value == val);
};

var EX_EOF = {};

function tokenizer($TEXT) {

        var S = {
                text            : $TEXT.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/^\uFEFF/, ''),
                pos             : 0,
                tokpos          : 0,
                line            : 0,
                tokline         : 0,
                col             : 0,
                tokcol          : 0,
                newline_before  : false,
                regex_allowed   : false,
                comments_before : []
        };

        function peek() { return S.text.charAt(S.pos); };

        function next(signal_eof, in_string) {
                var ch = S.text.charAt(S.pos++);
                if (signal_eof && !ch)
                        throw EX_EOF;
                if (ch == "\n") {
                        S.newline_before = S.newline_before || !in_string;
                        ++S.line;
                        S.col = 0;
                } else {
                        ++S.col;
                }
                return ch;
        };

        function eof() {
                return !S.peek();
        };

        function find(what, signal_eof) {
                var pos = S.text.indexOf(what, S.pos);
                if (signal_eof && pos == -1) throw EX_EOF;
                return pos;
        };

        function start_token() {
                S.tokline = S.line;
                S.tokcol = S.col;
                S.tokpos = S.pos;
        };

        function token(type, value, is_comment) {
                S.regex_allowed = ((type == "operator" && !HOP(UNARY_POSTFIX, value)) ||
                                   (type == "keyword" && HOP(KEYWORDS_BEFORE_EXPRESSION, value)) ||
                                   (type == "punc" && HOP(PUNC_BEFORE_EXPRESSION, value)));
                var ret = {
                        type   : type,
                        value  : value,
                        line   : S.tokline,
                        col    : S.tokcol,
                        pos    : S.tokpos,
                        endpos : S.pos,
                        nlb    : S.newline_before
                };
                if (!is_comment) {
                        ret.comments_before = S.comments_before;
                        S.comments_before = [];
                        // make note of any newlines in the comments that came before
                        for (var i = 0, len = ret.comments_before.length; i < len; i++) {
                                ret.nlb = ret.nlb || ret.comments_before[i].nlb;
                        }
                }
                S.newline_before = false;
                return ret;
        };

        function skip_whitespace() {
                while (HOP(WHITESPACE_CHARS, peek()))
                        next();
        };

        function read_while(pred) {
                var ret = "", ch = peek(), i = 0;
                while (ch && pred(ch, i++)) {
                        ret += next();
                        ch = peek();
                }
                return ret;
        };

        function parse_error(err) {
                js_error(err, S.tokline, S.tokcol, S.tokpos);
        };

        function read_num(prefix) {
                var has_e = false, after_e = false, has_x = false, has_dot = prefix == ".";
                var num = read_while(function(ch, i){
                        if (ch == "x" || ch == "X") {
                                if (has_x) return false;
                                return has_x = true;
                        }
                        if (!has_x && (ch == "E" || ch == "e")) {
                                if (has_e) return false;
                                return has_e = after_e = true;
                        }
                        if (ch == "-") {
                                if (after_e || (i == 0 && !prefix)) return true;
                                return false;
                        }
                        if (ch == "+") return after_e;
                        after_e = false;
                        if (ch == ".") {
                                if (!has_dot && !has_x && !has_e)
                                        return has_dot = true;
                                return false;
                        }
                        return is_alphanumeric_char(ch);
                });
                if (prefix)
                        num = prefix + num;
                var valid = parse_js_number(num);
                if (!isNaN(valid)) {
                        return token("num", valid);
                } else {
                        parse_error("Invalid syntax: " + num);
                }
        };

        function read_escaped_char(in_string) {
                var ch = next(true, in_string);
                switch (ch) {
                    case "n" : return "\n";
                    case "r" : return "\r";
                    case "t" : return "\t";
                    case "b" : return "\b";
                    case "v" : return "\u000b";
                    case "f" : return "\f";
                    case "0" : return "\0";
                    case "x" : return String.fromCharCode(hex_bytes(2));
                    case "u" : return String.fromCharCode(hex_bytes(4));
                    case "\n": return "";
                    default  : return ch;
                }
        };

        function hex_bytes(n) {
                var num = 0;
                for (; n > 0; --n) {
                        var digit = parseInt(next(true), 16);
                        if (isNaN(digit))
                                parse_error("Invalid hex-character pattern in string");
                        num = (num << 4) | digit;
                }
                return num;
        };

        function read_string() {
                return with_eof_error("Unterminated string constant", function(){
                        var quote = next(), ret = "";
                        for (;;) {
                                var ch = next(true);
                                if (ch == "\\") {
                                        // read OctalEscapeSequence (XXX: deprecated if "strict mode")
                                        // https://github.com/mishoo/UglifyJS/issues/178
                                        var octal_len = 0, first = null;
                                        ch = read_while(function(ch){
                                                if (ch >= "0" && ch <= "7") {
                                                        if (!first) {
                                                                first = ch;
                                                                return ++octal_len;
                                                        }
                                                        else if (first <= "3" && octal_len <= 2) return ++octal_len;
                                                        else if (first >= "4" && octal_len <= 1) return ++octal_len;
                                                }
                                                return false;
                                        });
                                        if (octal_len > 0) ch = String.fromCharCode(parseInt(ch, 8));
                                        else ch = read_escaped_char(true);
                                }
                                else if (ch == quote) break;
                                ret += ch;
                        }
                        return token("string", ret);
                });
        };

        function read_line_comment() {
                next();
                var i = find("\n"), ret;
                if (i == -1) {
                        ret = S.text.substr(S.pos);
                        S.pos = S.text.length;
                } else {
                        ret = S.text.substring(S.pos, i);
                        S.pos = i;
                }
                return token("comment1", ret, true);
        };

        function read_multiline_comment() {
                next();
                return with_eof_error("Unterminated multiline comment", function(){
                        var i = find("*/", true),
                            text = S.text.substring(S.pos, i);
                        S.pos = i + 2;
                        S.line += text.split("\n").length - 1;
                        S.newline_before = S.newline_before || text.indexOf("\n") >= 0;

                        // https://github.com/mishoo/UglifyJS/issues/#issue/100
                        if (/^@cc_on/i.test(text)) {
                                warn("WARNING: at line " + S.line);
                                warn("*** Found \"conditional comment\": " + text);
                                warn("*** UglifyJS DISCARDS ALL COMMENTS.  This means your code might no longer work properly in Internet Explorer.");
                        }

                        return token("comment2", text, true);
                });
        };

        function read_name() {
                var backslash = false, name = "", ch, escaped = false, hex;
                while ((ch = peek()) != null) {
                        if (!backslash) {
                                if (ch == "\\") escaped = backslash = true, next();
                                else if (is_identifier_char(ch)) name += next();
                                else break;
                        }
                        else {
                                if (ch != "u") parse_error("Expecting UnicodeEscapeSequence -- uXXXX");
                                ch = read_escaped_char();
                                if (!is_identifier_char(ch)) parse_error("Unicode char: " + ch.charCodeAt(0) + " is not valid in identifier");
                                name += ch;
                                backslash = false;
                        }
                }
                if (HOP(KEYWORDS, name) && escaped) {
                        hex = name.charCodeAt(0).toString(16).toUpperCase();
                        name = "\\u" + "0000".substr(hex.length) + hex + name.slice(1);
                }
                return name;
        };

        function read_regexp(regexp) {
                return with_eof_error("Unterminated regular expression", function(){
                        var prev_backslash = false, ch, in_class = false;
                        while ((ch = next(true))) if (prev_backslash) {
                                regexp += "\\" + ch;
                                prev_backslash = false;
                        } else if (ch == "[") {
                                in_class = true;
                                regexp += ch;
                        } else if (ch == "]" && in_class) {
                                in_class = false;
                                regexp += ch;
                        } else if (ch == "/" && !in_class) {
                                break;
                        } else if (ch == "\\") {
                                prev_backslash = true;
                        } else {
                                regexp += ch;
                        }
                        var mods = read_name();
                        return token("regexp", [ regexp, mods ]);
                });
        };

        function read_operator(prefix) {
                function grow(op) {
                        if (!peek()) return op;
                        var bigger = op + peek();
                        if (HOP(OPERATORS, bigger)) {
                                next();
                                return grow(bigger);
                        } else {
                                return op;
                        }
                };
                return token("operator", grow(prefix || next()));
        };

        function handle_slash() {
                next();
                var regex_allowed = S.regex_allowed;
                switch (peek()) {
                    case "/":
                        S.comments_before.push(read_line_comment());
                        S.regex_allowed = regex_allowed;
                        return next_token();
                    case "*":
                        S.comments_before.push(read_multiline_comment());
                        S.regex_allowed = regex_allowed;
                        return next_token();
                }
                return S.regex_allowed ? read_regexp("") : read_operator("/");
        };

        function handle_dot() {
                next();
                return is_digit(peek())
                        ? read_num(".")
                        : token("punc", ".");
        };

        function read_word() {
                var word = read_name();
                return !HOP(KEYWORDS, word)
                        ? token("name", word)
                        : HOP(OPERATORS, word)
                        ? token("operator", word)
                        : HOP(KEYWORDS_ATOM, word)
                        ? token("atom", word)
                        : token("keyword", word);
        };

        function with_eof_error(eof_error, cont) {
                try {
                        return cont();
                } catch(ex) {
                        if (ex === EX_EOF) parse_error(eof_error);
                        else throw ex;
                }
        };

        function next_token(force_regexp) {
                if (force_regexp != null)
                        return read_regexp(force_regexp);
                skip_whitespace();
                start_token();
                var ch = peek();
                if (!ch) return token("eof");
                if (is_digit(ch)) return read_num();
                if (ch == '"' || ch == "'") return read_string();
                if (HOP(PUNC_CHARS, ch)) return token("punc", next());
                if (ch == ".") return handle_dot();
                if (ch == "/") return handle_slash();
                if (HOP(OPERATOR_CHARS, ch)) return read_operator();
                if (ch == "\\" || is_identifier_start(ch)) return read_word();
                parse_error("Unexpected character '" + ch + "'");
        };

        next_token.context = function(nc) {
                if (nc) S = nc;
                return S;
        };

        return next_token;

};

/* -----[ Parser (constants) ]----- */

var UNARY_PREFIX = array_to_hash([
        "typeof",
        "void",
        "delete",
        "--",
        "++",
        "!",
        "~",
        "-",
        "+"
]);

var UNARY_POSTFIX = array_to_hash([ "--", "++" ]);

var ASSIGNMENT = (function(a, ret, i){
        while (i < a.length) {
                ret[a[i]] = a[i].substr(0, a[i].length - 1);
                i++;
        }
        return ret;
})(
        ["+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&="],
        { "=": true },
        0
);

var PRECEDENCE = (function(a, ret){
        for (var i = 0, n = 1; i < a.length; ++i, ++n) {
                var b = a[i];
                for (var j = 0; j < b.length; ++j) {
                        ret[b[j]] = n;
                }
        }
        return ret;
})(
        [
                ["||"],
                ["&&"],
                ["|"],
                ["^"],
                ["&"],
                ["==", "===", "!=", "!=="],
                ["<", ">", "<=", ">=", "in", "instanceof"],
                [">>", "<<", ">>>"],
                ["+", "-"],
                ["*", "/", "%"]
        ],
        {}
);

var STATEMENTS_WITH_LABELS = array_to_hash([ "for", "do", "while", "switch" ]);

var ATOMIC_START_TOKEN = array_to_hash([ "atom", "num", "string", "regexp", "name" ]);

/* -----[ Parser ]----- */

function NodeWithToken(str, start, end) {
        this.name = str;
        this.start = start;
        this.end = end;
};

NodeWithToken.prototype.toString = function() { return this.name; };

function parse($TEXT, exigent_mode, embed_tokens) {

        var S = {
                input         : typeof $TEXT == "string" ? tokenizer($TEXT, true) : $TEXT,
                token         : null,
                prev          : null,
                peeked        : null,
                in_function   : 0,
                in_directives : true,
                in_loop       : 0,
                labels        : []
        };

        S.token = next();

        function is(type, value) {
                return is_token(S.token, type, value);
        };

        function peek() { return S.peeked || (S.peeked = S.input()); };

        function next() {
                S.prev = S.token;
                if (S.peeked) {
                        S.token = S.peeked;
                        S.peeked = null;
                } else {
                        S.token = S.input();
                }
                S.in_directives = S.in_directives && (
                        S.token.type == "string" || is("punc", ";")
                );
                return S.token;
        };

        function prev() {
                return S.prev;
        };

        function croak(msg, line, col, pos) {
                var ctx = S.input.context();
                js_error(msg,
                         line != null ? line : ctx.tokline,
                         col != null ? col : ctx.tokcol,
                         pos != null ? pos : ctx.tokpos);
        };

        function token_error(token, msg) {
                croak(msg, token.line, token.col);
        };

        function unexpected(token) {
                if (token == null)
                        token = S.token;
                token_error(token, "Unexpected token: " + token.type + " (" + token.value + ")");
        };

        function expect_token(type, val) {
                if (is(type, val)) {
                        return next();
                }
                token_error(S.token, "Unexpected token " + S.token.type + ", expected " + type);
        };

        function expect(punc) { return expect_token("punc", punc); };

        function can_insert_semicolon() {
                return !exigent_mode && (
                        S.token.nlb || is("eof") || is("punc", "}")
                );
        };

        function semicolon() {
                if (is("punc", ";")) next();
                else if (!can_insert_semicolon()) unexpected();
        };

        function as() {
                return slice(arguments);
        };

        function parenthesised() {
                expect("(");
                var ex = expression();
                expect(")");
                return ex;
        };

        function add_tokens(str, start, end) {
                return str instanceof NodeWithToken ? str : new NodeWithToken(str, start, end);
        };

        function maybe_embed_tokens(parser) {
                if (embed_tokens) return function() {
                        var start = S.token;
                        var ast = parser.apply(this, arguments);
                        ast[0] = add_tokens(ast[0], start, prev());
                        return ast;
                };
                else return parser;
        };

        var statement = maybe_embed_tokens(function() {
                if (is("operator", "/") || is("operator", "/=")) {
                        S.peeked = null;
                        S.token = S.input(S.token.value.substr(1)); // force regexp
                }
                switch (S.token.type) {
                    case "string":
                        var dir = S.in_directives, stat = simple_statement();
                        if (dir && stat[1][0] == "string" && !is("punc", ","))
                            return as("directive", stat[1][1]);
                        return stat;
                    case "num":
                    case "regexp":
                    case "operator":
                    case "atom":
                        return simple_statement();

                    case "name":
                        return is_token(peek(), "punc", ":")
                                ? labeled_statement(prog1(S.token.value, next, next))
                                : simple_statement();

                    case "punc":
                        switch (S.token.value) {
                            case "{":
                                return as("block", block_());
                            case "[":
                            case "(":
                                return simple_statement();
                            case ";":
                                next();
                                return as("block");
                            default:
                                unexpected();
                        }

                    case "keyword":
                        switch (prog1(S.token.value, next)) {
                            case "break":
                                return break_cont("break");

                            case "continue":
                                return break_cont("continue");

                            case "debugger":
                                semicolon();
                                return as("debugger");

                            case "do":
                                return (function(body){
                                        expect_token("keyword", "while");
                                        return as("do", prog1(parenthesised, semicolon), body);
                                })(in_loop(statement));

                            case "for":
                                return for_();

                            case "function":
                                return function_(true);

                            case "if":
                                return if_();

                            case "return":
                                if (S.in_function == 0)
                                        croak("'return' outside of function");
                                return as("return",
                                          is("punc", ";")
                                          ? (next(), null)
                                          : can_insert_semicolon()
                                          ? null
                                          : prog1(expression, semicolon));

                            case "switch":
                                return as("switch", parenthesised(), switch_block_());

                            case "throw":
                                if (S.token.nlb)
                                        croak("Illegal newline after 'throw'");
                                return as("throw", prog1(expression, semicolon));

                            case "try":
                                return try_();

                            case "var":
                                return prog1(var_, semicolon);

                            case "const":
                                return prog1(const_, semicolon);

                            case "while":
                                return as("while", parenthesised(), in_loop(statement));

                            case "with":
                                return as("with", parenthesised(), statement());

                            default:
                                unexpected();
                        }
                }
        });

        function labeled_statement(label) {
                S.labels.push(label);
                var start = S.token, stat = statement();
                if (exigent_mode && !HOP(STATEMENTS_WITH_LABELS, stat[0]))
                        unexpected(start);
                S.labels.pop();
                return as("label", label, stat);
        };

        function simple_statement() {
                return as("stat", prog1(expression, semicolon));
        };

        function break_cont(type) {
                var name;
                if (!can_insert_semicolon()) {
                        name = is("name") ? S.token.value : null;
                }
                if (name != null) {
                        next();
                        if (!member(name, S.labels))
                                croak("Label " + name + " without matching loop or statement");
                }
                else if (S.in_loop == 0)
                        croak(type + " not inside a loop or switch");
                semicolon();
                return as(type, name);
        };

        function for_() {
                expect("(");
                var init = null;
                if (!is("punc", ";")) {
                        init = is("keyword", "var")
                                ? (next(), var_(true))
                                : expression(true, true);
                        if (is("operator", "in")) {
                                if (init[0] == "var" && init[1].length > 1)
                                        croak("Only one variable declaration allowed in for..in loop");
                                return for_in(init);
                        }
                }
                return regular_for(init);
        };

        function regular_for(init) {
                expect(";");
                var test = is("punc", ";") ? null : expression();
                expect(";");
                var step = is("punc", ")") ? null : expression();
                expect(")");
                return as("for", init, test, step, in_loop(statement));
        };

        function for_in(init) {
                var lhs = init[0] == "var" ? as("name", init[1][0]) : init;
                next();
                var obj = expression();
                expect(")");
                return as("for-in", init, lhs, obj, in_loop(statement));
        };

        var function_ = function(in_statement) {
                var name = is("name") ? prog1(S.token.value, next) : null;
                if (in_statement && !name)
                        unexpected();
                expect("(");
                return as(in_statement ? "defun" : "function",
                          name,
                          // arguments
                          (function(first, a){
                                  while (!is("punc", ")")) {
                                          if (first) first = false; else expect(",");
                                          if (!is("name")) unexpected();
                                          a.push(S.token.value);
                                          next();
                                  }
                                  next();
                                  return a;
                          })(true, []),
                          // body
                          (function(){
                                  ++S.in_function;
                                  var loop = S.in_loop;
                                  S.in_directives = true;
                                  S.in_loop = 0;
                                  var a = block_();
                                  --S.in_function;
                                  S.in_loop = loop;
                                  return a;
                          })());
        };

        function if_() {
                var cond = parenthesised(), body = statement(), belse;
                if (is("keyword", "else")) {
                        next();
                        belse = statement();
                }
                return as("if", cond, body, belse);
        };

        function block_() {
                expect("{");
                var a = [];
                while (!is("punc", "}")) {
                        if (is("eof")) unexpected();
                        a.push(statement());
                }
                next();
                return a;
        };

        var switch_block_ = curry(in_loop, function(){
                expect("{");
                var a = [], cur = null;
                while (!is("punc", "}")) {
                        if (is("eof")) unexpected();
                        if (is("keyword", "case")) {
                                next();
                                cur = [];
                                a.push([ expression(), cur ]);
                                expect(":");
                        }
                        else if (is("keyword", "default")) {
                                next();
                                expect(":");
                                cur = [];
                                a.push([ null, cur ]);
                        }
                        else {
                                if (!cur) unexpected();
                                cur.push(statement());
                        }
                }
                next();
                return a;
        });

        function try_() {
                var body = block_(), bcatch, bfinally;
                if (is("keyword", "catch")) {
                        next();
                        expect("(");
                        if (!is("name"))
                                croak("Name expected");
                        var name = S.token.value;
                        next();
                        expect(")");
                        bcatch = [ name, block_() ];
                }
                if (is("keyword", "finally")) {
                        next();
                        bfinally = block_();
                }
                if (!bcatch && !bfinally)
                        croak("Missing catch/finally blocks");
                return as("try", body, bcatch, bfinally);
        };

        function vardefs(no_in) {
                var a = [];
                for (;;) {
                        if (!is("name"))
                                unexpected();
                        var name = S.token.value;
                        next();
                        if (is("operator", "=")) {
                                next();
                                a.push([ name, expression(false, no_in) ]);
                        } else {
                                a.push([ name ]);
                        }
                        if (!is("punc", ","))
                                break;
                        next();
                }
                return a;
        };

        function var_(no_in) {
                return as("var", vardefs(no_in));
        };

        function const_() {
                return as("const", vardefs());
        };

        function new_() {
                var newexp = expr_atom(false), args;
                if (is("punc", "(")) {
                        next();
                        args = expr_list(")");
                } else {
                        args = [];
                }
                return subscripts(as("new", newexp, args), true);
        };

        var expr_atom = maybe_embed_tokens(function(allow_calls) {
                if (is("operator", "new")) {
                        next();
                        return new_();
                }
                if (is("punc")) {
                        switch (S.token.value) {
                            case "(":
                                next();
                                return subscripts(prog1(expression, curry(expect, ")")), allow_calls);
                            case "[":
                                next();
                                return subscripts(array_(), allow_calls);
                            case "{":
                                next();
                                return subscripts(object_(), allow_calls);
                        }
                        unexpected();
                }
                if (is("keyword", "function")) {
                        next();
                        return subscripts(function_(false), allow_calls);
                }
                if (HOP(ATOMIC_START_TOKEN, S.token.type)) {
                        var atom = S.token.type == "regexp"
                                ? as("regexp", S.token.value[0], S.token.value[1])
                                : as(S.token.type, S.token.value);
                        return subscripts(prog1(atom, next), allow_calls);
                }
                unexpected();
        });

        function expr_list(closing, allow_trailing_comma, allow_empty) {
                var first = true, a = [];
                while (!is("punc", closing)) {
                        if (first) first = false; else expect(",");
                        if (allow_trailing_comma && is("punc", closing)) break;
                        if (is("punc", ",") && allow_empty) {
                                a.push([ "atom", "undefined" ]);
                        } else {
                                a.push(expression(false));
                        }
                }
                next();
                return a;
        };

        function array_() {
                return as("array", expr_list("]", !exigent_mode, true));
        };

        function object_() {
                var first = true, a = [];
                while (!is("punc", "}")) {
                        if (first) first = false; else expect(",");
                        if (!exigent_mode && is("punc", "}"))
                                // allow trailing comma
                                break;
                        var type = S.token.type;
                        var name = as_property_name();
                        if (type == "name" && (name == "get" || name == "set") && !is("punc", ":")) {
                                a.push([ as_name(), function_(false), name ]);
                        } else {
                                expect(":");
                                a.push([ name, expression(false) ]);
                        }
                }
                next();
                return as("object", a);
        };

        function as_property_name() {
                switch (S.token.type) {
                    case "num":
                    case "string":
                        return prog1(S.token.value, next);
                }
                return as_name();
        };

        function as_name() {
                switch (S.token.type) {
                    case "name":
                    case "operator":
                    case "keyword":
                    case "atom":
                        return prog1(S.token.value, next);
                    default:
                        unexpected();
                }
        };

        function subscripts(expr, allow_calls) {
                if (is("punc", ".")) {
                        next();
                        return subscripts(as("dot", expr, as_name()), allow_calls);
                }
                if (is("punc", "[")) {
                        next();
                        return subscripts(as("sub", expr, prog1(expression, curry(expect, "]"))), allow_calls);
                }
                if (allow_calls && is("punc", "(")) {
                        next();
                        return subscripts(as("call", expr, expr_list(")")), true);
                }
                return expr;
        };

        function maybe_unary(allow_calls) {
                if (is("operator") && HOP(UNARY_PREFIX, S.token.value)) {
                        return make_unary("unary-prefix",
                                          prog1(S.token.value, next),
                                          maybe_unary(allow_calls));
                }
                var val = expr_atom(allow_calls);
                while (is("operator") && HOP(UNARY_POSTFIX, S.token.value) && !S.token.nlb) {
                        val = make_unary("unary-postfix", S.token.value, val);
                        next();
                }
                return val;
        };

        function make_unary(tag, op, expr) {
                if ((op == "++" || op == "--") && !is_assignable(expr))
                        croak("Invalid use of " + op + " operator");
                return as(tag, op, expr);
        };

        function expr_op(left, min_prec, no_in) {
                var op = is("operator") ? S.token.value : null;
                if (op && op == "in" && no_in) op = null;
                var prec = op != null ? PRECEDENCE[op] : null;
                if (prec != null && prec > min_prec) {
                        next();
                        var right = expr_op(maybe_unary(true), prec, no_in);
                        return expr_op(as("binary", op, left, right), min_prec, no_in);
                }
                return left;
        };

        function expr_ops(no_in) {
                return expr_op(maybe_unary(true), 0, no_in);
        };

        function maybe_conditional(no_in) {
                var expr = expr_ops(no_in);
                if (is("operator", "?")) {
                        next();
                        var yes = expression(false);
                        expect(":");
                        return as("conditional", expr, yes, expression(false, no_in));
                }
                return expr;
        };

        function is_assignable(expr) {
                if (!exigent_mode) return true;
                switch (expr[0]+"") {
                    case "dot":
                    case "sub":
                    case "new":
                    case "call":
                        return true;
                    case "name":
                        return expr[1] != "this";
                }
        };

        function maybe_assign(no_in) {
                var left = maybe_conditional(no_in), val = S.token.value;
                if (is("operator") && HOP(ASSIGNMENT, val)) {
                        if (is_assignable(left)) {
                                next();
                                return as("assign", ASSIGNMENT[val], left, maybe_assign(no_in));
                        }
                        croak("Invalid assignment");
                }
                return left;
        };

        var expression = maybe_embed_tokens(function(commas, no_in) {
                if (arguments.length == 0)
                        commas = true;
                var expr = maybe_assign(no_in);
                if (commas && is("punc", ",")) {
                        next();
                        return as("seq", expr, expression(true, no_in));
                }
                return expr;
        });

        function in_loop(cont) {
                try {
                        ++S.in_loop;
                        return cont();
                } finally {
                        --S.in_loop;
                }
        };

        return as("toplevel", (function(a){
                while (!is("eof"))
                        a.push(statement());
                return a;
        })([]));

};

/* -----[ Utilities ]----- */

function curry(f) {
        var args = slice(arguments, 1);
        return function() { return f.apply(this, args.concat(slice(arguments))); };
};

function prog1(ret) {
        if (ret instanceof Function)
                ret = ret();
        for (var i = 1, n = arguments.length; --n > 0; ++i)
                arguments[i]();
        return ret;
};

function array_to_hash(a) {
        var ret = {};
        for (var i = 0; i < a.length; ++i)
                ret[a[i]] = true;
        return ret;
};

function slice(a, start) {
        return Array.prototype.slice.call(a, start || 0);
};

function characters(str) {
        return str.split("");
};

function member(name, array) {
        for (var i = array.length; --i >= 0;)
                if (array[i] == name)
                        return true;
        return false;
};

function HOP(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
};

var warn = function() {};

/* -----[ Exports ]----- */

exports.tokenizer = tokenizer;
exports.parse = parse;
exports.slice = slice;
exports.curry = curry;
exports.member = member;
exports.array_to_hash = array_to_hash;
exports.PRECEDENCE = PRECEDENCE;
exports.KEYWORDS_ATOM = KEYWORDS_ATOM;
exports.RESERVED_WORDS = RESERVED_WORDS;
exports.KEYWORDS = KEYWORDS;
exports.ATOMIC_START_TOKEN = ATOMIC_START_TOKEN;
exports.OPERATORS = OPERATORS;
exports.is_alphanumeric_char = is_alphanumeric_char;
exports.is_identifier_start = is_identifier_start;
exports.is_identifier_char = is_identifier_char;
exports.set_logger = function(logger) {
        warn = logger;
};

// Local variables:
// js-indent-level: 8
// End:

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/process.js":[function(require,module,exports){
/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.

  This version is suitable for Node.js.  With minimal changes (the
  exports stuff) it should work on any JS platform.

  This file implements some AST processors.  They work on data built
  by parse-js.

  Exported functions:

    - ast_mangle(ast, options) -- mangles the variable/function names
      in the AST.  Returns an AST.

    - ast_squeeze(ast) -- employs various optimizations to make the
      final generated code even smaller.  Returns an AST.

    - gen_code(ast, options) -- generates JS code from the AST.  Pass
      true (or an object, see the code for some options) as second
      argument to get "pretty" (indented) code.

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2010 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

var jsp = require("./parse-js"),
    curry = jsp.curry,
    slice = jsp.slice,
    member = jsp.member,
    is_identifier_char = jsp.is_identifier_char,
    PRECEDENCE = jsp.PRECEDENCE,
    OPERATORS = jsp.OPERATORS;

/* -----[ helper for AST traversal ]----- */

function ast_walker() {
        function _vardefs(defs) {
                return [ this[0], MAP(defs, function(def){
                        var a = [ def[0] ];
                        if (def.length > 1)
                                a[1] = walk(def[1]);
                        return a;
                }) ];
        };
        function _block(statements) {
                var out = [ this[0] ];
                if (statements != null)
                        out.push(MAP(statements, walk));
                return out;
        };
        var walkers = {
                "string": function(str) {
                        return [ this[0], str ];
                },
                "num": function(num) {
                        return [ this[0], num ];
                },
                "name": function(name) {
                        return [ this[0], name ];
                },
                "toplevel": function(statements) {
                        return [ this[0], MAP(statements, walk) ];
                },
                "block": _block,
                "splice": _block,
                "var": _vardefs,
                "const": _vardefs,
                "try": function(t, c, f) {
                        return [
                                this[0],
                                MAP(t, walk),
                                c != null ? [ c[0], MAP(c[1], walk) ] : null,
                                f != null ? MAP(f, walk) : null
                        ];
                },
                "throw": function(expr) {
                        return [ this[0], walk(expr) ];
                },
                "new": function(ctor, args) {
                        return [ this[0], walk(ctor), MAP(args, walk) ];
                },
                "switch": function(expr, body) {
                        return [ this[0], walk(expr), MAP(body, function(branch){
                                return [ branch[0] ? walk(branch[0]) : null,
                                         MAP(branch[1], walk) ];
                        }) ];
                },
                "break": function(label) {
                        return [ this[0], label ];
                },
                "continue": function(label) {
                        return [ this[0], label ];
                },
                "conditional": function(cond, t, e) {
                        return [ this[0], walk(cond), walk(t), walk(e) ];
                },
                "assign": function(op, lvalue, rvalue) {
                        return [ this[0], op, walk(lvalue), walk(rvalue) ];
                },
                "dot": function(expr) {
                        return [ this[0], walk(expr) ].concat(slice(arguments, 1));
                },
                "call": function(expr, args) {
                        return [ this[0], walk(expr), MAP(args, walk) ];
                },
                "function": function(name, args, body) {
                        return [ this[0], name, args.slice(), MAP(body, walk) ];
                },
                "debugger": function() {
                        return [ this[0] ];
                },
                "defun": function(name, args, body) {
                        return [ this[0], name, args.slice(), MAP(body, walk) ];
                },
                "if": function(conditional, t, e) {
                        return [ this[0], walk(conditional), walk(t), walk(e) ];
                },
                "for": function(init, cond, step, block) {
                        return [ this[0], walk(init), walk(cond), walk(step), walk(block) ];
                },
                "for-in": function(vvar, key, hash, block) {
                        return [ this[0], walk(vvar), walk(key), walk(hash), walk(block) ];
                },
                "while": function(cond, block) {
                        return [ this[0], walk(cond), walk(block) ];
                },
                "do": function(cond, block) {
                        return [ this[0], walk(cond), walk(block) ];
                },
                "return": function(expr) {
                        return [ this[0], walk(expr) ];
                },
                "binary": function(op, left, right) {
                        return [ this[0], op, walk(left), walk(right) ];
                },
                "unary-prefix": function(op, expr) {
                        return [ this[0], op, walk(expr) ];
                },
                "unary-postfix": function(op, expr) {
                        return [ this[0], op, walk(expr) ];
                },
                "sub": function(expr, subscript) {
                        return [ this[0], walk(expr), walk(subscript) ];
                },
                "object": function(props) {
                        return [ this[0], MAP(props, function(p){
                                return p.length == 2
                                        ? [ p[0], walk(p[1]) ]
                                        : [ p[0], walk(p[1]), p[2] ]; // get/set-ter
                        }) ];
                },
                "regexp": function(rx, mods) {
                        return [ this[0], rx, mods ];
                },
                "array": function(elements) {
                        return [ this[0], MAP(elements, walk) ];
                },
                "stat": function(stat) {
                        return [ this[0], walk(stat) ];
                },
                "seq": function() {
                        return [ this[0] ].concat(MAP(slice(arguments), walk));
                },
                "label": function(name, block) {
                        return [ this[0], name, walk(block) ];
                },
                "with": function(expr, block) {
                        return [ this[0], walk(expr), walk(block) ];
                },
                "atom": function(name) {
                        return [ this[0], name ];
                },
                "directive": function(dir) {
                        return [ this[0], dir ];
                }
        };

        var user = {};
        var stack = [];
        function walk(ast) {
                if (ast == null)
                        return null;
                try {
                        stack.push(ast);
                        var type = ast[0];
                        var gen = user[type];
                        if (gen) {
                                var ret = gen.apply(ast, ast.slice(1));
                                if (ret != null)
                                        return ret;
                        }
                        gen = walkers[type];
                        return gen.apply(ast, ast.slice(1));
                } finally {
                        stack.pop();
                }
        };

        function dive(ast) {
                if (ast == null)
                        return null;
                try {
                        stack.push(ast);
                        return walkers[ast[0]].apply(ast, ast.slice(1));
                } finally {
                        stack.pop();
                }
        };

        function with_walkers(walkers, cont){
                var save = {}, i;
                for (i in walkers) if (HOP(walkers, i)) {
                        save[i] = user[i];
                        user[i] = walkers[i];
                }
                var ret = cont();
                for (i in save) if (HOP(save, i)) {
                        if (!save[i]) delete user[i];
                        else user[i] = save[i];
                }
                return ret;
        };

        return {
                walk: walk,
                dive: dive,
                with_walkers: with_walkers,
                parent: function() {
                        return stack[stack.length - 2]; // last one is current node
                },
                stack: function() {
                        return stack;
                }
        };
};

/* -----[ Scope and mangling ]----- */

function Scope(parent) {
        this.names = {};        // names defined in this scope
        this.mangled = {};      // mangled names (orig.name => mangled)
        this.rev_mangled = {};  // reverse lookup (mangled => orig.name)
        this.cname = -1;        // current mangled name
        this.refs = {};         // names referenced from this scope
        this.uses_with = false; // will become TRUE if with() is detected in this or any subscopes
        this.uses_eval = false; // will become TRUE if eval() is detected in this or any subscopes
        this.directives = [];   // directives activated from this scope
        this.parent = parent;   // parent scope
        this.children = [];     // sub-scopes
        if (parent) {
                this.level = parent.level + 1;
                parent.children.push(this);
        } else {
                this.level = 0;
        }
};

function base54_digits() {
        if (typeof DIGITS_OVERRIDE_FOR_TESTING != "undefined")
                return DIGITS_OVERRIDE_FOR_TESTING;
        else
                return "etnrisouaflchpdvmgybwESxTNCkLAOM_DPHBjFIqRUzWXV$JKQGYZ0516372984";
}

var base54 = (function(){
        var DIGITS = base54_digits();
        return function(num) {
                var ret = "", base = 54;
                do {
                        ret += DIGITS.charAt(num % base);
                        num = Math.floor(num / base);
                        base = 64;
                } while (num > 0);
                return ret;
        };
})();

Scope.prototype = {
        has: function(name) {
                for (var s = this; s; s = s.parent)
                        if (HOP(s.names, name))
                                return s;
        },
        has_mangled: function(mname) {
                for (var s = this; s; s = s.parent)
                        if (HOP(s.rev_mangled, mname))
                                return s;
        },
        toJSON: function() {
                return {
                        names: this.names,
                        uses_eval: this.uses_eval,
                        uses_with: this.uses_with
                };
        },

        next_mangled: function() {
                // we must be careful that the new mangled name:
                //
                // 1. doesn't shadow a mangled name from a parent
                //    scope, unless we don't reference the original
                //    name from this scope OR from any sub-scopes!
                //    This will get slow.
                //
                // 2. doesn't shadow an original name from a parent
                //    scope, in the event that the name is not mangled
                //    in the parent scope and we reference that name
                //    here OR IN ANY SUBSCOPES!
                //
                // 3. doesn't shadow a name that is referenced but not
                //    defined (possibly global defined elsewhere).
                for (;;) {
                        var m = base54(++this.cname), prior;

                        // case 1.
                        prior = this.has_mangled(m);
                        if (prior && this.refs[prior.rev_mangled[m]] === prior)
                                continue;

                        // case 2.
                        prior = this.has(m);
                        if (prior && prior !== this && this.refs[m] === prior && !prior.has_mangled(m))
                                continue;

                        // case 3.
                        if (HOP(this.refs, m) && this.refs[m] == null)
                                continue;

                        // I got "do" once. :-/
                        if (!is_identifier(m))
                                continue;

                        return m;
                }
        },
        set_mangle: function(name, m) {
                this.rev_mangled[m] = name;
                return this.mangled[name] = m;
        },
        get_mangled: function(name, newMangle) {
                if (this.uses_eval || this.uses_with) return name; // no mangle if eval or with is in use
                var s = this.has(name);
                if (!s) return name; // not in visible scope, no mangle
                if (HOP(s.mangled, name)) return s.mangled[name]; // already mangled in this scope
                if (!newMangle) return name;                      // not found and no mangling requested
                return s.set_mangle(name, s.next_mangled());
        },
        references: function(name) {
                return name && !this.parent || this.uses_with || this.uses_eval || this.refs[name];
        },
        define: function(name, type) {
                if (name != null) {
                        if (type == "var" || !HOP(this.names, name))
                                this.names[name] = type || "var";
                        return name;
                }
        },
        active_directive: function(dir) {
                return member(dir, this.directives) || this.parent && this.parent.active_directive(dir);
        }
};

function ast_add_scope(ast) {

        var current_scope = null;
        var w = ast_walker(), walk = w.walk;
        var having_eval = [];

        function with_new_scope(cont) {
                current_scope = new Scope(current_scope);
                current_scope.labels = new Scope();
                var ret = current_scope.body = cont();
                ret.scope = current_scope;
                current_scope = current_scope.parent;
                return ret;
        };

        function define(name, type) {
                return current_scope.define(name, type);
        };

        function reference(name) {
                current_scope.refs[name] = true;
        };

        function _lambda(name, args, body) {
                var is_defun = this[0] == "defun";
                return [ this[0], is_defun ? define(name, "defun") : name, args, with_new_scope(function(){
                        if (!is_defun) define(name, "lambda");
                        MAP(args, function(name){ define(name, "arg") });
                        return MAP(body, walk);
                })];
        };

        function _vardefs(type) {
                return function(defs) {
                        MAP(defs, function(d){
                                define(d[0], type);
                                if (d[1]) reference(d[0]);
                        });
                };
        };

        function _breacont(label) {
                if (label)
                        current_scope.labels.refs[label] = true;
        };

        return with_new_scope(function(){
                // process AST
                var ret = w.with_walkers({
                        "function": _lambda,
                        "defun": _lambda,
                        "label": function(name, stat) { current_scope.labels.define(name) },
                        "break": _breacont,
                        "continue": _breacont,
                        "with": function(expr, block) {
                                for (var s = current_scope; s; s = s.parent)
                                        s.uses_with = true;
                        },
                        "var": _vardefs("var"),
                        "const": _vardefs("const"),
                        "try": function(t, c, f) {
                                if (c != null) return [
                                        this[0],
                                        MAP(t, walk),
                                        [ define(c[0], "catch"), MAP(c[1], walk) ],
                                        f != null ? MAP(f, walk) : null
                                ];
                        },
                        "name": function(name) {
                                if (name == "eval")
                                        having_eval.push(current_scope);
                                reference(name);
                        }
                }, function(){
                        return walk(ast);
                });

                // the reason why we need an additional pass here is
                // that names can be used prior to their definition.

                // scopes where eval was detected and their parents
                // are marked with uses_eval, unless they define the
                // "eval" name.
                MAP(having_eval, function(scope){
                        if (!scope.has("eval")) while (scope) {
                                scope.uses_eval = true;
                                scope = scope.parent;
                        }
                });

                // for referenced names it might be useful to know
                // their origin scope.  current_scope here is the
                // toplevel one.
                function fixrefs(scope, i) {
                        // do children first; order shouldn't matter
                        for (i = scope.children.length; --i >= 0;)
                                fixrefs(scope.children[i]);
                        for (i in scope.refs) if (HOP(scope.refs, i)) {
                                // find origin scope and propagate the reference to origin
                                for (var origin = scope.has(i), s = scope; s; s = s.parent) {
                                        s.refs[i] = origin;
                                        if (s === origin) break;
                                }
                        }
                };
                fixrefs(current_scope);

                return ret;
        });

};

/* -----[ mangle names ]----- */

function ast_mangle(ast, options) {
        var w = ast_walker(), walk = w.walk, scope;
        options = defaults(options, {
                mangle       : true,
                toplevel     : false,
                defines      : null,
                except       : null,
                no_functions : false
        });

        function get_mangled(name, newMangle) {
                if (!options.mangle) return name;
                if (!options.toplevel && !scope.parent) return name; // don't mangle toplevel
                if (options.except && member(name, options.except))
                        return name;
                if (options.no_functions && HOP(scope.names, name) &&
                    (scope.names[name] == 'defun' || scope.names[name] == 'lambda'))
                        return name;
                return scope.get_mangled(name, newMangle);
        };

        function get_define(name) {
                if (options.defines) {
                        // we always lookup a defined symbol for the current scope FIRST, so declared
                        // vars trump a DEFINE symbol, but if no such var is found, then match a DEFINE value
                        if (!scope.has(name)) {
                                if (HOP(options.defines, name)) {
                                        return options.defines[name];
                                }
                        }
                        return null;
                }
        };

        function _lambda(name, args, body) {
                if (!options.no_functions && options.mangle) {
                        var is_defun = this[0] == "defun", extra;
                        if (name) {
                                if (is_defun) name = get_mangled(name);
                                else if (body.scope.references(name)) {
                                        extra = {};
                                        if (!(scope.uses_eval || scope.uses_with))
                                                name = extra[name] = scope.next_mangled();
                                        else
                                                extra[name] = name;
                                }
                                else name = null;
                        }
                }
                body = with_scope(body.scope, function(){
                        args = MAP(args, function(name){ return get_mangled(name) });
                        return MAP(body, walk);
                }, extra);
                return [ this[0], name, args, body ];
        };

        function with_scope(s, cont, extra) {
                var _scope = scope;
                scope = s;
                if (extra) for (var i in extra) if (HOP(extra, i)) {
                        s.set_mangle(i, extra[i]);
                }
                for (var i in s.names) if (HOP(s.names, i)) {
                        get_mangled(i, true);
                }
                var ret = cont();
                ret.scope = s;
                scope = _scope;
                return ret;
        };

        function _vardefs(defs) {
                return [ this[0], MAP(defs, function(d){
                        return [ get_mangled(d[0]), walk(d[1]) ];
                }) ];
        };

        function _breacont(label) {
                if (label) return [ this[0], scope.labels.get_mangled(label) ];
        };

        return w.with_walkers({
                "function": _lambda,
                "defun": function() {
                        // move function declarations to the top when
                        // they are not in some block.
                        var ast = _lambda.apply(this, arguments);
                        switch (w.parent()[0]) {
                            case "toplevel":
                            case "function":
                            case "defun":
                                return MAP.at_top(ast);
                        }
                        return ast;
                },
                "label": function(label, stat) {
                        if (scope.labels.refs[label]) return [
                                this[0],
                                scope.labels.get_mangled(label, true),
                                walk(stat)
                        ];
                        return walk(stat);
                },
                "break": _breacont,
                "continue": _breacont,
                "var": _vardefs,
                "const": _vardefs,
                "name": function(name) {
                        return get_define(name) || [ this[0], get_mangled(name) ];
                },
                "try": function(t, c, f) {
                        return [ this[0],
                                 MAP(t, walk),
                                 c != null ? [ get_mangled(c[0]), MAP(c[1], walk) ] : null,
                                 f != null ? MAP(f, walk) : null ];
                },
                "toplevel": function(body) {
                        var self = this;
                        return with_scope(self.scope, function(){
                                return [ self[0], MAP(body, walk) ];
                        });
                },
                "directive": function() {
                        return MAP.at_top(this);
                }
        }, function() {
                return walk(ast_add_scope(ast));
        });
};

/* -----[
   - compress foo["bar"] into foo.bar,
   - remove block brackets {} where possible
   - join consecutive var declarations
   - various optimizations for IFs:
     - if (cond) foo(); else bar();  ==>  cond?foo():bar();
     - if (cond) foo();  ==>  cond&&foo();
     - if (foo) return bar(); else return baz();  ==> return foo?bar():baz(); // also for throw
     - if (foo) return bar(); else something();  ==> {if(foo)return bar();something()}
   ]----- */

var warn = function(){};

function best_of(ast1, ast2) {
        return gen_code(ast1).length > gen_code(ast2[0] == "stat" ? ast2[1] : ast2).length ? ast2 : ast1;
};

function last_stat(b) {
        if (b[0] == "block" && b[1] && b[1].length > 0)
                return b[1][b[1].length - 1];
        return b;
}

function aborts(t) {
        if (t) switch (last_stat(t)[0]) {
            case "return":
            case "break":
            case "continue":
            case "throw":
                return true;
        }
};

function boolean_expr(expr) {
        return ( (expr[0] == "unary-prefix"
                  && member(expr[1], [ "!", "delete" ])) ||

                 (expr[0] == "binary"
                  && member(expr[1], [ "in", "instanceof", "==", "!=", "===", "!==", "<", "<=", ">=", ">" ])) ||

                 (expr[0] == "binary"
                  && member(expr[1], [ "&&", "||" ])
                  && boolean_expr(expr[2])
                  && boolean_expr(expr[3])) ||

                 (expr[0] == "conditional"
                  && boolean_expr(expr[2])
                  && boolean_expr(expr[3])) ||

                 (expr[0] == "assign"
                  && expr[1] === true
                  && boolean_expr(expr[3])) ||

                 (expr[0] == "seq"
                  && boolean_expr(expr[expr.length - 1]))
               );
};

function empty(b) {
        return !b || (b[0] == "block" && (!b[1] || b[1].length == 0));
};

function is_string(node) {
        return (node[0] == "string" ||
                node[0] == "unary-prefix" && node[1] == "typeof" ||
                node[0] == "binary" && node[1] == "+" &&
                (is_string(node[2]) || is_string(node[3])));
};

var when_constant = (function(){

        var $NOT_CONSTANT = {};

        // this can only evaluate constant expressions.  If it finds anything
        // not constant, it throws $NOT_CONSTANT.
        function evaluate(expr) {
                switch (expr[0]) {
                    case "string":
                    case "num":
                        return expr[1];
                    case "name":
                    case "atom":
                        switch (expr[1]) {
                            case "true": return true;
                            case "false": return false;
                            case "null": return null;
                        }
                        break;
                    case "unary-prefix":
                        switch (expr[1]) {
                            case "!": return !evaluate(expr[2]);
                            case "typeof": return typeof evaluate(expr[2]);
                            case "~": return ~evaluate(expr[2]);
                            case "-": return -evaluate(expr[2]);
                            case "+": return +evaluate(expr[2]);
                        }
                        break;
                    case "binary":
                        var left = expr[2], right = expr[3];
                        switch (expr[1]) {
                            case "&&"         : return evaluate(left) &&         evaluate(right);
                            case "||"         : return evaluate(left) ||         evaluate(right);
                            case "|"          : return evaluate(left) |          evaluate(right);
                            case "&"          : return evaluate(left) &          evaluate(right);
                            case "^"          : return evaluate(left) ^          evaluate(right);
                            case "+"          : return evaluate(left) +          evaluate(right);
                            case "*"          : return evaluate(left) *          evaluate(right);
                            case "/"          : return evaluate(left) /          evaluate(right);
                            case "%"          : return evaluate(left) %          evaluate(right);
                            case "-"          : return evaluate(left) -          evaluate(right);
                            case "<<"         : return evaluate(left) <<         evaluate(right);
                            case ">>"         : return evaluate(left) >>         evaluate(right);
                            case ">>>"        : return evaluate(left) >>>        evaluate(right);
                            case "=="         : return evaluate(left) ==         evaluate(right);
                            case "==="        : return evaluate(left) ===        evaluate(right);
                            case "!="         : return evaluate(left) !=         evaluate(right);
                            case "!=="        : return evaluate(left) !==        evaluate(right);
                            case "<"          : return evaluate(left) <          evaluate(right);
                            case "<="         : return evaluate(left) <=         evaluate(right);
                            case ">"          : return evaluate(left) >          evaluate(right);
                            case ">="         : return evaluate(left) >=         evaluate(right);
                            case "in"         : return evaluate(left) in         evaluate(right);
                            case "instanceof" : return evaluate(left) instanceof evaluate(right);
                        }
                }
                throw $NOT_CONSTANT;
        };

        return function(expr, yes, no) {
                try {
                        var val = evaluate(expr), ast;
                        switch (typeof val) {
                            case "string": ast =  [ "string", val ]; break;
                            case "number": ast =  [ "num", val ]; break;
                            case "boolean": ast =  [ "name", String(val) ]; break;
                            default:
                                if (val === null) { ast = [ "atom", "null" ]; break; }
                                throw new Error("Can't handle constant of type: " + (typeof val));
                        }
                        return yes.call(expr, ast, val);
                } catch(ex) {
                        if (ex === $NOT_CONSTANT) {
                                if (expr[0] == "binary"
                                    && (expr[1] == "===" || expr[1] == "!==")
                                    && ((is_string(expr[2]) && is_string(expr[3]))
                                        || (boolean_expr(expr[2]) && boolean_expr(expr[3])))) {
                                        expr[1] = expr[1].substr(0, 2);
                                }
                                else if (no && expr[0] == "binary"
                                         && (expr[1] == "||" || expr[1] == "&&")) {
                                    // the whole expression is not constant but the lval may be...
                                    try {
                                        var lval = evaluate(expr[2]);
                                        expr = ((expr[1] == "&&" && (lval ? expr[3] : lval))    ||
                                                (expr[1] == "||" && (lval ? lval    : expr[3])) ||
                                                expr);
                                    } catch(ex2) {
                                        // IGNORE... lval is not constant
                                    }
                                }
                                return no ? no.call(expr, expr) : null;
                        }
                        else throw ex;
                }
        };

})();

function warn_unreachable(ast) {
        if (!empty(ast))
                warn("Dropping unreachable code: " + gen_code(ast, true));
};

function prepare_ifs(ast) {
        var w = ast_walker(), walk = w.walk;
        // In this first pass, we rewrite ifs which abort with no else with an
        // if-else.  For example:
        //
        // if (x) {
        //     blah();
        //     return y;
        // }
        // foobar();
        //
        // is rewritten into:
        //
        // if (x) {
        //     blah();
        //     return y;
        // } else {
        //     foobar();
        // }
        function redo_if(statements) {
                statements = MAP(statements, walk);

                for (var i = 0; i < statements.length; ++i) {
                        var fi = statements[i];
                        if (fi[0] != "if") continue;

                        if (fi[3]) continue;

                        var t = fi[2];
                        if (!aborts(t)) continue;

                        var conditional = walk(fi[1]);

                        var e_body = redo_if(statements.slice(i + 1));
                        var e = e_body.length == 1 ? e_body[0] : [ "block", e_body ];

                        return statements.slice(0, i).concat([ [
                                fi[0],          // "if"
                                conditional,    // conditional
                                t,              // then
                                e               // else
                        ] ]);
                }

                return statements;
        };

        function redo_if_lambda(name, args, body) {
                body = redo_if(body);
                return [ this[0], name, args, body ];
        };

        function redo_if_block(statements) {
                return [ this[0], statements != null ? redo_if(statements) : null ];
        };

        return w.with_walkers({
                "defun": redo_if_lambda,
                "function": redo_if_lambda,
                "block": redo_if_block,
                "splice": redo_if_block,
                "toplevel": function(statements) {
                        return [ this[0], redo_if(statements) ];
                },
                "try": function(t, c, f) {
                        return [
                                this[0],
                                redo_if(t),
                                c != null ? [ c[0], redo_if(c[1]) ] : null,
                                f != null ? redo_if(f) : null
                        ];
                }
        }, function() {
                return walk(ast);
        });
};

function for_side_effects(ast, handler) {
        var w = ast_walker(), walk = w.walk;
        var $stop = {}, $restart = {};
        function stop() { throw $stop };
        function restart() { throw $restart };
        function found(){ return handler.call(this, this, w, stop, restart) };
        function unary(op) {
                if (op == "++" || op == "--")
                        return found.apply(this, arguments);
        };
        function binary(op) {
                if (op == "&&" || op == "||")
                        return found.apply(this, arguments);
        };
        return w.with_walkers({
                "try": found,
                "throw": found,
                "return": found,
                "new": found,
                "switch": found,
                "break": found,
                "continue": found,
                "assign": found,
                "call": found,
                "if": found,
                "for": found,
                "for-in": found,
                "while": found,
                "do": found,
                "return": found,
                "unary-prefix": unary,
                "unary-postfix": unary,
                "conditional": found,
                "binary": binary,
                "defun": found
        }, function(){
                while (true) try {
                        walk(ast);
                        break;
                } catch(ex) {
                        if (ex === $stop) break;
                        if (ex === $restart) continue;
                        throw ex;
                }
        });
};

function ast_lift_variables(ast) {
        var w = ast_walker(), walk = w.walk, scope;
        function do_body(body, env) {
                var _scope = scope;
                scope = env;
                body = MAP(body, walk);
                var hash = {}, names = MAP(env.names, function(type, name){
                        if (type != "var") return MAP.skip;
                        if (!env.references(name)) return MAP.skip;
                        hash[name] = true;
                        return [ name ];
                });
                if (names.length > 0) {
                        // looking for assignments to any of these variables.
                        // we can save considerable space by moving the definitions
                        // in the var declaration.
                        for_side_effects([ "block", body ], function(ast, walker, stop, restart) {
                                if (ast[0] == "assign"
                                    && ast[1] === true
                                    && ast[2][0] == "name"
                                    && HOP(hash, ast[2][1])) {
                                        // insert the definition into the var declaration
                                        for (var i = names.length; --i >= 0;) {
                                                if (names[i][0] == ast[2][1]) {
                                                        if (names[i][1]) // this name already defined, we must stop
                                                                stop();
                                                        names[i][1] = ast[3]; // definition
                                                        names.push(names.splice(i, 1)[0]);
                                                        break;
                                                }
                                        }
                                        // remove this assignment from the AST.
                                        var p = walker.parent();
                                        if (p[0] == "seq") {
                                                var a = p[2];
                                                a.unshift(0, p.length);
                                                p.splice.apply(p, a);
                                        }
                                        else if (p[0] == "stat") {
                                                p.splice(0, p.length, "block"); // empty statement
                                        }
                                        else {
                                                stop();
                                        }
                                        restart();
                                }
                                stop();
                        });
                        body.unshift([ "var", names ]);
                }
                scope = _scope;
                return body;
        };
        function _vardefs(defs) {
                var ret = null;
                for (var i = defs.length; --i >= 0;) {
                        var d = defs[i];
                        if (!d[1]) continue;
                        d = [ "assign", true, [ "name", d[0] ], d[1] ];
                        if (ret == null) ret = d;
                        else ret = [ "seq", d, ret ];
                }
                if (ret == null && w.parent()[0] != "for") {
                        if (w.parent()[0] == "for-in")
                                return [ "name", defs[0][0] ];
                        return MAP.skip;
                }
                return [ "stat", ret ];
        };
        function _toplevel(body) {
                return [ this[0], do_body(body, this.scope) ];
        };
        return w.with_walkers({
                "function": function(name, args, body){
                        for (var i = args.length; --i >= 0 && !body.scope.references(args[i]);)
                                args.pop();
                        if (!body.scope.references(name)) name = null;
                        return [ this[0], name, args, do_body(body, body.scope) ];
                },
                "defun": function(name, args, body){
                        if (!scope.references(name)) return MAP.skip;
                        for (var i = args.length; --i >= 0 && !body.scope.references(args[i]);)
                                args.pop();
                        return [ this[0], name, args, do_body(body, body.scope) ];
                },
                "var": _vardefs,
                "toplevel": _toplevel
        }, function(){
                return walk(ast_add_scope(ast));
        });
};

function ast_squeeze(ast, options) {
        ast = squeeze_1(ast, options);
        ast = squeeze_2(ast, options);
        return ast;
};

function squeeze_1(ast, options) {
        options = defaults(options, {
                make_seqs   : true,
                dead_code   : true,
                no_warnings : false,
                keep_comps  : true,
                unsafe      : false
        });

        var w = ast_walker(), walk = w.walk, scope;

        function negate(c) {
                var not_c = [ "unary-prefix", "!", c ];
                switch (c[0]) {
                    case "unary-prefix":
                        return c[1] == "!" && boolean_expr(c[2]) ? c[2] : not_c;
                    case "seq":
                        c = slice(c);
                        c[c.length - 1] = negate(c[c.length - 1]);
                        return c;
                    case "conditional":
                        return best_of(not_c, [ "conditional", c[1], negate(c[2]), negate(c[3]) ]);
                    case "binary":
                        var op = c[1], left = c[2], right = c[3];
                        if (!options.keep_comps) switch (op) {
                            case "<="  : return [ "binary", ">", left, right ];
                            case "<"   : return [ "binary", ">=", left, right ];
                            case ">="  : return [ "binary", "<", left, right ];
                            case ">"   : return [ "binary", "<=", left, right ];
                        }
                        switch (op) {
                            case "=="  : return [ "binary", "!=", left, right ];
                            case "!="  : return [ "binary", "==", left, right ];
                            case "===" : return [ "binary", "!==", left, right ];
                            case "!==" : return [ "binary", "===", left, right ];
                            case "&&"  : return best_of(not_c, [ "binary", "||", negate(left), negate(right) ]);
                            case "||"  : return best_of(not_c, [ "binary", "&&", negate(left), negate(right) ]);
                        }
                        break;
                }
                return not_c;
        };

        function make_conditional(c, t, e) {
                var make_real_conditional = function() {
                        if (c[0] == "unary-prefix" && c[1] == "!") {
                                return e ? [ "conditional", c[2], e, t ] : [ "binary", "||", c[2], t ];
                        } else {
                                return e ? best_of(
                                        [ "conditional", c, t, e ],
                                        [ "conditional", negate(c), e, t ]
                                ) : [ "binary", "&&", c, t ];
                        }
                };
                // shortcut the conditional if the expression has a constant value
                return when_constant(c, function(ast, val){
                        warn_unreachable(val ? e : t);
                        return          (val ? t : e);
                }, make_real_conditional);
        };

        function rmblock(block) {
                if (block != null && block[0] == "block" && block[1]) {
                        if (block[1].length == 1)
                                block = block[1][0];
                        else if (block[1].length == 0)
                                block = [ "block" ];
                }
                return block;
        };

        function _lambda(name, args, body) {
                return [ this[0], name, args, tighten(body, "lambda") ];
        };

        // this function does a few things:
        // 1. discard useless blocks
        // 2. join consecutive var declarations
        // 3. remove obviously dead code
        // 4. transform consecutive statements using the comma operator
        // 5. if block_type == "lambda" and it detects constructs like if(foo) return ... - rewrite like if (!foo) { ... }
        function tighten(statements, block_type) {
                statements = MAP(statements, walk);

                statements = statements.reduce(function(a, stat){
                        if (stat[0] == "block") {
                                if (stat[1]) {
                                        a.push.apply(a, stat[1]);
                                }
                        } else {
                                a.push(stat);
                        }
                        return a;
                }, []);

                statements = (function(a, prev){
                        statements.forEach(function(cur){
                                if (prev && ((cur[0] == "var" && prev[0] == "var") ||
                                             (cur[0] == "const" && prev[0] == "const"))) {
                                        prev[1] = prev[1].concat(cur[1]);
                                } else {
                                        a.push(cur);
                                        prev = cur;
                                }
                        });
                        return a;
                })([]);

                if (options.dead_code) statements = (function(a, has_quit){
                        statements.forEach(function(st){
                                if (has_quit) {
                                        if (st[0] == "function" || st[0] == "defun") {
                                                a.push(st);
                                        }
                                        else if (st[0] == "var" || st[0] == "const") {
                                                if (!options.no_warnings)
                                                        warn("Variables declared in unreachable code");
                                                st[1] = MAP(st[1], function(def){
                                                        if (def[1] && !options.no_warnings)
                                                                warn_unreachable([ "assign", true, [ "name", def[0] ], def[1] ]);
                                                        return [ def[0] ];
                                                });
                                                a.push(st);
                                        }
                                        else if (!options.no_warnings)
                                                warn_unreachable(st);
                                }
                                else {
                                        a.push(st);
                                        if (member(st[0], [ "return", "throw", "break", "continue" ]))
                                                has_quit = true;
                                }
                        });
                        return a;
                })([]);

                if (options.make_seqs) statements = (function(a, prev) {
                        statements.forEach(function(cur){
                                if (prev && prev[0] == "stat" && cur[0] == "stat") {
                                        prev[1] = [ "seq", prev[1], cur[1] ];
                                } else {
                                        a.push(cur);
                                        prev = cur;
                                }
                        });
                        if (a.length >= 2
                            && a[a.length-2][0] == "stat"
                            && (a[a.length-1][0] == "return" || a[a.length-1][0] == "throw")
                            && a[a.length-1][1])
                        {
                                a.splice(a.length - 2, 2,
                                         [ a[a.length-1][0],
                                           [ "seq", a[a.length-2][1], a[a.length-1][1] ]]);
                        }
                        return a;
                })([]);

                // this increases jQuery by 1K.  Probably not such a good idea after all..
                // part of this is done in prepare_ifs anyway.
                // if (block_type == "lambda") statements = (function(i, a, stat){
                //         while (i < statements.length) {
                //                 stat = statements[i++];
                //                 if (stat[0] == "if" && !stat[3]) {
                //                         if (stat[2][0] == "return" && stat[2][1] == null) {
                //                                 a.push(make_if(negate(stat[1]), [ "block", statements.slice(i) ]));
                //                                 break;
                //                         }
                //                         var last = last_stat(stat[2]);
                //                         if (last[0] == "return" && last[1] == null) {
                //                                 a.push(make_if(stat[1], [ "block", stat[2][1].slice(0, -1) ], [ "block", statements.slice(i) ]));
                //                                 break;
                //                         }
                //                 }
                //                 a.push(stat);
                //         }
                //         return a;
                // })(0, []);

                return statements;
        };

        function make_if(c, t, e) {
                return when_constant(c, function(ast, val){
                        if (val) {
                                t = walk(t);
                                warn_unreachable(e);
                                return t || [ "block" ];
                        } else {
                                e = walk(e);
                                warn_unreachable(t);
                                return e || [ "block" ];
                        }
                }, function() {
                        return make_real_if(c, t, e);
                });
        };

        function abort_else(c, t, e) {
                var ret = [ [ "if", negate(c), e ] ];
                if (t[0] == "block") {
                        if (t[1]) ret = ret.concat(t[1]);
                } else {
                        ret.push(t);
                }
                return walk([ "block", ret ]);
        };

        function make_real_if(c, t, e) {
                c = walk(c);
                t = walk(t);
                e = walk(e);

                if (empty(e) && empty(t))
                        return [ "stat", c ];

                if (empty(t)) {
                        c = negate(c);
                        t = e;
                        e = null;
                } else if (empty(e)) {
                        e = null;
                } else {
                        // if we have both else and then, maybe it makes sense to switch them?
                        (function(){
                                var a = gen_code(c);
                                var n = negate(c);
                                var b = gen_code(n);
                                if (b.length < a.length) {
                                        var tmp = t;
                                        t = e;
                                        e = tmp;
                                        c = n;
                                }
                        })();
                }
                var ret = [ "if", c, t, e ];
                if (t[0] == "if" && empty(t[3]) && empty(e)) {
                        ret = best_of(ret, walk([ "if", [ "binary", "&&", c, t[1] ], t[2] ]));
                }
                else if (t[0] == "stat") {
                        if (e) {
                                if (e[0] == "stat")
                                        ret = best_of(ret, [ "stat", make_conditional(c, t[1], e[1]) ]);
                                else if (aborts(e))
                                        ret = abort_else(c, t, e);
                        }
                        else {
                                ret = best_of(ret, [ "stat", make_conditional(c, t[1]) ]);
                        }
                }
                else if (e && t[0] == e[0] && (t[0] == "return" || t[0] == "throw") && t[1] && e[1]) {
                        ret = best_of(ret, [ t[0], make_conditional(c, t[1], e[1] ) ]);
                }
                else if (e && aborts(t)) {
                        ret = [ [ "if", c, t ] ];
                        if (e[0] == "block") {
                                if (e[1]) ret = ret.concat(e[1]);
                        }
                        else {
                                ret.push(e);
                        }
                        ret = walk([ "block", ret ]);
                }
                else if (t && aborts(e)) {
                        ret = abort_else(c, t, e);
                }
                return ret;
        };

        function _do_while(cond, body) {
                return when_constant(cond, function(cond, val){
                        if (!val) {
                                warn_unreachable(body);
                                return [ "block" ];
                        } else {
                                return [ "for", null, null, null, walk(body) ];
                        }
                });
        };

        return w.with_walkers({
                "sub": function(expr, subscript) {
                        if (subscript[0] == "string") {
                                var name = subscript[1];
                                if (is_identifier(name))
                                        return [ "dot", walk(expr), name ];
                                else if (/^[1-9][0-9]*$/.test(name) || name === "0")
                                        return [ "sub", walk(expr), [ "num", parseInt(name, 10) ] ];
                        }
                },
                "if": make_if,
                "toplevel": function(body) {
                        return [ "toplevel", tighten(body) ];
                },
                "switch": function(expr, body) {
                        var last = body.length - 1;
                        return [ "switch", walk(expr), MAP(body, function(branch, i){
                                var block = tighten(branch[1]);
                                if (i == last && block.length > 0) {
                                        var node = block[block.length - 1];
                                        if (node[0] == "break" && !node[1])
                                                block.pop();
                                }
                                return [ branch[0] ? walk(branch[0]) : null, block ];
                        }) ];
                },
                "function": _lambda,
                "defun": _lambda,
                "block": function(body) {
                        if (body) return rmblock([ "block", tighten(body) ]);
                },
                "binary": function(op, left, right) {
                        return when_constant([ "binary", op, walk(left), walk(right) ], function yes(c){
                                return best_of(walk(c), this);
                        }, function no() {
                                return function(){
                                        if(op != "==" && op != "!=") return;
                                        var l = walk(left), r = walk(right);
                                        if(l && l[0] == "unary-prefix" && l[1] == "!" && l[2][0] == "num")
                                                left = ['num', +!l[2][1]];
                                        else if (r && r[0] == "unary-prefix" && r[1] == "!" && r[2][0] == "num")
                                                right = ['num', +!r[2][1]];
                                        return ["binary", op, left, right];
                                }() || this;
                        });
                },
                "conditional": function(c, t, e) {
                        return make_conditional(walk(c), walk(t), walk(e));
                },
                "try": function(t, c, f) {
                        return [
                                "try",
                                tighten(t),
                                c != null ? [ c[0], tighten(c[1]) ] : null,
                                f != null ? tighten(f) : null
                        ];
                },
                "unary-prefix": function(op, expr) {
                        expr = walk(expr);
                        var ret = [ "unary-prefix", op, expr ];
                        if (op == "!")
                                ret = best_of(ret, negate(expr));
                        return when_constant(ret, function(ast, val){
                                return walk(ast); // it's either true or false, so minifies to !0 or !1
                        }, function() { return ret });
                },
                "name": function(name) {
                        switch (name) {
                            case "true": return [ "unary-prefix", "!", [ "num", 0 ]];
                            case "false": return [ "unary-prefix", "!", [ "num", 1 ]];
                        }
                },
                "while": _do_while,
                "assign": function(op, lvalue, rvalue) {
                        lvalue = walk(lvalue);
                        rvalue = walk(rvalue);
                        var okOps = [ '+', '-', '/', '*', '%', '>>', '<<', '>>>', '|', '^', '&' ];
                        if (op === true && lvalue[0] === "name" && rvalue[0] === "binary" &&
                            ~okOps.indexOf(rvalue[1]) && rvalue[2][0] === "name" &&
                            rvalue[2][1] === lvalue[1]) {
                                return [ this[0], rvalue[1], lvalue, rvalue[3] ]
                        }
                        return [ this[0], op, lvalue, rvalue ];
                },
                "call": function(expr, args) {
                        expr = walk(expr);
                        if (options.unsafe && expr[0] == "dot" && expr[1][0] == "string" && expr[2] == "toString") {
                                return expr[1];
                        }
                        return [ this[0], expr,  MAP(args, walk) ];
                },
                "num": function (num) {
                        if (!isFinite(num))
                                return [ "binary", "/", num === 1 / 0
                                         ? [ "num", 1 ] : num === -1 / 0
                                         ? [ "unary-prefix", "-", [ "num", 1 ] ]
                                         : [ "num", 0 ], [ "num", 0 ] ];

                        return [ this[0], num ];
                }
        }, function() {
                return walk(prepare_ifs(walk(prepare_ifs(ast))));
        });
};

function squeeze_2(ast, options) {
        var w = ast_walker(), walk = w.walk, scope;
        function with_scope(s, cont) {
                var save = scope, ret;
                scope = s;
                ret = cont();
                scope = save;
                return ret;
        };
        function lambda(name, args, body) {
                return [ this[0], name, args, with_scope(body.scope, curry(MAP, body, walk)) ];
        };
        return w.with_walkers({
                "directive": function(dir) {
                        if (scope.active_directive(dir))
                                return [ "block" ];
                        scope.directives.push(dir);
                },
                "toplevel": function(body) {
                        return [ this[0], with_scope(this.scope, curry(MAP, body, walk)) ];
                },
                "function": lambda,
                "defun": lambda
        }, function(){
                return walk(ast_add_scope(ast));
        });
};

/* -----[ re-generate code from the AST ]----- */

var DOT_CALL_NO_PARENS = jsp.array_to_hash([
        "name",
        "array",
        "object",
        "string",
        "dot",
        "sub",
        "call",
        "regexp",
        "defun"
]);

function make_string(str, ascii_only) {
        var dq = 0, sq = 0;
        str = str.replace(/[\\\b\f\n\r\t\x22\x27\u2028\u2029\0]/g, function(s){
                switch (s) {
                    case "\\": return "\\\\";
                    case "\b": return "\\b";
                    case "\f": return "\\f";
                    case "\n": return "\\n";
                    case "\r": return "\\r";
                    case "\u2028": return "\\u2028";
                    case "\u2029": return "\\u2029";
                    case '"': ++dq; return '"';
                    case "'": ++sq; return "'";
                    case "\0": return "\\0";
                }
                return s;
        });
        if (ascii_only) str = to_ascii(str);
        if (dq > sq) return "'" + str.replace(/\x27/g, "\\'") + "'";
        else return '"' + str.replace(/\x22/g, '\\"') + '"';
};

function to_ascii(str) {
        return str.replace(/[\u0080-\uffff]/g, function(ch) {
                var code = ch.charCodeAt(0).toString(16);
                while (code.length < 4) code = "0" + code;
                return "\\u" + code;
        });
};

var SPLICE_NEEDS_BRACKETS = jsp.array_to_hash([ "if", "while", "do", "for", "for-in", "with" ]);

function gen_code(ast, options) {
        options = defaults(options, {
                indent_start : 0,
                indent_level : 4,
                quote_keys   : false,
                space_colon  : false,
                beautify     : false,
                ascii_only   : false,
                inline_script: false
        });
        var beautify = !!options.beautify;
        var indentation = 0,
            newline = beautify ? "\n" : "",
            space = beautify ? " " : "";

        function encode_string(str) {
                var ret = make_string(str, options.ascii_only);
                if (options.inline_script)
                        ret = ret.replace(/<\x2fscript([>\/\t\n\f\r ])/gi, "<\\/script$1");
                return ret;
        };

        function make_name(name) {
                name = name.toString();
                if (options.ascii_only)
                        name = to_ascii(name);
                return name;
        };

        function indent(line) {
                if (line == null)
                        line = "";
                if (beautify)
                        line = repeat_string(" ", options.indent_start + indentation * options.indent_level) + line;
                return line;
        };

        function with_indent(cont, incr) {
                if (incr == null) incr = 1;
                indentation += incr;
                try { return cont.apply(null, slice(arguments, 1)); }
                finally { indentation -= incr; }
        };

        function last_char(str) {
                str = str.toString();
                return str.charAt(str.length - 1);
        };

        function first_char(str) {
                return str.toString().charAt(0);
        };

        function add_spaces(a) {
                if (beautify)
                        return a.join(" ");
                var b = [];
                for (var i = 0; i < a.length; ++i) {
                        var next = a[i + 1];
                        b.push(a[i]);
                        if (next &&
                            ((is_identifier_char(last_char(a[i])) && (is_identifier_char(first_char(next))
                                                                      || first_char(next) == "\\")) ||
                             (/[\+\-]$/.test(a[i].toString()) && /^[\+\-]/.test(next.toString())))) {
                                b.push(" ");
                        }
                }
                return b.join("");
        };

        function add_commas(a) {
                return a.join("," + space);
        };

        function parenthesize(expr) {
                var gen = make(expr);
                for (var i = 1; i < arguments.length; ++i) {
                        var el = arguments[i];
                        if ((el instanceof Function && el(expr)) || expr[0] == el)
                                return "(" + gen + ")";
                }
                return gen;
        };

        function best_of(a) {
                if (a.length == 1) {
                        return a[0];
                }
                if (a.length == 2) {
                        var b = a[1];
                        a = a[0];
                        return a.length <= b.length ? a : b;
                }
                return best_of([ a[0], best_of(a.slice(1)) ]);
        };

        function needs_parens(expr) {
                if (expr[0] == "function" || expr[0] == "object") {
                        // dot/call on a literal function requires the
                        // function literal itself to be parenthesized
                        // only if it's the first "thing" in a
                        // statement.  This means that the parent is
                        // "stat", but it could also be a "seq" and
                        // we're the first in this "seq" and the
                        // parent is "stat", and so on.  Messy stuff,
                        // but it worths the trouble.
                        var a = slice(w.stack()), self = a.pop(), p = a.pop();
                        while (p) {
                                if (p[0] == "stat") return true;
                                if (((p[0] == "seq" || p[0] == "call" || p[0] == "dot" || p[0] == "sub" || p[0] == "conditional") && p[1] === self) ||
                                    ((p[0] == "binary" || p[0] == "assign" || p[0] == "unary-postfix") && p[2] === self)) {
                                        self = p;
                                        p = a.pop();
                                } else {
                                        return false;
                                }
                        }
                }
                return !HOP(DOT_CALL_NO_PARENS, expr[0]);
        };

        function make_num(num) {
                var str = num.toString(10), a = [ str.replace(/^0\./, ".").replace('e+', 'e') ], m;
                if (Math.floor(num) === num) {
                        if (num >= 0) {
                                a.push("0x" + num.toString(16).toLowerCase(), // probably pointless
                                       "0" + num.toString(8)); // same.
                        } else {
                                a.push("-0x" + (-num).toString(16).toLowerCase(), // probably pointless
                                       "-0" + (-num).toString(8)); // same.
                        }
                        if ((m = /^(.*?)(0+)$/.exec(num))) {
                                a.push(m[1] + "e" + m[2].length);
                        }
                } else if ((m = /^0?\.(0+)(.*)$/.exec(num))) {
                        a.push(m[2] + "e-" + (m[1].length + m[2].length),
                               str.substr(str.indexOf(".")));
                }
                return best_of(a);
        };

        var w = ast_walker();
        var make = w.walk;
        return w.with_walkers({
                "string": encode_string,
                "num": make_num,
                "name": make_name,
                "debugger": function(){ return "debugger;" },
                "toplevel": function(statements) {
                        return make_block_statements(statements)
                                .join(newline + newline);
                },
                "splice": function(statements) {
                        var parent = w.parent();
                        if (HOP(SPLICE_NEEDS_BRACKETS, parent)) {
                                // we need block brackets in this case
                                return make_block.apply(this, arguments);
                        } else {
                                return MAP(make_block_statements(statements, true),
                                           function(line, i) {
                                                   // the first line is already indented
                                                   return i > 0 ? indent(line) : line;
                                           }).join(newline);
                        }
                },
                "block": make_block,
                "var": function(defs) {
                        return "var " + add_commas(MAP(defs, make_1vardef)) + ";";
                },
                "const": function(defs) {
                        return "const " + add_commas(MAP(defs, make_1vardef)) + ";";
                },
                "try": function(tr, ca, fi) {
                        var out = [ "try", make_block(tr) ];
                        if (ca) out.push("catch", "(" + ca[0] + ")", make_block(ca[1]));
                        if (fi) out.push("finally", make_block(fi));
                        return add_spaces(out);
                },
                "throw": function(expr) {
                        return add_spaces([ "throw", make(expr) ]) + ";";
                },
                "new": function(ctor, args) {
                        args = args.length > 0 ? "(" + add_commas(MAP(args, function(expr){
                                return parenthesize(expr, "seq");
                        })) + ")" : "";
                        return add_spaces([ "new", parenthesize(ctor, "seq", "binary", "conditional", "assign", function(expr){
                                var w = ast_walker(), has_call = {};
                                try {
                                        w.with_walkers({
                                                "call": function() { throw has_call },
                                                "function": function() { return this }
                                        }, function(){
                                                w.walk(expr);
                                        });
                                } catch(ex) {
                                        if (ex === has_call)
                                                return true;
                                        throw ex;
                                }
                        }) + args ]);
                },
                "switch": function(expr, body) {
                        return add_spaces([ "switch", "(" + make(expr) + ")", make_switch_block(body) ]);
                },
                "break": function(label) {
                        var out = "break";
                        if (label != null)
                                out += " " + make_name(label);
                        return out + ";";
                },
                "continue": function(label) {
                        var out = "continue";
                        if (label != null)
                                out += " " + make_name(label);
                        return out + ";";
                },
                "conditional": function(co, th, el) {
                        return add_spaces([ parenthesize(co, "assign", "seq", "conditional"), "?",
                                            parenthesize(th, "seq"), ":",
                                            parenthesize(el, "seq") ]);
                },
                "assign": function(op, lvalue, rvalue) {
                        if (op && op !== true) op += "=";
                        else op = "=";
                        return add_spaces([ make(lvalue), op, parenthesize(rvalue, "seq") ]);
                },
                "dot": function(expr) {
                        var out = make(expr), i = 1;
                        if (expr[0] == "num") {
                                if (!/[a-f.]/i.test(out))
                                        out += ".";
                        } else if (expr[0] != "function" && needs_parens(expr))
                                out = "(" + out + ")";
                        while (i < arguments.length)
                                out += "." + make_name(arguments[i++]);
                        return out;
                },
                "call": function(func, args) {
                        var f = make(func);
                        if (f.charAt(0) != "(" && needs_parens(func))
                                f = "(" + f + ")";
                        return f + "(" + add_commas(MAP(args, function(expr){
                                return parenthesize(expr, "seq");
                        })) + ")";
                },
                "function": make_function,
                "defun": make_function,
                "if": function(co, th, el) {
                        var out = [ "if", "(" + make(co) + ")", el ? make_then(th) : make(th) ];
                        if (el) {
                                out.push("else", make(el));
                        }
                        return add_spaces(out);
                },
                "for": function(init, cond, step, block) {
                        var out = [ "for" ];
                        init = (init != null ? make(init) : "").replace(/;*\s*$/, ";" + space);
                        cond = (cond != null ? make(cond) : "").replace(/;*\s*$/, ";" + space);
                        step = (step != null ? make(step) : "").replace(/;*\s*$/, "");
                        var args = init + cond + step;
                        if (args == "; ; ") args = ";;";
                        out.push("(" + args + ")", make(block));
                        return add_spaces(out);
                },
                "for-in": function(vvar, key, hash, block) {
                        return add_spaces([ "for", "(" +
                                            (vvar ? make(vvar).replace(/;+$/, "") : make(key)),
                                            "in",
                                            make(hash) + ")", make(block) ]);
                },
                "while": function(condition, block) {
                        return add_spaces([ "while", "(" + make(condition) + ")", make(block) ]);
                },
                "do": function(condition, block) {
                        return add_spaces([ "do", make(block), "while", "(" + make(condition) + ")" ]) + ";";
                },
                "return": function(expr) {
                        var out = [ "return" ];
                        if (expr != null) out.push(make(expr));
                        return add_spaces(out) + ";";
                },
                "binary": function(operator, lvalue, rvalue) {
                        var left = make(lvalue), right = make(rvalue);
                        // XXX: I'm pretty sure other cases will bite here.
                        //      we need to be smarter.
                        //      adding parens all the time is the safest bet.
                        if (member(lvalue[0], [ "assign", "conditional", "seq" ]) ||
                            lvalue[0] == "binary" && PRECEDENCE[operator] > PRECEDENCE[lvalue[1]] ||
                            lvalue[0] == "function" && needs_parens(this)) {
                                left = "(" + left + ")";
                        }
                        if (member(rvalue[0], [ "assign", "conditional", "seq" ]) ||
                            rvalue[0] == "binary" && PRECEDENCE[operator] >= PRECEDENCE[rvalue[1]] &&
                            !(rvalue[1] == operator && member(operator, [ "&&", "||", "*" ]))) {
                                right = "(" + right + ")";
                        }
                        else if (!beautify && options.inline_script && (operator == "<" || operator == "<<")
                                 && rvalue[0] == "regexp" && /^script/i.test(rvalue[1])) {
                                right = " " + right;
                        }
                        return add_spaces([ left, operator, right ]);
                },
                "unary-prefix": function(operator, expr) {
                        var val = make(expr);
                        if (!(expr[0] == "num" || (expr[0] == "unary-prefix" && !HOP(OPERATORS, operator + expr[1])) || !needs_parens(expr)))
                                val = "(" + val + ")";
                        return operator + (jsp.is_alphanumeric_char(operator.charAt(0)) ? " " : "") + val;
                },
                "unary-postfix": function(operator, expr) {
                        var val = make(expr);
                        if (!(expr[0] == "num" || (expr[0] == "unary-postfix" && !HOP(OPERATORS, operator + expr[1])) || !needs_parens(expr)))
                                val = "(" + val + ")";
                        return val + operator;
                },
                "sub": function(expr, subscript) {
                        var hash = make(expr);
                        if (needs_parens(expr))
                                hash = "(" + hash + ")";
                        return hash + "[" + make(subscript) + "]";
                },
                "object": function(props) {
                        var obj_needs_parens = needs_parens(this);
                        if (props.length == 0)
                                return obj_needs_parens ? "({})" : "{}";
                        var out = "{" + newline + with_indent(function(){
                                return MAP(props, function(p){
                                        if (p.length == 3) {
                                                // getter/setter.  The name is in p[0], the arg.list in p[1][2], the
                                                // body in p[1][3] and type ("get" / "set") in p[2].
                                                return indent(make_function(p[0], p[1][2], p[1][3], p[2], true));
                                        }
                                        var key = p[0], val = parenthesize(p[1], "seq");
                                        if (options.quote_keys) {
                                                key = encode_string(key);
                                        } else if ((typeof key == "number" || !beautify && +key + "" == key)
                                                   && parseFloat(key) >= 0) {
                                                key = make_num(+key);
                                        } else if (!is_identifier(key)) {
                                                key = encode_string(key);
                                        }
                                        return indent(add_spaces(beautify && options.space_colon
                                                                 ? [ key, ":", val ]
                                                                 : [ key + ":", val ]));
                                }).join("," + newline);
                        }) + newline + indent("}");
                        return obj_needs_parens ? "(" + out + ")" : out;
                },
                "regexp": function(rx, mods) {
                        if (options.ascii_only) rx = to_ascii(rx);
                        return "/" + rx + "/" + mods;
                },
                "array": function(elements) {
                        if (elements.length == 0) return "[]";
                        return add_spaces([ "[", add_commas(MAP(elements, function(el, i){
                                if (!beautify && el[0] == "atom" && el[1] == "undefined") return i === elements.length - 1 ? "," : "";
                                return parenthesize(el, "seq");
                        })), "]" ]);
                },
                "stat": function(stmt) {
                        return stmt != null
                                ? make(stmt).replace(/;*\s*$/, ";")
                                : ";";
                },
                "seq": function() {
                        return add_commas(MAP(slice(arguments), make));
                },
                "label": function(name, block) {
                        return add_spaces([ make_name(name), ":", make(block) ]);
                },
                "with": function(expr, block) {
                        return add_spaces([ "with", "(" + make(expr) + ")", make(block) ]);
                },
                "atom": function(name) {
                        return make_name(name);
                },
                "directive": function(dir) {
                        return make_string(dir) + ";";
                }
        }, function(){ return make(ast) });

        // The squeezer replaces "block"-s that contain only a single
        // statement with the statement itself; technically, the AST
        // is correct, but this can create problems when we output an
        // IF having an ELSE clause where the THEN clause ends in an
        // IF *without* an ELSE block (then the outer ELSE would refer
        // to the inner IF).  This function checks for this case and
        // adds the block brackets if needed.
        function make_then(th) {
                if (th == null) return ";";
                if (th[0] == "do") {
                        // https://github.com/mishoo/UglifyJS/issues/#issue/57
                        // IE croaks with "syntax error" on code like this:
                        //     if (foo) do ... while(cond); else ...
                        // we need block brackets around do/while
                        return make_block([ th ]);
                }
                var b = th;
                while (true) {
                        var type = b[0];
                        if (type == "if") {
                                if (!b[3])
                                        // no else, we must add the block
                                        return make([ "block", [ th ]]);
                                b = b[3];
                        }
                        else if (type == "while" || type == "do") b = b[2];
                        else if (type == "for" || type == "for-in") b = b[4];
                        else break;
                }
                return make(th);
        };

        function make_function(name, args, body, keyword, no_parens) {
                var out = keyword || "function";
                if (name) {
                        out += " " + make_name(name);
                }
                out += "(" + add_commas(MAP(args, make_name)) + ")";
                out = add_spaces([ out, make_block(body) ]);
                return (!no_parens && needs_parens(this)) ? "(" + out + ")" : out;
        };

        function must_has_semicolon(node) {
                switch (node[0]) {
                    case "with":
                    case "while":
                        return empty(node[2]) || must_has_semicolon(node[2]);
                    case "for":
                    case "for-in":
                        return empty(node[4]) || must_has_semicolon(node[4]);
                    case "if":
                        if (empty(node[2]) && !node[3]) return true; // `if' with empty `then' and no `else'
                        if (node[3]) {
                                if (empty(node[3])) return true; // `else' present but empty
                                return must_has_semicolon(node[3]); // dive into the `else' branch
                        }
                        return must_has_semicolon(node[2]); // dive into the `then' branch
                    case "directive":
                        return true;
                }
        };

        function make_block_statements(statements, noindent) {
                for (var a = [], last = statements.length - 1, i = 0; i <= last; ++i) {
                        var stat = statements[i];
                        var code = make(stat);
                        if (code != ";") {
                                if (!beautify && i == last && !must_has_semicolon(stat)) {
                                        code = code.replace(/;+\s*$/, "");
                                }
                                a.push(code);
                        }
                }
                return noindent ? a : MAP(a, indent);
        };

        function make_switch_block(body) {
                var n = body.length;
                if (n == 0) return "{}";
                return "{" + newline + MAP(body, function(branch, i){
                        var has_body = branch[1].length > 0, code = with_indent(function(){
                                return indent(branch[0]
                                              ? add_spaces([ "case", make(branch[0]) + ":" ])
                                              : "default:");
                        }, 0.5) + (has_body ? newline + with_indent(function(){
                                return make_block_statements(branch[1]).join(newline);
                        }) : "");
                        if (!beautify && has_body && i < n - 1)
                                code += ";";
                        return code;
                }).join(newline) + newline + indent("}");
        };

        function make_block(statements) {
                if (!statements) return ";";
                if (statements.length == 0) return "{}";
                return "{" + newline + with_indent(function(){
                        return make_block_statements(statements).join(newline);
                }) + newline + indent("}");
        };

        function make_1vardef(def) {
                var name = def[0], val = def[1];
                if (val != null)
                        name = add_spaces([ make_name(name), "=", parenthesize(val, "seq") ]);
                return name;
        };

};

function split_lines(code, max_line_length) {
        var splits = [ 0 ];
        jsp.parse(function(){
                var next_token = jsp.tokenizer(code);
                var last_split = 0;
                var prev_token;
                function current_length(tok) {
                        return tok.pos - last_split;
                };
                function split_here(tok) {
                        last_split = tok.pos;
                        splits.push(last_split);
                };
                function custom(){
                        var tok = next_token.apply(this, arguments);
                        out: {
                                if (prev_token) {
                                        if (prev_token.type == "keyword") break out;
                                }
                                if (current_length(tok) > max_line_length) {
                                        switch (tok.type) {
                                            case "keyword":
                                            case "atom":
                                            case "name":
                                            case "punc":
                                                split_here(tok);
                                                break out;
                                        }
                                }
                        }
                        prev_token = tok;
                        return tok;
                };
                custom.context = function() {
                        return next_token.context.apply(this, arguments);
                };
                return custom;
        }());
        return splits.map(function(pos, i){
                return code.substring(pos, splits[i + 1] || code.length);
        }).join("\n");
};

/* -----[ Utilities ]----- */

function repeat_string(str, i) {
        if (i <= 0) return "";
        if (i == 1) return str;
        var d = repeat_string(str, i >> 1);
        d += d;
        if (i & 1) d += str;
        return d;
};

function defaults(args, defs) {
        var ret = {};
        if (args === true)
                args = {};
        for (var i in defs) if (HOP(defs, i)) {
                ret[i] = (args && HOP(args, i)) ? args[i] : defs[i];
        }
        return ret;
};

function is_identifier(name) {
        return /^[a-z_$][a-z0-9_$]*$/i.test(name)
                && name != "this"
                && !HOP(jsp.KEYWORDS_ATOM, name)
                && !HOP(jsp.RESERVED_WORDS, name)
                && !HOP(jsp.KEYWORDS, name);
};

function HOP(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
};

// some utilities

var MAP;

(function(){
        MAP = function(a, f, o) {
                var ret = [], top = [], i;
                function doit() {
                        var val = f.call(o, a[i], i);
                        if (val instanceof AtTop) {
                                val = val.v;
                                if (val instanceof Splice) {
                                        top.push.apply(top, val.v);
                                } else {
                                        top.push(val);
                                }
                        }
                        else if (val != skip) {
                                if (val instanceof Splice) {
                                        ret.push.apply(ret, val.v);
                                } else {
                                        ret.push(val);
                                }
                        }
                };
                if (a instanceof Array) for (i = 0; i < a.length; ++i) doit();
                else for (i in a) if (HOP(a, i)) doit();
                return top.concat(ret);
        };
        MAP.at_top = function(val) { return new AtTop(val) };
        MAP.splice = function(val) { return new Splice(val) };
        var skip = MAP.skip = {};
        function AtTop(val) { this.v = val };
        function Splice(val) { this.v = val };
})();

/* -----[ Exports ]----- */

exports.ast_walker = ast_walker;
exports.ast_mangle = ast_mangle;
exports.ast_squeeze = ast_squeeze;
exports.ast_lift_variables = ast_lift_variables;
exports.gen_code = gen_code;
exports.ast_add_scope = ast_add_scope;
exports.set_logger = function(logger) { warn = logger };
exports.make_string = make_string;
exports.split_lines = split_lines;
exports.MAP = MAP;

// keep this last!
exports.ast_squeeze_more = require("./squeeze-more").ast_squeeze_more;

// Local variables:
// js-indent-level: 8
// End:

},{"./parse-js":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/parse-js.js","./squeeze-more":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/squeeze-more.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/squeeze-more.js":[function(require,module,exports){
var jsp = require("./parse-js"),
    pro = require("./process"),
    slice = jsp.slice,
    member = jsp.member,
    curry = jsp.curry,
    MAP = pro.MAP,
    PRECEDENCE = jsp.PRECEDENCE,
    OPERATORS = jsp.OPERATORS;

function ast_squeeze_more(ast) {
        var w = pro.ast_walker(), walk = w.walk, scope;
        function with_scope(s, cont) {
                var save = scope, ret;
                scope = s;
                ret = cont();
                scope = save;
                return ret;
        };
        function _lambda(name, args, body) {
                return [ this[0], name, args, with_scope(body.scope, curry(MAP, body, walk)) ];
        };
        return w.with_walkers({
                "toplevel": function(body) {
                        return [ this[0], with_scope(this.scope, curry(MAP, body, walk)) ];
                },
                "function": _lambda,
                "defun": _lambda,
                "new": function(ctor, args) {
                        if (ctor[0] == "name") {
                                if (ctor[1] == "Array" && !scope.has("Array")) {
                                        if (args.length != 1) {
                                                return [ "array", args ];
                                        } else {
                                                return walk([ "call", [ "name", "Array" ], args ]);
                                        }
                                } else if (ctor[1] == "Object" && !scope.has("Object")) {
                                        if (!args.length) {
                                                return [ "object", [] ];
                                        } else {
                                                return walk([ "call", [ "name", "Object" ], args ]);
                                        }
                                } else if ((ctor[1] == "RegExp" || ctor[1] == "Function" || ctor[1] == "Error") && !scope.has(ctor[1])) {
                                        return walk([ "call", [ "name", ctor[1] ], args]);
                                }
                        }
                },
                "call": function(expr, args) {
                        if (expr[0] == "dot" && expr[1][0] == "string" && args.length == 1
                            && (args[0][1] > 0 && expr[2] == "substring" || expr[2] == "substr")) {
                                return [ "call", [ "dot", expr[1], "slice"], args];
                        }
                        if (expr[0] == "dot" && expr[2] == "toString" && args.length == 0) {
                                // foo.toString()  ==>  foo+""
                                if (expr[1][0] == "string") return expr[1];
                                return [ "binary", "+", expr[1], [ "string", "" ]];
                        }
                        if (expr[0] == "name") {
                                if (expr[1] == "Array" && args.length != 1 && !scope.has("Array")) {
                                        return [ "array", args ];
                                }
                                if (expr[1] == "Object" && !args.length && !scope.has("Object")) {
                                        return [ "object", [] ];
                                }
                                if (expr[1] == "String" && !scope.has("String")) {
                                        return [ "binary", "+", args[0], [ "string", "" ]];
                                }
                        }
                }
        }, function() {
                return walk(pro.ast_add_scope(ast));
        });
};

exports.ast_squeeze_more = ast_squeeze_more;

// Local variables:
// js-indent-level: 8
// End:

},{"./parse-js":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/parse-js.js","./process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/process.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/uglify-js.js":[function(require,module,exports){
//convienence function(src, [options]);
function uglify(orig_code, options){
  options || (options = {});
  var jsp = uglify.parser;
  var pro = uglify.uglify;

  var ast = jsp.parse(orig_code, options.strict_semicolons); // parse code and get the initial AST
  ast = pro.ast_mangle(ast, options.mangle_options); // get a new AST with mangled names
  ast = pro.ast_squeeze(ast, options.squeeze_options); // get an AST with compression optimizations
  var final_code = pro.gen_code(ast, options.gen_options); // compressed code here
  return final_code;
};

uglify.parser = require("./lib/parse-js");
uglify.uglify = require("./lib/process");
uglify.consolidator = require("./lib/consolidator");

module.exports = uglify

},{"./lib/consolidator":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/consolidator.js","./lib/parse-js":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/parse-js.js","./lib/process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/process.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/underscore/underscore.js":[function(require,module,exports){
//     Underscore.js 1.3.3
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore is freely distributable under the MIT license.
//     Portions of Underscore are inspired or borrowed from Prototype,
//     Oliver Steele's Functional, and John Resig's Micro-Templating.
//     For all details and documentation:
//     http://documentcloud.github.com/underscore

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var slice            = ArrayProto.slice,
      unshift          = ArrayProto.unshift,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) { return new wrapper(obj); };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root['_'] = _;
  }

  // Current version.
  _.VERSION = '1.3.3';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    if (obj.length === +obj.length) results.length = obj.length;
    return results;
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError('Reduce of empty array with no initial value');
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var reversed = _.toArray(obj).reverse();
    if (context && !initial) iterator = _.bind(iterator, context);
    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    each(obj, function(value, index, list) {
      if (!iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if a given value is included in the array or object using `===`.
  // Aliased as `contains`.
  _.include = _.contains = function(obj, target) {
    var found = false;
    if (obj == null) return found;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    found = any(obj, function(value) {
      return value === target;
    });
    return found;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    return _.map(obj, function(value) {
      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Return the maximum element or (element-based computation).
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var shuffled = [], rand;
    each(obj, function(value, index, list) {
      rand = Math.floor(Math.random() * (index + 1));
      shuffled[index] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, val, context) {
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      if (a === void 0) return 1;
      if (b === void 0) return -1;
      return a < b ? -1 : a > b ? 1 : 0;
    }), 'value');
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, val) {
    var result = {};
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    each(obj, function(value, index) {
      var key = iterator(value, index);
      (result[key] || (result[key] = [])).push(value);
    });
    return result;
  };

  // Use a comparator function to figure out at what index an object should
  // be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator) {
    iterator || (iterator = _.identity);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >> 1;
      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj)                                     return [];
    if (_.isArray(obj))                           return slice.call(obj);
    if (_.isArguments(obj))                       return slice.call(obj);
    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    return _.isArray(obj) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especcialy useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail`.
  // Especially useful on the arguments object. Passing an **index** will return
  // the rest of the values in the array from that index onward. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = function(array, index, guard) {
    return slice.call(array, (index == null) || guard ? 1 : index);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, function(value){ return !!value; });
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return _.reduce(array, function(memo, value) {
      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));
      memo[memo.length] = value;
      return memo;
    }, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator) {
    var initial = iterator ? _.map(array, iterator) : array;
    var results = [];
    // The `isSorted` flag is irrelevant if the array only contains two elements.
    if (array.length < 3) isSorted = true;
    _.reduce(initial, function (memo, value, index) {
      if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {
        memo.push(value);
        results.push(array[index]);
      }
      return memo;
    }, []);
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays. (Aliased as "intersect" for back-compat.)
  _.intersection = _.intersect = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = _.flatten(slice.call(arguments, 1), true);
    return _.filter(array, function(value){ return !_.include(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) results[i] = _.pluck(args, "" + i);
    return results;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i, l;
    if (isSorted) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item) {
    if (array == null) return -1;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
    var i = array.length;
    while (i--) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Binding with arguments is also known as `curry`.
  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
  // We check for `func.bind` first, to fail fast when `func` is undefined.
  _.bind = function bind(func, context) {
    var bound, args;
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length == 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, throttling, more, result;
    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);
    return function() {
      context = this; args = arguments;
      var later = function() {
        timeout = null;
        if (more) func.apply(context, args);
        whenDone();
      };
      if (!timeout) timeout = setTimeout(later, wait);
      if (throttling) {
        more = true;
      } else {
        result = func.apply(context, args);
      }
      whenDone();
      throttling = true;
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      if (immediate && !timeout) func.apply(context, args);
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      return memo = func.apply(this, arguments);
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func].concat(slice.call(arguments, 0));
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) { return func.apply(this, arguments); }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    return _.map(obj, _.identity);
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var result = {};
    each(_.flatten(slice.call(arguments, 1)), function(key) {
      if (key in obj) result[key] = obj[key];
    });
    return result;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        if (obj[prop] == null) obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function.
  function eq(a, b, stack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a._chain) a = a._wrapped;
    if (b._chain) b = b._wrapped;
    // Invoke a custom `isEqual` method if one is provided.
    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);
    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = stack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (stack[length] == a) return true;
    }
    // Add the first object to the stack of traversed objects.
    stack.push(a);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          // Ensure commutative equality for sparse arrays.
          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent.
      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    stack.pop();
    return result;
  }

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType == 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Is a given variable an arguments object?
  _.isArguments = function(obj) {
    return toString.call(obj) == '[object Arguments]';
  };
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Is a given value a function?
  _.isFunction = function(obj) {
    return toString.call(obj) == '[object Function]';
  };

  // Is a given value a string?
  _.isString = function(obj) {
    return toString.call(obj) == '[object String]';
  };

  // Is a given value a number?
  _.isNumber = function(obj) {
    return toString.call(obj) == '[object Number]';
  };

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return _.isNumber(obj) && isFinite(obj);
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    // `NaN` is the only value for which `===` is not reflexive.
    return obj !== obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value a date?
  _.isDate = function(obj) {
    return toString.call(obj) == '[object Date]';
  };

  // Is the given value a regular expression?
  _.isRegExp = function(obj) {
    return toString.call(obj) == '[object RegExp]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Has own property?
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function (n, iterator, context) {
    for (var i = 0; i < n; i++) iterator.call(context, i);
  };

  // Escape a string for HTML interpolation.
  _.escape = function(string) {
    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g,'&#x2F;');
  };

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object, ensuring that
  // they're correctly added to the OOP wrapper as well.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      addToWrapper(name, _[name] = obj[name]);
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = idCounter++;
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /.^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    '\\': '\\',
    "'": "'",
    'r': '\r',
    'n': '\n',
    't': '\t',
    'u2028': '\u2028',
    'u2029': '\u2029'
  };

  for (var p in escapes) escapes[escapes[p]] = p;
  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
  var unescaper = /\\(\\|'|r|n|t|u2028|u2029)/g;

  // Within an interpolation, evaluation, or escaping, remove HTML escaping
  // that had been previously added.
  var unescape = function(code) {
    return code.replace(unescaper, function(match, escape) {
      return escapes[escape];
    });
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    settings = _.defaults(settings || {}, _.templateSettings);

    // Compile the template source, taking care to escape characters that
    // cannot be included in a string literal and then unescape them in code
    // blocks.
    var source = "__p+='" + text
      .replace(escaper, function(match) {
        return '\\' + escapes[match];
      })
      .replace(settings.escape || noMatch, function(match, code) {
        return "'+\n_.escape(" + unescape(code) + ")+\n'";
      })
      .replace(settings.interpolate || noMatch, function(match, code) {
        return "'+\n(" + unescape(code) + ")+\n'";
      })
      .replace(settings.evaluate || noMatch, function(match, code) {
        return "';\n" + unescape(code) + "\n;__p+='";
      }) + "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __p='';" +
      "var print=function(){__p+=Array.prototype.join.call(arguments, '')};\n" +
      source + "return __p;\n";

    var render = new Function(settings.variable || 'obj', '_', source);
    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for build time
    // precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' +
      source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // The OOP Wrapper
  // ---------------

  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.
  var wrapper = function(obj) { this._wrapped = obj; };

  // Expose `wrapper.prototype` as `_.prototype`
  _.prototype = wrapper.prototype;

  // Helper function to continue chaining intermediate results.
  var result = function(obj, chain) {
    return chain ? _(obj).chain() : obj;
  };

  // A method to easily add functions to the OOP wrapper.
  var addToWrapper = function(name, func) {
    wrapper.prototype[name] = function() {
      var args = slice.call(arguments);
      unshift.call(args, this._wrapped);
      return result(func.apply(_, args), this._chain);
    };
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      var wrapped = this._wrapped;
      method.apply(wrapped, arguments);
      var length = wrapped.length;
      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];
      return result(wrapped, this._chain);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      return result(method.apply(this._wrapped, arguments), this._chain);
    };
  });

  // Start chaining a wrapped Underscore object.
  wrapper.prototype.chain = function() {
    this._chain = true;
    return this;
  };

  // Extracts the result from a wrapped and chained object.
  wrapper.prototype.value = function() {
    return this._wrapped;
  };

}).call(this);

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/unicoderegexp/lib/unicodeRegExp.js":[function(require,module,exports){
(function (root, factory) {
    // expose unicodeRegExp as
    // - an AMD module (require)
    // - a node module

    if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
        define(factory);
    } else {
        root.unicodeRegExp = factory();
    }
}(this, function (xregexp) {
    var unicodeRegExp = {};

    // These are taken from the XRegExp library (see ../extractRegExpsFromXRegExp.js):
    unicodeRegExp.letter = /[A-Za-z-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]/;
    unicodeRegExp.mark = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u08FE\u0900-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C01-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C82\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D02\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1DC0-\u1DE6\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE26]/;
    unicodeRegExp.number = /[0-9----------------------------------------------------------]/;
    unicodeRegExp.punctuation = /[\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
    unicodeRegExp.symbol = /[\u0024+<->\u005E`\u007C~--------------------------------------------------------------------]/;
    unicodeRegExp.separator = /[\u0020\u00A0\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
    unicodeRegExp.other = /[\u0000-\u001F\u007F-\u009F\u00AD\u0378\u0379\u037F-\u0383\u038B\u038D\u03A2\u0528-\u0530\u0557\u0558\u0560\u0588\u058B-\u058E\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u0605\u061C\u061D\u06DD\u070E\u070F\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08A1\u08AD-\u08E3\u08FF\u0978\u0980\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0C00\u0C04\u0C0D\u0C11\u0C29\u0C34\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5A-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C80\u0C81\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D01\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D4F-\u0D56\u0D58-\u0D5F\u0D64\u0D65\u0D76-\u0D78\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F5-\u13FF\u169D-\u169F\u16F1-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191D-\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C80-\u1CBF\u1CC8-\u1CCF\u1CF7-\u1CFF\u1DE7-\u1DFB\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u200B-\u200F\u202A-\u202E\u2060-\u206F\u2072\u2073\u208F\u209D-\u209F\u20BA-\u20CF\u20F1-\u20FF\u218A-\u218F\u23F4-\u23FF\u2427-\u243F\u244B-\u245F\u2700\u2B4D-\u2B4F\u2B5A-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E3C-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FCD-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA698-\uA69E\uA6F8-\uA6FF\uA78F\uA794-\uA79F\uA7AB-\uA7F7\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C5-\uA8CD\uA8DA-\uA8DF\uA8FC-\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9E0-\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAA7C-\uAA7F\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F-\uABBF\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE27-\uFE2F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD-\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFFB\uFFFE\uFFFF]/; // Other (control, format, private use, surrogate, and unassigned codes)

    var unicodePackageNamesMapping = {
        L: unicodeRegExp.letter,
        M: unicodeRegExp.mark,
        N: unicodeRegExp.number,
        P: unicodeRegExp.punctuation,
        S: unicodeRegExp.symbol,
        Z: unicodeRegExp.separator,
        C: unicodeRegExp.other,
        letter: unicodeRegExp.letter,
        mark: unicodeRegExp.mark,
        number: unicodeRegExp.number,
        digit: unicodeRegExp.number,
        punctuation: unicodeRegExp.punctuation,
        symbol: unicodeRegExp.symbol,
        separator: unicodeRegExp.separator,
        other: unicodeRegExp.other
    };

    unicodeRegExp.unicodePackageNameRegExp = new RegExp('^\\[\\:(\\^)?(' + Object.keys(unicodePackageNamesMapping).join('|') + ')\\:\\]$');

    unicodeRegExp.expandCldrUnicodeSetIdToCharacterClass = function (unicodeSetId) {
        return new RegExp(unicodeSetId.replace(unicodeRegExp.unicodePackageNameRegExp, function ($0, negated, packageName) {
            var characters = unicodePackageNamesMapping[packageName].source.replace(/^\[|\]$/g, '');
            return '[' + (negated ? '^' + characters : characters) + ']';
        }));
    };

    unicodeRegExp.spliceCharacterClassRegExps = function () { // ...
        var args = Array.prototype.slice.call(arguments);

        return new RegExp('[' + args.map(function (regExp) {
            return regExp.source.replace(/^\[|\]$/g, '');
        }).join("") + ']');
    };

    // All of the above combined, except 'separator', and 'other':
    unicodeRegExp.visible = unicodeRegExp.spliceCharacterClassRegExps(
        unicodeRegExp.letter,
        unicodeRegExp.mark,
        unicodeRegExp.number,
        unicodeRegExp.punctuation,
        unicodeRegExp.symbol
    );

    // The set of printable characters also includes space:
    unicodeRegExp.printable = unicodeRegExp.spliceCharacterClassRegExps(
        unicodeRegExp.visible,
        unicodeRegExp.separator
    );

    // Helper function for removing a char from a character class regular expression:

    function parseCharCode(u4, x2, literal) {
        if (u4 || x2) {
            return parseInt(u4 || x2, 16);
        } else {
            return literal.charCodeAt(0);
        }
    }

    function charCodeToRegExpToken(charCode) {
        if (charCode >= 0x20 && charCode < 0x7f) {
            return String.fromCharCode(charCode);
        } else {
            var hexStr = charCode.toString(16);
            return "\\u" + "0000".slice(hexStr.length) + hexStr;
        }
    }

    var characterClassToken = /(?:\\u([0-9a-f]{4})|\\x([0-9a-f]{2})|([^\-]))(?:-(?:\\u([0-9a-f]{4})|\\x([0-9a-f]{2})|([^\-])))?/gi;

    unicodeRegExp.removeCharacterFromCharacterClassRegExp = function (regExp, ch) {
        var charCode = ch.charCodeAt(0);

        return new RegExp('[' + regExp.source.replace(/^\[|\]$/g, '').replace(characterClassToken, function ($0, fromU4, fromX2, fromLiteral, toU4, toX2, toLiteral) {
            var fromCharCode = parseCharCode(fromU4, fromX2, fromLiteral);
            if (toU4 || toX2 || toLiteral) {
                var toCharCode = parseCharCode(toU4, toX2, toLiteral);
                if (charCode === fromCharCode) {
                    if (charCode + 1 < toCharCode) {
                        return charCodeToRegExpToken(charCode + 1) + '-' + charCodeToRegExpToken(toCharCode);
                    } else {
                        return charCodeToRegExpToken(toCharCode);
                    }
                } else if (charCode === toCharCode) {
                    if (fromCharCode < charCode - 1) {
                        return charCodeToRegExpToken(fromCharCode) + '-' + charCodeToRegExpToken(charCode - 1);
                    } else {
                        // fromCharCode === toCharCode - 1, rewrite to single char
                        return charCodeToRegExpToken(fromCharCode);
                    }
                } else if (charCode > fromCharCode && charCode < toCharCode) {
                    return charCodeToRegExpToken(fromCharCode) + (charCode > fromCharCode + 1 ? '-' + charCodeToRegExpToken(charCode - 1) : '') +
                        (charCode + 1 < toCharCode ? charCodeToRegExpToken(charCode + 1) + '-' : '') + charCodeToRegExpToken(toCharCode);
                } else {
                    return $0;
                }
            } else {
                if (charCode === fromCharCode) {
                    return "";
                } else {
                    return charCodeToRegExpToken(fromCharCode);
                }
            }
        }) + ']');
    };

    return unicodeRegExp;
}));

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xmldom/dom-parser.js":[function(require,module,exports){
function DOMParser(options){
	this.options = options ||{locator:{}};
	
}
DOMParser.prototype.parseFromString = function(source,mimeType){	
	var options = this.options;
	var sax =  new XMLReader();
	var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
	var errorHandler = options.errorHandler;
	var locator = options.locator;
	var defaultNSMap = options.xmlns||{};
	var entityMap = {'lt':'<','gt':'>','amp':'&','quot':'"','apos':"'"}
	if(locator){
		domBuilder.setDocumentLocator(locator)
	}
	
	sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);
	sax.domBuilder = options.domBuilder || domBuilder;
	if(/\/x?html?$/.test(mimeType)){
		entityMap.nbsp = '\xa0';
		entityMap.copy = '\xa9';
		defaultNSMap['']= 'http://www.w3.org/1999/xhtml';
	}
	if(source){
		sax.parse(source,defaultNSMap,entityMap);
	}else{
		sax.errorHandler.error("invalid document source");
	}
	return domBuilder.document;
}
function buildErrorHandler(errorImpl,domBuilder,locator){
	if(!errorImpl){
		if(domBuilder instanceof DOMHandler){
			return domBuilder;
		}
		errorImpl = domBuilder ;
	}
	var errorHandler = {}
	var isCallback = errorImpl instanceof Function;
	locator = locator||{}
	function build(key){
		var fn = errorImpl[key];
		if(!fn){
			if(isCallback){
				fn = errorImpl.length == 2?function(msg){errorImpl(key,msg)}:errorImpl;
			}else{
				var i=arguments.length;
				while(--i){
					if(fn = errorImpl[arguments[i]]){
						break;
					}
				}
			}
		}
		errorHandler[key] = fn && function(msg){
			fn(msg+_locator(locator));
		}||function(){};
	}
	build('warning','warn');
	build('error','warn','warning');
	build('fatalError','warn','warning','error');
	return errorHandler;
}
/**
 * +ContentHandler+ErrorHandler
 * +LexicalHandler+EntityResolver2
 * -DeclHandler-DTDHandler 
 * 
 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
 */
function DOMHandler() {
    this.cdata = false;
}
function position(locator,node){
	node.lineNumber = locator.lineNumber;
	node.columnNumber = locator.columnNumber;
}
/**
 * @see org.xml.sax.ContentHandler#startDocument
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
 */ 
DOMHandler.prototype = {
	startDocument : function() {
    	this.document = new DOMImplementation().createDocument(null, null, null);
    	if (this.locator) {
        	this.document.documentURI = this.locator.systemId;
    	}
	},
	startElement:function(namespaceURI, localName, qName, attrs) {
		var doc = this.document;
	    var el = doc.createElementNS(namespaceURI, qName||localName);
	    var len = attrs.length;
	    appendElement(this, el);
	    this.currentElement = el;
	    
		this.locator && position(this.locator,el)
	    for (var i = 0 ; i < len; i++) {
	        var namespaceURI = attrs.getURI(i);
	        var value = attrs.getValue(i);
	        var qName = attrs.getQName(i);
			var attr = doc.createAttributeNS(namespaceURI, qName);
			if( attr.getOffset){
				position(attr.getOffset(1),attr)
			}
			attr.value = attr.nodeValue = value;
			el.setAttributeNode(attr)
	    }
	},
	endElement:function(namespaceURI, localName, qName) {
		var current = this.currentElement
	    var tagName = current.tagName;
	    this.currentElement = current.parentNode;
	},
	startPrefixMapping:function(prefix, uri) {
	},
	endPrefixMapping:function(prefix) {
	},
	processingInstruction:function(target, data) {
	    var ins = this.document.createProcessingInstruction(target, data);
	    this.locator && position(this.locator,ins)
	    appendElement(this, ins);
	},
	ignorableWhitespace:function(ch, start, length) {
	},
	characters:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
		//console.log(chars)
		if(this.currentElement && chars){
			if (this.cdata) {
				var charNode = this.document.createCDATASection(chars);
				this.currentElement.appendChild(charNode);
			} else {
				var charNode = this.document.createTextNode(chars);
				this.currentElement.appendChild(charNode);
			}
			this.locator && position(this.locator,charNode)
		}
	},
	skippedEntity:function(name) {
	},
	endDocument:function() {
		this.document.normalize();
	},
	setDocumentLocator:function (locator) {
	    if(this.locator = locator){// && !('lineNumber' in locator)){
	    	locator.lineNumber = 0;
	    }
	},
	//LexicalHandler
	comment:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
	    var comm = this.document.createComment(chars);
	    this.locator && position(this.locator,comm)
	    appendElement(this, comm);
	},
	
	startCDATA:function() {
	    //used in characters() methods
	    this.cdata = true;
	},
	endCDATA:function() {
	    this.cdata = false;
	},
	
	startDTD:function(name, publicId, systemId) {
		var impl = this.document.implementation;
	    if (impl && impl.createDocumentType) {
	        var dt = impl.createDocumentType(name, publicId, systemId);
	        this.locator && position(this.locator,dt)
	        appendElement(this, dt);
	    }
	},
	/**
	 * @see org.xml.sax.ErrorHandler
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
	 */
	warning:function(error) {
		console.warn(error,_locator(this.locator));
	},
	error:function(error) {
		console.error(error,_locator(this.locator));
	},
	fatalError:function(error) {
		console.error(error,_locator(this.locator));
	    throw error;
	}
}
function _locator(l){
	if(l){
		return '\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'
	}
}
function _toString(chars,start,length){
	if(typeof chars == 'string'){
		return chars.substr(start,length)
	}else{//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
		if(chars.length >= start+length || start){
			return new java.lang.String(chars,start,length)+'';
		}
		return chars;
	}
}

/*
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
 * used method of org.xml.sax.ext.LexicalHandler:
 *  #comment(chars, start, length)
 *  #startCDATA()
 *  #endCDATA()
 *  #startDTD(name, publicId, systemId)
 *
 *
 * IGNORED method of org.xml.sax.ext.LexicalHandler:
 *  #endDTD()
 *  #startEntity(name)
 *  #endEntity(name)
 *
 *
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
 * IGNORED method of org.xml.sax.ext.DeclHandler
 * 	#attributeDecl(eName, aName, type, mode, value)
 *  #elementDecl(name, model)
 *  #externalEntityDecl(name, publicId, systemId)
 *  #internalEntityDecl(name, value)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
 * IGNORED method of org.xml.sax.EntityResolver2
 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
 *  #resolveEntity(publicId, systemId)
 *  #getExternalSubset(name, baseURI)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
 * IGNORED method of org.xml.sax.DTDHandler
 *  #notationDecl(name, publicId, systemId) {};
 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
 */
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){
	DOMHandler.prototype[key] = function(){return null}
})

/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
function appendElement (hander,node) {
    if (!hander.currentElement) {
        hander.document.appendChild(node);
    } else {
        hander.currentElement.appendChild(node);
    }
}//appendChild and setAttributeNS are preformance key

if(typeof require == 'function'){
	var XMLReader = require('./sax').XMLReader;
	var DOMImplementation = exports.DOMImplementation = require('./dom').DOMImplementation;
	exports.XMLSerializer = require('./dom').XMLSerializer ;
	exports.DOMParser = DOMParser;
}

},{"./dom":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xmldom/dom.js","./sax":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xmldom/sax.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xmldom/dom.js":[function(require,module,exports){
/*
 * DOM Level 2
 * Object DOMException
 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
 */

function copy(src,dest){
	for(var p in src){
		dest[p] = src[p];
	}
}
/**
^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
 */
function _extends(Class,Super){
	var pt = Class.prototype;
	if(Object.create){
		var ppt = Object.create(Super.prototype)
		pt.__proto__ = ppt;
	}
	if(!(pt instanceof Super)){
		function t(){};
		t.prototype = Super.prototype;
		t = new t();
		copy(pt,t);
		Class.prototype = pt = t;
	}
	if(pt.constructor != Class){
		if(typeof Class != 'function'){
			console.error("unknow Class:"+Class)
		}
		pt.constructor = Class
	}
}
var htmlns = 'http://www.w3.org/1999/xhtml' ;
// Node Types
var NodeType = {}
var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

// ExceptionCode
var ExceptionCode = {}
var ExceptionMessage = {};
var INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
var DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
var WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
var INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
var NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
var NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
//level2
var INVALID_STATE_ERR        	= ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
var SYNTAX_ERR               	= ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
var INVALID_MODIFICATION_ERR 	= ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
var NAMESPACE_ERR            	= ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
var INVALID_ACCESS_ERR       	= ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);


function DOMException(code, message) {
	if(message instanceof Error){
		var error = message;
	}else{
		error = this;
		Error.call(this, ExceptionMessage[code]);
		this.message = ExceptionMessage[code];
		if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
	}
	error.code = code;
	if(message) this.message = this.message + ": " + message;
	return error;
};
DOMException.prototype = Error.prototype;
copy(ExceptionCode,DOMException)
/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
 * The items in the NodeList are accessible via an integral index, starting from 0.
 */
function NodeList() {
};
NodeList.prototype = {
	/**
	 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
	 * @standard level1
	 */
	length:0, 
	/**
	 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
	 * @standard level1
	 * @param index  unsigned long 
	 *   Index into the collection.
	 * @return Node
	 * 	The node at the indexth position in the NodeList, or null if that is not a valid index. 
	 */
	item: function(index) {
		return this[index] || null;
	}
};
function LiveNodeList(node,refresh){
	this._node = node;
	this._refresh = refresh
	_updateLiveList(this);
}
function _updateLiveList(list){
	var inc = list._node._inc || list._node.ownerDocument._inc;
	if(list._inc != inc){
		var ls = list._refresh(list._node);
		//console.log(ls.length)
		__set__(list,'length',ls.length);
		copy(ls,list);
		list._inc = inc;
	}
}
LiveNodeList.prototype.item = function(i){
	_updateLiveList(this);
	return this[i];
}

_extends(LiveNodeList,NodeList);
/**
 * 
 * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.
 * NamedNodeMap objects in the DOM are live.
 * used for attributes or DocumentType entities 
 */
function NamedNodeMap() {
};

function _findNodeIndex(list,node){
	var i = list.length;
	while(i--){
		if(list[i] === node){return i}
	}
}

function _addNamedNode(el,list,newAttr,oldAttr){
	if(oldAttr){
		list[_findNodeIndex(list,oldAttr)] = newAttr;
	}else{
		list[list.length++] = newAttr;
	}
	if(el){
		newAttr.ownerElement = el;
		var doc = el.ownerDocument;
		if(doc){
			oldAttr && _onRemoveAttribute(doc,el,oldAttr);
			_onAddAttribute(doc,el,newAttr);
		}
	}
}
function _removeNamedNode(el,list,attr){
	var i = _findNodeIndex(list,attr);
	if(i>=0){
		var lastIndex = list.length-1
		while(i<lastIndex){
			list[i] = list[++i]
		}
		list.length = lastIndex;
		if(el){
			var doc = el.ownerDocument;
			if(doc){
				_onRemoveAttribute(doc,el,attr);
				attr.ownerElement = null;
			}
		}
	}else{
		throw DOMException(NOT_FOUND_ERR,new Error())
	}
}
NamedNodeMap.prototype = {
	length:0,
	item:NodeList.prototype.item,
	getNamedItem: function(key) {
//		if(key.indexOf(':')>0 || key == 'xmlns'){
//			return null;
//		}
		var i = this.length;
		while(i--){
			var attr = this[i];
			if(attr.nodeName == key){
				return attr;
			}
		}
	},
	setNamedItem: function(attr) {
		var el = attr.ownerElement;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		var oldAttr = this.getNamedItem(attr.nodeName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},
	/* returns Node */
	setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
		var el = attr.ownerElement, oldAttr;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},

	/* returns Node */
	removeNamedItem: function(key) {
		var attr = this.getNamedItem(key);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
		
		
	},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
	
	//for level2
	removeNamedItemNS:function(namespaceURI,localName){
		var attr = this.getNamedItemNS(namespaceURI,localName);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
	},
	getNamedItemNS: function(namespaceURI, localName) {
		var i = this.length;
		while(i--){
			var node = this[i];
			if(node.localName == localName && node.namespaceURI == namespaceURI){
				return node;
			}
		}
		return null;
	}
};
/**
 * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490
 */
function DOMImplementation(/* Object */ features) {
	this._features = {};
	if (features) {
		for (var feature in features) {
			 this._features = features[feature];
		}
	}
};

DOMImplementation.prototype = {
	hasFeature: function(/* string */ feature, /* string */ version) {
		var versions = this._features[feature.toLowerCase()];
		if (versions && (!version || version in versions)) {
			return true;
		} else {
			return false;
		}
	},
	// Introduced in DOM Level 2:
	createDocument:function(namespaceURI,  qualifiedName, doctype){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR
		var doc = new Document();
		doc.doctype = doctype;
		if(doctype){
			doc.appendChild(doctype);
		}
		doc.implementation = this;
		doc.childNodes = new NodeList();
		if(qualifiedName){
			var root = doc.createElementNS(namespaceURI,qualifiedName);
			doc.appendChild(root);
		}
		return doc;
	},
	// Introduced in DOM Level 2:
	createDocumentType:function(qualifiedName, publicId, systemId){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR
		var node = new DocumentType();
		node.name = qualifiedName;
		node.nodeName = qualifiedName;
		node.publicId = publicId;
		node.systemId = systemId;
		// Introduced in DOM Level 2:
		//readonly attribute DOMString        internalSubset;
		
		//TODO:..
		//  readonly attribute NamedNodeMap     entities;
		//  readonly attribute NamedNodeMap     notations;
		return node;
	}
};


/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
 */

function Node() {
};

Node.prototype = {
	firstChild : null,
	lastChild : null,
	previousSibling : null,
	nextSibling : null,
	attributes : null,
	parentNode : null,
	childNodes : null,
	ownerDocument : null,
	nodeValue : null,
	namespaceURI : null,
	prefix : null,
	localName : null,
	// Modified in DOM Level 2:
	insertBefore:function(newChild, refChild){//raises 
		return _insertBefore(this,newChild,refChild);
	},
	replaceChild:function(newChild, oldChild){//raises 
		this.insertBefore(newChild,oldChild);
		if(oldChild){
			this.removeChild(oldChild);
		}
	},
	removeChild:function(oldChild){
		return _removeChild(this,oldChild);
	},
	appendChild:function(newChild){
		return this.insertBefore(newChild,null);
	},
	hasChildNodes:function(){
		return this.firstChild != null;
	},
	cloneNode:function(deep){
		return cloneNode(this.ownerDocument||this,this,deep);
	},
	// Modified in DOM Level 2:
	normalize:function(){
		var child = this.firstChild;
		while(child){
			var next = child.nextSibling;
			if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
				this.removeChild(next);
				child.appendData(next.data);
			}else{
				child.normalize();
				child = next;
			}
		}
	},
  	// Introduced in DOM Level 2:
	isSupported:function(feature, version){
		return this.ownerDocument.implementation.hasFeature(feature,version);
	},
    // Introduced in DOM Level 2:
    hasAttributes:function(){
    	return this.attributes.length>0;
    },
    lookupPrefix:function(namespaceURI){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			for(var n in map){
    				if(map[n] == namespaceURI){
    					return n;
    				}
    			}
    		}
    		el = el.nodeType == 2?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI:function(prefix){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			if(prefix in map){
    				return map[prefix] ;
    			}
    		}
    		el = el.nodeType == 2?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace:function(namespaceURI){
    	var prefix = this.lookupPrefix(namespaceURI);
    	return prefix == null;
    }
};


function _xmlEncoder(c){
	return c == '<' && '&lt;' ||
         c == '>' && '&gt;' ||
         c == '&' && '&amp;' ||
         c == '"' && '&quot;' ||
         '&#'+c.charCodeAt()+';'
}


copy(NodeType,Node);
copy(NodeType,Node.prototype);

/**
 * @param callback return true for continue,false for break
 * @return boolean true: break visit;
 */
function _visitNode(node,callback){
	if(callback(node)){
		return true;
	}
	if(node = node.firstChild){
		do{
			if(_visitNode(node,callback)){return true}
        }while(node=node.nextSibling)
    }
}



function Document(){
}
function _onAddAttribute(doc,el,newAttr){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value
	}
}
function _onRemoveAttribute(doc,el,newAttr,remove){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		delete el._nsMap[newAttr.prefix?newAttr.localName:'']
	}
}
function _onUpdateChild(doc,el,newChild){
	if(doc && doc._inc){
		doc._inc++;
		//update childNodes
		var cs = el.childNodes;
		if(newChild){
			cs[cs.length++] = newChild;
		}else{
			//console.log(1)
			var child = el.firstChild;
			var i = 0;
			while(child){
				cs[i++] = child;
				child =child.nextSibling;
			}
			cs.length = i;
		}
	}
}

/**
 * attributes;
 * children;
 * 
 * writeable properties:
 * nodeValue,Attr:value,CharacterData:data
 * prefix
 */
function _removeChild(parentNode,child){
	var previous = child.previousSibling;
	var next = child.nextSibling;
	if(previous){
		previous.nextSibling = next;
	}else{
		parentNode.firstChild = next
	}
	if(next){
		next.previousSibling = previous;
	}else{
		parentNode.lastChild = previous;
	}
	_onUpdateChild(parentNode.ownerDocument,parentNode);
	return child;
}
/**
 * preformance key(refChild == null)
 */
function _insertBefore(parentNode,newChild,nextChild){
	var cp = newChild.parentNode;
	if(cp){
		cp.removeChild(newChild);//remove and update
	}
	if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
		var newFirst = newChild.firstChild;
		if (newFirst == null) {
			return newChild;
		}
		var newLast = newChild.lastChild;
	}else{
		newFirst = newLast = newChild;
	}
	var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;

	newFirst.previousSibling = pre;
	newLast.nextSibling = nextChild;
	
	
	if(pre){
		pre.nextSibling = newFirst;
	}else{
		parentNode.firstChild = newFirst;
	}
	if(nextChild == null){
		parentNode.lastChild = newLast;
	}else{
		nextChild.previousSibling = newLast;
	}
	do{
		newFirst.parentNode = parentNode;
	}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
	_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);
	//console.log(parentNode.lastChild.nextSibling == null)
	if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
		newChild.firstChild = newChild.lastChild = null;
	}
	return newChild;
}
function _appendSingleChild(parentNode,newChild){
	var cp = newChild.parentNode;
	if(cp){
		var pre = parentNode.lastChild;
		cp.removeChild(newChild);//remove and update
		var pre = parentNode.lastChild;
	}
	var pre = parentNode.lastChild;
	newChild.parentNode = parentNode;
	newChild.previousSibling = pre;
	newChild.nextSibling = null;
	if(pre){
		pre.nextSibling = newChild;
	}else{
		parentNode.firstChild = newChild;
	}
	parentNode.lastChild = newChild;
	_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);
	return newChild;
	//console.log("__aa",parentNode.lastChild.nextSibling == null)
}
Document.prototype = {
	//implementation : null,
	nodeName :  '#document',
	nodeType :  DOCUMENT_NODE,
	doctype :  null,
	documentElement :  null,
	_inc : 1,
	
	insertBefore :  function(newChild, refChild){//raises 
		if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
			var child = newChild.firstChild;
			while(child){
				var next = child.nextSibling;
				this.insertBefore(child,refChild);
				child = next;
			}
			return newChild;
		}
		if(this.documentElement == null && newChild.nodeType == 1){
			this.documentElement = newChild;
		}
		
		return _insertBefore(this,newChild,refChild),(newChild.ownerDocument = this),newChild;
	},
	removeChild :  function(oldChild){
		if(this.documentElement == oldChild){
			this.documentElement = null;
		}
		return _removeChild(this,oldChild);
	},
	// Introduced in DOM Level 2:
	importNode : function(importedNode,deep){
		return importNode(this,importedNode,deep);
	},
	// Introduced in DOM Level 2:
	getElementById :	function(id){
		var rtv = null;
		_visitNode(this.documentElement,function(node){
			if(node.nodeType == 1){
				if(node.getAttribute('id') == id){
					rtv = node;
					return true;
				}
			}
		})
		return rtv;
	},
	
	//document factory method:
	createElement :	function(tagName){
		var node = new Element();
		node.ownerDocument = this;
		node.nodeName = tagName;
		node.tagName = tagName;
		node.childNodes = new NodeList();
		var attrs	= node.attributes = new NamedNodeMap();
		attrs._ownerElement = node;
		return node;
	},
	createDocumentFragment :	function(){
		var node = new DocumentFragment();
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		return node;
	},
	createTextNode :	function(data){
		var node = new Text();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createComment :	function(data){
		var node = new Comment();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createCDATASection :	function(data){
		var node = new CDATASection();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createProcessingInstruction :	function(target,data){
		var node = new ProcessingInstruction();
		node.ownerDocument = this;
		node.tagName = node.target = target;
		node.nodeValue= node.data = data;
		return node;
	},
	createAttribute :	function(name){
		var node = new Attr();
		node.ownerDocument	= this;
		node.name = name;
		node.nodeName	= name;
		node.localName = name;
		node.specified = true;
		return node;
	},
	createEntityReference :	function(name){
		var node = new EntityReference();
		node.ownerDocument	= this;
		node.nodeName	= name;
		return node;
	},
	// Introduced in DOM Level 2:
	createElementNS :	function(namespaceURI,qualifiedName){
		var node = new Element();
		var pl = qualifiedName.split(':');
		var attrs	= node.attributes = new NamedNodeMap();
		node.childNodes = new NodeList();
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.tagName = qualifiedName;
		node.namespaceURI = namespaceURI;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		attrs._ownerElement = node;
		return node;
	},
	// Introduced in DOM Level 2:
	createAttributeNS :	function(namespaceURI,qualifiedName){
		var node = new Attr();
		var pl = qualifiedName.split(':');
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.name = qualifiedName;
		node.namespaceURI = namespaceURI;
		node.specified = true;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		return node;
	}
};
_extends(Document,Node);


function Element() {
	this._nsMap = {};
};
Element.prototype = {
	nodeType : ELEMENT_NODE,
	hasAttribute : function(name){
		return this.getAttributeNode(name)!=null;
	},
	getAttribute : function(name){
		var attr = this.getAttributeNode(name);
		return attr && attr.value || '';
	},
	getAttributeNode : function(name){
		return this.attributes.getNamedItem(name);
	},
	setAttribute : function(name, value){
		var attr = this.ownerDocument.createAttribute(name);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	removeAttribute : function(name){
		var attr = this.getAttributeNode(name)
		attr && this.removeAttributeNode(attr);
	},
	
	//four real opeartion method
	appendChild:function(newChild){
		if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
			return this.insertBefore(newChild,null);
		}else{
			return _appendSingleChild(this,newChild);
		}
	},
	setAttributeNode : function(newAttr){
		return this.attributes.setNamedItem(newAttr);
	},
	setAttributeNodeNS : function(newAttr){
		return this.attributes.setNamedItemNS(newAttr);
	},
	removeAttributeNode : function(oldAttr){
		return this.attributes.removeNamedItem(oldAttr.nodeName);
	},
	//get real attribute name,and remove it by removeAttributeNode
	removeAttributeNS : function(namespaceURI, localName){
		var old = this.getAttributeNodeNS(namespaceURI, localName);
		old && this.removeAttributeNode(old);
	},
	
	hasAttributeNS : function(namespaceURI, localName){
		return this.getAttributeNodeNS(namespaceURI, localName)!=null;
	},
	getAttributeNS : function(namespaceURI, localName){
		var attr = this.getAttributeNodeNS(namespaceURI, localName);
		return attr && attr.value || '';
	},
	setAttributeNS : function(namespaceURI, qualifiedName, value){
		var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
		attr.value = attr.nodeValue = value;
		this.setAttributeNode(attr)
	},
	getAttributeNodeNS : function(namespaceURI, localName){
		return this.attributes.getNamedItemNS(namespaceURI, localName);
	},
	
	getElementsByTagName : function(tagName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
					ls.push(node);
				}
			});
			return ls;
		});
	},
	getElementsByTagNameNS : function(namespaceURI, localName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType === ELEMENT_NODE && node.namespaceURI === namespaceURI && (localName === '*' || node.localName == localName)){
					ls.push(node);
				}
			});
			return ls;
		});
	}
};
Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


_extends(Element,Node);
function Attr() {
};
Attr.prototype.nodeType = ATTRIBUTE_NODE;
_extends(Attr,Node);


function CharacterData() {
};
CharacterData.prototype = {
	data : '',
	substringData : function(offset, count) {
		return this.data.substring(offset, offset+count);
	},
	appendData: function(text) {
		text = this.data+text;
		this.nodeValue = this.data = text;
		this.length = text.length;
	},
	insertData: function(offset,text) {
		this.replaceData(offset,0,text);
	
	},
	appendChild:function(newChild){
		//if(!(newChild instanceof CharacterData)){
			throw new Error(ExceptionMessage[3])
		//}
		return Node.prototype.appendChild.apply(this,arguments)
	},
	deleteData: function(offset, count) {
		this.replaceData(offset,count,"");
	},
	replaceData: function(offset, count, text) {
		var start = this.data.substring(0,offset);
		var end = this.data.substring(offset+count);
		text = start + text + end;
		this.nodeValue = this.data = text;
		this.length = text.length;
	}
}
_extends(CharacterData,Node);
function Text() {
};
Text.prototype = {
	nodeName : "#text",
	nodeType : TEXT_NODE,
	splitText : function(offset) {
		var text = this.data;
		var newText = text.substring(offset);
		text = text.substring(0, offset);
		this.data = this.nodeValue = text;
		this.length = text.length;
		var newNode = this.ownerDocument.createTextNode(newText);
		if(this.parentNode){
			this.parentNode.insertBefore(newNode, this.nextSibling);
		}
		return newNode;
	}
}
_extends(Text,CharacterData);
function Comment() {
};
Comment.prototype = {
	nodeName : "#comment",
	nodeType : COMMENT_NODE
}
_extends(Comment,CharacterData);

function CDATASection() {
};
CDATASection.prototype = {
	nodeName : "#cdata-section",
	nodeType : CDATA_SECTION_NODE
}
_extends(CDATASection,CharacterData);


function DocumentType() {
};
DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
_extends(DocumentType,Node);

function Notation() {
};
Notation.prototype.nodeType = NOTATION_NODE;
_extends(Notation,Node);

function Entity() {
};
Entity.prototype.nodeType = ENTITY_NODE;
_extends(Entity,Node);

function EntityReference() {
};
EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
_extends(EntityReference,Node);

function DocumentFragment() {
};
DocumentFragment.prototype.nodeName =	"#document-fragment";
DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
_extends(DocumentFragment,Node);


function ProcessingInstruction() {
}
ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
_extends(ProcessingInstruction,Node);
function XMLSerializer(){}
XMLSerializer.prototype.serializeToString = function(node){
	var buf = [];
	serializeToString(node,buf);
	return buf.join('');
}
Node.prototype.toString =function(){
	return XMLSerializer.prototype.serializeToString(this);
}
function serializeToString(node,buf){
	switch(node.nodeType){
	case ELEMENT_NODE:
		var attrs = node.attributes;
		var len = attrs.length;
		var child = node.firstChild;
		var nodeName = node.tagName;
		var isHTML = htmlns === node.namespaceURI
		buf.push('<',nodeName);
		for(var i=0;i<len;i++){
			serializeToString(attrs.item(i),buf,isHTML);
		}
		if(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){
			buf.push('>');
			//if is cdata child node
			if(isHTML && /^script$/i.test(nodeName)){
				if(child){
					buf.push(child.data);
				}
			}else{
				while(child){
					serializeToString(child,buf);
					child = child.nextSibling;
				}
			}
			buf.push('</',nodeName,'>');
		}else{
			buf.push('/>');
		}
		return;
	case DOCUMENT_NODE:
	case DOCUMENT_FRAGMENT_NODE:
		var child = node.firstChild;
		while(child){
			serializeToString(child,buf);
			child = child.nextSibling;
		}
		return;
	case ATTRIBUTE_NODE:
		return buf.push(' ',node.name,'="',node.value.replace(/[<&"]/g,_xmlEncoder),'"');
	case TEXT_NODE:
		return buf.push(node.data.replace(/[<&]/g,_xmlEncoder));
	case CDATA_SECTION_NODE:
		return buf.push( '<![CDATA[',node.data,']]>');
	case COMMENT_NODE:
		return buf.push( "<!--",node.data,"-->");
	case DOCUMENT_TYPE_NODE:
		var pubid = node.publicId;
		var sysid = node.systemId;
		buf.push('<!DOCTYPE ',node.name);
		if(pubid){
			buf.push(' PUBLIC "',pubid);
			if (sysid && sysid!='.') {
				buf.push( '" "',sysid);
			}
			buf.push('">');
		}else if(sysid && sysid!='.'){
			buf.push(' SYSTEM "',sysid,'">');
		}else{
			var sub = node.internalSubset;
			if(sub){
				buf.push(" [",sub,"]");
			}
			buf.push(">");
		}
		return;
	case PROCESSING_INSTRUCTION_NODE:
		return buf.push( "<?",node.target," ",node.data,"?>");
	case ENTITY_REFERENCE_NODE:
		return buf.push( '&',node.nodeName,';');
	//case ENTITY_NODE:
	//case NOTATION_NODE:
	default:
		buf.push('??',node.nodeName);
	}
}
function importNode(doc,node,deep){
	var node2;
	switch (node.nodeType) {
	case ELEMENT_NODE:
		node2 = node.cloneNode(false);
		node2.ownerDocument = doc;
		//var attrs = node2.attributes;
		//var len = attrs.length;
		//for(var i=0;i<len;i++){
			//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
		//}
	case DOCUMENT_FRAGMENT_NODE:
		break;
	case ATTRIBUTE_NODE:
		deep = true;
		break;
	//case ENTITY_REFERENCE_NODE:
	//case PROCESSING_INSTRUCTION_NODE:
	////case TEXT_NODE:
	//case CDATA_SECTION_NODE:
	//case COMMENT_NODE:
	//	deep = false;
	//	break;
	//case DOCUMENT_NODE:
	//case DOCUMENT_TYPE_NODE:
	//cannot be imported.
	//case ENTITY_NODE:
	//case NOTATION_NODE
	//can not hit in level3
	//default:throw e;
	}
	if(!node2){
		node2 = node.cloneNode(false);//false
	}
	node2.ownerDocument = doc;
	node2.parentNode = null;
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(importNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}
//
//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
function cloneNode(doc,node,deep){
	var node2 = new node.constructor();
	for(var n in node){
		var v = node[n];
		if(typeof v != 'object' ){
			if(v != node2[n]){
				node2[n] = v;
			}
		}
	}
	if(node.childNodes){
		node2.childNodes = new NodeList();
	}
	node2.ownerDocument = doc;
	switch (node2.nodeType) {
	case ELEMENT_NODE:
		var attrs	= node.attributes;
		var attrs2	= node2.attributes = new NamedNodeMap();
		var len = attrs.length
		attrs2._ownerElement = node2;
		for(var i=0;i<len;i++){
			node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
		}
		break;;
	case ATTRIBUTE_NODE:
		deep = true;
	}
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(cloneNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}

function __set__(object,key,value){
	object[key] = value
}
//do dynamic
try{
	if(Object.defineProperty){
		Object.defineProperty(LiveNodeList.prototype,'length',{
			get:function(){
				_updateLiveList(this);
				return this.$$length;
			}
		});
		Object.defineProperty(Node.prototype,'textContent',{
			get:function(){
				return getTextContent(this);
			},
			set:function(data){
				switch(this.nodeType){
				case 1:
				case 11:
					while(this.firstChild){
						this.removeChild(this.firstChild);
					}
					if(data || String(data)){
						this.appendChild(this.ownerDocument.createTextNode(data));
					}
					break;
				default:
					//TODO:
					this.data = data;
					this.value = value;
					this.nodeValue = data;
				}
			}
		})
		
		function getTextContent(node){
			switch(node.nodeType){
			case 1:
			case 11:
				var buf = [];
				node = node.firstChild;
				while(node){
					if(node.nodeType!==7 && node.nodeType !==8){
						buf.push(getTextContent(node));
					}
					node = node.nextSibling;
				}
				return buf.join('');
			default:
				return node.nodeValue;
			}
		}
		__set__ = function(object,key,value){
			//console.log(value)
			object['$$'+key] = value
		}
	}
}catch(e){//ie8
}

if(typeof require == 'function'){
	exports.DOMImplementation = DOMImplementation;
	exports.XMLSerializer = XMLSerializer;
}

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xmldom/sax.js":[function(require,module,exports){
//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
//[5]   	Name	   ::=   	NameStartChar (NameChar)*
var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]///\u10000-\uEFFFF
var nameChar = new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\u00B7\u0300-\u036F\\ux203F-\u2040]");
var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\:'+nameStartChar.source+nameChar.source+'*)?$');
//var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

//S_TAG,	S_ATTR,	S_EQ,	S_V
//S_ATTR_S,	S_E,	S_S,	S_C
var S_TAG = 0;//tag name offerring
var S_ATTR = 1;//attr name offerring 
var S_ATTR_S=2;//attr name end and space offer
var S_EQ = 3;//=space?
var S_V = 4;//attr value(no quot value only)
var S_E = 5;//attr value end and no space(quot end)
var S_S = 6;//(attr value end || tag end ) && (space offer)
var S_C = 7;//closed el<el />

function XMLReader(){
	
}

XMLReader.prototype = {
	parse:function(source,defaultNSMap,entityMap){
		var domBuilder = this.domBuilder;
		domBuilder.startDocument();
		_copy(defaultNSMap ,defaultNSMap = {})
		parse(source,defaultNSMap,entityMap,
				domBuilder,this.errorHandler);
		domBuilder.endDocument();
	}
}
function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){
  function fixedFromCharCode(code) {
		// String.prototype.fromCharCode does not supports
		// > 2 bytes unicode chars directly
		if (code > 0xffff) {
			code -= 0x10000;
			var surrogate1 = 0xd800 + (code >> 10)
				, surrogate2 = 0xdc00 + (code & 0x3ff);

			return String.fromCharCode(surrogate1, surrogate2);
		} else {
			return String.fromCharCode(code);
		}
	}
	function entityReplacer(a){
		var k = a.slice(1,-1);
		if(k in entityMap){
			return entityMap[k]; 
		}else if(k.charAt(0) === '#'){
			return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))
		}else{
			errorHandler.error('entity not found:'+a);
			return a;
		}
	}
	function appendText(end){//has some bugs
		var xt = source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);
		locator&&position(start);
		domBuilder.characters(xt,0,end-start);
		start = end
	}
	function position(start,m){
		while(start>=endPos && (m = linePattern.exec(source))){
			startPos = m.index;
			endPos = startPos + m[0].length;
			locator.lineNumber++;
			//console.log('line++:',locator,startPos,endPos)
		}
		locator.columnNumber = start-startPos+1;
	}
	var startPos = 0;
	var endPos = 0;
	var linePattern = /.+(?:\r\n?|\n)|.*$/g
	var locator = domBuilder.locator;
	
	var parseStack = [{currentNSMap:defaultNSMapCopy}]
	var closeMap = {};
	var start = 0;
	while(true){
		var i = source.indexOf('<',start);
		if(i<0){
			if(!source.substr(start).match(/^\s*$/)){
				var doc = domBuilder.document;
    			var text = doc.createTextNode(source.substr(start));
    			doc.appendChild(text);
    			domBuilder.currentElement = text;
			}
			return;
		}
		if(i>start){
			appendText(i);
		}
		switch(source.charAt(i+1)){
		case '/':
			var end = source.indexOf('>',i+3);
			var tagName = source.substring(i+2,end);
			var config = parseStack.pop();
			var localNSMap = config.localNSMap;
			
	        if(config.tagName != tagName){
	            errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName );
	        }
			domBuilder.endElement(config.uri,config.localName,tagName);
			if(localNSMap){
				for(var prefix in localNSMap){
					domBuilder.endPrefixMapping(prefix) ;
				}
			}
			end++;
			break;
			// end elment
		case '?':// <?...?>
			locator&&position(i);
			end = parseInstruction(source,i,domBuilder);
			break;
		case '!':// <!doctype,<![CDATA,<!--
			locator&&position(i);
			end = parseDCC(source,i,domBuilder,errorHandler);
			break;
		default:
			try{
				locator&&position(i);
				
				var el = new ElementAttributes();
				
				//elStartEnd
				var end = parseElementStartPart(source,i,el,entityReplacer,errorHandler);
				var len = el.length;
				//position fixed
				if(len && locator){
					var backup = copyLocator(locator,{});
					for(var i = 0;i<len;i++){
						var a = el[i];
						position(a.offset);
						a.offset = copyLocator(locator,{});
					}
					copyLocator(backup,locator);
				}
				if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){
					el.closed = true;
					if(!entityMap.nbsp){
						errorHandler.warning('unclosed xml attribute');
					}
				}
				appendElement(el,domBuilder,parseStack);
				
				
				if(el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed){
					end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)
				}else{
					end++;
				}
			}catch(e){
				errorHandler.error('element parse error: '+e);
				end = -1;
			}

		}
		if(end<0){
			//TODO: sax
			appendText(i+1);
		}else{
			start = end;
		}
	}
}
function copyLocator(f,t){
	t.lineNumber = f.lineNumber;
	t.columnNumber = f.columnNumber;
	return t;
	
}

/**
 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
 */
function parseElementStartPart(source,start,el,entityReplacer,errorHandler){
	var attrName;
	var value;
	var p = ++start;
	var s = S_TAG;//status
	while(true){
		var c = source.charAt(p);
		switch(c){
		case '=':
			if(s === S_ATTR){//attrName
				attrName = source.slice(start,p);
				s = S_EQ;
			}else if(s === S_ATTR_S){
				s = S_EQ;
			}else{
				//fatalError: equal must after attrName or space after attrName
				throw new Error('attribute equal must after attrName');
			}
			break;
		case '\'':
		case '"':
			if(s === S_EQ){//equal
				start = p+1;
				p = source.indexOf(c,start)
				if(p>0){
					value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					el.add(attrName,value,start-1);
					s = S_E;
				}else{
					//fatalError: no end quot match
					throw new Error('attribute value no end \''+c+'\' match');
				}
			}else if(s == S_V){
				value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
				//console.log(attrName,value,start,p)
				el.add(attrName,value,start);
				//console.dir(el)
				errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');
				start = p+1;
				s = S_E
			}else{
				//fatalError: no equal before
				throw new Error('attribute value must after "="');
			}
			break;
		case '/':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_E:
			case S_S:
			case S_C:
				s = S_C;
				el.closed = true;
			case S_V:
			case S_ATTR:
			case S_ATTR_S:
				break;
			//case S_EQ:
			default:
				throw new Error("attribute invalid close char('/')")
			}
			break;
		case ''://end document
			//throw new Error('unexpected end of input')
			errorHandler.error('unexpected end of input');
		case '>':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_E:
			case S_S:
			case S_C:
				break;//normal
			case S_V://Compatible state
			case S_ATTR:
				value = source.slice(start,p);
				if(value.slice(-1) === '/'){
					el.closed  = true;
					value = value.slice(0,-1)
				}
			case S_ATTR_S:
				if(s === S_ATTR_S){
					value = attrName;
				}
				if(s == S_V){
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					el.add(attrName,value.replace(/&#?\w+;/g,entityReplacer),start)
				}else{
					errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')
					el.add(value,value,start)
				}
				break;
			case S_EQ:
				throw new Error('attribute value missed!!');
			}
//			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
			return p;
		/*xml space '\x20' | #x9 | #xD | #xA; */
		case '\u0080':
			c = ' ';
		default:
			if(c<= ' '){//space
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));//tagName
					s = S_S;
					break;
				case S_ATTR:
					attrName = source.slice(start,p)
					s = S_ATTR_S;
					break;
				case S_V:
					var value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					el.add(attrName,value,start)
				case S_E:
					s = S_S;
					break;
				//case S_S:
				//case S_EQ:
				//case S_ATTR_S:
				//	void();break;
				//case S_C:
					//ignore warning
				}
			}else{//not space
//S_TAG,	S_ATTR,	S_EQ,	S_V
//S_ATTR_S,	S_E,	S_S,	S_C
				switch(s){
				//case S_TAG:void();break;
				//case S_ATTR:void();break;
				//case S_V:void();break;
				case S_ATTR_S:
					errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead!!')
					el.add(attrName,attrName,start);
					start = p;
					s = S_ATTR;
					break;
				case S_E:
					errorHandler.warning('attribute space is required"'+attrName+'"!!')
				case S_S:
					s = S_ATTR;
					start = p;
					break;
				case S_EQ:
					s = S_V;
					start = p;
					break;
				case S_C:
					throw new Error("elements closed character '/' and '>' must be connected to");
				}
			}
		}
		p++;
	}
}
/**
 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
 */
function appendElement(el,domBuilder,parseStack){
	var tagName = el.tagName;
	var localNSMap = null;
	var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
	var i = el.length;
	while(i--){
		var a = el[i];
		var qName = a.qName;
		var value = a.value;
		var nsp = qName.indexOf(':');
		if(nsp>0){
			var prefix = a.prefix = qName.slice(0,nsp);
			var localName = qName.slice(nsp+1);
			var nsPrefix = prefix === 'xmlns' && localName
		}else{
			localName = qName;
			prefix = null
			nsPrefix = qName === 'xmlns' && ''
		}
		//can not set prefix,because prefix !== ''
		a.localName = localName ;
		//prefix == null for no ns prefix attribute 
		if(nsPrefix !== false){//hack!!
			if(localNSMap == null){
				localNSMap = {}
				//console.log(currentNSMap,0)
				_copy(currentNSMap,currentNSMap={})
				//console.log(currentNSMap,1)
			}
			currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
			a.uri = 'http://www.w3.org/2000/xmlns/'
			domBuilder.startPrefixMapping(nsPrefix, value) 
		}
	}
	var i = el.length;
	while(i--){
		a = el[i];
		var prefix = a.prefix;
		if(prefix){//no prefix attribute has no namespace
			if(prefix === 'xml'){
				a.uri = 'http://www.w3.org/XML/1998/namespace';
			}if(prefix !== 'xmlns'){
				a.uri = currentNSMap[prefix]
				
				//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
			}
		}
	}
	var nsp = tagName.indexOf(':');
	if(nsp>0){
		prefix = el.prefix = tagName.slice(0,nsp);
		localName = el.localName = tagName.slice(nsp+1);
	}else{
		prefix = null;//important!!
		localName = el.localName = tagName;
	}
	//no prefix element has default namespace
	var ns = el.uri = currentNSMap[prefix || ''];
	domBuilder.startElement(ns,localName,tagName,el);
	//endPrefixMapping and startPrefixMapping have not any help for dom builder
	//localNSMap = null
	if(el.closed){
		domBuilder.endElement(ns,localName,tagName);
		if(localNSMap){
			for(prefix in localNSMap){
				domBuilder.endPrefixMapping(prefix) 
			}
		}
	}else{
		el.currentNSMap = currentNSMap;
		el.localNSMap = localNSMap;
		parseStack.push(el);
	}
}
function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){
	if(/^(?:script|textarea)$/i.test(tagName)){
		var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);
		var text = source.substring(elStartEnd+1,elEndStart);
		if(/[&<]/.test(text)){
			if(/^script$/i.test(tagName)){
				//if(!/\]\]>/.test(text)){
					//lexHandler.startCDATA();
					domBuilder.characters(text,0,text.length);
					//lexHandler.endCDATA();
					return elEndStart;
				//}
			}//}else{//text area
				text = text.replace(/&#?\w+;/g,entityReplacer);
				domBuilder.characters(text,0,text.length);
				return elEndStart;
			//}
			
		}
	}
	return elStartEnd+1;
}
function fixSelfClosed(source,elStartEnd,tagName,closeMap){
	//if(tagName in closeMap){
	var pos = closeMap[tagName];
	if(pos == null){
		//console.log(tagName)
		pos = closeMap[tagName] = source.lastIndexOf('</'+tagName+'>')
	}
	return pos<elStartEnd;
	//} 
}
function _copy(source,target){
	for(var n in source){target[n] = source[n]}
}
function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'
	var next= source.charAt(start+2)
	switch(next){
	case '-':
		if(source.charAt(start + 3) === '-'){
			var end = source.indexOf('-->',start+4);
			//append comment source.substring(4,end)//<!--
			if(end>start){
				domBuilder.comment(source,start+4,end-start-4);
				return end+3;
			}else{
				errorHandler.error("Unclosed comment");
				return -1;
			}
		}else{
			//error
			return -1;
		}
	default:
		if(source.substr(start+3,6) == 'CDATA['){
			var end = source.indexOf(']]>',start+9);
			domBuilder.startCDATA();
			domBuilder.characters(source,start+9,end-start-9);
			domBuilder.endCDATA() 
			return end+3;
		}
		//<!DOCTYPE
		//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) 
		var matchs = split(source,start);
		var len = matchs.length;
		if(len>1 && /!doctype/i.test(matchs[0][0])){
			var name = matchs[1][0];
			var pubid = len>3 && /^public$/i.test(matchs[2][0]) && matchs[3][0]
			var sysid = len>4 && matchs[4][0];
			var lastMatch = matchs[len-1]
			domBuilder.startDTD(name,pubid && pubid.replace(/^(['"])(.*?)\1$/,'$2'),
					sysid && sysid.replace(/^(['"])(.*?)\1$/,'$2'));
			domBuilder.endDTD();
			
			return lastMatch.index+lastMatch[0].length
		}
	}
	return -1;
}



function parseInstruction(source,start,domBuilder){
	var end = source.indexOf('?>',start);
	if(end){
		var match = source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
		if(match){
			var len = match[0].length;
			domBuilder.processingInstruction(match[1], match[2]) ;
			return end+2;
		}else{//error
			return -1;
		}
	}
	return -1;
}

/**
 * @param source
 */
function ElementAttributes(source){
	
}
ElementAttributes.prototype = {
	setTagName:function(tagName){
		if(!tagNamePattern.test(tagName)){
			throw new Error('invalid tagName:'+tagName)
		}
		this.tagName = tagName
	},
	add:function(qName,value,offset){
		if(!tagNamePattern.test(qName)){
			throw new Error('invalid attribute:'+qName)
		}
		this[this.length++] = {qName:qName,value:value,offset:offset}
	},
	length:0,
	getLocalName:function(i){return this[i].localName},
	getOffset:function(i){return this[i].offset},
	getQName:function(i){return this[i].qName},
	getURI:function(i){return this[i].uri},
	getValue:function(i){return this[i].value}
//	,getIndex:function(uri, localName)){
//		if(localName){
//			
//		}else{
//			var qName = uri
//		}
//	},
//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
//	getType:function(uri,localName){}
//	getType:function(i){},
}




function _set_proto_(thiz,parent){
	thiz.__proto__ = parent;
	return thiz;
}
if(!(_set_proto_({},_set_proto_.prototype) instanceof _set_proto_)){
	_set_proto_ = function(thiz,parent){
		function p(){};
		p.prototype = parent;
		p = new p();
		for(parent in thiz){
			p[parent] = thiz[parent];
		}
		return p;
	}
}

function split(source,start){
	var match;
	var buf = [];
	var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
	reg.lastIndex = start;
	reg.exec(source);//skip <
	while(match = reg.exec(source)){
		buf.push(match);
		if(match[1])return buf;
	}
}

if(typeof require == 'function'){
	exports.XMLReader = XMLReader;
}


},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xpath/xpath.js":[function(require,module,exports){
/*
 * xpath.js
 *
 * An XPath 1.0 library for JavaScript.
 *
 * Cameron McCormack <cam (at) mcc.id.au>
 *
 * This work is licensed under the Creative Commons Attribution-ShareAlike
 * License. To view a copy of this license, visit
 *
 *   http://creativecommons.org/licenses/by-sa/2.0/
 *
 * or send a letter to Creative Commons, 559 Nathan Abbott Way, Stanford,
 * California 94305, USA.
 *
 * Revision 20: April 26, 2011
 *   Fixed a typo resulting in FIRST_ORDERED_NODE_TYPE results being wrong,
 *   thanks to <shi_a009 (at) hotmail.com>.
 *
 * Revision 19: November 29, 2005
 *   Nodesets now store their nodes in a height balanced tree, increasing
 *   performance for the common case of selecting nodes in document order,
 *   thanks to Sastien Cramatte <contact (at) zeninteractif.com>.
 *   AVL tree code adapted from Raimund Neumann <rnova (at) gmx.net>.
 *
 * Revision 18: October 27, 2005
 *   DOM 3 XPath support.  Caveats:
 *     - namespace prefixes aren't resolved in XPathEvaluator.createExpression,
 *       but in XPathExpression.evaluate.
 *     - XPathResult.invalidIteratorState is not implemented.
 *
 * Revision 17: October 25, 2005
 *   Some core XPath function fixes and a patch to avoid crashing certain
 *   versions of MSXML in PathExpr.prototype.getOwnerElement, thanks to
 *   Sastien Cramatte <contact (at) zeninteractif.com>.
 *
 * Revision 16: September 22, 2005
 *   Workarounds for some IE 5.5 deficiencies.
 *   Fixed problem with prefix node tests on attribute nodes.
 *
 * Revision 15: May 21, 2005
 *   Fixed problem with QName node tests on elements with an xmlns="...".
 *
 * Revision 14: May 19, 2005
 *   Fixed QName node tests on attribute node regression.
 *
 * Revision 13: May 3, 2005
 *   Node tests are case insensitive now if working in an HTML DOM.
 *
 * Revision 12: April 26, 2005
 *   Updated licence.  Slight code changes to enable use of Dean
 *   Edwards' script compression, http://dean.edwards.name/packer/ .
 *
 * Revision 11: April 23, 2005
 *   Fixed bug with 'and' and 'or' operators, fix thanks to
 *   Sandy McArthur <sandy (at) mcarthur.org>.
 *
 * Revision 10: April 15, 2005
 *   Added support for a virtual root node, supposedly helpful for
 *   implementing XForms.  Fixed problem with QName node tests and
 *   the parent axis.
 *
 * Revision 9: March 17, 2005
 *   Namespace resolver tweaked so using the document node as the context
 *   for namespace lookups is equivalent to using the document element.
 *
 * Revision 8: February 13, 2005
 *   Handle implicit declaration of 'xmlns' namespace prefix.
 *   Fixed bug when comparing nodesets.
 *   Instance data can now be associated with a FunctionResolver, and
 *     workaround for MSXML not supporting 'localName' and 'getElementById',
 *     thanks to Grant Gongaware.
 *   Fix a few problems when the context node is the root node.
 *
 * Revision 7: February 11, 2005
 *   Default namespace resolver fix from Grant Gongaware
 *   <grant (at) gongaware.com>.
 *
 * Revision 6: February 10, 2005
 *   Fixed bug in 'number' function.
 *
 * Revision 5: February 9, 2005
 *   Fixed bug where text nodes not getting converted to string values.
 *
 * Revision 4: January 21, 2005
 *   Bug in 'name' function, fix thanks to Bill Edney.
 *   Fixed incorrect processing of namespace nodes.
 *   Fixed NamespaceResolver to resolve 'xml' namespace.
 *   Implemented union '|' operator.
 *
 * Revision 3: January 14, 2005
 *   Fixed bug with nodeset comparisons, bug lexing < and >.
 *
 * Revision 2: October 26, 2004
 *   QName node test namespace handling fixed.  Few other bug fixes.
 *
 * Revision 1: August 13, 2004
 *   Bug fixes from William J. Edney <bedney (at) technicalpursuit.com>.
 *   Added minimal licence.
 *
 * Initial version: June 14, 2004
 */

// non-node wrapper
if(typeof exports === 'undefined' ) {
	xpath = {};
}
(function(exports) {
	
// XPathParser ///////////////////////////////////////////////////////////////

XPathParser.prototype = new Object();
XPathParser.prototype.constructor = XPathParser;
XPathParser.superclass = Object.prototype;

function XPathParser() {
	this.init();
}

XPathParser.prototype.init = function() {
	this.reduceActions = [];

	this.reduceActions[3] = function(rhs) {
		return new OrOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[5] = function(rhs) {
		return new AndOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[7] = function(rhs) {
		return new EqualsOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[8] = function(rhs) {
		return new NotEqualOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[10] = function(rhs) {
		return new LessThanOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[11] = function(rhs) {
		return new GreaterThanOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[12] = function(rhs) {
		return new LessThanOrEqualOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[13] = function(rhs) {
		return new GreaterThanOrEqualOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[15] = function(rhs) {
		return new PlusOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[16] = function(rhs) {
		return new MinusOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[18] = function(rhs) {
		return new MultiplyOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[19] = function(rhs) {
		return new DivOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[20] = function(rhs) {
		return new ModOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[22] = function(rhs) {
		return new UnaryMinusOperation(rhs[1]);
	};
	this.reduceActions[24] = function(rhs) {
		return new BarOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[25] = function(rhs) {
		return new PathExpr(undefined, undefined, rhs[0]);
	};
	this.reduceActions[27] = function(rhs) {
		rhs[0].locationPath = rhs[2];
		return rhs[0];
	};
	this.reduceActions[28] = function(rhs) {
		rhs[0].locationPath = rhs[2];
		rhs[0].locationPath.steps.unshift(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));
		return rhs[0];
	};
	this.reduceActions[29] = function(rhs) {
		return new PathExpr(rhs[0], [], undefined);
	};
	this.reduceActions[30] = function(rhs) {
		if (Utilities.instance_of(rhs[0], PathExpr)) {
			if (rhs[0].filterPredicates == undefined) {
				rhs[0].filterPredicates = [];
			}
			rhs[0].filterPredicates.push(rhs[1]);
			return rhs[0];
		} else {
			return new PathExpr(rhs[0], [rhs[1]], undefined);
		}
	};
	this.reduceActions[32] = function(rhs) {
		return rhs[1];
	};
	this.reduceActions[33] = function(rhs) {
		return new XString(rhs[0]);
	};
	this.reduceActions[34] = function(rhs) {
		return new XNumber(rhs[0]);
	};
	this.reduceActions[36] = function(rhs) {
		return new FunctionCall(rhs[0], []);
	};
	this.reduceActions[37] = function(rhs) {
		return new FunctionCall(rhs[0], rhs[2]);
	};
	this.reduceActions[38] = function(rhs) {
		return [ rhs[0] ];
	};
	this.reduceActions[39] = function(rhs) {
		rhs[2].unshift(rhs[0]);
		return rhs[2];
	};
	this.reduceActions[43] = function(rhs) {
		return new LocationPath(true, []);
	};
	this.reduceActions[44] = function(rhs) {
		rhs[1].absolute = true;
		return rhs[1];
	};
	this.reduceActions[46] = function(rhs) {
		return new LocationPath(false, [ rhs[0] ]);
	};
	this.reduceActions[47] = function(rhs) {
		rhs[0].steps.push(rhs[2]);
		return rhs[0];
	};
	this.reduceActions[49] = function(rhs) {
		return new Step(rhs[0], rhs[1], []);
	};
	this.reduceActions[50] = function(rhs) {
		return new Step(Step.CHILD, rhs[0], []);
	};
	this.reduceActions[51] = function(rhs) {
		return new Step(rhs[0], rhs[1], rhs[2]);
	};
	this.reduceActions[52] = function(rhs) {
		return new Step(Step.CHILD, rhs[0], rhs[1]);
	};
	this.reduceActions[54] = function(rhs) {
		return [ rhs[0] ];
	};
	this.reduceActions[55] = function(rhs) {
		rhs[1].unshift(rhs[0]);
		return rhs[1];
	};
	this.reduceActions[56] = function(rhs) {
		if (rhs[0] == "ancestor") {
			return Step.ANCESTOR;
		} else if (rhs[0] == "ancestor-or-self") {
			return Step.ANCESTORORSELF;
		} else if (rhs[0] == "attribute") {
			return Step.ATTRIBUTE;
		} else if (rhs[0] == "child") {
			return Step.CHILD;
		} else if (rhs[0] == "descendant") {
			return Step.DESCENDANT;
		} else if (rhs[0] == "descendant-or-self") {
			return Step.DESCENDANTORSELF;
		} else if (rhs[0] == "following") {
			return Step.FOLLOWING;
		} else if (rhs[0] == "following-sibling") {
			return Step.FOLLOWINGSIBLING;
		} else if (rhs[0] == "namespace") {
			return Step.NAMESPACE;
		} else if (rhs[0] == "parent") {
			return Step.PARENT;
		} else if (rhs[0] == "preceding") {
			return Step.PRECEDING;
		} else if (rhs[0] == "preceding-sibling") {
			return Step.PRECEDINGSIBLING;
		} else if (rhs[0] == "self") {
			return Step.SELF;
		}
		return -1;
	};
	this.reduceActions[57] = function(rhs) {
		return Step.ATTRIBUTE;
	};
	this.reduceActions[59] = function(rhs) {
		if (rhs[0] == "comment") {
			return new NodeTest(NodeTest.COMMENT, undefined);
		} else if (rhs[0] == "text") {
			return new NodeTest(NodeTest.TEXT, undefined);
		} else if (rhs[0] == "processing-instruction") {
			return new NodeTest(NodeTest.PI, undefined);
		} else if (rhs[0] == "node") {
			return new NodeTest(NodeTest.NODE, undefined);
		}
		return new NodeTest(-1, undefined);
	};
	this.reduceActions[60] = function(rhs) {
		return new NodeTest(NodeTest.PI, rhs[2]);
	};
	this.reduceActions[61] = function(rhs) {
		return rhs[1];
	};
	this.reduceActions[63] = function(rhs) {
		rhs[1].absolute = true;
		rhs[1].steps.unshift(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));
		return rhs[1];
	};
	this.reduceActions[64] = function(rhs) {
		rhs[0].steps.push(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));
		rhs[0].steps.push(rhs[2]);
		return rhs[0];
	};
	this.reduceActions[65] = function(rhs) {
		return new Step(Step.SELF, new NodeTest(NodeTest.NODE, undefined), []);
	};
	this.reduceActions[66] = function(rhs) {
		return new Step(Step.PARENT, new NodeTest(NodeTest.NODE, undefined), []);
	};
	this.reduceActions[67] = function(rhs) {
		return new VariableReference(rhs[1]);
	};
	this.reduceActions[68] = function(rhs) {
		return new NodeTest(NodeTest.NAMETESTANY, undefined);
	};
	this.reduceActions[69] = function(rhs) {
		var prefix = rhs[0].substring(0, rhs[0].indexOf(":"));
		return new NodeTest(NodeTest.NAMETESTPREFIXANY, prefix);
	};
	this.reduceActions[70] = function(rhs) {
		return new NodeTest(NodeTest.NAMETESTQNAME, rhs[0]);
	};
};

XPathParser.actionTable = [
	" s s        sssssssss    s ss  s  ss",
	"                 s                  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"                rrrrr               ",
	" s s        sssssssss    s ss  s  ss",
	"rs  rrrrrrrr s  sssssrrrrrr  rrs rs ",
	" s s        sssssssss    s ss  s  ss",
	"                            s       ",
	"                            s       ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"  s                                 ",
	"                            s       ",
	" s           s  sssss          s  s ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"a                                   ",
	"r       s                    rr  r  ",
	"r      sr                    rr  r  ",
	"r   s  rr            s       rr  r  ",
	"r   rssrr            rss     rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrrsss         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrrs  rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r  srrrrrrrr         rrrrrrs rr sr  ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"                sssss               ",
	"r  rrrrrrrrr         rrrrrrr rr sr  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             s      ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"              s                     ",
	"                             s      ",
	"                rrrrr               ",
	" s s        sssssssss    s sss s  ss",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss      ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s           s  sssss          s  s ",
	" s           s  sssss          s  s ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	" s           s  sssss          s  s ",
	" s           s  sssss          s  s ",
	"r  rrrrrrrrr         rrrrrrr rr sr  ",
	"r  rrrrrrrrr         rrrrrrr rr sr  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             s      ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             rr     ",
	"                             s      ",
	"                             rs     ",
	"r      sr                    rr  r  ",
	"r   s  rr            s       rr  r  ",
	"r   rssrr            rss     rr  r  ",
	"r   rssrr            rss     rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrrsss         rrrrr   rr  r  ",
	"r   rrrrrsss         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"                                 r  ",
	"                                 s  ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	" s s        sssssssss    s ss  s  ss",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             r      "
];

XPathParser.actionTableNumber = [
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"                 J                  ",
	"a  aaaaaaaaa         aaaaaaa aa  a  ",
	"                YYYYY               ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"K1  KKKKKKKK .  +*)('KKKKKK  KK# K\" ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"                            N       ",
	"                            O       ",
	"e  eeeeeeeee         eeeeeee ee ee  ",
	"f  fffffffff         fffffff ff ff  ",
	"d  ddddddddd         ddddddd dd dd  ",
	"B  BBBBBBBBB         BBBBBBB BB BB  ",
	"A  AAAAAAAAA         AAAAAAA AA AA  ",
	"  P                                 ",
	"                            Q       ",
	" 1           .  +*)('          #  \" ",
	"b  bbbbbbbbb         bbbbbbb bb  b  ",
	"                                    ",
	"!       S                    !!  !  ",
	"\"      T\"                    \"\"  \"  ",
	"$   V  $$            U       $$  $  ",
	"&   &ZY&&            &XW     &&  &  ",
	")   )))))            )))\\[   ))  )  ",
	".   ....._^]         .....   ..  .  ",
	"1   11111111         11111   11  1  ",
	"5   55555555         55555`  55  5  ",
	"7   77777777         777777  77  7  ",
	"9   99999999         999999  99  9  ",
	":  c::::::::         ::::::b :: a:  ",
	"I  fIIIIIIII         IIIIIIe II  I  ",
	"=  =========         ======= == ==  ",
	"?  ?????????         ??????? ?? ??  ",
	"C  CCCCCCCCC         CCCCCCC CC CC  ",
	"J   JJJJJJJJ         JJJJJJ  JJ  J  ",
	"M   MMMMMMMM         MMMMMM  MM  M  ",
	"N  NNNNNNNNN         NNNNNNN NN  N  ",
	"P  PPPPPPPPP         PPPPPPP PP  P  ",
	"                +*)('               ",
	"R  RRRRRRRRR         RRRRRRR RR aR  ",
	"U  UUUUUUUUU         UUUUUUU UU  U  ",
	"Z  ZZZZZZZZZ         ZZZZZZZ ZZ ZZ  ",
	"c  ccccccccc         ccccccc cc cc  ",
	"                             j      ",
	"L  fLLLLLLLL         LLLLLLe LL  L  ",
	"6   66666666         66666   66  6  ",
	"              k                     ",
	"                             l      ",
	"                XXXXX               ",
	" 1 0        /.-,+*)('    & %$m #  \"!",
	"_  f________         ______e __  _  ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('      %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1           .  +*)('          #  \" ",
	" 1           .  +*)('          #  \" ",
	">  >>>>>>>>>         >>>>>>> >> >>  ",
	" 1           .  +*)('          #  \" ",
	" 1           .  +*)('          #  \" ",
	"Q  QQQQQQQQQ         QQQQQQQ QQ aQ  ",
	"V  VVVVVVVVV         VVVVVVV VV aV  ",
	"T  TTTTTTTTT         TTTTTTT TT  T  ",
	"@  @@@@@@@@@         @@@@@@@ @@ @@  ",
	"                             \x87      ",
	"[  [[[[[[[[[         [[[[[[[ [[ [[  ",
	"D  DDDDDDDDD         DDDDDDD DD DD  ",
	"                             HH     ",
	"                             \x88      ",
	"                             F\x89     ",
	"#      T#                    ##  #  ",
	"%   V  %%            U       %%  %  ",
	"'   'ZY''            'XW     ''  '  ",
	"(   (ZY((            (XW     ((  (  ",
	"+   +++++            +++\\[   ++  +  ",
	"*   *****            ***\\[   **  *  ",
	"-   -----            ---\\[   --  -  ",
	",   ,,,,,            ,,,\\[   ,,  ,  ",
	"0   00000_^]         00000   00  0  ",
	"/   /////_^]         /////   //  /  ",
	"2   22222222         22222   22  2  ",
	"3   33333333         33333   33  3  ",
	"4   44444444         44444   44  4  ",
	"8   88888888         888888  88  8  ",
	"                                 ^  ",
	"                                 \x8a  ",
	";  f;;;;;;;;         ;;;;;;e ;;  ;  ",
	"<  f<<<<<<<<         <<<<<<e <<  <  ",
	"O  OOOOOOOOO         OOOOOOO OO  O  ",
	"`  `````````         ``````` ``  `  ",
	"S  SSSSSSSSS         SSSSSSS SS  S  ",
	"W  WWWWWWWWW         WWWWWWW WW  W  ",
	"\\  \\\\\\\\\\\\\\\\\\         \\\\\\\\\\\\\\ \\\\ \\\\  ",
	"E  EEEEEEEEE         EEEEEEE EE EE  ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"]  ]]]]]]]]]         ]]]]]]] ]] ]]  ",
	"                             G      "
];

XPathParser.gotoTable = [
	"3456789:;<=>?@ AB  CDEFGH IJ ",
	"                             ",
	"                             ",
	"                             ",
	"L456789:;<=>?@ AB  CDEFGH IJ ",
	"            M        EFGH IJ ",
	"       N;<=>?@ AB  CDEFGH IJ ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"            S        EFGH IJ ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"              e              ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                        h  J ",
	"              i          j   ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"o456789:;<=>?@ ABpqCDEFGH IJ ",
	"                             ",
	"  r6789:;<=>?@ AB  CDEFGH IJ ",
	"   s789:;<=>?@ AB  CDEFGH IJ ",
	"    t89:;<=>?@ AB  CDEFGH IJ ",
	"    u89:;<=>?@ AB  CDEFGH IJ ",
	"     v9:;<=>?@ AB  CDEFGH IJ ",
	"     w9:;<=>?@ AB  CDEFGH IJ ",
	"     x9:;<=>?@ AB  CDEFGH IJ ",
	"     y9:;<=>?@ AB  CDEFGH IJ ",
	"      z:;<=>?@ AB  CDEFGH IJ ",
	"      {:;<=>?@ AB  CDEFGH IJ ",
	"       |;<=>?@ AB  CDEFGH IJ ",
	"       };<=>?@ AB  CDEFGH IJ ",
	"       ~;<=>?@ AB  CDEFGH IJ ",
	"         \x7f=>?@ AB  CDEFGH IJ ",
	"\x80456789:;<=>?@ AB  CDEFGH IJ\x81",
	"            \x82        EFGH IJ ",
	"            \x83        EFGH IJ ",
	"                             ",
	"                     \x84 GH IJ ",
	"                     \x85 GH IJ ",
	"              i          \x86   ",
	"              i          \x87   ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"o456789:;<=>?@ AB\x8cqCDEFGH IJ ",
	"                             ",
	"                             "
];

XPathParser.productions = [
	[1, 1, 2],
	[2, 1, 3],
	[3, 1, 4],
	[3, 3, 3, -9, 4],
	[4, 1, 5],
	[4, 3, 4, -8, 5],
	[5, 1, 6],
	[5, 3, 5, -22, 6],
	[5, 3, 5, -5, 6],
	[6, 1, 7],
	[6, 3, 6, -23, 7],
	[6, 3, 6, -24, 7],
	[6, 3, 6, -6, 7],
	[6, 3, 6, -7, 7],
	[7, 1, 8],
	[7, 3, 7, -25, 8],
	[7, 3, 7, -26, 8],
	[8, 1, 9],
	[8, 3, 8, -12, 9],
	[8, 3, 8, -11, 9],
	[8, 3, 8, -10, 9],
	[9, 1, 10],
	[9, 2, -26, 9],
	[10, 1, 11],
	[10, 3, 10, -27, 11],
	[11, 1, 12],
	[11, 1, 13],
	[11, 3, 13, -28, 14],
	[11, 3, 13, -4, 14],
	[13, 1, 15],
	[13, 2, 13, 16],
	[15, 1, 17],
	[15, 3, -29, 2, -30],
	[15, 1, -15],
	[15, 1, -16],
	[15, 1, 18],
	[18, 3, -13, -29, -30],
	[18, 4, -13, -29, 19, -30],
	[19, 1, 20],
	[19, 3, 20, -31, 19],
	[20, 1, 2],
	[12, 1, 14],
	[12, 1, 21],
	[21, 1, -28],
	[21, 2, -28, 14],
	[21, 1, 22],
	[14, 1, 23],
	[14, 3, 14, -28, 23],
	[14, 1, 24],
	[23, 2, 25, 26],
	[23, 1, 26],
	[23, 3, 25, 26, 27],
	[23, 2, 26, 27],
	[23, 1, 28],
	[27, 1, 16],
	[27, 2, 16, 27],
	[25, 2, -14, -3],
	[25, 1, -32],
	[26, 1, 29],
	[26, 3, -20, -29, -30],
	[26, 4, -21, -29, -15, -30],
	[16, 3, -33, 30, -34],
	[30, 1, 2],
	[22, 2, -4, 14],
	[24, 3, 14, -4, 23],
	[28, 1, -35],
	[28, 1, -2],
	[17, 2, -36, -18],
	[29, 1, -17],
	[29, 1, -19],
	[29, 1, -18]
];

XPathParser.DOUBLEDOT = 2;
XPathParser.DOUBLECOLON = 3;
XPathParser.DOUBLESLASH = 4;
XPathParser.NOTEQUAL = 5;
XPathParser.LESSTHANOREQUAL = 6;
XPathParser.GREATERTHANOREQUAL = 7;
XPathParser.AND = 8;
XPathParser.OR = 9;
XPathParser.MOD = 10;
XPathParser.DIV = 11;
XPathParser.MULTIPLYOPERATOR = 12;
XPathParser.FUNCTIONNAME = 13;
XPathParser.AXISNAME = 14;
XPathParser.LITERAL = 15;
XPathParser.NUMBER = 16;
XPathParser.ASTERISKNAMETEST = 17;
XPathParser.QNAME = 18;
XPathParser.NCNAMECOLONASTERISK = 19;
XPathParser.NODETYPE = 20;
XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL = 21;
XPathParser.EQUALS = 22;
XPathParser.LESSTHAN = 23;
XPathParser.GREATERTHAN = 24;
XPathParser.PLUS = 25;
XPathParser.MINUS = 26;
XPathParser.BAR = 27;
XPathParser.SLASH = 28;
XPathParser.LEFTPARENTHESIS = 29;
XPathParser.RIGHTPARENTHESIS = 30;
XPathParser.COMMA = 31;
XPathParser.AT = 32;
XPathParser.LEFTBRACKET = 33;
XPathParser.RIGHTBRACKET = 34;
XPathParser.DOT = 35;
XPathParser.DOLLAR = 36;

XPathParser.prototype.tokenize = function(s1) {
	var types = [];
	var values = [];
	var s = s1 + '\0';

	var pos = 0;
	var c = s.charAt(pos++);
	while (1) {
		while (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
			c = s.charAt(pos++);
		}
		if (c == '\0' || pos >= s.length) {
			break;
		}

		if (c == '(') {
			types.push(XPathParser.LEFTPARENTHESIS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == ')') {
			types.push(XPathParser.RIGHTPARENTHESIS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '[') {
			types.push(XPathParser.LEFTBRACKET);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == ']') {
			types.push(XPathParser.RIGHTBRACKET);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '@') {
			types.push(XPathParser.AT);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == ',') {
			types.push(XPathParser.COMMA);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '|') {
			types.push(XPathParser.BAR);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '+') {
			types.push(XPathParser.PLUS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '-') {
			types.push(XPathParser.MINUS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '=') {
			types.push(XPathParser.EQUALS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '$') {
			types.push(XPathParser.DOLLAR);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}

		if (c == '.') {
			c = s.charAt(pos++);
			if (c == '.') {
				types.push(XPathParser.DOUBLEDOT);
				values.push("..");
				c = s.charAt(pos++);
				continue;
			}
			if (c >= '0' && c <= '9') {
				var number = "." + c;
				c = s.charAt(pos++);
				while (c >= '0' && c <= '9') {
					number += c;
					c = s.charAt(pos++);
				}
				types.push(XPathParser.NUMBER);
				values.push(number);
				continue;
			}
			types.push(XPathParser.DOT);
			values.push('.');
			continue;
		}

		if (c == '\'' || c == '"') {
			var delimiter = c;
			var literal = "";
			while ((c = s.charAt(pos++)) != delimiter) {
				literal += c;
			}
			types.push(XPathParser.LITERAL);
			values.push(literal);
			c = s.charAt(pos++);
			continue;
		}

		if (c >= '0' && c <= '9') {
			var number = c;
			c = s.charAt(pos++);
			while (c >= '0' && c <= '9') {
				number += c;
				c = s.charAt(pos++);
			}
			if (c == '.') {
				if (s.charAt(pos) >= '0' && s.charAt(pos) <= '9') {
					number += c;
					number += s.charAt(pos++);
					c = s.charAt(pos++);
					while (c >= '0' && c <= '9') {
						number += c;
						c = s.charAt(pos++);
					}
				}
			}
			types.push(XPathParser.NUMBER);
			values.push(number);
			continue;
		}

		if (c == '*') {
			if (types.length > 0) {
				var last = types[types.length - 1];
				if (last != XPathParser.AT
						&& last != XPathParser.DOUBLECOLON
						&& last != XPathParser.LEFTPARENTHESIS
						&& last != XPathParser.LEFTBRACKET
						&& last != XPathParser.AND
						&& last != XPathParser.OR
						&& last != XPathParser.MOD
						&& last != XPathParser.DIV
						&& last != XPathParser.MULTIPLYOPERATOR
						&& last != XPathParser.SLASH
						&& last != XPathParser.DOUBLESLASH
						&& last != XPathParser.BAR
						&& last != XPathParser.PLUS
						&& last != XPathParser.MINUS
						&& last != XPathParser.EQUALS
						&& last != XPathParser.NOTEQUAL
						&& last != XPathParser.LESSTHAN
						&& last != XPathParser.LESSTHANOREQUAL
						&& last != XPathParser.GREATERTHAN
						&& last != XPathParser.GREATERTHANOREQUAL) {
					types.push(XPathParser.MULTIPLYOPERATOR);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
			}
			types.push(XPathParser.ASTERISKNAMETEST);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}

		if (c == ':') {
			if (s.charAt(pos) == ':') {
				types.push(XPathParser.DOUBLECOLON);
				values.push("::");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
		}

		if (c == '/') {
			c = s.charAt(pos++);
			if (c == '/') {
				types.push(XPathParser.DOUBLESLASH);
				values.push("//");
				c = s.charAt(pos++);
				continue;
			}
			types.push(XPathParser.SLASH);
			values.push('/');
			continue;
		}

		if (c == '!') {
			if (s.charAt(pos) == '=') {
				types.push(XPathParser.NOTEQUAL);
				values.push("!=");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
		}

		if (c == '<') {
			if (s.charAt(pos) == '=') {
				types.push(XPathParser.LESSTHANOREQUAL);
				values.push("<=");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
			types.push(XPathParser.LESSTHAN);
			values.push('<');
			c = s.charAt(pos++);
			continue;
		}

		if (c == '>') {
			if (s.charAt(pos) == '=') {
				types.push(XPathParser.GREATERTHANOREQUAL);
				values.push(">=");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
			types.push(XPathParser.GREATERTHAN);
			values.push('>');
			c = s.charAt(pos++);
			continue;
		}

		if (c == '_' || Utilities.isLetter(c.charCodeAt(0))) {
			var name = c;
			c = s.charAt(pos++);
			while (Utilities.isNCNameChar(c.charCodeAt(0))) {
				name += c;
				c = s.charAt(pos++);
			}
			if (types.length > 0) {
				var last = types[types.length - 1];
				if (last != XPathParser.AT
						&& last != XPathParser.DOUBLECOLON
						&& last != XPathParser.LEFTPARENTHESIS
						&& last != XPathParser.LEFTBRACKET
						&& last != XPathParser.AND
						&& last != XPathParser.OR
						&& last != XPathParser.MOD
						&& last != XPathParser.DIV
						&& last != XPathParser.MULTIPLYOPERATOR
						&& last != XPathParser.SLASH
						&& last != XPathParser.DOUBLESLASH
						&& last != XPathParser.BAR
						&& last != XPathParser.PLUS
						&& last != XPathParser.MINUS
						&& last != XPathParser.EQUALS
						&& last != XPathParser.NOTEQUAL
						&& last != XPathParser.LESSTHAN
						&& last != XPathParser.LESSTHANOREQUAL
						&& last != XPathParser.GREATERTHAN
						&& last != XPathParser.GREATERTHANOREQUAL) {
					if (name == "and") {
						types.push(XPathParser.AND);
						values.push(name);
						continue;
					}
					if (name == "or") {
						types.push(XPathParser.OR);
						values.push(name);
						continue;
					}
					if (name == "mod") {
						types.push(XPathParser.MOD);
						values.push(name);
						continue;
					}
					if (name == "div") {
						types.push(XPathParser.DIV);
						values.push(name);
						continue;
					}
				}
			}
			if (c == ':') {
				if (s.charAt(pos) == '*') {
					types.push(XPathParser.NCNAMECOLONASTERISK);
					values.push(name + ":*");
					pos++;
					c = s.charAt(pos++);
					continue;
				}
				if (s.charAt(pos) == '_' || Utilities.isLetter(s.charCodeAt(pos))) {
					name += ':';
					c = s.charAt(pos++);
					while (Utilities.isNCNameChar(c.charCodeAt(0))) {
						name += c;
						c = s.charAt(pos++);
					}
					if (c == '(') {
						types.push(XPathParser.FUNCTIONNAME);
						values.push(name);
						continue;
					}
					types.push(XPathParser.QNAME);
					values.push(name);
					continue;
				}
				if (s.charAt(pos) == ':') {
					types.push(XPathParser.AXISNAME);
					values.push(name);
					continue;
				}
			}
			if (c == '(') {
				if (name == "comment" || name == "text" || name == "node") {
					types.push(XPathParser.NODETYPE);
					values.push(name);
					continue;
				}
				if (name == "processing-instruction") {
					if (s.charAt(pos) == ')') {
						types.push(XPathParser.NODETYPE);
					} else {
						types.push(XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL);
					}
					values.push(name);
					continue;
				}
				types.push(XPathParser.FUNCTIONNAME);
				values.push(name);
				continue;
			}
			types.push(XPathParser.QNAME);
			values.push(name);
			continue;
		}

		throw new Error("Unexpected character " + c);
	}
	types.push(1);
	values.push("[EOF]");
	return [types, values];
};

XPathParser.SHIFT = 's';
XPathParser.REDUCE = 'r';
XPathParser.ACCEPT = 'a';

XPathParser.prototype.parse = function(s) {
	var types;
	var values;
	var res = this.tokenize(s);
	if (res == undefined) {
		return undefined;
	}
	types = res[0];
	values = res[1];
	var tokenPos = 0;
	var state = [];
	var tokenType = [];
	var tokenValue = [];
	var s;
	var a;
	var t;

	state.push(0);
	tokenType.push(1);
	tokenValue.push("_S");

	a = types[tokenPos];
	t = values[tokenPos++];
	while (1) {
		s = state[state.length - 1];
		switch (XPathParser.actionTable[s].charAt(a - 1)) {
			case XPathParser.SHIFT:
				tokenType.push(-a);
				tokenValue.push(t);
				state.push(XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32);
				a = types[tokenPos];
				t = values[tokenPos++];
				break;
			case XPathParser.REDUCE:
				var num = XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][1];
				var rhs = [];
				for (var i = 0; i < num; i++) {
					tokenType.pop();
					rhs.unshift(tokenValue.pop());
					state.pop();
				}
				var s_ = state[state.length - 1];
				tokenType.push(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0]);
				if (this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32] == undefined) {
					tokenValue.push(rhs[0]);
				} else {
					tokenValue.push(this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32](rhs));
				}
				state.push(XPathParser.gotoTable[s_].charCodeAt(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0] - 2) - 33);
				break;
			case XPathParser.ACCEPT:
				return new XPath(tokenValue.pop());
			default:
				throw new Error("XPath parse error");
		}
	}
};

// XPath /////////////////////////////////////////////////////////////////////

XPath.prototype = new Object();
XPath.prototype.constructor = XPath;
XPath.superclass = Object.prototype;

function XPath(e) {
	this.expression = e;
}

XPath.prototype.toString = function() {
	return this.expression.toString();
};

XPath.prototype.evaluate = function(c) {
	c.contextNode = c.expressionContextNode;
	c.contextSize = 1;
	c.contextPosition = 1;
	c.caseInsensitive = false;
	if (c.contextNode != null) {
		var doc = c.contextNode;
		if (doc.nodeType != 9 /*Node.DOCUMENT_NODE*/) {
			doc = doc.ownerDocument;
		}
		try {
			c.caseInsensitive = doc.implementation.hasFeature("HTML", "2.0");
		} catch (e) {
			c.caseInsensitive = true;
		}
	}
	return this.expression.evaluate(c);
};

XPath.XML_NAMESPACE_URI = "http://www.w3.org/XML/1998/namespace";
XPath.XMLNS_NAMESPACE_URI = "http://www.w3.org/2000/xmlns/";

// Expression ////////////////////////////////////////////////////////////////

Expression.prototype = new Object();
Expression.prototype.constructor = Expression;
Expression.superclass = Object.prototype;

function Expression() {
}

Expression.prototype.init = function() {
};

Expression.prototype.toString = function() {
	return "<Expression>";
};

Expression.prototype.evaluate = function(c) {
	throw new Error("Could not evaluate expression.");
};

// UnaryOperation ////////////////////////////////////////////////////////////

UnaryOperation.prototype = new Expression();
UnaryOperation.prototype.constructor = UnaryOperation;
UnaryOperation.superclass = Expression.prototype;

function UnaryOperation(rhs) {
	if (arguments.length > 0) {
		this.init(rhs);
	}
}

UnaryOperation.prototype.init = function(rhs) {
	this.rhs = rhs;
};

// UnaryMinusOperation ///////////////////////////////////////////////////////

UnaryMinusOperation.prototype = new UnaryOperation();
UnaryMinusOperation.prototype.constructor = UnaryMinusOperation;
UnaryMinusOperation.superclass = UnaryOperation.prototype;

function UnaryMinusOperation(rhs) {
	if (arguments.length > 0) {
		this.init(rhs);
	}
}

UnaryMinusOperation.prototype.init = function(rhs) {
	UnaryMinusOperation.superclass.init.call(this, rhs);
};

UnaryMinusOperation.prototype.evaluate = function(c) {
	return this.rhs.evaluate(c).number().negate();
};

UnaryMinusOperation.prototype.toString = function() {
	return "-" + this.rhs.toString();
};

// BinaryOperation ///////////////////////////////////////////////////////////

BinaryOperation.prototype = new Expression();
BinaryOperation.prototype.constructor = BinaryOperation;
BinaryOperation.superclass = Expression.prototype;

function BinaryOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

BinaryOperation.prototype.init = function(lhs, rhs) {
	this.lhs = lhs;
	this.rhs = rhs;
};

// OrOperation ///////////////////////////////////////////////////////////////

OrOperation.prototype = new BinaryOperation();
OrOperation.prototype.constructor = OrOperation;
OrOperation.superclass = BinaryOperation.prototype;

function OrOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

OrOperation.prototype.init = function(lhs, rhs) {
	OrOperation.superclass.init.call(this, lhs, rhs);
};

OrOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " or " + this.rhs.toString() + ")";
};

OrOperation.prototype.evaluate = function(c) {
	var b = this.lhs.evaluate(c).bool();
	if (b.booleanValue()) {
		return b;
	}
	return this.rhs.evaluate(c).bool();
};

// AndOperation //////////////////////////////////////////////////////////////

AndOperation.prototype = new BinaryOperation();
AndOperation.prototype.constructor = AndOperation;
AndOperation.superclass = BinaryOperation.prototype;

function AndOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

AndOperation.prototype.init = function(lhs, rhs) {
	AndOperation.superclass.init.call(this, lhs, rhs);
};

AndOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " and " + this.rhs.toString() + ")";
};

AndOperation.prototype.evaluate = function(c) {
	var b = this.lhs.evaluate(c).bool();
	if (!b.booleanValue()) {
		return b;
	}
	return this.rhs.evaluate(c).bool();
};

// EqualsOperation ///////////////////////////////////////////////////////////

EqualsOperation.prototype = new BinaryOperation();
EqualsOperation.prototype.constructor = EqualsOperation;
EqualsOperation.superclass = BinaryOperation.prototype;

function EqualsOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

EqualsOperation.prototype.init = function(lhs, rhs) {
	EqualsOperation.superclass.init.call(this, lhs, rhs);
};

EqualsOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " = " + this.rhs.toString() + ")";
};

EqualsOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).equals(this.rhs.evaluate(c));
};

// NotEqualOperation /////////////////////////////////////////////////////////

NotEqualOperation.prototype = new BinaryOperation();
NotEqualOperation.prototype.constructor = NotEqualOperation;
NotEqualOperation.superclass = BinaryOperation.prototype;

function NotEqualOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

NotEqualOperation.prototype.init = function(lhs, rhs) {
	NotEqualOperation.superclass.init.call(this, lhs, rhs);
};

NotEqualOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " != " + this.rhs.toString() + ")";
};

NotEqualOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).notequal(this.rhs.evaluate(c));
};

// LessThanOperation /////////////////////////////////////////////////////////

LessThanOperation.prototype = new BinaryOperation();
LessThanOperation.prototype.constructor = LessThanOperation;
LessThanOperation.superclass = BinaryOperation.prototype;

function LessThanOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

LessThanOperation.prototype.init = function(lhs, rhs) {
	LessThanOperation.superclass.init.call(this, lhs, rhs);
};

LessThanOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).lessthan(this.rhs.evaluate(c));
};

LessThanOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " < " + this.rhs.toString() + ")";
};

// GreaterThanOperation //////////////////////////////////////////////////////

GreaterThanOperation.prototype = new BinaryOperation();
GreaterThanOperation.prototype.constructor = GreaterThanOperation;
GreaterThanOperation.superclass = BinaryOperation.prototype;

function GreaterThanOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

GreaterThanOperation.prototype.init = function(lhs, rhs) {
	GreaterThanOperation.superclass.init.call(this, lhs, rhs);
};

GreaterThanOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).greaterthan(this.rhs.evaluate(c));
};

GreaterThanOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " > " + this.rhs.toString() + ")";
};

// LessThanOrEqualOperation //////////////////////////////////////////////////

LessThanOrEqualOperation.prototype = new BinaryOperation();
LessThanOrEqualOperation.prototype.constructor = LessThanOrEqualOperation;
LessThanOrEqualOperation.superclass = BinaryOperation.prototype;

function LessThanOrEqualOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

LessThanOrEqualOperation.prototype.init = function(lhs, rhs) {
	LessThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
};

LessThanOrEqualOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).lessthanorequal(this.rhs.evaluate(c));
};

LessThanOrEqualOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " <= " + this.rhs.toString() + ")";
};

// GreaterThanOrEqualOperation ///////////////////////////////////////////////

GreaterThanOrEqualOperation.prototype = new BinaryOperation();
GreaterThanOrEqualOperation.prototype.constructor = GreaterThanOrEqualOperation;
GreaterThanOrEqualOperation.superclass = BinaryOperation.prototype;

function GreaterThanOrEqualOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

GreaterThanOrEqualOperation.prototype.init = function(lhs, rhs) {
	GreaterThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
};

GreaterThanOrEqualOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).greaterthanorequal(this.rhs.evaluate(c));
};

GreaterThanOrEqualOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " >= " + this.rhs.toString() + ")";
};

// PlusOperation /////////////////////////////////////////////////////////////

PlusOperation.prototype = new BinaryOperation();
PlusOperation.prototype.constructor = PlusOperation;
PlusOperation.superclass = BinaryOperation.prototype;

function PlusOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

PlusOperation.prototype.init = function(lhs, rhs) {
	PlusOperation.superclass.init.call(this, lhs, rhs);
};

PlusOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().plus(this.rhs.evaluate(c).number());
};

PlusOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " + " + this.rhs.toString() + ")";
};

// MinusOperation ////////////////////////////////////////////////////////////

MinusOperation.prototype = new BinaryOperation();
MinusOperation.prototype.constructor = MinusOperation;
MinusOperation.superclass = BinaryOperation.prototype;

function MinusOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

MinusOperation.prototype.init = function(lhs, rhs) {
	MinusOperation.superclass.init.call(this, lhs, rhs);
};

MinusOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().minus(this.rhs.evaluate(c).number());
};

MinusOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " - " + this.rhs.toString() + ")";
};

// MultiplyOperation /////////////////////////////////////////////////////////

MultiplyOperation.prototype = new BinaryOperation();
MultiplyOperation.prototype.constructor = MultiplyOperation;
MultiplyOperation.superclass = BinaryOperation.prototype;

function MultiplyOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

MultiplyOperation.prototype.init = function(lhs, rhs) {
	MultiplyOperation.superclass.init.call(this, lhs, rhs);
};

MultiplyOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().multiply(this.rhs.evaluate(c).number());
};

MultiplyOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " * " + this.rhs.toString() + ")";
};

// DivOperation //////////////////////////////////////////////////////////////

DivOperation.prototype = new BinaryOperation();
DivOperation.prototype.constructor = DivOperation;
DivOperation.superclass = BinaryOperation.prototype;

function DivOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

DivOperation.prototype.init = function(lhs, rhs) {
	DivOperation.superclass.init.call(this, lhs, rhs);
};

DivOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().div(this.rhs.evaluate(c).number());
};

DivOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " div " + this.rhs.toString() + ")";
};

// ModOperation //////////////////////////////////////////////////////////////

ModOperation.prototype = new BinaryOperation();
ModOperation.prototype.constructor = ModOperation;
ModOperation.superclass = BinaryOperation.prototype;

function ModOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

ModOperation.prototype.init = function(lhs, rhs) {
	ModOperation.superclass.init.call(this, lhs, rhs);
};

ModOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().mod(this.rhs.evaluate(c).number());
};

ModOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " mod " + this.rhs.toString() + ")";
};

// BarOperation //////////////////////////////////////////////////////////////

BarOperation.prototype = new BinaryOperation();
BarOperation.prototype.constructor = BarOperation;
BarOperation.superclass = BinaryOperation.prototype;

function BarOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

BarOperation.prototype.init = function(lhs, rhs) {
	BarOperation.superclass.init.call(this, lhs, rhs);
};

BarOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).nodeset().union(this.rhs.evaluate(c).nodeset());
};

BarOperation.prototype.toString = function() {
	return this.lhs.toString() + " | " + this.rhs.toString();
};

// PathExpr //////////////////////////////////////////////////////////////////

PathExpr.prototype = new Expression();
PathExpr.prototype.constructor = PathExpr;
PathExpr.superclass = Expression.prototype;

function PathExpr(filter, filterPreds, locpath) {
	if (arguments.length > 0) {
		this.init(filter, filterPreds, locpath);
	}
}

PathExpr.prototype.init = function(filter, filterPreds, locpath) {
	PathExpr.superclass.init.call(this);
	this.filter = filter;
	this.filterPredicates = filterPreds;
	this.locationPath = locpath;
};

PathExpr.prototype.evaluate = function(c) {
	var nodes;
	var xpc = new XPathContext();
	xpc.variableResolver = c.variableResolver;
	xpc.functionResolver = c.functionResolver;
	xpc.namespaceResolver = c.namespaceResolver;
	xpc.expressionContextNode = c.expressionContextNode;
	xpc.virtualRoot = c.virtualRoot;
	xpc.caseInsensitive = c.caseInsensitive;
	if (this.filter == null) {
		nodes = [ c.contextNode ];
	} else {
		var ns = this.filter.evaluate(c);
		if (!Utilities.instance_of(ns, XNodeSet)) {
			if (this.filterPredicates != null && this.filterPredicates.length > 0 || this.locationPath != null) {
				throw new Error("Path expression filter must evaluate to a nodset if predicates or location path are used");
			}
			return ns;
		}
		nodes = ns.toArray();
		if (this.filterPredicates != null) {
			// apply each of the predicates in turn
			for (var j = 0; j < this.filterPredicates.length; j++) {
				var pred = this.filterPredicates[j];
				var newNodes = [];
				xpc.contextSize = nodes.length;
				for (xpc.contextPosition = 1; xpc.contextPosition <= xpc.contextSize; xpc.contextPosition++) {
					xpc.contextNode = nodes[xpc.contextPosition - 1];
					if (this.predicateMatches(pred, xpc)) {
						newNodes.push(xpc.contextNode);
					}
				}
				nodes = newNodes;
			}
		}
	}
	if (this.locationPath != null) {
		if (this.locationPath.absolute) {
			if (nodes[0].nodeType != 9 /*Node.DOCUMENT_NODE*/) {
				if (xpc.virtualRoot != null) {
					nodes = [ xpc.virtualRoot ];
				} else {
					if (nodes[0].ownerDocument == null) {
						// IE 5.5 doesn't have ownerDocument?
						var n = nodes[0];
						while (n.parentNode != null) {
							n = n.parentNode;
						}
						nodes = [ n ];
					} else {
						nodes = [ nodes[0].ownerDocument ];
					}
				}
			} else {
				nodes = [ nodes[0] ];
			}
		}
		for (var i = 0; i < this.locationPath.steps.length; i++) {
			var step = this.locationPath.steps[i];
			var newNodes = [];
			for (var j = 0; j < nodes.length; j++) {
				xpc.contextNode = nodes[j];
				switch (step.axis) {
					case Step.ANCESTOR:
						// look at all the ancestor nodes
						if (xpc.contextNode === xpc.virtualRoot) {
							break;
						}
						var m;
						if (xpc.contextNode.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
							m = this.getOwnerElement(xpc.contextNode);
						} else {
							m = xpc.contextNode.parentNode;
						}
						while (m != null) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
							if (m === xpc.virtualRoot) {
								break;
							}
							m = m.parentNode;
						}
						break;

					case Step.ANCESTORORSELF:
						// look at all the ancestor nodes and the current node
						for (var m = xpc.contextNode; m != null; m = m.nodeType == 2 /*Node.ATTRIBUTE_NODE*/ ? this.getOwnerElement(m) : m.parentNode) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
							if (m === xpc.virtualRoot) {
								break;
							}
						}
						break;

					case Step.ATTRIBUTE:
						// look at the attributes
						var nnm = xpc.contextNode.attributes;
						if (nnm != null) {
							for (var k = 0; k < nnm.length; k++) {
								var m = nnm.item(k);
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.push(m);
								}
							}
						}
						break;

					case Step.CHILD:
						// look at all child elements
						for (var m = xpc.contextNode.firstChild; m != null; m = m.nextSibling) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
						}
						break;

					case Step.DESCENDANT:
						// look at all descendant nodes
						var st = [ xpc.contextNode.firstChild ];
						while (st.length > 0) {
							for (var m = st.pop(); m != null; ) {
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.push(m);
								}
								if (m.firstChild != null) {
									st.push(m.nextSibling);
									m = m.firstChild;
								} else {
									m = m.nextSibling;
								}
							}
						}
						break;

					case Step.DESCENDANTORSELF:
						// look at self
						if (step.nodeTest.matches(xpc.contextNode, xpc)) {
							newNodes.push(xpc.contextNode);
						}
						// look at all descendant nodes
						var st = [ xpc.contextNode.firstChild ];
						while (st.length > 0) {
							for (var m = st.pop(); m != null; ) {
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.push(m);
								}
								if (m.firstChild != null) {
									st.push(m.nextSibling);
									m = m.firstChild;
								} else {
									m = m.nextSibling;
								}
							}
						}
						break;

					case Step.FOLLOWING:
						if (xpc.contextNode === xpc.virtualRoot) {
							break;
						}
						var st = [];
						if (xpc.contextNode.firstChild != null) {
							st.unshift(xpc.contextNode.firstChild);
						} else {
							st.unshift(xpc.contextNode.nextSibling);
						}
						for (var m = xpc.contextNode.parentNode; m != null && m.nodeType != 9 /*Node.DOCUMENT_NODE*/ && m !== xpc.virtualRoot; m = m.parentNode) {
							st.unshift(m.nextSibling);
						}
						do {
							for (var m = st.pop(); m != null; ) {
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.push(m);
								}
								if (m.firstChild != null) {
									st.push(m.nextSibling);
									m = m.firstChild;
								} else {
									m = m.nextSibling;
								}
							}
						} while (st.length > 0);
						break;

					case Step.FOLLOWINGSIBLING:
						if (xpc.contextNode === xpc.virtualRoot) {
							break;
						}
						for (var m = xpc.contextNode.nextSibling; m != null; m = m.nextSibling) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
						}
						break;

					case Step.NAMESPACE:
						var n = {};
						if (xpc.contextNode.nodeType == 1 /*Node.ELEMENT_NODE*/) {
							n["xml"] = XPath.XML_NAMESPACE_URI;
							n["xmlns"] = XPath.XMLNS_NAMESPACE_URI;
							for (var m = xpc.contextNode; m != null && m.nodeType == 1 /*Node.ELEMENT_NODE*/; m = m.parentNode) {
								for (var k = 0; k < m.attributes.length; k++) {
									var attr = m.attributes.item(k);
									var nm = String(attr.name);
									if (nm == "xmlns") {
										if (n[""] == undefined) {
											n[""] = attr.value;
										}
									} else if (nm.length > 6 && nm.substring(0, 6) == "xmlns:") {
										var pre = nm.substring(6, nm.length);
										if (n[pre] == undefined) {
											n[pre] = attr.value;
										}
									}
								}
							}
							for (var pre in n) {
								var nsn = new NamespaceNode(pre, n[pre], xpc.contextNode);
								if (step.nodeTest.matches(nsn, xpc)) {
									newNodes.push(nsn);
								}
							}
						}
						break;

					case Step.PARENT:
						m = null;
						if (xpc.contextNode !== xpc.virtualRoot) {
							if (xpc.contextNode.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
								m = this.getOwnerElement(xpc.contextNode);
							} else {
								m = xpc.contextNode.parentNode;
							}
						}
						if (m != null && step.nodeTest.matches(m, xpc)) {
							newNodes.push(m);
						}
						break;

					case Step.PRECEDING:
						var st;
						if (xpc.virtualRoot != null) {
							st = [ xpc.virtualRoot ];
						} else {
							st = xpc.contextNode.nodeType == 9 /*Node.DOCUMENT_NODE*/
								? [ xpc.contextNode ]
								: [ xpc.contextNode.ownerDocument ];
						}
						outer: while (st.length > 0) {
							for (var m = st.pop(); m != null; ) {
								if (m == xpc.contextNode) {
									break outer;
								}
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.unshift(m);
								}
								if (m.firstChild != null) {
									st.push(m.nextSibling);
									m = m.firstChild;
								} else {
									m = m.nextSibling;
								}
							}
						}
						break;

					case Step.PRECEDINGSIBLING:
						if (xpc.contextNode === xpc.virtualRoot) {
							break;
						}
						for (var m = xpc.contextNode.previousSibling; m != null; m = m.previousSibling) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
						}
						break;

					case Step.SELF:
						if (step.nodeTest.matches(xpc.contextNode, xpc)) {
							newNodes.push(xpc.contextNode);
						}
						break;

					default:
				}
			}
			nodes = newNodes;
			// apply each of the predicates in turn
			for (var j = 0; j < step.predicates.length; j++) {
				var pred = step.predicates[j];
				var newNodes = [];
				xpc.contextSize = nodes.length;
				for (xpc.contextPosition = 1; xpc.contextPosition <= xpc.contextSize; xpc.contextPosition++) {
					xpc.contextNode = nodes[xpc.contextPosition - 1];
					if (this.predicateMatches(pred, xpc)) {
						newNodes.push(xpc.contextNode);
					} else {
					}
				}
				nodes = newNodes;
			}
		}
	}
	var ns = new XNodeSet();
	ns.addArray(nodes);
	return ns;
};

PathExpr.prototype.predicateMatches = function(pred, c) {
	var res = pred.evaluate(c);
	if (Utilities.instance_of(res, XNumber)) {
		return c.contextPosition == res.numberValue();
	}
	return res.booleanValue();
};

PathExpr.prototype.toString = function() {
	if (this.filter != undefined) {
		var s = this.filter.toString();
		if (Utilities.instance_of(this.filter, XString)) {
			s = "'" + s + "'";
		}
		if (this.filterPredicates != undefined) {
			for (var i = 0; i < this.filterPredicates.length; i++) {
				s = s + "[" + this.filterPredicates[i].toString() + "]";
			}
		}
		if (this.locationPath != undefined) {
			if (!this.locationPath.absolute) {
				s += "/";
			}
			s += this.locationPath.toString();
		}
		return s;
	}
	return this.locationPath.toString();
};

PathExpr.prototype.getOwnerElement = function(n) {
	// DOM 2 has ownerElement
	if (n.ownerElement) {
		return n.ownerElement;
	}
	// DOM 1 Internet Explorer can use selectSingleNode (ironically)
	try {
		if (n.selectSingleNode) {
			return n.selectSingleNode("..");
		}
	} catch (e) {
	}
	// Other DOM 1 implementations must use this egregious search
	var doc = n.nodeType == 9 /*Node.DOCUMENT_NODE*/
			? n
			: n.ownerDocument;
	var elts = doc.getElementsByTagName("*");
	for (var i = 0; i < elts.length; i++) {
		var elt = elts.item(i);
		var nnm = elt.attributes;
		for (var j = 0; j < nnm.length; j++) {
			var an = nnm.item(j);
			if (an === n) {
				return elt;
			}
		}
	}
	return null;
};

// LocationPath //////////////////////////////////////////////////////////////

LocationPath.prototype = new Object();
LocationPath.prototype.constructor = LocationPath;
LocationPath.superclass = Object.prototype;

function LocationPath(abs, steps) {
	if (arguments.length > 0) {
		this.init(abs, steps);
	}
}

LocationPath.prototype.init = function(abs, steps) {
	this.absolute = abs;
	this.steps = steps;
};

LocationPath.prototype.toString = function() {
	var s;
	if (this.absolute) {
		s = "/";
	} else {
		s = "";
	}
	for (var i = 0; i < this.steps.length; i++) {
		if (i != 0) {
			s += "/";
		}
		s += this.steps[i].toString();
	}
	return s;
};

// Step //////////////////////////////////////////////////////////////////////

Step.prototype = new Object();
Step.prototype.constructor = Step;
Step.superclass = Object.prototype;

function Step(axis, nodetest, preds) {
	if (arguments.length > 0) {
		this.init(axis, nodetest, preds);
	}
}

Step.prototype.init = function(axis, nodetest, preds) {
	this.axis = axis;
	this.nodeTest = nodetest;
	this.predicates = preds;
};

Step.prototype.toString = function() {
	var s;
	switch (this.axis) {
		case Step.ANCESTOR:
			s = "ancestor";
			break;
		case Step.ANCESTORORSELF:
			s = "ancestor-or-self";
			break;
		case Step.ATTRIBUTE:
			s = "attribute";
			break;
		case Step.CHILD:
			s = "child";
			break;
		case Step.DESCENDANT:
			s = "descendant";
			break;
		case Step.DESCENDANTORSELF:
			s = "descendant-or-self";
			break;
		case Step.FOLLOWING:
			s = "following";
			break;
		case Step.FOLLOWINGSIBLING:
			s = "following-sibling";
			break;
		case Step.NAMESPACE:
			s = "namespace";
			break;
		case Step.PARENT:
			s = "parent";
			break;
		case Step.PRECEDING:
			s = "preceding";
			break;
		case Step.PRECEDINGSIBLING:
			s = "preceding-sibling";
			break;
		case Step.SELF:
			s = "self";
			break;
	}
	s += "::";
	s += this.nodeTest.toString();
	for (var i = 0; i < this.predicates.length; i++) {
		s += "[" + this.predicates[i].toString() + "]";
	}
	return s;
};

Step.ANCESTOR = 0;
Step.ANCESTORORSELF = 1;
Step.ATTRIBUTE = 2;
Step.CHILD = 3;
Step.DESCENDANT = 4;
Step.DESCENDANTORSELF = 5;
Step.FOLLOWING = 6;
Step.FOLLOWINGSIBLING = 7;
Step.NAMESPACE = 8;
Step.PARENT = 9;
Step.PRECEDING = 10;
Step.PRECEDINGSIBLING = 11;
Step.SELF = 12;

// NodeTest //////////////////////////////////////////////////////////////////

NodeTest.prototype = new Object();
NodeTest.prototype.constructor = NodeTest;
NodeTest.superclass = Object.prototype;

function NodeTest(type, value) {
	if (arguments.length > 0) {
		this.init(type, value);
	}
}

NodeTest.prototype.init = function(type, value) {
	this.type = type;
	this.value = value;
};

NodeTest.prototype.toString = function() {
	switch (this.type) {
		case NodeTest.NAMETESTANY:
			return "*";
		case NodeTest.NAMETESTPREFIXANY:
			return this.value + ":*";
		case NodeTest.NAMETESTRESOLVEDANY:
			return "{" + this.value + "}*";
		case NodeTest.NAMETESTQNAME:
			return this.value;
		case NodeTest.NAMETESTRESOLVEDNAME:
			return "{" + this.namespaceURI + "}" + this.value;
		case NodeTest.COMMENT:
			return "comment()";
		case NodeTest.TEXT:
			return "text()";
		case NodeTest.PI:
			if (this.value != undefined) {
				return "processing-instruction(\"" + this.value + "\")";
			}
			return "processing-instruction()";
		case NodeTest.NODE:
			return "node()";
	}
	return "<unknown nodetest type>";
};

NodeTest.prototype.matches = function(n, xpc) {
	switch (this.type) {
		case NodeTest.NAMETESTANY:
			if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/
					|| n.nodeType == 1 /*Node.ELEMENT_NODE*/
					|| n.nodeType == XPathNamespace.XPATH_NAMESPACE_NODE) {
				return true;
			}
			return false;
		case NodeTest.NAMETESTPREFIXANY:
			if ((n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/ || n.nodeType == 1 /*Node.ELEMENT_NODE*/)) {
				var ns = xpc.namespaceResolver.getNamespace(this.value, xpc.expressionContextNode);
				if (ns == null) {
					throw new Error("Cannot resolve QName " + this.value);
				}
				return ns == (n.namespaceURI || '');
			}
			return false;
		case NodeTest.NAMETESTQNAME:
			if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/
					|| n.nodeType == 1 /*Node.ELEMENT_NODE*/
					|| n.nodeType == XPathNamespace.XPATH_NAMESPACE_NODE) {
				var test = Utilities.resolveQName(this.value, xpc.namespaceResolver, xpc.expressionContextNode, false);
				if (test[0] == null) {
					throw new Error("Cannot resolve QName " + this.value);
				}
				test[0] = String(test[0]);
				test[1] = String(test[1]);
				if (test[0] == "") {
					test[0] = null;
				}
				var node = [n.namespaceURI || '', n.localName];
				node[0] = String(node[0]);
				node[1] = String(node[1]);
				if (node[0] == "") {
					node[0] = null;
				}
				if (xpc.caseInsensitive) {
					return test[0] == node[0] && String(test[1]).toLowerCase() == String(node[1]).toLowerCase();
				}
				return test[0] == node[0] && test[1] == node[1];
			}
			return false;
		case NodeTest.COMMENT:
			return n.nodeType == 8 /*Node.COMMENT_NODE*/;
		case NodeTest.TEXT:
			return n.nodeType == 3 /*Node.TEXT_NODE*/ || n.nodeType == 4 /*Node.CDATA_SECTION_NODE*/;
		case NodeTest.PI:
			return n.nodeType == 7 /*Node.PROCESSING_INSTRUCTION_NODE*/
				&& (this.value == null || n.nodeName == this.value);
		case NodeTest.NODE:
			return n.nodeType == 9 /*Node.DOCUMENT_NODE*/
				|| n.nodeType == 1 /*Node.ELEMENT_NODE*/
				|| n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/
				|| n.nodeType == 3 /*Node.TEXT_NODE*/
				|| n.nodeType == 4 /*Node.CDATA_SECTION_NODE*/
				|| n.nodeType == 8 /*Node.COMMENT_NODE*/
				|| n.nodeType == 7 /*Node.PROCESSING_INSTRUCTION_NODE*/;
	}
	return false;
};

NodeTest.NAMETESTANY = 0;
NodeTest.NAMETESTPREFIXANY = 1;
NodeTest.NAMETESTQNAME = 2;
NodeTest.COMMENT = 3;
NodeTest.TEXT = 4;
NodeTest.PI = 5;
NodeTest.NODE = 6;

// VariableReference /////////////////////////////////////////////////////////

VariableReference.prototype = new Expression();
VariableReference.prototype.constructor = VariableReference;
VariableReference.superclass = Expression.prototype;

function VariableReference(v) {
	if (arguments.length > 0) {
		this.init(v);
	}
}

VariableReference.prototype.init = function(v) {
	this.variable = v;
};

VariableReference.prototype.toString = function() {
	return "$" + this.variable;
};

VariableReference.prototype.evaluate = function(c) {
	return c.variableResolver.getVariable(this.variable, c);
};

// FunctionCall //////////////////////////////////////////////////////////////

FunctionCall.prototype = new Expression();
FunctionCall.prototype.constructor = FunctionCall;
FunctionCall.superclass = Expression.prototype;

function FunctionCall(fn, args) {
	if (arguments.length > 0) {
		this.init(fn, args);
	}
}

FunctionCall.prototype.init = function(fn, args) {
	this.functionName = fn;
	this.arguments = args;
};

FunctionCall.prototype.toString = function() {
	var s = this.functionName + "(";
	for (var i = 0; i < this.arguments.length; i++) {
		if (i > 0) {
			s += ", ";
		}
		s += this.arguments[i].toString();
	}
	return s + ")";
};

FunctionCall.prototype.evaluate = function(c) {
	var f = c.functionResolver.getFunction(this.functionName, c);
	if (f == undefined) {
		throw new Error("Unknown function " + this.functionName);
	}
	var a = [c].concat(this.arguments);
	return f.apply(c.functionResolver.thisArg, a);
};

// XString ///////////////////////////////////////////////////////////////////

XString.prototype = new Expression();
XString.prototype.constructor = XString;
XString.superclass = Expression.prototype;

function XString(s) {
	if (arguments.length > 0) {
		this.init(s);
	}
}

XString.prototype.init = function(s) {
	this.str = s;
};

XString.prototype.toString = function() {
	return this.str;
};

XString.prototype.evaluate = function(c) {
	return this;
};

XString.prototype.string = function() {
	return this;
};

XString.prototype.number = function() {
	return new XNumber(this.str);
};

XString.prototype.bool = function() {
	return new XBoolean(this.str);
};

XString.prototype.nodeset = function() {
	throw new Error("Cannot convert string to nodeset");
};

XString.prototype.stringValue = function() {
	return this.str;
};

XString.prototype.numberValue = function() {
	return this.number().numberValue();
};

XString.prototype.booleanValue = function() {
	return this.bool().booleanValue();
};

XString.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().equals(r);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.number().equals(r);
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithString(this, Operators.equals);
	}
	return new XBoolean(this.str == r.str);
};

XString.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().notequal(r);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.number().notequal(r);
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithString(this, Operators.notequal);
	}
	return new XBoolean(this.str != r.str);
};

XString.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.greaterthanorequal);
	}
	return this.number().lessthan(r.number());
};

XString.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.lessthanorequal);
	}
	return this.number().greaterthan(r.number());
};

XString.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.greaterthan);
	}
	return this.number().lessthanorequal(r.number());
};

XString.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.lessthan);
	}
	return this.number().greaterthanorequal(r.number());
};

// XNumber ///////////////////////////////////////////////////////////////////

XNumber.prototype = new Expression();
XNumber.prototype.constructor = XNumber;
XNumber.superclass = Expression.prototype;

function XNumber(n) {
	if (arguments.length > 0) {
		this.init(n);
	}
}

XNumber.prototype.init = function(n) {
	this.num = Number(n);
};

XNumber.prototype.toString = function() {
	return this.num;
};

XNumber.prototype.evaluate = function(c) {
	return this;
};

XNumber.prototype.string = function() {
	return new XString(this.num);
};

XNumber.prototype.number = function() {
	return this;
};

XNumber.prototype.bool = function() {
	return new XBoolean(this.num);
};

XNumber.prototype.nodeset = function() {
	throw new Error("Cannot convert number to nodeset");
};

XNumber.prototype.stringValue = function() {
	return this.string().stringValue();
};

XNumber.prototype.numberValue = function() {
	return this.num;
};

XNumber.prototype.booleanValue = function() {
	return this.bool().booleanValue();
};

XNumber.prototype.negate = function() {
	return new XNumber(-this.num);
};

XNumber.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().equals(r);
	}
	if (Utilities.instance_of(r, XString)) {
		return this.equals(r.number());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.equals);
	}
	return new XBoolean(this.num == r.num);
};

XNumber.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().notequal(r);
	}
	if (Utilities.instance_of(r, XString)) {
		return this.notequal(r.number());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.notequal);
	}
	return new XBoolean(this.num != r.num);
};

XNumber.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.greaterthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.lessthan(r.number());
	}
	return new XBoolean(this.num < r.num);
};

XNumber.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.lessthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.greaterthan(r.number());
	}
	return new XBoolean(this.num > r.num);
};

XNumber.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.greaterthan);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.lessthanorequal(r.number());
	}
	return new XBoolean(this.num <= r.num);
};

XNumber.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.lessthan);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.greaterthanorequal(r.number());
	}
	return new XBoolean(this.num >= r.num);
};

XNumber.prototype.plus = function(r) {
	return new XNumber(this.num + r.num);
};

XNumber.prototype.minus = function(r) {
	return new XNumber(this.num - r.num);
};

XNumber.prototype.multiply = function(r) {
	return new XNumber(this.num * r.num);
};

XNumber.prototype.div = function(r) {
	return new XNumber(this.num / r.num);
};

XNumber.prototype.mod = function(r) {
	return new XNumber(this.num % r.num);
};

// XBoolean //////////////////////////////////////////////////////////////////

XBoolean.prototype = new Expression();
XBoolean.prototype.constructor = XBoolean;
XBoolean.superclass = Expression.prototype;

function XBoolean(b) {
	if (arguments.length > 0) {
		this.init(b);
	}
}

XBoolean.prototype.init = function(b) {
	this.b = Boolean(b);
};

XBoolean.prototype.toString = function() {
	return this.b.toString();
};

XBoolean.prototype.evaluate = function(c) {
	return this;
};

XBoolean.prototype.string = function() {
	return new XString(this.b);
};

XBoolean.prototype.number = function() {
	return new XNumber(this.b);
};

XBoolean.prototype.bool = function() {
	return this;
};

XBoolean.prototype.nodeset = function() {
	throw new Error("Cannot convert boolean to nodeset");
};

XBoolean.prototype.stringValue = function() {
	return this.string().stringValue();
};

XBoolean.prototype.numberValue = function() {
	return this.num().numberValue();
};

XBoolean.prototype.booleanValue = function() {
	return this.b;
};

XBoolean.prototype.not = function() {
	return new XBoolean(!this.b);
};

XBoolean.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {
		return this.equals(r.bool());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithBoolean(this, Operators.equals);
	}
	return new XBoolean(this.b == r.b);
};

XBoolean.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {
		return this.notequal(r.bool());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithBoolean(this, Operators.notequal);
	}
	return new XBoolean(this.b != r.b);
};

XBoolean.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.greaterthanorequal);
	}
	return this.number().lessthan(r.number());
};

XBoolean.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.lessthanorequal);
	}
	return this.number().greaterthan(r.number());
};

XBoolean.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.greaterthan);
	}
	return this.number().lessthanorequal(r.number());
};

XBoolean.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.lessthan);
	}
	return this.number().greaterthanorequal(r.number());
};

// AVLTree ///////////////////////////////////////////////////////////////////

AVLTree.prototype = new Object();
AVLTree.prototype.constructor = AVLTree;
AVLTree.superclass = Object.prototype;

function AVLTree(n) {
	this.init(n);
}

AVLTree.prototype.init = function(n) {
	this.left = null;
    this.right = null;
	this.node = n;
	this.depth = 1;
};

AVLTree.prototype.balance = function() {
    var ldepth = this.left  == null ? 0 : this.left.depth;
    var rdepth = this.right == null ? 0 : this.right.depth;

	if (ldepth > rdepth + 1) {
        // LR or LL rotation
        var lldepth = this.left.left  == null ? 0 : this.left.left.depth;
        var lrdepth = this.left.right == null ? 0 : this.left.right.depth;

        if (lldepth < lrdepth) {
            // LR rotation consists of a RR rotation of the left child
            this.left.rotateRR();
            // plus a LL rotation of this node, which happens anyway
        }
        this.rotateLL();
    } else if (ldepth + 1 < rdepth) {
        // RR or RL rorarion
		var rrdepth = this.right.right == null ? 0 : this.right.right.depth;
		var rldepth = this.right.left  == null ? 0 : this.right.left.depth;

        if (rldepth > rrdepth) {
            // RR rotation consists of a LL rotation of the right child
            this.right.rotateLL();
            // plus a RR rotation of this node, which happens anyway
        }
        this.rotateRR();
    }
};

AVLTree.prototype.rotateLL = function() {
    // the left side is too long => rotate from the left (_not_ leftwards)
    var nodeBefore = this.node;
    var rightBefore = this.right;
    this.node = this.left.node;
    this.right = this.left;
    this.left = this.left.left;
    this.right.left = this.right.right;
    this.right.right = rightBefore;
    this.right.node = nodeBefore;
    this.right.updateInNewLocation();
    this.updateInNewLocation();
};

AVLTree.prototype.rotateRR = function() {
    // the right side is too long => rotate from the right (_not_ rightwards)
    var nodeBefore = this.node;
    var leftBefore = this.left;
    this.node = this.right.node;
    this.left = this.right;
    this.right = this.right.right;
    this.left.right = this.left.left;
    this.left.left = leftBefore;
    this.left.node = nodeBefore;
    this.left.updateInNewLocation();
    this.updateInNewLocation();
};

AVLTree.prototype.updateInNewLocation = function() {
    this.getDepthFromChildren();
};

AVLTree.prototype.getDepthFromChildren = function() {
    this.depth = this.node == null ? 0 : 1;
    if (this.left != null) {
        this.depth = this.left.depth + 1;
    }
    if (this.right != null && this.depth <= this.right.depth) {
        this.depth = this.right.depth + 1;
    }
};

AVLTree.prototype.order = function(n1, n2) {
	if (n1 === n2) {
		return 0;
	}
	var d1 = 0;
	var d2 = 0;
	for (var m1 = n1; m1 != null; m1 = m1.parentNode) {
		d1++;
	}
	for (var m2 = n2; m2 != null; m2 = m2.parentNode) {
		d2++;
	}
	if (d1 > d2) {
		while (d1 > d2) {
			n1 = n1.parentNode;
			d1--;
		}
		if (n1 == n2) {
			return 1;
		}
	} else if (d2 > d1) {
		while (d2 > d1) {
			n2 = n2.parentNode;
			d2--;
		}
		if (n1 == n2) {
			return -1;
		}
	}
	while (n1.parentNode != n2.parentNode) {
		n1 = n1.parentNode;
		n2 = n2.parentNode;
	}
	while (n1.previousSibling != null && n2.previousSibling != null) {
		n1 = n1.previousSibling;
		n2 = n2.previousSibling;
	}
	if (n1.previousSibling == null) {
		return -1;
	}
	return 1;
};

AVLTree.prototype.add = function(n)  {
	if (n === this.node) {
        return false;
    }

	var o = this.order(n, this.node);

    var ret = false;
    if (o == -1) {
        if (this.left == null) {
            this.left = new AVLTree(n);
            ret = true;
        } else {
            ret = this.left.add(n);
            if (ret) {
                this.balance();
            }
        }
    } else if (o == 1) {
        if (this.right == null) {
            this.right = new AVLTree(n);
            ret = true;
        } else {
            ret = this.right.add(n);
            if (ret) {
                this.balance();
            }
        }
    }

    if (ret) {
        this.getDepthFromChildren();
    }
    return ret;
};

// XNodeSet //////////////////////////////////////////////////////////////////

XNodeSet.prototype = new Expression();
XNodeSet.prototype.constructor = XNodeSet;
XNodeSet.superclass = Expression.prototype;

function XNodeSet() {
	this.init();
}

XNodeSet.prototype.init = function() {
	this.tree = null;
	this.size = 0;
};

XNodeSet.prototype.toString = function() {
	var p = this.first();
	if (p == null) {
		return "";
	}
	return this.stringForNode(p);
};

XNodeSet.prototype.evaluate = function(c) {
	return this;
};

XNodeSet.prototype.string = function() {
	return new XString(this.toString());
};

XNodeSet.prototype.stringValue = function() {
	return this.toString();
};

XNodeSet.prototype.number = function() {
	return new XNumber(this.string());
};

XNodeSet.prototype.numberValue = function() {
	return Number(this.string());
};

XNodeSet.prototype.bool = function() {
	return new XBoolean(this.tree != null);
};

XNodeSet.prototype.booleanValue = function() {
	return this.tree != null;
};

XNodeSet.prototype.nodeset = function() {
	return this;
};

XNodeSet.prototype.stringForNode = function(n) {
	if (n.nodeType == 9 /*Node.DOCUMENT_NODE*/) {
		n = n.documentElement;
	}
	if (n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
		return this.stringForNodeRec(n);
	}
	if (n.isNamespaceNode) {
		return n.namespace;
	}
	return n.nodeValue;
};

XNodeSet.prototype.stringForNodeRec = function(n) {
	var s = "";
	for (var n2 = n.firstChild; n2 != null; n2 = n2.nextSibling) {
		if (n2.nodeType == 3 /*Node.TEXT_NODE*/) {
			s += n2.nodeValue;
		} else if (n2.nodeType == 1 /*Node.ELEMENT_NODE*/) {
			s += this.stringForNodeRec(n2);
		}
	}
	return s;
};

XNodeSet.prototype.first = function() {
	var p = this.tree;
	if (p == null) {
		return null;
	}
	while (p.left != null) {
		p = p.left;
	}
	return p.node;
};

XNodeSet.prototype.add = function(n) {
    var added;
    if (this.tree == null) {
        this.tree = new AVLTree(n);
        added = true;
    } else {
        added = this.tree.add(n);
    }
    if (added) {
        this.size++;
    }
};

XNodeSet.prototype.addArray = function(ns) {
	for (var i = 0; i < ns.length; i++) {
		this.add(ns[i]);
	}
};

XNodeSet.prototype.toArray = function() {
	var a = [];
	this.toArrayRec(this.tree, a);
	return a;
};

XNodeSet.prototype.toArrayRec = function(t, a) {
	if (t != null) {
		this.toArrayRec(t.left, a);
		a.push(t.node);
		this.toArrayRec(t.right, a);
	}
};

XNodeSet.prototype.compareWithString = function(r, o) {
	var a = this.toArray();
	for (var i = 0; i < a.length; i++) {
		var n = a[i];
		var l = new XString(this.stringForNode(n));
		var res = o(l, r);
		if (res.booleanValue()) {
			return res;
		}
	}
	return new XBoolean(false);
};

XNodeSet.prototype.compareWithNumber = function(r, o) {
	var a = this.toArray();
	for (var i = 0; i < a.length; i++) {
		var n = a[i];
		var l = new XNumber(this.stringForNode(n));
		var res = o(l, r);
		if (res.booleanValue()) {
			return res;
		}
	}
	return new XBoolean(false);
};

XNodeSet.prototype.compareWithBoolean = function(r, o) {
	return o(this.bool(), r);
};

XNodeSet.prototype.compareWithNodeSet = function(r, o) {
	var a = this.toArray();
	for (var i = 0; i < a.length; i++) {
		var n = a[i];
		var l = new XString(this.stringForNode(n));
		var b = r.toArray();
		for (var j = 0; j < b.length; j++) {
			var n2 = b[j];
			var r = new XString(this.stringForNode(n2));
			var res = o(l, r);
			if (res.booleanValue()) {
				return res;
			}
		}
	}
	return new XBoolean(false);
};

XNodeSet.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithString(r, Operators.equals);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.equals);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.equals);
	}
	return this.compareWithNodeSet(r, Operators.equals);
};

XNodeSet.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithString(r, Operators.notequal);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.notequal);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.notequal);
	}
	return this.compareWithNodeSet(r, Operators.notequal);
};

XNodeSet.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithNumber(r.number(), Operators.lessthan);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.lessthan);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.lessthan);
	}
	return this.compareWithNodeSet(r, Operators.lessthan);
};

XNodeSet.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithNumber(r.number(), Operators.greaterthan);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.greaterthan);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.greaterthan);
	}
	return this.compareWithNodeSet(r, Operators.greaterthan);
};

XNodeSet.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithNumber(r.number(), Operators.lessthanorequal);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.lessthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.lessthanorequal);
	}
	return this.compareWithNodeSet(r, Operators.lessthanorequal);
};

XNodeSet.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithNumber(r.number(), Operators.greaterthanorequal);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.greaterthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.greaterthanorequal);
	}
	return this.compareWithNodeSet(r, Operators.greaterthanorequal);
};

XNodeSet.prototype.union = function(r) {
	var ns = new XNodeSet();
	ns.tree = this.tree;
	ns.size = this.size;
	ns.addArray(r.toArray());
	return ns;
};

// XPathNamespace ////////////////////////////////////////////////////////////

XPathNamespace.prototype = new Object();
XPathNamespace.prototype.constructor = XPathNamespace;
XPathNamespace.superclass = Object.prototype;

function XPathNamespace(pre, ns, p) {
	this.isXPathNamespace = true;
	this.ownerDocument = p.ownerDocument;
	this.nodeName = "#namespace";
	this.prefix = pre;
	this.localName = pre;
	this.namespaceURI = ns;
	this.nodeValue = ns;
	this.ownerElement = p;
	this.nodeType = XPathNamespace.XPATH_NAMESPACE_NODE;
}

XPathNamespace.prototype.toString = function() {
	return "{ \"" + this.prefix + "\", \"" + this.namespaceURI + "\" }";
};

// Operators /////////////////////////////////////////////////////////////////

var Operators = new Object();

Operators.equals = function(l, r) {
	return l.equals(r);
};

Operators.notequal = function(l, r) {
	return l.notequal(r);
};

Operators.lessthan = function(l, r) {
	return l.lessthan(r);
};

Operators.greaterthan = function(l, r) {
	return l.greaterthan(r);
};

Operators.lessthanorequal = function(l, r) {
	return l.lessthanorequal(r);
};

Operators.greaterthanorequal = function(l, r) {
	return l.greaterthanorequal(r);
};

// XPathContext //////////////////////////////////////////////////////////////

XPathContext.prototype = new Object();
XPathContext.prototype.constructor = XPathContext;
XPathContext.superclass = Object.prototype;

function XPathContext(vr, nr, fr) {
	this.variableResolver = vr != null ? vr : new VariableResolver();
	this.namespaceResolver = nr != null ? nr : new NamespaceResolver();
	this.functionResolver = fr != null ? fr : new FunctionResolver();
}

// VariableResolver //////////////////////////////////////////////////////////

VariableResolver.prototype = new Object();
VariableResolver.prototype.constructor = VariableResolver;
VariableResolver.superclass = Object.prototype;

function VariableResolver() {
}

VariableResolver.prototype.getVariable = function(vn, c) {
	var parts = Utilities.splitQName(vn);
	if (parts[0] != null) {
		parts[0] = c.namespaceResolver.getNamespace(parts[0], c.expressionContextNode);
        if (parts[0] == null) {
            throw new Error("Cannot resolve QName " + fn);
        }
	}
	return this.getVariableWithName(parts[0], parts[1], c.expressionContextNode);
};

VariableResolver.prototype.getVariableWithName = function(ns, ln, c) {
	return null;
};

// FunctionResolver //////////////////////////////////////////////////////////

FunctionResolver.prototype = new Object();
FunctionResolver.prototype.constructor = FunctionResolver;
FunctionResolver.superclass = Object.prototype;

function FunctionResolver(thisArg) {
	this.thisArg = thisArg != null ? thisArg : Functions;
	this.functions = new Object();
	this.addStandardFunctions();
}

FunctionResolver.prototype.addStandardFunctions = function() {
	this.functions["{}last"] = Functions.last;
	this.functions["{}position"] = Functions.position;
	this.functions["{}count"] = Functions.count;
	this.functions["{}id"] = Functions.id;
	this.functions["{}local-name"] = Functions.localName;
	this.functions["{}namespace-uri"] = Functions.namespaceURI;
	this.functions["{}name"] = Functions.name;
	this.functions["{}string"] = Functions.string;
	this.functions["{}concat"] = Functions.concat;
	this.functions["{}starts-with"] = Functions.startsWith;
	this.functions["{}contains"] = Functions.contains;
	this.functions["{}substring-before"] = Functions.substringBefore;
	this.functions["{}substring-after"] = Functions.substringAfter;
	this.functions["{}substring"] = Functions.substring;
	this.functions["{}string-length"] = Functions.stringLength;
	this.functions["{}normalize-space"] = Functions.normalizeSpace;
	this.functions["{}translate"] = Functions.translate;
	this.functions["{}boolean"] = Functions.boolean_;
	this.functions["{}not"] = Functions.not;
	this.functions["{}true"] = Functions.true_;
	this.functions["{}false"] = Functions.false_;
	this.functions["{}lang"] = Functions.lang;
	this.functions["{}number"] = Functions.number;
	this.functions["{}sum"] = Functions.sum;
	this.functions["{}floor"] = Functions.floor;
	this.functions["{}ceiling"] = Functions.ceiling;
	this.functions["{}round"] = Functions.round;
};

FunctionResolver.prototype.addFunction = function(ns, ln, f) {
	this.functions["{" + ns + "}" + ln] = f;
};

FunctionResolver.prototype.getFunction = function(fn, c) {
	var parts = Utilities.resolveQName(fn, c.namespaceResolver, c.contextNode, false);
    if (parts[0] == null) {
        throw new Error("Cannot resolve QName " + fn);
    }
	return this.getFunctionWithName(parts[0], parts[1], c.contextNode);
};

FunctionResolver.prototype.getFunctionWithName = function(ns, ln, c) {
	return this.functions["{" + ns + "}" + ln];
};

// NamespaceResolver /////////////////////////////////////////////////////////

NamespaceResolver.prototype = new Object();
NamespaceResolver.prototype.constructor = NamespaceResolver;
NamespaceResolver.superclass = Object.prototype;

function NamespaceResolver() {
}

NamespaceResolver.prototype.getNamespace = function(prefix, n) {
	if (prefix == "xml") {
		return XPath.XML_NAMESPACE_URI;
	} else if (prefix == "xmlns") {
		return XPath.XMLNS_NAMESPACE_URI;
	}
	if (n.nodeType == 9 /*Node.DOCUMENT_NODE*/) {
		n = n.documentElement;
	} else if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
		n = PathExpr.prototype.getOwnerElement(n);
	} else if (n.nodeType != 1 /*Node.ELEMENT_NODE*/) {
		n = n.parentNode;
	}
	while (n != null && n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
		var nnm = n.attributes;
		for (var i = 0; i < nnm.length; i++) {
			var a = nnm.item(i);
			var aname = a.nodeName;
			if (aname == "xmlns" && prefix == ""
					|| aname == "xmlns:" + prefix) {
				return String(a.nodeValue);
			}
		}
		n = n.parentNode;
	}
	return null;
};

// Functions /////////////////////////////////////////////////////////////////

Functions = new Object();

Functions.last = function() {
	var c = arguments[0];
	if (arguments.length != 1) {
		throw new Error("Function last expects ()");
	}
	return new XNumber(c.contextSize);
};

Functions.position = function() {
	var c = arguments[0];
	if (arguments.length != 1) {
		throw new Error("Function position expects ()");
	}
	return new XNumber(c.contextPosition);
};

Functions.count = function() {
	var c = arguments[0];
	var ns;
	if (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c), XNodeSet)) {
		throw new Error("Function count expects (node-set)");
	}
	return new XNumber(ns.size);
};

Functions.id = function() {
	var c = arguments[0];
	var id;
	if (arguments.length != 2) {
		throw new Error("Function id expects (object)");
	}
	id = arguments[1].evaluate(c);
	if (Utilities.instance_of(id, XNodeSet)) {
		id = id.toArray().join(" ");
	} else {
		id = id.stringValue();
	}
	var ids = id.split(/[\x0d\x0a\x09\x20]+/);
	var count = 0;
	var ns = new XNodeSet();
	var doc = c.contextNode.nodeType == 9 /*Node.DOCUMENT_NODE*/
			? c.contextNode
			: c.contextNode.ownerDocument;
	for (var i = 0; i < ids.length; i++) {
		var n;
		if (doc.getElementById) {
			n = doc.getElementById(ids[i]);
		} else {
			n = Utilities.getElementById(doc, ids[i]);
		}
		if (n != null) {
			ns.add(n);
			count++;
		}
	}
	return ns;
};

Functions.localName = function() {
	var c = arguments[0];
	var n;
	if (arguments.length == 1) {
		n = c.contextNode;
	} else if (arguments.length == 2) {
		n = arguments[1].evaluate(c).first();
	} else {
		throw new Error("Function local-name expects (node-set?)");
	}
	if (n == null) {
		return new XString("");
	}
	return new XString(n.localName ? n.localName : n.baseName);
};

Functions.namespaceURI = function() {
	var c = arguments[0];
	var n;
	if (arguments.length == 1) {
		n = c.contextNode;
	} else if (arguments.length == 2) {
		n = arguments[1].evaluate(c).first();
	} else {
		throw new Error("Function namespace-uri expects (node-set?)");
	}
	if (n == null) {
		return new XString("");
	}
	return new XString(n.namespaceURI);
};

Functions.name = function() {
	var c = arguments[0];
	var n;
	if (arguments.length == 1) {
		n = c.contextNode;
	} else if (arguments.length == 2) {
		n = arguments[1].evaluate(c).first();
	} else {
		throw new Error("Function name expects (node-set?)");
	}
	if (n == null) {
		return new XString("");
	}
	if (n.nodeType == 1 /*Node.ELEMENT_NODE*/ || n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
		return new XString(n.nodeName);
	} else if (n.localName == null) {
		return new XString("");
	} else {
		return new XString(n.localName);
	}
};

Functions.string = function() {
	var c = arguments[0];
	if (arguments.length == 1) {
		return XNodeSet.prototype.stringForNode(c.contextNode);
	} else if (arguments.length == 2) {
		return arguments[1].evaluate(c).string();
	}
	throw new Error("Function string expects (object?)");
};

Functions.concat = function() {
	var c = arguments[0];
	if (arguments.length < 3) {
		throw new Error("Function concat expects (string, string, string*)");
	}
	var s = "";
	for (var i = 1; i < arguments.length; i++) {
		s += arguments[i].evaluate(c).stringValue();
	}
	return new XString(s);
};

Functions.startsWith = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function startsWith expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	return new XBoolean(s1.substring(0, s2.length) == s2);
};

Functions.contains = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function contains expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	return new XBoolean(s1.indexOf(s2) != -1);
};

Functions.substringBefore = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function substring-before expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	return new XString(s1.substring(0, s1.indexOf(s2)));
};

Functions.substringAfter = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function substring-after expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	if (s2.length == 0) {
		return new XString(s1);
	}
	var i = s1.indexOf(s2);
	if (i == -1) {
		return new XString("");
	}
	return new XString(s1.substring(s1.indexOf(s2) + 1));
};

Functions.substring = function() {
	var c = arguments[0];
	if (!(arguments.length == 3 || arguments.length == 4)) {
		throw new Error("Function substring expects (string, number, number?)");
	}
	var s = arguments[1].evaluate(c).stringValue();
	var n1 = Math.round(arguments[2].evaluate(c).numberValue()) - 1;
	var n2 = arguments.length == 4 ? n1 + Math.round(arguments[3].evaluate(c).numberValue()) : undefined;
	return new XString(s.substring(n1, n2));
};

Functions.stringLength = function() {
	var c = arguments[0];
	var s;
	if (arguments.length == 1) {
		s = XNodeSet.prototype.stringForNode(c.contextNode);
	} else if (arguments.length == 2) {
		s = arguments[1].evaluate(c).stringValue();
	} else {
		throw new Error("Function string-length expects (string?)");
	}
	return new XNumber(s.length);
};

Functions.normalizeSpace = function() {
	var c = arguments[0];
	var s;
	if (arguments.length == 1) {
		s = XNodeSet.prototype.stringForNode(c.contextNode);
	} else if (arguments.length == 2) {
		s = arguments[1].evaluate(c).stringValue();
	} else {
		throw new Error("Function normalize-space expects (string?)");
	}
	var i = 0;
	var j = s.length - 1;
	while (Utilities.isSpace(s.charCodeAt(j))) {
		j--;
	}
	var t = "";
	while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {
		i++;
	}
	while (i <= j) {
		if (Utilities.isSpace(s.charCodeAt(i))) {
			t += " ";
			while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {
				i++;
			}
		} else {
			t += s.charAt(i);
			i++;
		}
	}
	return new XString(t);
};

Functions.translate = function() {
	var c = arguments[0];
	if (arguments.length != 4) {
		throw new Error("Function translate expects (string, string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	var s3 = arguments[3].evaluate(c).stringValue();
	var map = [];
	for (var i = 0; i < s2.length; i++) {
		var j = s2.charCodeAt(i);
		if (map[j] == undefined) {
			var k = i > s3.length ? "" : s3.charAt(i);
			map[j] = k;
		}
	}
	var t = "";
	for (var i = 0; i < s1.length; i++) {
		var c = s1.charCodeAt(i);
		var r = map[c];
		if (r == undefined) {
			t += s1.charAt(i);
		} else {
			t += r;
		}
	}
	return new XString(t);
};

Functions.boolean_ = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function boolean expects (object)");
	}
	return arguments[1].evaluate(c).bool();
};

Functions.not = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function not expects (object)");
	}
	return arguments[1].evaluate(c).bool().not();
};

Functions.true_ = function() {
	if (arguments.length != 1) {
		throw new Error("Function true expects ()");
	}
	return new XBoolean(true);
};

Functions.false_ = function() {
	if (arguments.length != 1) {
		throw new Error("Function false expects ()");
	}
	return new XBoolean(false);
};

Functions.lang = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function lang expects (string)");
	}
	var lang;
	for (var n = c.contextNode; n != null && n.nodeType != 9 /*Node.DOCUMENT_NODE*/; n = n.parentNode) {
		var a = n.getAttributeNS(XPath.XML_NAMESPACE_URI, "lang");
		if (a != null) {
			lang = String(a);
			break;
		}
	}
	if (lang == null) {
		return new XBoolean(false);
	}
	var s = arguments[1].evaluate(c).stringValue();
	return new XBoolean(lang.substring(0, s.length) == s
				&& (lang.length == s.length || lang.charAt(s.length) == '-'));
};

Functions.number = function() {
	var c = arguments[0];
	if (!(arguments.length == 1 || arguments.length == 2)) {
		throw new Error("Function number expects (object?)");
	}
	if (arguments.length == 1) {
		return new XNumber(XNodeSet.prototype.stringForNode(c.contextNode));
	}
	return arguments[1].evaluate(c).number();
};

Functions.sum = function() {
	var c = arguments[0];
	var ns;
	if (arguments.length != 2 || !Utilities.instance_of((ns = arguments[1].evaluate(c)), XNodeSet)) {
		throw new Error("Function sum expects (node-set)");
	}
	ns = ns.toArray();
	var n = 0;
	for (var i = 0; i < ns.length; i++) {
		n += new XNumber(XNodeSet.prototype.stringForNode(ns[i])).numberValue();
	}
	return new XNumber(n);
};

Functions.floor = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function floor expects (number)");
	}
	return new XNumber(Math.floor(arguments[1].evaluate(c).numberValue()));
};

Functions.ceiling = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function ceiling expects (number)");
	}
	return new XNumber(Math.ceil(arguments[1].evaluate(c).numberValue()));
};

Functions.round = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function round expects (number)");
	}
	return new XNumber(Math.round(arguments[1].evaluate(c).numberValue()));
};

// Utilities /////////////////////////////////////////////////////////////////

Utilities = new Object();

Utilities.splitQName = function(qn) {
	var i = qn.indexOf(":");
	if (i == -1) {
		return [ null, qn ];
	}
	return [ qn.substring(0, i), qn.substring(i + 1) ];
};

Utilities.resolveQName = function(qn, nr, n, useDefault) {
	var parts = Utilities.splitQName(qn);
	if (parts[0] != null) {
		parts[0] = nr.getNamespace(parts[0], n);
	} else {
		if (useDefault) {
			parts[0] = nr.getNamespace("", n);
			if (parts[0] == null) {
				parts[0] = "";
			}
		} else {
			parts[0] = "";
		}
	}
	return parts;
};

Utilities.isSpace = function(c) {
	return c == 0x9 || c == 0xd || c == 0xa || c == 0x20;
};

Utilities.isLetter = function(c) {
	return c >= 0x0041 && c <= 0x005A ||
		c >= 0x0061 && c <= 0x007A ||
		c >= 0x00C0 && c <= 0x00D6 ||
		c >= 0x00D8 && c <= 0x00F6 ||
		c >= 0x00F8 && c <= 0x00FF ||
		c >= 0x0100 && c <= 0x0131 ||
		c >= 0x0134 && c <= 0x013E ||
		c >= 0x0141 && c <= 0x0148 ||
		c >= 0x014A && c <= 0x017E ||
		c >= 0x0180 && c <= 0x01C3 ||
		c >= 0x01CD && c <= 0x01F0 ||
		c >= 0x01F4 && c <= 0x01F5 ||
		c >= 0x01FA && c <= 0x0217 ||
		c >= 0x0250 && c <= 0x02A8 ||
		c >= 0x02BB && c <= 0x02C1 ||
		c == 0x0386 ||
		c >= 0x0388 && c <= 0x038A ||
		c == 0x038C ||
		c >= 0x038E && c <= 0x03A1 ||
		c >= 0x03A3 && c <= 0x03CE ||
		c >= 0x03D0 && c <= 0x03D6 ||
		c == 0x03DA ||
		c == 0x03DC ||
		c == 0x03DE ||
		c == 0x03E0 ||
		c >= 0x03E2 && c <= 0x03F3 ||
		c >= 0x0401 && c <= 0x040C ||
		c >= 0x040E && c <= 0x044F ||
		c >= 0x0451 && c <= 0x045C ||
		c >= 0x045E && c <= 0x0481 ||
		c >= 0x0490 && c <= 0x04C4 ||
		c >= 0x04C7 && c <= 0x04C8 ||
		c >= 0x04CB && c <= 0x04CC ||
		c >= 0x04D0 && c <= 0x04EB ||
		c >= 0x04EE && c <= 0x04F5 ||
		c >= 0x04F8 && c <= 0x04F9 ||
		c >= 0x0531 && c <= 0x0556 ||
		c == 0x0559 ||
		c >= 0x0561 && c <= 0x0586 ||
		c >= 0x05D0 && c <= 0x05EA ||
		c >= 0x05F0 && c <= 0x05F2 ||
		c >= 0x0621 && c <= 0x063A ||
		c >= 0x0641 && c <= 0x064A ||
		c >= 0x0671 && c <= 0x06B7 ||
		c >= 0x06BA && c <= 0x06BE ||
		c >= 0x06C0 && c <= 0x06CE ||
		c >= 0x06D0 && c <= 0x06D3 ||
		c == 0x06D5 ||
		c >= 0x06E5 && c <= 0x06E6 ||
		c >= 0x0905 && c <= 0x0939 ||
		c == 0x093D ||
		c >= 0x0958 && c <= 0x0961 ||
		c >= 0x0985 && c <= 0x098C ||
		c >= 0x098F && c <= 0x0990 ||
		c >= 0x0993 && c <= 0x09A8 ||
		c >= 0x09AA && c <= 0x09B0 ||
		c == 0x09B2 ||
		c >= 0x09B6 && c <= 0x09B9 ||
		c >= 0x09DC && c <= 0x09DD ||
		c >= 0x09DF && c <= 0x09E1 ||
		c >= 0x09F0 && c <= 0x09F1 ||
		c >= 0x0A05 && c <= 0x0A0A ||
		c >= 0x0A0F && c <= 0x0A10 ||
		c >= 0x0A13 && c <= 0x0A28 ||
		c >= 0x0A2A && c <= 0x0A30 ||
		c >= 0x0A32 && c <= 0x0A33 ||
		c >= 0x0A35 && c <= 0x0A36 ||
		c >= 0x0A38 && c <= 0x0A39 ||
		c >= 0x0A59 && c <= 0x0A5C ||
		c == 0x0A5E ||
		c >= 0x0A72 && c <= 0x0A74 ||
		c >= 0x0A85 && c <= 0x0A8B ||
		c == 0x0A8D ||
		c >= 0x0A8F && c <= 0x0A91 ||
		c >= 0x0A93 && c <= 0x0AA8 ||
		c >= 0x0AAA && c <= 0x0AB0 ||
		c >= 0x0AB2 && c <= 0x0AB3 ||
		c >= 0x0AB5 && c <= 0x0AB9 ||
		c == 0x0ABD ||
		c == 0x0AE0 ||
		c >= 0x0B05 && c <= 0x0B0C ||
		c >= 0x0B0F && c <= 0x0B10 ||
		c >= 0x0B13 && c <= 0x0B28 ||
		c >= 0x0B2A && c <= 0x0B30 ||
		c >= 0x0B32 && c <= 0x0B33 ||
		c >= 0x0B36 && c <= 0x0B39 ||
		c == 0x0B3D ||
		c >= 0x0B5C && c <= 0x0B5D ||
		c >= 0x0B5F && c <= 0x0B61 ||
		c >= 0x0B85 && c <= 0x0B8A ||
		c >= 0x0B8E && c <= 0x0B90 ||
		c >= 0x0B92 && c <= 0x0B95 ||
		c >= 0x0B99 && c <= 0x0B9A ||
		c == 0x0B9C ||
		c >= 0x0B9E && c <= 0x0B9F ||
		c >= 0x0BA3 && c <= 0x0BA4 ||
		c >= 0x0BA8 && c <= 0x0BAA ||
		c >= 0x0BAE && c <= 0x0BB5 ||
		c >= 0x0BB7 && c <= 0x0BB9 ||
		c >= 0x0C05 && c <= 0x0C0C ||
		c >= 0x0C0E && c <= 0x0C10 ||
		c >= 0x0C12 && c <= 0x0C28 ||
		c >= 0x0C2A && c <= 0x0C33 ||
		c >= 0x0C35 && c <= 0x0C39 ||
		c >= 0x0C60 && c <= 0x0C61 ||
		c >= 0x0C85 && c <= 0x0C8C ||
		c >= 0x0C8E && c <= 0x0C90 ||
		c >= 0x0C92 && c <= 0x0CA8 ||
		c >= 0x0CAA && c <= 0x0CB3 ||
		c >= 0x0CB5 && c <= 0x0CB9 ||
		c == 0x0CDE ||
		c >= 0x0CE0 && c <= 0x0CE1 ||
		c >= 0x0D05 && c <= 0x0D0C ||
		c >= 0x0D0E && c <= 0x0D10 ||
		c >= 0x0D12 && c <= 0x0D28 ||
		c >= 0x0D2A && c <= 0x0D39 ||
		c >= 0x0D60 && c <= 0x0D61 ||
		c >= 0x0E01 && c <= 0x0E2E ||
		c == 0x0E30 ||
		c >= 0x0E32 && c <= 0x0E33 ||
		c >= 0x0E40 && c <= 0x0E45 ||
		c >= 0x0E81 && c <= 0x0E82 ||
		c == 0x0E84 ||
		c >= 0x0E87 && c <= 0x0E88 ||
		c == 0x0E8A ||
		c == 0x0E8D ||
		c >= 0x0E94 && c <= 0x0E97 ||
		c >= 0x0E99 && c <= 0x0E9F ||
		c >= 0x0EA1 && c <= 0x0EA3 ||
		c == 0x0EA5 ||
		c == 0x0EA7 ||
		c >= 0x0EAA && c <= 0x0EAB ||
		c >= 0x0EAD && c <= 0x0EAE ||
		c == 0x0EB0 ||
		c >= 0x0EB2 && c <= 0x0EB3 ||
		c == 0x0EBD ||
		c >= 0x0EC0 && c <= 0x0EC4 ||
		c >= 0x0F40 && c <= 0x0F47 ||
		c >= 0x0F49 && c <= 0x0F69 ||
		c >= 0x10A0 && c <= 0x10C5 ||
		c >= 0x10D0 && c <= 0x10F6 ||
		c == 0x1100 ||
		c >= 0x1102 && c <= 0x1103 ||
		c >= 0x1105 && c <= 0x1107 ||
		c == 0x1109 ||
		c >= 0x110B && c <= 0x110C ||
		c >= 0x110E && c <= 0x1112 ||
		c == 0x113C ||
		c == 0x113E ||
		c == 0x1140 ||
		c == 0x114C ||
		c == 0x114E ||
		c == 0x1150 ||
		c >= 0x1154 && c <= 0x1155 ||
		c == 0x1159 ||
		c >= 0x115F && c <= 0x1161 ||
		c == 0x1163 ||
		c == 0x1165 ||
		c == 0x1167 ||
		c == 0x1169 ||
		c >= 0x116D && c <= 0x116E ||
		c >= 0x1172 && c <= 0x1173 ||
		c == 0x1175 ||
		c == 0x119E ||
		c == 0x11A8 ||
		c == 0x11AB ||
		c >= 0x11AE && c <= 0x11AF ||
		c >= 0x11B7 && c <= 0x11B8 ||
		c == 0x11BA ||
		c >= 0x11BC && c <= 0x11C2 ||
		c == 0x11EB ||
		c == 0x11F0 ||
		c == 0x11F9 ||
		c >= 0x1E00 && c <= 0x1E9B ||
		c >= 0x1EA0 && c <= 0x1EF9 ||
		c >= 0x1F00 && c <= 0x1F15 ||
		c >= 0x1F18 && c <= 0x1F1D ||
		c >= 0x1F20 && c <= 0x1F45 ||
		c >= 0x1F48 && c <= 0x1F4D ||
		c >= 0x1F50 && c <= 0x1F57 ||
		c == 0x1F59 ||
		c == 0x1F5B ||
		c == 0x1F5D ||
		c >= 0x1F5F && c <= 0x1F7D ||
		c >= 0x1F80 && c <= 0x1FB4 ||
		c >= 0x1FB6 && c <= 0x1FBC ||
		c == 0x1FBE ||
		c >= 0x1FC2 && c <= 0x1FC4 ||
		c >= 0x1FC6 && c <= 0x1FCC ||
		c >= 0x1FD0 && c <= 0x1FD3 ||
		c >= 0x1FD6 && c <= 0x1FDB ||
		c >= 0x1FE0 && c <= 0x1FEC ||
		c >= 0x1FF2 && c <= 0x1FF4 ||
		c >= 0x1FF6 && c <= 0x1FFC ||
		c == 0x2126 ||
		c >= 0x212A && c <= 0x212B ||
		c == 0x212E ||
		c >= 0x2180 && c <= 0x2182 ||
		c >= 0x3041 && c <= 0x3094 ||
		c >= 0x30A1 && c <= 0x30FA ||
		c >= 0x3105 && c <= 0x312C ||
		c >= 0xAC00 && c <= 0xD7A3 ||
		c >= 0x4E00 && c <= 0x9FA5 ||
		c == 0x3007 ||
		c >= 0x3021 && c <= 0x3029;
};

Utilities.isNCNameChar = function(c) {
	return c >= 0x0030 && c <= 0x0039
		|| c >= 0x0660 && c <= 0x0669
		|| c >= 0x06F0 && c <= 0x06F9
		|| c >= 0x0966 && c <= 0x096F
		|| c >= 0x09E6 && c <= 0x09EF
		|| c >= 0x0A66 && c <= 0x0A6F
		|| c >= 0x0AE6 && c <= 0x0AEF
		|| c >= 0x0B66 && c <= 0x0B6F
		|| c >= 0x0BE7 && c <= 0x0BEF
		|| c >= 0x0C66 && c <= 0x0C6F
		|| c >= 0x0CE6 && c <= 0x0CEF
		|| c >= 0x0D66 && c <= 0x0D6F
		|| c >= 0x0E50 && c <= 0x0E59
		|| c >= 0x0ED0 && c <= 0x0ED9
		|| c >= 0x0F20 && c <= 0x0F29
		|| c == 0x002E
		|| c == 0x002D
		|| c == 0x005F
		|| Utilities.isLetter(c)
		|| c >= 0x0300 && c <= 0x0345
		|| c >= 0x0360 && c <= 0x0361
		|| c >= 0x0483 && c <= 0x0486
		|| c >= 0x0591 && c <= 0x05A1
		|| c >= 0x05A3 && c <= 0x05B9
		|| c >= 0x05BB && c <= 0x05BD
		|| c == 0x05BF
		|| c >= 0x05C1 && c <= 0x05C2
		|| c == 0x05C4
		|| c >= 0x064B && c <= 0x0652
		|| c == 0x0670
		|| c >= 0x06D6 && c <= 0x06DC
		|| c >= 0x06DD && c <= 0x06DF
		|| c >= 0x06E0 && c <= 0x06E4
		|| c >= 0x06E7 && c <= 0x06E8
		|| c >= 0x06EA && c <= 0x06ED
		|| c >= 0x0901 && c <= 0x0903
		|| c == 0x093C
		|| c >= 0x093E && c <= 0x094C
		|| c == 0x094D
		|| c >= 0x0951 && c <= 0x0954
		|| c >= 0x0962 && c <= 0x0963
		|| c >= 0x0981 && c <= 0x0983
		|| c == 0x09BC
		|| c == 0x09BE
		|| c == 0x09BF
		|| c >= 0x09C0 && c <= 0x09C4
		|| c >= 0x09C7 && c <= 0x09C8
		|| c >= 0x09CB && c <= 0x09CD
		|| c == 0x09D7
		|| c >= 0x09E2 && c <= 0x09E3
		|| c == 0x0A02
		|| c == 0x0A3C
		|| c == 0x0A3E
		|| c == 0x0A3F
		|| c >= 0x0A40 && c <= 0x0A42
		|| c >= 0x0A47 && c <= 0x0A48
		|| c >= 0x0A4B && c <= 0x0A4D
		|| c >= 0x0A70 && c <= 0x0A71
		|| c >= 0x0A81 && c <= 0x0A83
		|| c == 0x0ABC
		|| c >= 0x0ABE && c <= 0x0AC5
		|| c >= 0x0AC7 && c <= 0x0AC9
		|| c >= 0x0ACB && c <= 0x0ACD
		|| c >= 0x0B01 && c <= 0x0B03
		|| c == 0x0B3C
		|| c >= 0x0B3E && c <= 0x0B43
		|| c >= 0x0B47 && c <= 0x0B48
		|| c >= 0x0B4B && c <= 0x0B4D
		|| c >= 0x0B56 && c <= 0x0B57
		|| c >= 0x0B82 && c <= 0x0B83
		|| c >= 0x0BBE && c <= 0x0BC2
		|| c >= 0x0BC6 && c <= 0x0BC8
		|| c >= 0x0BCA && c <= 0x0BCD
		|| c == 0x0BD7
		|| c >= 0x0C01 && c <= 0x0C03
		|| c >= 0x0C3E && c <= 0x0C44
		|| c >= 0x0C46 && c <= 0x0C48
		|| c >= 0x0C4A && c <= 0x0C4D
		|| c >= 0x0C55 && c <= 0x0C56
		|| c >= 0x0C82 && c <= 0x0C83
		|| c >= 0x0CBE && c <= 0x0CC4
		|| c >= 0x0CC6 && c <= 0x0CC8
		|| c >= 0x0CCA && c <= 0x0CCD
		|| c >= 0x0CD5 && c <= 0x0CD6
		|| c >= 0x0D02 && c <= 0x0D03
		|| c >= 0x0D3E && c <= 0x0D43
		|| c >= 0x0D46 && c <= 0x0D48
		|| c >= 0x0D4A && c <= 0x0D4D
		|| c == 0x0D57
		|| c == 0x0E31
		|| c >= 0x0E34 && c <= 0x0E3A
		|| c >= 0x0E47 && c <= 0x0E4E
		|| c == 0x0EB1
		|| c >= 0x0EB4 && c <= 0x0EB9
		|| c >= 0x0EBB && c <= 0x0EBC
		|| c >= 0x0EC8 && c <= 0x0ECD
		|| c >= 0x0F18 && c <= 0x0F19
		|| c == 0x0F35
		|| c == 0x0F37
		|| c == 0x0F39
		|| c == 0x0F3E
		|| c == 0x0F3F
		|| c >= 0x0F71 && c <= 0x0F84
		|| c >= 0x0F86 && c <= 0x0F8B
		|| c >= 0x0F90 && c <= 0x0F95
		|| c == 0x0F97
		|| c >= 0x0F99 && c <= 0x0FAD
		|| c >= 0x0FB1 && c <= 0x0FB7
		|| c == 0x0FB9
		|| c >= 0x20D0 && c <= 0x20DC
		|| c == 0x20E1
		|| c >= 0x302A && c <= 0x302F
		|| c == 0x3099
		|| c == 0x309A
		|| c == 0x00B7
		|| c == 0x02D0
		|| c == 0x02D1
		|| c == 0x0387
		|| c == 0x0640
		|| c == 0x0E46
		|| c == 0x0EC6
		|| c == 0x3005
		|| c >= 0x3031 && c <= 0x3035
		|| c >= 0x309D && c <= 0x309E
		|| c >= 0x30FC && c <= 0x30FE;
};

Utilities.coalesceText = function(n) {
	for (var m = n.firstChild; m != null; m = m.nextSibling) {
		if (m.nodeType == 3 /*Node.TEXT_NODE*/ || m.nodeType == 4 /*Node.CDATA_SECTION_NODE*/) {
			var s = m.nodeValue;
			var first = m;
			m = m.nextSibling;
			while (m != null && (m.nodeType == 3 /*Node.TEXT_NODE*/ || m.nodeType == 4 /*Node.CDATA_SECTION_NODE*/)) {
				s += m.nodeValue;
				var del = m;
				m = m.nextSibling;
				del.parentNode.removeChild(del);
			}
			if (first.nodeType == 4 /*Node.CDATA_SECTION_NODE*/) {
				var p = first.parentNode;
				if (first.nextSibling == null) {
					p.removeChild(first);
					p.appendChild(p.ownerDocument.createTextNode(s));
				} else {
					var next = first.nextSibling;
					p.removeChild(first);
					p.insertBefore(p.ownerDocument.createTextNode(s), next);
				}
			} else {
				first.nodeValue = s;
			}
			if (m == null) {
				break;
			}
		} else if (m.nodeType == 1 /*Node.ELEMENT_NODE*/) {
			Utilities.coalesceText(m);
		}
	}
};

Utilities.instance_of = function(o, c) {
	while (o != null) {
		if (o.constructor === c) {
			return true;
		}
		if (o === Object) {
			return false;
		}
		o = o.constructor.superclass;
	}
	return false;
};

Utilities.getElementById = function(n, id) {
	// Note that this does not check the DTD to check for actual
	// attributes of type ID, so this may be a bit wrong.
	if (n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
		if (n.getAttribute("id") == id
				|| n.getAttributeNS(null, "id") == id) {
			return n;
		}
	}
	for (var m = n.firstChild; m != null; m = m.nextSibling) {
		var res = Utilities.getElementById(m, id);
		if (res != null) {
			return res;
		}
	}
	return null;
};

// XPathException ////////////////////////////////////////////////////////////

XPathException.prototype = {};
XPathException.prototype.constructor = XPathException;
XPathException.superclass = Object.prototype;

function XPathException(c, e) {
	this.code = c;
	this.exception = e;
}

XPathException.prototype.toString = function() {
	var msg = this.exception ? ": " + this.exception.toString() : "";
	switch (this.code) {
		case XPathException.INVALID_EXPRESSION_ERR:
			return "Invalid expression" + msg;
		case XPathException.TYPE_ERR:
			return "Type error" + msg;
	}
};

XPathException.INVALID_EXPRESSION_ERR = 51;
XPathException.TYPE_ERR = 52;

// XPathExpression ///////////////////////////////////////////////////////////

XPathExpression.prototype = {};
XPathExpression.prototype.constructor = XPathExpression;
XPathExpression.superclass = Object.prototype;

function XPathExpression(e, r, p) {
	this.xpath = p.parse(e);
	this.context = new XPathContext();
	this.context.namespaceResolver = new XPathNSResolverWrapper(r);
}

XPathExpression.prototype.evaluate = function(n, t, res) {
	this.context.expressionContextNode = n;
	var result = this.xpath.evaluate(this.context);
	return new XPathResult(result, t);
}

// XPathNSResolverWrapper ////////////////////////////////////////////////////

XPathNSResolverWrapper.prototype = {};
XPathNSResolverWrapper.prototype.constructor = XPathNSResolverWrapper;
XPathNSResolverWrapper.superclass = Object.prototype;

function XPathNSResolverWrapper(r) {
	this.xpathNSResolver = r;
}

XPathNSResolverWrapper.prototype.getNamespace = function(prefix, n) {
    if (this.xpathNSResolver == null) {
        return null;
    }
	return this.xpathNSResolver.lookupNamespaceURI(prefix);
};

// NodeXPathNSResolver ///////////////////////////////////////////////////////

NodeXPathNSResolver.prototype = {};
NodeXPathNSResolver.prototype.constructor = NodeXPathNSResolver;
NodeXPathNSResolver.superclass = Object.prototype;

function NodeXPathNSResolver(n) {
	this.node = n;
	this.namespaceResolver = new NamespaceResolver();
}

NodeXPathNSResolver.prototype.lookupNamespaceURI = function(prefix) {
	return this.namespaceResolver.getNamespace(prefix, this.node);
};

// XPathResult ///////////////////////////////////////////////////////////////

XPathResult.prototype = {};
XPathResult.prototype.constructor = XPathResult;
XPathResult.superclass = Object.prototype;

function XPathResult(v, t) {
	if (t == XPathResult.ANY_TYPE) {
		if (v.constructor === XString) {
			t = XPathResult.STRING_TYPE;
		} else if (v.constructor === XNumber) {
			t = XPathResult.NUMBER_TYPE;
		} else if (v.constructor === XBoolean) {
			t = XPathResult.BOOLEAN_TYPE;
		} else if (v.constructor === XNodeSet) {
			t = XPathResult.UNORDERED_NODE_ITERATOR_TYPE;
		}
	}
	this.resultType = t;
	switch (t) {
		case XPathResult.NUMBER_TYPE:
			this.numberValue = v.numberValue();
			return;
		case XPathResult.STRING_TYPE:
			this.stringValue = v.stringValue();
			return;
		case XPathResult.BOOLEAN_TYPE:
			this.booleanValue = v.booleanValue();
			return;
		case XPathResult.ANY_UNORDERED_NODE_TYPE:
		case XPathResult.FIRST_ORDERED_NODE_TYPE:
			if (v.constructor === XNodeSet) {
				this.singleNodeValue = v.first();
				return;
			}
			break;
		case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
		case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
			if (v.constructor === XNodeSet) {
				this.invalidIteratorState = false;
				this.nodes = v.toArray();
				this.iteratorIndex = 0;
				return;
			}
			break;
		case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
		case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
			if (v.constructor === XNodeSet) {
				this.nodes = v.toArray();
				this.snapshotLength = this.nodes.length;
				return;
			}
			break;
	}
	throw new XPathException(XPathException.TYPE_ERR);
};

XPathResult.prototype.iterateNext = function() {
	if (this.resultType != XPathResult.UNORDERED_NODE_ITERATOR_TYPE
			&& this.resultType != XPathResult.ORDERED_NODE_ITERATOR_TYPE) {
		throw new XPathException(XPathException.TYPE_ERR);
	}
	return this.nodes[this.iteratorIndex++];
};

XPathResult.prototype.snapshotItem = function(i) {
	if (this.resultType != XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE
			&& this.resultType != XPathResult.ORDERED_NODE_SNAPSHOT_TYPE) {
		throw new XPathException(XPathException.TYPE_ERR);
	}
	return this.nodes[i];
};

XPathResult.ANY_TYPE = 0;
XPathResult.NUMBER_TYPE = 1;
XPathResult.STRING_TYPE = 2;
XPathResult.BOOLEAN_TYPE = 3;
XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
XPathResult.FIRST_ORDERED_NODE_TYPE = 9;

// DOM 3 XPath support ///////////////////////////////////////////////////////

function installDOM3XPathSupport(doc, p) {
	doc.createExpression = function(e, r) {
		try {
			return new XPathExpression(e, r, p);
		} catch (e) {
			throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, e);
		}
	};
	doc.createNSResolver = function(n) {
		return new NodeXPathNSResolver(n);
	};
	doc.evaluate = function(e, cn, r, t, res) {
		if (t < 0 || t > 9) {
			throw { code: 0, toString: function() { return "Request type not supported"; } };
		}
        return doc.createExpression(e, r, p).evaluate(cn, t, res);
	};
};

// ---------------------------------------------------------------------------

// Install DOM 3 XPath support for the current document.
try {
	var shouldInstall = true;
	try {
		if (document.implementation
				&& document.implementation.hasFeature
				&& document.implementation.hasFeature("XPath", null)) {
			shouldInstall = false;
		}
	} catch (e) {
	}
	if (shouldInstall) {
		installDOM3XPathSupport(document, new XPathParser());
	}
} catch (e) {
}

// ---------------------------------------------------------------------------
// exports for node.js

installDOM3XPathSupport(exports, new XPathParser());

exports.XPathResult = XPathResult;

// helper
exports.select = function(e, doc, single) {
	return exports.selectWithResolver(e, doc, null, single);
};

exports.useNamespaces = function(mappings) {
	var resolver = {
		mappings: mappings || {},
		lookupNamespaceURI: function(prefix) {
			return this.mappings[prefix];
		}
	};

	return function(e, doc, single) {
		return exports.selectWithResolver(e, doc, resolver, single);
	};
};

exports.selectWithResolver = function(e, doc, resolver, single) {
	var expression = new XPathExpression(e, resolver, new XPathParser());
	var type = XPathResult.ANY_TYPE;

	var result = expression.evaluate(doc, type, null);

	if (result.resultType == XPathResult.STRING_TYPE) {
		result = result.stringValue;
	}
	else if (result.resultType == XPathResult.NUMBER_TYPE) {
		result = result.numberValue;
	}
	else if (result.resultType == XPathResult.BOOLEAN_TYPE) {
		result = result.booleanValue;
	}
	else {
		result = result.nodes;
		if (single) {
			result = result[0];
		}
	}

	return result;
};

exports.select1 = function(e, doc) {
	return exports.select(e, doc, true);
};

// end non-node wrapper
})(typeof exports !== 'undefined' ? exports : xpath);

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/events/events.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/flux/index.js":[function(require,module,exports){
/**
 * Copyright (c) 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

module.exports.Dispatcher = require('./lib/Dispatcher');

},{"./lib/Dispatcher":"/Users/Jacob/workspace/scheduler/front-end/node_modules/flux/lib/Dispatcher.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/flux/lib/Dispatcher.js":[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Dispatcher
 * 
 * @preventMunge
 */

'use strict';

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var invariant = require('fbjs/lib/invariant');

var _prefix = 'ID_';

/**
 * Dispatcher is used to broadcast payloads to registered callbacks. This is
 * different from generic pub-sub systems in two ways:
 *
 *   1) Callbacks are not subscribed to particular events. Every payload is
 *      dispatched to every registered callback.
 *   2) Callbacks can be deferred in whole or part until other callbacks have
 *      been executed.
 *
 * For example, consider this hypothetical flight destination form, which
 * selects a default city when a country is selected:
 *
 *   var flightDispatcher = new Dispatcher();
 *
 *   // Keeps track of which country is selected
 *   var CountryStore = {country: null};
 *
 *   // Keeps track of which city is selected
 *   var CityStore = {city: null};
 *
 *   // Keeps track of the base flight price of the selected city
 *   var FlightPriceStore = {price: null}
 *
 * When a user changes the selected city, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'city-update',
 *     selectedCity: 'paris'
 *   });
 *
 * This payload is digested by `CityStore`:
 *
 *   flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'city-update') {
 *       CityStore.city = payload.selectedCity;
 *     }
 *   });
 *
 * When the user selects a country, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'country-update',
 *     selectedCountry: 'australia'
 *   });
 *
 * This payload is digested by both stores:
 *
 *   CountryStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       CountryStore.country = payload.selectedCountry;
 *     }
 *   });
 *
 * When the callback to update `CountryStore` is registered, we save a reference
 * to the returned token. Using this token with `waitFor()`, we can guarantee
 * that `CountryStore` is updated before the callback that updates `CityStore`
 * needs to query its data.
 *
 *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       // `CountryStore.country` may not be updated.
 *       flightDispatcher.waitFor([CountryStore.dispatchToken]);
 *       // `CountryStore.country` is now guaranteed to be updated.
 *
 *       // Select the default city for the new country
 *       CityStore.city = getDefaultCityForCountry(CountryStore.country);
 *     }
 *   });
 *
 * The usage of `waitFor()` can be chained, for example:
 *
 *   FlightPriceStore.dispatchToken =
 *     flightDispatcher.register(function(payload) {
 *       switch (payload.actionType) {
 *         case 'country-update':
 *         case 'city-update':
 *           flightDispatcher.waitFor([CityStore.dispatchToken]);
 *           FlightPriceStore.price =
 *             getFlightPriceStore(CountryStore.country, CityStore.city);
 *           break;
 *     }
 *   });
 *
 * The `country-update` payload will be guaranteed to invoke the stores'
 * registered callbacks in order: `CountryStore`, `CityStore`, then
 * `FlightPriceStore`.
 */

var Dispatcher = (function () {
  function Dispatcher() {
    _classCallCheck(this, Dispatcher);

    this._callbacks = {};
    this._isDispatching = false;
    this._isHandled = {};
    this._isPending = {};
    this._lastID = 1;
  }

  /**
   * Registers a callback to be invoked with every dispatched payload. Returns
   * a token that can be used with `waitFor()`.
   */

  Dispatcher.prototype.register = function register(callback) {
    var id = _prefix + this._lastID++;
    this._callbacks[id] = callback;
    return id;
  };

  /**
   * Removes a callback based on its token.
   */

  Dispatcher.prototype.unregister = function unregister(id) {
    !this._callbacks[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.unregister(...): `%s` does not map to a registered callback.', id) : invariant(false) : undefined;
    delete this._callbacks[id];
  };

  /**
   * Waits for the callbacks specified to be invoked before continuing execution
   * of the current callback. This method should only be used by a callback in
   * response to a dispatched payload.
   */

  Dispatcher.prototype.waitFor = function waitFor(ids) {
    !this._isDispatching ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): Must be invoked while dispatching.') : invariant(false) : undefined;
    for (var ii = 0; ii < ids.length; ii++) {
      var id = ids[ii];
      if (this._isPending[id]) {
        !this._isHandled[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): Circular dependency detected while ' + 'waiting for `%s`.', id) : invariant(false) : undefined;
        continue;
      }
      !this._callbacks[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): `%s` does not map to a registered callback.', id) : invariant(false) : undefined;
      this._invokeCallback(id);
    }
  };

  /**
   * Dispatches a payload to all registered callbacks.
   */

  Dispatcher.prototype.dispatch = function dispatch(payload) {
    !!this._isDispatching ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.') : invariant(false) : undefined;
    this._startDispatching(payload);
    try {
      for (var id in this._callbacks) {
        if (this._isPending[id]) {
          continue;
        }
        this._invokeCallback(id);
      }
    } finally {
      this._stopDispatching();
    }
  };

  /**
   * Is this Dispatcher currently dispatching.
   */

  Dispatcher.prototype.isDispatching = function isDispatching() {
    return this._isDispatching;
  };

  /**
   * Call the callback stored with the given id. Also do some internal
   * bookkeeping.
   *
   * @internal
   */

  Dispatcher.prototype._invokeCallback = function _invokeCallback(id) {
    this._isPending[id] = true;
    this._callbacks[id](this._pendingPayload);
    this._isHandled[id] = true;
  };

  /**
   * Set up bookkeeping needed when dispatching.
   *
   * @internal
   */

  Dispatcher.prototype._startDispatching = function _startDispatching(payload) {
    for (var id in this._callbacks) {
      this._isPending[id] = false;
      this._isHandled[id] = false;
    }
    this._pendingPayload = payload;
    this._isDispatching = true;
  };

  /**
   * Clear bookkeeping used for dispatching.
   *
   * @internal
   */

  Dispatcher.prototype._stopDispatching = function _stopDispatching() {
    delete this._pendingPayload;
    this._isDispatching = false;
  };

  return Dispatcher;
})();

module.exports = Dispatcher;
}).call(this,require('_process'))

},{"_process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js","fbjs/lib/invariant":"/Users/Jacob/workspace/scheduler/front-end/node_modules/flux/node_modules/fbjs/lib/invariant.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/flux/node_modules/fbjs/lib/invariant.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

"use strict";

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function (condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error('Invariant Violation: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;
}).call(this,require('_process'))

},{"_process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/node-calendar/node-calendar.js":[function(require,module,exports){
/*!
 * node-calendar
 * Copyright(c) 2013 Armin Tamzarian <tamzarian1989@gmail.com>
 * MIT Licensed
 */

(function() {

    var _DAYS_IN_MONTH = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var _DAYS_BEFORE_MONTH = [-1, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];

    try {
      var cldr = require("cldr");
    }
    catch(err) {
      cldr = false;
    }

    /**
     * Adjust the provided weekday index from the Javascript index scheme
     * (SUN=0, MON=1, ...) to the Python scheme (MON=0, TUE=1, ...)
     *
     * @api private
     */
    function _adjustWeekday(weekday) {
      return weekday > 0 ? weekday - 1 : 6
    };

    /**
     * Extracts the wide or abbreviated day names for a specified locale.
     * If cldr is not installed values default to that for locale en_US.
     *
     * @param {Boolean} abbr
     * @param {String} locale
     * @api private
     */
    function _extractLocaleDays(abbr, locale) {
      short = typeof(abbr) === "undefined" ? false : abbr;

      if(abbr) {
        return cldr ? cldr.extractDayNames(locale).format.abbreviated : ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
      }
      else {
        return cldr ? cldr.extractDayNames(locale).format.wide : ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
      }
    };

    /**
     * Extracts the wide or abbreviated month names for a specified locale.
     * If cldr is not installed values default to that for locale en_US.
     *
     * @param {Boolean} abbr
     * @param {String} locale
     * @api private
     */
    function _extractLocaleMonths(abbr, locale) {
      short = typeof(abbr) === "undefined" ? false : abbr;

      var months = []
      if(abbr) {
        months = cldr ? cldr.extractMonthNames(locale).format.abbreviated : ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      }
      else {
        months = cldr ? cldr.extractMonthNames(locale).format.wide : ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
      }

      months.unshift('');
      return months;
    };

    /**
     * Calculates the ordinal time from given year, month, day values.
     *
     * @param {Number} year
     * @param {Number} month
     * @param {Number} day
     * @api private
     */
    function _toordinal(year, month, day) {
      var days_before_year = ((year - 1) * 365) + Math.floor((year - 1) / 4) - Math.floor((year - 1) / 100) + Math.floor((year - 1) / 400);
      var days_before_month = _DAYS_BEFORE_MONTH[month] + (month > 2 && isleap(year) ? 1 : 0);
      return (days_before_year + days_before_month + day);
    }

    /**
     * Return true for leap years, false for non-leap years.
     *
     * @param {Number} year
     * @api public
     */
    function isleap(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    };

    /**
     * Return number of leap years in range [y1, y2).
     * Assumes y1 <= y2.
     *
     * @param {Number} y1
     * @param {Number} y2
     * @api public
     */
    function leapdays(y1, y2) {
      y1--;
      y2--;
      return (Math.floor(y2/4) - Math.floor(y1/4)) - (Math.floor(y2/100) - Math.floor(y1/100)) + (Math.floor(y2/400) - Math.floor(y1/400));
    };

    /**
     * Return starting weekday (0-6 ~ Mon-Sun) and number of days (28-31) for
     * year, month.
     *
     * @param {Number} year
     * @param {Number} month
     * @throws {IllegalMonthError} If the provided month is invalid.
     * @api public
     */
    function monthrange(year, month) {
      if(month < 1 || month > 12) {
        throw new IllegalMonthError();
      }

      var day1 = weekday(year, month, 1);
      var ndays = _DAYS_IN_MONTH[month] + (month === 2 && isleap(year));

      return [day1, ndays];
    };

    /**
     * Sets the locale for use in extracting month and weekday names.
     *
     * @param {String} locale
     * @throws {IllegalLocaleError} If the provided locale is invalid.
     * @api public
     */
    function setlocale(locale) {
      locale = typeof(locale) === "undefined" ? "en_US" : locale;

      if((cldr && (cldr.localeIds.indexOf(locale.replace(/-/g, '_').toLowerCase()) === -1)) || (!cldr && ((locale.replace(/-/g, '_').toLowerCase() !== "en_us")))) {
         throw new IllegalLocaleError();
      }

      this.day_name   = _extractLocaleDays(false, locale);
      this.day_abbr   = _extractLocaleDays(true, locale);
      this.month_name = _extractLocaleMonths(false, locale);
      this.month_abbr = _extractLocaleMonths(true, locale);
    };

    /**
      * Unrelated but handy function to calculate Unix timestamp from GMT.
      *
      * @param {Array} tuple
      * @throws {IllegalMonthError} If the provided month element is invalid.
      * @throws {IllegalDayError} If the provided day element is invalid.
      * @api public
      */
    function timegm(timegmt) {
      var year   = timegmt[0];
      var month  = timegmt[1];
      var day    = timegmt[2];
      var hour   = timegmt[3];
      var minute = timegmt[4];
      var second = timegmt[5];

      if(month < 1 || month > 12) {
        throw new IllegalMonthError();
      }

      if(day < 1 || day > (_DAYS_IN_MONTH[month] + (month === 2 && isleap(year)))) {
        throw new IllegalDayError();
      }

      if(hour < 0 || hour > 23 || minute < 0 || minute > 59 || second < 0 || second > 59) {
        throw new IllegalTimeError();
      }

      var days = _toordinal(year, month, 1) - 719163 + day - 1;
      var hours = (days * 24) + hour;
      var minutes = (hours * 60) + minute;
      var seconds = (minutes * 60) + second;

      return seconds;
    }

    /**
     * Return weekday (0-6 ~ Mon-Sun) for year (1970-...), month (1-12),
     * day (1-31).
     *
     * @param {Number} year
     * @param {Number} month
     * @param {Number} day
     * @throws {IllegalMonthError} If the provided month element is invalid.
     * @throws {IllegalDayError} If the provided day element is invalid.
     * @api public
     */
    function weekday(year, month, day) {
      if(month < 1 || month > 12) {
        throw new IllegalMonthError();
      }

      if(day < 1 || day > (_DAYS_IN_MONTH[month] + (month === 2 && isleap(year)))) {
        throw new IllegalDayError();
      }

      var date = new Date(year, month - 1, day);
      return _adjustWeekday(date.getDay());
    };


    /**
     * Base calendar class. This class doesn't do any formatting. It simply
     * provides data to subclasses.
     *
     * @param {Number} firstweekday
     * @throws {IllegalWeekdayError} If the provided firstweekday is invalid.
     * @api public
     */
    function Calendar(firstweekday) {
      this._firstweekday = typeof(firstweekday) === "undefined" ? 0 : firstweekday;

      if(firstweekday < 0 || firstweekday > 6) {
        throw new IllegalWeekdayError();
      }

      this._oneday = 1000 * 60 * 60 * 24;
      this._onehour = 1000 * 60 * 60;
    };

    /**
     * GET-er for firstweekday
     *
     * @api public
     */
    Calendar.prototype.getfirstweekday = function() {
      return this._firstweekday;
    };

    /**
     * SET-er for firstweekday
     *
     * @param {Number} firstweekday
     * @throws {IllegalWeekdayError} If the provided firstweekday is invalid.
     * @api public
     */
    Calendar.prototype.setfirstweekday = function(firstweekday) {
      if(firstweekday < 0 || firstweekday > 6) {
        throw new IllegalWeekdayError();
      }

      this._firstweekday = firstweekday;
    };

    /**
     * Return an array for one week of weekday numbers starting with the
     * configured first one.
     *
     * @api public
     */
    Calendar.prototype.iterweekdays = function() {
      var weekdays = [];
      for(var i = this._firstweekday; i < this._firstweekday + 7; i++) {
        weekdays.push(i % 7);
      }

      return weekdays;
    };

    /**
     * Return an array for one month. The array will contain Date
     * values and will always iterate through complete weeks, so it will yield
     * dates outside the specified month.
     *
     * @param {Number} year
     * @param {Number} month
     * @api public
     */

    Calendar.prototype.itermonthdates = function(year, month) {
      if(month < 1 || month > 12) {
        throw new IllegalMonthError();
      }

      var date = new Date(year, month - 1, 1);
      var day = _adjustWeekday(date.getDay());
      var days = (day - this._firstweekday)  >= 0 ? (day - this._firstweekday) % 7 : 7 + (day - this._firstweekday);

      date.setTime(date.getTime() - (days * this._oneday));

      var dates = [];
      while(true) {
        dates.push(new Date(date.getTime()));

        var currentDate = date.getDate();
        date.setTime(date.getTime() + this._oneday);

        // Hack to account for DST
        while(date.getDate() === currentDate) {
          date.setTime(date.getTime() + this._onehour);
        }

        if(date.getMonth() !== month - 1 && _adjustWeekday(date.getDay()) === this._firstweekday) {
          break;
        }
      }

      return dates;
    };
    /**
     * Like itermonthdates(), but will yield day numbers. For days outside
     * the specified month the day number is 0.
     *
     * @param {Number} year
     * @param {Number} month
     * @api public
     */
    Calendar.prototype.itermonthdays = function(year, month) {
      return this.itermonthdates(year, month).map(function(value){
        return value.getMonth() === month - 1 ? value.getDate() : 0;
      });
    };

    /**
     * Like itermonthdates(), but will yield [day number, weekday number]
     * arrays. For days outside the specified month the day number is 0.
     *
     * @param {Number} year
     * @param {Number} month
     * @api public
     */
    Calendar.prototype.itermonthdays2 = function(year, month) {
      return this.itermonthdates(year, month).map(function(value){
        return value.getMonth() === month - 1 ? [value.getDate(), _adjustWeekday(value.getDay())] : [0, _adjustWeekday(value.getDay())];
      }, this);
    };

    /**
     * Return a matrix (array of array) representing a month's calendar.
     * Each row represents a week; week entries are Date values.
     *
     * @param {Number} year
     * @param {Number} month
     * @api public
     */
    Calendar.prototype.monthdatescalendar = function(year, month) {
      var days = [];
      dates = this.itermonthdates(year, month);
      for(var i = 0; i < dates.length; i += 7) {
        days.push(dates.slice(i, i + 7));
      }

      return days;
    };

    /**
     * Return a matrix representing a month's calendar.
     * Each row represents a week; days outside this month are zero.
     *
     * @param {Number} year
     * @param {Number} month
     * @api public
     */
    Calendar.prototype.monthdayscalendar = function(year, month) {
      var days = [];
      dates = this.itermonthdays(year, month);
      for(var i = 0; i < dates.length; i += 7) {
        days.push(dates.slice(i, i + 7));
      }

      return days;
    };

    /**
     * Return a matrix representing a month's calendar.
     * Each row represents a week; week entries are
     * [day number, weekday number] arrays. Day numbers outside this month
     * are zero.
     *
     * @param {Number} year
     * @param {Number} month
     * @api public
     */
    Calendar.prototype.monthdays2calendar = function(year, month) {
      var days = [];
      dates = this.itermonthdays2(year, month);
      for(var i = 0; i < dates.length; i += 7) {
        days.push(dates.slice(i, i + 7));
      }

      return days;
    };

    /**
     * Return the data for the specified year ready for formatting. The return
     * value is an array of month rows. Each month row contains up to width months.
     * Each month contains between 4 and 6 weeks and each week contains 1-7
     * days. Days are Date objects.
     *
     * @param {Number} year
     * @param {Number} width
     * @api public
     */
    Calendar.prototype.yeardatescalendar = function(year, width) {
      width = typeof(width) === "undefined" ? 3 : width;

      var months = [];
      for(var month = 1; month <= 12; month++) {
        months.push(this.monthdatescalendar(year, month));
      }

      var rows = [];
      for(var i = 0; i < months.length; i += width) {
        rows.push(months.slice(i, i + width));
      }
      return rows;
    };

    /**
     * Return the data for the specified year ready for formatting (similar to
     * yeardatescalendar()). Entries in the week arrays are day numbers.
     * Day numbers outside this month are zero.
     *
     * @param {Number} year
     * @param {Number} width
     * @api public
     */
    Calendar.prototype.yeardayscalendar = function(year, width) {
      width = typeof(width) === "undefined" ? 3 : width;

      var months = [];
      for(var month = 1; month <= 12; month++) {
        months.push(this.monthdayscalendar(year, month));
      }

      var rows = [];
      for(var i = 0; i < months.length; i += width) {
        rows.push(months.slice(i, i + width));
      }
      return rows;
    };

    /**
     * Return the data for the specified year ready for formatting (similar to
     * yeardatescalendar()). Entries in the week arrays are
     * [day number, weekday number] arrays. Day numbers outside this month are
     * zero.
     *
     * @param {Number} year
     * @param {Number} width
     * @api public
     */
    Calendar.prototype.yeardays2calendar = function(year, width) {
      width = typeof(width) === "undefined" ? 3 : width;

      var months = [];
      for(var month = 1; month <= 12; month++) {
        months.push(this.monthdays2calendar(year, month));
      }

      var rows = [];
      for(var i = 0; i < months.length; i += width) {
        rows.push(months.slice(i, i + width));
      }
      return rows;
    };

    /**
     * Error indicating a nonexistent or unsupported locale specified.
     *
     * @param {String} message
     * @api public
     */
    function IllegalLocaleError(message) {
      this.name = "IllegalLocaleError";
      this.message = typeof(message) === "undefined" ? "Invalid locale specified." : message;
    };
    IllegalLocaleError.prototype = new Error();
    IllegalLocaleError.prototype.constructor = IllegalLocaleError;

    /**
     * Error indicating a day index specified outside of the valid range.
     *
     * @param {String} message
     * @api public
     */
    function IllegalDayError(message) {
      this.name = "IllegalDayError";
      this.message = typeof(message) === "undefined" ? "Invalid day specified." : message;
    };
    IllegalDayError.prototype = new Error();
    IllegalDayError.prototype.constructor = IllegalDayError;

    /**
     * Error indicating a month index specified outside of the expected range (1-12 ~ Jan-Dec).
     *
     * @param {String} message
     * @api public
     */
    function IllegalMonthError(message) {
      this.name = "IllegalMonthError";
      this.message = typeof(message) === "undefined" ? "Invalid month specified." : message;
    };
    IllegalMonthError.prototype = new Error();
    IllegalMonthError.prototype.constructor = IllegalMonthError;

    /**
     * Error indicating a time element is outside of the valid range.
     *
     * @param {String} message
     * @api public
     */
    function IllegalTimeError(message) {
      this.name = "IllegalTimeError";
      this.message = typeof(message) === "undefined" ? "Invalid time element specified." : message;
    };
    IllegalTimeError.prototype = new Error();
    IllegalTimeError.prototype.constructor = IllegalTimeError;

    /**
     * Error indicating a weekday index specified outside of the expected range (0-6 ~ Mon-Sun).
     *
     * @param {String} message
     * @api public
     */
    function IllegalWeekdayError(message) {
      this.name = "IllegalWeekdayError";
      this.message = typeof(message) === "undefined" ? "Invalid weekday specified." : message;
    };
    IllegalWeekdayError .prototype = new Error();
    IllegalWeekdayError .prototype.constructor = IllegalWeekdayError ;

    // export of package-like object with explicit public API
    var calendar = function() {};

    calendar.isleap     = isleap;
    calendar.leapdays   = leapdays;
    calendar.monthrange = monthrange;
    calendar.weekday    = weekday;
    calendar.setlocale  = setlocale;
    calendar.timegm     = timegm;
    calendar.Calendar   = Calendar;

    calendar.IllegalLocaleError  = IllegalLocaleError;
    calendar.IllegalDayError     = IllegalDayError;
    calendar.IllegalMonthError   = IllegalMonthError;
    calendar.IllegalTimeError    = IllegalTimeError;
    calendar.IllegalWeekdayError = IllegalWeekdayError;

    calendar.MONDAY     = 0;
    calendar.TUESDAY    = 1;
    calendar.WEDNESDAY  = 2;
    calendar.THURSDAY   = 3;
    calendar.FRIDAY     = 4;
    calendar.SATURDAY   = 5;
    calendar.SUNDAY     = 6;

    calendar.JANUARY    =  1;
    calendar.FEBRUARY   =  2;
    calendar.MARCH      =  3;
    calendar.APRIL      =  4;
    calendar.MAY        =  5;
    calendar.JUNE       =  6;
    calendar.JULY       =  7;
    calendar.AUGUST     =  8;
    calendar.SEPTEMBER  =  9;
    calendar.OCTOBER    = 10;
    calendar.NOVEMBER   = 11;
    calendar.DECEMBER   = 12;

    calendar.setlocale();

    // Initialization methodology and noConflict courtesy node-uuid:
    // https://github.com/broofa/node-uuid

    var _global = this;

    // Publish as node.js module
    if (typeof(module) != 'undefined' && module.exports) {
      module.exports = calendar;
    }

    // Publish as global (in browsers)
    else {
      var _previousRoot = _global.calendar;

      /**
        * Reset global 'calendar' variable
        *
        * @api public
        */
      calendar.noconflict = function() {
        _global.calendar = _previousRoot;
        return calendar;
      };

      _global.calendar = calendar;
    }

}).call(this);

},{"cldr":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/cldr.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/react/lib/Object.assign.js":[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Object.assign
 */

// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign

'use strict';

function assign(target, sources) {
  if (target == null) {
    throw new TypeError('Object.assign target cannot be null or undefined');
  }

  var to = Object(target);
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
    var nextSource = arguments[nextIndex];
    if (nextSource == null) {
      continue;
    }

    var from = Object(nextSource);

    // We don't currently support accessors nor proxies. Therefore this
    // copy cannot throw. If we ever supported this then we must handle
    // exceptions and side-effects. We don't support symbols so they won't
    // be transferred.

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
  }

  return to;
}

module.exports = assign;

},{}],"/Users/Jacob/workspace/scheduler/front-end/src/js/Action.js":[function(require,module,exports){
var AppDispatcher = require('./Dispatcher.js');
var appConstants = require('./Constants.js');

var plannerActions = {
  newMonth: function (date) {
    AppDispatcher.handleViewAction({
      actionType: appConstants.NEW_MONTH,
      data: date
    });
  },
  findMonth: function (direction) {
    AppDispatcher.handleViewAction({
      actionType: appConstants.FIND_MONTH,
      data: direction
    });
  },
  selectedDay: function (dayNum) {
    AppDispatcher.handleViewAction({
      actionType: appConstants.SELECTED_DAY,
      data: dayNum
    });
  },
  addEvents: function (evt) {
    AppDispatcher.handleViewAction({
      actionType: appConstants.ADD_EVENTS,
      data: evt
    });
  },
  deleteEvents: function (evt) {
    AppDispatcher.handleViewAction({
      actionType: appConstants.DELETE_EVENTS,
      data: evt
    })
  },
  addToDo: function (toDo) {
    AppDispatcher.handleViewAction({
      actionType: appConstants.ADD_TODO,
      data: toDo
    })
  },
  deleteToDo: function (toDo) {
    AppDispatcher.handleViewAction({
      actionType: appConstants.DELETE_TODO,
      data: toDo
    })
  },
  toDoStatus: function (toDo) {
    AppDispatcher.handleViewAction({
      actionType: appConstants.TODO_STATUS,
      data: toDo
    })
  }
};

module.exports = plannerActions;

},{"./Constants.js":"/Users/Jacob/workspace/scheduler/front-end/src/js/Constants.js","./Dispatcher.js":"/Users/Jacob/workspace/scheduler/front-end/src/js/Dispatcher.js"}],"/Users/Jacob/workspace/scheduler/front-end/src/js/Constants.js":[function(require,module,exports){
var appConstants = {
  NEW_MONTH: 'NEW_MONTH',
  FIND_MONTH: 'FIND_MONTH',
  SELECTED_DAY: 'SELECTED_DAY',
  ADD_EVENTS: 'ADD_EVENTS',
  DELETE_EVENTS: 'DELETE_EVENTS',
  ADD_TODO: 'ADD_TODO',
  DELETE_TODO: 'DELETE_TODO',
  TODO_STATUS: 'TODO_STATUS'
};

module.exports = appConstants;

},{}],"/Users/Jacob/workspace/scheduler/front-end/src/js/Dispatcher.js":[function(require,module,exports){
var Dispatcher = require('flux').Dispatcher;
var AppDispatcher = new Dispatcher();

AppDispatcher.handleViewAction = function(action) {
  this.dispatch({
    source: 'VIEW_ACTION',
    action: action
  });
}

module.exports = AppDispatcher;

},{"flux":"/Users/Jacob/workspace/scheduler/front-end/node_modules/flux/index.js"}],"/Users/Jacob/workspace/scheduler/front-end/src/js/assets/calendarConversions.js":[function(require,module,exports){
var monthConversion = {
  Jan : [1, 'January'],
  Feb : [2, 'February'],
  Mar : [3, 'March'],
  Apr : [4, 'April'],
  May : [5, 'May'],
  Jun : [6, 'June'],
  Jul : [7, 'July'],
  Aug : [8, 'August'],
  Sep : [9, 'September'],
  Oct : [10, 'October'],
  Nov : [11, 'November'],
  Dec : [12, 'December'],
  1 : 'Jan',
  2 : 'Feb',
  3 : 'Mar',
  4 : 'Apr',
  5 : 'May',
  6 : 'Jun',
  7 : 'Jul',
  8 : 'Aug',
  9 : 'Sep',
  10 : 'Oct',
  11 : 'Nov',
  12 : 'Dec',
}

var monthAnimation = function (direction) {
  if(direction) {
    var mon = document.getElementsByClassName('monthGrid')[0].classList;
    mon.add('animated', 'bounceInLeft');
    setTimeout(function(){ mon.remove('animated', 'bounceInLeft') }, 1000);
  } else {
    var mon = document.getElementsByClassName('monthGrid')[0].classList;
    mon.add('animated', 'bounceInRight');
    setTimeout(function(){ mon.remove('animated', 'bounceInRight') }, 1000);
  }
}

var sortedEvents = function (evt1, evt2) {
  return parseInt(evt1.time.start.replace(':', '')) - parseInt(evt2.time.start.replace(':', ''));
}

module.exports = {
  monthConversion: monthConversion,
  monthAnimation: monthAnimation,
  sortedEvents: sortedEvents
}

},{}],"/Users/Jacob/workspace/scheduler/front-end/src/js/assets/taskHelpers.js":[function(require,module,exports){
var handlers = {
  dateToggle: function () {
    this.setState({
      dateToggle: this.state.dateToggle ? this.state.dateToggle = false : this.state.dateToggle = true
    })
  },
  eventsToggle: function () {
    this.setState({
      eventsToggle: this.state.eventsToggle ? this.state.eventsToggle = false : this.state.eventsToggle = true
    })
  },
  toDoToggle: function () {
    this.setState({
      toDoToggle: this.state.toDoToggle ? this.state.toDoToggle = false : this.state.toDoToggle = true
    })
  }
}

var toggleState = {
  dateToggle: true,
  eventsToggle: false,
  toDoToggle: false
}

module.exports = {
  handlers: handlers,
  toggleState: toggleState
}

},{}],"/Users/Jacob/workspace/scheduler/front-end/src/js/components/Day.jsx":[function(require,module,exports){
var Day = React.createClass({displayName: "Day",
  render: function () {
    return (
      React.createElement("div", {className: "monthDay"}, 
        
         this.props.currentMonth.items.events[parseInt(this.props.day)]
         ? this.props.currentMonth.items.events[parseInt(this.props.day)].map(function (evt, i) {
            return React.createElement("p", {className: "calendarEvent", key: i}, evt.title)
           })
         : null, 
        
        
         this.props.currentMonth.items.todos[parseInt(this.props.day)]
         ? this.props.currentMonth.items.todos[parseInt(this.props.day)].map(function (toDo, i) {
            return React.createElement("p", {className: toDo.completed ? "calendarToDoC" : "calendarToDoNC", key: i}, toDo.title) 
           })
         : null
        
      )
    )
  }
})

module.exports = Day;

},{}],"/Users/Jacob/workspace/scheduler/front-end/src/js/components/events.jsx":[function(require,module,exports){
var Events = React.createClass({displayName: "Events",
  getEvents: function () {
    var dayEvents = this.props.currentMonth.items.events[this.props.currentMonth.selectedDay];
    return dayEvents || null;
  },
  render: function () {
    return (
      React.createElement("div", {className: "dayEvents animated zoomIn"}, 
         this.getEvents() != null
          ? this.getEvents().map(function (day, i) {
            return (
              React.createElement("div", {className: "dayEventContainer", key: day.time.start + day.title}, 
                React.createElement("form", null, 
                  React.createElement("span", {className: "eventMarker fa fa-calendar-check-o"}), 
                  React.createElement("input", {type: "text", placeholder: "Title", name: "title", defaultValue: day.title}), 
                  React.createElement("input", {type: "time", placeholder: "Start", name: "start", defaultValue: day.time.start}), 
                  React.createElement("input", {type: "time", placeholder: "End", name: "end", defaultValue: day.time.end}), 
                  React.createElement("textarea", {defaultValue: "Description", name: "description", defaultValue: day.description}), 
                  React.createElement("span", {className: "deleteEvent glyphicon glyphicon-minus-sign", onClick: this.props.deleteEvents.bind(this, {day: day.day, evtIndex: i})})
                )
              )
            )
          }, this)
          :
          React.createElement("p", null, "No Events Today")
        
      )
    )
  }
})

module.exports = Events;

},{}],"/Users/Jacob/workspace/scheduler/front-end/src/js/components/month.jsx":[function(require,module,exports){
var Day = require('./Day.jsx');

var Month = React.createClass({displayName: "Month",
  render: function () {
    var that = this;
    return (
      React.createElement("section", null, 
        React.createElement("div", {className: "calendarHeader"}, 
          React.createElement("button", {className: "btn btn-primary", onClick: this.props.handlers.displayMonth}, "Back"), 
          React.createElement("div", {className: "monthName"}, 
            React.createElement("h1", null, this.props.currentMonth.name), 
            React.createElement("h4", null, this.props.currentMonth.year)
          ), 
          React.createElement("button", {className: "btn btn-primary", onClick: this.props.handlers.displayMonth}, "Forward")
        ), 
        React.createElement("table", {className: "monthGrid table-bordered"}, 
          React.createElement("thead", null, 
            React.createElement("tr", null, 
              React.createElement("th", null, "Sunday"), " ", React.createElement("th", null, "Monday"), " ", React.createElement("th", null, "Tuesday"), " ", React.createElement("th", null, "Wednesday"), " ", React.createElement("th", null, "Thursday"), " ", React.createElement("th", null, "Friday"), " ", React.createElement("th", null, "Saturday")
            )
          ), 
          React.createElement("tbody", null, 
            this.props.currentMonth.monthMatrix.map(function(week) {
              return (
                React.createElement("tr", {key: week}, 
                  week.map(function(day, i) {
                    return day == parseInt(this.props.currentMonth.selectedDay)
                      ? React.createElement("td", {className: "selectedDay", key: i}, 
                          React.createElement("div", {className: "scroll"}, 
                            React.createElement("b", null, React.createElement("p", null, day)), 
                            React.createElement(Day, {day: day, currentMonth: this.props.currentMonth})
                          )
                        )
                      : React.createElement("td", {onClick: this.props.handlers.selectedDay.bind(this, day), key: i}, 
                          React.createElement("div", {className: "scroll"}, 
                            React.createElement("b", null, React.createElement("p", null, day)), 
                            React.createElement(Day, {day: day, currentMonth: this.props.currentMonth})
                          )
                        )
                  },this)
                )
              );
            },this)
          )
        )
      )
    );
  }
})

module.exports = Month;

},{"./Day.jsx":"/Users/Jacob/workspace/scheduler/front-end/src/js/components/Day.jsx"}],"/Users/Jacob/workspace/scheduler/front-end/src/js/components/planner.jsx":[function(require,module,exports){
var Month = require('./month.jsx');
var SelectedDay = require('./selectedDay.jsx');
var TaskManager = require('./taskManager.jsx');
var plannerStore = require('../stores/plannerStore.js');
var plannerActions = require('../Action.js');
var monthAnimation = require('../assets/calendarConversions').monthAnimation;

var Planner = React.createClass({displayName: "Planner",

  getInitialState: function () {
    var now = new Date().toString().split(' ');
    plannerActions.newMonth([now[1], now[3], now[2]]);
    return {
      currentMonth: plannerStore.getCurrentMonth(),
    }
  },
  componentDidMount: function () {
    plannerStore.addChangeListener(this._onChange);
  },
  componentWillUnmount: function () {
    plannerStore.removeChangeListener(this._onChange);
  },
  monthHandlers: {
    selectedDay:  function (day) {
      plannerActions.selectedDay(day);
    },
    displayMonth: function (e) {
      monthAnimation(e.target.innerHTML == 'Forward' ? true : false);
      e.target.innerHTML == 'Forward' ? plannerActions.findMonth(true) : plannerActions.findMonth(false);
    }
  },
  taskHandlers: {
    addEvents: function (e) {
      plannerActions.addEvents(e);
    },
    deleteEvents: function (e) {
      plannerActions.deleteEvents(e);
    },
    addToDo: function (e) {
      plannerActions.addToDo(e);
    },
    deleteToDo: function (e) {
      plannerActions.deleteToDo(e)
    },
    toDoStatus: function (e) {
      plannerActions.toDoStatus(e);
    }
  },
  _onChange: function () {
    this.setState({
      currentMonth: plannerStore.getCurrentMonth()
    })
  },
  render: function() {
    return (
      React.createElement("div", {className: "animated zoomIn container-fluid"}, 
        React.createElement("div", {className: "row text-center"}, 
          React.createElement("div", {className: "col-md-8"}, 
            React.createElement(Month, {currentMonth: this.state.currentMonth, handlers: this.monthHandlers})
          ), 
          React.createElement("div", {className: "col-md-4"}, 
            React.createElement(TaskManager, {currentMonth: this.state.currentMonth, handlers: this.taskHandlers})
          )
        )
      )
    );
  }

});


React.render(React.createElement(Planner, null), document.getElementById('app'));

},{"../Action.js":"/Users/Jacob/workspace/scheduler/front-end/src/js/Action.js","../assets/calendarConversions":"/Users/Jacob/workspace/scheduler/front-end/src/js/assets/calendarConversions.js","../stores/plannerStore.js":"/Users/Jacob/workspace/scheduler/front-end/src/js/stores/plannerStore.js","./month.jsx":"/Users/Jacob/workspace/scheduler/front-end/src/js/components/month.jsx","./selectedDay.jsx":"/Users/Jacob/workspace/scheduler/front-end/src/js/components/selectedDay.jsx","./taskManager.jsx":"/Users/Jacob/workspace/scheduler/front-end/src/js/components/taskManager.jsx"}],"/Users/Jacob/workspace/scheduler/front-end/src/js/components/selectedDay.jsx":[function(require,module,exports){
var SelectedDay = React.createClass ({displayName: "SelectedDay",
  handleEventSubmit: function () {
    var form = document.getElementsByName('newEvent');
    this.props.addEvents({
      day: this.props.currentMonth.selectedDay, time: {start: form[1].value, end: form[2].value}, title: form[0].value, description: form[3].value
    });
    for (var i = 0; i < form.length; i++) {
      form[i].value = null;
    }
    form[form.length -1].value = 'Description';
  },
  handleToDoSubmit: function () {
    var form = document.getElementsByName('newToDo');
    this.props.addToDo({
      day: this.props.currentMonth.selectedDay, title: form[0].value, priority: form[1].value, description: form[2].value, completed: false
    });
    console.log(form[0].value, form[1].value, form[2].value);
    form[0].value = null;
    form[1].value = 3;
    form[2].value = 'Description';
  },
  render: function () {
    return (
      React.createElement("div", {className: "animated zoomIn selectedDayContainer"}, 
        /* New Event */
        React.createElement("div", {className: "categoryOne"}, 
          React.createElement("h4", null, "Add Event"), 
          React.createElement("input", {type: "text", placeholder: "Title", name: "newEvent"}), 
          React.createElement("div", {className: "time"}, 
            React.createElement("span", {className: "fa fa-hourglass-start"}, " "), 
            React.createElement("input", {type: "time", placeholder: "Start", name: "newEvent"})
          ), 
          React.createElement("div", {className: "time"}, 
            React.createElement("span", {className: "fa fa-hourglass-end"}, " "), 
            React.createElement("input", {type: "time", placeholder: "End", name: "newEvent"})
          ), 
          React.createElement("textarea", {defaultValue: "Description", name: "newEvent"}), 
          React.createElement("span", {className: "btnSpan glyphicon glyphicon-plus-sign", onClick: this.handleEventSubmit})
        ), 
        /* New ToDo */
        React.createElement("div", null, 
          React.createElement("h4", {className: "toDoHeader"}, "Add ToDo"), 
          React.createElement("input", {type: "text", placeholder: "Title", name: "newToDo"}), 
          React.createElement("div", {className: "toDoPriority"}, 
            React.createElement("span", {className: "prioritySpan"}, "Priority"), 
            React.createElement("input", {type: "range", min: "1", max: "5", list: "interest", defaultValue: 3, name: "newToDo"}), 
              React.createElement("datalist", {id: "interest"}, 
                React.createElement("option", null, "1"), 
                React.createElement("option", null, "2"), 
                React.createElement("option", null, "3"), 
                React.createElement("option", null, "4"), 
                React.createElement("option", null, "5")
              )
          ), 
          React.createElement("textarea", {defaultValue: "Description", name: "newToDo"}), 
          React.createElement("span", {className: "btnSpan glyphicon glyphicon-plus-sign", onClick: this.handleToDoSubmit})
        )
      )
    )
  }
})

module.exports = SelectedDay

},{}],"/Users/Jacob/workspace/scheduler/front-end/src/js/components/taskManager.jsx":[function(require,module,exports){
var SelectedDay = require('./selectedDay.jsx');
var Events = require('./events.jsx');
var ToDo = require('./toDo.jsx');
var taskHelpers = require('../assets/taskHelpers.js');

var TaskManager = React.createClass({displayName: "TaskManager",

  getInitialState: function () {
    return taskHelpers.toggleState
  },
  toggleHandlers: taskHelpers.handlers,

  render: function () {
    return (
      React.createElement("section", {className: "taskManager"}, 
        React.createElement("h1", {className: "taskHeader"}, "Task Manager"), 
        React.createElement("div", {className: "taskContainer"}, 
          React.createElement("div", {className: "taskSection"}, 
            React.createElement("div", {onClick: this.toggleHandlers.dateToggle.bind(this)}, 
              React.createElement("span", {className: "taskIcon glyphicon glyphicon-triangle-" + (this.state.dateToggle ? "bottom" : "right")}), 
              React.createElement("h3", null, this.props.currentMonth.name +" "+ this.props.currentMonth.selectedDay +", "+ this.props.currentMonth.year)
            ), 
            this.state.dateToggle ? React.createElement(SelectedDay, {currentMonth: this.props.currentMonth, addEvents: this.props.handlers.addEvents, addToDo: this.props.handlers.addToDo}) : null
          ), 
          React.createElement("div", {className: "taskSection"}, 
            React.createElement("div", {onClick: this.toggleHandlers.eventsToggle.bind(this)}, 
              React.createElement("span", {className: "taskIcon glyphicon glyphicon-triangle-" + (this.state.eventsToggle ? "bottom" : "right")}), 
              React.createElement("h3", null, "Events")
            ), 
            this.state.eventsToggle ? React.createElement(Events, {currentMonth: this.props.currentMonth, deleteEvents: this.props.handlers.deleteEvents}) : null
          ), 
          React.createElement("div", {className: "taskSection"}, 
            React.createElement("div", {onClick: this.toggleHandlers.toDoToggle.bind(this)}, 
              React.createElement("span", {className: "taskIcon glyphicon glyphicon-triangle-" + (this.state.toDoToggle ? "bottom" : "right")}), 
              React.createElement("h3", null, "ToDo's")
            ), 
            this.state.toDoToggle ? React.createElement(ToDo, {currentMonth: this.props.currentMonth, toDoStatus: this.props.handlers.toDoStatus, deleteToDo: this.props.handlers.deleteToDo}) : null
          )
        )
      )
    )
  }
})

module.exports = TaskManager;

},{"../assets/taskHelpers.js":"/Users/Jacob/workspace/scheduler/front-end/src/js/assets/taskHelpers.js","./events.jsx":"/Users/Jacob/workspace/scheduler/front-end/src/js/components/events.jsx","./selectedDay.jsx":"/Users/Jacob/workspace/scheduler/front-end/src/js/components/selectedDay.jsx","./toDo.jsx":"/Users/Jacob/workspace/scheduler/front-end/src/js/components/toDo.jsx"}],"/Users/Jacob/workspace/scheduler/front-end/src/js/components/toDo.jsx":[function(require,module,exports){
var ToDo = React.createClass({displayName: "ToDo",
  getToDos: function () {
    var dayToDos = this.props.currentMonth.items.todos[this.props.currentMonth.selectedDay];
    return dayToDos || null;
  },
  render: function () {
    return (
      React.createElement("div", {className: "dayToDos animated zoomIn"}, 
         this.getToDos() != null
          ? this.getToDos().map(function (toDo, i) {
            return (
              React.createElement("div", {className: "dayToDoContainer", key: toDo.title + toDo.priority}, 
                React.createElement("span", {className: "toDoMarker fa fa-thumb-tack"}), 
                React.createElement("input", {type: "text", placeholder: "Title", name: "newToDo", defaultValue: toDo.title}), 
                React.createElement("div", {className: "toDoPriority"}, 
                  React.createElement("span", {className: "prioritySpan"}, "Priority"), 
                  React.createElement("input", {type: "range", min: "1", max: "5", list: "interest", defaultValue: toDo.priority, name: "newToDo"}), 
                    React.createElement("datalist", {id: "interest"}, 
                      React.createElement("option", null, "1"), 
                      React.createElement("option", null, "2"), 
                      React.createElement("option", null, "3"), 
                      React.createElement("option", null, "4"), 
                      React.createElement("option", null, "5")
                    )
                ), 
                React.createElement("textarea", {defaultValue: "Description", name: "newToDo", defaultValue: toDo.description}), 
                React.createElement("span", {className: toDo.completed ? "completedToDo fa fa-check-square-o" : "notCompletedToDo fa fa-square-o", onClick: this.props.toDoStatus.bind(this, {day: toDo.day, index: i})}), 
                React.createElement("span", {className: "deleteToDo glyphicon glyphicon-minus-sign", onClick: this.props.deleteToDo.bind(this, {toDo: toDo, index: i})})
              )
            )
          }, this)
          :
          React.createElement("p", null, "No ToDo's Today")
        
      )
    )
  }
})

module.exports = ToDo;

},{}],"/Users/Jacob/workspace/scheduler/front-end/src/js/stores/plannerStore.js":[function(require,module,exports){
var AppDispatcher = require('../Dispatcher.js');
var appConstants = require('../Constants.js');
var objectAssign = require('react/lib/Object.assign');
var EventEmitter = require('events').EventEmitter;
var calendar = require('node-calendar');
var assets = require('../assets/calendarConversions');

var CHANGE_EVENT = 'change';

var years = {};
var current = {};

function Month(date) {
  this.name = assets.monthConversion[date[0]][1];
  this.monthKey = assets.monthConversion[date[0]][0];
  this.year = parseInt(date[1]);
  this.monthMatrix = date;
  this.selectedDay = date[2] || 1;
  this.items = {
    events: {},
    todos: {}
  };
}

Month.prototype.newMonth = function () {
  this.monthMatrix = new calendar.Calendar(calendar.SUNDAY).monthdayscalendar(this.monthMatrix[1], assets.monthConversion[this.monthMatrix[0]][0]);
};

var newMonth = function (date) {
  current = new Month(date);
  current.newMonth();
  years[current.year] ? years[current.year].push(current) : years[current.year] = [current];
}

var findMonth = function (direction) {
  if(direction)
    current.monthKey +1 < 13 ? newCurrent = [current.monthKey +1, current.year] : newCurrent = [1, current.year +1];
  else
    current.monthKey -1 > 0 ? newCurrent = [current.monthKey -1, current.year] : newCurrent = [12, current.year -1];
  if(years[newCurrent[1]]){
    var checker = years[newCurrent[1]].filter(function (mon) {
      if(mon.monthKey === newCurrent[0])
        return mon;
    })
    checker.length > 0 ? current = checker[0] : newMonth([assets.monthConversion[newCurrent[0]], newCurrent[1]]);
  } else {
    newMonth([assets.monthConversion[newCurrent[0]], newCurrent[1]]);
  }
}

var selectedDay = function (dayNum) {
  current.selectedDay = dayNum;
}

var addEvents = function (evt) {
  current.items.events[evt.day] ? current.items.events[evt.day].push(evt) : current.items.events[evt.day] = [evt];
  current.items.events[evt.day].sort(assets.sortedEvents);
}

var deleteEvents = function (day, evtIndex) {
  current.items.events[day].splice(evtIndex, 1);
}

var addToDo = function (toDo) {
  current.items.todos[toDo.day] ? current.items.todos[toDo.day].push(toDo) : current.items.todos[toDo.day] = [toDo];
}

var deleteToDo = function (toDo, index) {
  current.items.todos[toDo.day].splice(index, 1);
}

var toDoStatus = function (toDo) {
  current.items.todos[toDo.day][toDo.index].completed ? current.items.todos[toDo.day][toDo.index].completed = false : current.items.todos[toDo.day][toDo.index].completed = true;
}

var plannerStore = objectAssign({}, EventEmitter.prototype, {
  addChangeListener: function (cb) {
    this.on(CHANGE_EVENT, cb);
  },
  removeChangeListener: function (cb) {
    this.removeListener(CHANGE_EVENT, cb);
  },
  getCurrentMonth: function () {
    console.log(years, current);
    return current;
  }
});

AppDispatcher.register(function (payload) {
  var action = payload.action;
  switch(action.actionType){
    case appConstants.NEW_MONTH:
      newMonth(action.data);
      plannerStore.emit(CHANGE_EVENT);
      break;
    case appConstants.FIND_MONTH:
      findMonth(action.data);
      plannerStore.emit(CHANGE_EVENT);
      break;
    case appConstants.SELECTED_DAY:
      selectedDay(action.data);
      plannerStore.emit(CHANGE_EVENT);
      break;
    case appConstants.ADD_EVENTS:
      addEvents(action.data);
      plannerStore.emit(CHANGE_EVENT);
      break;
    case appConstants.DELETE_EVENTS:
      deleteEvents(action.data.day, action.data.evtIndex);
      plannerStore.emit(CHANGE_EVENT);
      break;
    case appConstants.ADD_TODO:
      addToDo(action.data);
      plannerStore.emit(CHANGE_EVENT);
      break;
    case appConstants.TODO_STATUS:
      toDoStatus(action.data);
      plannerStore.emit(CHANGE_EVENT);
      break;
    case appConstants.DELETE_TODO:
      deleteToDo(action.data.toDo, action.data.index);
      plannerStore.emit(CHANGE_EVENT);
      break;
    default:
      return true;
  }
});

module.exports = plannerStore;

},{"../Constants.js":"/Users/Jacob/workspace/scheduler/front-end/src/js/Constants.js","../Dispatcher.js":"/Users/Jacob/workspace/scheduler/front-end/src/js/Dispatcher.js","../assets/calendarConversions":"/Users/Jacob/workspace/scheduler/front-end/src/js/assets/calendarConversions.js","events":"/Users/Jacob/workspace/scheduler/front-end/node_modules/events/events.js","node-calendar":"/Users/Jacob/workspace/scheduler/front-end/node_modules/node-calendar/node-calendar.js","react/lib/Object.assign":"/Users/Jacob/workspace/scheduler/front-end/node_modules/react/lib/Object.assign.js"}]},{},["/Users/Jacob/workspace/scheduler/front-end/src/js/components/planner.jsx"])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvY2xkci9saWIvQ2xkclBsdXJhbFJ1bGUuanMiLCJub2RlX21vZHVsZXMvY2xkci9saWIvQ2xkclBsdXJhbFJ1bGVTZXQuanMiLCJub2RlX21vZHVsZXMvY2xkci9saWIvQ2xkclJibmZSdWxlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbGliL2NsZHIuanMiLCJub2RlX21vZHVsZXMvY2xkci9saWIvY2xkclBsdXJhbFJ1bGVUZXJtRnVuY3Rpb25CeU5hbWUuanMiLCJub2RlX21vZHVsZXMvY2xkci9saWIvY29udmVydE9iamVjdHNXaXRoSW50ZWdlcktleXNUb0FycmF5cy5qcyIsIm5vZGVfbW9kdWxlcy9jbGRyL2xpYi9tZW1vaXplQXN5bmMuanMiLCJub2RlX21vZHVsZXMvY2xkci9saWIvbm9ybWFsaXplTG9jYWxlSWQuanMiLCJub2RlX21vZHVsZXMvY2xkci9saWIvbm9ybWFsaXplUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY2xkci9ub2RlX21vZHVsZXMvcGFzc2Vycm9yL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jbGRyL25vZGVfbW9kdWxlcy9wZWdqcy9saWIvcGVnLmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3NlcS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jbGRyL25vZGVfbW9kdWxlcy9zZXEvbm9kZV9tb2R1bGVzL2NoYWluc2F3L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3NlcS9ub2RlX21vZHVsZXMvY2hhaW5zYXcvbm9kZV9tb2R1bGVzL3RyYXZlcnNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3NlcS9ub2RlX21vZHVsZXMvaGFzaGlzaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jbGRyL25vZGVfbW9kdWxlcy9zZXEvbm9kZV9tb2R1bGVzL2hhc2hpc2gvbm9kZV9tb2R1bGVzL3RyYXZlcnNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9saWIvY29uc29saWRhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9saWIvcGFyc2UtanMuanMiLCJub2RlX21vZHVsZXMvY2xkci9ub2RlX21vZHVsZXMvdWdsaWZ5LWpzL2xpYi9wcm9jZXNzLmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9saWIvc3F1ZWV6ZS1tb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy91Z2xpZnktanMuanMiLCJub2RlX21vZHVsZXMvY2xkci9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3VuaWNvZGVyZWdleHAvbGliL3VuaWNvZGVSZWdFeHAuanMiLCJub2RlX21vZHVsZXMvY2xkci9ub2RlX21vZHVsZXMveG1sZG9tL2RvbS1wYXJzZXIuanMiLCJub2RlX21vZHVsZXMvY2xkci9ub2RlX21vZHVsZXMveG1sZG9tL2RvbS5qcyIsIm5vZGVfbW9kdWxlcy9jbGRyL25vZGVfbW9kdWxlcy94bWxkb20vc2F4LmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3hwYXRoL3hwYXRoLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvZmx1eC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mbHV4L2xpYi9EaXNwYXRjaGVyLmpzIiwibm9kZV9tb2R1bGVzL2ZsdXgvbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWNhbGVuZGFyL25vZGUtY2FsZW5kYXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL09iamVjdC5hc3NpZ24uanMiLCIvVXNlcnMvSmFjb2Ivd29ya3NwYWNlL3NjaGVkdWxlci9mcm9udC1lbmQvc3JjL2pzL0FjdGlvbi5qcyIsIi9Vc2Vycy9KYWNvYi93b3Jrc3BhY2Uvc2NoZWR1bGVyL2Zyb250LWVuZC9zcmMvanMvQ29uc3RhbnRzLmpzIiwiL1VzZXJzL0phY29iL3dvcmtzcGFjZS9zY2hlZHVsZXIvZnJvbnQtZW5kL3NyYy9qcy9EaXNwYXRjaGVyLmpzIiwiL1VzZXJzL0phY29iL3dvcmtzcGFjZS9zY2hlZHVsZXIvZnJvbnQtZW5kL3NyYy9qcy9hc3NldHMvY2FsZW5kYXJDb252ZXJzaW9ucy5qcyIsIi9Vc2Vycy9KYWNvYi93b3Jrc3BhY2Uvc2NoZWR1bGVyL2Zyb250LWVuZC9zcmMvanMvYXNzZXRzL3Rhc2tIZWxwZXJzLmpzIiwiL1VzZXJzL0phY29iL3dvcmtzcGFjZS9zY2hlZHVsZXIvZnJvbnQtZW5kL3NyYy9qcy9jb21wb25lbnRzL0RheS5qc3giLCIvVXNlcnMvSmFjb2Ivd29ya3NwYWNlL3NjaGVkdWxlci9mcm9udC1lbmQvc3JjL2pzL2NvbXBvbmVudHMvZXZlbnRzLmpzeCIsIi9Vc2Vycy9KYWNvYi93b3Jrc3BhY2Uvc2NoZWR1bGVyL2Zyb250LWVuZC9zcmMvanMvY29tcG9uZW50cy9tb250aC5qc3giLCIvVXNlcnMvSmFjb2Ivd29ya3NwYWNlL3NjaGVkdWxlci9mcm9udC1lbmQvc3JjL2pzL2NvbXBvbmVudHMvcGxhbm5lci5qc3giLCIvVXNlcnMvSmFjb2Ivd29ya3NwYWNlL3NjaGVkdWxlci9mcm9udC1lbmQvc3JjL2pzL2NvbXBvbmVudHMvc2VsZWN0ZWREYXkuanN4IiwiL1VzZXJzL0phY29iL3dvcmtzcGFjZS9zY2hlZHVsZXIvZnJvbnQtZW5kL3NyYy9qcy9jb21wb25lbnRzL3Rhc2tNYW5hZ2VyLmpzeCIsIi9Vc2Vycy9KYWNvYi93b3Jrc3BhY2Uvc2NoZWR1bGVyL2Zyb250LWVuZC9zcmMvanMvY29tcG9uZW50cy90b0RvLmpzeCIsIi9Vc2Vycy9KYWNvYi93b3Jrc3BhY2Uvc2NoZWR1bGVyL2Zyb250LWVuZC9zcmMvanMvc3RvcmVzL3BsYW5uZXJTdG9yZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2g3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeDFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BrRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuaUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNudklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN0T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0bEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0EsSUFBSSxhQUFhLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUM7QUFDL0MsSUFBSSxZQUFZLEdBQUcsT0FBTyxDQUFDLGdCQUFnQixDQUFDLENBQUM7O0FBRTdDLElBQUksY0FBYyxHQUFHO0VBQ25CLFFBQVEsRUFBRSxVQUFVLElBQUksRUFBRTtJQUN4QixhQUFhLENBQUMsZ0JBQWdCLENBQUM7TUFDN0IsVUFBVSxFQUFFLFlBQVksQ0FBQyxTQUFTO01BQ2xDLElBQUksRUFBRSxJQUFJO0tBQ1gsQ0FBQyxDQUFDO0dBQ0o7RUFDRCxTQUFTLEVBQUUsVUFBVSxTQUFTLEVBQUU7SUFDOUIsYUFBYSxDQUFDLGdCQUFnQixDQUFDO01BQzdCLFVBQVUsRUFBRSxZQUFZLENBQUMsVUFBVTtNQUNuQyxJQUFJLEVBQUUsU0FBUztLQUNoQixDQUFDLENBQUM7R0FDSjtFQUNELFdBQVcsRUFBRSxVQUFVLE1BQU0sRUFBRTtJQUM3QixhQUFhLENBQUMsZ0JBQWdCLENBQUM7TUFDN0IsVUFBVSxFQUFFLFlBQVksQ0FBQyxZQUFZO01BQ3JDLElBQUksRUFBRSxNQUFNO0tBQ2IsQ0FBQyxDQUFDO0dBQ0o7RUFDRCxTQUFTLEVBQUUsVUFBVSxHQUFHLEVBQUU7SUFDeEIsYUFBYSxDQUFDLGdCQUFnQixDQUFDO01BQzdCLFVBQVUsRUFBRSxZQUFZLENBQUMsVUFBVTtNQUNuQyxJQUFJLEVBQUUsR0FBRztLQUNWLENBQUMsQ0FBQztHQUNKO0VBQ0QsWUFBWSxFQUFFLFVBQVUsR0FBRyxFQUFFO0lBQzNCLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQztNQUM3QixVQUFVLEVBQUUsWUFBWSxDQUFDLGFBQWE7TUFDdEMsSUFBSSxFQUFFLEdBQUc7S0FDVixDQUFDO0dBQ0g7RUFDRCxPQUFPLEVBQUUsVUFBVSxJQUFJLEVBQUU7SUFDdkIsYUFBYSxDQUFDLGdCQUFnQixDQUFDO01BQzdCLFVBQVUsRUFBRSxZQUFZLENBQUMsUUFBUTtNQUNqQyxJQUFJLEVBQUUsSUFBSTtLQUNYLENBQUM7R0FDSDtFQUNELFVBQVUsRUFBRSxVQUFVLElBQUksRUFBRTtJQUMxQixhQUFhLENBQUMsZ0JBQWdCLENBQUM7TUFDN0IsVUFBVSxFQUFFLFlBQVksQ0FBQyxXQUFXO01BQ3BDLElBQUksRUFBRSxJQUFJO0tBQ1gsQ0FBQztHQUNIO0VBQ0QsVUFBVSxFQUFFLFVBQVUsSUFBSSxFQUFFO0lBQzFCLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQztNQUM3QixVQUFVLEVBQUUsWUFBWSxDQUFDLFdBQVc7TUFDcEMsSUFBSSxFQUFFLElBQUk7S0FDWCxDQUFDO0dBQ0g7QUFDSCxDQUFDLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxjQUFjLENBQUM7OztBQ3REaEMsSUFBSSxZQUFZLEdBQUc7RUFDakIsU0FBUyxFQUFFLFdBQVc7RUFDdEIsVUFBVSxFQUFFLFlBQVk7RUFDeEIsWUFBWSxFQUFFLGNBQWM7RUFDNUIsVUFBVSxFQUFFLFlBQVk7RUFDeEIsYUFBYSxFQUFFLGVBQWU7RUFDOUIsUUFBUSxFQUFFLFVBQVU7RUFDcEIsV0FBVyxFQUFFLGFBQWE7RUFDMUIsV0FBVyxFQUFFLGFBQWE7QUFDNUIsQ0FBQyxDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsWUFBWSxDQUFDOzs7QUNYOUIsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFVBQVUsQ0FBQztBQUM1QyxJQUFJLGFBQWEsR0FBRyxJQUFJLFVBQVUsRUFBRSxDQUFDOztBQUVyQyxhQUFhLENBQUMsZ0JBQWdCLEdBQUcsU0FBUyxNQUFNLEVBQUU7RUFDaEQsSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUNaLE1BQU0sRUFBRSxhQUFhO0lBQ3JCLE1BQU0sRUFBRSxNQUFNO0dBQ2YsQ0FBQyxDQUFDO0FBQ0wsQ0FBQzs7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLGFBQWEsQ0FBQzs7O0FDVi9CLElBQUksZUFBZSxHQUFHO0VBQ3BCLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUM7RUFDcEIsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQztFQUNyQixHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDO0VBQ2xCLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUM7RUFDbEIsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQztFQUNoQixHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDO0VBQ2pCLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUM7RUFDakIsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQztFQUNuQixHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsV0FBVyxDQUFDO0VBQ3RCLEdBQUcsR0FBRyxDQUFDLEVBQUUsRUFBRSxTQUFTLENBQUM7RUFDckIsR0FBRyxHQUFHLENBQUMsRUFBRSxFQUFFLFVBQVUsQ0FBQztFQUN0QixHQUFHLEdBQUcsQ0FBQyxFQUFFLEVBQUUsVUFBVSxDQUFDO0VBQ3RCLENBQUMsR0FBRyxLQUFLO0VBQ1QsQ0FBQyxHQUFHLEtBQUs7RUFDVCxDQUFDLEdBQUcsS0FBSztFQUNULENBQUMsR0FBRyxLQUFLO0VBQ1QsQ0FBQyxHQUFHLEtBQUs7RUFDVCxDQUFDLEdBQUcsS0FBSztFQUNULENBQUMsR0FBRyxLQUFLO0VBQ1QsQ0FBQyxHQUFHLEtBQUs7RUFDVCxDQUFDLEdBQUcsS0FBSztFQUNULEVBQUUsR0FBRyxLQUFLO0VBQ1YsRUFBRSxHQUFHLEtBQUs7RUFDVixFQUFFLEdBQUcsS0FBSztBQUNaLENBQUM7O0FBRUQsSUFBSSxjQUFjLEdBQUcsVUFBVSxTQUFTLEVBQUU7RUFDeEMsR0FBRyxTQUFTLEVBQUU7SUFDWixJQUFJLEdBQUcsR0FBRyxRQUFRLENBQUMsc0JBQXNCLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBQ3BFLEdBQUcsQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLGNBQWMsQ0FBQyxDQUFDO0lBQ3BDLFVBQVUsQ0FBQyxVQUFVLEVBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0dBQ3hFLE1BQU07SUFDTCxJQUFJLEdBQUcsR0FBRyxRQUFRLENBQUMsc0JBQXNCLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBQ3BFLEdBQUcsQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLGVBQWUsQ0FBQyxDQUFDO0lBQ3JDLFVBQVUsQ0FBQyxVQUFVLEVBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsZUFBZSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0dBQ3pFO0FBQ0gsQ0FBQzs7QUFFRCxJQUFJLFlBQVksR0FBRyxVQUFVLElBQUksRUFBRSxJQUFJLEVBQUU7RUFDdkMsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDakcsQ0FBQzs7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHO0VBQ2YsZUFBZSxFQUFFLGVBQWU7RUFDaEMsY0FBYyxFQUFFLGNBQWM7RUFDOUIsWUFBWSxFQUFFLFlBQVk7Q0FDM0I7OztBQy9DRCxJQUFJLFFBQVEsR0FBRztFQUNiLFVBQVUsRUFBRSxZQUFZO0lBQ3RCLElBQUksQ0FBQyxRQUFRLENBQUM7TUFDWixVQUFVLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLElBQUk7S0FDakcsQ0FBQztHQUNIO0VBQ0QsWUFBWSxFQUFFLFlBQVk7SUFDeEIsSUFBSSxDQUFDLFFBQVEsQ0FBQztNQUNaLFlBQVksRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEdBQUcsSUFBSTtLQUN6RyxDQUFDO0dBQ0g7RUFDRCxVQUFVLEVBQUUsWUFBWTtJQUN0QixJQUFJLENBQUMsUUFBUSxDQUFDO01BQ1osVUFBVSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxJQUFJO0tBQ2pHLENBQUM7R0FDSDtBQUNILENBQUM7O0FBRUQsSUFBSSxXQUFXLEdBQUc7RUFDaEIsVUFBVSxFQUFFLElBQUk7RUFDaEIsWUFBWSxFQUFFLEtBQUs7RUFDbkIsVUFBVSxFQUFFLEtBQUs7QUFDbkIsQ0FBQzs7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHO0VBQ2YsUUFBUSxFQUFFLFFBQVE7RUFDbEIsV0FBVyxFQUFFLFdBQVc7Q0FDekI7OztBQzNCRCxJQUFJLHlCQUF5QixtQkFBQTtFQUMzQixNQUFNLEVBQUUsWUFBWTtJQUNsQjtNQUNFLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsVUFBVyxDQUFBLEVBQUE7UUFDdkI7U0FDQSxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1dBQzVELElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQyxFQUFFO1lBQ3BGLE9BQU8sb0JBQUEsR0FBRSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxlQUFBLEVBQWUsQ0FBQyxHQUFBLEVBQUcsQ0FBRSxDQUFHLENBQUEsRUFBQyxHQUFHLENBQUMsS0FBVSxDQUFBO1lBQzNELENBQUM7V0FDRixJQUFJLEVBQUE7UUFDTjtRQUNBO1NBQ0EsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztXQUMzRCxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQVUsSUFBSSxFQUFFLENBQUMsRUFBRTtZQUNwRixPQUFPLG9CQUFBLEdBQUUsRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUUsSUFBSSxDQUFDLFNBQVMsR0FBRyxlQUFlLEdBQUcsZ0JBQWdCLEVBQUMsQ0FBQyxHQUFBLEVBQUcsQ0FBRSxDQUFHLENBQUEsRUFBQyxJQUFJLENBQUMsS0FBVSxDQUFBO1lBQ2xHLENBQUM7V0FDRixJQUFJO1FBQ047TUFDRyxDQUFBO0tBQ1A7R0FDRjtBQUNILENBQUMsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLEdBQUcsQ0FBQzs7O0FDdkJyQixJQUFJLDRCQUE0QixzQkFBQTtFQUM5QixTQUFTLEVBQUUsWUFBWTtJQUNyQixJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQzFGLE9BQU8sU0FBUyxJQUFJLElBQUksQ0FBQztHQUMxQjtFQUNELE1BQU0sRUFBRSxZQUFZO0lBQ2xCO01BQ0Usb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQywyQkFBNEIsQ0FBQSxFQUFBO1FBQ3hDLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLElBQUk7WUFDdEIsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEdBQUcsRUFBRSxDQUFDLEVBQUU7WUFDdkM7Y0FDRSxvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLG1CQUFBLEVBQW1CLENBQUMsR0FBQSxFQUFHLENBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDLEtBQU8sQ0FBQSxFQUFBO2dCQUNsRSxvQkFBQSxNQUFLLEVBQUEsSUFBQyxFQUFBO2tCQUNKLG9CQUFBLE1BQUssRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsb0NBQXFDLENBQU8sQ0FBQSxFQUFBO2tCQUM1RCxvQkFBQSxPQUFNLEVBQUEsQ0FBQSxDQUFDLElBQUEsRUFBSSxDQUFDLE1BQUEsRUFBTSxDQUFDLFdBQUEsRUFBVyxDQUFDLE9BQUEsRUFBTyxDQUFDLElBQUEsRUFBSSxDQUFDLE9BQUEsRUFBTyxDQUFDLFlBQUEsRUFBWSxDQUFFLEdBQUcsQ0FBQyxLQUFPLENBQVEsQ0FBQSxFQUFBO2tCQUNyRixvQkFBQSxPQUFNLEVBQUEsQ0FBQSxDQUFDLElBQUEsRUFBSSxDQUFDLE1BQUEsRUFBTSxDQUFDLFdBQUEsRUFBVyxDQUFDLE9BQUEsRUFBTyxDQUFDLElBQUEsRUFBSSxDQUFDLE9BQUEsRUFBTyxDQUFDLFlBQUEsRUFBWSxDQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBTyxDQUFRLENBQUEsRUFBQTtrQkFDMUYsb0JBQUEsT0FBTSxFQUFBLENBQUEsQ0FBQyxJQUFBLEVBQUksQ0FBQyxNQUFBLEVBQU0sQ0FBQyxXQUFBLEVBQVcsQ0FBQyxLQUFBLEVBQUssQ0FBQyxJQUFBLEVBQUksQ0FBQyxLQUFBLEVBQUssQ0FBQyxZQUFBLEVBQVksQ0FBRSxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUssQ0FBUSxDQUFBLEVBQUE7a0JBQ3BGLG9CQUFBLFVBQVMsRUFBQSxDQUFBLENBQUMsWUFBQSxFQUFZLENBQUMsYUFBQSxFQUFhLENBQUMsSUFBQSxFQUFJLENBQUMsYUFBQSxFQUFhLENBQUMsWUFBQSxFQUFZLENBQUUsR0FBRyxDQUFDLFdBQWEsQ0FBVyxDQUFBLEVBQUE7a0JBQ2xHLG9CQUFBLE1BQUssRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsNENBQUEsRUFBNEMsQ0FBQyxPQUFBLEVBQU8sQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFHLENBQU8sQ0FBQTtnQkFDekksQ0FBQTtjQUNILENBQUE7YUFDUDtBQUNiLFdBQVcsRUFBRSxJQUFJLENBQUM7O1VBRVIsb0JBQUEsR0FBRSxFQUFBLElBQUMsRUFBQSxpQkFBbUIsQ0FBQTtRQUN2QjtNQUNHLENBQUE7S0FDUDtHQUNGO0FBQ0gsQ0FBQyxDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDOzs7QUMvQnhCLElBQUksR0FBRyxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQzs7QUFFL0IsSUFBSSwyQkFBMkIscUJBQUE7RUFDN0IsTUFBTSxFQUFFLFlBQVk7SUFDbEIsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDO0lBQ2hCO01BQ0Usb0JBQUEsU0FBUSxFQUFBLElBQUMsRUFBQTtRQUNQLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsZ0JBQWlCLENBQUEsRUFBQTtVQUM5QixvQkFBQSxRQUFPLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLGlCQUFBLEVBQWlCLENBQUMsT0FBQSxFQUFPLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsWUFBYyxDQUFBLEVBQUEsTUFBYSxDQUFBLEVBQUE7VUFDNUYsb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxXQUFZLENBQUEsRUFBQTtZQUN6QixvQkFBQSxJQUFHLEVBQUEsSUFBQyxFQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLElBQVUsQ0FBQSxFQUFBO1lBQ3ZDLG9CQUFBLElBQUcsRUFBQSxJQUFDLEVBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsSUFBVSxDQUFBO1VBQ25DLENBQUEsRUFBQTtVQUNOLG9CQUFBLFFBQU8sRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsaUJBQUEsRUFBaUIsQ0FBQyxPQUFBLEVBQU8sQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxZQUFjLENBQUEsRUFBQSxTQUFnQixDQUFBO1FBQzNGLENBQUEsRUFBQTtRQUNOLG9CQUFBLE9BQU0sRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsMEJBQTJCLENBQUEsRUFBQTtVQUMxQyxvQkFBQSxPQUFNLEVBQUEsSUFBQyxFQUFBO1lBQ0wsb0JBQUEsSUFBRyxFQUFBLElBQUMsRUFBQTtjQUNGLG9CQUFBLElBQUcsRUFBQSxJQUFDLEVBQUEsUUFBVyxDQUFBLEVBQUEsR0FBQSxFQUFDLG9CQUFBLElBQUcsRUFBQSxJQUFDLEVBQUEsUUFBVyxDQUFBLEVBQUEsR0FBQSxFQUFDLG9CQUFBLElBQUcsRUFBQSxJQUFDLEVBQUEsU0FBWSxDQUFBLEVBQUEsR0FBQSxFQUFDLG9CQUFBLElBQUcsRUFBQSxJQUFDLEVBQUEsV0FBYyxDQUFBLEVBQUEsR0FBQSxFQUFDLG9CQUFBLElBQUcsRUFBQSxJQUFDLEVBQUEsVUFBYSxDQUFBLEVBQUEsR0FBQSxFQUFDLG9CQUFBLElBQUcsRUFBQSxJQUFDLEVBQUEsUUFBVyxDQUFBLEVBQUEsR0FBQSxFQUFDLG9CQUFBLElBQUcsRUFBQSxJQUFDLEVBQUEsVUFBYSxDQUFBO1lBQ3BILENBQUE7VUFDQyxDQUFBLEVBQUE7VUFDUixvQkFBQSxPQUFNLEVBQUEsSUFBQyxFQUFBO1lBQ0osSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxTQUFTLElBQUksRUFBRTtjQUN0RDtnQkFDRSxvQkFBQSxJQUFHLEVBQUEsQ0FBQSxDQUFDLEdBQUEsRUFBRyxDQUFFLElBQU0sQ0FBQSxFQUFBO2tCQUNaLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQyxFQUFFO29CQUN6QixPQUFPLEdBQUcsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDO3dCQUN2RCxvQkFBQSxJQUFHLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLGFBQUEsRUFBYSxDQUFDLEdBQUEsRUFBRyxDQUFFLENBQUcsQ0FBQSxFQUFBOzBCQUNsQyxvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLFFBQVMsQ0FBQSxFQUFBOzRCQUN0QixvQkFBQSxHQUFFLEVBQUEsSUFBQyxFQUFBLG9CQUFBLEdBQUUsRUFBQSxJQUFDLEVBQUMsR0FBUSxDQUFJLENBQUEsRUFBQTs0QkFDbkIsb0JBQUMsR0FBRyxFQUFBLENBQUEsQ0FBQyxHQUFBLEVBQUcsQ0FBRSxHQUFHLEVBQUMsQ0FBQyxZQUFBLEVBQVksQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQWEsQ0FBQSxDQUFHLENBQUE7MEJBQ3BELENBQUE7d0JBQ0gsQ0FBQTt3QkFDTCxvQkFBQSxJQUFHLEVBQUEsQ0FBQSxDQUFDLE9BQUEsRUFBTyxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFDLENBQUMsR0FBQSxFQUFHLENBQUUsQ0FBRyxDQUFBLEVBQUE7MEJBQ3BFLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsUUFBUyxDQUFBLEVBQUE7NEJBQ3RCLG9CQUFBLEdBQUUsRUFBQSxJQUFDLEVBQUEsb0JBQUEsR0FBRSxFQUFBLElBQUMsRUFBQyxHQUFRLENBQUksQ0FBQSxFQUFBOzRCQUNuQixvQkFBQyxHQUFHLEVBQUEsQ0FBQSxDQUFDLEdBQUEsRUFBRyxDQUFFLEdBQUcsRUFBQyxDQUFDLFlBQUEsRUFBWSxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBYSxDQUFBLENBQUcsQ0FBQTswQkFDcEQsQ0FBQTt3QkFDSCxDQUFBO21CQUNWLENBQUMsSUFBSSxDQUFFO2dCQUNMLENBQUE7Z0JBQ0w7YUFDSCxDQUFDLElBQUksQ0FBRTtVQUNGLENBQUE7UUFDRixDQUFBO01BQ0EsQ0FBQTtNQUNWO0dBQ0g7QUFDSCxDQUFDLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7OztBQ2xEdkIsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ25DLElBQUksV0FBVyxHQUFHLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQy9DLElBQUksV0FBVyxHQUFHLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQy9DLElBQUksWUFBWSxHQUFHLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO0FBQ3hELElBQUksY0FBYyxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUM3QyxJQUFJLGNBQWMsR0FBRyxPQUFPLENBQUMsK0JBQStCLENBQUMsQ0FBQyxjQUFjLENBQUM7O0FBRTdFLElBQUksNkJBQTZCLHVCQUFBOztFQUUvQixlQUFlLEVBQUUsWUFBWTtJQUMzQixJQUFJLEdBQUcsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMzQyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2xELE9BQU87TUFDTCxZQUFZLEVBQUUsWUFBWSxDQUFDLGVBQWUsRUFBRTtLQUM3QztHQUNGO0VBQ0QsaUJBQWlCLEVBQUUsWUFBWTtJQUM3QixZQUFZLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0dBQ2hEO0VBQ0Qsb0JBQW9CLEVBQUUsWUFBWTtJQUNoQyxZQUFZLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0dBQ25EO0VBQ0QsYUFBYSxFQUFFO0lBQ2IsV0FBVyxHQUFHLFVBQVUsR0FBRyxFQUFFO01BQzNCLGNBQWMsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDakM7SUFDRCxZQUFZLEVBQUUsVUFBVSxDQUFDLEVBQUU7TUFDekIsY0FBYyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsU0FBUyxJQUFJLFNBQVMsR0FBRyxJQUFJLEdBQUcsS0FBSyxDQUFDLENBQUM7TUFDL0QsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLElBQUksU0FBUyxHQUFHLGNBQWMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsY0FBYyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUNwRztHQUNGO0VBQ0QsWUFBWSxFQUFFO0lBQ1osU0FBUyxFQUFFLFVBQVUsQ0FBQyxFQUFFO01BQ3RCLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDN0I7SUFDRCxZQUFZLEVBQUUsVUFBVSxDQUFDLEVBQUU7TUFDekIsY0FBYyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNoQztJQUNELE9BQU8sRUFBRSxVQUFVLENBQUMsRUFBRTtNQUNwQixjQUFjLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQzNCO0lBQ0QsVUFBVSxFQUFFLFVBQVUsQ0FBQyxFQUFFO01BQ3ZCLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO0tBQzdCO0lBQ0QsVUFBVSxFQUFFLFVBQVUsQ0FBQyxFQUFFO01BQ3ZCLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDOUI7R0FDRjtFQUNELFNBQVMsRUFBRSxZQUFZO0lBQ3JCLElBQUksQ0FBQyxRQUFRLENBQUM7TUFDWixZQUFZLEVBQUUsWUFBWSxDQUFDLGVBQWUsRUFBRTtLQUM3QyxDQUFDO0dBQ0g7RUFDRCxNQUFNLEVBQUUsV0FBVztJQUNqQjtNQUNFLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsaUNBQWtDLENBQUEsRUFBQTtRQUMvQyxvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLGlCQUFrQixDQUFBLEVBQUE7VUFDL0Isb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxVQUFXLENBQUEsRUFBQTtZQUN4QixvQkFBQyxLQUFLLEVBQUEsQ0FBQSxDQUFDLFlBQUEsRUFBWSxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFDLENBQUMsUUFBQSxFQUFRLENBQUUsSUFBSSxDQUFDLGFBQWMsQ0FBQSxDQUFHLENBQUE7VUFDMUUsQ0FBQSxFQUFBO1VBQ04sb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxVQUFXLENBQUEsRUFBQTtZQUN4QixvQkFBQyxXQUFXLEVBQUEsQ0FBQSxDQUFDLFlBQUEsRUFBWSxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFDLENBQUMsUUFBQSxFQUFRLENBQUUsSUFBSSxDQUFDLFlBQWEsQ0FBQSxDQUFHLENBQUE7VUFDL0UsQ0FBQTtRQUNGLENBQUE7TUFDRixDQUFBO01BQ047QUFDTixHQUFHOztBQUVILENBQUMsQ0FBQyxDQUFDO0FBQ0g7O0FBRUEsS0FBSyxDQUFDLE1BQU0sQ0FBQyxvQkFBQyxPQUFPLEVBQUEsSUFBQSxDQUFHLENBQUEsRUFBRSxRQUFRLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7OztBQ3ZFMUQsSUFBSSxrQ0FBa0MsMkJBQUE7RUFDcEMsaUJBQWlCLEVBQUUsWUFBWTtJQUM3QixJQUFJLElBQUksR0FBRyxRQUFRLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDbEQsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUM7TUFDbkIsR0FBRyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFdBQVcsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSztLQUM3SSxDQUFDLENBQUM7SUFDSCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtNQUNwQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztLQUN0QjtJQUNELElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxhQUFhLENBQUM7R0FDNUM7RUFDRCxnQkFBZ0IsRUFBRSxZQUFZO0lBQzVCLElBQUksSUFBSSxHQUFHLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNqRCxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQztNQUNqQixHQUFHLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFdBQVcsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxLQUFLO0tBQ3RJLENBQUMsQ0FBQztJQUNILE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN6RCxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztJQUNyQixJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNsQixJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLGFBQWEsQ0FBQztHQUMvQjtFQUNELE1BQU0sRUFBRSxZQUFZO0lBQ2xCO01BQ0Usb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxzQ0FBdUMsQ0FBQSxFQUFBO1FBQ25ELGVBQWdCO1FBQ2pCLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsYUFBYyxDQUFBLEVBQUE7VUFDM0Isb0JBQUEsSUFBRyxFQUFBLElBQUMsRUFBQSxXQUFjLENBQUEsRUFBQTtVQUNsQixvQkFBQSxPQUFNLEVBQUEsQ0FBQSxDQUFDLElBQUEsRUFBSSxDQUFDLE1BQUEsRUFBTSxDQUFDLFdBQUEsRUFBVyxDQUFDLE9BQUEsRUFBTyxDQUFDLElBQUEsRUFBSSxDQUFDLFVBQVcsQ0FBUSxDQUFBLEVBQUE7VUFDL0Qsb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxNQUFPLENBQUEsRUFBQTtZQUNwQixvQkFBQSxNQUFLLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLHVCQUF3QixDQUFBLEVBQUEsR0FBUSxDQUFBLEVBQUE7WUFDaEQsb0JBQUEsT0FBTSxFQUFBLENBQUEsQ0FBQyxJQUFBLEVBQUksQ0FBQyxNQUFBLEVBQU0sQ0FBQyxXQUFBLEVBQVcsQ0FBQyxPQUFBLEVBQU8sQ0FBQyxJQUFBLEVBQUksQ0FBQyxVQUFXLENBQVEsQ0FBQTtVQUMzRCxDQUFBLEVBQUE7VUFDTixvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLE1BQU8sQ0FBQSxFQUFBO1lBQ3BCLG9CQUFBLE1BQUssRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMscUJBQXNCLENBQUEsRUFBQSxHQUFRLENBQUEsRUFBQTtZQUM5QyxvQkFBQSxPQUFNLEVBQUEsQ0FBQSxDQUFDLElBQUEsRUFBSSxDQUFDLE1BQUEsRUFBTSxDQUFDLFdBQUEsRUFBVyxDQUFDLEtBQUEsRUFBSyxDQUFDLElBQUEsRUFBSSxDQUFDLFVBQVcsQ0FBUSxDQUFBO1VBQ3pELENBQUEsRUFBQTtVQUNOLG9CQUFBLFVBQVMsRUFBQSxDQUFBLENBQUMsWUFBQSxFQUFZLENBQUMsYUFBQSxFQUFhLENBQUMsSUFBQSxFQUFJLENBQUMsVUFBVyxDQUFXLENBQUEsRUFBQTtVQUNoRSxvQkFBQSxNQUFLLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLHVDQUFBLEVBQXVDLENBQUMsT0FBQSxFQUFPLENBQUUsSUFBSSxDQUFDLGlCQUFtQixDQUFPLENBQUE7UUFDNUYsQ0FBQSxFQUFBO1FBQ0wsY0FBZTtRQUNoQixvQkFBQSxLQUFJLEVBQUEsSUFBQyxFQUFBO1VBQ0gsb0JBQUEsSUFBRyxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxZQUFhLENBQUEsRUFBQSxVQUFhLENBQUEsRUFBQTtVQUN4QyxvQkFBQSxPQUFNLEVBQUEsQ0FBQSxDQUFDLElBQUEsRUFBSSxDQUFDLE1BQUEsRUFBTSxDQUFDLFdBQUEsRUFBVyxDQUFDLE9BQUEsRUFBTyxDQUFDLElBQUEsRUFBSSxDQUFDLFNBQVUsQ0FBUSxDQUFBLEVBQUE7VUFDOUQsb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxjQUFlLENBQUEsRUFBQTtZQUM1QixvQkFBQSxNQUFLLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLGNBQWUsQ0FBQSxFQUFBLFVBQWUsQ0FBQSxFQUFBO1lBQzlDLG9CQUFBLE9BQU0sRUFBQSxDQUFBLENBQUMsSUFBQSxFQUFJLENBQUMsT0FBQSxFQUFPLENBQUMsR0FBQSxFQUFHLENBQUMsR0FBQSxFQUFHLENBQUMsR0FBQSxFQUFHLENBQUMsR0FBQSxFQUFHLENBQUMsSUFBQSxFQUFJLENBQUMsVUFBQSxFQUFVLENBQUMsWUFBQSxFQUFZLENBQUUsQ0FBQyxFQUFDLENBQUMsSUFBQSxFQUFJLENBQUMsU0FBVSxDQUFRLENBQUEsRUFBQTtjQUMxRixvQkFBQSxVQUFTLEVBQUEsQ0FBQSxDQUFDLEVBQUEsRUFBRSxDQUFDLFVBQVcsQ0FBQSxFQUFBO2dCQUN0QixvQkFBQSxRQUFPLEVBQUEsSUFBQyxFQUFBLEdBQVUsQ0FBQSxFQUFBO2dCQUNsQixvQkFBQSxRQUFPLEVBQUEsSUFBQyxFQUFBLEdBQVUsQ0FBQSxFQUFBO2dCQUNsQixvQkFBQSxRQUFPLEVBQUEsSUFBQyxFQUFBLEdBQVUsQ0FBQSxFQUFBO2dCQUNsQixvQkFBQSxRQUFPLEVBQUEsSUFBQyxFQUFBLEdBQVUsQ0FBQSxFQUFBO2dCQUNsQixvQkFBQSxRQUFPLEVBQUEsSUFBQyxFQUFBLEdBQVUsQ0FBQTtjQUNULENBQUE7VUFDVCxDQUFBLEVBQUE7VUFDTixvQkFBQSxVQUFTLEVBQUEsQ0FBQSxDQUFDLFlBQUEsRUFBWSxDQUFDLGFBQUEsRUFBYSxDQUFDLElBQUEsRUFBSSxDQUFDLFNBQVUsQ0FBVyxDQUFBLEVBQUE7VUFDL0Qsb0JBQUEsTUFBSyxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyx1Q0FBQSxFQUF1QyxDQUFDLE9BQUEsRUFBTyxDQUFFLElBQUksQ0FBQyxnQkFBa0IsQ0FBTyxDQUFBO1FBQzNGLENBQUE7TUFDRixDQUFBO0tBQ1A7R0FDRjtBQUNILENBQUMsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLFdBQVc7OztBQzlENUIsSUFBSSxXQUFXLEdBQUcsT0FBTyxDQUFDLG1CQUFtQixDQUFDLENBQUM7QUFDL0MsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQ3JDLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNqQyxJQUFJLFdBQVcsR0FBRyxPQUFPLENBQUMsMEJBQTBCLENBQUMsQ0FBQzs7QUFFdEQsSUFBSSxpQ0FBaUMsMkJBQUE7O0VBRW5DLGVBQWUsRUFBRSxZQUFZO0lBQzNCLE9BQU8sV0FBVyxDQUFDLFdBQVc7R0FDL0I7QUFDSCxFQUFFLGNBQWMsRUFBRSxXQUFXLENBQUMsUUFBUTs7RUFFcEMsTUFBTSxFQUFFLFlBQVk7SUFDbEI7TUFDRSxvQkFBQSxTQUFRLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLGFBQWMsQ0FBQSxFQUFBO1FBQy9CLG9CQUFBLElBQUcsRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsWUFBYSxDQUFBLEVBQUEsY0FBaUIsQ0FBQSxFQUFBO1FBQzVDLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsZUFBZ0IsQ0FBQSxFQUFBO1VBQzdCLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsYUFBYyxDQUFBLEVBQUE7WUFDM0Isb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxPQUFBLEVBQU8sQ0FBRSxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFHLENBQUEsRUFBQTtjQUN2RCxvQkFBQSxNQUFLLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFFLHdDQUF3QyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLFFBQVEsR0FBRyxPQUFPLENBQUcsQ0FBTyxDQUFBLEVBQUE7Y0FDakgsb0JBQUEsSUFBRyxFQUFBLElBQUMsRUFBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsSUFBVSxDQUFBO1lBQ2pILENBQUEsRUFBQTtZQUNMLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLG9CQUFDLFdBQVcsRUFBQSxDQUFBLENBQUMsWUFBQSxFQUFZLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEVBQUMsQ0FBQyxTQUFBLEVBQVMsQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUMsQ0FBQyxPQUFBLEVBQU8sQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxPQUFRLENBQUEsQ0FBRyxDQUFBLEdBQUcsSUFBSztVQUNuSyxDQUFBLEVBQUE7VUFDTixvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLGFBQWMsQ0FBQSxFQUFBO1lBQzNCLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsT0FBQSxFQUFPLENBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBRyxDQUFBLEVBQUE7Y0FDekQsb0JBQUEsTUFBSyxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBRSx3Q0FBd0MsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksR0FBRyxRQUFRLEdBQUcsT0FBTyxDQUFHLENBQU8sQ0FBQSxFQUFBO2NBQ25ILG9CQUFBLElBQUcsRUFBQSxJQUFDLEVBQUEsUUFBVyxDQUFBO1lBQ1gsQ0FBQSxFQUFBO1lBQ0wsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEdBQUcsb0JBQUMsTUFBTSxFQUFBLENBQUEsQ0FBQyxZQUFBLEVBQVksQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksRUFBQyxDQUFDLFlBQUEsRUFBWSxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFlBQWEsQ0FBQSxDQUFHLENBQUEsR0FBRyxJQUFLO1VBQ2hJLENBQUEsRUFBQTtVQUNOLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsYUFBYyxDQUFBLEVBQUE7WUFDM0Isb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxPQUFBLEVBQU8sQ0FBRSxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFHLENBQUEsRUFBQTtjQUN2RCxvQkFBQSxNQUFLLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFFLHdDQUF3QyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLFFBQVEsR0FBRyxPQUFPLENBQUcsQ0FBTyxDQUFBLEVBQUE7Y0FDakgsb0JBQUEsSUFBRyxFQUFBLElBQUMsRUFBQSxRQUFXLENBQUE7WUFDWCxDQUFBLEVBQUE7WUFDTCxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxvQkFBQyxJQUFJLEVBQUEsQ0FBQSxDQUFDLFlBQUEsRUFBWSxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFDLENBQUMsVUFBQSxFQUFVLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFDLENBQUMsVUFBQSxFQUFVLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsVUFBVyxDQUFBLENBQUcsQ0FBQSxHQUFHLElBQUs7VUFDcEssQ0FBQTtRQUNGLENBQUE7TUFDRSxDQUFBO0tBQ1g7R0FDRjtBQUNILENBQUMsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLFdBQVcsQ0FBQzs7O0FDNUM3QixJQUFJLDBCQUEwQixvQkFBQTtFQUM1QixRQUFRLEVBQUUsWUFBWTtJQUNwQixJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3hGLE9BQU8sUUFBUSxJQUFJLElBQUksQ0FBQztHQUN6QjtFQUNELE1BQU0sRUFBRSxZQUFZO0lBQ2xCO01BQ0Usb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQywwQkFBMkIsQ0FBQSxFQUFBO1FBQ3ZDLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLElBQUk7WUFDckIsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxVQUFVLElBQUksRUFBRSxDQUFDLEVBQUU7WUFDdkM7Y0FDRSxvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLGtCQUFBLEVBQWtCLENBQUMsR0FBQSxFQUFHLENBQUUsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBVSxDQUFBLEVBQUE7Z0JBQ2pFLG9CQUFBLE1BQUssRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsNkJBQThCLENBQU8sQ0FBQSxFQUFBO2dCQUNyRCxvQkFBQSxPQUFNLEVBQUEsQ0FBQSxDQUFDLElBQUEsRUFBSSxDQUFDLE1BQUEsRUFBTSxDQUFDLFdBQUEsRUFBVyxDQUFDLE9BQUEsRUFBTyxDQUFDLElBQUEsRUFBSSxDQUFDLFNBQUEsRUFBUyxDQUFDLFlBQUEsRUFBWSxDQUFFLElBQUksQ0FBQyxLQUFPLENBQVEsQ0FBQSxFQUFBO2dCQUN4RixvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLGNBQWUsQ0FBQSxFQUFBO2tCQUM1QixvQkFBQSxNQUFLLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLGNBQWUsQ0FBQSxFQUFBLFVBQWUsQ0FBQSxFQUFBO2tCQUM5QyxvQkFBQSxPQUFNLEVBQUEsQ0FBQSxDQUFDLElBQUEsRUFBSSxDQUFDLE9BQUEsRUFBTyxDQUFDLEdBQUEsRUFBRyxDQUFDLEdBQUEsRUFBRyxDQUFDLEdBQUEsRUFBRyxDQUFDLEdBQUEsRUFBRyxDQUFDLElBQUEsRUFBSSxDQUFDLFVBQUEsRUFBVSxDQUFDLFlBQUEsRUFBWSxDQUFFLElBQUksQ0FBQyxRQUFRLEVBQUMsQ0FBQyxJQUFBLEVBQUksQ0FBQyxTQUFVLENBQVEsQ0FBQSxFQUFBO29CQUN0RyxvQkFBQSxVQUFTLEVBQUEsQ0FBQSxDQUFDLEVBQUEsRUFBRSxDQUFDLFVBQVcsQ0FBQSxFQUFBO3NCQUN0QixvQkFBQSxRQUFPLEVBQUEsSUFBQyxFQUFBLEdBQVUsQ0FBQSxFQUFBO3NCQUNsQixvQkFBQSxRQUFPLEVBQUEsSUFBQyxFQUFBLEdBQVUsQ0FBQSxFQUFBO3NCQUNsQixvQkFBQSxRQUFPLEVBQUEsSUFBQyxFQUFBLEdBQVUsQ0FBQSxFQUFBO3NCQUNsQixvQkFBQSxRQUFPLEVBQUEsSUFBQyxFQUFBLEdBQVUsQ0FBQSxFQUFBO3NCQUNsQixvQkFBQSxRQUFPLEVBQUEsSUFBQyxFQUFBLEdBQVUsQ0FBQTtvQkFDVCxDQUFBO2dCQUNULENBQUEsRUFBQTtnQkFDTixvQkFBQSxVQUFTLEVBQUEsQ0FBQSxDQUFDLFlBQUEsRUFBWSxDQUFDLGFBQUEsRUFBYSxDQUFDLElBQUEsRUFBSSxDQUFDLFNBQUEsRUFBUyxDQUFDLFlBQUEsRUFBWSxDQUFFLElBQUksQ0FBQyxXQUFhLENBQVcsQ0FBQSxFQUFBO2dCQUMvRixvQkFBQSxNQUFLLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFFLElBQUksQ0FBQyxTQUFTLEdBQUcsb0NBQW9DLEdBQUcsaUNBQWlDLEVBQUMsQ0FBQyxPQUFBLEVBQU8sQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFHLENBQU8sQ0FBQSxFQUFBO2dCQUN6TCxvQkFBQSxNQUFLLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLDJDQUFBLEVBQTJDLENBQUMsT0FBQSxFQUFPLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFHLENBQU8sQ0FBQTtjQUNsSSxDQUFBO2FBQ1A7QUFDYixXQUFXLEVBQUUsSUFBSSxDQUFDOztVQUVSLG9CQUFBLEdBQUUsRUFBQSxJQUFDLEVBQUEsaUJBQW1CLENBQUE7UUFDdkI7TUFDRyxDQUFBO0tBQ1A7R0FDRjtBQUNILENBQUMsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQzs7O0FDdkN0QixJQUFJLGFBQWEsR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUNoRCxJQUFJLFlBQVksR0FBRyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQztBQUM5QyxJQUFJLFlBQVksR0FBRyxPQUFPLENBQUMseUJBQXlCLENBQUMsQ0FBQztBQUN0RCxJQUFJLFlBQVksR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsWUFBWSxDQUFDO0FBQ2xELElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUN4QyxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsK0JBQStCLENBQUMsQ0FBQzs7QUFFdEQsSUFBSSxZQUFZLEdBQUcsUUFBUSxDQUFDOztBQUU1QixJQUFJLEtBQUssR0FBRyxFQUFFLENBQUM7QUFDZixJQUFJLE9BQU8sR0FBRyxFQUFFLENBQUM7O0FBRWpCLFNBQVMsS0FBSyxDQUFDLElBQUksRUFBRTtFQUNuQixJQUFJLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDL0MsSUFBSSxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQ25ELElBQUksQ0FBQyxJQUFJLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQzlCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO0VBQ3hCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztFQUNoQyxJQUFJLENBQUMsS0FBSyxHQUFHO0lBQ1gsTUFBTSxFQUFFLEVBQUU7SUFDVixLQUFLLEVBQUUsRUFBRTtHQUNWLENBQUM7QUFDSixDQUFDOztBQUVELEtBQUssQ0FBQyxTQUFTLENBQUMsUUFBUSxHQUFHLFlBQVk7RUFDckMsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLFFBQVEsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNuSixDQUFDLENBQUM7O0FBRUYsSUFBSSxRQUFRLEdBQUcsVUFBVSxJQUFJLEVBQUU7RUFDN0IsT0FBTyxHQUFHLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0VBQzFCLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQztFQUNuQixLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUM1RixDQUFDOztBQUVELElBQUksU0FBUyxHQUFHLFVBQVUsU0FBUyxFQUFFO0VBQ25DLEdBQUcsU0FBUztBQUNkLElBQUksT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsRUFBRSxHQUFHLFVBQVUsR0FBRyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxVQUFVLEdBQUcsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQzs7SUFFaEgsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFVBQVUsR0FBRyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxVQUFVLEdBQUcsQ0FBQyxFQUFFLEVBQUUsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztFQUNsSCxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN0QixJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsR0FBRyxFQUFFO01BQ3ZELEdBQUcsR0FBRyxDQUFDLFFBQVEsS0FBSyxVQUFVLENBQUMsQ0FBQyxDQUFDO1FBQy9CLE9BQU8sR0FBRyxDQUFDO0tBQ2QsQ0FBQztJQUNGLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLE9BQU8sR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0dBQzlHLE1BQU07SUFDTCxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7R0FDbEU7QUFDSCxDQUFDOztBQUVELElBQUksV0FBVyxHQUFHLFVBQVUsTUFBTSxFQUFFO0VBQ2xDLE9BQU8sQ0FBQyxXQUFXLEdBQUcsTUFBTSxDQUFDO0FBQy9CLENBQUM7O0FBRUQsSUFBSSxTQUFTLEdBQUcsVUFBVSxHQUFHLEVBQUU7RUFDN0IsT0FBTyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7RUFDaEgsT0FBTyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDMUQsQ0FBQzs7QUFFRCxJQUFJLFlBQVksR0FBRyxVQUFVLEdBQUcsRUFBRSxRQUFRLEVBQUU7RUFDMUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUNoRCxDQUFDOztBQUVELElBQUksT0FBTyxHQUFHLFVBQVUsSUFBSSxFQUFFO0VBQzVCLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3BILENBQUM7O0FBRUQsSUFBSSxVQUFVLEdBQUcsVUFBVSxJQUFJLEVBQUUsS0FBSyxFQUFFO0VBQ3RDLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ2pELENBQUM7O0FBRUQsSUFBSSxVQUFVLEdBQUcsVUFBVSxJQUFJLEVBQUU7RUFDL0IsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLEdBQUcsS0FBSyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztBQUNqTCxDQUFDOztBQUVELElBQUksWUFBWSxHQUFHLFlBQVksQ0FBQyxFQUFFLEVBQUUsWUFBWSxDQUFDLFNBQVMsRUFBRTtFQUMxRCxpQkFBaUIsRUFBRSxVQUFVLEVBQUUsRUFBRTtJQUMvQixJQUFJLENBQUMsRUFBRSxDQUFDLFlBQVksRUFBRSxFQUFFLENBQUMsQ0FBQztHQUMzQjtFQUNELG9CQUFvQixFQUFFLFVBQVUsRUFBRSxFQUFFO0lBQ2xDLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0dBQ3ZDO0VBQ0QsZUFBZSxFQUFFLFlBQVk7SUFDM0IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDNUIsT0FBTyxPQUFPLENBQUM7R0FDaEI7QUFDSCxDQUFDLENBQUMsQ0FBQzs7QUFFSCxhQUFhLENBQUMsUUFBUSxDQUFDLFVBQVUsT0FBTyxFQUFFO0VBQ3hDLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUM7RUFDNUIsT0FBTyxNQUFNLENBQUMsVUFBVTtJQUN0QixLQUFLLFlBQVksQ0FBQyxTQUFTO01BQ3pCLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7TUFDdEIsWUFBWSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztNQUNoQyxNQUFNO0lBQ1IsS0FBSyxZQUFZLENBQUMsVUFBVTtNQUMxQixTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO01BQ3ZCLFlBQVksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7TUFDaEMsTUFBTTtJQUNSLEtBQUssWUFBWSxDQUFDLFlBQVk7TUFDNUIsV0FBVyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztNQUN6QixZQUFZLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO01BQ2hDLE1BQU07SUFDUixLQUFLLFlBQVksQ0FBQyxVQUFVO01BQzFCLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7TUFDdkIsWUFBWSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztNQUNoQyxNQUFNO0lBQ1IsS0FBSyxZQUFZLENBQUMsYUFBYTtNQUM3QixZQUFZLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztNQUNwRCxZQUFZLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO01BQ2hDLE1BQU07SUFDUixLQUFLLFlBQVksQ0FBQyxRQUFRO01BQ3hCLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7TUFDckIsWUFBWSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztNQUNoQyxNQUFNO0lBQ1IsS0FBSyxZQUFZLENBQUMsV0FBVztNQUMzQixVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO01BQ3hCLFlBQVksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7TUFDaEMsTUFBTTtJQUNSLEtBQUssWUFBWSxDQUFDLFdBQVc7TUFDM0IsVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7TUFDaEQsWUFBWSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztNQUNoQyxNQUFNO0lBQ1I7TUFDRSxPQUFPLElBQUksQ0FBQztHQUNmO0FBQ0gsQ0FBQyxDQUFDLENBQUM7O0FBRUgsTUFBTSxDQUFDLE9BQU8sR0FBRyxZQUFZLENBQUMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIixudWxsLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwidmFyIGZzID0gcmVxdWlyZSgnZnMnKSxcbiAgICBQYXRoID0gcmVxdWlyZSgncGF0aCcpLFxuICAgIFBFRyA9IHJlcXVpcmUoJ3BlZ2pzJyksXG4gICAgcGFyc2VyID0gUEVHLmJ1aWxkUGFyc2VyKGZzLnJlYWRGaWxlU3luYyhQYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnY2xkclBsdXJhbFJ1bGUucGVnanMnKSwgJ3V0Zi04JykpO1xuXG5mdW5jdGlvbiByYW5nZUxpc3RUb0phdmFTY3JpcHRBc3QocmFuZ2VMaXN0Tm9kZSwgbGhzSmF2YVNjcmlwdEFzdCwgd2l0aGluU2VtYW50aWNzKSB7XG4gICAgdmFyIGphdmFTY3JpcHRBc3QsXG4gICAgICAgIHNlZW5SYW5nZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSByYW5nZUxpc3ROb2RlLnJhbmdlcy5sZW5ndGggLSAxIDsgaSA+PSAwIDsgaSAtPSAxKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHJhbmdlTGlzdE5vZGUucmFuZ2VzW2ldLFxuICAgICAgICAgICAgaXRlbUphdmFTY3JpcHRBc3Q7XG4gICAgICAgIGlmIChyYW5nZS50eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaXRlbUphdmFTY3JpcHRBc3QgPSBbJ2JpbmFyeScsICc9PT0nLCBsaHNKYXZhU2NyaXB0QXN0LCBbJ251bScsIHJhbmdlLnZhbHVlXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyByYW5nZS50eXBlID09PSAncmFuZ2UnXG4gICAgICAgICAgICBzZWVuUmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgaXRlbUphdmFTY3JpcHRBc3QgPSBbJ2JpbmFyeScsICcmJicsIFsnYmluYXJ5JywgJz49JywgbGhzSmF2YVNjcmlwdEFzdCwgWydudW0nLCByYW5nZS5taW4udmFsdWVdXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbJ2JpbmFyeScsICc8PScsIGxoc0phdmFTY3JpcHRBc3QsIFsnbnVtJywgcmFuZ2UubWF4LnZhbHVlXV1dO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqYXZhU2NyaXB0QXN0KSB7XG4gICAgICAgICAgICBqYXZhU2NyaXB0QXN0ID0gWydiaW5hcnknLCAnfHwnLCBpdGVtSmF2YVNjcmlwdEFzdCwgamF2YVNjcmlwdEFzdF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBqYXZhU2NyaXB0QXN0ID0gaXRlbUphdmFTY3JpcHRBc3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlZW5SYW5nZSAmJiAhd2l0aGluU2VtYW50aWNzKSB7XG4gICAgICAgIGphdmFTY3JpcHRBc3QgPSBbJ2JpbmFyeScsICcmJicsIFsnYmluYXJ5JywgJz09PScsIGxoc0phdmFTY3JpcHRBc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsnY2FsbCcsIFsnZG90JywgWyduYW1lJywgJ01hdGgnXSwgJ2Zsb29yJ10sIFtsaHNKYXZhU2NyaXB0QXN0XV1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqYXZhU2NyaXB0QXN0XTtcbiAgICB9XG4gICAgcmV0dXJuIGphdmFTY3JpcHRBc3Q7XG59XG5cbmZ1bmN0aW9uIG5vZGVUb0phdmFTY3JpcHRBc3Qobm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIFsnbnVtJywgbm9kZS52YWx1ZV07XG4gICAgY2FzZSAnbic6XG4gICAgY2FzZSAnaSc6XG4gICAgY2FzZSAndic6XG4gICAgY2FzZSAndyc6XG4gICAgY2FzZSAnZic6XG4gICAgY2FzZSAndCc6XG4gICAgICAgIHJldHVybiBbJ25hbWUnLCBub2RlLnR5cGVdO1xuICAgIGNhc2UgJ2lzJzpcbiAgICAgICAgcmV0dXJuIFsnYmluYXJ5JywgJz09PSddLmNvbmNhdChub2RlLm9wZXJhbmRzLm1hcChub2RlVG9KYXZhU2NyaXB0QXN0KSk7XG4gICAgY2FzZSAnaXNub3QnOlxuICAgICAgICByZXR1cm4gWydiaW5hcnknLCAnIT09J10uY29uY2F0KG5vZGUub3BlcmFuZHMubWFwKG5vZGVUb0phdmFTY3JpcHRBc3QpKTtcbiAgICBjYXNlICdtb2QnOlxuICAgICAgICByZXR1cm4gWydiaW5hcnknLCAnJSddLmNvbmNhdChub2RlLm9wZXJhbmRzLm1hcChub2RlVG9KYXZhU2NyaXB0QXN0KSk7XG4gICAgY2FzZSAnYW5kJzpcbiAgICAgICAgcmV0dXJuIFsnYmluYXJ5JywgJyYmJ10uY29uY2F0KG5vZGUub3BlcmFuZHMubWFwKG5vZGVUb0phdmFTY3JpcHRBc3QpKTtcbiAgICBjYXNlICdvcic6XG4gICAgICAgIHJldHVybiBbJ2JpbmFyeScsICd8fCddLmNvbmNhdChub2RlLm9wZXJhbmRzLm1hcChub2RlVG9KYXZhU2NyaXB0QXN0KSk7XG4gICAgY2FzZSAnbm90JzpcbiAgICAgICAgcmV0dXJuIFsndW5hcnktcHJlZml4JywgJyEnLCBub2RlVG9KYXZhU2NyaXB0QXN0KG5vZGUub3BlcmFuZHMpXTtcbiAgICBjYXNlICdpc25vdCc6XG4gICAgICAgIHJldHVybiBbJ2JpbmFyeScsICchPT0nXS5jb25jYXQobm9kZS5vcGVyYW5kcy5tYXAobm9kZVRvSmF2YVNjcmlwdEFzdCkpO1xuICAgIGNhc2UgJ3dpdGhpbic6XG4gICAgICAgIHJldHVybiByYW5nZUxpc3RUb0phdmFTY3JpcHRBc3Qobm9kZS5vcGVyYW5kc1sxXSwgbm9kZVRvSmF2YVNjcmlwdEFzdChub2RlLm9wZXJhbmRzWzBdKSwgdHJ1ZSk7XG4gICAgY2FzZSAnbm90d2l0aGluJzpcbiAgICAgICAgcmV0dXJuIFsndW5hcnktcHJlZml4JywgJyEnLCByYW5nZUxpc3RUb0phdmFTY3JpcHRBc3Qobm9kZS5vcGVyYW5kc1sxXSwgbm9kZVRvSmF2YVNjcmlwdEFzdChub2RlLm9wZXJhbmRzWzBdKSwgdHJ1ZSldO1xuICAgIGNhc2UgJ2luJzpcbiAgICAgICAgcmV0dXJuIHJhbmdlTGlzdFRvSmF2YVNjcmlwdEFzdChub2RlLm9wZXJhbmRzWzFdLCBub2RlVG9KYXZhU2NyaXB0QXN0KG5vZGUub3BlcmFuZHNbMF0pLCBmYWxzZSk7XG4gICAgY2FzZSAnbm90aW4nOlxuICAgICAgICByZXR1cm4gWyd1bmFyeS1wcmVmaXgnLCAnIScsIHJhbmdlTGlzdFRvSmF2YVNjcmlwdEFzdChub2RlLm9wZXJhbmRzWzFdLCBub2RlVG9KYXZhU2NyaXB0QXN0KG5vZGUub3BlcmFuZHNbMF0pLCBmYWxzZSldO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm9kZVRvSmF2YVNjcmlwdEFzdDogVW5rbm93biBub2RlIHR5cGU6ICcgKyBub2RlLnR5cGUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdHJhdmVyc2Uobm9kZSwgbGFtYmRhKSB7XG4gICAgbGFtYmRhKG5vZGUpO1xuICAgIGlmIChub2RlLm9wZXJhbmRzKSB7XG4gICAgICAgIG5vZGUub3BlcmFuZHMuZm9yRWFjaChmdW5jdGlvbiAob3BlcmFuZCkge1xuICAgICAgICAgICAgdHJhdmVyc2Uob3BlcmFuZCwgbGFtYmRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBDbGRyUGx1cmFsUnVsZShzcmMpIHtcbiAgICB0aGlzLnRvcExldmVsTm9kZSA9IHBhcnNlci5wYXJzZShzcmMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpLnJlcGxhY2UoL1xcc3syLH0vZywgJyAnKSk7XG59XG5cbkNsZHJQbHVyYWxSdWxlLnByb3RvdHlwZSA9IHtcbiAgICB0b0phdmFTY3JpcHRBc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVUb0phdmFTY3JpcHRBc3QodGhpcy50b3BMZXZlbE5vZGUpO1xuICAgIH0sXG5cbiAgICBlYWNoTm9kZTogZnVuY3Rpb24gKGxhbWJkYSkge1xuICAgICAgICB0cmF2ZXJzZSh0aGlzLnRvcExldmVsTm9kZSwgbGFtYmRhKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlSXNVc2VkQnlUZXJtOiBmdW5jdGlvbiAoaXNVc2VkQnlUZXJtKSB7XG4gICAgICAgIHRoaXMuZWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChbJ2knLCAndicsICd3JywgJ2YnLCAndCcsICduJ10uaW5kZXhPZihub2RlLnR5cGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlzVXNlZEJ5VGVybVtub2RlLnR5cGVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpc1VzZWRCeVRlcm07XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGRyUGx1cmFsUnVsZTtcbiIsInZhciBDbGRyUGx1cmFsUnVsZSA9IHJlcXVpcmUoJy4vQ2xkclBsdXJhbFJ1bGUnKSxcbiAgICBjbGRyUGx1cmFsUnVsZVRlcm1GdW5jdGlvbkJ5TmFtZSA9IHJlcXVpcmUoJy4vY2xkclBsdXJhbFJ1bGVUZXJtRnVuY3Rpb25CeU5hbWUnKSxcbiAgICB1Z2xpZnlKcyA9IHJlcXVpcmUoJ3VnbGlmeS1qcycpO1xuXG5mdW5jdGlvbiBDbGRyUGx1cmFsUnVsZVNldCgpIHtcbiAgICB0aGlzLmNsZHJQbHVyYWxSdWxlQnlDb3VudCA9IHt9O1xufVxuXG5DbGRyUGx1cmFsUnVsZVNldC5wcm90b3R5cGUgPSB7XG4gICAgYWRkUnVsZTogZnVuY3Rpb24gKGNsZHJQbHVyYWxSdWxlLCBjb3VudCkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZHJQbHVyYWxSdWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY2xkclBsdXJhbFJ1bGUgPSBjbGRyUGx1cmFsUnVsZS5yZXBsYWNlKC9cXHMqQCg/OmRlY2ltYWx8aW50ZWdlcikuKiQvLCAnJyk7XG4gICAgICAgICAgICAvLyBTb21lIGNvdW50PVwib3RoZXJcIiBub2RlcyBpbiBDTERSIDI0KyBjb25zaXN0IHB1cmVseSBvZiBzYW1wbGUgdGV4dC5cbiAgICAgICAgICAgIC8vIERvbid0IGFkZCB0aG9zZS5cbiAgICAgICAgICAgIGlmIChjbGRyUGx1cmFsUnVsZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGRyUGx1cmFsUnVsZSA9IG5ldyBDbGRyUGx1cmFsUnVsZShjbGRyUGx1cmFsUnVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGRyUGx1cmFsUnVsZUJ5Q291bnRbY291bnRdID0gY2xkclBsdXJhbFJ1bGU7XG4gICAgfSxcblxuICAgIHRvSmF2YVNjcmlwdEZ1bmN0aW9uQm9keUFzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGVtZW50QXN0cyA9IFtdLFxuICAgICAgICAgICAgaXNVc2VkQnlUZXJtID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuY2xkclBsdXJhbFJ1bGVCeUNvdW50KS5mb3JFYWNoKGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICAgICAgdmFyIGNsZHJQbHVyYWxSdWxlID0gdGhpcy5jbGRyUGx1cmFsUnVsZUJ5Q291bnRbY291bnRdO1xuICAgICAgICAgICAgY2xkclBsdXJhbFJ1bGUudXBkYXRlSXNVc2VkQnlUZXJtKGlzVXNlZEJ5VGVybSk7XG4gICAgICAgICAgICBzdGF0ZW1lbnRBc3RzLnB1c2goXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAnaWYnLFxuICAgICAgICAgICAgICAgICAgICBjbGRyUGx1cmFsUnVsZS50b0phdmFTY3JpcHRBc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgWydyZXR1cm4nLCBbJ3N0cmluZycsIGNvdW50XV1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICApO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgc3RhdGVtZW50QXN0cy5wdXNoKFsncmV0dXJuJywgWydzdHJpbmcnLCAnb3RoZXInXV0pO1xuICAgICAgICB2YXIgdmFyQXN0cyA9IFtdO1xuXG4gICAgICAgIFsnaScsICd2JywgJ3cnLCAnZicsICd0J10uZm9yRWFjaChmdW5jdGlvbiAodGVybSkge1xuICAgICAgICAgICAgaWYgKGlzVXNlZEJ5VGVybVt0ZXJtXSkge1xuICAgICAgICAgICAgICAgIHZhckFzdHMucHVzaChbdGVybSwgdWdsaWZ5SnMucGFyc2VyLnBhcnNlKGNsZHJQbHVyYWxSdWxlVGVybUZ1bmN0aW9uQnlOYW1lW3Rlcm1dLnRvU3RyaW5nKCkpWzFdWzBdWzNdWzBdWzFdXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhpc1VzZWRCeVRlcm0pLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgc3RhdGVtZW50QXN0cy51bnNoaWZ0KFxuICAgICAgICAgICAgICAgIC8vIGlmICh0eXBlb2YgbiA9PT0gJ3N0cmluZycpIG4gPSBwYXJzZUludChuLCAxMCk7XG4gICAgICAgICAgICAgICAgWyAnaWYnLFxuICAgICAgICAgICAgICAgICAgICAgIFsgJ2JpbmFyeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnPT09JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFsgJ3VuYXJ5LXByZWZpeCcsICd0eXBlb2YnLCBbICduYW1lJywgJ24nIF0gXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFsgJ3N0cmluZycsICdzdHJpbmcnIF0gXSxcbiAgICAgICAgICAgICAgICAgICAgICBbICdzdGF0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFsgJ2Fzc2lnbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFsgJ25hbWUnLCAnbicgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgWyAnY2FsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWyAnbmFtZScsICdwYXJzZUludCcgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIFsgJ25hbWUnLCAnbicgXSwgWyAnbnVtJywgMTAgXSBdIF0gXSBdLFxuICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCBdXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhckFzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc3RhdGVtZW50QXN0cy51bnNoaWZ0KFsndmFyJywgdmFyQXN0c10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZW1lbnRBc3RzO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xkclBsdXJhbFJ1bGVTZXQ7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxuZnVuY3Rpb24gQ2xkclJibmZSdWxlU2V0KGNvbmZpZykge1xuICAgIF8uZXh0ZW5kKHRoaXMsIGNvbmZpZyk7XG4gICAgdGhpcy5ydWxlQnlWYWx1ZSA9IHt9O1xufVxuXG5DbGRyUmJuZlJ1bGVTZXQuZ2V0U2FmZVJlbmRlcmVyTmFtZSA9IGZ1bmN0aW9uIChyZW5kZXJlck5hbWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICAoXCJyZW5kZXItXCIgKyByZW5kZXJlck5hbWUpXG4gICAgICAgIC5yZXBsYWNlKC9bXlxcdy1dL2csICctJylcbiAgICAgICAgLnJlcGxhY2UoL1stX10rKFswLTlhLXpdKS9naSwgZnVuY3Rpb24gKCQwLCBjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5yZXBsYWNlKCdHUkVFS05VTUVSQUxNQUpVU0NVTEVTJywgJ0dyZWVrTnVtZXJhbE1hanVzY3VsZXMnKVxuICAgICk7XG59O1xuXG5DbGRyUmJuZlJ1bGVTZXQucHJvdG90eXBlID0ge1xuICAgIHRvRnVuY3Rpb25Bc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgaXNTZWVuQnlSdWxlU2V0VHlwZSA9IHt9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJ1bGVUb0V4cHJlc3Npb25Bc3QocnVsZSkge1xuICAgICAgICAgICAgdmFyIGV4cHJlc3Npb25Bc3RzID0gW10sXG4gICAgICAgICAgICAgICAgcmJuZiA9IHJ1bGUucmJuZjtcblxuICAgICAgICAgICAgLy8gXCJJZiBhIHJ1bGUgYm9keSBiZWdpbnMgd2l0aCBhbiBhcG9zdHJvcGhlLCB0aGUgYXBvc3Ryb3BoZSBpcyBpZ25vcmVkLCBidXQgYWxsIHRleHQgYWZ0ZXIgaXQgYmVjb21lc1xuICAgICAgICAgICAgLy8gc2lnbmlmaWNhbnQgKHRoaXMgaXMgaG93IHlvdSBjYW4gaGF2ZSBhIHJ1bGUncyBydWxlIHRleHQgYmVnaW4gd2l0aCB3aGl0ZXNwYWNlKS5cIlxuICAgICAgICAgICAgLy8gLS0gaHR0cDovL3d3dy5pY3UtcHJvamVjdC5vcmcvYXBpcmVmL2ljdTRjL2NsYXNzUnVsZUJhc2VkTnVtYmVyRm9ybWF0Lmh0bWxcbiAgICAgICAgICAgIHJibmYgPSByYm5mLnJlcGxhY2UoL14nLywgJycpO1xuXG4gICAgICAgICAgICB2YXIgcmFkaXggPSBydWxlLnJhZGl4IHx8IDEwO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXREaXZpc29yKCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXZpc29yID0gMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMTAgKiBkaXZpc29yIDw9IHBhcnNlSW50KHJ1bGUudmFsdWUsIDEwKSkgeyAvLyBJbmVmZmljaWVudCwgYnV0IHdvbid0IHN1ZmZlciBmcm9tIE1hdGgubG9nIHJvdW5kaW5nIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICBkaXZpc29yICo9IDEwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGl2aXNvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVwbGFjZSBpcyB1c2VkIGZvciB0b2tlbml6YXRpb24sIHRoZSByZXR1cm4gdmFsdWUgaXNuJ3QgdXNlZDpcbiAgICAgICAgICAgIHJibmYucmVwbGFjZSgvKD86KFtcXDxcXD5cXD1dKSg/OiglJT9bXFx3XFwtXSspfChbIywwLl0rKSk/XFwxKXwoPzpcXFsoW15cXF1dKylcXF0pfChbXFx4N2YtXFx1ZmZmZjonXFwuXFxzXFx3XFxkXFwtXSspL2dpLCBmdW5jdGlvbiAoJDAsIHNwZWNpYWxDaGFyLCBvdGhlckZvcm1hdCwgZGVjaW1hbEZvcm1hdCwgb3B0aW9uYWwsIGxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWVhbmluZ3Mgb2YgdGhlIHN1YnN0aXR1dGlvbiB0b2tlbiBjaGFyYWN0ZXJzIGFyZSBhcyBmb2xsb3dzOlxuICAgICAgICAgICAgICAgIGlmIChzcGVjaWFsQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWNpYWxDaGFyID09PSAnPCcpIHsgLy8gPDxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXlxcZCskLy50ZXN0KHJ1bGUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gbm9ybWFsIHJ1bGU6IERpdmlkZSB0aGUgbnVtYmVyIGJ5IHRoZSBydWxlJ3MgZGl2aXNvciBhbmQgZm9ybWF0IHRoZSBxdW90aWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSBbJ2NhbGwnLCBbJ2RvdCcsIFsnbmFtZScsICdNYXRoJ10sICdmbG9vciddLCBbWydiaW5hcnknLCAnLycsIFsnbmFtZScsICduJ10sIFsnbnVtJywgZ2V0RGl2aXNvcigpXV1dXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocnVsZS52YWx1ZSA9PT0gJy14Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignPDwgbm90IGFsbG93ZWQgaW4gbmVnYXRpdmUgbnVtYmVyIHJ1bGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gZnJhY3Rpb24gb3IgbWFzdGVyIHJ1bGU6IElzb2xhdGUgdGhlIG51bWJlcidzIGludGVncmFsIHBhcnQgYW5kIGZvcm1hdCBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gWydjYWxsJywgWydkb3QnLCBbJ25hbWUnLCAnTWF0aCddLCAnZmxvb3InXSwgW1snbmFtZScsICduJ11dXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzcGVjaWFsQ2hhciA9PT0gJz4nKSB7IC8vID4+XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoL1xcLi8udGVzdChydWxlLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZyYWN0aW9uIG9yIG1hc3RlciBydWxlID0+IHBhcnNlSW50KFN0cmluZyhuKS5yZXBsYWNlKC9cXGQqXFwuLywgJycpLCAxMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gWydjYWxsJywgWyduYW1lJywgJ3BhcnNlSW50J10sIFtbJ2NhbGwnLCBbJ2RvdCcsIFsnY2FsbCcsIFsnbmFtZScsICdTdHJpbmcnXSwgW1snbmFtZScsICduJ11dXSwgJ3JlcGxhY2UnXSwgW1sncmVnZXhwJywgJ1xcXFxkKlxcXFwuJywgJyddLCBbJ3N0cmluZycsICcnXV1dLCBbJ251bScsIDEwXV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChydWxlLnZhbHVlID09PSAnLXgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IFsndW5hcnktcHJlZml4JywgJy0nLCBbJ25hbWUnLCAnbiddXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IFsnYmluYXJ5JywgJyUnLCBbJ25hbWUnLCAnbiddLCBbJ251bScsIGdldERpdmlzb3IoKV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNpYWxDaGFyID09PSAnPScpIHsgLy8gPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSBbJ25hbWUnLCAnbiddO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiA+Pj4gbm90IHN1cHBvcnRlZFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzdWJzdGl0dXRpb24gZGVzY3JpcHRvciAoaS5lLiwgdGhlIHRleHQgYmV0d2VlbiB0aGUgdG9rZW4gY2hhcmFjdGVycykgbWF5IHRha2Ugb25lIG9mIHRocmVlIGZvcm1zOlxuICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgcnVsZSBzZXQgbmFtZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gdGhlIG1hdGhlbWF0aWNhbCBvcGVyYXRpb24gb24gdGhlIG51bWJlciwgYW5kIGZvcm1hdCB0aGUgcmVzdWx0IHVzaW5nIHRoZSBuYW1lZCBydWxlIHNldC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdGhlckZvcm1hdE5hbWUgPSBDbGRyUmJuZlJ1bGVTZXQuZ2V0U2FmZVJlbmRlcmVyTmFtZShvdGhlckZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NlZW5CeVJ1bGVTZXRUeXBlW290aGVyRm9ybWF0TmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHVybiBpbnRvIHRoaXMuPG90aGVyRm9ybWF0TmFtZT4oPGV4cHI+KVxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbkFzdHMucHVzaChbJ2NhbGwnLCBbJ2RvdCcsIFsnbmFtZScsICd0aGlzJ10sIG90aGVyRm9ybWF0TmFtZV0sIFtleHByXV0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRlY2ltYWxGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgRGVjaW1hbEZvcm1hdCBwYXR0ZXJuOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGVyZm9ybSB0aGUgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBvbiB0aGUgbnVtYmVyLCBhbmQgZm9ybWF0IHRoZSByZXN1bHQgdXNpbmcgYSBEZWNpbWFsRm9ybWF0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIHRoZSBzcGVjaWZpZWQgcGF0dGVybi4gVGhlIHBhdHRlcm4gbXVzdCBiZWdpbiB3aXRoIDAgb3IgIy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25Bc3RzLnB1c2goWydjYWxsJywgWydkb3QnLCBbJ25hbWUnLCAndGhpcyddLCAncmVuZGVyTnVtYmVyJ10sIFtleHByLCBbJ3N0cmluZycsIGRlY2ltYWxGb3JtYXRdXV0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGVjaWFsQ2hhciA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgeW91IG9taXQgdGhlIHN1YnN0aXR1dGlvbiBkZXNjcmlwdG9yIGluIGEgPj4gc3Vic3RpdHV0aW9uIGluIGEgZnJhY3Rpb24gcnVsZSwgZm9ybWF0IHRoZSByZXN1bHQgb25lIGRpZ2l0IGF0IGEgdGltZSB1c2luZyB0aGUgcnVsZSBzZXQgY29udGFpbmluZyB0aGUgY3VycmVudCBydWxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25Bc3RzLnB1c2goWydjYWxsJywgWydkb3QnLCBbJ25hbWUnLCAndGhpcyddLCB0aGF0LnR5cGVdLCBbZXhwcl1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY2lhbENoYXIgPT09ICc8Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHlvdSBvbWl0IHRoZSBzdWJzdGl0dXRpb24gZGVzY3JpcHRvciBpbiBhIDw8IHN1YnN0aXR1dGlvbiBpbiBhIHJ1bGUgaW4gYSBmcmFjdGlvbiBydWxlIHNldCwgZm9ybWF0IHRoZSByZXN1bHQgdXNpbmcgdGhlIGRlZmF1bHQgcnVsZSBzZXQgZm9yIHRoaXMgcmVuZGVyZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IFNob3VsZCBiZSB0aGUgZGVmYXVsdCBydWxlIHNldCBmb3IgdGhpcyByZW5kZXJlciFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uQXN0cy5wdXNoKFsnY2FsbCcsIFsnZG90JywgWyduYW1lJywgJ3RoaXMnXSwgdGhhdC50eXBlXSwgW2V4cHJdXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignPT0gbm90IHN1cHBvcnRlZCEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25hbCkgeyAvLyBbIC4uLiBdXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25hbFJ1bGVFeHByZXNzaW9uQXN0ID0gcnVsZVRvRXhwcmVzc2lvbkFzdCh7cmFkaXg6IHJ1bGUucmFkaXgsIHJibmY6IG9wdGlvbmFsLCB2YWx1ZTogcnVsZS52YWx1ZX0pO1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uQXN0cy5wdXNoKFsnY29uZGl0aW9uYWwnLCBbJ2JpbmFyeScsICc9PT0nLCBbJ25hbWUnLCAnbiddLCBbJ251bScsIHBhcnNlSW50KHJ1bGUudmFsdWUsIDEwKV1dLCBbJ3N0cmluZycsICcnXSwgb3B0aW9uYWxSdWxlRXhwcmVzc2lvbkFzdF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uQXN0cy5wdXNoKFsnc3RyaW5nJywgbGl0ZXJhbF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdG9rZW4gaW4gXCIgKyBydWxlLnJibmYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25Bc3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25Bc3RzID0gW1snc3RyaW5nJywgJyddXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBleHByZXNzaW9uQXN0ID0gZXhwcmVzc2lvbkFzdHMuc2hpZnQoKTtcbiAgICAgICAgICAgIHdoaWxlIChleHByZXNzaW9uQXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbkFzdCA9IFsnYmluYXJ5JywgJysnLCBleHByZXNzaW9uQXN0LCBleHByZXNzaW9uQXN0cy5zaGlmdCgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uQXN0O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29uZGl0aW9uVG9TdGF0ZW1lbnRBc3QoY29uZGl0aW9uQXN0LCBydWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gWydpZicsIGNvbmRpdGlvbkFzdCwgWydyZXR1cm4nLCBydWxlVG9FeHByZXNzaW9uQXN0KHJ1bGUpXSwgbnVsbF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhdGVtZW50QXN0cyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5ydWxlQnlWYWx1ZVsneC4wJ10gfHwgdGhpcy5ydWxlQnlWYWx1ZVsneC54J10pIHtcbiAgICAgICAgICAgIC8vIHZhciBpc0ZyYWN0aW9uYWwgPSBuICE9PSBNYXRoLmZsb29yKG4pO1xuICAgICAgICAgICAgc3RhdGVtZW50QXN0cy5wdXNoKFsndmFyJywgW1snaXNGcmFjdGlvbmFsJywgWydiaW5hcnknLCAnIT09JywgWyduYW1lJywgJ24nXSwgWydjYWxsJywgWydkb3QnLCBbJ25hbWUnLCAnTWF0aCddLCAnZmxvb3InXSwgW1snbmFtZScsICduJ11dXV1dXV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJ1bGVCeVZhbHVlWyd4LjAnXSkge1xuICAgICAgICAgICAgc3RhdGVtZW50QXN0cy5wdXNoKGNvbmRpdGlvblRvU3RhdGVtZW50QXN0KFsnbmFtZScsICdpc0ZyYWN0aW9uYWwnXSwgdGhpcy5ydWxlQnlWYWx1ZVsneC4wJ10pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ydWxlQnlWYWx1ZVsnLXgnXSkge1xuICAgICAgICAgICAgc3RhdGVtZW50QXN0cy5wdXNoKGNvbmRpdGlvblRvU3RhdGVtZW50QXN0KFsnYmluYXJ5JywgJzwnLCBbJ25hbWUnLCAnbiddLCBbJ251bScsIDBdXSwgdGhpcy5ydWxlQnlWYWx1ZVsnLXgnXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJ1bGVCeVZhbHVlWyd4LngnXSkge1xuICAgICAgICAgICAgc3RhdGVtZW50QXN0cy5wdXNoKGNvbmRpdGlvblRvU3RhdGVtZW50QXN0KFsnYmluYXJ5JywgJyYmJywgWyduYW1lJywgJ2lzRnJhY3Rpb25hbCddLCBbJ2JpbmFyeScsICc+JywgWyduYW1lJywgJ24nXSwgWydudW0nLCAxXV1dLCB0aGlzLnJ1bGVCeVZhbHVlWyd4LngnXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJ1bGVCeVZhbHVlWycwLngnXSkge1xuICAgICAgICAgICAgc3RhdGVtZW50QXN0cy5wdXNoKGNvbmRpdGlvblRvU3RhdGVtZW50QXN0KFsnYmluYXJ5JywgJyYmJywgWydiaW5hcnknLCAnPicsIFsnbmFtZScsICduJ10sIFsnbnVtJywgMF1dLCBbJ2JpbmFyeScsICc8JywgWyduYW1lJywgJ24nXSwgWydudW0nLCAxXV1dLCB0aGlzLnJ1bGVCeVZhbHVlWycwLngnXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5ydWxlQnlWYWx1ZSkuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIC9eXFxkKyQvLnRlc3QodmFsdWUpO1xuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIgLSBhO1xuICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChudW1lcmljYWxWYWx1ZSkge1xuICAgICAgICAgICAgc3RhdGVtZW50QXN0cy5wdXNoKGNvbmRpdGlvblRvU3RhdGVtZW50QXN0KFsnYmluYXJ5JywgJz49JywgWyduYW1lJywgJ24nXSwgWydudW0nLCBudW1lcmljYWxWYWx1ZV1dLCB0aGlzLnJ1bGVCeVZhbHVlW251bWVyaWNhbFZhbHVlXSkpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4ge2Z1bmN0aW9uQXN0OiBbJ2Z1bmN0aW9uJywgbnVsbCwgWyduJ10sIHN0YXRlbWVudEFzdHNdLCBkZXBlbmRlbmNpZXM6IE9iamVjdC5rZXlzKGlzU2VlbkJ5UnVsZVNldFR5cGUpfTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsZHJSYm5mUnVsZVNldDtcbiIsInZhciBQYXRoID0gcmVxdWlyZSgncGF0aCcpLFxuICAgIGZzID0gcmVxdWlyZSgnZnMnKSxcbiAgICBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpLFxuICAgIHBhc3NFcnJvciA9IHJlcXVpcmUoJ3Bhc3NlcnJvcicpLFxuICAgIG1lbW9pemVBc3luYyA9IHJlcXVpcmUoJy4vbWVtb2l6ZUFzeW5jJyksXG4gICAgZG9tID0gcmVxdWlyZSgneG1sZG9tJykuRE9NUGFyc2VyLFxuICAgIHhwYXRoID0gcmVxdWlyZSgneHBhdGgnKSxcbiAgICBzZXEgPSByZXF1aXJlKCdzZXEnKSxcbiAgICBub3JtYWxpemVMb2NhbGVJZCA9IHJlcXVpcmUoJy4vbm9ybWFsaXplTG9jYWxlSWQnKSxcbiAgICBub3JtYWxpemVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vbm9ybWFsaXplUHJvcGVydHknKSxcbiAgICBjb252ZXJ0T2JqZWN0c1dpdGhJbnRlZ2VyS2V5c1RvQXJyYXlzID0gcmVxdWlyZSgnLi9jb252ZXJ0T2JqZWN0c1dpdGhJbnRlZ2VyS2V5c1RvQXJyYXlzJyksXG4gICAgQ2xkclBsdXJhbFJ1bGVTZXQgPSByZXF1aXJlKCcuL0NsZHJQbHVyYWxSdWxlU2V0JyksXG4gICAgQ2xkclJibmZSdWxlU2V0ID0gcmVxdWlyZSgnLi9DbGRyUmJuZlJ1bGVTZXQnKSxcbiAgICB1Z2xpZnlKcyA9IHJlcXVpcmUoJ3VnbGlmeS1qcycpLFxuICAgIHVuaWNvZGVyZWdleHAgPSByZXF1aXJlKCd1bmljb2RlcmVnZXhwJyk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVhQYXRoUXVlcnkoeHBhdGhRdWVyeSkge1xuICAgIHZhciB4cGF0aFF1ZXJ5RnJhZ21lbnRzID0geHBhdGhRdWVyeS5zcGxpdCgnLycpO1xuICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IHhwYXRoUXVlcnlGcmFnbWVudHMubGVuZ3RoIDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChpID4gMCAmJiB4cGF0aFF1ZXJ5RnJhZ21lbnRzW2ldID09PSAnLi4nICYmIHhwYXRoUXVlcnlGcmFnbWVudHNbaSAtIDFdICE9PSAnLi4nKSB7XG4gICAgICAgICAgICB4cGF0aFF1ZXJ5RnJhZ21lbnRzLnNwbGljZShpIC0gMSwgMik7XG4gICAgICAgICAgICBpIC09IDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHhwYXRoUXVlcnlGcmFnbWVudHMuam9pbignLycpO1xufVxuXG5mdW5jdGlvbiBleHBhbmRMb2NhbGVJZFRvUHJpb3JpdGl6ZWRMaXN0KGxvY2FsZUlkKSB7XG4gICAgbG9jYWxlSWQgPSBub3JtYWxpemVMb2NhbGVJZChsb2NhbGVJZCk7XG4gICAgaWYgKCFsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciBsb2NhbGVJZHMgPSBbbG9jYWxlSWRdO1xuICAgIHdoaWxlICgvX1teX10rJC8udGVzdChsb2NhbGVJZCkpIHtcbiAgICAgICAgbG9jYWxlSWQgPSBsb2NhbGVJZC5yZXBsYWNlKC9fW15fXSskLywgJycpO1xuICAgICAgICBsb2NhbGVJZHMucHVzaChsb2NhbGVJZCk7XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGVJZHM7XG59XG5cbmZ1bmN0aW9uIENsZHIoY2xkclBhdGgpIHtcbiAgICAvLyBTdXBwb3J0IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycgb3BlcmF0b3I6XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENsZHIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2xkcihjbGRyUGF0aCk7XG4gICAgfVxuICAgIHRoaXMuY2xkclBhdGggPSBjbGRyUGF0aDtcbiAgICB0aGlzLmRvY3VtZW50QnlGaWxlTmFtZSA9IHt9O1xuICAgIHRoaXMubWVtb2l6ZXJCeUZpbGVOYW1lID0ge307XG59XG5cbkNsZHIucHJvdG90eXBlID0ge1xuICAgIGdldCBmaWxlTmFtZXNCeVR5cGVBbmROb3JtYWxpemVkTG9jYWxlSWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmlsZU5hbWVzQnlUeXBlQW5kTm9ybWFsaXplZExvY2FsZUlkKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxlTmFtZXNCeVR5cGVBbmROb3JtYWxpemVkTG9jYWxlSWQgPSB7fTtcbiAgICAgICAgICAgIFsnbWFpbicsICdyYm5mJ10uZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGVOYW1lc0J5VHlwZUFuZE5vcm1hbGl6ZWRMb2NhbGVJZFt0eXBlXSA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciBmaWxlTmFtZXM7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWVzID0gZnMucmVhZGRpclN5bmMoUGF0aC5yZXNvbHZlKHRoaXMuY2xkclBhdGgsIFwiY29tbW9uXCIsIHR5cGUpKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXJlY3RvcnkgZG9lc24ndCBleGlzdCwganVzdCBwcmV0ZW5kIGl0J3MgZW1wdHkuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmlsZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaEZpbGVOYW1lID0gZmlsZU5hbWUubWF0Y2goL14oLiopXFwueG1sJC8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hGaWxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlsZU5hbWVzQnlUeXBlQW5kTm9ybWFsaXplZExvY2FsZUlkW3R5cGVdW25vcm1hbGl6ZUxvY2FsZUlkKG1hdGNoRmlsZU5hbWVbMV0pXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUGF0aC5yZXNvbHZlKHRoaXMuY2xkclBhdGgsIFwiY29tbW9uXCIsIHR5cGUsIGZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGVOYW1lc0J5VHlwZUFuZE5vcm1hbGl6ZWRMb2NhbGVJZDtcbiAgICB9LFxuXG4gICAgZ2V0IGxvY2FsZUlkcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2NhbGVJZHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsZUlkcyA9IE9iamVjdC5rZXlzKHRoaXMuZmlsZU5hbWVzQnlUeXBlQW5kTm9ybWFsaXplZExvY2FsZUlkLm1haW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGVJZHM7XG4gICAgfSxcblxuICAgIGdldCBjYWxlbmRhcklkcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxlbmRhcklkcykge1xuICAgICAgICAgICAgdGhpcy5fY2FsZW5kYXJJZHMgPSBbXTtcbiAgICAgICAgICAgIHhwYXRoLnNlbGVjdCgnL2xkbWxCQ1A0Ny9rZXl3b3JkL2tleVtAbmFtZT1cImNhXCJdL3R5cGUnLCB0aGlzLmdldERvY3VtZW50KFBhdGgucmVzb2x2ZSh0aGlzLmNsZHJQYXRoLCAnY29tbW9uJywgJ2JjcDQ3JywgJ2NhbGVuZGFyLnhtbCcpKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5Tm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBjYWxlbmRhcklkID0ga2V5Tm9kZS5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsZW5kYXJJZCA9PT0gJ2dyZWdvcnknKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFySWQgPSAnZ3JlZ29yaWFuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsZW5kYXJJZHMucHVzaChjYWxlbmRhcklkKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxlbmRhcklkcztcbiAgICB9LFxuXG4gICAgZ2V0IG51bWJlclN5c3RlbUlkcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9udW1iZXJTeXN0ZW1JZHMpIHtcbiAgICAgICAgICAgIHRoaXMuX251bWJlclN5c3RlbUlkcyA9IFtdO1xuICAgICAgICAgICAgeHBhdGguc2VsZWN0KCcvbGRtbEJDUDQ3L2tleXdvcmQva2V5W0BuYW1lPVwibnVcIl0vdHlwZScsIHRoaXMuZ2V0RG9jdW1lbnQoUGF0aC5yZXNvbHZlKHRoaXMuY2xkclBhdGgsICdjb21tb24nLCAnYmNwNDcnLCAnbnVtYmVyLnhtbCcpKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX251bWJlclN5c3RlbUlkcy5wdXNoKGtleU5vZGUuZ2V0QXR0cmlidXRlKCduYW1lJykpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX251bWJlclN5c3RlbUlkcztcbiAgICB9LFxuXG4gICAgLy8gV29ya3MgYm90aCBhc3luYyBhbmQgc3luYyAob21pdCBjYik6XG4gICAgZ2V0RG9jdW1lbnQ6IGZ1bmN0aW9uIChmaWxlTmFtZSwgY2IpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBpZiAodGhhdC5kb2N1bWVudEJ5RmlsZU5hbWVbZmlsZU5hbWVdKSB7XG4gICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IobnVsbCwgdGhhdC5kb2N1bWVudEJ5RmlsZU5hbWVbZmlsZU5hbWVdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuZG9jdW1lbnRCeUZpbGVOYW1lW2ZpbGVOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBub3QgdG8gbG9hZCBmaWxlIG1vcmUgdGhhbiBvbmNlIGlmIGl0J3MgYmVpbmcgbG9hZGVkIHdoZW4gZ2V0RG9jdW1lbnQgaXMgY2FsbGVkIGZvciB0aGUgc2Vjb25kIHRpbWU6XG4gICAgICAgICAgICAgICAgdGhhdC5tZW1vaXplckJ5RmlsZU5hbWVbZmlsZU5hbWVdID0gdGhhdC5tZW1vaXplckJ5RmlsZU5hbWVbZmlsZU5hbWVdIHx8IG1lbW9pemVBc3luYyhmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgZnMucmVhZEZpbGUoZmlsZU5hbWUsICd1dGYtOCcsIHBhc3NFcnJvcihjYiwgZnVuY3Rpb24gKHhtbFN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvY3VtZW50ID0gbmV3IGRvbSgpLnBhcnNlRnJvbVN0cmluZyh4bWxTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5kb2N1bWVudEJ5RmlsZU5hbWVbZmlsZU5hbWVdID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYihudWxsLCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGF0Lm1lbW9pemVyQnlGaWxlTmFtZVtmaWxlTmFtZV0oY2IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5kb2N1bWVudEJ5RmlsZU5hbWVbZmlsZU5hbWVdID0gbmV3IGRvbSgpLnBhcnNlRnJvbVN0cmluZyhmcy5yZWFkRmlsZVN5bmMoZmlsZU5hbWUsICd1dGYtOCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZTogZnVuY3Rpb24gKGxvY2FsZUlkLCB0eXBlKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGV4cGFuZExvY2FsZUlkVG9Qcmlvcml0aXplZExpc3QobG9jYWxlSWQpLmNvbmNhdCgncm9vdCcpLm1hcChmdW5jdGlvbiAoc3ViTG9jYWxlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGF0LmZpbGVOYW1lc0J5VHlwZUFuZE5vcm1hbGl6ZWRMb2NhbGVJZFt0eXBlXVtub3JtYWxpemVMb2NhbGVJZChzdWJMb2NhbGVJZCldO1xuICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGZpbGVOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gISFmaWxlTmFtZTtcbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChmaWxlTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoYXQuZ2V0RG9jdW1lbnQoZmlsZU5hbWUpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcHJlbG9hZDogZnVuY3Rpb24gKGxvY2FsZUlkcywgY2IpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsZUlkcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IgPSBsb2NhbGVJZHM7XG4gICAgICAgICAgICBsb2NhbGVJZHMgPSB0aGF0LmxvY2FsZUlkcztcbiAgICAgICAgfVxuICAgICAgICBsb2NhbGVJZHMgPSAoQXJyYXkuaXNBcnJheShsb2NhbGVJZHMpID8gbG9jYWxlSWRzIDogW2xvY2FsZUlkc10pLm1hcChub3JtYWxpemVMb2NhbGVJZCk7XG4gICAgICAgIHZhciBuZWVkZWRMb2NhbGVCeUlkID0ge3Jvb3Q6IHRydWV9O1xuICAgICAgICBsb2NhbGVJZHMuZm9yRWFjaChmdW5jdGlvbiAobG9jYWxlSWQpIHtcbiAgICAgICAgICAgIGV4cGFuZExvY2FsZUlkVG9Qcmlvcml0aXplZExpc3QobG9jYWxlSWQpLmZvckVhY2goZnVuY3Rpb24gKHN1YkxvY2FsZUlkKSB7XG4gICAgICAgICAgICAgICAgbmVlZGVkTG9jYWxlQnlJZFtzdWJMb2NhbGVJZF0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZmlsZU5hbWVzID0gW1xuICAgICAgICAgICAgUGF0aC5yZXNvbHZlKHRoYXQuY2xkclBhdGgsICdjb21tb24nLCAnc3VwcGxlbWVudGFsJywgJ3BsdXJhbHMueG1sJyksXG4gICAgICAgICAgICBQYXRoLnJlc29sdmUodGhhdC5jbGRyUGF0aCwgJ2NvbW1vbicsICdzdXBwbGVtZW50YWwnLCAnbnVtYmVyaW5nU3lzdGVtcy54bWwnKVxuICAgICAgICBdO1xuICAgICAgICBPYmplY3Qua2V5cyhuZWVkZWRMb2NhbGVCeUlkKS5mb3JFYWNoKGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuICAgICAgICAgICAgWydtYWluJywgJ3JibmYnXS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gdGhhdC5maWxlTmFtZXNCeVR5cGVBbmROb3JtYWxpemVkTG9jYWxlSWRbdHlwZV1bbG9jYWxlSWRdO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZXMucHVzaChmaWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXEoZmlsZU5hbWVzKVxuICAgICAgICAgICAgLnBhckVhY2goMjAsIGZ1bmN0aW9uIChmaWxlTmFtZSkge1xuICAgICAgICAgICAgICAgIHRoYXQuZ2V0RG9jdW1lbnQoZmlsZU5hbWUsIHRoaXMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zZXEoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGNiKTtcbiAgICB9LFxuXG4gICAgY3JlYXRlRmluZGVyOiBmdW5jdGlvbiAocHJpb3JpdGl6ZWREb2N1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGZpbmRlcih4cGF0aFF1ZXJ5KSB7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdGl6ZWRSZXN1bHRzID0gW107XG4gICAgICAgICAgICBwcmlvcml0aXplZERvY3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChkb2N1bWVudCwgaSkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHRzRm9yTG9jYWxlRG9jdW1lbnQgPSB4cGF0aC5zZWxlY3QoeHBhdGhRdWVyeSwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzRm9yTG9jYWxlRG9jdW1lbnQubGVuZ3RoID09PSAwICYmIGkgPT09IChwcmlvcml0aXplZERvY3VtZW50cy5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSdyZSBpbiByb290IGFuZCB0aGVyZSB3ZXJlIG5vIHJlc3VsdHMsIGxvb2sgZm9yIGFsaWFzIGVsZW1lbnRzIGluIHBhdGg6XG4gICAgICAgICAgICAgICAgICAgIHZhciBxdWVyeUZyYWdtZW50cyA9IHhwYXRoUXVlcnkuc3BsaXQoJy8nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcHBlZFF1ZXJ5RnJhZ21lbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChxdWVyeUZyYWdtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxpYXNOb2RlcyA9IHhwYXRoLnNlbGVjdChxdWVyeUZyYWdtZW50cy5qb2luKCcvJykgKyAnL2FsaWFzJywgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsaWFzTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbGlhc1NwZWNpZmllZFF1ZXJ5ID0gbm9ybWFsaXplWFBhdGhRdWVyeShxdWVyeUZyYWdtZW50cy5qb2luKCcvJykgKyAnLycgKyBhbGlhc05vZGVzWzBdLmdldEF0dHJpYnV0ZSgncGF0aCcpICsgJy8nICsgcG9wcGVkUXVlcnlGcmFnbWVudHMuam9pbignLycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShwcmlvcml0aXplZFJlc3VsdHMsIGZpbmRlcihhbGlhc1NwZWNpZmllZFF1ZXJ5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3BwZWRRdWVyeUZyYWdtZW50cy51bnNoaWZ0KHF1ZXJ5RnJhZ21lbnRzLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHByaW9yaXRpemVkUmVzdWx0cywgcmVzdWx0c0ZvckxvY2FsZURvY3VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwcmlvcml0aXplZFJlc3VsdHM7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGV4dHJhY3RMb2NhbGVEaXNwbGF5UGF0dGVybjogZnVuY3Rpb24gKGxvY2FsZUlkKSB7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIGxvY2FsZURpc3BsYXlQYXR0ZXJuID0ge307XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2xvY2FsZURpc3BsYXlOYW1lcy9sb2NhbGVEaXNwbGF5UGF0dGVybi8qXCIpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGxvY2FsZURpc3BsYXlQYXR0ZXJuW25vZGUubm9kZU5hbWVdID0gbm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsb2NhbGVEaXNwbGF5UGF0dGVybjtcbiAgICB9LFxuXG4gICAgZXh0cmFjdExhbmd1YWdlRGlzcGxheU5hbWVzOiBmdW5jdGlvbiAobG9jYWxlSWQpIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgbGFuZ3VhZ2VEaXNwbGF5TmFtZXMgPSB7fTtcbiAgICAgICAgZmluZGVyKCcvbGRtbC9sb2NhbGVEaXNwbGF5TmFtZXMvbGFuZ3VhZ2VzL2xhbmd1YWdlJykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIGlkID0gbm9ybWFsaXplTG9jYWxlSWQobm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSk7XG4gICAgICAgICAgICBsYW5ndWFnZURpc3BsYXlOYW1lc1tpZF0gPSBsYW5ndWFnZURpc3BsYXlOYW1lc1tpZF0gfHwgbm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZURpc3BsYXlOYW1lcztcbiAgICB9LFxuXG4gICAgZXh0cmFjdFRpbWVab25lRGlzcGxheU5hbWVzOiBmdW5jdGlvbiAobG9jYWxlSWQpIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgdGltZVpvbmVEaXNwbGF5TmFtZXMgPSB7fTtcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvZGF0ZXMvdGltZVpvbmVOYW1lcy96b25lXCIpLmZvckVhY2goZnVuY3Rpb24gKHpvbmVOb2RlKSB7XG4gICAgICAgICAgICB2YXIgdGltZVpvbmVJZCA9IHpvbmVOb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpLFxuICAgICAgICAgICAgICAgIGV4ZW1wbGFyQ2l0eU5vZGVzID0geHBhdGguc2VsZWN0KFwiZXhlbXBsYXJDaXR5XCIsIHpvbmVOb2RlKSxcbiAgICAgICAgICAgICAgICB0ek5hbWVMb2NhbGU7XG4gICAgICAgICAgICBpZiAoZXhlbXBsYXJDaXR5Tm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHR6TmFtZUxvY2FsZSA9IGV4ZW1wbGFyQ2l0eU5vZGVzWzBdLnRleHRDb250ZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2VuZXJpY0Rpc3BsYXlOYW1lTm9kZXMgPSB4cGF0aC5zZWxlY3QoXCJsb25nL2dlbmVyaWNcIiwgem9uZU5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChnZW5lcmljRGlzcGxheU5hbWVOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHR6TmFtZUxvY2FsZSA9IGdlbmVyaWNEaXNwbGF5TmFtZU5vZGVzWzBdLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb25nRGlzcGxheU5hbWVOb2RlcyA9IHhwYXRoLnNlbGVjdChcImxvbmcvc3RhbmRhcmRcIiwgem9uZU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9uZ0Rpc3BsYXlOYW1lTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHpOYW1lTG9jYWxlID0gbG9uZ0Rpc3BsYXlOYW1lTm9kZXNbMF0udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHpOYW1lTG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgdGltZVpvbmVEaXNwbGF5TmFtZXNbdGltZVpvbmVJZF0gPSB0aW1lWm9uZURpc3BsYXlOYW1lc1t0aW1lWm9uZUlkXSB8fCB0ek5hbWVMb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGltZVpvbmVEaXNwbGF5TmFtZXM7XG4gICAgfSxcblxuICAgIGV4dHJhY3RUaW1lWm9uZUZvcm1hdHM6IGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICB0aW1lWm9uZUZvcm1hdHMgPSB7fTtcbiAgICAgICAgWydob3VyRm9ybWF0JywgJ2dtdEZvcm1hdCcsICdnbXRaZXJvRm9ybWF0JywgJ3JlZ2lvbkZvcm1hdCcsICdmYWxsYmFja0Zvcm1hdCcsICdmYWxsYmFja1JlZ2lvbkZvcm1hdCddLmZvckVhY2goZnVuY3Rpb24gKHRhZ05hbWUpIHtcbiAgICAgICAgICAgIGZpbmRlcihcIi9sZG1sL2RhdGVzL3RpbWVab25lTmFtZXMvXCIgKyB0YWdOYW1lKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdE5hbWUgPSBub2RlLm5vZGVOYW1lLnJlcGxhY2UoL0Zvcm1hdCQvLCAnJyksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0TmFtZSA9PT0gJ2hvdXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzsnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGltZVpvbmVGb3JtYXRzW2Zvcm1hdE5hbWVdID0gdGltZVpvbmVGb3JtYXRzW2Zvcm1hdE5hbWVdIHx8IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC9kYXRlcy90aW1lWm9uZU5hbWVzL3JlZ2lvbkZvcm1hdFtAdHlwZV1cIikuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBub2RlLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICAgICAgdGltZVpvbmVGb3JtYXRzLnJlZ2lvbnMgPSB0aW1lWm9uZUZvcm1hdHMucmVnaW9ucyB8fCB7fTtcbiAgICAgICAgICAgIHRpbWVab25lRm9ybWF0cy5yZWdpb25zW3R5cGVdID0gdGltZVpvbmVGb3JtYXRzLnJlZ2lvbnNbdHlwZV0gfHwgbm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aW1lWm9uZUZvcm1hdHM7XG4gICAgfSxcblxuICAgIGV4dHJhY3RUZXJyaXRvcnlEaXNwbGF5TmFtZXM6IGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICB0ZXJyaXRvcnlEaXNwbGF5TmFtZXMgPSB7fTtcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvbG9jYWxlRGlzcGxheU5hbWVzL3RlcnJpdG9yaWVzL3RlcnJpdG9yeVwiKS5mb3JFYWNoKGZ1bmN0aW9uICh0ZXJyaXRvcnlOb2RlKSB7XG4gICAgICAgICAgICB2YXIgdGVycml0b3J5SWQgPSB0ZXJyaXRvcnlOb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICAgICAgdGVycml0b3J5RGlzcGxheU5hbWVzW3RlcnJpdG9yeUlkXSA9IHRlcnJpdG9yeURpc3BsYXlOYW1lc1t0ZXJyaXRvcnlJZF0gfHwgdGVycml0b3J5Tm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0ZXJyaXRvcnlEaXNwbGF5TmFtZXM7XG4gICAgfSxcblxuICAgIGV4dHJhY3RDdXJyZW5jeUluZm9CeUlkOiBmdW5jdGlvbiAobG9jYWxlSWQpIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgY3VycmVuY3lEaXNwbGF5TmFtZUJ5Q3VycmVuY3lJZCA9IHt9LFxuICAgICAgICAgICAgY3VycmVuY3lEaXNwbGF5TmFtZUJ5Q3VycmVuY3lJZEFuZENvdW50ID0ge30sXG4gICAgICAgICAgICBjdXJyZW5jeVN5bWJvbEJ5Q3VycmVuY3lJZCA9IHt9O1xuXG4gICAgICAgIGZpbmRlcihcIi9sZG1sL251bWJlcnMvY3VycmVuY2llcy9jdXJyZW5jeS9kaXNwbGF5TmFtZVwiKS5mb3JFYWNoKGZ1bmN0aW9uIChkaXNwbGF5TmFtZU5vZGUpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW5jeUlkID0gZGlzcGxheU5hbWVOb2RlLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyksXG4gICAgICAgICAgICAgICAgY291bnRBdHRyaWJ1dGUgPSBkaXNwbGF5TmFtZU5vZGUuZ2V0QXR0cmlidXRlKCdjb3VudCcpO1xuICAgICAgICAgICAgaWYgKGNvdW50QXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVuY3lEaXNwbGF5TmFtZUJ5Q3VycmVuY3lJZEFuZENvdW50W2N1cnJlbmN5SWRdID0gY3VycmVuY3lEaXNwbGF5TmFtZUJ5Q3VycmVuY3lJZEFuZENvdW50W2N1cnJlbmN5SWRdIHx8IHt9O1xuICAgICAgICAgICAgICAgIGN1cnJlbmN5RGlzcGxheU5hbWVCeUN1cnJlbmN5SWRBbmRDb3VudFtjdXJyZW5jeUlkXVtjb3VudEF0dHJpYnV0ZV0gPSBkaXNwbGF5TmFtZU5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbmN5RGlzcGxheU5hbWVCeUN1cnJlbmN5SWRbY3VycmVuY3lJZF0gPSBjdXJyZW5jeURpc3BsYXlOYW1lQnlDdXJyZW5jeUlkW2N1cnJlbmN5SWRdIHx8IGRpc3BsYXlOYW1lTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZmluZGVyKFwiL2xkbWwvbnVtYmVycy9jdXJyZW5jaWVzL2N1cnJlbmN5L3N5bWJvbFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChzeW1ib2xOb2RlKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVuY3lJZCA9IHN5bWJvbE5vZGUucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgICAgIGN1cnJlbmN5U3ltYm9sQnlDdXJyZW5jeUlkW2N1cnJlbmN5SWRdID0gY3VycmVuY3lTeW1ib2xCeUN1cnJlbmN5SWRbY3VycmVuY3lJZF0gfHwgc3ltYm9sTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGN1cnJlbmN5SW5mb0J5SWQgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoY3VycmVuY3lEaXNwbGF5TmFtZUJ5Q3VycmVuY3lJZCkuZm9yRWFjaChmdW5jdGlvbiAoY3VycmVuY3lJZCkge1xuICAgICAgICAgICAgY3VycmVuY3lJbmZvQnlJZFtjdXJyZW5jeUlkXSA9IF8uZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogY3VycmVuY3lEaXNwbGF5TmFtZUJ5Q3VycmVuY3lJZFtjdXJyZW5jeUlkXSxcbiAgICAgICAgICAgICAgICBzeW1ib2w6IGN1cnJlbmN5U3ltYm9sQnlDdXJyZW5jeUlkW2N1cnJlbmN5SWRdXG4gICAgICAgICAgICB9LCBjdXJyZW5jeURpc3BsYXlOYW1lQnlDdXJyZW5jeUlkQW5kQ291bnRbY3VycmVuY3lJZF0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbmN5SW5mb0J5SWQ7XG4gICAgfSxcblxuICAgIGV4dHJhY3RTY3JpcHREaXNwbGF5TmFtZXM6IGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBzY3JpcHREaXNwbGF5TmFtZXMgPSB7fTtcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvbG9jYWxlRGlzcGxheU5hbWVzL3NjcmlwdHMvc2NyaXB0XCIpLmZvckVhY2goZnVuY3Rpb24gKHNjcmlwdE5vZGUpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHNjcmlwdE5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgICAgICBzY3JpcHREaXNwbGF5TmFtZXNbaWRdID0gc2NyaXB0RGlzcGxheU5hbWVzW2lkXSB8fCBzY3JpcHROb2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNjcmlwdERpc3BsYXlOYW1lcztcbiAgICB9LFxuXG4gICAgZXh0cmFjdEtleVR5cGVzOiBmdW5jdGlvbiAobG9jYWxlSWQpIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAga2V5VHlwZXMgPSB7fTtcbiAgICAgICAgZmluZGVyKCcvbGRtbC9sb2NhbGVEaXNwbGF5TmFtZXMva2V5cy9rZXknKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXlOb2RlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGtleU5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgICAgICBrZXlUeXBlc1t0eXBlXSA9IHsgZGlzcGxheU5hbWU6IGtleU5vZGUudGV4dENvbnRlbnQgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbmRlcignL2xkbWwvbG9jYWxlRGlzcGxheU5hbWVzL3R5cGVzL3R5cGUnKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlTm9kZSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IHR5cGVOb2RlLmdldEF0dHJpYnV0ZSgna2V5JyksXG4gICAgICAgICAgICAgICAgdHlwZSA9IG5vcm1hbGl6ZVByb3BlcnR5KHR5cGVOb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpKTtcbiAgICAgICAgICAgIGtleVR5cGVzW2tleV0gPSBrZXlUeXBlc1trZXldIHx8IHt9O1xuICAgICAgICAgICAga2V5VHlwZXNba2V5XS50eXBlcyA9IGtleVR5cGVzW2tleV0udHlwZXMgfHwge307XG4gICAgICAgICAgICBrZXlUeXBlc1trZXldLnR5cGVzW3R5cGVdID0gdHlwZU5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ga2V5VHlwZXM7XG4gICAgfSxcblxuICAgIGV4dHJhY3RUcmFuc2Zvcm1OYW1lczogZnVuY3Rpb24gKGxvY2FsZUlkKSB7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIHRyYW5zZm9ybU5hbWVzID0ge307XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2xvY2FsZURpc3BsYXlOYW1lcy90cmFuc2Zvcm1OYW1lcy90cmFuc2Zvcm1OYW1lXCIpLmZvckVhY2goZnVuY3Rpb24gKHRyYW5zZm9ybU5hbWVOb2RlKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSB0cmFuc2Zvcm1OYW1lTm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybU5hbWVzW2lkXSA9IHRyYW5zZm9ybU5hbWVzW2lkXSB8fCB0cmFuc2Zvcm1OYW1lTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1OYW1lcztcbiAgICB9LFxuXG4gICAgZXh0cmFjdE1lYXN1cmVtZW50U3lzdGVtTmFtZXM6IGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBtZWFzdXJlbWVudFN5c3RlbU5hbWVzID0ge307XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2xvY2FsZURpc3BsYXlOYW1lcy9tZWFzdXJlbWVudFN5c3RlbU5hbWVzL21lYXN1cmVtZW50U3lzdGVtTmFtZVwiKS5mb3JFYWNoKGZ1bmN0aW9uIChtZWFzdXJlbWVudFN5c3RlbU5hbWVOb2RlKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBtZWFzdXJlbWVudFN5c3RlbU5hbWVOb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICAgICAgbWVhc3VyZW1lbnRTeXN0ZW1OYW1lc1tpZF0gPSBtZWFzdXJlbWVudFN5c3RlbU5hbWVzW2lkXSB8fCBtZWFzdXJlbWVudFN5c3RlbU5hbWVOb2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1lYXN1cmVtZW50U3lzdGVtTmFtZXM7XG4gICAgfSxcblxuICAgIGV4dHJhY3RDb2RlUGF0dGVybnM6IGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBjb2RlUGF0dGVybnMgPSB7fTtcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvbG9jYWxlRGlzcGxheU5hbWVzL2NvZGVQYXR0ZXJucy9jb2RlUGF0dGVyblwiKS5mb3JFYWNoKGZ1bmN0aW9uIChjb2RlUGF0dGVybk5vZGUpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IGNvZGVQYXR0ZXJuTm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgICAgIGNvZGVQYXR0ZXJuc1tpZF0gPSBjb2RlUGF0dGVybnNbaWRdIHx8IGNvZGVQYXR0ZXJuTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb2RlUGF0dGVybnM7XG4gICAgfSxcblxuICAgIC8vIENhbGVuZGFyIGV4dHJhY3Rpb24gbWV0aG9kczpcblxuICAgIGV4dHJhY3RFcmFOYW1lczogZnVuY3Rpb24gKGxvY2FsZUlkLCBjYWxlbmRhcklkKSB7XG4gICAgICAgIGNhbGVuZGFySWQgPSBjYWxlbmRhcklkIHx8ICdncmVnb3JpYW4nO1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBlcmFOYW1lcztcbiAgICAgICAgWydlcmFOYW1lcycsICdlcmFBYmJyJ10uZm9yRWFjaChmdW5jdGlvbiAoZXJhVHlwZSkge1xuICAgICAgICAgICAgdmFyIHR5cGVJbk91dHB1dCA9IHtlcmFOYW1lczogJ3dpZGUnLCBlcmFBYmJyOiAnYWJicmV2aWF0ZWQnfVtlcmFUeXBlXTtcbiAgICAgICAgICAgIGZpbmRlcihcIi9sZG1sL2RhdGVzL2NhbGVuZGFycy9jYWxlbmRhcltAdHlwZT0nXCIgKyBjYWxlbmRhcklkICsgXCInXS9lcmFzL1wiICsgZXJhVHlwZSArIFwiL2VyYVwiKS5mb3JFYWNoKGZ1bmN0aW9uIChlcmFOb2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBwYXJzZUludChlcmFOb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpLCAxMCk7XG4gICAgICAgICAgICAgICAgZXJhTmFtZXMgPSBlcmFOYW1lcyB8fCB7fTtcbiAgICAgICAgICAgICAgICBlcmFOYW1lc1t0eXBlSW5PdXRwdXRdID0gZXJhTmFtZXNbdHlwZUluT3V0cHV0XSB8fCB7fTtcbiAgICAgICAgICAgICAgICBlcmFOYW1lc1t0eXBlSW5PdXRwdXRdW3R5cGVdID0gZXJhTmFtZXNbdHlwZUluT3V0cHV0XVt0eXBlXSB8fCBlcmFOb2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29udmVydE9iamVjdHNXaXRoSW50ZWdlcktleXNUb0FycmF5cyhlcmFOYW1lcyk7XG4gICAgfSxcblxuICAgIGV4dHJhY3RRdWFydGVyTmFtZXM6IGZ1bmN0aW9uIChsb2NhbGVJZCwgY2FsZW5kYXJJZCkge1xuICAgICAgICBjYWxlbmRhcklkID0gY2FsZW5kYXJJZCB8fCAnZ3JlZ29yaWFuJztcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgcXVhcnRlck5hbWVzO1xuICAgICAgICBbJ2Zvcm1hdCcsICdzdGFuZC1hbG9uZSddLmZvckVhY2goZnVuY3Rpb24gKHF1YXJ0ZXJDb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcXVhcnRlckNvbnRleHRDYW1lbENhc2UgPSBub3JtYWxpemVQcm9wZXJ0eShxdWFydGVyQ29udGV4dCk7IC8vIHN0YW5kLWFsb25lID0+IHN0YW5kQWxvbmVcbiAgICAgICAgICAgIFsnYWJicmV2aWF0ZWQnLCAnbmFycm93JywgJ3dpZGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChxdWFydGVyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBmaW5kZXIoXCIvbGRtbC9kYXRlcy9jYWxlbmRhcnMvY2FsZW5kYXJbQHR5cGU9J1wiICsgY2FsZW5kYXJJZCArIFwiJ10vcXVhcnRlcnMvcXVhcnRlckNvbnRleHRbQHR5cGU9J1wiICsgcXVhcnRlckNvbnRleHQgKyBcIiddL3F1YXJ0ZXJXaWR0aFtAdHlwZT0nXCIgKyBxdWFydGVyV2lkdGggKyBcIiddL3F1YXJ0ZXJcIikuZm9yRWFjaChmdW5jdGlvbiAocXVhcnRlck5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHF1YXJ0ZXJObyA9IHBhcnNlSW50KHF1YXJ0ZXJOb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpLCAxMCkgLSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIHF1YXJ0ZXJOYW1lcyA9IHF1YXJ0ZXJOYW1lcyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgcXVhcnRlck5hbWVzW3F1YXJ0ZXJDb250ZXh0Q2FtZWxDYXNlXSA9IHF1YXJ0ZXJOYW1lc1txdWFydGVyQ29udGV4dENhbWVsQ2FzZV0gfHwge307XG4gICAgICAgICAgICAgICAgICAgIHF1YXJ0ZXJOYW1lc1txdWFydGVyQ29udGV4dENhbWVsQ2FzZV1bcXVhcnRlcldpZHRoXSA9IHF1YXJ0ZXJOYW1lc1txdWFydGVyQ29udGV4dENhbWVsQ2FzZV1bcXVhcnRlcldpZHRoXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgcXVhcnRlck5hbWVzW3F1YXJ0ZXJDb250ZXh0Q2FtZWxDYXNlXVtxdWFydGVyV2lkdGhdW3F1YXJ0ZXJOb10gPSBxdWFydGVyTmFtZXNbcXVhcnRlckNvbnRleHRDYW1lbENhc2VdW3F1YXJ0ZXJXaWR0aF1bcXVhcnRlck5vXSB8fCBxdWFydGVyTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRPYmplY3RzV2l0aEludGVnZXJLZXlzVG9BcnJheXMocXVhcnRlck5hbWVzKTtcbiAgICB9LFxuXG4gICAgZXh0cmFjdERheVBlcmlvZHM6IGZ1bmN0aW9uIChsb2NhbGVJZCwgY2FsZW5kYXJJZCkge1xuICAgICAgICBjYWxlbmRhcklkID0gY2FsZW5kYXJJZCB8fCAnZ3JlZ29yaWFuJztcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgZGF5UGVyaW9kcztcbiAgICAgICAgWydmb3JtYXQnLCAnc3RhbmQtYWxvbmUnXS5mb3JFYWNoKGZ1bmN0aW9uIChkYXlQZXJpb2RDb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgZGF5UGVyaW9kQ29udGV4dENhbWVsQ2FzZSA9IG5vcm1hbGl6ZVByb3BlcnR5KGRheVBlcmlvZENvbnRleHQpOyAvLyBzdGFuZC1hbG9uZSA9PiBzdGFuZEFsb25lXG4gICAgICAgICAgICBbJ2FiYnJldmlhdGVkJywgJ25hcnJvdycsICd3aWRlJywgJ3Nob3J0J10uZm9yRWFjaChmdW5jdGlvbiAoZGF5UGVyaW9kV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBmaW5kZXIoXCIvbGRtbC9kYXRlcy9jYWxlbmRhcnMvY2FsZW5kYXJbQHR5cGU9J1wiICsgY2FsZW5kYXJJZCArIFwiJ10vZGF5UGVyaW9kcy9kYXlQZXJpb2RDb250ZXh0W0B0eXBlPSdcIiArIGRheVBlcmlvZENvbnRleHQgKyBcIiddL2RheVBlcmlvZFdpZHRoW0B0eXBlPSdcIiArIGRheVBlcmlvZFdpZHRoICsgXCInXS9kYXlQZXJpb2RcIikuZm9yRWFjaChmdW5jdGlvbiAoZGF5UGVyaW9kTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGRheVBlcmlvZE5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGF5UGVyaW9kcyA9IGRheVBlcmlvZHMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGRheVBlcmlvZHNbZGF5UGVyaW9kQ29udGV4dENhbWVsQ2FzZV0gPSBkYXlQZXJpb2RzW2RheVBlcmlvZENvbnRleHRDYW1lbENhc2VdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBkYXlQZXJpb2RzW2RheVBlcmlvZENvbnRleHRDYW1lbENhc2VdW2RheVBlcmlvZFdpZHRoXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXlQZXJpb2RzW2RheVBlcmlvZENvbnRleHRDYW1lbENhc2VdW2RheVBlcmlvZFdpZHRoXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgZGF5UGVyaW9kc1tkYXlQZXJpb2RDb250ZXh0Q2FtZWxDYXNlXVtkYXlQZXJpb2RXaWR0aF1bdHlwZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF5UGVyaW9kc1tkYXlQZXJpb2RDb250ZXh0Q2FtZWxDYXNlXVtkYXlQZXJpb2RXaWR0aF1bdHlwZV0gfHwgZGF5UGVyaW9kTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRheVBlcmlvZHM7XG4gICAgfSxcblxuICAgIGV4dHJhY3RDeWNsaWNOYW1lczogZnVuY3Rpb24gKGxvY2FsZUlkLCBjYWxlbmRhcklkKSB7XG4gICAgICAgIGNhbGVuZGFySWQgPSBjYWxlbmRhcklkIHx8ICdncmVnb3JpYW4nO1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBjeWNsaWNOYW1lcztcbiAgICAgICAgWydkYXlQYXJ0cycsICdkYXlzJywgJ21vbnRocycsICd5ZWFycycsICd6b2RpYWNzJ10uZm9yRWFjaChmdW5jdGlvbiAoY3ljbGljTmFtZVNldCkge1xuICAgICAgICAgICAgWydmb3JtYXQnXS5mb3JFYWNoKGZ1bmN0aW9uIChjeWNsaWNOYW1lQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIFsnYWJicmV2aWF0ZWQnLCAnbmFycm93JywgJ3dpZGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChjeWNsaWNOYW1lV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluZGVyKFwiL2xkbWwvZGF0ZXMvY2FsZW5kYXJzL2NhbGVuZGFyW0B0eXBlPSdcIiArIGNhbGVuZGFySWQgKyBcIiddL2N5Y2xpY05hbWVTZXRzL2N5Y2xpY05hbWVTZXRbQHR5cGU9J1wiICsgY3ljbGljTmFtZVNldCArIFwiJ10vY3ljbGljTmFtZUNvbnRleHRbQHR5cGU9J1wiICsgY3ljbGljTmFtZUNvbnRleHQgKyBcIiddL2N5Y2xpY05hbWVXaWR0aFtAdHlwZT0nXCIgKyBjeWNsaWNOYW1lV2lkdGggKyBcIiddL2N5Y2xpY05hbWVcIikuZm9yRWFjaChmdW5jdGlvbiAoY3ljbGljTmFtZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gY3ljbGljTmFtZU5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeWNsaWNOYW1lcyA9IGN5Y2xpY05hbWVzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3ljbGljTmFtZXNbY3ljbGljTmFtZVNldF0gPSBjeWNsaWNOYW1lc1tjeWNsaWNOYW1lU2V0XSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5Y2xpY05hbWVzW2N5Y2xpY05hbWVTZXRdW2N5Y2xpY05hbWVDb250ZXh0XSA9IGN5Y2xpY05hbWVzW2N5Y2xpY05hbWVTZXRdW2N5Y2xpY05hbWVDb250ZXh0XSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5Y2xpY05hbWVzW2N5Y2xpY05hbWVTZXRdW2N5Y2xpY05hbWVDb250ZXh0XVtjeWNsaWNOYW1lV2lkdGhdID0gY3ljbGljTmFtZXNbY3ljbGljTmFtZVNldF1bY3ljbGljTmFtZUNvbnRleHRdW2N5Y2xpY05hbWVXaWR0aF0gfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICBjeWNsaWNOYW1lc1tjeWNsaWNOYW1lU2V0XVtjeWNsaWNOYW1lQ29udGV4dF1bY3ljbGljTmFtZVdpZHRoXVt0eXBlXSA9IGN5Y2xpY05hbWVzW2N5Y2xpY05hbWVTZXRdW2N5Y2xpY05hbWVDb250ZXh0XVtjeWNsaWNOYW1lV2lkdGhdW3R5cGVdIHx8IGN5Y2xpY05hbWVOb2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRPYmplY3RzV2l0aEludGVnZXJLZXlzVG9BcnJheXMoY3ljbGljTmFtZXMpO1xuICAgIH0sXG5cbiAgICBleHRyYWN0TW9udGhOYW1lczogZnVuY3Rpb24gKGxvY2FsZUlkLCBjYWxlbmRhcklkKSB7XG4gICAgICAgIGNhbGVuZGFySWQgPSBjYWxlbmRhcklkIHx8ICdncmVnb3JpYW4nO1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBtb250aE5hbWVzO1xuICAgICAgICBbJ2Zvcm1hdCcsICdzdGFuZC1hbG9uZSddLmZvckVhY2goZnVuY3Rpb24gKG1vbnRoQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIG1vbnRoQ29udGV4dENhbWVsQ2FzZSA9IG5vcm1hbGl6ZVByb3BlcnR5KG1vbnRoQ29udGV4dCk7IC8vIHN0YW5kLWFsb25lID0+IHN0YW5kQWxvbmVcbiAgICAgICAgICAgIFsnYWJicmV2aWF0ZWQnLCAnbmFycm93JywgJ3dpZGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChtb250aFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgZmluZGVyKFwiL2xkbWwvZGF0ZXMvY2FsZW5kYXJzL2NhbGVuZGFyW0B0eXBlPSdcIiArIGNhbGVuZGFySWQgKyBcIiddL21vbnRocy9tb250aENvbnRleHRbQHR5cGU9J1wiICsgbW9udGhDb250ZXh0ICsgXCInXS9tb250aFdpZHRoW0B0eXBlPSdcIiArIG1vbnRoV2lkdGggKyBcIiddL21vbnRoXCIpLmZvckVhY2goZnVuY3Rpb24gKG1vbnRoTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW9udGhObyA9IHBhcnNlSW50KG1vbnRoTm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSwgMTApIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgbW9udGhOYW1lcyA9IG1vbnRoTmFtZXMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoTmFtZXNbbW9udGhDb250ZXh0Q2FtZWxDYXNlXSA9IG1vbnRoTmFtZXNbbW9udGhDb250ZXh0Q2FtZWxDYXNlXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgbW9udGhOYW1lc1ttb250aENvbnRleHRDYW1lbENhc2VdW21vbnRoV2lkdGhdID0gbW9udGhOYW1lc1ttb250aENvbnRleHRDYW1lbENhc2VdW21vbnRoV2lkdGhdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBtb250aE5hbWVzW21vbnRoQ29udGV4dENhbWVsQ2FzZV1bbW9udGhXaWR0aF1bbW9udGhOb10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgbW9udGhOYW1lc1ttb250aENvbnRleHRDYW1lbENhc2VdW21vbnRoV2lkdGhdW21vbnRoTm9dIHx8IG1vbnRoTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRPYmplY3RzV2l0aEludGVnZXJLZXlzVG9BcnJheXMobW9udGhOYW1lcyk7XG4gICAgfSxcblxuICAgIGV4dHJhY3RNb250aFBhdHRlcm5zOiBmdW5jdGlvbiAobG9jYWxlSWQsIGNhbGVuZGFySWQpIHtcbiAgICAgICAgY2FsZW5kYXJJZCA9IGNhbGVuZGFySWQgfHwgJ2dyZWdvcmlhbic7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIG1vbnRoUGF0dGVybnM7XG4gICAgICAgIFsnZm9ybWF0JywgJ251bWVyaWMnLCAnc3RhbmQtYWxvbmUnXS5mb3JFYWNoKGZ1bmN0aW9uIChtb250aFBhdHRlcm5Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbW9udGhQYXR0ZXJuQ29udGV4dENhbWVsQ2FzZSA9IG5vcm1hbGl6ZVByb3BlcnR5KG1vbnRoUGF0dGVybkNvbnRleHQpOyAvLyBzdGFuZC1hbG9uZSA9PiBzdGFuZEFsb25lXG4gICAgICAgICAgICBbJ2FiYnJldmlhdGVkJywgJ25hcnJvdycsICd3aWRlJywgJ2FsbCddLmZvckVhY2goZnVuY3Rpb24gKG1vbnRoUGF0dGVybldpZHRoKSB7XG4gICAgICAgICAgICAgICAgZmluZGVyKFwiL2xkbWwvZGF0ZXMvY2FsZW5kYXJzL2NhbGVuZGFyW0B0eXBlPSdcIiArIGNhbGVuZGFySWQgKyBcIiddL21vbnRoUGF0dGVybnMvbW9udGhQYXR0ZXJuQ29udGV4dFtAdHlwZT0nXCIgKyBtb250aFBhdHRlcm5Db250ZXh0ICsgXCInXS9tb250aFBhdHRlcm5XaWR0aFtAdHlwZT0nXCIgKyBtb250aFBhdHRlcm5XaWR0aCArIFwiJ10vbW9udGhQYXR0ZXJuXCIpLmZvckVhY2goZnVuY3Rpb24gKG1vbnRoUGF0dGVybk5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBtb250aFBhdHRlcm5Ob2RlLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICAgICAgICAgICAgICBtb250aFBhdHRlcm5zID0gbW9udGhQYXR0ZXJucyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgbW9udGhQYXR0ZXJuc1ttb250aFBhdHRlcm5Db250ZXh0Q2FtZWxDYXNlXSA9IG1vbnRoUGF0dGVybnNbbW9udGhQYXR0ZXJuQ29udGV4dENhbWVsQ2FzZV0gfHwge307XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoUGF0dGVybnNbbW9udGhQYXR0ZXJuQ29udGV4dENhbWVsQ2FzZV1bbW9udGhQYXR0ZXJuV2lkdGhdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoUGF0dGVybnNbbW9udGhQYXR0ZXJuQ29udGV4dENhbWVsQ2FzZV1bbW9udGhQYXR0ZXJuV2lkdGhdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBtb250aFBhdHRlcm5zW21vbnRoUGF0dGVybkNvbnRleHRDYW1lbENhc2VdW21vbnRoUGF0dGVybldpZHRoXVt0eXBlXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBtb250aFBhdHRlcm5zW21vbnRoUGF0dGVybkNvbnRleHRDYW1lbENhc2VdW21vbnRoUGF0dGVybldpZHRoXVt0eXBlXSB8fCBtb250aFBhdHRlcm5Ob2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbW9udGhQYXR0ZXJucztcbiAgICB9LFxuXG4gICAgZXh0cmFjdERheU5hbWVzOiBmdW5jdGlvbiAobG9jYWxlSWQsIGNhbGVuZGFySWQpIHtcbiAgICAgICAgY2FsZW5kYXJJZCA9IGNhbGVuZGFySWQgfHwgJ2dyZWdvcmlhbic7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIGRheU5vQnlDbGRySWQgPSB7c3VuOiAwLCBtb246IDEsIHR1ZTogMiwgd2VkOiAzLCB0aHU6IDQsIGZyaTogNSwgc2F0OiA2fSxcbiAgICAgICAgICAgIGRheU5hbWVzO1xuICAgICAgICBbJ2Zvcm1hdCcsICdudW1lcmljJywgJ3N0YW5kLWFsb25lJ10uZm9yRWFjaChmdW5jdGlvbiAoZGF5Q29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGRheUNvbnRleHRDYW1lbENhc2UgPSBub3JtYWxpemVQcm9wZXJ0eShkYXlDb250ZXh0KTsgLy8gc3RhbmQtYWxvbmUgPT4gc3RhbmRBbG9uZVxuICAgICAgICAgICAgWydhYmJyZXZpYXRlZCcsICduYXJyb3cnLCAnd2lkZScsICdzaG9ydCddLmZvckVhY2goZnVuY3Rpb24gKGRheVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgZmluZGVyKFwiL2xkbWwvZGF0ZXMvY2FsZW5kYXJzL2NhbGVuZGFyW0B0eXBlPSdcIiArIGNhbGVuZGFySWQgKyBcIiddL2RheXMvZGF5Q29udGV4dFtAdHlwZT0nXCIgKyBkYXlDb250ZXh0ICsgXCInXS9kYXlXaWR0aFtAdHlwZT0nXCIgKyBkYXlXaWR0aCArIFwiJ10vZGF5XCIpLmZvckVhY2goZnVuY3Rpb24gKGRheU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRheU5vID0gZGF5Tm9CeUNsZHJJZFtkYXlOb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpXTtcbiAgICAgICAgICAgICAgICAgICAgZGF5TmFtZXMgPSBkYXlOYW1lcyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgZGF5TmFtZXNbZGF5Q29udGV4dENhbWVsQ2FzZV0gPSBkYXlOYW1lc1tkYXlDb250ZXh0Q2FtZWxDYXNlXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgZGF5TmFtZXNbZGF5Q29udGV4dENhbWVsQ2FzZV1bZGF5V2lkdGhdID0gZGF5TmFtZXNbZGF5Q29udGV4dENhbWVsQ2FzZV1bZGF5V2lkdGhdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBkYXlOYW1lc1tkYXlDb250ZXh0Q2FtZWxDYXNlXVtkYXlXaWR0aF1bZGF5Tm9dID0gZGF5TmFtZXNbZGF5Q29udGV4dENhbWVsQ2FzZV1bZGF5V2lkdGhdW2RheU5vXSB8fCBkYXlOb2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29udmVydE9iamVjdHNXaXRoSW50ZWdlcktleXNUb0FycmF5cyhkYXlOYW1lcyk7XG4gICAgfSxcblxuICAgIGV4dHJhY3RGaWVsZHM6IGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBmaWVsZHM7XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2RhdGVzL2ZpZWxkcy9maWVsZC9kaXNwbGF5TmFtZVwiKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZERpc3BsYXlOYW1lTm9kZSkge1xuICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkRGlzcGxheU5hbWVOb2RlLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgICAgICBmaWVsZHMgPSBmaWVsZHMgfHwge307XG4gICAgICAgICAgICBmaWVsZHNbZmllbGROYW1lXSA9IGZpZWxkc1tmaWVsZE5hbWVdIHx8IHt9O1xuICAgICAgICAgICAgZmllbGRzW2ZpZWxkTmFtZV0uZGlzcGxheU5hbWUgPSBmaWVsZHNbZmllbGROYW1lXS5kaXNwbGF5TmFtZSB8fCBmaWVsZERpc3BsYXlOYW1lTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZmluZGVyKFwiL2xkbWwvZGF0ZXMvZmllbGRzL2ZpZWxkL3JlbGF0aXZlXCIpLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkUmVsYXRpdmVOb2RlKSB7XG4gICAgICAgICAgICB2YXIgZmllbGROYW1lID0gZmllbGRSZWxhdGl2ZU5vZGUucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSxcbiAgICAgICAgICAgICAgICB0eXBlID0gZmllbGRSZWxhdGl2ZU5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgICAgICBmaWVsZHMgPSBmaWVsZHMgfHwge307XG4gICAgICAgICAgICBmaWVsZHNbZmllbGROYW1lXSA9IGZpZWxkc1tmaWVsZE5hbWVdIHx8IHt9O1xuICAgICAgICAgICAgZmllbGRzW2ZpZWxkTmFtZV0ucmVsYXRpdmUgPSBmaWVsZHNbZmllbGROYW1lXS5yZWxhdGl2ZSB8fCB7fTtcbiAgICAgICAgICAgIGZpZWxkc1tmaWVsZE5hbWVdLnJlbGF0aXZlW3R5cGVdID0gZmllbGRzW2ZpZWxkTmFtZV0ucmVsYXRpdmVbdHlwZV0gfHwgZmllbGRSZWxhdGl2ZU5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2RhdGVzL2ZpZWxkcy9maWVsZC9yZWxhdGl2ZVRpbWUvcmVsYXRpdmVUaW1lUGF0dGVyblwiKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWxhdGl2ZVRpbWVQYXR0ZXJuTm9kZSkge1xuICAgICAgICAgICAgdmFyIHJlbGF0aXZlVGltZU5vZGUgPSByZWxhdGl2ZVRpbWVQYXR0ZXJuTm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgIGZpZWxkTmFtZSA9IHJlbGF0aXZlVGltZU5vZGUucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSxcbiAgICAgICAgICAgICAgICB0eXBlID0gcmVsYXRpdmVUaW1lTm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSxcbiAgICAgICAgICAgICAgICBjb3VudCA9IHJlbGF0aXZlVGltZVBhdHRlcm5Ob2RlLmdldEF0dHJpYnV0ZSgnY291bnQnKTtcbiAgICAgICAgICAgIGZpZWxkcyA9IGZpZWxkcyB8fCB7fTtcbiAgICAgICAgICAgIGZpZWxkc1tmaWVsZE5hbWVdID0gZmllbGRzW2ZpZWxkTmFtZV0gfHwge307XG4gICAgICAgICAgICBmaWVsZHNbZmllbGROYW1lXS5yZWxhdGl2ZVRpbWUgPSBmaWVsZHNbZmllbGROYW1lXS5yZWxhdGl2ZVRpbWUgfHwge307XG4gICAgICAgICAgICBmaWVsZHNbZmllbGROYW1lXS5yZWxhdGl2ZVRpbWVbdHlwZV0gPSBmaWVsZHNbZmllbGROYW1lXS5yZWxhdGl2ZVRpbWVbdHlwZV0gfHwge307XG4gICAgICAgICAgICBmaWVsZHNbZmllbGROYW1lXS5yZWxhdGl2ZVRpbWVbdHlwZV1bY291bnRdID0gZmllbGRzW2ZpZWxkTmFtZV0ucmVsYXRpdmVUaW1lW3R5cGVdW2NvdW50XSB8fCByZWxhdGl2ZVRpbWVQYXR0ZXJuTm9kZS50ZXh0Q29udGVudFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpZWxkcztcbiAgICB9LFxuXG4gICAgZXh0cmFjdERhdGVUaW1lUGF0dGVybnM6IGZ1bmN0aW9uIChsb2NhbGVJZCwgY2FsZW5kYXJJZCkge1xuICAgICAgICBjYWxlbmRhcklkID0gY2FsZW5kYXJJZCB8fCAnZ3JlZ29yaWFuJztcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgZGF0ZVRpbWVQYXR0ZXJucztcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvZGF0ZXMvY2FsZW5kYXJzL2NhbGVuZGFyW0B0eXBlPSdcIiArIGNhbGVuZGFySWQgKyBcIiddL2RhdGVUaW1lRm9ybWF0cy9kYXRlVGltZUZvcm1hdExlbmd0aC9kYXRlVGltZUZvcm1hdFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRlVGltZUZvcm1hdE5vZGUpIHtcbiAgICAgICAgICAgIHZhciBkYXRlVGltZUZvcm1hdExlbmd0aFR5cGUgPSBkYXRlVGltZUZvcm1hdE5vZGUucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSxcbiAgICAgICAgICAgICAgICBwYXR0ZXJuTm9kZXMgPSB4cGF0aC5zZWxlY3QoXCJwYXR0ZXJuXCIsIGRhdGVUaW1lRm9ybWF0Tm9kZSk7XG4gICAgICAgICAgICBpZiAocGF0dGVybk5vZGVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZXhhY3RseSBvbmUgcGF0dGVybiBpbiBkYXRlVGltZUZvcm1hdE5vZGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGVUaW1lUGF0dGVybnMgPSBkYXRlVGltZVBhdHRlcm5zIHx8IHt9O1xuICAgICAgICAgICAgZGF0ZVRpbWVQYXR0ZXJuc1tkYXRlVGltZUZvcm1hdExlbmd0aFR5cGVdID0gZGF0ZVRpbWVQYXR0ZXJuc1tkYXRlVGltZUZvcm1hdExlbmd0aFR5cGVdIHx8IHBhdHRlcm5Ob2Rlc1swXS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRlVGltZVBhdHRlcm5zO1xuICAgIH0sXG5cbiAgICBleHRyYWN0RGF0ZU9yVGltZUZvcm1hdHM6IGZ1bmN0aW9uIChsb2NhbGVJZCwgY2FsZW5kYXJJZCwgZGF0ZU9yVGltZSkge1xuICAgICAgICBjYWxlbmRhcklkID0gY2FsZW5kYXJJZCB8fCAnZ3JlZ29yaWFuJztcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgZm9ybWF0cztcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvZGF0ZXMvY2FsZW5kYXJzL2NhbGVuZGFyW0B0eXBlPSdcIiArIGNhbGVuZGFySWQgKyBcIiddL1wiICsgZGF0ZU9yVGltZSArIFwiRm9ybWF0cy9cIiArIGRhdGVPclRpbWUgKyBcIkZvcm1hdExlbmd0aC9cIiArIGRhdGVPclRpbWUgKyBcIkZvcm1hdC8qXCIpLmZvckVhY2goZnVuY3Rpb24gKHBhdHRlcm5Ob2RlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHBhdHRlcm5Ob2RlLnBhcmVudE5vZGUucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgICAgIGZvcm1hdHMgPSBmb3JtYXRzIHx8IHt9O1xuICAgICAgICAgICAgZm9ybWF0c1t0eXBlXSA9IGZvcm1hdHNbdHlwZV0gfHwgcGF0dGVybk5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZm9ybWF0cztcbiAgICB9LFxuXG4gICAgZXh0cmFjdERhdGVGb3JtYXRzOiBmdW5jdGlvbiAobG9jYWxlSWQsIGNhbGVuZGFySWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdERhdGVPclRpbWVGb3JtYXRzKGxvY2FsZUlkLCBjYWxlbmRhcklkLCAnZGF0ZScpO1xuICAgIH0sXG5cbiAgICBleHRyYWN0VGltZUZvcm1hdHM6IGZ1bmN0aW9uIChsb2NhbGVJZCwgY2FsZW5kYXJJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHRyYWN0RGF0ZU9yVGltZUZvcm1hdHMobG9jYWxlSWQsIGNhbGVuZGFySWQsICd0aW1lJyk7XG4gICAgfSxcblxuICAgIGV4dHJhY3REYXRlRm9ybWF0SXRlbXM6IGZ1bmN0aW9uIChsb2NhbGVJZCwgY2FsZW5kYXJJZCkge1xuICAgICAgICBjYWxlbmRhcklkID0gY2FsZW5kYXJJZCB8fCAnZ3JlZ29yaWFuJztcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgZGF0ZUZvcm1hdEl0ZW1zO1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC9kYXRlcy9jYWxlbmRhcnMvY2FsZW5kYXJbQHR5cGU9J1wiICsgY2FsZW5kYXJJZCArIFwiJ10vZGF0ZVRpbWVGb3JtYXRzL2F2YWlsYWJsZUZvcm1hdHMvZGF0ZUZvcm1hdEl0ZW1cIikuZm9yRWFjaChmdW5jdGlvbiAoZGF0ZUZvcm1hdEl0ZW1Ob2RlKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBkYXRlRm9ybWF0SXRlbU5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgZGF0ZUZvcm1hdEl0ZW1zID0gZGF0ZUZvcm1hdEl0ZW1zIHx8IHt9O1xuICAgICAgICAgICAgZGF0ZUZvcm1hdEl0ZW1zW2lkXSA9IGRhdGVGb3JtYXRJdGVtc1tpZF0gfHwgZGF0ZUZvcm1hdEl0ZW1Ob2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGVGb3JtYXRJdGVtcztcbiAgICB9LFxuXG4gICAgZXh0cmFjdERhdGVJbnRlcnZhbEZvcm1hdHM6IGZ1bmN0aW9uIChsb2NhbGVJZCwgY2FsZW5kYXJJZCkge1xuICAgICAgICBjYWxlbmRhcklkID0gY2FsZW5kYXJJZCB8fCAnZ3JlZ29yaWFuJztcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgZGF0ZUludGVydmFsRm9ybWF0cztcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvZGF0ZXMvY2FsZW5kYXJzL2NhbGVuZGFyW0B0eXBlPSdcIiArIGNhbGVuZGFySWQgKyBcIiddL2RhdGVUaW1lRm9ybWF0cy9pbnRlcnZhbEZvcm1hdHMvaW50ZXJ2YWxGb3JtYXRJdGVtXCIpLmZvckVhY2goZnVuY3Rpb24gKGludGVydmFsRm9ybWF0SXRlbU5vZGUpIHtcbiAgICAgICAgICAgIHZhciBkYXRlSW50ZXJ2YWxGb3JtYXQgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGludGVydmFsRm9ybWF0SXRlbU5vZGUuY2hpbGROb2Rlcy5sZW5ndGggOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JlYXRlc3REaWZmZXJlbmNlTm9kZSA9IGludGVydmFsRm9ybWF0SXRlbU5vZGUuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JlYXRlc3REaWZmZXJlbmNlTm9kZS5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2Ugbm9kZVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGdyZWF0ZXN0RGlmZmVyZW5jZUlkQXR0cmlidXRlID0gZ3JlYXRlc3REaWZmZXJlbmNlTm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgICAgICAgICAgdmFyIGdyZWF0ZXN0RGlmZmVyZW5jZUlkID0gZ3JlYXRlc3REaWZmZXJlbmNlSWRBdHRyaWJ1dGU7XG4gICAgICAgICAgICAgICAgZGF0ZUludGVydmFsRm9ybWF0W2dyZWF0ZXN0RGlmZmVyZW5jZUlkXSA9IGRhdGVJbnRlcnZhbEZvcm1hdFtncmVhdGVzdERpZmZlcmVuY2VJZF0gfHwgZ3JlYXRlc3REaWZmZXJlbmNlTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpZCA9IGludGVydmFsRm9ybWF0SXRlbU5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgZGF0ZUludGVydmFsRm9ybWF0cyA9IGRhdGVJbnRlcnZhbEZvcm1hdHMgfHwge307XG4gICAgICAgICAgICBkYXRlSW50ZXJ2YWxGb3JtYXRzW2lkXSA9IGRhdGVJbnRlcnZhbEZvcm1hdHNbaWRdIHx8IGRhdGVJbnRlcnZhbEZvcm1hdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRlSW50ZXJ2YWxGb3JtYXRzO1xuICAgIH0sXG5cbiAgICBleHRyYWN0RGF0ZUludGVydmFsRmFsbGJhY2tGb3JtYXQ6IGZ1bmN0aW9uIChsb2NhbGVJZCwgY2FsZW5kYXJJZCkge1xuICAgICAgICBjYWxlbmRhcklkID0gY2FsZW5kYXJJZCB8fCAnZ3JlZ29yaWFuJztcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgZGF0ZUludGVydmFsRmFsbGJhY2tGb3JtYXQ7XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2RhdGVzL2NhbGVuZGFycy9jYWxlbmRhcltAdHlwZT0nXCIgKyBjYWxlbmRhcklkICsgXCInXS9kYXRlVGltZUZvcm1hdHMvaW50ZXJ2YWxGb3JtYXRzL2ludGVydmFsRm9ybWF0RmFsbGJhY2tcIikuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJ2YWxGb3JtYXRGYWxsYmFja05vZGUpIHtcbiAgICAgICAgICAgIGRhdGVJbnRlcnZhbEZhbGxiYWNrRm9ybWF0ID0gZGF0ZUludGVydmFsRmFsbGJhY2tGb3JtYXQgfHwgaW50ZXJ2YWxGb3JtYXRGYWxsYmFja05vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0ZUludGVydmFsRmFsbGJhY2tGb3JtYXQ7XG4gICAgfSxcblxuICAgIC8vIE51bWJlciBleHRyYWN0aW9uIGNvZGU6XG5cbiAgICBleHRyYWN0TnVtYmVyU3ltYm9sczogZnVuY3Rpb24gKGxvY2FsZUlkLCBudW1iZXJTeXN0ZW1JZCkge1xuICAgICAgICBudW1iZXJTeXN0ZW1JZCA9IG51bWJlclN5c3RlbUlkIHx8ICdsYXRuJztcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgbnVtYmVyU3ltYm9scztcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvbnVtYmVycy9zeW1ib2xzW0BudW1iZXJTeXN0ZW0gPSAnXCIgKyBudW1iZXJTeXN0ZW1JZCArIFwiJ10vKltuYW1lKCkgIT0gJ2FsaWFzJ11cIikuY29uY2F0KGZpbmRlcihcIi9sZG1sL251bWJlcnMvc3ltYm9scy8qW25hbWUoKSAhPSAnYWxpYXMnXVwiKSkuZm9yRWFjaChmdW5jdGlvbiAobnVtYmVyU3ltYm9sTm9kZSkge1xuICAgICAgICAgICAgdmFyIHN5bWJvbElkID0gbnVtYmVyU3ltYm9sTm9kZS5ub2RlTmFtZTtcbiAgICAgICAgICAgIG51bWJlclN5bWJvbHMgPSBudW1iZXJTeW1ib2xzIHx8IHt9O1xuICAgICAgICAgICAgbnVtYmVyU3ltYm9sc1tzeW1ib2xJZF0gPSBudW1iZXJTeW1ib2xzW3N5bWJvbElkXSB8fCBudW1iZXJTeW1ib2xOb2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG51bWJlclN5bWJvbHM7XG4gICAgfSxcblxuICAgIGV4dHJhY3ROdW1iZXJGb3JtYXRzOiBmdW5jdGlvbiAobG9jYWxlSWQsIG51bWJlclN5c3RlbUlkKSB7XG4gICAgICAgIG51bWJlclN5c3RlbUlkID0gbnVtYmVyU3lzdGVtSWQgfHwgJ2xhdG4nO1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBudW1iZXJGb3JtYXRzO1xuICAgICAgICBbJ3NjaWVudGlmaWMnLCAnZGVjaW1hbCcsICdjdXJyZW5jeScsICdwZXJjZW50J10uZm9yRWFjaChmdW5jdGlvbiAoZm9ybWF0VHlwZSkge1xuICAgICAgICAgICAgWydmdWxsJywgJ2xvbmcnLCAnbWVkaXVtJywgJ3Nob3J0J10uZm9yRWFjaChmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZmluZGVyKFwiL2xkbWwvbnVtYmVycy9cIiArIGZvcm1hdFR5cGUgKyBcIkZvcm1hdHNbQG51bWJlclN5c3RlbSA9ICdcIiArIG51bWJlclN5c3RlbUlkICsgXCInXS9cIiArIGZvcm1hdFR5cGUgKyBcIkZvcm1hdExlbmd0aFtAdHlwZT0nXCIgKyBsZW5ndGggKyBcIiddL1wiICsgZm9ybWF0VHlwZSArIFwiRm9ybWF0L3BhdHRlcm5cIikuZm9yRWFjaChmdW5jdGlvbiAocGF0dGVybk5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBwYXR0ZXJuTm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gcGF0dGVybk5vZGUuZ2V0QXR0cmlidXRlKCdjb3VudCcpO1xuICAgICAgICAgICAgICAgICAgICBudW1iZXJGb3JtYXRzID0gbnVtYmVyRm9ybWF0cyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyRm9ybWF0c1tmb3JtYXRUeXBlXSA9IG51bWJlckZvcm1hdHNbZm9ybWF0VHlwZV0gfHwge307XG4gICAgICAgICAgICAgICAgICAgIG51bWJlckZvcm1hdHNbZm9ybWF0VHlwZV1bbGVuZ3RoXSA9IG51bWJlckZvcm1hdHNbZm9ybWF0VHlwZV1bbGVuZ3RoXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyRm9ybWF0c1tmb3JtYXRUeXBlXVtsZW5ndGhdW3R5cGVdID0gbnVtYmVyRm9ybWF0c1tmb3JtYXRUeXBlXVtsZW5ndGhdW3R5cGVdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBudW1iZXJGb3JtYXRzW2Zvcm1hdFR5cGVdW2xlbmd0aF1bdHlwZV1bY291bnRdID0gbnVtYmVyRm9ybWF0c1tmb3JtYXRUeXBlXVtsZW5ndGhdW3R5cGVdW2NvdW50XSB8fCBwYXR0ZXJuTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmluZGVyKFwiL2xkbWwvbnVtYmVycy9cIiArIGZvcm1hdFR5cGUgKyBcIkZvcm1hdHNbQG51bWJlclN5c3RlbSA9ICdcIiArIG51bWJlclN5c3RlbUlkICsgXCInXS9cIiArIGZvcm1hdFR5cGUgKyBcIkZvcm1hdExlbmd0aFtub3QoQHR5cGUpXS9cIiArIGZvcm1hdFR5cGUgKyBcIkZvcm1hdC9wYXR0ZXJuXCIpLmZvckVhY2goZnVuY3Rpb24gKHBhdHRlcm5Ob2RlKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyRm9ybWF0cyA9IG51bWJlckZvcm1hdHMgfHwge307XG4gICAgICAgICAgICAgICAgbnVtYmVyRm9ybWF0c1tmb3JtYXRUeXBlXSA9IG51bWJlckZvcm1hdHNbZm9ybWF0VHlwZV0gfHwge307XG4gICAgICAgICAgICAgICAgbnVtYmVyRm9ybWF0c1tmb3JtYXRUeXBlXS5kZWZhdWx0ID0gbnVtYmVyRm9ybWF0c1tmb3JtYXRUeXBlXS5kZWZhdWx0IHx8IHBhdHRlcm5Ob2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaW5kZXIoXCIvbGRtbC9udW1iZXJzL1wiICsgZm9ybWF0VHlwZSArIFwiRm9ybWF0c1tAbnVtYmVyU3lzdGVtID0gJ1wiICsgbnVtYmVyU3lzdGVtSWQgKyBcIiddL3VuaXRQYXR0ZXJuXCIpLmZvckVhY2goZnVuY3Rpb24gKHVuaXRQYXR0ZXJuTm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IHVuaXRQYXR0ZXJuTm9kZS5nZXRBdHRyaWJ1dGUoJ2NvdW50Jyk7XG4gICAgICAgICAgICAgICAgbnVtYmVyRm9ybWF0cyA9IG51bWJlckZvcm1hdHMgfHwge307XG4gICAgICAgICAgICAgICAgbnVtYmVyRm9ybWF0c1tmb3JtYXRUeXBlXSA9IG51bWJlckZvcm1hdHNbZm9ybWF0VHlwZV0gfHwge307XG4gICAgICAgICAgICAgICAgbnVtYmVyRm9ybWF0c1tmb3JtYXRUeXBlXVtjb3VudF0gPSBudW1iZXJGb3JtYXRzW2Zvcm1hdFR5cGVdW2NvdW50XSB8fCB1bml0UGF0dGVybk5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZmluZGVyKFwiL2xkbWwvbnVtYmVycy9jdXJyZW5jeUZvcm1hdHNbQG51bWJlclN5c3RlbSA9ICdcIiArIG51bWJlclN5c3RlbUlkICsgXCInXS9jdXJyZW5jeVNwYWNpbmdcIikuZm9yRWFjaChmdW5jdGlvbiAoY3VycmVuY3lTcGFjaW5nTm9kZSkge1xuICAgICAgICAgICAgbnVtYmVyRm9ybWF0cyA9IG51bWJlckZvcm1hdHMgfHwge307XG4gICAgICAgICAgICBudW1iZXJGb3JtYXRzLmN1cnJlbmN5ID0gbnVtYmVyRm9ybWF0cy5jdXJyZW5jeSB8fCB7fTtcbiAgICAgICAgICAgIG51bWJlckZvcm1hdHMuY3VycmVuY3kuY3VycmVuY3lTcGFjaW5nID0gbnVtYmVyRm9ybWF0cy5jdXJyZW5jeS5jdXJyZW5jeVNwYWNpbmcgfHwge307XG5cbiAgICAgICAgICAgIFsnYmVmb3JlJywgJ2FmdGVyJ10uZm9yRWFjaChmdW5jdGlvbiAocGxhY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGxhY2VEYXRhID0gbnVtYmVyRm9ybWF0cy5jdXJyZW5jeS5jdXJyZW5jeVNwYWNpbmdbcGxhY2UgKyAnQ3VycmVuY3knXSA9IG51bWJlckZvcm1hdHMuY3VycmVuY3kuY3VycmVuY3lTcGFjaW5nW3BsYWNlICsgJ0N1cnJlbmN5J10gfHwge307XG5cbiAgICAgICAgICAgICAgICBbJ2N1cnJlbmN5TWF0Y2gnLCAnc3Vycm91bmRpbmdNYXRjaCcsICdpbnNlcnRCZXR3ZWVuJ10uZm9yRWFjaChmdW5jdGlvbiAoc3BhY2luZ1Byb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSB4cGF0aC5zZWxlY3QocGxhY2UgKyBcIkN1cnJlbmN5L1wiICsgc3BhY2luZ1Byb3BlcnR5TmFtZSwgY3VycmVuY3lTcGFjaW5nTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJGb3JtYXRzLmN1cnJlbmN5LmN1cnJlbmN5U3BhY2luZ1twbGFjZSArICdDdXJyZW5jeSddW3NwYWNpbmdQcm9wZXJ0eU5hbWVdID0gbWF0Y2hbMF0udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIFsnY3VycmVuY3lNYXRjaCcsICdzdXJyb3VuZGluZ01hdGNoJ10uZm9yRWFjaChmdW5jdGlvbiAoc3BhY2luZ1Byb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGxhY2VEYXRhW3NwYWNpbmdQcm9wZXJ0eU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZURhdGFbc3BhY2luZ1Byb3BlcnR5TmFtZV0gPSB1bmljb2RlcmVnZXhwLmV4cGFuZENsZHJVbmljb2RlU2V0SWRUb0NoYXJhY3RlckNsYXNzKHBsYWNlRGF0YVtzcGFjaW5nUHJvcGVydHlOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbnVtYmVyRm9ybWF0cztcbiAgICB9LFxuXG4gICAgZXh0cmFjdERlZmF1bHROdW1iZXJTeXN0ZW1JZDogZnVuY3Rpb24gKGxvY2FsZUlkKSB7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIGRlZmF1bHROdW1iZXJTeXN0ZW1JZDtcbiAgICAgICAgZmluZGVyKCcvbGRtbC9udW1iZXJzL2RlZmF1bHROdW1iZXJpbmdTeXN0ZW0nKS5mb3JFYWNoKGZ1bmN0aW9uIChkZWZhdWx0TnVtYmVyaW5nU3lzdGVtTm9kZSkge1xuICAgICAgICAgICAgZGVmYXVsdE51bWJlclN5c3RlbUlkID0gZGVmYXVsdE51bWJlclN5c3RlbUlkIHx8IGRlZmF1bHROdW1iZXJpbmdTeXN0ZW1Ob2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHROdW1iZXJTeXN0ZW1JZDtcbiAgICB9LFxuXG4gICAgZXh0cmFjdFVuaXRQYXR0ZXJuczogZnVuY3Rpb24gKGxvY2FsZUlkKSB7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIHVuaXRQYXR0ZXJucyA9IHt9O1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC91bml0cy91bml0TGVuZ3RoL3VuaXQvdW5pdFBhdHRlcm5cIikuZm9yRWFjaChmdW5jdGlvbiAodW5pdFBhdHRlcm5Ob2RlKSB7XG4gICAgICAgICAgICB2YXIgdW5pdE5vZGUgPSB1bml0UGF0dGVybk5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICB1bml0TGVuZ3RoID0gdW5pdE5vZGUucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSxcbiAgICAgICAgICAgICAgICB1bml0SWQgPSBub3JtYWxpemVQcm9wZXJ0eSh1bml0Tm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSk7XG4gICAgICAgICAgICB1bml0UGF0dGVybnNbdW5pdExlbmd0aF0gPSB1bml0UGF0dGVybnNbdW5pdExlbmd0aF0gfHwge307XG4gICAgICAgICAgICB1bml0UGF0dGVybnNbdW5pdExlbmd0aF0udW5pdCA9IHVuaXRQYXR0ZXJuc1t1bml0TGVuZ3RoXS51bml0IHx8IHt9O1xuICAgICAgICAgICAgdW5pdFBhdHRlcm5zW3VuaXRMZW5ndGhdLnVuaXRbdW5pdElkXSA9IHVuaXRQYXR0ZXJuc1t1bml0TGVuZ3RoXS51bml0W3VuaXRJZF0gfHwge307XG4gICAgICAgICAgICB2YXIgY291bnQgPSB1bml0UGF0dGVybk5vZGUuZ2V0QXR0cmlidXRlKCdjb3VudCcpO1xuICAgICAgICAgICAgdW5pdFBhdHRlcm5zW3VuaXRMZW5ndGhdLnVuaXRbdW5pdElkXVtjb3VudF0gPSB1bml0UGF0dGVybnNbdW5pdExlbmd0aF0udW5pdFt1bml0SWRdW2NvdW50XSB8fCB1bml0UGF0dGVybk5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC91bml0cy91bml0TGVuZ3RoL2NvbXBvdW5kVW5pdC9jb21wb3VuZFVuaXRQYXR0ZXJuXCIpLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvdW5kVW5pdFBhdHRlcm5Ob2RlKSB7XG4gICAgICAgICAgICB2YXIgY29tcG91bmRVbml0Tm9kZSA9IGNvbXBvdW5kVW5pdFBhdHRlcm5Ob2RlLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgdW5pdExlbmd0aCA9IGNvbXBvdW5kVW5pdE5vZGUucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSxcbiAgICAgICAgICAgICAgICBjb21wb3VuZFVuaXRJZCA9IGNvbXBvdW5kVW5pdE5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG5cbiAgICAgICAgICAgIHVuaXRQYXR0ZXJuc1t1bml0TGVuZ3RoXS5jb21wb3VuZFVuaXQgPSB1bml0UGF0dGVybnNbdW5pdExlbmd0aF0uY29tcG91bmRVbml0IHx8IHt9O1xuICAgICAgICAgICAgdW5pdFBhdHRlcm5zW3VuaXRMZW5ndGhdLmNvbXBvdW5kVW5pdFtjb21wb3VuZFVuaXRJZF0gPSBjb21wb3VuZFVuaXRQYXR0ZXJuTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1bml0UGF0dGVybnM7XG4gICAgfSxcblxuICAgIGV4dHJhY3REZWxpbWl0ZXJzOiBmdW5jdGlvbiAobG9jYWxlSWQpIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgZGVsaW1pdGVycyA9IHt9O1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC9kZWxpbWl0ZXJzLypcIikuZm9yRWFjaChmdW5jdGlvbiAoZGVsaW1pdGVyTm9kZSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBkZWxpbWl0ZXJOb2RlLm5vZGVOYW1lO1xuICAgICAgICAgICAgZGVsaW1pdGVyc1t0eXBlXSA9IGRlbGltaXRlcnNbdHlwZV0gfHwgZGVsaW1pdGVyTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZWxpbWl0ZXJzO1xuICAgIH0sXG5cbiAgICBleHRyYWN0TGlzdFBhdHRlcm5zOiBmdW5jdGlvbiAobG9jYWxlSWQpIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgbGlzdFBhdHRlcm5zID0ge307XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2xpc3RQYXR0ZXJucy9saXN0UGF0dGVybi9saXN0UGF0dGVyblBhcnRcIikuZm9yRWFjaChmdW5jdGlvbiAobGlzdFBhdHRlcm5QYXJ0Tm9kZSkge1xuICAgICAgICAgICAgdmFyIGxpc3RQYXR0ZXJuVHlwZUF0dHJpYnV0ZSA9IGxpc3RQYXR0ZXJuUGFydE5vZGUucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSxcbiAgICAgICAgICAgICAgICB0eXBlID0gbGlzdFBhdHRlcm5UeXBlQXR0cmlidXRlID8gbm9ybWFsaXplUHJvcGVydHkobGlzdFBhdHRlcm5UeXBlQXR0cmlidXRlKSA6ICdkZWZhdWx0JyxcbiAgICAgICAgICAgICAgICBwYXJ0ID0gbGlzdFBhdHRlcm5QYXJ0Tm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgICAgIGxpc3RQYXR0ZXJuc1t0eXBlXSA9IGxpc3RQYXR0ZXJuc1t0eXBlXSB8fCB7fTtcbiAgICAgICAgICAgIGxpc3RQYXR0ZXJuc1t0eXBlXVtwYXJ0XSA9IGxpc3RQYXR0ZXJuc1t0eXBlXVtwYXJ0XSB8fCBsaXN0UGF0dGVyblBhcnROb2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGxpc3RQYXR0ZXJucztcbiAgICB9LFxuXG4gICAgZXh0cmFjdENoYXJhY3RlcnM6IGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBjaGFyYWN0ZXJzID0ge1xuICAgICAgICAgICAgICAgIGV4ZW1wbGFyOiB7fSxcbiAgICAgICAgICAgICAgICBlbGxpcHNpczoge31cbiAgICAgICAgICAgIH07XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2NoYXJhY3RlcnMvZXhlbXBsYXJDaGFyYWN0ZXJzXCIpLmZvckVhY2goZnVuY3Rpb24gKGV4ZW1wbGFyQ2hhcmFjdGVyc05vZGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlQXR0ciA9IGV4ZW1wbGFyQ2hhcmFjdGVyc05vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyksXG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGVBdHRyIHx8ICdkZWZhdWx0JztcbiAgICAgICAgICAgIGNoYXJhY3RlcnMuZXhlbXBsYXJbdHlwZV0gPSBjaGFyYWN0ZXJzLmV4ZW1wbGFyW3R5cGVdIHx8IGV4ZW1wbGFyQ2hhcmFjdGVyc05vZGUudGV4dENvbnRlbnQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKS5zcGxpdChcIiBcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC9jaGFyYWN0ZXJzL2VsbGlwc2lzXCIpLmZvckVhY2goZnVuY3Rpb24gKGVsbGlwc2lzTm9kZSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBlbGxpcHNpc05vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgICAgICBjaGFyYWN0ZXJzLmVsbGlwc2lzW3R5cGVdID0gY2hhcmFjdGVycy5lbGxpcHNpc1t0eXBlXSB8fCBlbGxpcHNpc05vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC9jaGFyYWN0ZXJzL21vcmVJbmZvcm1hdGlvblwiKS5mb3JFYWNoKGZ1bmN0aW9uIChtb3JlSW5mb3JtYXRpb25Ob2RlKSB7XG4gICAgICAgICAgICBjaGFyYWN0ZXJzLm1vcmVJbmZvcm1hdGlvbiA9IGNoYXJhY3RlcnMubW9yZUluZm9ybWF0aW9uIHx8IG1vcmVJbmZvcm1hdGlvbk5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2hhcmFjdGVycztcbiAgICB9LFxuXG4gICAgZXh0cmFjdFBsdXJhbFJ1bGVGdW5jdGlvbjogZnVuY3Rpb24gKGxvY2FsZUlkKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIGRvY3VtZW50ID0gdGhhdC5nZXREb2N1bWVudChQYXRoLnJlc29sdmUodGhhdC5jbGRyUGF0aCwgJ2NvbW1vbicsICdzdXBwbGVtZW50YWwnLCAncGx1cmFscy54bWwnKSksXG4gICAgICAgICAgICBzdWJMb2NhbGVJZHMgPSBleHBhbmRMb2NhbGVJZFRvUHJpb3JpdGl6ZWRMaXN0KGxvY2FsZUlkKSxcbiAgICAgICAgICAgIHN0YXRlbWVudEFzdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgc3ViTG9jYWxlSWRzLmxlbmd0aCA7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHN1YkxvY2FsZUlkID0gc3ViTG9jYWxlSWRzW2ldLFxuICAgICAgICAgICAgICAgIG1hdGNoTG9jYWxlc1hQYXRoRXhwciA9XG4gICAgICAgICAgICAgICAgICAgIFwiQGxvY2FsZXMgPSAnXCIgKyBzdWJMb2NhbGVJZCArIFwiJyBvciBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwic3RhcnRzLXdpdGgoQGxvY2FsZXMsICdcIiArIHN1YkxvY2FsZUlkICsgXCInKSBvciBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiY29udGFpbnMoQGxvY2FsZXMsICcgXCIgKyBzdWJMb2NhbGVJZCArIFwiICcpIG9yIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJzdWJzdHJpbmcoQGxvY2FsZXMsIHN0cmluZy1sZW5ndGgoQGxvY2FsZXMpIC0gc3RyaW5nLWxlbmd0aCgnIFwiICsgc3ViTG9jYWxlSWQgKyBcIicpICsgMSkgPSAnIFwiICsgc3ViTG9jYWxlSWQgKyBcIidcIixcbiAgICAgICAgICAgICAgICBwbHVyYWxSdWxlc05vZGVzID0geHBhdGguc2VsZWN0KFwiL3N1cHBsZW1lbnRhbERhdGEvcGx1cmFscy9wbHVyYWxSdWxlc1tcIiArIG1hdGNoTG9jYWxlc1hQYXRoRXhwciArIFwiXVwiLCBkb2N1bWVudCksXG4gICAgICAgICAgICAgICAgY2xkclBsdXJhbFJ1bGVTZXQgPSBuZXcgQ2xkclBsdXJhbFJ1bGVTZXQoKTtcbiAgICAgICAgICAgIGlmIChwbHVyYWxSdWxlc05vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB4cGF0aC5zZWxlY3QoXCJwbHVyYWxSdWxlXCIsIHBsdXJhbFJ1bGVzTm9kZXNbMF0pLmZvckVhY2goZnVuY3Rpb24gKHBsdXJhbFJ1bGVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZHJQbHVyYWxSdWxlU2V0LmFkZFJ1bGUocGx1cmFsUnVsZU5vZGUudGV4dENvbnRlbnQsIHBsdXJhbFJ1bGVOb2RlLmdldEF0dHJpYnV0ZSgnY291bnQnKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdGVtZW50QXN0cyA9IGNsZHJQbHVyYWxSdWxlU2V0LnRvSmF2YVNjcmlwdEZ1bmN0aW9uQm9keUFzdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJuXCIsIHVnbGlmeUpzLnVnbGlmeS5nZW5fY29kZShbJ3RvcGxldmVsJywgc3RhdGVtZW50QXN0c10pKTtcbiAgICB9LFxuXG4gICAgLy8gJ3R5cGVzJyBpcyBvcHRpb25hbCwgZGVmYXVsdHMgdG8gYWxsIGF2YWlsYWJsZVxuICAgIGV4dHJhY3RSYm5mRnVuY3Rpb25CeVR5cGU6IGZ1bmN0aW9uIChsb2NhbGVJZCwgdHlwZXMpIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdyYm5mJykpLFxuICAgICAgICAgICAgY2xkclJibmZSdWxlU2V0QnlUeXBlID0ge307XG4gICAgICAgIGZpbmRlcignL2xkbWwvcmJuZi9ydWxlc2V0R3JvdXBpbmcvcnVsZXNldC9yYm5mcnVsZScpLmZvckVhY2goZnVuY3Rpb24gKHJibmZSdWxlTm9kZSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBDbGRyUmJuZlJ1bGVTZXQuZ2V0U2FmZVJlbmRlcmVyTmFtZShyYm5mUnVsZU5vZGUucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSksXG4gICAgICAgICAgICAgICAgdmFsdWUgPSByYm5mUnVsZU5vZGUuZ2V0QXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgICAgICAgY2xkclJibmZSdWxlU2V0QnlUeXBlW3R5cGVdID0gY2xkclJibmZSdWxlU2V0QnlUeXBlW3R5cGVdIHx8IG5ldyBDbGRyUmJuZlJ1bGVTZXQoe3R5cGU6IHR5cGV9KTtcbiAgICAgICAgICAgIGlmICghY2xkclJibmZSdWxlU2V0QnlUeXBlW3R5cGVdLnJ1bGVCeVZhbHVlW3ZhbHVlXSkge1xuICAgICAgICAgICAgICAgIHZhciByYWRpeEF0dHJpYnV0ZSA9IHJibmZSdWxlTm9kZS5nZXRBdHRyaWJ1dGUoJ3JhZGl4Jyk7XG4gICAgICAgICAgICAgICAgY2xkclJibmZSdWxlU2V0QnlUeXBlW3R5cGVdLnJ1bGVCeVZhbHVlW3ZhbHVlXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICByYm5mOiByYm5mUnVsZU5vZGUudGV4dENvbnRlbnQucmVwbGFjZSgvOyQvLCAnJykucmVwbGFjZSgv4oaQL2csICc8JykucmVwbGFjZSgv4oaSL2csICc+JyksXG4gICAgICAgICAgICAgICAgICAgIHJhZGl4OiByYWRpeEF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaXNBZGRlZEJ5VHlwZSA9IHt9LFxuICAgICAgICAgICAgdHlwZXNUb0FkZCA9IHR5cGVzID8gW10uY29uY2F0KHR5cGVzKSA6IE9iamVjdC5rZXlzKGNsZHJSYm5mUnVsZVNldEJ5VHlwZSksXG4gICAgICAgICAgICByYm5mRnVuY3Rpb25CeVR5cGUgPSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyTnVtYmVyOiBTdHJpbmcgLy8gUHJvdmlkZSBhIChiYWQpIGRlZmF1bHQgbnVtYmVyIHJlbmRlcmluZyBpbXBsZW1lbnRhdGlvbiB0byBhdm9pZCAjMTNcbiAgICAgICAgICAgIH07XG4gICAgICAgIHdoaWxlICh0eXBlc1RvQWRkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZXNUb0FkZC5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKCEodHlwZSBpbiBpc0FkZGVkQnlUeXBlKSkge1xuICAgICAgICAgICAgICAgIGlzQWRkZWRCeVR5cGVbdHlwZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBjbGRyUmJuZlJ1bGVTZXQgPSBjbGRyUmJuZlJ1bGVTZXRCeVR5cGVbdHlwZV07XG4gICAgICAgICAgICAgICAgLy8gU29tZSBydWxlcyBhcmVuJ3QgYXZhaWxhYmxlIGluIHNvbWUgbG9jYWxlcyAoc3VjaCBhcyBzcGVsbG91dC1jYXJkaW5hbC1maW5hbmNpYWwpLlxuICAgICAgICAgICAgICAgIC8vIFRoZSBlYXNpZXN0IHRoaW5nIGlzIGp1c3QgdG8gc2tpcCB0aGUgbWlzc2luZyBvbmVzIGhlcmUsIGV2ZW4gdGhvdWdoIGl0IGNhbiBwcm9kdWNlXG4gICAgICAgICAgICAgICAgLy8gc29tZSBicm9rZW4gZnVuY3Rpb24gc2V0czpcbiAgICAgICAgICAgICAgICBpZiAoY2xkclJibmZSdWxlU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBjbGRyUmJuZlJ1bGVTZXQudG9GdW5jdGlvbkFzdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJibmZGdW5jdGlvbkJ5VHlwZVt0eXBlXSA9IG5ldyBGdW5jdGlvbihcIm5cIiwgdWdsaWZ5SnMudWdsaWZ5Lmdlbl9jb2RlKFsndG9wbGV2ZWwnLCByZXN1bHQuZnVuY3Rpb25Bc3RbM11dKSk7XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHR5cGVzVG9BZGQsIHJlc3VsdC5kZXBlbmRlbmNpZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmJuZkZ1bmN0aW9uQnlUeXBlO1xuICAgIH0sXG5cbiAgICBleHRyYWN0RGlnaXRzQnlOdW1iZXJTeXN0ZW1JZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLmdldERvY3VtZW50KFBhdGgucmVzb2x2ZSh0aGlzLmNsZHJQYXRoLCAnY29tbW9uJywgJ3N1cHBsZW1lbnRhbCcsICdudW1iZXJpbmdTeXN0ZW1zLnhtbCcpKSxcbiAgICAgICAgICAgIGRpZ2l0c0J5TnVtYmVyU3lzdGVtSWQgPSB7fTtcblxuICAgICAgICB4cGF0aC5zZWxlY3QoJy9zdXBwbGVtZW50YWxEYXRhL251bWJlcmluZ1N5c3RlbXMvbnVtYmVyaW5nU3lzdGVtJywgZG9jdW1lbnQpLmZvckVhY2goZnVuY3Rpb24gKG51bWJlcmluZ1N5c3RlbU5vZGUpIHtcbiAgICAgICAgICAgIHZhciBudW1iZXJTeXN0ZW1JZCA9IG51bWJlcmluZ1N5c3RlbU5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgaWYgKG51bWJlcmluZ1N5c3RlbU5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJykgPT09ICdudW1lcmljJykge1xuICAgICAgICAgICAgICAgIGRpZ2l0c0J5TnVtYmVyU3lzdGVtSWRbbnVtYmVyU3lzdGVtSWRdID0gbnVtYmVyaW5nU3lzdGVtTm9kZS5nZXRBdHRyaWJ1dGUoJ2RpZ2l0cycpLnNwbGl0KC8oPzopLyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHR5cGU9J2FsZ29yaXRobWljJ1xuICAgICAgICAgICAgICAgIHZhciBydWxlc0F0dHJpYnV0ZUZyYWdtZW50cyA9IG51bWJlcmluZ1N5c3RlbU5vZGUuZ2V0QXR0cmlidXRlKCdydWxlcycpLnNwbGl0KCcvJyksXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUxvY2FsZUlkID0gcnVsZXNBdHRyaWJ1dGVGcmFnbWVudHMubGVuZ3RoID09PSAzID8gbm9ybWFsaXplTG9jYWxlSWQocnVsZXNBdHRyaWJ1dGVGcmFnbWVudHNbMF0pIDogJ3Jvb3QnLFxuICAgICAgICAgICAgICAgICAgICBydWxlVHlwZSA9IENsZHJSYm5mUnVsZVNldC5nZXRTYWZlUmVuZGVyZXJOYW1lKHJ1bGVzQXR0cmlidXRlRnJhZ21lbnRzW3J1bGVzQXR0cmlidXRlRnJhZ21lbnRzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICBkaWdpdHNCeU51bWJlclN5c3RlbUlkW251bWJlclN5c3RlbUlkXSA9IHJ1bGVUeXBlOyAvLyBBIHN0cmluZyB2YWx1ZSBtZWFucyBcInVzZSB0aGlzIHJibmYgcmVuZGVyZXIgZm9yIHRoZSBkaWdpdHNcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGRpZ2l0c0J5TnVtYmVyU3lzdGVtSWQ7XG4gICAgfSxcblxuICAgIGV4dHJhY3RMYXlvdXQ6IGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBsYXlvdXQgPSB7fTtcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvbGF5b3V0LyovKlwiKS5mb3JFYWNoKGZ1bmN0aW9uIChsZWFmTm9kZSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBsZWFmTm9kZS5ub2RlTmFtZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRUeXBlID0gbGVhZk5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZTtcbiAgICAgICAgICAgIGxheW91dFtwYXJlbnRUeXBlXSA9IGxheW91dFtwYXJlbnRUeXBlXSB8fCB7fTtcbiAgICAgICAgICAgIGxheW91dFtwYXJlbnRUeXBlXVt0eXBlXSA9IGxheW91dFtwYXJlbnRUeXBlXVt0eXBlXSB8fCBsZWFmTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsYXlvdXQ7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgQ2xkcihQYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4vM3JkcGFydHkvY2xkci8nKSk7XG5tb2R1bGUuZXhwb3J0cy5sb2FkID0gZnVuY3Rpb24gKGNsZHJQYXRoKSB7XG4gICAgcmV0dXJuIG5ldyBDbGRyKGNsZHJQYXRoKTtcbn07XG4iLCJleHBvcnRzLmkgPSBmdW5jdGlvbiBpKG4pIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG59O1xuXG5leHBvcnRzLnYgPSBmdW5jdGlvbiB2KG4pIHtcbiAgICByZXR1cm4gbi50b1N0cmluZygpLnJlcGxhY2UoL15bXi5dKlxcLj8vLCAnJykubGVuZ3RoO1xufTtcblxuZXhwb3J0cy53ID0gZnVuY3Rpb24gdyhuKSB7XG4gICAgcmV0dXJuIG4udG9TdHJpbmcoKS5yZXBsYWNlKC9eW14uXSpcXC4/fDArJC9nLCAnJykubGVuZ3RoO1xufTtcblxuZXhwb3J0cy5mID0gZnVuY3Rpb24gZihuKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KG4udG9TdHJpbmcoKS5yZXBsYWNlKC9eW14uXSpcXC4/LywgJycpLCAxMCkgfHwgMDtcbn07XG5cbmV4cG9ydHMudCA9IGZ1bmN0aW9uIHQobikge1xuICAgIHJldHVybiBwYXJzZUludChuLnRvU3RyaW5nKCkucmVwbGFjZSgvXlteLl0qXFwuP3wwKyQvZywgJycpLCAxMCkgfHwgMDtcbn07XG4iLCIvLyBDb252ZXJ0IG9iamVjdHMgd2l0aCBhbGwgaW50ZWdlciBrZXlzIHN0YXJ0aW5nIGZyb20gMCB0byBhcnJheXMgYW5kIHJlbW92ZSB1bmRlZmluZWQgdmFsdWVzOlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb252ZXJ0T2JqZWN0c1dpdGhJbnRlZ2VyS2V5c1RvQXJyYXlzKG9iaikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG9iai5tYXAoY29udmVydE9iamVjdHNXaXRoSW50ZWdlcktleXNUb0FycmF5cyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBpZiAoMCBpbiBvYmogfHwgMSBpbiBvYmopIHtcbiAgICAgICAgICAgIHZhciBmaXJzdE51bWVyaWNLZXlOdW1iZXIgPSAwIGluIG9iaiA/IDAgOiAxLFxuICAgICAgICAgICAgICAgIG5leHROdW1lcmljS2V5TnVtYmVyID0gZmlyc3ROdW1lcmljS2V5TnVtYmVyICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0TnVtZXJpY0tleU51bWJlciBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBuZXh0TnVtZXJpY0tleU51bWJlciArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID4gMCAmJiBuZXh0TnVtZXJpY0tleU51bWJlciA9PT0ga2V5cy5sZW5ndGggKyBmaXJzdE51bWVyaWNLZXlOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgaTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwIDsgaSA8IGZpcnN0TnVtZXJpY0tleU51bWJlciA7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhcnJheS5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IGZpcnN0TnVtZXJpY0tleU51bWJlciA7IGkgPCBrZXlzLmxlbmd0aCA7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhcnJheS5wdXNoKGNvbnZlcnRPYmplY3RzV2l0aEludGVnZXJLZXlzVG9BcnJheXMob2JqW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0T2JqID0ge307XG4gICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9ialtrZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdE9ialtrZXldID0gY29udmVydE9iamVjdHNXaXRoSW50ZWdlcktleXNUb0FycmF5cyhvYmpba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0T2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxufTtcbiIsIi8vIENyZWF0ZSBhIG1lbW9pemVyIGZvciBhbiBhc3luYyBmdW5jdGlvblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZW1vaXplQXN5bmMoZm4pIHtcbiAgICB2YXIgcmVzdWx0QXJndW1lbnRzLFxuICAgICAgICB3YWl0aW5nQ2FsbGJhY2tzO1xuICAgIHJldHVybiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBpZiAocmVzdWx0QXJndW1lbnRzKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjYi5hcHBseSh0aGlzLCByZXN1bHRBcmd1bWVudHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAod2FpdGluZ0NhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgIHdhaXRpbmdDYWxsYmFja3MucHVzaChjYik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdhaXRpbmdDYWxsYmFja3MgPSBbY2JdO1xuICAgICAgICAgICAgICAgIGZuKGZ1bmN0aW9uICgpIHsgLy8gLi4uXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRBcmd1bWVudHMgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgIHdhaXRpbmdDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAod2FpdGluZ0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWl0aW5nQ2FsbGJhY2suYXBwbHkodGhpcywgcmVzdWx0QXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHdhaXRpbmdDYWxsYmFja3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn07XG4iLCIvKlxuICogUmVwbGFjZSAtIHdpdGggXyBhbmQgY29udmVydCB0byBsb3dlciBjYXNlOiBlbi1HQiA9PiBlbl9nYlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZUlkKGxvY2FsZUlkKSB7XG4gICAgcmV0dXJuIGxvY2FsZUlkICYmIGxvY2FsZUlkLnJlcGxhY2UoLy0vZywgJ18nKS50b0xvd2VyQ2FzZSgpO1xufTtcbiIsIi8qXG4gKiBDb252ZXJ0IGZvby1iYXIgYXR0cmlidXRlIHZhbHVlcyB0byBmb29CYXIgSmF2YVNjcmlwdCBrZXlzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplUHJvcGVydHkoc3RyKSB7XG5cdHJldHVybiBzdHIucmVwbGFjZSgvLShbYS16XSkvZywgZnVuY3Rpb24gKCQwLCBjaCkge1xuICAgICAgICByZXR1cm4gY2gudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhc3NFcnJvcihlcnJvckNhbGxiYWNrLCBzdWNjZXNzQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVycikgeyAvLyAuLi5cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIpO1xuICAgICAgICB9IGVsc2UgaWYgKHN1Y2Nlc3NDYWxsYmFjaykge1xuICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbiIsIi8qXG4gKiBQRUcuanMgMC43LjBcbiAqXG4gKiBodHRwOi8vcGVnanMubWFqZGEuY3ovXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTIgRGF2aWQgTWFqZGFcbiAqIExpY2Vuc2VuZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cbnZhciBQRUcgPSAoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG5cbnZhciBQRUcgPSB7XG4gIC8qIFBFRy5qcyB2ZXJzaW9uICh1c2VzIHNlbWFudGljIHZlcnNpb25pbmcpLiAqL1xuICBWRVJTSU9OOiBcIjAuNy4wXCIsXG5cbiAgLypcbiAgICogR2VuZXJhdGVzIGEgcGFyc2VyIGZyb20gYSBzcGVjaWZpZWQgZ3JhbW1hciBhbmQgcmV0dXJucyBpdC5cbiAgICpcbiAgICogVGhlIGdyYW1tYXIgbXVzdCBiZSBhIHN0cmluZyBpbiB0aGUgZm9ybWF0IGRlc2NyaWJlZCBieSB0aGUgbWV0YWdyYW1hciBpblxuICAgKiB0aGUgcGFyc2VyLnBlZ2pzIGZpbGUuXG4gICAqXG4gICAqIFRocm93cyB8UEVHLnBhcnNlci5TeW50YXhFcnJvcnwgaWYgdGhlIGdyYW1tYXIgY29udGFpbnMgYSBzeW50YXggZXJyb3Igb3JcbiAgICogfFBFRy5HcmFtbWFyRXJyb3J8IGlmIGl0IGNvbnRhaW5zIGEgc2VtYW50aWMgZXJyb3IuIE5vdGUgdGhhdCBub3QgYWxsXG4gICAqIGVycm9ycyBhcmUgZGV0ZWN0ZWQgZHVyaW5nIHRoZSBnZW5lcmF0aW9uIGFuZCBzb21lIG1heSBwcm90cnVkZSB0byB0aGVcbiAgICogZ2VuZXJhdGVkIHBhcnNlciBhbmQgY2F1c2UgaXRzIG1hbGZ1bmN0aW9uLlxuICAgKi9cbiAgYnVpbGRQYXJzZXI6IGZ1bmN0aW9uKGdyYW1tYXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gUEVHLmNvbXBpbGVyLmNvbXBpbGUoUEVHLnBhcnNlci5wYXJzZShncmFtbWFyKSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbi8qIFRocm93biB3aGVuIHRoZSBncmFtbWFyIGNvbnRhaW5zIGFuIGVycm9yLiAqL1xuXG5QRUcuR3JhbW1hckVycm9yID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICB0aGlzLm5hbWUgPSBcIlBFRy5HcmFtbWFyRXJyb3JcIjtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn07XG5cblBFRy5HcmFtbWFyRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4vKiBMaWtlIFB5dGhvbidzIHxyYW5nZXwsIGJ1dCB3aXRob3V0IHxzdGVwfC4gKi9cbmZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBzdG9wKSB7XG4gIGlmIChzdG9wID09PSB1bmRlZmluZWQpIHtcbiAgICBzdG9wID0gc3RhcnQ7XG4gICAgc3RhcnQgPSAwO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShNYXRoLm1heCgwLCBzdG9wIC0gc3RhcnQpKTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBzdGFydDsgaiA8IHN0b3A7IGkrKywgaisrKSB7XG4gICAgcmVzdWx0W2ldID0gajtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmaW5kKGFycmF5LCBjYWxsYmFjaykge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGNhbGxiYWNrKGFycmF5W2ldKSkge1xuICAgICAgcmV0dXJuIGFycmF5W2ldO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb250YWlucyhhcnJheSwgdmFsdWUpIHtcbiAgLypcbiAgICogU3R1cGlkIElFIGRvZXMgbm90IGhhdmUgQXJyYXkucHJvdG90eXBlLmluZGV4T2YsIG90aGVyd2lzZSB0aGlzIGZ1bmN0aW9uXG4gICAqIHdvdWxkIGJlIGEgb25lLWxpbmVyLlxuICAgKi9cbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGVhY2goYXJyYXksIGNhbGxiYWNrKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjYWxsYmFjayhhcnJheVtpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwKGFycmF5LCBjYWxsYmFjaykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSBjYWxsYmFjayhhcnJheVtpXSwgaSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGx1Y2soYXJyYXksIGtleSkge1xuICByZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZVtrZXldOyB9KTtcbn1cblxuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIHJlc3VsdC5wdXNoKG9iamVjdFtrZXldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKlxuICogUmV0dXJucyBhIHN0cmluZyBwYWRkZWQgb24gdGhlIGxlZnQgdG8gYSBkZXNpcmVkIGxlbmd0aCB3aXRoIGEgY2hhcmFjdGVyLlxuICpcbiAqIFRoZSBjb2RlIG5lZWRzIHRvIGJlIGluIHN5bmMgd2l0aCB0aGUgY29kZSB0ZW1wbGF0ZSBpbiB0aGUgY29tcGlsYXRpb25cbiAqIGZ1bmN0aW9uIGZvciBcImFjdGlvblwiIG5vZGVzLlxuICovXG5mdW5jdGlvbiBwYWRMZWZ0KGlucHV0LCBwYWRkaW5nLCBsZW5ndGgpIHtcbiAgdmFyIHJlc3VsdCA9IGlucHV0O1xuXG4gIHZhciBwYWRMZW5ndGggPSBsZW5ndGggLSBpbnB1dC5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFkTGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHQgPSBwYWRkaW5nICsgcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLypcbiAqIFJldHVybnMgYW4gZXNjYXBlIHNlcXVlbmNlIGZvciBnaXZlbiBjaGFyYWN0ZXIuIFVzZXMgXFx4IGZvciBjaGFyYWN0ZXJzIDw9XG4gKiAweEZGIHRvIHNhdmUgc3BhY2UsIFxcdSBmb3IgdGhlIHJlc3QuXG4gKlxuICogVGhlIGNvZGUgbmVlZHMgdG8gYmUgaW4gc3luYyB3aXRoIHRoZSBjb2RlIHRlbXBsYXRlIGluIHRoZSBjb21waWxhdGlvblxuICogZnVuY3Rpb24gZm9yIFwiYWN0aW9uXCIgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShjaCkge1xuICB2YXIgY2hhckNvZGUgPSBjaC5jaGFyQ29kZUF0KDApO1xuICB2YXIgZXNjYXBlQ2hhcjtcbiAgdmFyIGxlbmd0aDtcblxuICBpZiAoY2hhckNvZGUgPD0gMHhGRikge1xuICAgIGVzY2FwZUNoYXIgPSAneCc7XG4gICAgbGVuZ3RoID0gMjtcbiAgfSBlbHNlIHtcbiAgICBlc2NhcGVDaGFyID0gJ3UnO1xuICAgIGxlbmd0aCA9IDQ7XG4gIH1cblxuICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlQ2hhciArIHBhZExlZnQoY2hhckNvZGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCksICcwJywgbGVuZ3RoKTtcbn1cblxuLypcbiAqIFN1cnJvdW5kcyB0aGUgc3RyaW5nIHdpdGggcXVvdGVzIGFuZCBlc2NhcGVzIGNoYXJhY3RlcnMgaW5zaWRlIHNvIHRoYXQgdGhlXG4gKiByZXN1bHQgaXMgYSB2YWxpZCBKYXZhU2NyaXB0IHN0cmluZy5cbiAqXG4gKiBUaGUgY29kZSBuZWVkcyB0byBiZSBpbiBzeW5jIHdpdGggdGhlIGNvZGUgdGVtcGxhdGUgaW4gdGhlIGNvbXBpbGF0aW9uXG4gKiBmdW5jdGlvbiBmb3IgXCJhY3Rpb25cIiBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gcXVvdGUocykge1xuICAvKlxuICAgKiBFQ01BLTI2MiwgNXRoIGVkLiwgNy44LjQ6IEFsbCBjaGFyYWN0ZXJzIG1heSBhcHBlYXIgbGl0ZXJhbGx5IGluIGEgc3RyaW5nXG4gICAqIGxpdGVyYWwgZXhjZXB0IGZvciB0aGUgY2xvc2luZyBxdW90ZSBjaGFyYWN0ZXIsIGJhY2tzbGFzaCwgY2FycmlhZ2UgcmV0dXJuLFxuICAgKiBsaW5lIHNlcGFyYXRvciwgcGFyYWdyYXBoIHNlcGFyYXRvciwgYW5kIGxpbmUgZmVlZC4gQW55IGNoYXJhY3RlciBtYXlcbiAgICogYXBwZWFyIGluIHRoZSBmb3JtIG9mIGFuIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICpcbiAgICogRm9yIHBvcnRhYmlsaXR5LCB3ZSBhbHNvIGVzY2FwZSBlc2NhcGUgYWxsIGNvbnRyb2wgYW5kIG5vbi1BU0NJSVxuICAgKiBjaGFyYWN0ZXJzLiBOb3RlIHRoYXQgXCJcXDBcIiBhbmQgXCJcXHZcIiBlc2NhcGUgc2VxdWVuY2VzIGFyZSBub3QgdXNlZCBiZWNhdXNlXG4gICAqIEpTSGludCBkb2VzIG5vdCBsaWtlIHRoZSBmaXJzdCBhbmQgSUUgdGhlIHNlY29uZC5cbiAgICovXG4gIHJldHVybiAnXCInICsgc1xuICAgIC5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpICAvLyBiYWNrc2xhc2hcbiAgICAucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpICAgIC8vIGNsb3NpbmcgcXVvdGUgY2hhcmFjdGVyXG4gICAgLnJlcGxhY2UoL1xceDA4L2csICdcXFxcYicpIC8vIGJhY2tzcGFjZVxuICAgIC5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0JykgICAvLyBob3Jpem9udGFsIHRhYlxuICAgIC5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJykgICAvLyBsaW5lIGZlZWRcbiAgICAucmVwbGFjZSgvXFxmL2csICdcXFxcZicpICAgLy8gZm9ybSBmZWVkXG4gICAgLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKSAgIC8vIGNhcnJpYWdlIHJldHVyblxuICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MDdcXHgwQlxceDBFLVxceDFGXFx4ODAtXFx1RkZGRl0vZywgZXNjYXBlKVxuICAgICsgJ1wiJztcbn1cblxuLypcbiAqIEVzY2FwZXMgY2hhcmFjdGVycyBpbnNpZGUgdGhlIHN0cmluZyBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkIGFzIGEgbGlzdCBvZlxuICogY2hhcmFjdGVycyBpbiBhIGNoYXJhY3RlciBjbGFzcyBvZiBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqL1xuZnVuY3Rpb24gcXVvdGVGb3JSZWdleHBDbGFzcyhzKSB7XG4gIC8qXG4gICAqIEJhc2VkIG9uIEVDTUEtMjYyLCA1dGggZWQuLCA3LjguNSAmIDE1LjEwLjEuXG4gICAqXG4gICAqIEZvciBwb3J0YWJpbGl0eSwgd2UgYWxzbyBlc2NhcGUgZXNjYXBlIGFsbCBjb250cm9sIGFuZCBub24tQVNDSUlcbiAgICogY2hhcmFjdGVycy5cbiAgICovXG4gIHJldHVybiBzXG4gICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykgIC8vIGJhY2tzbGFzaFxuICAgIC5yZXBsYWNlKC9cXC8vZywgJ1xcXFwvJykgICAvLyBjbG9zaW5nIHNsYXNoXG4gICAgLnJlcGxhY2UoL1xcXS9nLCAnXFxcXF0nKSAgIC8vIGNsb3NpbmcgYnJhY2tldFxuICAgIC5yZXBsYWNlKC8tL2csICdcXFxcLScpICAgIC8vIGRhc2hcbiAgICAucmVwbGFjZSgvXFwwL2csICdcXFxcMCcpICAgLy8gbnVsbFxuICAgIC5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0JykgICAvLyBob3Jpem9udGFsIHRhYlxuICAgIC5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJykgICAvLyBsaW5lIGZlZWRcbiAgICAucmVwbGFjZSgvXFx2L2csICdcXFxceDBCJykgLy8gdmVydGljYWwgdGFiXG4gICAgLnJlcGxhY2UoL1xcZi9nLCAnXFxcXGYnKSAgIC8vIGZvcm0gZmVlZFxuICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJykgICAvLyBjYXJyaWFnZSByZXR1cm5cbiAgICAucmVwbGFjZSgvW1xceDAxLVxceDA4XFx4MEUtXFx4MUZcXHg4MC1cXHVGRkZGXS9nLCBlc2NhcGUpO1xufVxuXG4vKlxuICogQnVpbGRzIGEgbm9kZSB2aXNpdG9yIC0tIGEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgYSBub2RlIGFuZCBhbnkgbnVtYmVyIG9mXG4gKiBvdGhlciBwYXJhbWV0ZXJzLCBjYWxscyBhbiBhcHByb3ByaWF0ZSBmdW5jdGlvbiBhY2NvcmRpbmcgdG8gdGhlIG5vZGUgdHlwZSxcbiAqIHBhc3NlcyBpdCBhbGwgaXRzIHBhcmFtZXRlcnMgYW5kIHJldHVybnMgaXRzIHZhbHVlLiBUaGUgZnVuY3Rpb25zIGZvciB2YXJpb3VzXG4gKiBub2RlIHR5cGVzIGFyZSBwYXNzZWQgaW4gYSBwYXJhbWV0ZXIgdG8gfGJ1aWxkTm9kZVZpc2l0b3J8IGFzIGEgaGFzaC5cbiAqL1xuZnVuY3Rpb24gYnVpbGROb2RlVmlzaXRvcihmdW5jdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25zW25vZGUudHlwZV0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmluZFJ1bGVCeU5hbWUoYXN0LCBuYW1lKSB7XG4gIHJldHVybiBmaW5kKGFzdC5ydWxlcywgZnVuY3Rpb24ocikgeyByZXR1cm4gci5uYW1lID09PSBuYW1lOyB9KTtcbn1cblBFRy5wYXJzZXIgPSAoZnVuY3Rpb24oKXtcbiAgLypcbiAgICogR2VuZXJhdGVkIGJ5IFBFRy5qcyAwLjcuMC5cbiAgICpcbiAgICogaHR0cDovL3BlZ2pzLm1hamRhLmN6L1xuICAgKi9cbiAgXG4gIGZ1bmN0aW9uIHF1b3RlKHMpIHtcbiAgICAvKlxuICAgICAqIEVDTUEtMjYyLCA1dGggZWQuLCA3LjguNDogQWxsIGNoYXJhY3RlcnMgbWF5IGFwcGVhciBsaXRlcmFsbHkgaW4gYVxuICAgICAqIHN0cmluZyBsaXRlcmFsIGV4Y2VwdCBmb3IgdGhlIGNsb3NpbmcgcXVvdGUgY2hhcmFjdGVyLCBiYWNrc2xhc2gsXG4gICAgICogY2FycmlhZ2UgcmV0dXJuLCBsaW5lIHNlcGFyYXRvciwgcGFyYWdyYXBoIHNlcGFyYXRvciwgYW5kIGxpbmUgZmVlZC5cbiAgICAgKiBBbnkgY2hhcmFjdGVyIG1heSBhcHBlYXIgaW4gdGhlIGZvcm0gb2YgYW4gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogRm9yIHBvcnRhYmlsaXR5LCB3ZSBhbHNvIGVzY2FwZSBlc2NhcGUgYWxsIGNvbnRyb2wgYW5kIG5vbi1BU0NJSVxuICAgICAqIGNoYXJhY3RlcnMuIE5vdGUgdGhhdCBcIlxcMFwiIGFuZCBcIlxcdlwiIGVzY2FwZSBzZXF1ZW5jZXMgYXJlIG5vdCB1c2VkXG4gICAgICogYmVjYXVzZSBKU0hpbnQgZG9lcyBub3QgbGlrZSB0aGUgZmlyc3QgYW5kIElFIHRoZSBzZWNvbmQuXG4gICAgICovXG4gICAgIHJldHVybiAnXCInICsgc1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykgIC8vIGJhY2tzbGFzaFxuICAgICAgLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSAgICAvLyBjbG9zaW5nIHF1b3RlIGNoYXJhY3RlclxuICAgICAgLnJlcGxhY2UoL1xceDA4L2csICdcXFxcYicpIC8vIGJhY2tzcGFjZVxuICAgICAgLnJlcGxhY2UoL1xcdC9nLCAnXFxcXHQnKSAgIC8vIGhvcml6b250YWwgdGFiXG4gICAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpICAgLy8gbGluZSBmZWVkXG4gICAgICAucmVwbGFjZSgvXFxmL2csICdcXFxcZicpICAgLy8gZm9ybSBmZWVkXG4gICAgICAucmVwbGFjZSgvXFxyL2csICdcXFxccicpICAgLy8gY2FycmlhZ2UgcmV0dXJuXG4gICAgICAucmVwbGFjZSgvW1xceDAwLVxceDA3XFx4MEJcXHgwRS1cXHgxRlxceDgwLVxcdUZGRkZdL2csIGVzY2FwZSlcbiAgICAgICsgJ1wiJztcbiAgfVxuICBcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICAvKlxuICAgICAqIFBhcnNlcyB0aGUgaW5wdXQgd2l0aCBhIGdlbmVyYXRlZCBwYXJzZXIuIElmIHRoZSBwYXJzaW5nIGlzIHN1Y2Nlc3NmdWxsLFxuICAgICAqIHJldHVybnMgYSB2YWx1ZSBleHBsaWNpdGx5IG9yIGltcGxpY2l0bHkgc3BlY2lmaWVkIGJ5IHRoZSBncmFtbWFyIGZyb21cbiAgICAgKiB3aGljaCB0aGUgcGFyc2VyIHdhcyBnZW5lcmF0ZWQgKHNlZSB8UEVHLmJ1aWxkUGFyc2VyfCkuIElmIHRoZSBwYXJzaW5nIGlzXG4gICAgICogdW5zdWNjZXNzZnVsLCB0aHJvd3MgfFBFRy5wYXJzZXIuU3ludGF4RXJyb3J8IGRlc2NyaWJpbmcgdGhlIGVycm9yLlxuICAgICAqL1xuICAgIHBhcnNlOiBmdW5jdGlvbihpbnB1dCwgc3RhcnRSdWxlKSB7XG4gICAgICB2YXIgcGFyc2VGdW5jdGlvbnMgPSB7XG4gICAgICAgIFwiZ3JhbW1hclwiOiBwYXJzZV9ncmFtbWFyLFxuICAgICAgICBcImluaXRpYWxpemVyXCI6IHBhcnNlX2luaXRpYWxpemVyLFxuICAgICAgICBcInJ1bGVcIjogcGFyc2VfcnVsZSxcbiAgICAgICAgXCJjaG9pY2VcIjogcGFyc2VfY2hvaWNlLFxuICAgICAgICBcInNlcXVlbmNlXCI6IHBhcnNlX3NlcXVlbmNlLFxuICAgICAgICBcImxhYmVsZWRcIjogcGFyc2VfbGFiZWxlZCxcbiAgICAgICAgXCJwcmVmaXhlZFwiOiBwYXJzZV9wcmVmaXhlZCxcbiAgICAgICAgXCJzdWZmaXhlZFwiOiBwYXJzZV9zdWZmaXhlZCxcbiAgICAgICAgXCJwcmltYXJ5XCI6IHBhcnNlX3ByaW1hcnksXG4gICAgICAgIFwiYWN0aW9uXCI6IHBhcnNlX2FjdGlvbixcbiAgICAgICAgXCJicmFjZWRcIjogcGFyc2VfYnJhY2VkLFxuICAgICAgICBcIm5vbkJyYWNlQ2hhcmFjdGVyc1wiOiBwYXJzZV9ub25CcmFjZUNoYXJhY3RlcnMsXG4gICAgICAgIFwibm9uQnJhY2VDaGFyYWN0ZXJcIjogcGFyc2Vfbm9uQnJhY2VDaGFyYWN0ZXIsXG4gICAgICAgIFwiZXF1YWxzXCI6IHBhcnNlX2VxdWFscyxcbiAgICAgICAgXCJjb2xvblwiOiBwYXJzZV9jb2xvbixcbiAgICAgICAgXCJzZW1pY29sb25cIjogcGFyc2Vfc2VtaWNvbG9uLFxuICAgICAgICBcInNsYXNoXCI6IHBhcnNlX3NsYXNoLFxuICAgICAgICBcImFuZFwiOiBwYXJzZV9hbmQsXG4gICAgICAgIFwibm90XCI6IHBhcnNlX25vdCxcbiAgICAgICAgXCJxdWVzdGlvblwiOiBwYXJzZV9xdWVzdGlvbixcbiAgICAgICAgXCJzdGFyXCI6IHBhcnNlX3N0YXIsXG4gICAgICAgIFwicGx1c1wiOiBwYXJzZV9wbHVzLFxuICAgICAgICBcImxwYXJlblwiOiBwYXJzZV9scGFyZW4sXG4gICAgICAgIFwicnBhcmVuXCI6IHBhcnNlX3JwYXJlbixcbiAgICAgICAgXCJkb3RcIjogcGFyc2VfZG90LFxuICAgICAgICBcImlkZW50aWZpZXJcIjogcGFyc2VfaWRlbnRpZmllcixcbiAgICAgICAgXCJsaXRlcmFsXCI6IHBhcnNlX2xpdGVyYWwsXG4gICAgICAgIFwic3RyaW5nXCI6IHBhcnNlX3N0cmluZyxcbiAgICAgICAgXCJkb3VibGVRdW90ZWRTdHJpbmdcIjogcGFyc2VfZG91YmxlUXVvdGVkU3RyaW5nLFxuICAgICAgICBcImRvdWJsZVF1b3RlZENoYXJhY3RlclwiOiBwYXJzZV9kb3VibGVRdW90ZWRDaGFyYWN0ZXIsXG4gICAgICAgIFwic2ltcGxlRG91YmxlUXVvdGVkQ2hhcmFjdGVyXCI6IHBhcnNlX3NpbXBsZURvdWJsZVF1b3RlZENoYXJhY3RlcixcbiAgICAgICAgXCJzaW5nbGVRdW90ZWRTdHJpbmdcIjogcGFyc2Vfc2luZ2xlUXVvdGVkU3RyaW5nLFxuICAgICAgICBcInNpbmdsZVF1b3RlZENoYXJhY3RlclwiOiBwYXJzZV9zaW5nbGVRdW90ZWRDaGFyYWN0ZXIsXG4gICAgICAgIFwic2ltcGxlU2luZ2xlUXVvdGVkQ2hhcmFjdGVyXCI6IHBhcnNlX3NpbXBsZVNpbmdsZVF1b3RlZENoYXJhY3RlcixcbiAgICAgICAgXCJjbGFzc1wiOiBwYXJzZV9jbGFzcyxcbiAgICAgICAgXCJjbGFzc0NoYXJhY3RlclJhbmdlXCI6IHBhcnNlX2NsYXNzQ2hhcmFjdGVyUmFuZ2UsXG4gICAgICAgIFwiY2xhc3NDaGFyYWN0ZXJcIjogcGFyc2VfY2xhc3NDaGFyYWN0ZXIsXG4gICAgICAgIFwiYnJhY2tldERlbGltaXRlZENoYXJhY3RlclwiOiBwYXJzZV9icmFja2V0RGVsaW1pdGVkQ2hhcmFjdGVyLFxuICAgICAgICBcInNpbXBsZUJyYWNrZXREZWxpbWl0ZWRDaGFyYWN0ZXJcIjogcGFyc2Vfc2ltcGxlQnJhY2tldERlbGltaXRlZENoYXJhY3RlcixcbiAgICAgICAgXCJzaW1wbGVFc2NhcGVTZXF1ZW5jZVwiOiBwYXJzZV9zaW1wbGVFc2NhcGVTZXF1ZW5jZSxcbiAgICAgICAgXCJ6ZXJvRXNjYXBlU2VxdWVuY2VcIjogcGFyc2VfemVyb0VzY2FwZVNlcXVlbmNlLFxuICAgICAgICBcImhleEVzY2FwZVNlcXVlbmNlXCI6IHBhcnNlX2hleEVzY2FwZVNlcXVlbmNlLFxuICAgICAgICBcInVuaWNvZGVFc2NhcGVTZXF1ZW5jZVwiOiBwYXJzZV91bmljb2RlRXNjYXBlU2VxdWVuY2UsXG4gICAgICAgIFwiZW9sRXNjYXBlU2VxdWVuY2VcIjogcGFyc2VfZW9sRXNjYXBlU2VxdWVuY2UsXG4gICAgICAgIFwiZGlnaXRcIjogcGFyc2VfZGlnaXQsXG4gICAgICAgIFwiaGV4RGlnaXRcIjogcGFyc2VfaGV4RGlnaXQsXG4gICAgICAgIFwibGV0dGVyXCI6IHBhcnNlX2xldHRlcixcbiAgICAgICAgXCJsb3dlckNhc2VMZXR0ZXJcIjogcGFyc2VfbG93ZXJDYXNlTGV0dGVyLFxuICAgICAgICBcInVwcGVyQ2FzZUxldHRlclwiOiBwYXJzZV91cHBlckNhc2VMZXR0ZXIsXG4gICAgICAgIFwiX19cIjogcGFyc2VfX18sXG4gICAgICAgIFwiY29tbWVudFwiOiBwYXJzZV9jb21tZW50LFxuICAgICAgICBcInNpbmdsZUxpbmVDb21tZW50XCI6IHBhcnNlX3NpbmdsZUxpbmVDb21tZW50LFxuICAgICAgICBcIm11bHRpTGluZUNvbW1lbnRcIjogcGFyc2VfbXVsdGlMaW5lQ29tbWVudCxcbiAgICAgICAgXCJlb2xcIjogcGFyc2VfZW9sLFxuICAgICAgICBcImVvbENoYXJcIjogcGFyc2VfZW9sQ2hhcixcbiAgICAgICAgXCJ3aGl0ZXNwYWNlXCI6IHBhcnNlX3doaXRlc3BhY2VcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGlmIChzdGFydFJ1bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocGFyc2VGdW5jdGlvbnNbc3RhcnRSdWxlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBydWxlIG5hbWU6IFwiICsgcXVvdGUoc3RhcnRSdWxlKSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRSdWxlID0gXCJncmFtbWFyXCI7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgdmFyIHJlcG9ydEZhaWx1cmVzID0gMDtcbiAgICAgIHZhciByaWdodG1vc3RGYWlsdXJlc1BvcyA9IDA7XG4gICAgICB2YXIgcmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZCA9IFtdO1xuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYWRMZWZ0KGlucHV0LCBwYWRkaW5nLCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGlucHV0O1xuICAgICAgICBcbiAgICAgICAgdmFyIHBhZExlbmd0aCA9IGxlbmd0aCAtIGlucHV0Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRMZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJlc3VsdCA9IHBhZGRpbmcgKyByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIGVzY2FwZShjaCkge1xuICAgICAgICB2YXIgY2hhckNvZGUgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICB2YXIgZXNjYXBlQ2hhcjtcbiAgICAgICAgdmFyIGxlbmd0aDtcbiAgICAgICAgXG4gICAgICAgIGlmIChjaGFyQ29kZSA8PSAweEZGKSB7XG4gICAgICAgICAgZXNjYXBlQ2hhciA9ICd4JztcbiAgICAgICAgICBsZW5ndGggPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVzY2FwZUNoYXIgPSAndSc7XG4gICAgICAgICAgbGVuZ3RoID0gNDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZUNoYXIgKyBwYWRMZWZ0KGNoYXJDb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLCAnMCcsIGxlbmd0aCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIG1hdGNoRmFpbGVkKGZhaWx1cmUpIHtcbiAgICAgICAgaWYgKHBvcyA8IHJpZ2h0bW9zdEZhaWx1cmVzUG9zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAocG9zID4gcmlnaHRtb3N0RmFpbHVyZXNQb3MpIHtcbiAgICAgICAgICByaWdodG1vc3RGYWlsdXJlc1BvcyA9IHBvcztcbiAgICAgICAgICByaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkID0gW107XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWQucHVzaChmYWlsdXJlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfZ3JhbW1hcigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDM7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX19fKCk7XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2luaXRpYWxpemVyKCk7XG4gICAgICAgICAgcmVzdWx0MSA9IHJlc3VsdDEgIT09IG51bGwgPyByZXN1bHQxIDogXCJcIjtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MyA9IHBhcnNlX3J1bGUoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBbXTtcbiAgICAgICAgICAgICAgd2hpbGUgKHJlc3VsdDMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyLnB1c2gocmVzdWx0Myk7XG4gICAgICAgICAgICAgICAgcmVzdWx0MyA9IHBhcnNlX3J1bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBpbml0aWFsaXplciwgcnVsZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAgICAgICAgXCJncmFtbWFyXCIsXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyICE9PSBcIlwiID8gaW5pdGlhbGl6ZXIgOiBudWxsLFxuICAgICAgICAgICAgICAgIHJ1bGVzOiAgICAgICBydWxlcyxcbiAgICAgICAgICAgICAgICBzdGFydFJ1bGU6ICAgcnVsZXNbMF0ubmFtZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFsxXSwgcmVzdWx0MFsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9pbml0aWFsaXplcigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2FjdGlvbigpO1xuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9zZW1pY29sb24oKTtcbiAgICAgICAgICByZXN1bHQxID0gcmVzdWx0MSAhPT0gbnVsbCA/IHJlc3VsdDEgOiBcIlwiO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgY29kZSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW5pdGlhbGl6ZXJcIixcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3J1bGUoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzLCByZXN1bHQ0O1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV9pZGVudGlmaWVyKCk7XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX3N0cmluZygpO1xuICAgICAgICAgIHJlc3VsdDEgPSByZXN1bHQxICE9PSBudWxsID8gcmVzdWx0MSA6IFwiXCI7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9lcXVhbHMoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDMgPSBwYXJzZV9jaG9pY2UoKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ0ID0gcGFyc2Vfc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0NCA9IHJlc3VsdDQgIT09IG51bGwgPyByZXN1bHQ0IDogXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0NCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzLCByZXN1bHQ0XTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIG5hbWUsIGRpc3BsYXlOYW1lLCBleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogICAgICAgIFwicnVsZVwiLFxuICAgICAgICAgICAgICAgIG5hbWU6ICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSAhPT0gXCJcIiA/IGRpc3BsYXlOYW1lIDogbnVsbCxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiAgZXhwcmVzc2lvblxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsxXSwgcmVzdWx0MFszXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9jaG9pY2UoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMSwgcG9zMjtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV9zZXF1ZW5jZSgpO1xuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBbXTtcbiAgICAgICAgICBwb3MyID0gcG9zO1xuICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9zbGFzaCgpO1xuICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQzID0gcGFyc2Vfc2VxdWVuY2UoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBbcmVzdWx0MiwgcmVzdWx0M107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MyO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MS5wdXNoKHJlc3VsdDIpO1xuICAgICAgICAgICAgcG9zMiA9IHBvcztcbiAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9zbGFzaCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MyA9IHBhcnNlX3NlcXVlbmNlKCk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiA9IFtyZXN1bHQyLCByZXN1bHQzXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwb3MgPSBwb3MyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBoZWFkLCB0YWlsKSB7XG4gICAgICAgICAgICAgIGlmICh0YWlsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgYWx0ZXJuYXRpdmVzID0gW2hlYWRdLmNvbmNhdChtYXAoXG4gICAgICAgICAgICAgICAgICAgIHRhaWwsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVsZW1lbnQpIHsgcmV0dXJuIGVsZW1lbnRbMV07IH1cbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogICAgICAgICBcImNob2ljZVwiLFxuICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmVzOiBhbHRlcm5hdGl2ZXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzBdLCByZXN1bHQwWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3NlcXVlbmNlKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICByZXN1bHQwID0gW107XG4gICAgICAgIHJlc3VsdDEgPSBwYXJzZV9sYWJlbGVkKCk7XG4gICAgICAgIHdoaWxlIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MC5wdXNoKHJlc3VsdDEpO1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9sYWJlbGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfYWN0aW9uKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBlbGVtZW50cywgY29kZSkge1xuICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGVsZW1lbnRzLmxlbmd0aCAhPT0gMVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAgICAgXCJzZXF1ZW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IGVsZW1lbnRzWzBdO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgIFwiYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBjb2RlOiAgICAgICBjb2RlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzBdLCByZXN1bHQwWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgIHJlc3VsdDAgPSBbXTtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfbGFiZWxlZCgpO1xuICAgICAgICAgIHdoaWxlIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwLnB1c2gocmVzdWx0MSk7XG4gICAgICAgICAgICByZXN1bHQxID0gcGFyc2VfbGFiZWxlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzLmxlbmd0aCAhPT0gMVxuICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogICAgIFwic2VxdWVuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgOiBlbGVtZW50c1swXTtcbiAgICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfbGFiZWxlZCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2lkZW50aWZpZXIoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfY29sb24oKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX3ByZWZpeGVkKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBsYWJlbCwgZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgIFwibGFiZWxlZFwiLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAgICAgIGxhYmVsLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMF0sIHJlc3VsdDBbMl0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9wcmVmaXhlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9wcmVmaXhlZCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2FuZCgpO1xuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9hY3Rpb24oKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGNvZGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNlbWFudGljX2FuZFwiLFxuICAgICAgICAgICAgICAgIGNvZGU6IGNvZGVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICByZXN1bHQwID0gcGFyc2VfYW5kKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9zdWZmaXhlZCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAgICAgICBcInNpbXBsZV9hbmRcIixcbiAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9ub3QoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9hY3Rpb24oKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2VtYW50aWNfbm90XCIsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvZGVcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX25vdCgpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9zdWZmaXhlZCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgIFwic2ltcGxlX25vdFwiLFxuICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9zdWZmaXhlZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zdWZmaXhlZCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3ByaW1hcnkoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfcXVlc3Rpb24oKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAgICAgICBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvblxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9wcmltYXJ5KCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9zdGFyKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgIFwiemVyb19vcl9tb3JlXCIsXG4gICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFswXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfcHJpbWFyeSgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX3BsdXMoKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgIFwib25lX29yX21vcmVcIixcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfcHJpbWFyeSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfcHJpbWFyeSgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxLCBwb3MyLCBwb3MzO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2lkZW50aWZpZXIoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICBwb3MyID0gcG9zO1xuICAgICAgICAgIHJlcG9ydEZhaWx1cmVzKys7XG4gICAgICAgICAgcG9zMyA9IHBvcztcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2Vfc3RyaW5nKCk7XG4gICAgICAgICAgcmVzdWx0MSA9IHJlc3VsdDEgIT09IG51bGwgPyByZXN1bHQxIDogXCJcIjtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX2VxdWFscygpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MSA9IFtyZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcG9ydEZhaWx1cmVzLS07XG4gICAgICAgICAgaWYgKHJlc3VsdDEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBcIlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgbmFtZSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicnVsZV9yZWZcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gcGFyc2VfbGl0ZXJhbCgpO1xuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2RvdCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIHsgdHlwZTogXCJhbnlcIiB9OyB9KShwb3MwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfY2xhc3MoKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2xwYXJlbigpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQxID0gcGFyc2VfY2hvaWNlKCk7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfcnBhcmVuKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGV4cHJlc3Npb24pIHsgcmV0dXJuIGV4cHJlc3Npb247IH0pKHBvczAsIHJlc3VsdDBbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2FjdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcmVwb3J0RmFpbHVyZXMrKztcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2JyYWNlZCgpO1xuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9fXygpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgYnJhY2VkKSB7IHJldHVybiBicmFjZWQuc3Vic3RyKDEsIGJyYWNlZC5sZW5ndGggLSAyKTsgfSkocG9zMCwgcmVzdWx0MFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJlcG9ydEZhaWx1cmVzLS07XG4gICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCAmJiByZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgbWF0Y2hGYWlsZWQoXCJhY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2JyYWNlZCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMTIzKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwie1wiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwie1xcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IFtdO1xuICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9icmFjZWQoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX25vbkJyYWNlQ2hhcmFjdGVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQxLnB1c2gocmVzdWx0Mik7XG4gICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfYnJhY2VkKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQyID0gcGFyc2Vfbm9uQnJhY2VDaGFyYWN0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDEyNSkge1xuICAgICAgICAgICAgICByZXN1bHQyID0gXCJ9XCI7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIn1cXFwiXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBwYXJ0cykge1xuICAgICAgICAgICAgICByZXR1cm4gXCJ7XCIgKyBwYXJ0cy5qb2luKFwiXCIpICsgXCJ9XCI7XG4gICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX25vbkJyYWNlQ2hhcmFjdGVycygpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcmVzdWx0MSA9IHBhcnNlX25vbkJyYWNlQ2hhcmFjdGVyKCk7XG4gICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFtdO1xuICAgICAgICAgIHdoaWxlIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwLnB1c2gocmVzdWx0MSk7XG4gICAgICAgICAgICByZXN1bHQxID0gcGFyc2Vfbm9uQnJhY2VDaGFyYWN0ZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgY2hhcnMpIHsgcmV0dXJuIGNoYXJzLmpvaW4oXCJcIik7IH0pKHBvczAsIHJlc3VsdDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfbm9uQnJhY2VDaGFyYWN0ZXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICBcbiAgICAgICAgaWYgKC9eW157fV0vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbXnt9XVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2VxdWFscygpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNjEpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCI9XCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCI9XFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfX18oKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIFwiPVwiOyB9KShwb3MwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2NvbG9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA1OCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIjpcIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIjpcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9fXygpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCI6XCI7IH0pKHBvczApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc2VtaWNvbG9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA1OSkge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIjtcIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIjtcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9fXygpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCI7XCI7IH0pKHBvczApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc2xhc2goKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDQ3KSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiL1wiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiL1xcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX19fKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIi9cIjsgfSkocG9zMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9hbmQoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDM4KSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiJlwiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiJlxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX19fKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIiZcIjsgfSkocG9zMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9ub3QoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDMzKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiIVwiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiIVxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX19fKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIiFcIjsgfSkocG9zMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9xdWVzdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNjMpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCI/XCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCI/XFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfX18oKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIFwiP1wiOyB9KShwb3MwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3N0YXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDQyKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiKlwiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiKlxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX19fKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIipcIjsgfSkocG9zMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9wbHVzKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA0Mykge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIitcIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIitcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9fXygpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCIrXCI7IH0pKHBvczApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfbHBhcmVuKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA0MCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIihcIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIihcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9fXygpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCIoXCI7IH0pKHBvczApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfcnBhcmVuKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA0MSkge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIilcIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIilcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9fXygpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCIpXCI7IH0pKHBvczApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfZG90KCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA0Nikge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIi5cIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIi5cXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9fXygpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCIuXCI7IH0pKHBvczApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfaWRlbnRpZmllcigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcmVwb3J0RmFpbHVyZXMrKztcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2xldHRlcigpO1xuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDk1KSB7XG4gICAgICAgICAgICByZXN1bHQwID0gXCJfXCI7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiX1xcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAzNikge1xuICAgICAgICAgICAgICByZXN1bHQwID0gXCIkXCI7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIiRcXFwiXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IFtdO1xuICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9sZXR0ZXIoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX2RpZ2l0KCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA5NSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBcIl9cIjtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIl9cXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0MiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDM2KSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQyID0gXCIkXCI7XG4gICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiJFxcXCJcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQxLnB1c2gocmVzdWx0Mik7XG4gICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfbGV0dGVyKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfZGlnaXQoKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA5NSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IFwiX1wiO1xuICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIl9cXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMzYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IFwiJFwiO1xuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIkXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX19fKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBoZWFkLCB0YWlsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoZWFkICsgdGFpbC5qb2luKFwiXCIpO1xuICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJlcG9ydEZhaWx1cmVzLS07XG4gICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCAmJiByZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgbWF0Y2hGYWlsZWQoXCJpZGVudGlmaWVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9saXRlcmFsKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICByZXBvcnRGYWlsdXJlcysrO1xuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICByZXN1bHQwID0gcGFyc2VfZG91YmxlUXVvdGVkU3RyaW5nKCk7XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3NpbmdsZVF1b3RlZFN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMTA1KSB7XG4gICAgICAgICAgICByZXN1bHQxID0gXCJpXCI7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiaVxcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdDEgPSByZXN1bHQxICE9PSBudWxsID8gcmVzdWx0MSA6IFwiXCI7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9fXygpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUsIGZsYWdzKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJsaXRlcmFsXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgaWdub3JlQ2FzZTogZmxhZ3MgPT09IFwiaVwiXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzBdLCByZXN1bHQwWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmVwb3J0RmFpbHVyZXMtLTtcbiAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwICYmIHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBtYXRjaEZhaWxlZChcImxpdGVyYWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3N0cmluZygpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcmVwb3J0RmFpbHVyZXMrKztcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2RvdWJsZVF1b3RlZFN0cmluZygpO1xuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9zaW5nbGVRdW90ZWRTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9fXygpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgc3RyaW5nKSB7IHJldHVybiBzdHJpbmc7IH0pKHBvczAsIHJlc3VsdDBbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXBvcnRGYWlsdXJlcy0tO1xuICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDAgJiYgcmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIG1hdGNoRmFpbGVkKFwic3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9kb3VibGVRdW90ZWRTdHJpbmcoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDM0KSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiXFxcIlwiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXCJcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBbXTtcbiAgICAgICAgICByZXN1bHQyID0gcGFyc2VfZG91YmxlUXVvdGVkQ2hhcmFjdGVyKCk7XG4gICAgICAgICAgd2hpbGUgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDEucHVzaChyZXN1bHQyKTtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9kb3VibGVRdW90ZWRDaGFyYWN0ZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDM0KSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBcIlxcXCJcIjtcbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXCJcXFwiXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBjaGFycykgeyByZXR1cm4gY2hhcnMuam9pbihcIlwiKTsgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9kb3VibGVRdW90ZWRDaGFyYWN0ZXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICBcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3NpbXBsZURvdWJsZVF1b3RlZENoYXJhY3RlcigpO1xuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9zaW1wbGVFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfemVyb0VzY2FwZVNlcXVlbmNlKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfaGV4RXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfdW5pY29kZUVzY2FwZVNlcXVlbmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9lb2xFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc2ltcGxlRG91YmxlUXVvdGVkQ2hhcmFjdGVyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczEsIHBvczI7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBwb3MyID0gcG9zO1xuICAgICAgICByZXBvcnRGYWlsdXJlcysrO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAzNCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXCJcIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFwiXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA5Mikge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFwiXFxcXFwiO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxcXFxcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9lb2xDaGFyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcG9ydEZhaWx1cmVzLS07XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGggPiBwb3MpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcImFueSBjaGFyYWN0ZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgY2hhcl8pIHsgcmV0dXJuIGNoYXJfOyB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3NpbmdsZVF1b3RlZFN0cmluZygpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMzkpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCInXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCInXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gW107XG4gICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX3NpbmdsZVF1b3RlZENoYXJhY3RlcigpO1xuICAgICAgICAgIHdoaWxlIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQxLnB1c2gocmVzdWx0Mik7XG4gICAgICAgICAgICByZXN1bHQyID0gcGFyc2Vfc2luZ2xlUXVvdGVkQ2hhcmFjdGVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAzOSkge1xuICAgICAgICAgICAgICByZXN1bHQyID0gXCInXCI7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIidcXFwiXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBjaGFycykgeyByZXR1cm4gY2hhcnMuam9pbihcIlwiKTsgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zaW5nbGVRdW90ZWRDaGFyYWN0ZXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICBcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3NpbXBsZVNpbmdsZVF1b3RlZENoYXJhY3RlcigpO1xuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9zaW1wbGVFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfemVyb0VzY2FwZVNlcXVlbmNlKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfaGV4RXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfdW5pY29kZUVzY2FwZVNlcXVlbmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9lb2xFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc2ltcGxlU2luZ2xlUXVvdGVkQ2hhcmFjdGVyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczEsIHBvczI7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBwb3MyID0gcG9zO1xuICAgICAgICByZXBvcnRGYWlsdXJlcysrO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAzOSkge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIidcIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIidcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDkyKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gXCJcXFxcXCI7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXFxcXFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2VvbENoYXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVwb3J0RmFpbHVyZXMtLTtcbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IHBvcykge1xuICAgICAgICAgICAgcmVzdWx0MSA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiYW55IGNoYXJhY3RlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBjaGFyXykgeyByZXR1cm4gY2hhcl87IH0pKHBvczAsIHJlc3VsdDBbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfY2xhc3MoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzLCByZXN1bHQ0LCByZXN1bHQ1O1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHJlcG9ydEZhaWx1cmVzKys7XG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDkxKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiW1wiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiW1xcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gOTQpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBcIl5cIjtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJeXFxcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0MSA9IHJlc3VsdDEgIT09IG51bGwgPyByZXN1bHQxIDogXCJcIjtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IFtdO1xuICAgICAgICAgICAgcmVzdWx0MyA9IHBhcnNlX2NsYXNzQ2hhcmFjdGVyUmFuZ2UoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDMgPSBwYXJzZV9jbGFzc0NoYXJhY3RlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHJlc3VsdDMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKHJlc3VsdDMpO1xuICAgICAgICAgICAgICByZXN1bHQzID0gcGFyc2VfY2xhc3NDaGFyYWN0ZXJSYW5nZSgpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0MyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDMgPSBwYXJzZV9jbGFzc0NoYXJhY3RlcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA5Mykge1xuICAgICAgICAgICAgICAgIHJlc3VsdDMgPSBcIl1cIjtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIl1cXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDEwNSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0NCA9IFwiaVwiO1xuICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcImlcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQ0ID0gcmVzdWx0NCAhPT0gbnVsbCA/IHJlc3VsdDQgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQ1ID0gcGFyc2VfX18oKTtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQ1ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MywgcmVzdWx0NCwgcmVzdWx0NV07XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGludmVydGVkLCBwYXJ0cywgZmxhZ3MpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcnRzQ29udmVydGVkID0gbWFwKHBhcnRzLCBmdW5jdGlvbihwYXJ0KSB7IHJldHVybiBwYXJ0LmRhdGE7IH0pO1xuICAgICAgICAgICAgICB2YXIgcmF3VGV4dCA9IFwiW1wiXG4gICAgICAgICAgICAgICAgKyBpbnZlcnRlZFxuICAgICAgICAgICAgICAgICsgbWFwKHBhcnRzLCBmdW5jdGlvbihwYXJ0KSB7IHJldHVybiBwYXJ0LnJhd1RleHQ7IH0pLmpvaW4oXCJcIilcbiAgICAgICAgICAgICAgICArIFwiXVwiXG4gICAgICAgICAgICAgICAgKyBmbGFncztcbiAgICAgICAgXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJjbGFzc1wiLFxuICAgICAgICAgICAgICAgIGludmVydGVkOiAgIGludmVydGVkID09PSBcIl5cIixcbiAgICAgICAgICAgICAgICBpZ25vcmVDYXNlOiBmbGFncyA9PT0gXCJpXCIsXG4gICAgICAgICAgICAgICAgcGFydHM6ICAgICAgcGFydHNDb252ZXJ0ZWQsXG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IEdldCB0aGUgcmF3IHRleHQgZnJvbSB0aGUgaW5wdXQgZGlyZWN0bHkuXG4gICAgICAgICAgICAgICAgcmF3VGV4dDogICAgcmF3VGV4dFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFsxXSwgcmVzdWx0MFsyXSwgcmVzdWx0MFs0XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJlcG9ydEZhaWx1cmVzLS07XG4gICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCAmJiByZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgbWF0Y2hGYWlsZWQoXCJjaGFyYWN0ZXIgY2xhc3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2NsYXNzQ2hhcmFjdGVyUmFuZ2UoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV9jbGFzc0NoYXJhY3RlcigpO1xuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDQ1KSB7XG4gICAgICAgICAgICByZXN1bHQxID0gXCItXCI7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiLVxcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfY2xhc3NDaGFyYWN0ZXIoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0Ml07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGJlZ2luLCBlbmQpIHtcbiAgICAgICAgICAgICAgaWYgKGJlZ2luLmRhdGEuY2hhckNvZGVBdCgwKSA+IGVuZC5kYXRhLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdGhpcy5TeW50YXhFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiSW52YWxpZCBjaGFyYWN0ZXIgcmFuZ2U6IFwiICsgYmVnaW4ucmF3VGV4dCArIFwiLVwiICsgZW5kLnJhd1RleHQgKyBcIi5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogICAgW2JlZ2luLmRhdGEsIGVuZC5kYXRhXSxcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogR2V0IHRoZSByYXcgdGV4dCBmcm9tIHRoZSBpbnB1dCBkaXJlY3RseS5cbiAgICAgICAgICAgICAgICByYXdUZXh0OiBiZWdpbi5yYXdUZXh0ICsgXCItXCIgKyBlbmQucmF3VGV4dFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9jbGFzc0NoYXJhY3RlcigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgIHZhciBwb3MwO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2JyYWNrZXREZWxpbWl0ZWRDaGFyYWN0ZXIoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgY2hhcl8pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiAgICBjaGFyXyxcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogR2V0IHRoZSByYXcgdGV4dCBmcm9tIHRoZSBpbnB1dCBkaXJlY3RseS5cbiAgICAgICAgICAgICAgICByYXdUZXh0OiBxdW90ZUZvclJlZ2V4cENsYXNzKGNoYXJfKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9icmFja2V0RGVsaW1pdGVkQ2hhcmFjdGVyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgXG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV9zaW1wbGVCcmFja2V0RGVsaW1pdGVkQ2hhcmFjdGVyKCk7XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3NpbXBsZUVzY2FwZVNlcXVlbmNlKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV96ZXJvRXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9oZXhFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV91bmljb2RlRXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2VvbEVzY2FwZVNlcXVlbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zaW1wbGVCcmFja2V0RGVsaW1pdGVkQ2hhcmFjdGVyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczEsIHBvczI7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBwb3MyID0gcG9zO1xuICAgICAgICByZXBvcnRGYWlsdXJlcysrO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA5Mykge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIl1cIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIl1cXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDkyKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gXCJcXFxcXCI7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXFxcXFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2VvbENoYXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVwb3J0RmFpbHVyZXMtLTtcbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IHBvcykge1xuICAgICAgICAgICAgcmVzdWx0MSA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiYW55IGNoYXJhY3RlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBjaGFyXykgeyByZXR1cm4gY2hhcl87IH0pKHBvczAsIHJlc3VsdDBbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc2ltcGxlRXNjYXBlU2VxdWVuY2UoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMSwgcG9zMjtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDkyKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiXFxcXFwiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXFxcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHBvczIgPSBwb3M7XG4gICAgICAgICAgcmVwb3J0RmFpbHVyZXMrKztcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfZGlnaXQoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMTIwKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDEgPSBcInhcIjtcbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwieFxcXCJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQxID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDExNykge1xuICAgICAgICAgICAgICAgIHJlc3VsdDEgPSBcInVcIjtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcInVcXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0MSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9lb2xDaGFyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVwb3J0RmFpbHVyZXMtLTtcbiAgICAgICAgICBpZiAocmVzdWx0MSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MSA9IFwiXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGggPiBwb3MpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcImFueSBjaGFyYWN0ZXJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0Ml07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGNoYXJfKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjaGFyX1xuICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwiYlwiLCBcIlxcYlwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwiZlwiLCBcIlxcZlwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwiblwiLCBcIlxcblwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwiclwiLCBcIlxcclwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwidFwiLCBcIlxcdFwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwidlwiLCBcIlxceDBCXCIpOyAvLyBJRSBkb2VzIG5vdCByZWNvZ25pemUgXCJcXHZcIi5cbiAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMl0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfemVyb0VzY2FwZVNlcXVlbmNlKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczEsIHBvczI7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMikgPT09IFwiXFxcXDBcIikge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXFwwXCI7XG4gICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXDBcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHBvczIgPSBwb3M7XG4gICAgICAgICAgcmVwb3J0RmFpbHVyZXMrKztcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfZGlnaXQoKTtcbiAgICAgICAgICByZXBvcnRGYWlsdXJlcy0tO1xuICAgICAgICAgIGlmIChyZXN1bHQxID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQxID0gXCJcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIFwiXFx4MDBcIjsgfSkocG9zMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9oZXhFc2NhcGVTZXF1ZW5jZSgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIlxcXFx4XCIpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCJcXFxceFwiO1xuICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXFx4XFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfaGV4RGlnaXQoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX2hleERpZ2l0KCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBoMSwgaDIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaDEgKyBoMiwgMTYpKTtcbiAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMV0sIHJlc3VsdDBbMl0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfdW5pY29kZUVzY2FwZVNlcXVlbmNlKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MywgcmVzdWx0NDtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMikgPT09IFwiXFxcXHVcIikge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXFx1XCI7XG4gICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXHVcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9oZXhEaWdpdCgpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfaGV4RGlnaXQoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDMgPSBwYXJzZV9oZXhEaWdpdCgpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDQgPSBwYXJzZV9oZXhEaWdpdCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDMsIHJlc3VsdDRdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgaDEsIGgyLCBoMywgaDQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaDEgKyBoMiArIGgzICsgaDQsIDE2KSk7XG4gICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzFdLCByZXN1bHQwWzJdLCByZXN1bHQwWzNdLCByZXN1bHQwWzRdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2VvbEVzY2FwZVNlcXVlbmNlKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA5Mikge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXFxcIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxcXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfZW9sKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBlb2wpIHsgcmV0dXJuIGVvbDsgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9kaWdpdCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgIFxuICAgICAgICBpZiAoL15bMC05XS8udGVzdChpbnB1dC5jaGFyQXQocG9zKSkpIHtcbiAgICAgICAgICByZXN1bHQwID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlswLTldXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfaGV4RGlnaXQoKSB7XG4gICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICBcbiAgICAgICAgaWYgKC9eWzAtOWEtZkEtRl0vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbMC05YS1mQS1GXVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2xldHRlcigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgIFxuICAgICAgICByZXN1bHQwID0gcGFyc2VfbG93ZXJDYXNlTGV0dGVyKCk7XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3VwcGVyQ2FzZUxldHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9sb3dlckNhc2VMZXR0ZXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICBcbiAgICAgICAgaWYgKC9eW2Etel0vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbYS16XVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3VwcGVyQ2FzZUxldHRlcigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgIFxuICAgICAgICBpZiAoL15bQS1aXS8udGVzdChpbnB1dC5jaGFyQXQocG9zKSkpIHtcbiAgICAgICAgICByZXN1bHQwID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIltBLVpdXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfX18oKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICBcbiAgICAgICAgcmVzdWx0MCA9IFtdO1xuICAgICAgICByZXN1bHQxID0gcGFyc2Vfd2hpdGVzcGFjZSgpO1xuICAgICAgICBpZiAocmVzdWx0MSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9lb2woKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2NvbW1lbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwLnB1c2gocmVzdWx0MSk7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX3doaXRlc3BhY2UoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2VvbCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2NvbW1lbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2NvbW1lbnQoKSB7XG4gICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICBcbiAgICAgICAgcmVwb3J0RmFpbHVyZXMrKztcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3NpbmdsZUxpbmVDb21tZW50KCk7XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX211bHRpTGluZUNvbW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXBvcnRGYWlsdXJlcy0tO1xuICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDAgJiYgcmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIG1hdGNoRmFpbGVkKFwiY29tbWVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc2luZ2xlTGluZUNvbW1lbnQoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMSwgcG9zMjtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCIvL1wiKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiLy9cIjtcbiAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIi8vXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gW107XG4gICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICBwb3MyID0gcG9zO1xuICAgICAgICAgIHJlcG9ydEZhaWx1cmVzKys7XG4gICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX2VvbENoYXIoKTtcbiAgICAgICAgICByZXBvcnRGYWlsdXJlcy0tO1xuICAgICAgICAgIGlmIChyZXN1bHQyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gXCJcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IHBvcykge1xuICAgICAgICAgICAgICByZXN1bHQzID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MyA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiYW55IGNoYXJhY3RlclwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IFtyZXN1bHQyLCByZXN1bHQzXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQxLnB1c2gocmVzdWx0Mik7XG4gICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgcG9zMiA9IHBvcztcbiAgICAgICAgICAgIHJlcG9ydEZhaWx1cmVzKys7XG4gICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfZW9sQ2hhcigpO1xuICAgICAgICAgICAgcmVwb3J0RmFpbHVyZXMtLTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBcIlwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MyA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJhbnkgY2hhcmFjdGVyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBbcmVzdWx0MiwgcmVzdWx0M107XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX211bHRpTGluZUNvbW1lbnQoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMSwgcG9zMjtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCIvKlwiKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiLypcIjtcbiAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIi8qXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gW107XG4gICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICBwb3MyID0gcG9zO1xuICAgICAgICAgIHJlcG9ydEZhaWx1cmVzKys7XG4gICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIiovXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBcIiovXCI7XG4gICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiKi9cXFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXBvcnRGYWlsdXJlcy0tO1xuICAgICAgICAgIGlmIChyZXN1bHQyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gXCJcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IHBvcykge1xuICAgICAgICAgICAgICByZXN1bHQzID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MyA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiYW55IGNoYXJhY3RlclwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IFtyZXN1bHQyLCByZXN1bHQzXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQxLnB1c2gocmVzdWx0Mik7XG4gICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgcG9zMiA9IHBvcztcbiAgICAgICAgICAgIHJlcG9ydEZhaWx1cmVzKys7XG4gICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMikgPT09IFwiKi9cIikge1xuICAgICAgICAgICAgICByZXN1bHQyID0gXCIqL1wiO1xuICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIqL1xcXCJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcG9ydEZhaWx1cmVzLS07XG4gICAgICAgICAgICBpZiAocmVzdWx0MiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQyID0gXCJcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IHBvcykge1xuICAgICAgICAgICAgICAgIHJlc3VsdDMgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiYW55IGNoYXJhY3RlclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gW3Jlc3VsdDIsIHJlc3VsdDNdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIiovXCIpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IFwiKi9cIjtcbiAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiKi9cXFwiXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfZW9sKCkge1xuICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgXG4gICAgICAgIHJlcG9ydEZhaWx1cmVzKys7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDEwKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiXFxuXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcblxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIlxcclxcblwiKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gXCJcXHJcXG5cIjtcbiAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcclxcXFxuXFxcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDEzKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcclwiO1xuICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcclxcXCJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDgyMzIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gXCJcXHUyMDI4XCI7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcdTIwMjhcXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDgyMzMpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcdTIwMjlcIjtcbiAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcdTIwMjlcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXBvcnRGYWlsdXJlcy0tO1xuICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDAgJiYgcmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIG1hdGNoRmFpbGVkKFwiZW5kIG9mIGxpbmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2VvbENoYXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICBcbiAgICAgICAgaWYgKC9eW1xcblxcclxcdTIwMjhcXHUyMDI5XS8udGVzdChpbnB1dC5jaGFyQXQocG9zKSkpIHtcbiAgICAgICAgICByZXN1bHQwID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIltcXFxcblxcXFxyXFxcXHUyMDI4XFxcXHUyMDI5XVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3doaXRlc3BhY2UoKSB7XG4gICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICBcbiAgICAgICAgcmVwb3J0RmFpbHVyZXMrKztcbiAgICAgICAgaWYgKC9eWyBcXHRcXHgwQlxcZlxceEEwXFx1RkVGRlxcdTE2ODBcXHUxODBFXFx1MjAwMC1cXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXS8udGVzdChpbnB1dC5jaGFyQXQocG9zKSkpIHtcbiAgICAgICAgICByZXN1bHQwID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlsgXFxcXHRcXFxceDBCXFxcXGZcXFxceEEwXFxcXHVGRUZGXFxcXHUxNjgwXFxcXHUxODBFXFxcXHUyMDAwLVxcXFx1MjAwQVxcXFx1MjAyRlxcXFx1MjA1RlxcXFx1MzAwMF1cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcG9ydEZhaWx1cmVzLS07XG4gICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCAmJiByZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgbWF0Y2hGYWlsZWQoXCJ3aGl0ZXNwYWNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIGNsZWFudXBFeHBlY3RlZChleHBlY3RlZCkge1xuICAgICAgICBleHBlY3RlZC5zb3J0KCk7XG4gICAgICAgIFxuICAgICAgICB2YXIgbGFzdEV4cGVjdGVkID0gbnVsbDtcbiAgICAgICAgdmFyIGNsZWFuRXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChleHBlY3RlZFtpXSAhPT0gbGFzdEV4cGVjdGVkKSB7XG4gICAgICAgICAgICBjbGVhbkV4cGVjdGVkLnB1c2goZXhwZWN0ZWRbaV0pO1xuICAgICAgICAgICAgbGFzdEV4cGVjdGVkID0gZXhwZWN0ZWRbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGVhbkV4cGVjdGVkO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBjb21wdXRlRXJyb3JQb3NpdGlvbigpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhlIGZpcnN0IGlkZWEgd2FzIHRvIHVzZSB8U3RyaW5nLnNwbGl0fCB0byBicmVhayB0aGUgaW5wdXQgdXAgdG8gdGhlXG4gICAgICAgICAqIGVycm9yIHBvc2l0aW9uIGFsb25nIG5ld2xpbmVzIGFuZCBkZXJpdmUgdGhlIGxpbmUgYW5kIGNvbHVtbiBmcm9tXG4gICAgICAgICAqIHRoZXJlLiBIb3dldmVyIElFJ3MgfHNwbGl0fCBpbXBsZW1lbnRhdGlvbiBpcyBzbyBicm9rZW4gdGhhdCBpdCB3YXNcbiAgICAgICAgICogZW5vdWdoIHRvIHByZXZlbnQgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBcbiAgICAgICAgdmFyIGxpbmUgPSAxO1xuICAgICAgICB2YXIgY29sdW1uID0gMTtcbiAgICAgICAgdmFyIHNlZW5DUiA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLm1heChwb3MsIHJpZ2h0bW9zdEZhaWx1cmVzUG9zKTsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNoID0gaW5wdXQuY2hhckF0KGkpO1xuICAgICAgICAgIGlmIChjaCA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgaWYgKCFzZWVuQ1IpIHsgbGluZSsrOyB9XG4gICAgICAgICAgICBjb2x1bW4gPSAxO1xuICAgICAgICAgICAgc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJcXHJcIiB8fCBjaCA9PT0gXCJcXHUyMDI4XCIgfHwgY2ggPT09IFwiXFx1MjAyOVwiKSB7XG4gICAgICAgICAgICBsaW5lKys7XG4gICAgICAgICAgICBjb2x1bW4gPSAxO1xuICAgICAgICAgICAgc2VlbkNSID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sdW1uKys7XG4gICAgICAgICAgICBzZWVuQ1IgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IGxpbmU6IGxpbmUsIGNvbHVtbjogY29sdW1uIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIFxuICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlRnVuY3Rpb25zW3N0YXJ0UnVsZV0oKTtcbiAgICAgIFxuICAgICAgLypcbiAgICAgICAqIFRoZSBwYXJzZXIgaXMgbm93IGluIG9uZSBvZiB0aGUgZm9sbG93aW5nIHRocmVlIHN0YXRlczpcbiAgICAgICAqXG4gICAgICAgKiAxLiBUaGUgcGFyc2VyIHN1Y2Nlc3NmdWxseSBwYXJzZWQgdGhlIHdob2xlIGlucHV0LlxuICAgICAgICpcbiAgICAgICAqICAgIC0gfHJlc3VsdCAhPT0gbnVsbHxcbiAgICAgICAqICAgIC0gfHBvcyA9PT0gaW5wdXQubGVuZ3RofFxuICAgICAgICogICAgLSB8cmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZHwgbWF5IG9yIG1heSBub3QgY29udGFpbiBzb21ldGhpbmdcbiAgICAgICAqXG4gICAgICAgKiAyLiBUaGUgcGFyc2VyIHN1Y2Nlc3NmdWxseSBwYXJzZWQgb25seSBhIHBhcnQgb2YgdGhlIGlucHV0LlxuICAgICAgICpcbiAgICAgICAqICAgIC0gfHJlc3VsdCAhPT0gbnVsbHxcbiAgICAgICAqICAgIC0gfHBvcyA8IGlucHV0Lmxlbmd0aHxcbiAgICAgICAqICAgIC0gfHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWR8IG1heSBvciBtYXkgbm90IGNvbnRhaW4gc29tZXRoaW5nXG4gICAgICAgKlxuICAgICAgICogMy4gVGhlIHBhcnNlciBkaWQgbm90IHN1Y2Nlc3NmdWxseSBwYXJzZSBhbnkgcGFydCBvZiB0aGUgaW5wdXQuXG4gICAgICAgKlxuICAgICAgICogICAtIHxyZXN1bHQgPT09IG51bGx8XG4gICAgICAgKiAgIC0gfHBvcyA9PT0gMHxcbiAgICAgICAqICAgLSB8cmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZHwgY29udGFpbnMgYXQgbGVhc3Qgb25lIGZhaWx1cmVcbiAgICAgICAqXG4gICAgICAgKiBBbGwgY29kZSBmb2xsb3dpbmcgdGhpcyBjb21tZW50IChpbmNsdWRpbmcgY2FsbGVkIGZ1bmN0aW9ucykgbXVzdFxuICAgICAgICogaGFuZGxlIHRoZXNlIHN0YXRlcy5cbiAgICAgICAqL1xuICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCBwb3MgIT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gTWF0aC5tYXgocG9zLCByaWdodG1vc3RGYWlsdXJlc1Bvcyk7XG4gICAgICAgIHZhciBmb3VuZCA9IG9mZnNldCA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChvZmZzZXQpIDogbnVsbDtcbiAgICAgICAgdmFyIGVycm9yUG9zaXRpb24gPSBjb21wdXRlRXJyb3JQb3NpdGlvbigpO1xuICAgICAgICBcbiAgICAgICAgdGhyb3cgbmV3IHRoaXMuU3ludGF4RXJyb3IoXG4gICAgICAgICAgY2xlYW51cEV4cGVjdGVkKHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWQpLFxuICAgICAgICAgIGZvdW5kLFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICBlcnJvclBvc2l0aW9uLmxpbmUsXG4gICAgICAgICAgZXJyb3JQb3NpdGlvbi5jb2x1bW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIFxuICAgIC8qIFJldHVybnMgdGhlIHBhcnNlciBzb3VyY2UgY29kZS4gKi9cbiAgICB0b1NvdXJjZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9zb3VyY2U7IH1cbiAgfTtcbiAgXG4gIC8qIFRocm93biB3aGVuIGEgcGFyc2VyIGVuY291bnRlcnMgYSBzeW50YXggZXJyb3IuICovXG4gIFxuICByZXN1bHQuU3ludGF4RXJyb3IgPSBmdW5jdGlvbihleHBlY3RlZCwgZm91bmQsIG9mZnNldCwgbGluZSwgY29sdW1uKSB7XG4gICAgZnVuY3Rpb24gYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCkge1xuICAgICAgdmFyIGV4cGVjdGVkSHVtYW5pemVkLCBmb3VuZEh1bWFuaXplZDtcbiAgICAgIFxuICAgICAgc3dpdGNoIChleHBlY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGV4cGVjdGVkSHVtYW5pemVkID0gXCJlbmQgb2YgaW5wdXRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGV4cGVjdGVkSHVtYW5pemVkID0gZXhwZWN0ZWRbMF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZXhwZWN0ZWRIdW1hbml6ZWQgPSBleHBlY3RlZC5zbGljZSgwLCBleHBlY3RlZC5sZW5ndGggLSAxKS5qb2luKFwiLCBcIilcbiAgICAgICAgICAgICsgXCIgb3IgXCJcbiAgICAgICAgICAgICsgZXhwZWN0ZWRbZXhwZWN0ZWQubGVuZ3RoIC0gMV07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZvdW5kSHVtYW5pemVkID0gZm91bmQgPyBxdW90ZShmb3VuZCkgOiBcImVuZCBvZiBpbnB1dFwiO1xuICAgICAgXG4gICAgICByZXR1cm4gXCJFeHBlY3RlZCBcIiArIGV4cGVjdGVkSHVtYW5pemVkICsgXCIgYnV0IFwiICsgZm91bmRIdW1hbml6ZWQgKyBcIiBmb3VuZC5cIjtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5uYW1lID0gXCJTeW50YXhFcnJvclwiO1xuICAgIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICB0aGlzLmZvdW5kID0gZm91bmQ7XG4gICAgdGhpcy5tZXNzYWdlID0gYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCk7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5saW5lID0gbGluZTtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgfTtcbiAgXG4gIHJlc3VsdC5TeW50YXhFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG4gIFxuICByZXR1cm4gcmVzdWx0O1xufSkoKTtcblBFRy5jb21waWxlciA9IHtcbiAgLypcbiAgICogTmFtZXMgb2YgcGFzc2VzIHRoYXQgd2lsbCBnZXQgcnVuIGR1cmluZyB0aGUgY29tcGlsYXRpb24gKGluIHRoZSBzcGVjaWZpZWRcbiAgICogb3JkZXIpLlxuICAgKi9cbiAgYXBwbGllZFBhc3NOYW1lczogW1xuICAgIFwicmVwb3J0TWlzc2luZ1J1bGVzXCIsXG4gICAgXCJyZXBvcnRMZWZ0UmVjdXJzaW9uXCIsXG4gICAgXCJyZW1vdmVQcm94eVJ1bGVzXCIsXG4gICAgXCJjb21wdXRlVmFyTmFtZXNcIixcbiAgICBcImNvbXB1dGVQYXJhbXNcIlxuICBdLFxuXG4gIC8qXG4gICAqIEdlbmVyYXRlcyBhIHBhcnNlciBmcm9tIGEgc3BlY2lmaWVkIGdyYW1tYXIgQVNULiBUaHJvd3MgfFBFRy5HcmFtbWFyRXJyb3J8XG4gICAqIGlmIHRoZSBBU1QgY29udGFpbnMgYSBzZW1hbnRpYyBlcnJvci4gTm90ZSB0aGF0IG5vdCBhbGwgZXJyb3JzIGFyZSBkZXRlY3RlZFxuICAgKiBkdXJpbmcgdGhlIGdlbmVyYXRpb24gYW5kIHNvbWUgbWF5IHByb3RydWRlIHRvIHRoZSBnZW5lcmF0ZWQgcGFyc2VyIGFuZFxuICAgKiBjYXVzZSBpdHMgbWFsZnVuY3Rpb24uXG4gICAqL1xuICBjb21waWxlOiBmdW5jdGlvbihhc3QsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICBlYWNoKHRoaXMuYXBwbGllZFBhc3NOYW1lcywgZnVuY3Rpb24ocGFzc05hbWUpIHtcbiAgICAgIHRoYXQucGFzc2VzW3Bhc3NOYW1lXShhc3QpO1xuICAgIH0pO1xuXG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuZW1pdHRlcihhc3QsIG9wdGlvbnMpO1xuICAgIHZhciByZXN1bHQgPSBldmFsKHNvdXJjZSk7XG4gICAgcmVzdWx0Ll9zb3VyY2UgPSBzb3VyY2U7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG4vKlxuICogQ29tcGlsZXIgcGFzc2VzLlxuICpcbiAqIEVhY2ggcGFzcyBpcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcGFzc2VkIHRoZSBBU1QuIEl0IGNhbiBwZXJmb3JtIGNoZWNrcyBvbiBpdFxuICogb3IgbW9kaWZ5IGl0IGFzIG5lZWRlZC4gSWYgdGhlIHBhc3MgZW5jb3VudGVycyBhIHNlbWFudGljIGVycm9yLCBpdCB0aHJvd3NcbiAqIHxQRUcuR3JhbW1hckVycm9yfC5cbiAqL1xuUEVHLmNvbXBpbGVyLnBhc3NlcyA9IHtcbiAgLyogQ2hlY2tzIHRoYXQgYWxsIHJlZmVyZW5jZWQgcnVsZXMgZXhpc3QuICovXG4gIHJlcG9ydE1pc3NpbmdSdWxlczogZnVuY3Rpb24oYXN0KSB7XG4gICAgZnVuY3Rpb24gbm9wKCkge31cblxuICAgIGZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbihub2RlKSB7IGNoZWNrKG5vZGUuZXhwcmVzc2lvbik7IH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrU3Vibm9kZXMocHJvcGVydHlOYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24obm9kZSkgeyBlYWNoKG5vZGVbcHJvcGVydHlOYW1lXSwgY2hlY2spOyB9O1xuICAgIH1cblxuICAgIHZhciBjaGVjayA9IGJ1aWxkTm9kZVZpc2l0b3Ioe1xuICAgICAgZ3JhbW1hcjogICAgICBjaGVja1N1Ym5vZGVzKFwicnVsZXNcIiksXG4gICAgICBydWxlOiAgICAgICAgIGNoZWNrRXhwcmVzc2lvbixcbiAgICAgIGNob2ljZTogICAgICAgY2hlY2tTdWJub2RlcyhcImFsdGVybmF0aXZlc1wiKSxcbiAgICAgIHNlcXVlbmNlOiAgICAgY2hlY2tTdWJub2RlcyhcImVsZW1lbnRzXCIpLFxuICAgICAgbGFiZWxlZDogICAgICBjaGVja0V4cHJlc3Npb24sXG4gICAgICBzaW1wbGVfYW5kOiAgIGNoZWNrRXhwcmVzc2lvbixcbiAgICAgIHNpbXBsZV9ub3Q6ICAgY2hlY2tFeHByZXNzaW9uLFxuICAgICAgc2VtYW50aWNfYW5kOiBub3AsXG4gICAgICBzZW1hbnRpY19ub3Q6IG5vcCxcbiAgICAgIG9wdGlvbmFsOiAgICAgY2hlY2tFeHByZXNzaW9uLFxuICAgICAgemVyb19vcl9tb3JlOiBjaGVja0V4cHJlc3Npb24sXG4gICAgICBvbmVfb3JfbW9yZTogIGNoZWNrRXhwcmVzc2lvbixcbiAgICAgIGFjdGlvbjogICAgICAgY2hlY2tFeHByZXNzaW9uLFxuXG4gICAgICBydWxlX3JlZjpcbiAgICAgICAgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIGlmICghZmluZFJ1bGVCeU5hbWUoYXN0LCBub2RlLm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUEVHLkdyYW1tYXJFcnJvcihcbiAgICAgICAgICAgICAgXCJSZWZlcmVuY2VkIHJ1bGUgXFxcIlwiICsgbm9kZS5uYW1lICsgXCJcXFwiIGRvZXMgbm90IGV4aXN0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgbGl0ZXJhbDogICAgICBub3AsXG4gICAgICBhbnk6ICAgICAgICAgIG5vcCxcbiAgICAgIFwiY2xhc3NcIjogICAgICBub3BcbiAgICB9KTtcblxuICAgIGNoZWNrKGFzdCk7XG4gIH0sXG5cbiAgLyogQ2hlY2tzIHRoYXQgbm8gbGVmdCByZWN1cnNpb24gaXMgcHJlc2VudC4gKi9cbiAgcmVwb3J0TGVmdFJlY3Vyc2lvbjogZnVuY3Rpb24oYXN0KSB7XG4gICAgZnVuY3Rpb24gbm9wKCkge31cblxuICAgIGZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbihub2RlLCBhcHBsaWVkUnVsZXMpIHtcbiAgICAgIGNoZWNrKG5vZGUuZXhwcmVzc2lvbiwgYXBwbGllZFJ1bGVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1N1Ym5vZGVzKHByb3BlcnR5TmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUsIGFwcGxpZWRSdWxlcykge1xuICAgICAgICBlYWNoKG5vZGVbcHJvcGVydHlOYW1lXSwgZnVuY3Rpb24oc3Vibm9kZSkge1xuICAgICAgICAgIGNoZWNrKHN1Ym5vZGUsIGFwcGxpZWRSdWxlcyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgY2hlY2sgPSBidWlsZE5vZGVWaXNpdG9yKHtcbiAgICAgIGdyYW1tYXI6ICAgICBjaGVja1N1Ym5vZGVzKFwicnVsZXNcIiksXG5cbiAgICAgIHJ1bGU6XG4gICAgICAgIGZ1bmN0aW9uKG5vZGUsIGFwcGxpZWRSdWxlcykge1xuICAgICAgICAgIGNoZWNrKG5vZGUuZXhwcmVzc2lvbiwgYXBwbGllZFJ1bGVzLmNvbmNhdChub2RlLm5hbWUpKTtcbiAgICAgICAgfSxcblxuICAgICAgY2hvaWNlOiAgICAgIGNoZWNrU3Vibm9kZXMoXCJhbHRlcm5hdGl2ZXNcIiksXG5cbiAgICAgIHNlcXVlbmNlOlxuICAgICAgICBmdW5jdGlvbihub2RlLCBhcHBsaWVkUnVsZXMpIHtcbiAgICAgICAgICBpZiAobm9kZS5lbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjaGVjayhub2RlLmVsZW1lbnRzWzBdLCBhcHBsaWVkUnVsZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgbGFiZWxlZDogICAgICBjaGVja0V4cHJlc3Npb24sXG4gICAgICBzaW1wbGVfYW5kOiAgIGNoZWNrRXhwcmVzc2lvbixcbiAgICAgIHNpbXBsZV9ub3Q6ICAgY2hlY2tFeHByZXNzaW9uLFxuICAgICAgc2VtYW50aWNfYW5kOiBub3AsXG4gICAgICBzZW1hbnRpY19ub3Q6IG5vcCxcbiAgICAgIG9wdGlvbmFsOiAgICAgY2hlY2tFeHByZXNzaW9uLFxuICAgICAgemVyb19vcl9tb3JlOiBjaGVja0V4cHJlc3Npb24sXG4gICAgICBvbmVfb3JfbW9yZTogIGNoZWNrRXhwcmVzc2lvbixcbiAgICAgIGFjdGlvbjogICAgICAgY2hlY2tFeHByZXNzaW9uLFxuXG4gICAgICBydWxlX3JlZjpcbiAgICAgICAgZnVuY3Rpb24obm9kZSwgYXBwbGllZFJ1bGVzKSB7XG4gICAgICAgICAgaWYgKGNvbnRhaW5zKGFwcGxpZWRSdWxlcywgbm9kZS5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBFRy5HcmFtbWFyRXJyb3IoXG4gICAgICAgICAgICAgIFwiTGVmdCByZWN1cnNpb24gZGV0ZWN0ZWQgZm9yIHJ1bGUgXFxcIlwiICsgbm9kZS5uYW1lICsgXCJcXFwiLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGVjayhmaW5kUnVsZUJ5TmFtZShhc3QsIG5vZGUubmFtZSksIGFwcGxpZWRSdWxlcyk7XG4gICAgICAgIH0sXG5cbiAgICAgIGxpdGVyYWw6ICAgICAgbm9wLFxuICAgICAgYW55OiAgICAgICAgICBub3AsXG4gICAgICBcImNsYXNzXCI6ICAgICAgbm9wXG4gICAgfSk7XG5cbiAgICBjaGVjayhhc3QsIFtdKTtcbiAgfSxcblxuICAvKlxuICAgKiBSZW1vdmVzIHByb3h5IHJ1bGVzIC0tIHRoYXQgaXMsIHJ1bGVzIHRoYXQgb25seSBkZWxlZ2F0ZSB0byBvdGhlciBydWxlLlxuICAgKi9cbiAgcmVtb3ZlUHJveHlSdWxlczogZnVuY3Rpb24oYXN0KSB7XG4gICAgZnVuY3Rpb24gaXNQcm94eVJ1bGUobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJydWxlXCIgJiYgbm9kZS5leHByZXNzaW9uLnR5cGUgPT09IFwicnVsZV9yZWZcIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlUnVsZVJlZnMoYXN0LCBmcm9tLCB0bykge1xuICAgICAgZnVuY3Rpb24gbm9wKCkge31cblxuICAgICAgZnVuY3Rpb24gcmVwbGFjZUluRXhwcmVzc2lvbihub2RlLCBmcm9tLCB0bykge1xuICAgICAgICByZXBsYWNlKG5vZGUuZXhwcmVzc2lvbiwgZnJvbSwgdG8pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZXBsYWNlSW5TdWJub2Rlcyhwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUsIGZyb20sIHRvKSB7XG4gICAgICAgICAgZWFjaChub2RlW3Byb3BlcnR5TmFtZV0sIGZ1bmN0aW9uKHN1Ym5vZGUpIHtcbiAgICAgICAgICAgIHJlcGxhY2Uoc3Vibm9kZSwgZnJvbSwgdG8pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVwbGFjZSA9IGJ1aWxkTm9kZVZpc2l0b3Ioe1xuICAgICAgICBncmFtbWFyOiAgICAgIHJlcGxhY2VJblN1Ym5vZGVzKFwicnVsZXNcIiksXG4gICAgICAgIHJ1bGU6ICAgICAgICAgcmVwbGFjZUluRXhwcmVzc2lvbixcbiAgICAgICAgY2hvaWNlOiAgICAgICByZXBsYWNlSW5TdWJub2RlcyhcImFsdGVybmF0aXZlc1wiKSxcbiAgICAgICAgc2VxdWVuY2U6ICAgICByZXBsYWNlSW5TdWJub2RlcyhcImVsZW1lbnRzXCIpLFxuICAgICAgICBsYWJlbGVkOiAgICAgIHJlcGxhY2VJbkV4cHJlc3Npb24sXG4gICAgICAgIHNpbXBsZV9hbmQ6ICAgcmVwbGFjZUluRXhwcmVzc2lvbixcbiAgICAgICAgc2ltcGxlX25vdDogICByZXBsYWNlSW5FeHByZXNzaW9uLFxuICAgICAgICBzZW1hbnRpY19hbmQ6IG5vcCxcbiAgICAgICAgc2VtYW50aWNfbm90OiBub3AsXG4gICAgICAgIG9wdGlvbmFsOiAgICAgcmVwbGFjZUluRXhwcmVzc2lvbixcbiAgICAgICAgemVyb19vcl9tb3JlOiByZXBsYWNlSW5FeHByZXNzaW9uLFxuICAgICAgICBvbmVfb3JfbW9yZTogIHJlcGxhY2VJbkV4cHJlc3Npb24sXG4gICAgICAgIGFjdGlvbjogICAgICAgcmVwbGFjZUluRXhwcmVzc2lvbixcblxuICAgICAgICBydWxlX3JlZjpcbiAgICAgICAgICBmdW5jdGlvbihub2RlLCBmcm9tLCB0bykge1xuICAgICAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gZnJvbSkge1xuICAgICAgICAgICAgICBub2RlLm5hbWUgPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgIGxpdGVyYWw6ICAgICAgbm9wLFxuICAgICAgICBhbnk6ICAgICAgICAgIG5vcCxcbiAgICAgICAgXCJjbGFzc1wiOiAgICAgIG5vcFxuICAgICAgfSk7XG5cbiAgICAgIHJlcGxhY2UoYXN0LCBmcm9tLCB0byk7XG4gICAgfVxuXG4gICAgdmFyIGluZGljZXMgPSBbXTtcblxuICAgIGVhY2goYXN0LnJ1bGVzLCBmdW5jdGlvbihydWxlLCBpKSB7XG4gICAgICBpZiAoaXNQcm94eVJ1bGUocnVsZSkpIHtcbiAgICAgICAgcmVwbGFjZVJ1bGVSZWZzKGFzdCwgcnVsZS5uYW1lLCBydWxlLmV4cHJlc3Npb24ubmFtZSk7XG4gICAgICAgIGlmIChydWxlLm5hbWUgPT09IGFzdC5zdGFydFJ1bGUpIHtcbiAgICAgICAgICBhc3Quc3RhcnRSdWxlID0gcnVsZS5leHByZXNzaW9uLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaW5kaWNlcy5yZXZlcnNlKCk7XG5cbiAgICBlYWNoKGluZGljZXMsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBhc3QucnVsZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKlxuICAgKiBDb21wdXRlcyBuYW1lcyBvZiB2YXJpYWJsZXMgdXNlZCBmb3Igc3RvcmluZyBtYXRjaCByZXN1bHRzIGFuZCBwYXJzZVxuICAgKiBwb3NpdGlvbnMgaW4gZ2VuZXJhdGVkIGNvZGUuIFRoZXNlIHZhcmlhYmxlcyBhcmUgb3JnYW5pemVkIGFzIHR3byBzdGFja3MuXG4gICAqIFRoZSBmb2xsb3dpbmcgd2lsbCBob2xkIGFmdGVyIHJ1bm5pbmcgdGhpcyBwYXNzOlxuICAgKlxuICAgKiAgICogQWxsIG5vZGVzIGV4Y2VwdCBcImdyYW1tYXJcIiBhbmQgXCJydWxlXCIgbm9kZXMgd2lsbCBoYXZlIGEgfHJlc3VsdFZhcnxcbiAgICogICAgIHByb3BlcnR5LiBJdCB3aWxsIGNvbnRhaW4gYSBuYW1lIG9mIHRoZSB2YXJpYWJsZSB0aGF0IHdpbGwgc3RvcmUgYVxuICAgKiAgICAgbWF0Y2ggcmVzdWx0IG9mIHRoZSBleHByZXNzaW9uIHJlcHJlc2VudGVkIGJ5IHRoZSBub2RlIGluIGdlbmVyYXRlZFxuICAgKiAgICAgY29kZS5cbiAgICpcbiAgICogICAqIFNvbWUgbm9kZXMgd2lsbCBoYXZlIGEgfHBvc1ZhcnwgcHJvcGVydHkuIEl0IHdpbGwgY29udGFpbiBhIG5hbWUgb2YgdGhlXG4gICAqICAgICB2YXJpYWJsZSB0aGF0IHdpbGwgc3RvcmUgYSBwYXJzZSBwb3NpdGlvbiBpbiBnZW5lcmF0ZWQgY29kZS5cbiAgICpcbiAgICogICAqIEFsbCBcInJ1bGVcIiBub2RlcyB3aWxsIGNvbnRhaW4gfHJlc3VsdFZhcnN8IGFuZCB8cG9zVmFyc3wgcHJvcGVydGllcy5cbiAgICogICAgIFRoZXkgd2lsbCBjb250YWluIGEgbGlzdCBvZiB2YWx1ZXMgb2YgfHJlc3VsdFZhcnwgYW5kIHxwb3NWYXJ8XG4gICAqICAgICBwcm9wZXJ0aWVzIHVzZWQgaW4gcnVsZSdzIHN1Ym5vZGVzLiAoVGhpcyBpcyB1c2VmdWwgdG8gZGVjbGFyZVxuICAgKiAgICAgdmFyaWFibGVzIGluIGdlbmVyYXRlZCBjb2RlLilcbiAgICovXG4gIGNvbXB1dGVWYXJOYW1lczogZnVuY3Rpb24oYXN0KSB7XG4gICAgZnVuY3Rpb24gcmVzdWx0VmFyKGluZGV4KSB7IHJldHVybiBcInJlc3VsdFwiICsgaW5kZXg7IH1cbiAgICBmdW5jdGlvbiBwb3NWYXIoaW5kZXgpICAgIHsgcmV0dXJuIFwicG9zXCIgICAgKyBpbmRleDsgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZUxlYWYobm9kZSwgaW5kZXgpIHtcbiAgICAgIG5vZGUucmVzdWx0VmFyID0gcmVzdWx0VmFyKGluZGV4LnJlc3VsdCk7XG5cbiAgICAgIHJldHVybiB7IHJlc3VsdDogMCwgcG9zOiAwIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZUZyb21FeHByZXNzaW9uKGRlbHRhKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24obm9kZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGRlcHRoID0gY29tcHV0ZShcbiAgICAgICAgICAgICAgbm9kZS5leHByZXNzaW9uLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiBpbmRleC5yZXN1bHQgKyBkZWx0YS5yZXN1bHQsXG4gICAgICAgICAgICAgICAgcG9zOiAgICBpbmRleC5wb3MgICAgKyBkZWx0YS5wb3NcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICBub2RlLnJlc3VsdFZhciA9IHJlc3VsdFZhcihpbmRleC5yZXN1bHQpO1xuICAgICAgICBpZiAoZGVsdGEucG9zICE9PSAwKSB7XG4gICAgICAgICAgbm9kZS5wb3NWYXIgPSBwb3NWYXIoaW5kZXgucG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiBkZXB0aC5yZXN1bHQgKyBkZWx0YS5yZXN1bHQsXG4gICAgICAgICAgcG9zOiAgICBkZXB0aC5wb3MgICAgKyBkZWx0YS5wb3NcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGNvbXB1dGUgPSBidWlsZE5vZGVWaXNpdG9yKHtcbiAgICAgIGdyYW1tYXI6XG4gICAgICAgIGZ1bmN0aW9uKG5vZGUsIGluZGV4KSB7XG4gICAgICAgICAgZWFjaChub2RlLnJ1bGVzLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICBjb21wdXRlKG5vZGUsIGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgcnVsZTpcbiAgICAgICAgZnVuY3Rpb24obm9kZSwgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgZGVwdGggPSBjb21wdXRlKG5vZGUuZXhwcmVzc2lvbiwgaW5kZXgpO1xuXG4gICAgICAgICAgbm9kZS5yZXN1bHRWYXIgID0gcmVzdWx0VmFyKGluZGV4LnJlc3VsdCk7XG4gICAgICAgICAgbm9kZS5yZXN1bHRWYXJzID0gbWFwKHJhbmdlKGRlcHRoLnJlc3VsdCArIDEpLCByZXN1bHRWYXIpO1xuICAgICAgICAgIG5vZGUucG9zVmFycyAgICA9IG1hcChyYW5nZShkZXB0aC5wb3MpLCAgICAgICAgcG9zVmFyKTtcbiAgICAgICAgfSxcblxuICAgICAgY2hvaWNlOlxuICAgICAgICBmdW5jdGlvbihub2RlLCBpbmRleCkge1xuICAgICAgICAgIHZhciBkZXB0aHMgPSBtYXAobm9kZS5hbHRlcm5hdGl2ZXMsIGZ1bmN0aW9uKGFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcHV0ZShhbHRlcm5hdGl2ZSwgaW5kZXgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbm9kZS5yZXN1bHRWYXIgPSByZXN1bHRWYXIoaW5kZXgucmVzdWx0KTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6IE1hdGgubWF4LmFwcGx5KG51bGwsIHBsdWNrKGRlcHRocywgXCJyZXN1bHRcIikpLFxuICAgICAgICAgICAgcG9zOiAgICBNYXRoLm1heC5hcHBseShudWxsLCBwbHVjayhkZXB0aHMsIFwicG9zXCIpKVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgIHNlcXVlbmNlOlxuICAgICAgICBmdW5jdGlvbihub2RlLCBpbmRleCkge1xuICAgICAgICAgIHZhciBkZXB0aHMgPSBtYXAobm9kZS5lbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXB1dGUoXG4gICAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICAgIHsgcmVzdWx0OiBpbmRleC5yZXN1bHQgKyBpLCBwb3M6IGluZGV4LnBvcyArIDEgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG5vZGUucmVzdWx0VmFyID0gcmVzdWx0VmFyKGluZGV4LnJlc3VsdCk7XG4gICAgICAgICAgbm9kZS5wb3NWYXIgICAgPSBwb3NWYXIoaW5kZXgucG9zKTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6XG4gICAgICAgICAgICAgIG5vZGUuZWxlbWVudHMubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgID8gTWF0aC5tYXguYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG1hcChkZXB0aHMsIGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIGkgKyBkLnJlc3VsdDsgfSlcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IDAsXG5cbiAgICAgICAgICAgIHBvczpcbiAgICAgICAgICAgICAgbm9kZS5lbGVtZW50cy5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgPyAxICsgTWF0aC5tYXguYXBwbHkobnVsbCwgcGx1Y2soZGVwdGhzLCBcInBvc1wiKSlcbiAgICAgICAgICAgICAgICA6IDFcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICBsYWJlbGVkOiAgICAgIGNvbXB1dGVGcm9tRXhwcmVzc2lvbih7IHJlc3VsdDogMCwgcG9zOiAwIH0pLFxuICAgICAgc2ltcGxlX2FuZDogICBjb21wdXRlRnJvbUV4cHJlc3Npb24oeyByZXN1bHQ6IDAsIHBvczogMSB9KSxcbiAgICAgIHNpbXBsZV9ub3Q6ICAgY29tcHV0ZUZyb21FeHByZXNzaW9uKHsgcmVzdWx0OiAwLCBwb3M6IDEgfSksXG4gICAgICBzZW1hbnRpY19hbmQ6IGNvbXB1dGVMZWFmLFxuICAgICAgc2VtYW50aWNfbm90OiBjb21wdXRlTGVhZixcbiAgICAgIG9wdGlvbmFsOiAgICAgY29tcHV0ZUZyb21FeHByZXNzaW9uKHsgcmVzdWx0OiAwLCBwb3M6IDAgfSksXG4gICAgICB6ZXJvX29yX21vcmU6IGNvbXB1dGVGcm9tRXhwcmVzc2lvbih7IHJlc3VsdDogMSwgcG9zOiAwIH0pLFxuICAgICAgb25lX29yX21vcmU6ICBjb21wdXRlRnJvbUV4cHJlc3Npb24oeyByZXN1bHQ6IDEsIHBvczogMCB9KSxcbiAgICAgIGFjdGlvbjogICAgICAgY29tcHV0ZUZyb21FeHByZXNzaW9uKHsgcmVzdWx0OiAwLCBwb3M6IDEgfSksXG4gICAgICBydWxlX3JlZjogICAgIGNvbXB1dGVMZWFmLFxuICAgICAgbGl0ZXJhbDogICAgICBjb21wdXRlTGVhZixcbiAgICAgIGFueTogICAgICAgICAgY29tcHV0ZUxlYWYsXG4gICAgICBcImNsYXNzXCI6ICAgICAgY29tcHV0ZUxlYWZcbiAgICB9KTtcblxuICAgIGNvbXB1dGUoYXN0LCB7IHJlc3VsdDogMCwgcG9zOiAwIH0pO1xuICB9LFxuXG4gIC8qXG4gICAqIFRoaXMgcGFzcyB3YWxrcyB0aHJvdWdoIHRoZSBBU1QgYW5kIHRyYWNrcyB3aGF0IGxhYmVscyBhcmUgdmlzaWJsZSBhdCBlYWNoXG4gICAqIHBvaW50LiBGb3IgXCJhY3Rpb25cIiwgXCJzZW1hbnRpY19hbmRcIiBhbmQgXCJzZW1hbnRpY19vclwiIG5vZGVzIGl0IGNvbXB1dGVzXG4gICAqIHBhcmFtZXRlciBuYW1lcyBhbmQgdmFsdWVzIGZvciB0aGUgZnVuY3Rpb24gdXNlZCBpbiBnZW5lcmF0ZWQgY29kZS4gKEluIHRoZVxuICAgKiBlbWl0dGVyLCB1c2VyJ3MgY29kZSBpcyB3cmFwcGVkIGludG8gYSBmdW5jdGlvbiB0aGF0IGlzIGltbWVkaWF0ZWx5XG4gICAqIGV4ZWN1dGVkLiBJdHMgcGFyYW1ldGVyIG5hbWVzIGNvcnJlc3BvbmQgdG8gdmlzaWJsZSBsYWJlbHMgYW5kIGl0c1xuICAgKiBwYXJhbWV0ZXIgdmFsdWVzIHRvIHRoZWlyIGNhcHR1cmVkIHZhbHVlcykuIEltcGxpY2l0bHksIHRoaXMgcGFzcyBkZWZpbmVzXG4gICAqIHNjb3BpbmcgcnVsZXMgZm9yIGxhYmVscy5cbiAgICpcbiAgICogQWZ0ZXIgcnVubmluZyB0aGlzIHBhc3MsIGFsbCBcImFjdGlvblwiLCBcInNlbWFudGljX2FuZFwiIGFuZCBcInNlbWFudGljX29yXCJcbiAgICogbm9kZXMgd2lsbCBoYXZlIGEgfHBhcmFtc3wgcHJvcGVydHkgY29udGFpbmluZyBhbiBvYmplY3QgbWFwcGluZyBwYXJhbWV0ZXJcbiAgICogbmFtZXMgdG8gdGhlIGV4cHJlc3Npb25zIHRoYXQgd2lsbCBiZSB1c2VkIGFzIHRoZWlyIHZhbHVlcy5cbiAgICovXG4gIGNvbXB1dGVQYXJhbXM6IGZ1bmN0aW9uKGFzdCkge1xuICAgIHZhciBlbnZzID0gW107XG5cbiAgICBmdW5jdGlvbiBzY29wZWQoZikge1xuICAgICAgZW52cy5wdXNoKHt9KTtcbiAgICAgIGYoKTtcbiAgICAgIGVudnMucG9wKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9wKCkge31cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVGb3JTY29wZWRFeHByZXNzaW9uKG5vZGUpIHtcbiAgICAgIHNjb3BlZChmdW5jdGlvbigpIHsgY29tcHV0ZShub2RlLmV4cHJlc3Npb24pOyB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlUGFyYW1zKG5vZGUpIHtcbiAgICAgIHZhciBlbnYgPSBlbnZzW2VudnMubGVuZ3RoIC0gMV0sIHBhcmFtcyA9IHt9LCBuYW1lO1xuXG4gICAgICBmb3IgKG5hbWUgaW4gZW52KSB7XG4gICAgICAgIHBhcmFtc1tuYW1lXSA9IGVudltuYW1lXTtcbiAgICAgIH1cbiAgICAgIG5vZGUucGFyYW1zID0gcGFyYW1zO1xuICAgIH1cblxuICAgIHZhciBjb21wdXRlID0gYnVpbGROb2RlVmlzaXRvcih7XG4gICAgICBncmFtbWFyOlxuICAgICAgICBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgZWFjaChub2RlLnJ1bGVzLCBjb21wdXRlKTtcbiAgICAgICAgfSxcblxuICAgICAgcnVsZTogICAgICAgICBjb21wdXRlRm9yU2NvcGVkRXhwcmVzc2lvbixcblxuICAgICAgY2hvaWNlOlxuICAgICAgICBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgc2NvcGVkKGZ1bmN0aW9uKCkgeyBlYWNoKG5vZGUuYWx0ZXJuYXRpdmVzLCBjb21wdXRlKTsgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgIHNlcXVlbmNlOlxuICAgICAgICBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgdmFyIGVudiA9IGVudnNbZW52cy5sZW5ndGggLSAxXSwgbmFtZTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGZpeHVwKG5hbWUpIHtcbiAgICAgICAgICAgIGVhY2gocGx1Y2sobm9kZS5lbGVtZW50cywgXCJyZXN1bHRWYXJcIiksIGZ1bmN0aW9uKHJlc3VsdFZhciwgaSkge1xuICAgICAgICAgICAgICBpZiAoKG5ldyBSZWdFeHAoXCJeXCIgKyByZXN1bHRWYXIgKyBcIihcXFxcW1xcXFxkK1xcXFxdKSokXCIpKS50ZXN0KGVudltuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICBlbnZbbmFtZV0gPSBub2RlLnJlc3VsdFZhciArIFwiW1wiICsgaSArIFwiXVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgZW52W25hbWVdLnN1YnN0cihyZXN1bHRWYXIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWFjaChub2RlLmVsZW1lbnRzLCBjb21wdXRlKTtcblxuICAgICAgICAgIGZvciAobmFtZSBpbiBlbnYpIHtcbiAgICAgICAgICAgIGZpeHVwKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgbGFiZWxlZDpcbiAgICAgICAgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIGVudnNbZW52cy5sZW5ndGggLSAxXVtub2RlLmxhYmVsXSA9IG5vZGUucmVzdWx0VmFyO1xuXG4gICAgICAgICAgc2NvcGVkKGZ1bmN0aW9uKCkgeyBjb21wdXRlKG5vZGUuZXhwcmVzc2lvbik7IH0pO1xuICAgICAgICB9LFxuXG4gICAgICBzaW1wbGVfYW5kOiAgIGNvbXB1dGVGb3JTY29wZWRFeHByZXNzaW9uLFxuICAgICAgc2ltcGxlX25vdDogICBjb21wdXRlRm9yU2NvcGVkRXhwcmVzc2lvbixcbiAgICAgIHNlbWFudGljX2FuZDogY29tcHV0ZVBhcmFtcyxcbiAgICAgIHNlbWFudGljX25vdDogY29tcHV0ZVBhcmFtcyxcbiAgICAgIG9wdGlvbmFsOiAgICAgY29tcHV0ZUZvclNjb3BlZEV4cHJlc3Npb24sXG4gICAgICB6ZXJvX29yX21vcmU6IGNvbXB1dGVGb3JTY29wZWRFeHByZXNzaW9uLFxuICAgICAgb25lX29yX21vcmU6ICBjb21wdXRlRm9yU2NvcGVkRXhwcmVzc2lvbixcblxuICAgICAgYWN0aW9uOlxuICAgICAgICBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgc2NvcGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29tcHV0ZShub2RlLmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgY29tcHV0ZVBhcmFtcyhub2RlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgcnVsZV9yZWY6ICAgICBub3AsXG4gICAgICBsaXRlcmFsOiAgICAgIG5vcCxcbiAgICAgIGFueTogICAgICAgICAgbm9wLFxuICAgICAgXCJjbGFzc1wiOiAgICAgIG5vcFxuICAgIH0pO1xuXG4gICAgY29tcHV0ZShhc3QpO1xuICB9XG59O1xuLyogRW1pdHMgdGhlIGdlbmVyYXRlZCBjb2RlIGZvciB0aGUgQVNULiAqL1xuUEVHLmNvbXBpbGVyLmVtaXR0ZXIgPSBmdW5jdGlvbihhc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmIChvcHRpb25zLmNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmNhY2hlID0gZmFsc2U7XG4gIH1cbiAgaWYgKG9wdGlvbnMudHJhY2tMaW5lQW5kQ29sdW1uID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLnRyYWNrTGluZUFuZENvbHVtbiA9IGZhbHNlO1xuICB9XG5cbiAgLypcbiAgICogQ29kaWUgMS4xLjBcbiAgICpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2RtYWpkYS9jb2RpZVxuICAgKlxuICAgKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBEYXZpZCBNYWpkYVxuICAgKiBMaWNlbnNlbmQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICAgKi9cbiAgdmFyIENvZGllID0gKGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuXG4gIGZ1bmN0aW9uIHN0cmluZ0VzY2FwZShzKSB7XG4gICAgZnVuY3Rpb24gaGV4KGNoKSB7IHJldHVybiBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9XG5cbiAgICAvKlxuICAgICAqIEVDTUEtMjYyLCA1dGggZWQuLCA3LjguNDogQWxsIGNoYXJhY3RlcnMgbWF5IGFwcGVhciBsaXRlcmFsbHkgaW4gYVxuICAgICAqIHN0cmluZyBsaXRlcmFsIGV4Y2VwdCBmb3IgdGhlIGNsb3NpbmcgcXVvdGUgY2hhcmFjdGVyLCBiYWNrc2xhc2gsXG4gICAgICogY2FycmlhZ2UgcmV0dXJuLCBsaW5lIHNlcGFyYXRvciwgcGFyYWdyYXBoIHNlcGFyYXRvciwgYW5kIGxpbmUgZmVlZC5cbiAgICAgKiBBbnkgY2hhcmFjdGVyIG1heSBhcHBlYXIgaW4gdGhlIGZvcm0gb2YgYW4gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogRm9yIHBvcnRhYmlsaXR5LCB3ZSBhbHNvIGVzY2FwZSBlc2NhcGUgYWxsIGNvbnRyb2wgYW5kIG5vbi1BU0NJSVxuICAgICAqIGNoYXJhY3RlcnMuIE5vdGUgdGhhdCBcIlxcMFwiIGFuZCBcIlxcdlwiIGVzY2FwZSBzZXF1ZW5jZXMgYXJlIG5vdCB1c2VkXG4gICAgICogYmVjYXVzZSBKU0hpbnQgZG9lcyBub3QgbGlrZSB0aGUgZmlyc3QgYW5kIElFIHRoZSBzZWNvbmQuXG4gICAgICovXG4gICAgcmV0dXJuIHNcbiAgICAgIC5yZXBsYWNlKC9cXFxcL2csICAgJ1xcXFxcXFxcJykgLy8gYmFja3NsYXNoXG4gICAgICAucmVwbGFjZSgvXCIvZywgICAgJ1xcXFxcIicpICAvLyBjbG9zaW5nIGRvdWJsZSBxdW90ZVxuICAgICAgLnJlcGxhY2UoL1xceDA4L2csICdcXFxcYicpICAvLyBiYWNrc3BhY2VcbiAgICAgIC5yZXBsYWNlKC9cXHQvZywgICAnXFxcXHQnKSAgLy8gaG9yaXpvbnRhbCB0YWJcbiAgICAgIC5yZXBsYWNlKC9cXG4vZywgICAnXFxcXG4nKSAgLy8gbGluZSBmZWVkXG4gICAgICAucmVwbGFjZSgvXFxmL2csICAgJ1xcXFxmJykgIC8vIGZvcm0gZmVlZFxuICAgICAgLnJlcGxhY2UoL1xcci9nLCAgICdcXFxccicpICAvLyBjYXJyaWFnZSByZXR1cm5cbiAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MDdcXHgwQlxceDBFXFx4MEZdL2csIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgwJyArIGhleChjaCk7IH0pXG4gICAgICAucmVwbGFjZSgvW1xceDEwLVxceDFGXFx4ODAtXFx4RkZdL2csICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgnICArIGhleChjaCk7IH0pXG4gICAgICAucmVwbGFjZSgvW1xcdTAxODAtXFx1MEZGRl0vZywgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx1MCcgKyBoZXgoY2gpOyB9KVxuICAgICAgLnJlcGxhY2UoL1tcXHUxMDgwLVxcdUZGRkZdL2csICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxcdScgICsgaGV4KGNoKTsgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoKHMpIHsgcmV0dXJuICdfX3AucHVzaCgnICsgcyArICcpOyc7IH1cblxuICBmdW5jdGlvbiBwdXNoUmF3KHRlbXBsYXRlLCBsZW5ndGgsIHN0YXRlKSB7XG4gICAgZnVuY3Rpb24gdW5pbmRlbnQoY29kZSwgbGV2ZWwsIHVuaW5kZW50Rmlyc3QpIHtcbiAgICAgIHJldHVybiBjb2RlLnJlcGxhY2UoXG4gICAgICAgIG5ldyBSZWdFeHAoJ14ueycgKyBsZXZlbCArJ30nLCBcImdtXCIpLFxuICAgICAgICBmdW5jdGlvbihzdHIsIG9mZnNldCkge1xuICAgICAgICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmluZGVudEZpcnN0ID8gJycgOiBzdHI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgZXNjYXBlZCA9IHN0cmluZ0VzY2FwZSh1bmluZGVudChcbiAgICAgICAgICB0ZW1wbGF0ZS5zdWJzdHJpbmcoMCwgbGVuZ3RoKSxcbiAgICAgICAgICBzdGF0ZS5pbmRlbnRMZXZlbCgpLFxuICAgICAgICAgIHN0YXRlLmF0Qk9MXG4gICAgICAgICkpO1xuXG4gICAgcmV0dXJuIGVzY2FwZWQubGVuZ3RoID4gMCA/IHB1c2goJ1wiJyArIGVzY2FwZWQgKyAnXCInKSA6ICcnO1xuICB9XG5cblxuICB2YXIgQ29kaWUgPSB7XG4gICAgLyogQ29kaWUgdmVyc2lvbiAodXNlcyBzZW1hbnRpYyB2ZXJzaW9uaW5nKS4gKi9cbiAgICBWRVJTSU9OOiBcIjEuMS4wXCIsXG5cbiAgICAvKlxuICAgICAqIFNwZWNpZmllcyBieSBob3cgbWFueSBjaGFyYWN0ZXJzIGRvICNpZi8jZWxzZSBhbmQgI2ZvciB1bmluZGVudCB0aGVpclxuICAgICAqIGNvbnRlbnQgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLlxuICAgICAqL1xuICAgIGluZGVudFN0ZXA6IDIsXG5cbiAgICAvKiBEZXNjcmlwdGlvbiBvZiAjLWNvbW1hbmRzLiBFeHRlbmQgdG8gZGVmaW5lIHlvdXIgb3duIGNvbW1hbmRzLiAqL1xuICAgIGNvbW1hbmRzOiB7XG4gICAgICBcImlmXCI6ICAge1xuICAgICAgICBwYXJhbXM6ICAvXiguKikkLyxcbiAgICAgICAgY29tcGlsZTogZnVuY3Rpb24oc3RhdGUsIHByZWZpeCwgcGFyYW1zKSB7XG4gICAgICAgICAgcmV0dXJuIFsnaWYoJyArIHBhcmFtc1swXSArICcpeycsIFtdXTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RhY2tPcDogXCJwdXNoXCJcbiAgICAgIH0sXG4gICAgICBcImVsc2VcIjoge1xuICAgICAgICBwYXJhbXM6ICAvXiQvLFxuICAgICAgICBjb21waWxlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgIHZhciBzdGFjayA9IHN0YXRlLmNvbW1hbmRTdGFjayxcbiAgICAgICAgICAgICAgaW5zaWRlRWxzZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcImVsc2VcIixcbiAgICAgICAgICAgICAgaW5zaWRlSWYgICA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcImlmXCI7XG5cbiAgICAgICAgICBpZiAoaW5zaWRlRWxzZSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aXBsZSAjZWxzZXMuXCIpOyB9XG4gICAgICAgICAgaWYgKCFpbnNpZGVJZikgIHsgdGhyb3cgbmV3IEVycm9yKFwiVXNpbmcgI2Vsc2Ugb3V0c2lkZSBvZiAjaWYuXCIpOyB9XG5cbiAgICAgICAgICByZXR1cm4gWyd9ZWxzZXsnLCBbXV07XG4gICAgICAgIH0sXG4gICAgICAgIHN0YWNrT3A6IFwicmVwbGFjZVwiXG4gICAgICB9LFxuICAgICAgXCJmb3JcIjogIHtcbiAgICAgICAgcGFyYW1zOiAgL14oW2EtekEtWl9dW2EtekEtWjAtOV9dKilbIFxcdF0raW5bIFxcdF0rKC4qKSQvLFxuICAgICAgICBpbml0OiAgICBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgIHN0YXRlLmZvckN1cnJMZXZlbCA9IDA7ICAvLyBjdXJyZW50IGxldmVsIG9mICNmb3IgbG9vcCBuZXN0aW5nXG4gICAgICAgICAgc3RhdGUuZm9yTWF4TGV2ZWwgID0gMDsgIC8vIG1heGltdW0gbGV2ZWwgb2YgI2ZvciBsb29wIG5lc3RpbmdcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGlsZTogZnVuY3Rpb24oc3RhdGUsIHByZWZpeCwgcGFyYW1zKSB7XG4gICAgICAgICAgdmFyIGMgPSAnX19jJyArIHN0YXRlLmZvckN1cnJMZXZlbCwgLy8gX19jIGZvciBcImNvbGxlY3Rpb25cIlxuICAgICAgICAgICAgICBsID0gJ19fbCcgKyBzdGF0ZS5mb3JDdXJyTGV2ZWwsIC8vIF9fbCBmb3IgXCJsZW5ndGhcIlxuICAgICAgICAgICAgICBpID0gJ19faScgKyBzdGF0ZS5mb3JDdXJyTGV2ZWw7IC8vIF9faSBmb3IgXCJpbmRleFwiXG5cbiAgICAgICAgICBzdGF0ZS5mb3JDdXJyTGV2ZWwrKztcbiAgICAgICAgICBpZiAoc3RhdGUuZm9yTWF4TGV2ZWwgPCBzdGF0ZS5mb3JDdXJyTGV2ZWwpIHtcbiAgICAgICAgICAgIHN0YXRlLmZvck1heExldmVsID0gc3RhdGUuZm9yQ3VyckxldmVsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjICsgJz0nICsgcGFyYW1zWzFdICsgJzsnXG4gICAgICAgICAgICAgICsgbCArICc9JyArIGMgKyAnLmxlbmd0aDsnXG4gICAgICAgICAgICAgICsgJ2ZvcignICsgaSArICc9MDsnICsgaSArICc8JyArIGwgKyAnOycgKyBpICsgJysrKXsnXG4gICAgICAgICAgICAgICsgcGFyYW1zWzBdICsgJz0nICsgYyArICdbJyArIGkgKyAnXTsnLFxuICAgICAgICAgICAgW3BhcmFtc1swXSwgYywgbCwgaV1cbiAgICAgICAgICBdO1xuICAgICAgICB9LFxuICAgICAgICBleGl0OiAgICBmdW5jdGlvbihzdGF0ZSkgeyBzdGF0ZS5mb3JDdXJyTGV2ZWwtLTsgfSxcbiAgICAgICAgc3RhY2tPcDogXCJwdXNoXCJcbiAgICAgIH0sXG4gICAgICBcImVuZFwiOiAge1xuICAgICAgICBwYXJhbXM6ICAvXiQvLFxuICAgICAgICBjb21waWxlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgIHZhciBzdGFjayA9IHN0YXRlLmNvbW1hbmRTdGFjaywgZXhpdDtcblxuICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiVG9vIG1hbnkgI2VuZHMuXCIpOyB9XG5cbiAgICAgICAgICBleGl0ID0gQ29kaWUuY29tbWFuZHNbc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1dLmV4aXQ7XG4gICAgICAgICAgaWYgKGV4aXQpIHsgZXhpdChzdGF0ZSk7IH1cblxuICAgICAgICAgIHJldHVybiBbJ30nLCBbXV07XG4gICAgICAgIH0sXG4gICAgICAgIHN0YWNrT3A6IFwicG9wXCJcbiAgICAgIH0sXG4gICAgICBcImJsb2NrXCI6IHtcbiAgICAgICAgcGFyYW1zOiAvXiguKikkLyxcbiAgICAgICAgY29tcGlsZTogZnVuY3Rpb24oc3RhdGUsIHByZWZpeCwgcGFyYW1zKSB7XG4gICAgICAgICAgdmFyIHggPSAnX194JywgLy8gX194IGZvciBcInByZWZpeFwiLFxuICAgICAgICAgICAgICBuID0gJ19fbicsIC8vIF9fbiBmb3IgXCJsaW5lc1wiXG4gICAgICAgICAgICAgIGwgPSAnX19sJywgLy8gX19sIGZvciBcImxlbmd0aFwiXG4gICAgICAgICAgICAgIGkgPSAnX19pJzsgLy8gX19pIGZvciBcImluZGV4XCJcblxuICAgICAgICAgIC8qXG4gICAgICAgICAgICogT3JpZ2luYWxseSwgdGhlIGdlbmVyYXRlZCBjb2RlIHVzZWQgfFN0cmluZy5wcm90b3R5cGUucmVwbGFjZXwsIGJ1dFxuICAgICAgICAgICAqIGl0IGlzIGJ1Z2d5IGluIGNlcnRhaW4gdmVyc2lvbnMgb2YgVjggc28gaXQgd2FzIHJld3JpdHRlbi4gU2VlIHRoZVxuICAgICAgICAgICAqIHRlc3RzIGZvciBkZXRhaWxzLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB4ICsgJz1cIicgKyBzdHJpbmdFc2NhcGUocHJlZml4LnN1YnN0cmluZyhzdGF0ZS5pbmRlbnRMZXZlbCgpKSkgKyAnXCI7J1xuICAgICAgICAgICAgICArIG4gKyAnPSgnICsgcGFyYW1zWzBdICsgJykudG9TdHJpbmcoKS5zcGxpdChcIlxcXFxuXCIpOydcbiAgICAgICAgICAgICAgKyBsICsgJz0nICsgbiArICcubGVuZ3RoOydcbiAgICAgICAgICAgICAgKyAnZm9yKCcgKyBpICsgJz0wOycgKyBpICsgJzwnICsgbCArICc7JyArIGkgKyAnKyspeydcbiAgICAgICAgICAgICAgKyBuICsgJ1snICsgaSArJ109JyArIHggKyAnKycgKyBuICsgJ1snICsgaSArICddK1wiXFxcXG5cIjsnXG4gICAgICAgICAgICAgICsgJ30nXG4gICAgICAgICAgICAgICsgcHVzaChuICsgJy5qb2luKFwiXCIpJyksXG4gICAgICAgICAgICBbeCwgbiwgbCwgaV1cbiAgICAgICAgICBdO1xuICAgICAgICB9LFxuICAgICAgICBzdGFja09wOiBcIm5vcFwiXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogQ29tcGlsZXMgYSB0ZW1wbGF0ZSBpbnRvIGEgZnVuY3Rpb24uIFdoZW4gY2FsbGVkLCB0aGlzIGZ1bmN0aW9uIHdpbGxcbiAgICAgKiBleGVjdXRlIHRoZSB0ZW1wbGF0ZSBpbiB0aGUgY29udGV4dCBvZiBhbiBvYmplY3QgcGFzc2VkIGluIGEgcGFyYW1ldGVyIGFuZFxuICAgICAqIHJldHVybiB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIHRlbXBsYXRlOiBmdW5jdGlvbih0ZW1wbGF0ZSkge1xuICAgICAgdmFyIHN0YWNrT3BzID0ge1xuICAgICAgICBwdXNoOiAgICBmdW5jdGlvbihzdGFjaywgbmFtZSkgeyBzdGFjay5wdXNoKG5hbWUpOyB9LFxuICAgICAgICByZXBsYWNlOiBmdW5jdGlvbihzdGFjaywgbmFtZSkgeyBzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9IG5hbWU7IH0sXG4gICAgICAgIHBvcDogICAgIGZ1bmN0aW9uKHN0YWNrKSAgICAgICB7IHN0YWNrLnBvcCgpOyB9LFxuICAgICAgICBub3A6ICAgICBmdW5jdGlvbigpICAgICAgICAgICAgeyB9XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBjb21waWxlRXhwcihzdGF0ZSwgZXhwcikge1xuICAgICAgICBzdGF0ZS5hdEJPTCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gW3B1c2goZXhwciksIFtdXTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY29tcGlsZUNvbW1hbmQoc3RhdGUsIHByZWZpeCwgbmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBjb21tYW5kLCBtYXRjaCwgcmVzdWx0O1xuXG4gICAgICAgIGNvbW1hbmQgPSBDb2RpZS5jb21tYW5kc1tuYW1lXTtcbiAgICAgICAgaWYgKCFjb21tYW5kKSB7IHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29tbWFuZDogI1wiICsgbmFtZSArIFwiLlwiKTsgfVxuXG4gICAgICAgIG1hdGNoID0gY29tbWFuZC5wYXJhbXMuZXhlYyhwYXJhbXMpO1xuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgcGFyYW1zIGZvciBjb21tYW5kICNcIiArIG5hbWUgKyBcIjogXCIgKyBwYXJhbXMgKyBcIi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBjb21tYW5kLmNvbXBpbGUoc3RhdGUsIHByZWZpeCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICBzdGFja09wc1tjb21tYW5kLnN0YWNrT3BdKHN0YXRlLmNvbW1hbmRTdGFjaywgbmFtZSk7XG4gICAgICAgIHN0YXRlLmF0Qk9MID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRlID0geyAgICAgICAgICAgICAgIC8vIGNvbXBpbGF0aW9uIHN0YXRlXG4gICAgICAgICAgICBjb21tYW5kU3RhY2s6IFtdLCAgICAgLy8gICBzdGFjayBvZiBjb21tYW5kcyBhcyB0aGV5IHdlcmUgbmVzdGVkXG4gICAgICAgICAgICBhdEJPTDogICAgICAgIHRydWUsICAgLy8gICBpcyB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gcHJvY2VzcyBhdCBCT0w/XG4gICAgICAgICAgICBpbmRlbnRMZXZlbDogIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gQ29kaWUuaW5kZW50U3RlcCAqIHRoaXMuY29tbWFuZFN0YWNrLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvZGUgPSAnJywgICAgICAgICAgICAgIC8vIGdlbmVyYXRlZCB0ZW1wbGF0ZSBmdW5jdGlvbiBjb2RlXG4gICAgICAgICAgdmFycyA9IFsnX19wPVtdJ10sICAgICAgLy8gdmFyaWFibGVzIHVzZWQgYnkgZ2VuZXJhdGVkIGNvZGVcbiAgICAgICAgICBuYW1lLCBtYXRjaCwgcmVzdWx0LCBpO1xuXG4gICAgICAvKiBJbml0aWFsaXplIHN0YXRlLiAqL1xuICAgICAgZm9yIChuYW1lIGluIENvZGllLmNvbW1hbmRzKSB7XG4gICAgICAgIGlmIChDb2RpZS5jb21tYW5kc1tuYW1lXS5pbml0KSB7IENvZGllLmNvbW1hbmRzW25hbWVdLmluaXQoc3RhdGUpOyB9XG4gICAgICB9XG5cbiAgICAgIC8qIENvbXBpbGUgdGhlIHRlbXBsYXRlLiAqL1xuICAgICAgd2hpbGUgKChtYXRjaCA9IC9eKFsgXFx0XSopIyhbYS16QS1aX11bYS16QS1aMC05X10qKSg/OlsgXFx0XSsoW14gXFx0XFxuXVteXFxuXSopKT9bIFxcdF0qKD86XFxufCQpfCNcXHsoW159XSopXFx9L20uZXhlYyh0ZW1wbGF0ZSkpICE9PSBudWxsKSB7XG4gICAgICAgIGNvZGUgKz0gcHVzaFJhdyh0ZW1wbGF0ZSwgbWF0Y2guaW5kZXgsIHN0YXRlKTtcbiAgICAgICAgcmVzdWx0ID0gbWF0Y2hbMl0gIT09IHVuZGVmaW5lZCAmJiBtYXRjaFsyXSAhPT0gXCJcIlxuICAgICAgICAgID8gY29tcGlsZUNvbW1hbmQoc3RhdGUsIG1hdGNoWzFdLCBtYXRjaFsyXSwgbWF0Y2hbM10gfHwgXCJcIikgLy8gIy1jb21tYW5kXG4gICAgICAgICAgOiBjb21waWxlRXhwcihzdGF0ZSwgbWF0Y2hbNF0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gI3suLi59XG4gICAgICAgIGNvZGUgKz0gcmVzdWx0WzBdO1xuICAgICAgICB2YXJzID0gdmFycy5jb25jYXQocmVzdWx0WzFdKTtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5zdWJzdHJpbmcobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgY29kZSArPSBwdXNoUmF3KHRlbXBsYXRlLCB0ZW1wbGF0ZS5sZW5ndGgsIHN0YXRlKTtcblxuICAgICAgLyogQ2hlY2sgdGhlIGZpbmFsIHN0YXRlLiAqL1xuICAgICAgaWYgKHN0YXRlLmNvbW1hbmRTdGFjay5sZW5ndGggPiAwKSB7IHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgI2VuZC5cIik7IH1cblxuICAgICAgLyogU2FuaXRpemUgdGhlIGxpc3Qgb2YgdmFyaWFibGVzIHVzZWQgYnkgY29tbWFuZHMuICovXG4gICAgICB2YXJzLnNvcnQoKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh2YXJzW2ldID09PSB2YXJzW2kgLSAxXSkgeyB2YXJzLnNwbGljZShpLS0sIDEpOyB9XG4gICAgICB9XG5cbiAgICAgIC8qIENyZWF0ZSB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9uLiAqL1xuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcIl9fdlwiLCBbXG4gICAgICAgICdfX3Y9X192fHx7fTsnLFxuICAgICAgICAndmFyICcgKyB2YXJzLmpvaW4oJywnKSArICc7JyxcbiAgICAgICAgJ3dpdGgoX192KXsnLFxuICAgICAgICBjb2RlLFxuICAgICAgICAncmV0dXJuIF9fcC5qb2luKFwiXCIpLnJlcGxhY2UoL15cXFxcbit8XFxcXG4rJC9nLFwiXCIpO307J1xuICAgICAgXS5qb2luKCcnKSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDb2RpZTtcblxuICB9KSgpO1xuXG4gIHZhciB0ZW1wbGF0ZXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5hbWUsXG4gICAgICAgIHRlbXBsYXRlcyA9IHt9LFxuICAgICAgICBzb3VyY2VzID0ge1xuICAgICAgICAgIGdyYW1tYXI6IFtcbiAgICAgICAgICAgICcoZnVuY3Rpb24oKXsnLFxuICAgICAgICAgICAgJyAgLyonLFxuICAgICAgICAgICAgJyAgICogR2VuZXJhdGVkIGJ5IFBFRy5qcyAwLjcuMC4nLFxuICAgICAgICAgICAgJyAgIConLFxuICAgICAgICAgICAgJyAgICogaHR0cDovL3BlZ2pzLm1hamRhLmN6LycsXG4gICAgICAgICAgICAnICAgKi8nLFxuICAgICAgICAgICAgJyAgJyxcbiAgICAgICAgICAgIC8qIFRoaXMgbmVlZHMgdG8gYmUgaW4gc3luYyB3aXRoIHxxdW90ZXwgaW4gdXRpbHMuanMuICovXG4gICAgICAgICAgICAnICBmdW5jdGlvbiBxdW90ZShzKSB7JyxcbiAgICAgICAgICAgICcgICAgLyonLFxuICAgICAgICAgICAgJyAgICAgKiBFQ01BLTI2MiwgNXRoIGVkLiwgNy44LjQ6IEFsbCBjaGFyYWN0ZXJzIG1heSBhcHBlYXIgbGl0ZXJhbGx5IGluIGEnLFxuICAgICAgICAgICAgJyAgICAgKiBzdHJpbmcgbGl0ZXJhbCBleGNlcHQgZm9yIHRoZSBjbG9zaW5nIHF1b3RlIGNoYXJhY3RlciwgYmFja3NsYXNoLCcsXG4gICAgICAgICAgICAnICAgICAqIGNhcnJpYWdlIHJldHVybiwgbGluZSBzZXBhcmF0b3IsIHBhcmFncmFwaCBzZXBhcmF0b3IsIGFuZCBsaW5lIGZlZWQuJyxcbiAgICAgICAgICAgICcgICAgICogQW55IGNoYXJhY3RlciBtYXkgYXBwZWFyIGluIHRoZSBmb3JtIG9mIGFuIGVzY2FwZSBzZXF1ZW5jZS4nLFxuICAgICAgICAgICAgJyAgICAgKicsXG4gICAgICAgICAgICAnICAgICAqIEZvciBwb3J0YWJpbGl0eSwgd2UgYWxzbyBlc2NhcGUgZXNjYXBlIGFsbCBjb250cm9sIGFuZCBub24tQVNDSUknLFxuICAgICAgICAgICAgJyAgICAgKiBjaGFyYWN0ZXJzLiBOb3RlIHRoYXQgXCJcXFxcMFwiIGFuZCBcIlxcXFx2XCIgZXNjYXBlIHNlcXVlbmNlcyBhcmUgbm90IHVzZWQnLFxuICAgICAgICAgICAgJyAgICAgKiBiZWNhdXNlIEpTSGludCBkb2VzIG5vdCBsaWtlIHRoZSBmaXJzdCBhbmQgSUUgdGhlIHNlY29uZC4nLFxuICAgICAgICAgICAgJyAgICAgKi8nLFxuICAgICAgICAgICAgJyAgICAgcmV0dXJuIFxcJ1wiXFwnICsgcycsXG4gICAgICAgICAgICAnICAgICAgLnJlcGxhY2UoL1xcXFxcXFxcL2csIFxcJ1xcXFxcXFxcXFxcXFxcXFxcXCcpICAvLyBiYWNrc2xhc2gnLFxuICAgICAgICAgICAgJyAgICAgIC5yZXBsYWNlKC9cIi9nLCBcXCdcXFxcXFxcXFwiXFwnKSAgICAvLyBjbG9zaW5nIHF1b3RlIGNoYXJhY3RlcicsXG4gICAgICAgICAgICAnICAgICAgLnJlcGxhY2UoL1xcXFx4MDgvZywgXFwnXFxcXFxcXFxiXFwnKSAvLyBiYWNrc3BhY2UnLFxuICAgICAgICAgICAgJyAgICAgIC5yZXBsYWNlKC9cXFxcdC9nLCBcXCdcXFxcXFxcXHRcXCcpICAgLy8gaG9yaXpvbnRhbCB0YWInLFxuICAgICAgICAgICAgJyAgICAgIC5yZXBsYWNlKC9cXFxcbi9nLCBcXCdcXFxcXFxcXG5cXCcpICAgLy8gbGluZSBmZWVkJyxcbiAgICAgICAgICAgICcgICAgICAucmVwbGFjZSgvXFxcXGYvZywgXFwnXFxcXFxcXFxmXFwnKSAgIC8vIGZvcm0gZmVlZCcsXG4gICAgICAgICAgICAnICAgICAgLnJlcGxhY2UoL1xcXFxyL2csIFxcJ1xcXFxcXFxcclxcJykgICAvLyBjYXJyaWFnZSByZXR1cm4nLFxuICAgICAgICAgICAgJyAgICAgIC5yZXBsYWNlKC9bXFxcXHgwMC1cXFxceDA3XFxcXHgwQlxcXFx4MEUtXFxcXHgxRlxcXFx4ODAtXFxcXHVGRkZGXS9nLCBlc2NhcGUpJyxcbiAgICAgICAgICAgICcgICAgICArIFxcJ1wiXFwnOycsXG4gICAgICAgICAgICAnICB9JyxcbiAgICAgICAgICAgICcgICcsXG4gICAgICAgICAgICAnICB2YXIgcmVzdWx0ID0geycsXG4gICAgICAgICAgICAnICAgIC8qJyxcbiAgICAgICAgICAgICcgICAgICogUGFyc2VzIHRoZSBpbnB1dCB3aXRoIGEgZ2VuZXJhdGVkIHBhcnNlci4gSWYgdGhlIHBhcnNpbmcgaXMgc3VjY2Vzc2Z1bGwsJyxcbiAgICAgICAgICAgICcgICAgICogcmV0dXJucyBhIHZhbHVlIGV4cGxpY2l0bHkgb3IgaW1wbGljaXRseSBzcGVjaWZpZWQgYnkgdGhlIGdyYW1tYXIgZnJvbScsXG4gICAgICAgICAgICAnICAgICAqIHdoaWNoIHRoZSBwYXJzZXIgd2FzIGdlbmVyYXRlZCAoc2VlIHxQRUcuYnVpbGRQYXJzZXJ8KS4gSWYgdGhlIHBhcnNpbmcgaXMnLFxuICAgICAgICAgICAgJyAgICAgKiB1bnN1Y2Nlc3NmdWwsIHRocm93cyB8UEVHLnBhcnNlci5TeW50YXhFcnJvcnwgZGVzY3JpYmluZyB0aGUgZXJyb3IuJyxcbiAgICAgICAgICAgICcgICAgICovJyxcbiAgICAgICAgICAgICcgICAgcGFyc2U6IGZ1bmN0aW9uKGlucHV0LCBzdGFydFJ1bGUpIHsnLFxuICAgICAgICAgICAgJyAgICAgIHZhciBwYXJzZUZ1bmN0aW9ucyA9IHsnLFxuICAgICAgICAgICAgJyAgICAgICAgI2ZvciBydWxlIGluIG5vZGUucnVsZXMnLFxuICAgICAgICAgICAgJyAgICAgICAgICAje3N0cmluZyhydWxlLm5hbWUpICsgXCI6IHBhcnNlX1wiICsgcnVsZS5uYW1lICsgKHJ1bGUgIT09IG5vZGUucnVsZXNbbm9kZS5ydWxlcy5sZW5ndGggLSAxXSA/IFwiLFwiIDogXCJcIil9JyxcbiAgICAgICAgICAgICcgICAgICAgICNlbmQnLFxuICAgICAgICAgICAgJyAgICAgIH07JyxcbiAgICAgICAgICAgICcgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgIGlmIChzdGFydFJ1bGUgIT09IHVuZGVmaW5lZCkgeycsXG4gICAgICAgICAgICAnICAgICAgICBpZiAocGFyc2VGdW5jdGlvbnNbc3RhcnRSdWxlXSA9PT0gdW5kZWZpbmVkKSB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBydWxlIG5hbWU6IFwiICsgcXVvdGUoc3RhcnRSdWxlKSArIFwiLlwiKTsnLFxuICAgICAgICAgICAgJyAgICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgfSBlbHNlIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgc3RhcnRSdWxlID0gI3tzdHJpbmcobm9kZS5zdGFydFJ1bGUpfTsnLFxuICAgICAgICAgICAgJyAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgI3twb3NJbml0KFwicG9zXCIpfTsnLFxuICAgICAgICAgICAgJyAgICAgIHZhciByZXBvcnRGYWlsdXJlcyA9IDA7JywgLy8gMCA9IHJlcG9ydCwgYW55dGhpbmcgPiAwID0gZG8gbm90IHJlcG9ydFxuICAgICAgICAgICAgJyAgICAgICN7cG9zSW5pdChcInJpZ2h0bW9zdEZhaWx1cmVzUG9zXCIpfTsnLFxuICAgICAgICAgICAgJyAgICAgIHZhciByaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkID0gW107JyxcbiAgICAgICAgICAgICcgICAgICAjaWYgb3B0aW9ucy5jYWNoZScsXG4gICAgICAgICAgICAnICAgICAgICB2YXIgY2FjaGUgPSB7fTsnLFxuICAgICAgICAgICAgJyAgICAgICNlbmQnLFxuICAgICAgICAgICAgJyAgICAgICcsXG4gICAgICAgICAgICAvKiBUaGlzIG5lZWRzIHRvIGJlIGluIHN5bmMgd2l0aCB8cGFkTGVmdHwgaW4gdXRpbHMuanMuICovXG4gICAgICAgICAgICAnICAgICAgZnVuY3Rpb24gcGFkTGVmdChpbnB1dCwgcGFkZGluZywgbGVuZ3RoKSB7JyxcbiAgICAgICAgICAgICcgICAgICAgIHZhciByZXN1bHQgPSBpbnB1dDsnLFxuICAgICAgICAgICAgJyAgICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAgIHZhciBwYWRMZW5ndGggPSBsZW5ndGggLSBpbnB1dC5sZW5ndGg7JyxcbiAgICAgICAgICAgICcgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFkTGVuZ3RoOyBpKyspIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgICByZXN1bHQgPSBwYWRkaW5nICsgcmVzdWx0OycsXG4gICAgICAgICAgICAnICAgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgICByZXR1cm4gcmVzdWx0OycsXG4gICAgICAgICAgICAnICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgJyxcbiAgICAgICAgICAgIC8qIFRoaXMgbmVlZHMgdG8gYmUgaW4gc3luYyB3aXRoIHxlc2NhcGV8IGluIHV0aWxzLmpzLiAqL1xuICAgICAgICAgICAgJyAgICAgIGZ1bmN0aW9uIGVzY2FwZShjaCkgeycsXG4gICAgICAgICAgICAnICAgICAgICB2YXIgY2hhckNvZGUgPSBjaC5jaGFyQ29kZUF0KDApOycsXG4gICAgICAgICAgICAnICAgICAgICB2YXIgZXNjYXBlQ2hhcjsnLFxuICAgICAgICAgICAgJyAgICAgICAgdmFyIGxlbmd0aDsnLFxuICAgICAgICAgICAgJyAgICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAgIGlmIChjaGFyQ29kZSA8PSAweEZGKSB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgZXNjYXBlQ2hhciA9IFxcJ3hcXCc7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgbGVuZ3RoID0gMjsnLFxuICAgICAgICAgICAgJyAgICAgICAgfSBlbHNlIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgICBlc2NhcGVDaGFyID0gXFwndVxcJzsnLFxuICAgICAgICAgICAgJyAgICAgICAgICBsZW5ndGggPSA0OycsXG4gICAgICAgICAgICAnICAgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgICByZXR1cm4gXFwnXFxcXFxcXFxcXCcgKyBlc2NhcGVDaGFyICsgcGFkTGVmdChjaGFyQ29kZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSwgXFwnMFxcJywgbGVuZ3RoKTsnLFxuICAgICAgICAgICAgJyAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgI2lmIG9wdGlvbnMudHJhY2tMaW5lQW5kQ29sdW1uJyxcbiAgICAgICAgICAgICcgICAgICAgIGZ1bmN0aW9uIGNsb25lKG9iamVjdCkgeycsXG4gICAgICAgICAgICAnICAgICAgICAgIHZhciByZXN1bHQgPSB7fTsnLFxuICAgICAgICAgICAgJyAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldOycsXG4gICAgICAgICAgICAnICAgICAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgICAgICByZXR1cm4gcmVzdWx0OycsXG4gICAgICAgICAgICAnICAgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgICBmdW5jdGlvbiBhZHZhbmNlKHBvcywgbikgeycsXG4gICAgICAgICAgICAnICAgICAgICAgIHZhciBlbmRPZmZzZXQgPSBwb3Mub2Zmc2V0ICsgbjsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSBwb3Mub2Zmc2V0OyBvZmZzZXQgPCBlbmRPZmZzZXQ7IG9mZnNldCsrKSB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICB2YXIgY2ggPSBpbnB1dC5jaGFyQXQob2Zmc2V0KTsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgIGlmIChjaCA9PT0gXCJcXFxcblwiKSB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICAgIGlmICghcG9zLnNlZW5DUikgeyBwb3MubGluZSsrOyB9JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICAgIHBvcy5jb2x1bW4gPSAxOycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgICBwb3Muc2VlbkNSID0gZmFsc2U7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIlxcXFxyXCIgfHwgY2ggPT09IFwiXFxcXHUyMDI4XCIgfHwgY2ggPT09IFwiXFxcXHUyMDI5XCIpIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgICAgcG9zLmxpbmUrKzsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgICAgcG9zLmNvbHVtbiA9IDE7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICAgIHBvcy5zZWVuQ1IgPSB0cnVlOycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgfSBlbHNlIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgICAgcG9zLmNvbHVtbisrOycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgICBwb3Muc2VlbkNSID0gZmFsc2U7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgICAgIHBvcy5vZmZzZXQgKz0gbjsnLFxuICAgICAgICAgICAgJyAgICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgICNlbmQnLFxuICAgICAgICAgICAgJyAgICAgIGZ1bmN0aW9uIG1hdGNoRmFpbGVkKGZhaWx1cmUpIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgaWYgKCN7cG9zT2Zmc2V0KFwicG9zXCIpfSA8ICN7cG9zT2Zmc2V0KFwicmlnaHRtb3N0RmFpbHVyZXNQb3NcIil9KSB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgcmV0dXJuOycsXG4gICAgICAgICAgICAnICAgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgICBpZiAoI3twb3NPZmZzZXQoXCJwb3NcIil9ID4gI3twb3NPZmZzZXQoXCJyaWdodG1vc3RGYWlsdXJlc1Bvc1wiKX0pIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgICByaWdodG1vc3RGYWlsdXJlc1BvcyA9ICN7cG9zQ2xvbmUoXCJwb3NcIil9OycsXG4gICAgICAgICAgICAnICAgICAgICAgIHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWQgPSBbXTsnLFxuICAgICAgICAgICAgJyAgICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgICAgcmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZC5wdXNoKGZhaWx1cmUpOycsXG4gICAgICAgICAgICAnICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAjZm9yIHJ1bGUgaW4gbm9kZS5ydWxlcycsXG4gICAgICAgICAgICAnICAgICAgICAjYmxvY2sgZW1pdChydWxlKScsXG4gICAgICAgICAgICAnICAgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgICNlbmQnLFxuICAgICAgICAgICAgJyAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgZnVuY3Rpb24gY2xlYW51cEV4cGVjdGVkKGV4cGVjdGVkKSB7JyxcbiAgICAgICAgICAgICcgICAgICAgIGV4cGVjdGVkLnNvcnQoKTsnLFxuICAgICAgICAgICAgJyAgICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAgIHZhciBsYXN0RXhwZWN0ZWQgPSBudWxsOycsXG4gICAgICAgICAgICAnICAgICAgICB2YXIgY2xlYW5FeHBlY3RlZCA9IFtdOycsXG4gICAgICAgICAgICAnICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgaWYgKGV4cGVjdGVkW2ldICE9PSBsYXN0RXhwZWN0ZWQpIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgIGNsZWFuRXhwZWN0ZWQucHVzaChleHBlY3RlZFtpXSk7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICBsYXN0RXhwZWN0ZWQgPSBleHBlY3RlZFtpXTsnLFxuICAgICAgICAgICAgJyAgICAgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgICAgcmV0dXJuIGNsZWFuRXhwZWN0ZWQ7JyxcbiAgICAgICAgICAgICcgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgICNpZiAhb3B0aW9ucy50cmFja0xpbmVBbmRDb2x1bW4nLFxuICAgICAgICAgICAgJyAgICAgICAgZnVuY3Rpb24gY29tcHV0ZUVycm9yUG9zaXRpb24oKSB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgLyonLFxuICAgICAgICAgICAgJyAgICAgICAgICAgKiBUaGUgZmlyc3QgaWRlYSB3YXMgdG8gdXNlIHxTdHJpbmcuc3BsaXR8IHRvIGJyZWFrIHRoZSBpbnB1dCB1cCB0byB0aGUnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgKiBlcnJvciBwb3NpdGlvbiBhbG9uZyBuZXdsaW5lcyBhbmQgZGVyaXZlIHRoZSBsaW5lIGFuZCBjb2x1bW4gZnJvbScsXG4gICAgICAgICAgICAnICAgICAgICAgICAqIHRoZXJlLiBIb3dldmVyIElFXFwncyB8c3BsaXR8IGltcGxlbWVudGF0aW9uIGlzIHNvIGJyb2tlbiB0aGF0IGl0IHdhcycsXG4gICAgICAgICAgICAnICAgICAgICAgICAqIGVub3VnaCB0byBwcmV2ZW50IGl0LicsXG4gICAgICAgICAgICAnICAgICAgICAgICAqLycsXG4gICAgICAgICAgICAnICAgICAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgICAgIHZhciBsaW5lID0gMTsnLFxuICAgICAgICAgICAgJyAgICAgICAgICB2YXIgY29sdW1uID0gMTsnLFxuICAgICAgICAgICAgJyAgICAgICAgICB2YXIgc2VlbkNSID0gZmFsc2U7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLm1heChwb3MsIHJpZ2h0bW9zdEZhaWx1cmVzUG9zKTsgaSsrKSB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICB2YXIgY2ggPSBpbnB1dC5jaGFyQXQoaSk7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICBpZiAoY2ggPT09IFwiXFxcXG5cIikgeycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgICBpZiAoIXNlZW5DUikgeyBsaW5lKys7IH0nLFxuICAgICAgICAgICAgJyAgICAgICAgICAgICAgY29sdW1uID0gMTsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgICAgc2VlbkNSID0gZmFsc2U7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIlxcXFxyXCIgfHwgY2ggPT09IFwiXFxcXHUyMDI4XCIgfHwgY2ggPT09IFwiXFxcXHUyMDI5XCIpIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgICAgbGluZSsrOycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgICBjb2x1bW4gPSAxOycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgICBzZWVuQ1IgPSB0cnVlOycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgfSBlbHNlIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgICAgY29sdW1uKys7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICAgIHNlZW5DUiA9IGZhbHNlOycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgICAgICByZXR1cm4geyBsaW5lOiBsaW5lLCBjb2x1bW46IGNvbHVtbiB9OycsXG4gICAgICAgICAgICAnICAgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICAjZW5kJyxcbiAgICAgICAgICAgICcgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgICNpZiBub2RlLmluaXRpYWxpemVyJyxcbiAgICAgICAgICAgICcgICAgICAgICNibG9jayBlbWl0KG5vZGUuaW5pdGlhbGl6ZXIpJyxcbiAgICAgICAgICAgICcgICAgICAjZW5kJyxcbiAgICAgICAgICAgICcgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgIHZhciByZXN1bHQgPSBwYXJzZUZ1bmN0aW9uc1tzdGFydFJ1bGVdKCk7JyxcbiAgICAgICAgICAgICcgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgIC8qJyxcbiAgICAgICAgICAgICcgICAgICAgKiBUaGUgcGFyc2VyIGlzIG5vdyBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyB0aHJlZSBzdGF0ZXM6JyxcbiAgICAgICAgICAgICcgICAgICAgKicsXG4gICAgICAgICAgICAnICAgICAgICogMS4gVGhlIHBhcnNlciBzdWNjZXNzZnVsbHkgcGFyc2VkIHRoZSB3aG9sZSBpbnB1dC4nLFxuICAgICAgICAgICAgJyAgICAgICAqJyxcbiAgICAgICAgICAgICcgICAgICAgKiAgICAtIHxyZXN1bHQgIT09IG51bGx8JyxcbiAgICAgICAgICAgICcgICAgICAgKiAgICAtIHwje3Bvc09mZnNldChcInBvc1wiKX0gPT09IGlucHV0Lmxlbmd0aHwnLFxuICAgICAgICAgICAgJyAgICAgICAqICAgIC0gfHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWR8IG1heSBvciBtYXkgbm90IGNvbnRhaW4gc29tZXRoaW5nJyxcbiAgICAgICAgICAgICcgICAgICAgKicsXG4gICAgICAgICAgICAnICAgICAgICogMi4gVGhlIHBhcnNlciBzdWNjZXNzZnVsbHkgcGFyc2VkIG9ubHkgYSBwYXJ0IG9mIHRoZSBpbnB1dC4nLFxuICAgICAgICAgICAgJyAgICAgICAqJyxcbiAgICAgICAgICAgICcgICAgICAgKiAgICAtIHxyZXN1bHQgIT09IG51bGx8JyxcbiAgICAgICAgICAgICcgICAgICAgKiAgICAtIHwje3Bvc09mZnNldChcInBvc1wiKX0gPCBpbnB1dC5sZW5ndGh8JyxcbiAgICAgICAgICAgICcgICAgICAgKiAgICAtIHxyaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkfCBtYXkgb3IgbWF5IG5vdCBjb250YWluIHNvbWV0aGluZycsXG4gICAgICAgICAgICAnICAgICAgIConLFxuICAgICAgICAgICAgJyAgICAgICAqIDMuIFRoZSBwYXJzZXIgZGlkIG5vdCBzdWNjZXNzZnVsbHkgcGFyc2UgYW55IHBhcnQgb2YgdGhlIGlucHV0LicsXG4gICAgICAgICAgICAnICAgICAgIConLFxuICAgICAgICAgICAgJyAgICAgICAqICAgLSB8cmVzdWx0ID09PSBudWxsfCcsXG4gICAgICAgICAgICAnICAgICAgICogICAtIHwje3Bvc09mZnNldChcInBvc1wiKX0gPT09IDB8JyxcbiAgICAgICAgICAgICcgICAgICAgKiAgIC0gfHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWR8IGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBmYWlsdXJlJyxcbiAgICAgICAgICAgICcgICAgICAgKicsXG4gICAgICAgICAgICAnICAgICAgICogQWxsIGNvZGUgZm9sbG93aW5nIHRoaXMgY29tbWVudCAoaW5jbHVkaW5nIGNhbGxlZCBmdW5jdGlvbnMpIG11c3QnLFxuICAgICAgICAgICAgJyAgICAgICAqIGhhbmRsZSB0aGVzZSBzdGF0ZXMuJyxcbiAgICAgICAgICAgICcgICAgICAgKi8nLFxuICAgICAgICAgICAgJyAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgI3twb3NPZmZzZXQoXCJwb3NcIil9ICE9PSBpbnB1dC5sZW5ndGgpIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgdmFyIG9mZnNldCA9IE1hdGgubWF4KCN7cG9zT2Zmc2V0KFwicG9zXCIpfSwgI3twb3NPZmZzZXQoXCJyaWdodG1vc3RGYWlsdXJlc1Bvc1wiKX0pOycsXG4gICAgICAgICAgICAnICAgICAgICB2YXIgZm91bmQgPSBvZmZzZXQgPCBpbnB1dC5sZW5ndGggPyBpbnB1dC5jaGFyQXQob2Zmc2V0KSA6IG51bGw7JyxcbiAgICAgICAgICAgICcgICAgICAgICNpZiBvcHRpb25zLnRyYWNrTGluZUFuZENvbHVtbicsXG4gICAgICAgICAgICAnICAgICAgICAgIHZhciBlcnJvclBvc2l0aW9uID0gI3twb3NPZmZzZXQoXCJwb3NcIil9ID4gI3twb3NPZmZzZXQoXCJyaWdodG1vc3RGYWlsdXJlc1Bvc1wiKX0gPyBwb3MgOiByaWdodG1vc3RGYWlsdXJlc1BvczsnLFxuICAgICAgICAgICAgJyAgICAgICAgI2Vsc2UnLFxuICAgICAgICAgICAgJyAgICAgICAgICB2YXIgZXJyb3JQb3NpdGlvbiA9IGNvbXB1dGVFcnJvclBvc2l0aW9uKCk7JyxcbiAgICAgICAgICAgICcgICAgICAgICNlbmQnLFxuICAgICAgICAgICAgJyAgICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAgIHRocm93IG5ldyB0aGlzLlN5bnRheEVycm9yKCcsXG4gICAgICAgICAgICAnICAgICAgICAgIGNsZWFudXBFeHBlY3RlZChyaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkKSwnLFxuICAgICAgICAgICAgJyAgICAgICAgICBmb3VuZCwnLFxuICAgICAgICAgICAgJyAgICAgICAgICBvZmZzZXQsJyxcbiAgICAgICAgICAgICcgICAgICAgICAgZXJyb3JQb3NpdGlvbi5saW5lLCcsXG4gICAgICAgICAgICAnICAgICAgICAgIGVycm9yUG9zaXRpb24uY29sdW1uJyxcbiAgICAgICAgICAgICcgICAgICAgICk7JyxcbiAgICAgICAgICAgICcgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgIHJldHVybiByZXN1bHQ7JyxcbiAgICAgICAgICAgICcgICAgfSwnLFxuICAgICAgICAgICAgJyAgICAnLFxuICAgICAgICAgICAgJyAgICAvKiBSZXR1cm5zIHRoZSBwYXJzZXIgc291cmNlIGNvZGUuICovJyxcbiAgICAgICAgICAgICcgICAgdG9Tb3VyY2U6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fc291cmNlOyB9JyxcbiAgICAgICAgICAgICcgIH07JyxcbiAgICAgICAgICAgICcgICcsXG4gICAgICAgICAgICAnICAvKiBUaHJvd24gd2hlbiBhIHBhcnNlciBlbmNvdW50ZXJzIGEgc3ludGF4IGVycm9yLiAqLycsXG4gICAgICAgICAgICAnICAnLFxuICAgICAgICAgICAgJyAgcmVzdWx0LlN5bnRheEVycm9yID0gZnVuY3Rpb24oZXhwZWN0ZWQsIGZvdW5kLCBvZmZzZXQsIGxpbmUsIGNvbHVtbikgeycsXG4gICAgICAgICAgICAnICAgIGZ1bmN0aW9uIGJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpIHsnLFxuICAgICAgICAgICAgJyAgICAgIHZhciBleHBlY3RlZEh1bWFuaXplZCwgZm91bmRIdW1hbml6ZWQ7JyxcbiAgICAgICAgICAgICcgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgIHN3aXRjaCAoZXhwZWN0ZWQubGVuZ3RoKSB7JyxcbiAgICAgICAgICAgICcgICAgICAgIGNhc2UgMDonLFxuICAgICAgICAgICAgJyAgICAgICAgICBleHBlY3RlZEh1bWFuaXplZCA9IFwiZW5kIG9mIGlucHV0XCI7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgYnJlYWs7JyxcbiAgICAgICAgICAgICcgICAgICAgIGNhc2UgMTonLFxuICAgICAgICAgICAgJyAgICAgICAgICBleHBlY3RlZEh1bWFuaXplZCA9IGV4cGVjdGVkWzBdOycsXG4gICAgICAgICAgICAnICAgICAgICAgIGJyZWFrOycsXG4gICAgICAgICAgICAnICAgICAgICBkZWZhdWx0OicsXG4gICAgICAgICAgICAnICAgICAgICAgIGV4cGVjdGVkSHVtYW5pemVkID0gZXhwZWN0ZWQuc2xpY2UoMCwgZXhwZWN0ZWQubGVuZ3RoIC0gMSkuam9pbihcIiwgXCIpJyxcbiAgICAgICAgICAgICcgICAgICAgICAgICArIFwiIG9yIFwiJyxcbiAgICAgICAgICAgICcgICAgICAgICAgICArIGV4cGVjdGVkW2V4cGVjdGVkLmxlbmd0aCAtIDFdOycsXG4gICAgICAgICAgICAnICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICBmb3VuZEh1bWFuaXplZCA9IGZvdW5kID8gcXVvdGUoZm91bmQpIDogXCJlbmQgb2YgaW5wdXRcIjsnLFxuICAgICAgICAgICAgJyAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgcmV0dXJuIFwiRXhwZWN0ZWQgXCIgKyBleHBlY3RlZEh1bWFuaXplZCArIFwiIGJ1dCBcIiArIGZvdW5kSHVtYW5pemVkICsgXCIgZm91bmQuXCI7JyxcbiAgICAgICAgICAgICcgICAgfScsXG4gICAgICAgICAgICAnICAgICcsXG4gICAgICAgICAgICAnICAgIHRoaXMubmFtZSA9IFwiU3ludGF4RXJyb3JcIjsnLFxuICAgICAgICAgICAgJyAgICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7JyxcbiAgICAgICAgICAgICcgICAgdGhpcy5mb3VuZCA9IGZvdW5kOycsXG4gICAgICAgICAgICAnICAgIHRoaXMubWVzc2FnZSA9IGJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpOycsXG4gICAgICAgICAgICAnICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0OycsXG4gICAgICAgICAgICAnICAgIHRoaXMubGluZSA9IGxpbmU7JyxcbiAgICAgICAgICAgICcgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47JyxcbiAgICAgICAgICAgICcgIH07JyxcbiAgICAgICAgICAgICcgICcsXG4gICAgICAgICAgICAnICByZXN1bHQuU3ludGF4RXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlOycsXG4gICAgICAgICAgICAnICAnLFxuICAgICAgICAgICAgJyAgcmV0dXJuIHJlc3VsdDsnLFxuICAgICAgICAgICAgJ30pKCknXG4gICAgICAgICAgXSxcbiAgICAgICAgICBydWxlOiBbXG4gICAgICAgICAgICAnZnVuY3Rpb24gcGFyc2VfI3tub2RlLm5hbWV9KCkgeycsXG4gICAgICAgICAgICAnICAjaWYgb3B0aW9ucy5jYWNoZScsXG4gICAgICAgICAgICAnICAgIHZhciBjYWNoZUtleSA9IFwiI3tub2RlLm5hbWV9QFwiICsgI3twb3NPZmZzZXQoXCJwb3NcIil9OycsXG4gICAgICAgICAgICAnICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07JyxcbiAgICAgICAgICAgICcgICAgaWYgKGNhY2hlZFJlc3VsdCkgeycsXG4gICAgICAgICAgICAnICAgICAgcG9zID0gI3twb3NDbG9uZShcImNhY2hlZFJlc3VsdC5uZXh0UG9zXCIpfTsnLFxuICAgICAgICAgICAgJyAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0OycsXG4gICAgICAgICAgICAnICAgIH0nLFxuICAgICAgICAgICAgJyAgICAnLFxuICAgICAgICAgICAgJyAgI2VuZCcsXG4gICAgICAgICAgICAnICAjaWYgbm9kZS5yZXN1bHRWYXJzLmxlbmd0aCA+IDAnLFxuICAgICAgICAgICAgJyAgICB2YXIgI3tub2RlLnJlc3VsdFZhcnMuam9pbihcIiwgXCIpfTsnLFxuICAgICAgICAgICAgJyAgI2VuZCcsXG4gICAgICAgICAgICAnICAjaWYgbm9kZS5wb3NWYXJzLmxlbmd0aCA+IDAnLFxuICAgICAgICAgICAgJyAgICB2YXIgI3tub2RlLnBvc1ZhcnMuam9pbihcIiwgXCIpfTsnLFxuICAgICAgICAgICAgJyAgI2VuZCcsXG4gICAgICAgICAgICAnICAnLFxuICAgICAgICAgICAgJyAgI2lmIG5vZGUuZGlzcGxheU5hbWUgIT09IG51bGwnLFxuICAgICAgICAgICAgJyAgICByZXBvcnRGYWlsdXJlcysrOycsXG4gICAgICAgICAgICAnICAjZW5kJyxcbiAgICAgICAgICAgICcgICNibG9jayBlbWl0KG5vZGUuZXhwcmVzc2lvbiknLFxuICAgICAgICAgICAgJyAgI2lmIG5vZGUuZGlzcGxheU5hbWUgIT09IG51bGwnLFxuICAgICAgICAgICAgJyAgICByZXBvcnRGYWlsdXJlcy0tOycsXG4gICAgICAgICAgICAnICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCAmJiAje25vZGUucmVzdWx0VmFyfSA9PT0gbnVsbCkgeycsXG4gICAgICAgICAgICAnICAgICAgbWF0Y2hGYWlsZWQoI3tzdHJpbmcobm9kZS5kaXNwbGF5TmFtZSl9KTsnLFxuICAgICAgICAgICAgJyAgICB9JyxcbiAgICAgICAgICAgICcgICNlbmQnLFxuICAgICAgICAgICAgJyAgI2lmIG9wdGlvbnMuY2FjaGUnLFxuICAgICAgICAgICAgJyAgICAnLFxuICAgICAgICAgICAgJyAgICBjYWNoZVtjYWNoZUtleV0gPSB7JyxcbiAgICAgICAgICAgICcgICAgICBuZXh0UG9zOiAje3Bvc0Nsb25lKFwicG9zXCIpfSwnLFxuICAgICAgICAgICAgJyAgICAgIHJlc3VsdDogICN7bm9kZS5yZXN1bHRWYXJ9JyxcbiAgICAgICAgICAgICcgICAgfTsnLFxuICAgICAgICAgICAgJyAgI2VuZCcsXG4gICAgICAgICAgICAnICByZXR1cm4gI3tub2RlLnJlc3VsdFZhcn07JyxcbiAgICAgICAgICAgICd9J1xuICAgICAgICAgIF0sXG4gICAgICAgICAgY2hvaWNlOiBbXG4gICAgICAgICAgICAnI2Jsb2NrIGVtaXQoYWx0ZXJuYXRpdmUpJyxcbiAgICAgICAgICAgICcjYmxvY2sgbmV4dEFsdGVybmF0aXZlc0NvZGUnXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcImNob2ljZS5uZXh0XCI6IFtcbiAgICAgICAgICAgICdpZiAoI3tub2RlLnJlc3VsdFZhcn0gPT09IG51bGwpIHsnLFxuICAgICAgICAgICAgJyAgI2Jsb2NrIGNvZGUnLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgICAgXSxcbiAgICAgICAgICBzZXF1ZW5jZTogW1xuICAgICAgICAgICAgJyN7cG9zU2F2ZShub2RlKX07JyxcbiAgICAgICAgICAgICcjYmxvY2sgY29kZSdcbiAgICAgICAgICBdLFxuICAgICAgICAgIFwic2VxdWVuY2UuaXRlcmF0aW9uXCI6IFtcbiAgICAgICAgICAgICcjYmxvY2sgZW1pdChlbGVtZW50KScsXG4gICAgICAgICAgICAnaWYgKCN7ZWxlbWVudC5yZXN1bHRWYXJ9ICE9PSBudWxsKSB7JyxcbiAgICAgICAgICAgICcgICNibG9jayBjb2RlJyxcbiAgICAgICAgICAgICd9IGVsc2UgeycsXG4gICAgICAgICAgICAnICAje25vZGUucmVzdWx0VmFyfSA9IG51bGw7JyxcbiAgICAgICAgICAgICcgICN7cG9zUmVzdG9yZShub2RlKX07JyxcbiAgICAgICAgICAgICd9J1xuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJzZXF1ZW5jZS5pbm5lclwiOiBbXG4gICAgICAgICAgICAnI3tub2RlLnJlc3VsdFZhcn0gPSBbI3twbHVjayhub2RlLmVsZW1lbnRzLCBcInJlc3VsdFZhclwiKS5qb2luKFwiLCBcIil9XTsnXG4gICAgICAgICAgXSxcbiAgICAgICAgICBzaW1wbGVfYW5kOiBbXG4gICAgICAgICAgICAnI3twb3NTYXZlKG5vZGUpfTsnLFxuICAgICAgICAgICAgJ3JlcG9ydEZhaWx1cmVzKys7JyxcbiAgICAgICAgICAgICcjYmxvY2sgZW1pdChub2RlLmV4cHJlc3Npb24pJyxcbiAgICAgICAgICAgICdyZXBvcnRGYWlsdXJlcy0tOycsXG4gICAgICAgICAgICAnaWYgKCN7bm9kZS5yZXN1bHRWYXJ9ICE9PSBudWxsKSB7JyxcbiAgICAgICAgICAgICcgICN7bm9kZS5yZXN1bHRWYXJ9ID0gXCJcIjsnLFxuICAgICAgICAgICAgJyAgI3twb3NSZXN0b3JlKG5vZGUpfTsnLFxuICAgICAgICAgICAgJ30gZWxzZSB7JyxcbiAgICAgICAgICAgICcgICN7bm9kZS5yZXN1bHRWYXJ9ID0gbnVsbDsnLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgICAgXSxcbiAgICAgICAgICBzaW1wbGVfbm90OiBbXG4gICAgICAgICAgICAnI3twb3NTYXZlKG5vZGUpfTsnLFxuICAgICAgICAgICAgJ3JlcG9ydEZhaWx1cmVzKys7JyxcbiAgICAgICAgICAgICcjYmxvY2sgZW1pdChub2RlLmV4cHJlc3Npb24pJyxcbiAgICAgICAgICAgICdyZXBvcnRGYWlsdXJlcy0tOycsXG4gICAgICAgICAgICAnaWYgKCN7bm9kZS5yZXN1bHRWYXJ9ID09PSBudWxsKSB7JyxcbiAgICAgICAgICAgICcgICN7bm9kZS5yZXN1bHRWYXJ9ID0gXCJcIjsnLFxuICAgICAgICAgICAgJ30gZWxzZSB7JyxcbiAgICAgICAgICAgICcgICN7bm9kZS5yZXN1bHRWYXJ9ID0gbnVsbDsnLFxuICAgICAgICAgICAgJyAgI3twb3NSZXN0b3JlKG5vZGUpfTsnLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgICAgXSxcbiAgICAgICAgICBzZW1hbnRpY19hbmQ6IFtcbiAgICAgICAgICAgICcje25vZGUucmVzdWx0VmFyfSA9IChmdW5jdGlvbigjeyhvcHRpb25zLnRyYWNrTGluZUFuZENvbHVtbiA/IFtcIm9mZnNldFwiLCBcImxpbmVcIiwgXCJjb2x1bW5cIl0gOiBbXCJvZmZzZXRcIl0pLmNvbmNhdChrZXlzKG5vZGUucGFyYW1zKSkuam9pbihcIiwgXCIpfSkgeyN7bm9kZS5jb2RlfX0pKCN7KG9wdGlvbnMudHJhY2tMaW5lQW5kQ29sdW1uID8gW1wicG9zLm9mZnNldFwiLCBcInBvcy5saW5lXCIsIFwicG9zLmNvbHVtblwiXSA6IFtcInBvc1wiXSkuY29uY2F0KHZhbHVlcyhub2RlLnBhcmFtcykpLmpvaW4oXCIsIFwiKX0pID8gXCJcIiA6IG51bGw7J1xuICAgICAgICAgIF0sXG4gICAgICAgICAgc2VtYW50aWNfbm90OiBbXG4gICAgICAgICAgICAnI3tub2RlLnJlc3VsdFZhcn0gPSAoZnVuY3Rpb24oI3sob3B0aW9ucy50cmFja0xpbmVBbmRDb2x1bW4gPyBbXCJvZmZzZXRcIiwgXCJsaW5lXCIsIFwiY29sdW1uXCJdIDogW1wib2Zmc2V0XCJdKS5jb25jYXQoa2V5cyhub2RlLnBhcmFtcykpLmpvaW4oXCIsIFwiKX0pIHsje25vZGUuY29kZX19KSgjeyhvcHRpb25zLnRyYWNrTGluZUFuZENvbHVtbiA/IFtcInBvcy5vZmZzZXRcIiwgXCJwb3MubGluZVwiLCBcInBvcy5jb2x1bW5cIl0gOiBbXCJwb3NcIl0pLmNvbmNhdCh2YWx1ZXMobm9kZS5wYXJhbXMpKS5qb2luKFwiLCBcIil9KSA/IG51bGwgOiBcIlwiOydcbiAgICAgICAgICBdLFxuICAgICAgICAgIG9wdGlvbmFsOiBbXG4gICAgICAgICAgICAnI2Jsb2NrIGVtaXQobm9kZS5leHByZXNzaW9uKScsXG4gICAgICAgICAgICAnI3tub2RlLnJlc3VsdFZhcn0gPSAje25vZGUucmVzdWx0VmFyfSAhPT0gbnVsbCA/ICN7bm9kZS5yZXN1bHRWYXJ9IDogXCJcIjsnXG4gICAgICAgICAgXSxcbiAgICAgICAgICB6ZXJvX29yX21vcmU6IFtcbiAgICAgICAgICAgICcje25vZGUucmVzdWx0VmFyfSA9IFtdOycsXG4gICAgICAgICAgICAnI2Jsb2NrIGVtaXQobm9kZS5leHByZXNzaW9uKScsXG4gICAgICAgICAgICAnd2hpbGUgKCN7bm9kZS5leHByZXNzaW9uLnJlc3VsdFZhcn0gIT09IG51bGwpIHsnLFxuICAgICAgICAgICAgJyAgI3tub2RlLnJlc3VsdFZhcn0ucHVzaCgje25vZGUuZXhwcmVzc2lvbi5yZXN1bHRWYXJ9KTsnLFxuICAgICAgICAgICAgJyAgI2Jsb2NrIGVtaXQobm9kZS5leHByZXNzaW9uKScsXG4gICAgICAgICAgICAnfSdcbiAgICAgICAgICBdLFxuICAgICAgICAgIG9uZV9vcl9tb3JlOiBbXG4gICAgICAgICAgICAnI2Jsb2NrIGVtaXQobm9kZS5leHByZXNzaW9uKScsXG4gICAgICAgICAgICAnaWYgKCN7bm9kZS5leHByZXNzaW9uLnJlc3VsdFZhcn0gIT09IG51bGwpIHsnLFxuICAgICAgICAgICAgJyAgI3tub2RlLnJlc3VsdFZhcn0gPSBbXTsnLFxuICAgICAgICAgICAgJyAgd2hpbGUgKCN7bm9kZS5leHByZXNzaW9uLnJlc3VsdFZhcn0gIT09IG51bGwpIHsnLFxuICAgICAgICAgICAgJyAgICAje25vZGUucmVzdWx0VmFyfS5wdXNoKCN7bm9kZS5leHByZXNzaW9uLnJlc3VsdFZhcn0pOycsXG4gICAgICAgICAgICAnICAgICNibG9jayBlbWl0KG5vZGUuZXhwcmVzc2lvbiknLFxuICAgICAgICAgICAgJyAgfScsXG4gICAgICAgICAgICAnfSBlbHNlIHsnLFxuICAgICAgICAgICAgJyAgI3tub2RlLnJlc3VsdFZhcn0gPSBudWxsOycsXG4gICAgICAgICAgICAnfSdcbiAgICAgICAgICBdLFxuICAgICAgICAgIGFjdGlvbjogW1xuICAgICAgICAgICAgJyN7cG9zU2F2ZShub2RlKX07JyxcbiAgICAgICAgICAgICcjYmxvY2sgZW1pdChub2RlLmV4cHJlc3Npb24pJyxcbiAgICAgICAgICAgICdpZiAoI3tub2RlLnJlc3VsdFZhcn0gIT09IG51bGwpIHsnLFxuICAgICAgICAgICAgJyAgI3tub2RlLnJlc3VsdFZhcn0gPSAoZnVuY3Rpb24oI3sob3B0aW9ucy50cmFja0xpbmVBbmRDb2x1bW4gPyBbXCJvZmZzZXRcIiwgXCJsaW5lXCIsIFwiY29sdW1uXCJdIDogW1wib2Zmc2V0XCJdKS5jb25jYXQoa2V5cyhub2RlLnBhcmFtcykpLmpvaW4oXCIsIFwiKX0pIHsje25vZGUuY29kZX19KSgjeyhvcHRpb25zLnRyYWNrTGluZUFuZENvbHVtbiA/IFtub2RlLnBvc1ZhciArIFwiLm9mZnNldFwiLCBub2RlLnBvc1ZhciArIFwiLmxpbmVcIiwgbm9kZS5wb3NWYXIgKyBcIi5jb2x1bW5cIl0gOiBbbm9kZS5wb3NWYXJdKS5jb25jYXQodmFsdWVzKG5vZGUucGFyYW1zKSkuam9pbihcIiwgXCIpfSk7JyxcbiAgICAgICAgICAgICd9JyxcbiAgICAgICAgICAgICdpZiAoI3tub2RlLnJlc3VsdFZhcn0gPT09IG51bGwpIHsnLFxuICAgICAgICAgICAgJyAgI3twb3NSZXN0b3JlKG5vZGUpfTsnLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgICAgXSxcbiAgICAgICAgICBydWxlX3JlZjogW1xuICAgICAgICAgICAgJyN7bm9kZS5yZXN1bHRWYXJ9ID0gcGFyc2VfI3tub2RlLm5hbWV9KCk7J1xuICAgICAgICAgIF0sXG4gICAgICAgICAgbGl0ZXJhbDogW1xuICAgICAgICAgICAgJyNpZiBub2RlLnZhbHVlLmxlbmd0aCA9PT0gMCcsXG4gICAgICAgICAgICAnICAje25vZGUucmVzdWx0VmFyfSA9IFwiXCI7JyxcbiAgICAgICAgICAgICcjZWxzZScsXG4gICAgICAgICAgICAnICAjaWYgIW5vZGUuaWdub3JlQ2FzZScsXG4gICAgICAgICAgICAnICAgICNpZiBub2RlLnZhbHVlLmxlbmd0aCA9PT0gMScsXG4gICAgICAgICAgICAnICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoI3twb3NPZmZzZXQoXCJwb3NcIil9KSA9PT0gI3tub2RlLnZhbHVlLmNoYXJDb2RlQXQoMCl9KSB7JyxcbiAgICAgICAgICAgICcgICAgI2Vsc2UnLFxuICAgICAgICAgICAgJyAgICAgIGlmIChpbnB1dC5zdWJzdHIoI3twb3NPZmZzZXQoXCJwb3NcIil9LCAje25vZGUudmFsdWUubGVuZ3RofSkgPT09ICN7c3RyaW5nKG5vZGUudmFsdWUpfSkgeycsXG4gICAgICAgICAgICAnICAgICNlbmQnLFxuICAgICAgICAgICAgJyAgI2Vsc2UnLFxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIE9uZS1jaGFyIGxpdGVyYWxzIGFyZSBub3Qgb3B0aW1pemVkIHdoZW4gY2FzZS1pbnNlbnNpdGl2ZVxuICAgICAgICAgICAgICogbWF0Y2hpbmcgaXMgZW5hYmxlZC4gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIHNpbXBsZSB3YXkgdG9cbiAgICAgICAgICAgICAqIGxvd2VyY2FzZSBhIGNoYXJhY3RlciBjb2RlIHRoYXQgd29ya3MgZm9yIGNoYXJhY3RlciBvdXRzaWRlIEFTQ0lJXG4gICAgICAgICAgICAgKiBsZXR0ZXJzLiBNb3Jlb3ZlciwgfHRvTG93ZXJDYXNlfCBjYW4gY2hhbmdlIHN0cmluZyBsZW5ndGgsXG4gICAgICAgICAgICAgKiBtZWFuaW5nIHRoZSByZXN1bHQgb2YgbG93ZXJjYXNpbmcgYSBjaGFyYWN0ZXIgY2FuIGJlIG1vcmVcbiAgICAgICAgICAgICAqIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICcgICAgaWYgKGlucHV0LnN1YnN0cigje3Bvc09mZnNldChcInBvc1wiKX0sICN7bm9kZS52YWx1ZS5sZW5ndGh9KS50b0xvd2VyQ2FzZSgpID09PSAje3N0cmluZyhub2RlLnZhbHVlLnRvTG93ZXJDYXNlKCkpfSkgeycsXG4gICAgICAgICAgICAnICAjZW5kJyxcbiAgICAgICAgICAgICcgICAgI2lmICFub2RlLmlnbm9yZUNhc2UnLFxuICAgICAgICAgICAgJyAgICAgICN7bm9kZS5yZXN1bHRWYXJ9ID0gI3tzdHJpbmcobm9kZS52YWx1ZSl9OycsXG4gICAgICAgICAgICAnICAgICNlbHNlJyxcbiAgICAgICAgICAgICcgICAgICAje25vZGUucmVzdWx0VmFyfSA9IGlucHV0LnN1YnN0cigje3Bvc09mZnNldChcInBvc1wiKX0sICN7bm9kZS52YWx1ZS5sZW5ndGh9KTsnLFxuICAgICAgICAgICAgJyAgICAjZW5kJyxcbiAgICAgICAgICAgICcgICAgI3twb3NBZHZhbmNlKG5vZGUudmFsdWUubGVuZ3RoKX07JyxcbiAgICAgICAgICAgICcgIH0gZWxzZSB7JyxcbiAgICAgICAgICAgICcgICAgI3tub2RlLnJlc3VsdFZhcn0gPSBudWxsOycsXG4gICAgICAgICAgICAnICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkgeycsXG4gICAgICAgICAgICAnICAgICAgbWF0Y2hGYWlsZWQoI3tzdHJpbmcoc3RyaW5nKG5vZGUudmFsdWUpKX0pOycsXG4gICAgICAgICAgICAnICAgIH0nLFxuICAgICAgICAgICAgJyAgfScsXG4gICAgICAgICAgICAnI2VuZCdcbiAgICAgICAgICBdLFxuICAgICAgICAgIGFueTogW1xuICAgICAgICAgICAgJ2lmIChpbnB1dC5sZW5ndGggPiAje3Bvc09mZnNldChcInBvc1wiKX0pIHsnLFxuICAgICAgICAgICAgJyAgI3tub2RlLnJlc3VsdFZhcn0gPSBpbnB1dC5jaGFyQXQoI3twb3NPZmZzZXQoXCJwb3NcIil9KTsnLFxuICAgICAgICAgICAgJyAgI3twb3NBZHZhbmNlKDEpfTsnLFxuICAgICAgICAgICAgJ30gZWxzZSB7JyxcbiAgICAgICAgICAgICcgICN7bm9kZS5yZXN1bHRWYXJ9ID0gbnVsbDsnLFxuICAgICAgICAgICAgJyAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7JyxcbiAgICAgICAgICAgICcgICAgbWF0Y2hGYWlsZWQoXCJhbnkgY2hhcmFjdGVyXCIpOycsXG4gICAgICAgICAgICAnICB9JyxcbiAgICAgICAgICAgICd9J1xuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJjbGFzc1wiOiBbXG4gICAgICAgICAgICAnaWYgKCN7cmVnZXhwfS50ZXN0KGlucHV0LmNoYXJBdCgje3Bvc09mZnNldChcInBvc1wiKX0pKSkgeycsXG4gICAgICAgICAgICAnICAje25vZGUucmVzdWx0VmFyfSA9IGlucHV0LmNoYXJBdCgje3Bvc09mZnNldChcInBvc1wiKX0pOycsXG4gICAgICAgICAgICAnICAje3Bvc0FkdmFuY2UoMSl9OycsXG4gICAgICAgICAgICAnfSBlbHNlIHsnLFxuICAgICAgICAgICAgJyAgI3tub2RlLnJlc3VsdFZhcn0gPSBudWxsOycsXG4gICAgICAgICAgICAnICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHsnLFxuICAgICAgICAgICAgJyAgICBtYXRjaEZhaWxlZCgje3N0cmluZyhub2RlLnJhd1RleHQpfSk7JyxcbiAgICAgICAgICAgICcgIH0nLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuXG4gICAgZm9yIChuYW1lIGluIHNvdXJjZXMpIHtcbiAgICAgIHRlbXBsYXRlc1tuYW1lXSA9IENvZGllLnRlbXBsYXRlKHNvdXJjZXNbbmFtZV0uam9pbignXFxuJykpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZW1wbGF0ZXM7XG4gIH0pKCk7XG5cbiAgZnVuY3Rpb24gZmlsbChuYW1lLCB2YXJzKSB7XG4gICAgdmFycy5zdHJpbmcgID0gcXVvdGU7XG4gICAgdmFycy5wbHVjayAgID0gcGx1Y2s7XG4gICAgdmFycy5rZXlzICAgID0ga2V5cztcbiAgICB2YXJzLnZhbHVlcyAgPSB2YWx1ZXM7XG4gICAgdmFycy5lbWl0ICAgID0gZW1pdDtcbiAgICB2YXJzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgLyogUG9zaXRpb24taGFuZGxpbmcgbWFjcm9zICovXG4gICAgaWYgKG9wdGlvbnMudHJhY2tMaW5lQW5kQ29sdW1uKSB7XG4gICAgICB2YXJzLnBvc0luaXQgICAgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBcInZhciBcIlxuICAgICAgICAgICAgICsgbmFtZVxuICAgICAgICAgICAgICsgXCIgPSBcIlxuICAgICAgICAgICAgICsgXCJ7IG9mZnNldDogMCwgbGluZTogMSwgY29sdW1uOiAxLCBzZWVuQ1I6IGZhbHNlIH1cIjtcbiAgICAgIH07XG4gICAgICB2YXJzLnBvc0Nsb25lICAgPSBmdW5jdGlvbihuYW1lKSB7IHJldHVybiBcImNsb25lKFwiICsgbmFtZSArIFwiKVwiOyB9O1xuICAgICAgdmFycy5wb3NPZmZzZXQgID0gZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gbmFtZSArIFwiLm9mZnNldFwiOyB9O1xuXG4gICAgICB2YXJzLnBvc0FkdmFuY2UgPSBmdW5jdGlvbihuKSAgICB7IHJldHVybiBcImFkdmFuY2UocG9zLCBcIiArIG4gKyBcIilcIjsgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFycy5wb3NJbml0ICAgID0gZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gXCJ2YXIgXCIgKyBuYW1lICsgXCIgPSAwXCI7IH07XG4gICAgICB2YXJzLnBvc0Nsb25lICAgPSBmdW5jdGlvbihuYW1lKSB7IHJldHVybiBuYW1lOyB9O1xuICAgICAgdmFycy5wb3NPZmZzZXQgID0gZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gbmFtZTsgfTtcblxuICAgICAgdmFycy5wb3NBZHZhbmNlID0gZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gbiA9PT0gMSA/IFwicG9zKytcIiA6IFwicG9zICs9IFwiICsgbjtcbiAgICAgIH07XG4gICAgfVxuICAgIHZhcnMucG9zU2F2ZSAgICA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLnBvc1ZhciArIFwiID0gXCIgKyB2YXJzLnBvc0Nsb25lKFwicG9zXCIpO1xuICAgIH07XG4gICAgdmFycy5wb3NSZXN0b3JlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIFwicG9zXCIgKyBcIiA9IFwiICsgdmFycy5wb3NDbG9uZShub2RlLnBvc1Zhcik7XG4gICAgfTtcblxuICAgIHJldHVybiB0ZW1wbGF0ZXNbbmFtZV0odmFycyk7XG4gIH1cblxuICBmdW5jdGlvbiBlbWl0U2ltcGxlKG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obm9kZSkgeyByZXR1cm4gZmlsbChuYW1lLCB7IG5vZGU6IG5vZGUgfSk7IH07XG4gIH1cblxuICB2YXIgZW1pdCA9IGJ1aWxkTm9kZVZpc2l0b3Ioe1xuICAgIGdyYW1tYXI6IGVtaXRTaW1wbGUoXCJncmFtbWFyXCIpLFxuXG4gICAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uKG5vZGUpIHsgcmV0dXJuIG5vZGUuY29kZTsgfSxcblxuICAgIHJ1bGU6IGVtaXRTaW1wbGUoXCJydWxlXCIpLFxuXG4gICAgLypcbiAgICAgKiBUaGUgY29udHJhY3QgZm9yIGFsbCBjb2RlIGZyYWdtZW50cyBnZW5lcmF0ZWQgYnkgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnNcbiAgICAgKiBpcyBhcyBmb2xsb3dzLlxuICAgICAqXG4gICAgICogVGhlIGNvZGUgZnJhZ21lbnQgdHJpZXMgdG8gbWF0Y2ggYSBwYXJ0IG9mIHRoZSBpbnB1dCBzdGFydGluZyB3aXRoIHRoZVxuICAgICAqIHBvc2l0aW9uIGluZGljYXRlZCBpbiB8cG9zfC4gVGhhdCBwb3NpdGlvbiBtYXkgcG9pbnQgcGFzdCB0aGUgZW5kIG9mIHRoZVxuICAgICAqIGlucHV0LlxuICAgICAqXG4gICAgICogKiBJZiB0aGUgY29kZSBmcmFnbWVudCBtYXRjaGVzIHRoZSBpbnB1dCwgaXQgYWR2YW5jZXMgfHBvc3wgdG8gcG9pbnQgdG9cbiAgICAgKiAgIHRoZSBmaXJzdCBjaHJhY3RlciBmb2xsb3dpbmcgdGhlIG1hdGNoZWQgcGFydCBvZiB0aGUgaW5wdXQgYW5kIHNldHNcbiAgICAgKiAgIHZhcmlhYmxlIHdpdGggYSBuYW1lIHN0b3JlZCBpbiB8bm9kZS5yZXN1bHRWYXJ8IHRvIGFuIGFwcHJvcHJpYXRlXG4gICAgICogICB2YWx1ZS4gVGhpcyB2YWx1ZSBpcyBhbHdheXMgbm9uLXxudWxsfC5cbiAgICAgKlxuICAgICAqICogSWYgdGhlIGNvZGUgZnJhZ21lbnQgZG9lcyBub3QgbWF0Y2ggdGhlIGlucHV0LCBpdCByZXR1cm5zIHdpdGggfHBvc3xcbiAgICAgKiAgIHNldCB0byB0aGUgb3JpZ2luYWwgdmFsdWUgYW5kIGl0IHNldHMgYSB2YXJpYWJsZSB3aXRoIGEgbmFtZSBzdG9yZWQgaW5cbiAgICAgKiAgIHxub2RlLnJlc3VsdFZhcnwgdG8gfG51bGx8LlxuICAgICAqXG4gICAgICogVGhlIGNvZGUgY2FuIHVzZSB2YXJpYWJsZXMgd2l0aCBuYW1lcyBzdG9yZWQgaW4gfHJlc3VsdFZhcnwgYW5kIHxwb3NWYXJ8XG4gICAgICogcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBub2RlJ3Mgc3Vibm9kZXMuIEl0IGNhbid0IHVzZSBhbnkgb3RoZXJcbiAgICAgKiB2YXJpYWJsZXMuXG4gICAgICovXG5cbiAgICBjaG9pY2U6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBjb2RlLCBuZXh0QWx0ZXJuYXRpdmVzQ29kZTtcblxuICAgICAgZm9yICh2YXIgaSA9IG5vZGUuYWx0ZXJuYXRpdmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIG5leHRBbHRlcm5hdGl2ZXNDb2RlID0gaSAhPT0gbm9kZS5hbHRlcm5hdGl2ZXMubGVuZ3RoIC0gMVxuICAgICAgICAgID8gZmlsbChcImNob2ljZS5uZXh0XCIsIHsgbm9kZTogbm9kZSwgY29kZTogY29kZSB9KVxuICAgICAgICAgIDogJyc7XG4gICAgICAgIGNvZGUgPSBmaWxsKFwiY2hvaWNlXCIsIHtcbiAgICAgICAgICBhbHRlcm5hdGl2ZTogICAgICAgICAgbm9kZS5hbHRlcm5hdGl2ZXNbaV0sXG4gICAgICAgICAgbmV4dEFsdGVybmF0aXZlc0NvZGU6IG5leHRBbHRlcm5hdGl2ZXNDb2RlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29kZTtcbiAgICB9LFxuXG4gICAgc2VxdWVuY2U6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBjb2RlID0gZmlsbChcInNlcXVlbmNlLmlubmVyXCIsIHsgbm9kZTogbm9kZSB9KTtcblxuICAgICAgZm9yICh2YXIgaSA9IG5vZGUuZWxlbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29kZSA9IGZpbGwoXCJzZXF1ZW5jZS5pdGVyYXRpb25cIiwge1xuICAgICAgICAgIG5vZGU6ICAgIG5vZGUsXG4gICAgICAgICAgZWxlbWVudDogbm9kZS5lbGVtZW50c1tpXSxcbiAgICAgICAgICBjb2RlOiAgICBjb2RlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmlsbChcInNlcXVlbmNlXCIsIHsgbm9kZTogbm9kZSwgY29kZTogY29kZSB9KTtcbiAgICB9LFxuXG4gICAgbGFiZWxlZDogZnVuY3Rpb24obm9kZSkgeyByZXR1cm4gZW1pdChub2RlLmV4cHJlc3Npb24pOyB9LFxuXG4gICAgc2ltcGxlX2FuZDogICBlbWl0U2ltcGxlKFwic2ltcGxlX2FuZFwiKSxcbiAgICBzaW1wbGVfbm90OiAgIGVtaXRTaW1wbGUoXCJzaW1wbGVfbm90XCIpLFxuICAgIHNlbWFudGljX2FuZDogZW1pdFNpbXBsZShcInNlbWFudGljX2FuZFwiKSxcbiAgICBzZW1hbnRpY19ub3Q6IGVtaXRTaW1wbGUoXCJzZW1hbnRpY19ub3RcIiksXG4gICAgb3B0aW9uYWw6ICAgICBlbWl0U2ltcGxlKFwib3B0aW9uYWxcIiksXG4gICAgemVyb19vcl9tb3JlOiBlbWl0U2ltcGxlKFwiemVyb19vcl9tb3JlXCIpLFxuICAgIG9uZV9vcl9tb3JlOiAgZW1pdFNpbXBsZShcIm9uZV9vcl9tb3JlXCIpLFxuICAgIGFjdGlvbjogICAgICAgZW1pdFNpbXBsZShcImFjdGlvblwiKSxcbiAgICBydWxlX3JlZjogICAgIGVtaXRTaW1wbGUoXCJydWxlX3JlZlwiKSxcbiAgICBsaXRlcmFsOiAgICAgIGVtaXRTaW1wbGUoXCJsaXRlcmFsXCIpLFxuICAgIGFueTogICAgICAgICAgZW1pdFNpbXBsZShcImFueVwiKSxcblxuICAgIFwiY2xhc3NcIjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHJlZ2V4cDtcblxuICAgICAgaWYgKG5vZGUucGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICByZWdleHAgPSAnL15bJ1xuICAgICAgICAgICsgKG5vZGUuaW52ZXJ0ZWQgPyAnXicgOiAnJylcbiAgICAgICAgICArIG1hcChub2RlLnBhcnRzLCBmdW5jdGlvbihwYXJ0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJ0IGluc3RhbmNlb2YgQXJyYXlcbiAgICAgICAgICAgICAgICA/IHF1b3RlRm9yUmVnZXhwQ2xhc3MocGFydFswXSlcbiAgICAgICAgICAgICAgICAgICsgJy0nXG4gICAgICAgICAgICAgICAgICArIHF1b3RlRm9yUmVnZXhwQ2xhc3MocGFydFsxXSlcbiAgICAgICAgICAgICAgICA6IHF1b3RlRm9yUmVnZXhwQ2xhc3MocGFydCk7XG4gICAgICAgICAgICB9KS5qb2luKCcnKVxuICAgICAgICAgICsgJ10vJyArIChub2RlLmlnbm9yZUNhc2UgPyAnaScgOiAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKlxuICAgICAgICAgKiBTdHVwaWQgSUUgY29uc2lkZXJzIHJlZ2V4cHMgL1tdLyBhbmQgL1teXS8gc3ludGFjdGljYWxseSBpbnZhbGlkLCBzb1xuICAgICAgICAgKiB3ZSB0cmFuc2xhdGUgdGhlbSBpbnRvIGV1cWl2YWxlbnRzIGl0IGNhbiBoYW5kbGUuXG4gICAgICAgICAqL1xuICAgICAgICByZWdleHAgPSBub2RlLmludmVydGVkID8gJy9eW1xcXFxTXFxcXHNdLycgOiAnL14oPyEpLyc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaWxsKFwiY2xhc3NcIiwgeyBub2RlOiBub2RlLCByZWdleHA6IHJlZ2V4cCB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBlbWl0KGFzdCk7XG59O1xuXG5yZXR1cm4gUEVHO1xuXG59KSgpO1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IFBFRztcbn1cbiIsInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgSGFzaCA9IHJlcXVpcmUoJ2hhc2hpc2gnKTtcbnZhciBDaGFpbnNhdyA9IHJlcXVpcmUoJ2NoYWluc2F3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2VxO1xuZnVuY3Rpb24gU2VxICh4cykge1xuICAgIGlmICh4cyAmJiAhQXJyYXkuaXNBcnJheSh4cykgfHwgYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25hbCBhcmd1bWVudCB0byBTZXEoKSBpcyBleGFjdGx5IG9uZSBBcnJheScpO1xuICAgIH1cbiAgICBcbiAgICB2YXIgY2ggPSBDaGFpbnNhdyhmdW5jdGlvbiAoc2F3KSB7XG4gICAgICAgIGJ1aWxkZXIuY2FsbCh0aGlzLCBzYXcsIHhzIHx8IFtdKTtcbiAgICB9KTtcbiAgICBcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2sgPyBlcnIuc3RhY2sgOiBlcnIpXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBjaDtcbn1cblxuU2VxLmFwID0gU2VxOyAvLyBmb3IgY29tcGF0YWJpbGl0eSB3aXRoIHZlcnNpb25zIDwwLjNcblxuZnVuY3Rpb24gYnVpbGRlciAoc2F3LCB4cykge1xuICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICB2YXJzIDoge30sXG4gICAgICAgIGFyZ3MgOiB7fSxcbiAgICAgICAgc3RhY2sgOiB4cyxcbiAgICAgICAgZXJyb3IgOiBudWxsXG4gICAgfTtcbiAgICBjb250ZXh0LnN0YWNrXyA9IGNvbnRleHQuc3RhY2s7XG4gICAgXG4gICAgZnVuY3Rpb24gYWN0aW9uIChzdGVwLCBrZXksIGYsIGcpIHtcbiAgICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5lcnJvciA9IHsgbWVzc2FnZSA6IGVyciwga2V5IDoga2V5IH07XG4gICAgICAgICAgICAgICAgc2F3Lmp1bXAobGFzdFBhcik7XG4gICAgICAgICAgICAgICAgc2F3LmRvd24oJ2NhdGNoJyk7XG4gICAgICAgICAgICAgICAgZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdGFja19ba2V5XSA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYXJnc1trZXldID0gYXJncztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhY2tfLnB1c2guYXBwbHkoY29udGV4dC5zdGFja18sIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQudmFyc1trZXldID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYXJnc1trZXldID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZykgZyhhcmdzLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBIYXNoKGNvbnRleHQpLmZvckVhY2goZnVuY3Rpb24gKHYsaykgeyBjYltrXSA9IHYgfSk7XG4gICAgICAgIFxuICAgICAgICBjYi5pbnRvID0gZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGtleSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gY2I7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBjYi5uZXh0ID0gZnVuY3Rpb24gKGVyciwgeHMpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3RhY2tfLnB1c2guYXBwbHkoY29udGV4dC5zdGFja18sIHhzKTtcbiAgICAgICAgICAgIGNiLmFwcGx5KGNiLCBbZXJyXS5jb25jYXQoY29udGV4dC5zdGFjaykpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgY2IucGFzcyA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNiLmFwcGx5KGNiLCBbZXJyXS5jb25jYXQoY29udGV4dC5zdGFjaykpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgY2Iub2sgPSBjYi5iaW5kKGNiLCBudWxsKTtcbiAgICAgICAgXG4gICAgICAgIGYuYXBwbHkoY2IsIGNvbnRleHQuc3RhY2spO1xuICAgIH1cbiAgICBcbiAgICB2YXIgcnVubmluZyA9IDA7XG4gICAgdmFyIGVycm9ycyA9IDA7XG4gICAgXG4gICAgdGhpcy5zZXEgPSBmdW5jdGlvbiAoa2V5LCBjYikge1xuICAgICAgICB2YXIgYm91bmQgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIFxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSBib3VuZC51bnNoaWZ0KGNiKTtcbiAgICAgICAgICAgIGNiID0ga2V5O1xuICAgICAgICAgICAga2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoY29udGV4dC5lcnJvcikgc2F3Lm5leHQoKVxuICAgICAgICBlbHNlIGlmIChydW5uaW5nID09PSAwKSB7XG4gICAgICAgICAgICBhY3Rpb24oc2F3LnN0ZXAsIGtleSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhY2tfID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQuYXBwbHkoYXJncywgYm91bmQubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcgPT09IFNlcSA/IHRoaXMgOiBhcmdcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN0YWNrID0gY29udGV4dC5zdGFja187XG4gICAgICAgICAgICAgICAgICAgIHNhdy5uZXh0KClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICB2YXIgbGFzdFBhciA9IG51bGw7XG4gICAgdGhpcy5wYXIgPSBmdW5jdGlvbiAoa2V5LCBjYikge1xuICAgICAgICBsYXN0UGFyID0gc2F3LnN0ZXA7XG4gICAgICAgIFxuICAgICAgICBpZiAocnVubmluZyA9PSAwKSB7XG4gICAgICAgICAgICAvLyBlbXB0eSB0aGUgYWN0aXZlIHN0YWNrIGZvciB0aGUgZmlyc3QgcGFyKCkgaW4gYSBjaGFpblxuICAgICAgICAgICAgY29udGV4dC5zdGFja18gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGJvdW5kID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSBib3VuZC51bnNoaWZ0KGNiKTtcbiAgICAgICAgICAgIGNiID0ga2V5O1xuICAgICAgICAgICAga2V5ID0gY29udGV4dC5zdGFja18ubGVuZ3RoO1xuICAgICAgICAgICAgY29udGV4dC5zdGFja18ucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2JfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQuYXBwbHkoYXJncywgYm91bmQubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnID09PSBTZXEgPyB0aGlzIDogYXJnXG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgcnVubmluZyArKztcbiAgICAgICAgXG4gICAgICAgIHZhciBzdGVwID0gc2F3LnN0ZXA7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWN0aW9uKHN0ZXAsIGtleSwgY2JfLCBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgIGlmICghYXJncykgZXJyb3JzICsrO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJ1bm5pbmcgLS07XG4gICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmcgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN0YWNrID0gY29udGV4dC5zdGFja18uc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgc2F3LnN0ZXAgPSBsYXN0UGFyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JzID4gMCkgc2F3LmRvd24oJ2NhdGNoJyk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHNhdy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzYXcubmV4dCgpO1xuICAgIH07XG4gICAgXG4gICAgWyAnc2VxJywgJ3BhcicgXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHRoaXNbbmFtZSArICdfJ10gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGNiID0gdHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgID8gYXJnc1swXSA6IGFyZ3NbMV07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJndiA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBhcmd2LnVuc2hpZnQodGhpcyk7XG4gICAgICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGFyZ3NbMF0gPSBmbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZ3NbMV0gPSBmbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpc1tuYW1lXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzWydjYXRjaCddID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIGlmIChjb250ZXh0LmVycm9yKSB7XG4gICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGNvbnRleHQuZXJyb3IubWVzc2FnZSwgY29udGV4dC5lcnJvci5rZXkpO1xuICAgICAgICAgICAgY29udGV4dC5lcnJvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc2F3Lm5leHQoKTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICB0aGlzLnNlcShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0YWNrXyA9IGNvbnRleHQuc3RhY2suc2xpY2UoKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBjb250ZXh0LnN0YWNrLmxlbmd0aDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGVuZCA9PT0gMCkgdGhpcyhudWxsKVxuICAgICAgICAgICAgZWxzZSBjb250ZXh0LnN0YWNrLmZvckVhY2goZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24oc2F3LnN0ZXAsIGksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbCh0aGlzLCB4LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gZW5kIC0gMSkgc2F3Lm5leHQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuc2VxRWFjaCA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICB0aGlzLnNlcShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0YWNrXyA9IGNvbnRleHQuc3RhY2suc2xpY2UoKTtcbiAgICAgICAgICAgIHZhciB4cyA9IGNvbnRleHQuc3RhY2suc2xpY2UoKTtcbiAgICAgICAgICAgIGlmICh4cy5sZW5ndGggPT09IDApIHRoaXMobnVsbCk7XG4gICAgICAgICAgICBlbHNlIChmdW5jdGlvbiBuZXh0IChpKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICBzYXcuc3RlcCwgaSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBjYi5jYWxsKHRoaXMsIHhzW2ldLCBpKSB9LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmdzIHx8IGkgPT09IHhzLmxlbmd0aCAtIDEpIHNhdy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIG5leHQoaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pLmJpbmQodGhpcykoMCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5wYXJFYWNoID0gZnVuY3Rpb24gKGxpbWl0LCBjYikge1xuICAgICAgICB2YXIgeHMgPSBjb250ZXh0LnN0YWNrLnNsaWNlKCk7XG4gICAgICAgIGlmIChjYiA9PT0gdW5kZWZpbmVkKSB7IGNiID0gbGltaXQ7IGxpbWl0ID0geHMubGVuZ3RoIH1cbiAgICAgICAgY29udGV4dC5zdGFja18gPSBbXTtcbiAgICAgICAgXG4gICAgICAgIHZhciBhY3RpdmUgPSAwO1xuICAgICAgICB2YXIgZmluaXNoZWQgPSAwO1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgXG4gICAgICAgIGlmICh4cy5sZW5ndGggPT09IDApIHNhdy5uZXh0KClcbiAgICAgICAgZWxzZSB4cy5mb3JFYWNoKGZ1bmN0aW9uIGNhbGwgKHgsIGkpIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmUgPj0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGNhbGwuYmluZCh0aGlzLCB4LCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3RpdmUgKys7XG4gICAgICAgICAgICAgICAgYWN0aW9uKHNhdy5zdGVwLCBpLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKHRoaXMsIHgsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmUgLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZCArKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSBxdWV1ZS5zaGlmdCgpKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaW5pc2hlZCA9PT0geHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2F3Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5wYXJNYXAgPSBmdW5jdGlvbiAobGltaXQsIGNiKSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgdmFyIGxlbiA9IGNvbnRleHQuc3RhY2subGVuZ3RoO1xuICAgICAgICBpZiAoY2IgPT09IHVuZGVmaW5lZCkgeyBjYiA9IGxpbWl0OyBsaW1pdCA9IGxlbiB9XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgXG4gICAgICAgIFNlcSgpXG4gICAgICAgICAgICAuZXh0ZW5kKGNvbnRleHQuc3RhY2spXG4gICAgICAgICAgICAucGFyRWFjaChsaW1pdCwgZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tpXSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbmV4dC5zdGFjayA9IHNlbGYuc3RhY2s7XG4gICAgICAgICAgICAgICAgbmV4dC5zdGFja18gPSBzZWxmLnN0YWNrXztcbiAgICAgICAgICAgICAgICBuZXh0LnZhcnMgPSBzZWxmLnZhcnM7XG4gICAgICAgICAgICAgICAgbmV4dC5hcmdzID0gc2VsZi5hcmdzO1xuICAgICAgICAgICAgICAgIG5leHQuZXJyb3IgPSBzZWxmLmVycm9yO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIG5leHQuaW50byA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbmV4dC5vayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MudW5zaGlmdChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQuYXBwbHkobmV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjYi5hcHBseShuZXh0LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zZXEoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhY2sgPSByZXM7XG4gICAgICAgICAgICAgICAgc2F3Lm5leHQoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIDtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuc2VxTWFwID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgdmFyIGxhc3RJZHggPSBjb250ZXh0LnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnNlcUVhY2goZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzW2ldID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBsYXN0SWR4KVxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN0YWNrID0gcmVzO1xuICAgICAgICAgICAgICAgIHNlbGYuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG5leHQuc3RhY2sgPSBzZWxmLnN0YWNrO1xuICAgICAgICAgICAgbmV4dC5zdGFja18gPSBzZWxmLnN0YWNrXztcbiAgICAgICAgICAgIG5leHQudmFycyA9IHNlbGYudmFycztcbiAgICAgICAgICAgIG5leHQuYXJncyA9IHNlbGYuYXJncztcbiAgICAgICAgICAgIG5leHQuZXJyb3IgPSBzZWxmLmVycm9yO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBuZXh0LmludG8gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBsYXN0SWR4KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdGFjayA9IHJlcztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBuZXh0Lm9rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGFyZ3MudW5zaGlmdChudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dC5hcHBseShuZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNiLmFwcGx5KG5leHQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogQ29uc3VtZXMgYW55IGVycm9ycyB0aGF0IG9jY3VyIGluIGBjYmAuIENhbGxzIHRvIGB0aGlzLmludG8oaSlgIHdpbGwgcGxhY2VcbiAgICAgKiB0aGF0IHZhbHVlLCBpZiBhY2NlcHRlZCBieSB0aGUgZmlsdGVyLCBhdCB0aGUgaW5kZXggaW4gdGhlIHJlc3VsdHMgYXNcbiAgICAgKiBpZiBpdCB3ZXJlIHRoZSBpLXRoIGluZGV4IGJlZm9yZSBmaWx0ZXJpbmcuIChUaGlzIG1lYW5zIGl0IHdpbGwgbmV2ZXIgXG4gICAgICogb3ZlcnJpZGUgYW5vdGhlciB2YWx1ZSwgYW5kIHdpbGwgb25seSBhY3R1YWxseSBhcHBlYXIgYXQgaSBpZiB0aGUgZmlsdGVyXG4gICAgICogYWNjZXB0cyBhbGwgdmFsdWVzIGJlZm9yZSBpLilcbiAgICAgKi9cbiAgICB0aGlzLnBhckZpbHRlciA9IGZ1bmN0aW9uIChsaW1pdCwgY2IpIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICB2YXIgbGVuID0gY29udGV4dC5zdGFjay5sZW5ndGg7XG4gICAgICAgIGlmIChjYiA9PT0gdW5kZWZpbmVkKSB7IGNiID0gbGltaXQ7IGxpbWl0ID0gbGVuIH1cbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICBcbiAgICAgICAgU2VxKClcbiAgICAgICAgICAgIC5leHRlbmQoY29udGV4dC5zdGFjaylcbiAgICAgICAgICAgIC5wYXJFYWNoKGxpbWl0LCBmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIChlcnIsIG9rKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyICYmIG9rKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goW2ksIHhdKTtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzWzBdID0gbnVsbDsgLy8gZGlzY2FyZCBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbmV4dC5zdGFjayA9IHNlbGYuc3RhY2s7XG4gICAgICAgICAgICAgICAgbmV4dC5zdGFja18gPSBzZWxmLnN0YWNrXztcbiAgICAgICAgICAgICAgICBuZXh0LnZhcnMgPSBzZWxmLnZhcnM7XG4gICAgICAgICAgICAgICAgbmV4dC5hcmdzID0gc2VsZi5hcmdzO1xuICAgICAgICAgICAgICAgIG5leHQuZXJyb3IgPSBzZWxmLmVycm9yO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIG5leHQuaW50byA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIsIG9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVyciAmJiBvaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChba2V5LCB4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNbMF0gPSBudWxsOyAvLyBkaXNjYXJkIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbmV4dC5vayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MudW5zaGlmdChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQuYXBwbHkobmV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjYi5hcHBseShuZXh0LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zZXEoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhY2sgPSByZXMuc29ydCgpLm1hcChmdW5jdGlvbihwYWlyKXsgcmV0dXJuIHBhaXJbMV07IH0pO1xuICAgICAgICAgICAgICAgIHNhdy5uZXh0KCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICA7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBDb25zdW1lcyBhbnkgZXJyb3JzIHRoYXQgb2NjdXIgaW4gYGNiYC4gQ2FsbHMgdG8gYHRoaXMuaW50byhpKWAgd2lsbCBwbGFjZVxuICAgICAqIHRoYXQgdmFsdWUsIGlmIGFjY2VwdGVkIGJ5IHRoZSBmaWx0ZXIsIGF0IHRoZSBpbmRleCBpbiB0aGUgcmVzdWx0cyBhc1xuICAgICAqIGlmIGl0IHdlcmUgdGhlIGktdGggaW5kZXggYmVmb3JlIGZpbHRlcmluZy4gKFRoaXMgbWVhbnMgaXQgd2lsbCBuZXZlciBcbiAgICAgKiBvdmVycmlkZSBhbm90aGVyIHZhbHVlLCBhbmQgd2lsbCBvbmx5IGFjdHVhbGx5IGFwcGVhciBhdCBpIGlmIHRoZSBmaWx0ZXJcbiAgICAgKiBhY2NlcHRzIGFsbCB2YWx1ZXMgYmVmb3JlIGkuKVxuICAgICAqL1xuICAgIHRoaXMuc2VxRmlsdGVyID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgdmFyIGxhc3RJZHggPSBjb250ZXh0LnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnNlcUVhY2goZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbiAoZXJyLCBvaykge1xuICAgICAgICAgICAgICAgIGlmICghZXJyICYmIG9rKVxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChbaSwgeF0pO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBsYXN0SWR4KVxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN0YWNrID0gcmVzLnNvcnQoKS5tYXAoZnVuY3Rpb24ocGFpcil7IHJldHVybiBwYWlyWzFdOyB9KTtcbiAgICAgICAgICAgICAgICBhcmd1bWVudHNbMF0gPSBudWxsOyAvLyBkaXNjYXJkIGVycm9yc1xuICAgICAgICAgICAgICAgIHNlbGYuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG5leHQuc3RhY2sgPSBzZWxmLnN0YWNrO1xuICAgICAgICAgICAgbmV4dC5zdGFja18gPSBzZWxmLnN0YWNrXztcbiAgICAgICAgICAgIG5leHQudmFycyA9IHNlbGYudmFycztcbiAgICAgICAgICAgIG5leHQuYXJncyA9IHNlbGYuYXJncztcbiAgICAgICAgICAgIG5leHQuZXJyb3IgPSBzZWxmLmVycm9yO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBuZXh0LmludG8gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIsIG9rKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyICYmIG9rKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goW2tleSwgeF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbGFzdElkeClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhY2sgPSByZXMuc29ydCgpLm1hcChmdW5jdGlvbihwYWlyKXsgcmV0dXJuIHBhaXJbMV07IH0pO1xuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNbMF0gPSBudWxsOyAvLyBkaXNjYXJkIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG5leHQub2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgYXJncy51bnNoaWZ0KG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0LmFwcGx5KG5leHQsIGFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2IuYXBwbHkobmV4dCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBcbiAgICBbICdmb3JFYWNoJywgJ3NlcUVhY2gnLCAncGFyRWFjaCcsICdzZXFNYXAnLCAncGFyTWFwJywgJ3NlcUZpbHRlcicsICdwYXJGaWx0ZXInIF1cbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZSArICdfJ10gPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICB0aGlzW25hbWVdLmNhbGwodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMpXG4gICAgO1xuICAgIFxuICAgIFsncHVzaCcsJ3BvcCcsJ3NoaWZ0JywndW5zaGlmdCcsJ3NwbGljZScsJ3JldmVyc2UnXVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0YWNrW25hbWVdLmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHNhdy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzKVxuICAgIDtcbiAgICBcbiAgICBbICdtYXAnLCAnZmlsdGVyJywgJ3JlZHVjZScgXVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gY29udGV4dC5zdGFja1tuYW1lXS5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAvLyBzdGFjayBtdXN0IGJlIGFuIGFycmF5LCBvciBiYWQgdGhpbmdzIGhhcHBlblxuICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhY2sgPSAoQXJyYXkuaXNBcnJheShyZXMpID8gcmVzIDogW3Jlc10pO1xuICAgICAgICAgICAgICAgIHNhdy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzKVxuICAgIDtcbiAgICBcbiAgICB0aGlzLmV4dGVuZCA9IGZ1bmN0aW9uICh4cykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoeHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FyZ3VtZW50IHRvIC5leHRlbmQoKSBpcyBub3QgYW4gQXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnN0YWNrLnB1c2guYXBwbHkoY29udGV4dC5zdGFjaywgeHMpO1xuICAgICAgICBzYXcubmV4dCgpO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5mbGF0dGVuID0gZnVuY3Rpb24gKHBhbmNha2UpIHtcbiAgICAgICAgdmFyIHhzID0gW107XG4gICAgICAgIC8vIHNob3VsZCB3ZSBmdWxseSBmbGF0dGVuIHRoaXMgYXJyYXk/IChkZWZhdWx0OiB0cnVlKVxuICAgICAgICBpZiAocGFuY2FrZSA9PT0gdW5kZWZpbmVkKSB7IHBhbmNha2UgPSB0cnVlOyB9XG4gICAgICAgIGNvbnRleHQuc3RhY2suZm9yRWFjaChmdW5jdGlvbiBmICh4KSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh4KSAmJiBwYW5jYWtlKSB4LmZvckVhY2goZik7XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHgpKSB4cyA9IHhzLmNvbmNhdCh4KTtcbiAgICAgICAgICAgIGVsc2UgeHMucHVzaCh4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRleHQuc3RhY2sgPSB4cztcbiAgICAgICAgc2F3Lm5leHQoKTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMudW5mbGF0dGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZXh0LnN0YWNrID0gW2NvbnRleHQuc3RhY2tdO1xuICAgICAgICBzYXcubmV4dCgpO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGV4dC5zdGFjayA9IFtdO1xuICAgICAgICBzYXcubmV4dCgpO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5zZXQgPSBmdW5jdGlvbiAoc3RhY2spIHtcbiAgICAgICAgY29udGV4dC5zdGFjayA9IHN0YWNrO1xuICAgICAgICBzYXcubmV4dCgpO1xuICAgIH07XG4gICAgXG4gICAgdGhpc1snZG8nXSA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICBzYXcubmVzdChjYiwgY29udGV4dCk7XG4gICAgfTtcbn1cbiIsInZhciBUcmF2ZXJzZSA9IHJlcXVpcmUoJ3RyYXZlcnNlJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYWluc2F3O1xuZnVuY3Rpb24gQ2hhaW5zYXcgKGJ1aWxkZXIpIHtcbiAgICB2YXIgc2F3ID0gQ2hhaW5zYXcuc2F3KGJ1aWxkZXIsIHt9KTtcbiAgICB2YXIgciA9IGJ1aWxkZXIuY2FsbChzYXcuaGFuZGxlcnMsIHNhdyk7XG4gICAgaWYgKHIgIT09IHVuZGVmaW5lZCkgc2F3LmhhbmRsZXJzID0gcjtcbiAgICByZXR1cm4gc2F3LmNoYWluKCk7XG59O1xuXG5DaGFpbnNhdy5zYXcgPSBmdW5jdGlvbiAoYnVpbGRlciwgaGFuZGxlcnMpIHtcbiAgICB2YXIgc2F3ID0gbmV3IEV2ZW50RW1pdHRlcjtcbiAgICBzYXcuaGFuZGxlcnMgPSBoYW5kbGVycztcbiAgICBzYXcuYWN0aW9ucyA9IFtdO1xuICAgIHNhdy5zdGVwID0gMDtcbiAgICBcbiAgICBzYXcuY2hhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaCA9IFRyYXZlcnNlKHNhdy5oYW5kbGVycykubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1Jvb3QpIHJldHVybiBub2RlO1xuICAgICAgICAgICAgdmFyIHBzID0gdGhpcy5wYXRoO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhdy5hY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA6IHBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA6IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2F3LmVtaXQoJ2JlZ2luJyk7XG4gICAgICAgICAgICBzYXcubmV4dCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBjaDtcbiAgICB9O1xuICAgIFxuICAgIHNhdy5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWN0aW9uID0gc2F3LmFjdGlvbnNbc2F3LnN0ZXBdO1xuICAgICAgICBzYXcuc3RlcCArKztcbiAgICAgICAgXG4gICAgICAgIGlmICghYWN0aW9uKSB7XG4gICAgICAgICAgICBzYXcuZW1pdCgnZW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWFjdGlvbi50cmFwKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHNhdy5oYW5kbGVycztcbiAgICAgICAgICAgIGFjdGlvbi5wYXRoLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBub2RlID0gbm9kZVtrZXldIH0pO1xuICAgICAgICAgICAgbm9kZS5hcHBseShzYXcuaGFuZGxlcnMsIGFjdGlvbi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgc2F3Lm5lc3QgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHZhciBhdXRvbmV4dCA9IHRydWU7XG4gICAgICAgIFxuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHZhciBhdXRvbmV4dCA9IGNiO1xuICAgICAgICAgICAgY2IgPSBhcmdzLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBzID0gQ2hhaW5zYXcuc2F3KGJ1aWxkZXIsIHt9KTtcbiAgICAgICAgdmFyIHIgPSBidWlsZGVyLmNhbGwocy5oYW5kbGVycywgcyk7XG4gICAgICAgIFxuICAgICAgICBpZiAociAhPT0gdW5kZWZpbmVkKSBzLmhhbmRsZXJzID0gcjtcbiAgICAgICAgY2IuYXBwbHkocy5jaGFpbigpLCBhcmdzKTtcbiAgICAgICAgaWYgKGF1dG9uZXh0ICE9PSBmYWxzZSkgcy5vbignZW5kJywgc2F3Lm5leHQpO1xuICAgIH07XG4gICAgXG4gICAgc2F3LnRyYXAgPSBmdW5jdGlvbiAobmFtZSwgY2IpIHtcbiAgICAgICAgdmFyIHBzID0gQXJyYXkuaXNBcnJheShuYW1lKSA/IG5hbWUgOiBbbmFtZV07XG4gICAgICAgIHNhdy5hY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgcGF0aCA6IHBzLFxuICAgICAgICAgICAgc3RlcCA6IHNhdy5zdGVwLFxuICAgICAgICAgICAgY2IgOiBjYixcbiAgICAgICAgICAgIHRyYXAgOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgc2F3LmRvd24gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgcHMgPSAoQXJyYXkuaXNBcnJheShuYW1lKSA/IG5hbWUgOiBbbmFtZV0pLmpvaW4oJy8nKTtcbiAgICAgICAgdmFyIGkgPSBzYXcuYWN0aW9ucy5zbGljZShzYXcuc3RlcCkubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICBpZiAoeC50cmFwICYmIHguc3RlcCA8PSBzYXcuc3RlcCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHgucGF0aC5qb2luKCcvJykgPT0gcHM7XG4gICAgICAgIH0pLmluZGV4T2YodHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoaSA+PSAwKSBzYXcuc3RlcCArPSBpO1xuICAgICAgICBlbHNlIHNhdy5zdGVwID0gc2F3LmFjdGlvbnMubGVuZ3RoO1xuICAgICAgICBcbiAgICAgICAgdmFyIGFjdCA9IHNhdy5hY3Rpb25zW3Nhdy5zdGVwIC0gMV07XG4gICAgICAgIGlmIChhY3QgJiYgYWN0LnRyYXApIHtcbiAgICAgICAgICAgIC8vIEl0J3MgYSB0cmFwIVxuICAgICAgICAgICAgc2F3LnN0ZXAgPSBhY3Quc3RlcDtcbiAgICAgICAgICAgIGFjdC5jYigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Ugc2F3Lm5leHQoKTtcbiAgICB9O1xuICAgIFxuICAgIHNhdy5qdW1wID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgc2F3LnN0ZXAgPSBzdGVwO1xuICAgICAgICBzYXcubmV4dCgpO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHNhdztcbn07IFxuIiwibW9kdWxlLmV4cG9ydHMgPSBUcmF2ZXJzZTtcbmZ1bmN0aW9uIFRyYXZlcnNlIChvYmopIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhdmVyc2UpKSByZXR1cm4gbmV3IFRyYXZlcnNlKG9iaik7XG4gICAgdGhpcy52YWx1ZSA9IG9iajtcbn1cblxuVHJhdmVyc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwcykge1xuICAgIHZhciBub2RlID0gdGhpcy52YWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aDsgaSArKykge1xuICAgICAgICB2YXIga2V5ID0gcHNbaV07XG4gICAgICAgIGlmICghT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobm9kZSwga2V5KSkge1xuICAgICAgICAgICAgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlW2tleV07XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChwcywgdmFsdWUpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMudmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcy5sZW5ndGggLSAxOyBpICsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBwc1tpXTtcbiAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCBrZXkpKSBub2RlW2tleV0gPSB7fTtcbiAgICAgICAgbm9kZSA9IG5vZGVba2V5XTtcbiAgICB9XG4gICAgbm9kZVtwc1tpXV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgcmV0dXJuIHdhbGsodGhpcy52YWx1ZSwgY2IsIHRydWUpO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2IpIHtcbiAgICB0aGlzLnZhbHVlID0gd2Fsayh0aGlzLnZhbHVlLCBjYiwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChjYiwgaW5pdCkge1xuICAgIHZhciBza2lwID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMTtcbiAgICB2YXIgYWNjID0gc2tpcCA/IHRoaXMudmFsdWUgOiBpbml0O1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSb290IHx8ICFza2lwKSB7XG4gICAgICAgICAgICBhY2MgPSBjYi5jYWxsKHRoaXMsIGFjYywgeCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYWNjO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLmRlZXBFcXVhbCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnZGVlcEVxdWFsIHJlcXVpcmVzIGV4YWN0bHkgb25lIG9iamVjdCB0byBjb21wYXJlIGFnYWluc3QnXG4gICAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIHZhciBlcXVhbCA9IHRydWU7XG4gICAgdmFyIG5vZGUgPSBvYmo7XG4gICAgXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh5KSB7XG4gICAgICAgIHZhciBub3RFcXVhbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlcXVhbCA9IGZhbHNlO1xuICAgICAgICAgICAgLy90aGlzLnN0b3AoKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0pLmJpbmQodGhpcyk7XG4gICAgICAgIFxuICAgICAgICAvL2lmIChub2RlID09PSB1bmRlZmluZWQgfHwgbm9kZSA9PT0gbnVsbCkgcmV0dXJuIG5vdEVxdWFsKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXRoaXMuaXNSb290KSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgICBpZiAoIU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGUsIHRoaXMua2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3RFcXVhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JykgcmV0dXJuIG5vdEVxdWFsKCk7XG4gICAgICAgICAgICBub2RlID0gbm9kZVt0aGlzLmtleV07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciB4ID0gbm9kZTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMucG9zdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBub2RlID0geDtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB2YXIgdG9TID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy5jaXJjdWxhcikge1xuICAgICAgICAgICAgaWYgKFRyYXZlcnNlKG9iaikuZ2V0KHRoaXMuY2lyY3VsYXIucGF0aCkgIT09IHgpIG5vdEVxdWFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHggIT09IHR5cGVvZiB5KSB7XG4gICAgICAgICAgICBub3RFcXVhbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHggPT09IG51bGwgfHwgeSA9PT0gbnVsbCB8fCB4ID09PSB1bmRlZmluZWQgfHwgeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoeCAhPT0geSkgbm90RXF1YWwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4Ll9fcHJvdG9fXyAhPT0geS5fX3Byb3RvX18pIHtcbiAgICAgICAgICAgIG5vdEVxdWFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeCA9PT0geSkge1xuICAgICAgICAgICAgLy8gbm9wXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh4IGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgLy8gYm90aCByZWdleHBzIG9uIGFjY291bnQgb2YgdGhlIF9fcHJvdG9fXyBjaGVja1xuICAgICAgICAgICAgICAgIGlmICh4LnRvU3RyaW5nKCkgIT0geS50b1N0cmluZygpKSBub3RFcXVhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoeCAhPT0geSkgbm90RXF1YWwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICh0b1MoeSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nXG4gICAgICAgICAgICB8fCB0b1MoeCkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvUyh4KSAhPT0gdG9TKHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdEVxdWFsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoeCBpbnN0YW5jZW9mIERhdGUgfHwgeSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoISh4IGluc3RhbmNlb2YgRGF0ZSkgfHwgISh5IGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgICAgICAgICB8fCB4LmdldFRpbWUoKSAhPT0geS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm90RXF1YWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIga3ggPSBPYmplY3Qua2V5cyh4KTtcbiAgICAgICAgICAgICAgICB2YXIga3kgPSBPYmplY3Qua2V5cyh5KTtcbiAgICAgICAgICAgICAgICBpZiAoa3gubGVuZ3RoICE9PSBreS5sZW5ndGgpIHJldHVybiBub3RFcXVhbCgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga3gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSBreFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh5LCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90RXF1YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBlcXVhbDtcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5wYXRocyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWNjID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGFjYy5wdXNoKHRoaXMucGF0aCk7IFxuICAgIH0pO1xuICAgIHJldHVybiBhY2M7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUubm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFjYyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBhY2MucHVzaCh0aGlzLm5vZGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2M7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudHMgPSBbXSwgbm9kZXMgPSBbXTtcbiAgICBcbiAgICByZXR1cm4gKGZ1bmN0aW9uIGNsb25lIChzcmMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50c1tpXSA9PT0gc3JjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ29iamVjdCcgJiYgc3JjICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZHN0ID0gY29weShzcmMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYXJlbnRzLnB1c2goc3JjKTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goZHN0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkc3Rba2V5XSA9IGNsb25lKHNyY1trZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYXJlbnRzLnBvcCgpO1xuICAgICAgICAgICAgbm9kZXMucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gZHN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNyYztcbiAgICAgICAgfVxuICAgIH0pKHRoaXMudmFsdWUpO1xufTtcblxuZnVuY3Rpb24gd2FsayAocm9vdCwgY2IsIGltbXV0YWJsZSkge1xuICAgIHZhciBwYXRoID0gW107XG4gICAgdmFyIHBhcmVudHMgPSBbXTtcbiAgICB2YXIgYWxpdmUgPSB0cnVlO1xuICAgIFxuICAgIHJldHVybiAoZnVuY3Rpb24gd2Fsa2VyIChub2RlXykge1xuICAgICAgICB2YXIgbm9kZSA9IGltbXV0YWJsZSA/IGNvcHkobm9kZV8pIDogbm9kZV87XG4gICAgICAgIHZhciBtb2RpZmllcnMgPSB7fTtcbiAgICAgICAgXG4gICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICAgIG5vZGUgOiBub2RlLFxuICAgICAgICAgICAgbm9kZV8gOiBub2RlXyxcbiAgICAgICAgICAgIHBhdGggOiBbXS5jb25jYXQocGF0aCksXG4gICAgICAgICAgICBwYXJlbnQgOiBwYXJlbnRzLnNsaWNlKC0xKVswXSxcbiAgICAgICAgICAgIGtleSA6IHBhdGguc2xpY2UoLTEpWzBdLFxuICAgICAgICAgICAgaXNSb290IDogcGF0aC5sZW5ndGggPT09IDAsXG4gICAgICAgICAgICBsZXZlbCA6IHBhdGgubGVuZ3RoLFxuICAgICAgICAgICAgY2lyY3VsYXIgOiBudWxsLFxuICAgICAgICAgICAgdXBkYXRlIDogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmlzUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wYXJlbnQubm9kZVtzdGF0ZS5rZXldID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUubm9kZSA9IHg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2RlbGV0ZScgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLnBhcmVudC5ub2RlW3N0YXRlLmtleV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0YXRlLnBhcmVudC5ub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wYXJlbnQubm9kZS5zcGxpY2Uoc3RhdGUua2V5LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5wYXJlbnQubm9kZVtzdGF0ZS5rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiZWZvcmUgOiBmdW5jdGlvbiAoZikgeyBtb2RpZmllcnMuYmVmb3JlID0gZiB9LFxuICAgICAgICAgICAgYWZ0ZXIgOiBmdW5jdGlvbiAoZikgeyBtb2RpZmllcnMuYWZ0ZXIgPSBmIH0sXG4gICAgICAgICAgICBwcmUgOiBmdW5jdGlvbiAoZikgeyBtb2RpZmllcnMucHJlID0gZiB9LFxuICAgICAgICAgICAgcG9zdCA6IGZ1bmN0aW9uIChmKSB7IG1vZGlmaWVycy5wb3N0ID0gZiB9LFxuICAgICAgICAgICAgc3RvcCA6IGZ1bmN0aW9uICgpIHsgYWxpdmUgPSBmYWxzZSB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBpZiAoIWFsaXZlKSByZXR1cm4gc3RhdGU7XG4gICAgICAgIFxuICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlLmlzTGVhZiA9IE9iamVjdC5rZXlzKG5vZGUpLmxlbmd0aCA9PSAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50c1tpXS5ub2RlXyA9PT0gbm9kZV8pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2lyY3VsYXIgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5pc0xlYWYgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzdGF0ZS5ub3RMZWFmID0gIXN0YXRlLmlzTGVhZjtcbiAgICAgICAgc3RhdGUubm90Um9vdCA9ICFzdGF0ZS5pc1Jvb3Q7XG4gICAgICAgIFxuICAgICAgICAvLyB1c2UgcmV0dXJuIHZhbHVlcyB0byB1cGRhdGUgaWYgZGVmaW5lZFxuICAgICAgICB2YXIgcmV0ID0gY2IuY2FsbChzdGF0ZSwgc3RhdGUubm9kZSk7XG4gICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZS51cGRhdGUpIHN0YXRlLnVwZGF0ZShyZXQpO1xuICAgICAgICBpZiAobW9kaWZpZXJzLmJlZm9yZSkgbW9kaWZpZXJzLmJlZm9yZS5jYWxsKHN0YXRlLCBzdGF0ZS5ub2RlKTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUubm9kZSA9PSAnb2JqZWN0J1xuICAgICAgICAmJiBzdGF0ZS5ub2RlICE9PSBudWxsICYmICFzdGF0ZS5jaXJjdWxhcikge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzdGF0ZS5ub2RlKTtcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBpKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5wcmUpIG1vZGlmaWVycy5wcmUuY2FsbChzdGF0ZSwgc3RhdGUubm9kZVtrZXldLCBrZXkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHdhbGtlcihzdGF0ZS5ub2RlW2tleV0pO1xuICAgICAgICAgICAgICAgIGlmIChpbW11dGFibGUgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoc3RhdGUubm9kZSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5ub2RlW2tleV0gPSBjaGlsZC5ub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjaGlsZC5pc0xhc3QgPSBpID09IGtleXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBjaGlsZC5pc0ZpcnN0ID0gaSA9PSAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChtb2RpZmllcnMucG9zdCkgbW9kaWZpZXJzLnBvc3QuY2FsbChzdGF0ZSwgY2hpbGQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHBhdGgucG9wKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhcmVudHMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChtb2RpZmllcnMuYWZ0ZXIpIG1vZGlmaWVycy5hZnRlci5jYWxsKHN0YXRlLCBzdGF0ZS5ub2RlKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9KShyb290KS5ub2RlO1xufVxuXG5PYmplY3Qua2V5cyhUcmF2ZXJzZS5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIFRyYXZlcnNlW2tleV0gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICB2YXIgdCA9IFRyYXZlcnNlKG9iaik7XG4gICAgICAgIHJldHVybiB0W2tleV0uYXBwbHkodCwgYXJncyk7XG4gICAgfTtcbn0pO1xuXG5mdW5jdGlvbiBjb3B5IChzcmMpIHtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ29iamVjdCcgJiYgc3JjICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBkc3Q7XG4gICAgICAgIFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzcmMpKSB7XG4gICAgICAgICAgICBkc3QgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgRGF0ZShzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgICAgICAgIGRzdCA9IG5ldyBCb29sZWFuKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgTnVtYmVyKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgU3RyaW5nKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkc3QgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihzcmMpKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGRzdFtrZXldID0gc3JjW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZHN0O1xuICAgIH1cbiAgICBlbHNlIHJldHVybiBzcmM7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG52YXIgVHJhdmVyc2UgPSByZXF1aXJlKCd0cmF2ZXJzZScpO1xuXG5mdW5jdGlvbiBIYXNoIChoYXNoLCB4cykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhc2gpICYmIEFycmF5LmlzQXJyYXkoeHMpKSB7XG4gICAgICAgIHZhciB0byA9IE1hdGgubWluKGhhc2gubGVuZ3RoLCB4cy5sZW5ndGgpO1xuICAgICAgICB2YXIgYWNjID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgYWNjW2hhc2hbaV1dID0geHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhhc2goYWNjKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGhhc2ggPT09IHVuZGVmaW5lZCkgcmV0dXJuIEhhc2goe30pO1xuICAgIFxuICAgIHZhciBzZWxmID0ge1xuICAgICAgICBtYXAgOiBmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgdmFyIGFjYyA9IHsgX19wcm90b19fIDogaGFzaC5fX3Byb3RvX18gfTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGhhc2gpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gZi5jYWxsKHNlbGYsIGhhc2hba2V5XSwga2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIEhhc2goYWNjKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9yRWFjaCA6IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhoYXNoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBmLmNhbGwoc2VsZiwgaGFzaFtrZXldLCBrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfSxcbiAgICAgICAgZmlsdGVyIDogZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIHZhciBhY2MgPSB7IF9fcHJvdG9fXyA6IGhhc2guX19wcm90b19fIH07XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhoYXNoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZi5jYWxsKHNlbGYsIGhhc2hba2V5XSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBIYXNoKGFjYyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRldGVjdCA6IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gaGFzaCkge1xuICAgICAgICAgICAgICAgIGlmIChmLmNhbGwoc2VsZiwgaGFzaFtrZXldLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNoW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVkdWNlIDogZnVuY3Rpb24gKGYsIGFjYykge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhoYXNoKTtcbiAgICAgICAgICAgIGlmIChhY2MgPT09IHVuZGVmaW5lZCkgYWNjID0ga2V5cy5zaGlmdCgpO1xuICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBhY2MgPSBmLmNhbGwoc2VsZiwgYWNjLCBoYXNoW2tleV0sIGtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sXG4gICAgICAgIHNvbWUgOiBmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGhhc2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoZi5jYWxsKHNlbGYsIGhhc2hba2V5XSwga2V5KSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlQWxsKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNoW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVBbGwgOiBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgICAgIHhzLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGUoeCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9LFxuICAgICAgICBtZXJnZSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNvcHkudXBkYXRlQWxsKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jb3B5LnVwZGF0ZShvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtZXJnZUFsbCA6IGZ1bmN0aW9uICh4cykge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29weS51cGRhdGVBbGwoeHMpO1xuICAgICAgICB9LFxuICAgICAgICBoYXMgOiBmdW5jdGlvbiAoa2V5KSB7IC8vIG9ubHkgb3BlcmF0ZXMgb24gZW51bWVyYWJsZXNcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGtleSlcbiAgICAgICAgICAgICAgICA/IGtleS5ldmVyeShmdW5jdGlvbiAoaykgeyByZXR1cm4gc2VsZi5oYXMoaykgfSlcbiAgICAgICAgICAgICAgICA6IHNlbGYua2V5cy5pbmRleE9mKGtleS50b1N0cmluZygpKSA+PSAwO1xuICAgICAgICB9LFxuICAgICAgICB2YWx1ZXNBdCA6IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShrZXlzKVxuICAgICAgICAgICAgICAgID8ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gaGFzaFtrZXldIH0pXG4gICAgICAgICAgICAgICAgOiBoYXNoW2tleXNdXG4gICAgICAgICAgICA7XG4gICAgICAgIH0sXG4gICAgICAgIHRhcCA6IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICBmLmNhbGwoc2VsZiwgaGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfSxcbiAgICAgICAgZXh0cmFjdCA6IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgICB2YXIgYWNjID0ge307XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gaGFzaFtrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSGFzaChhY2MpO1xuICAgICAgICB9LFxuICAgICAgICBleGNsdWRlIDogZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmZpbHRlcihmdW5jdGlvbiAoXywga2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXMuaW5kZXhPZihrZXkpIDwgMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVuZCA6IGhhc2gsXG4gICAgICAgIGl0ZW1zIDogaGFzaFxuICAgIH07XG4gICAgXG4gICAgdmFyIHByb3BzID0ge1xuICAgICAgICBrZXlzIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gT2JqZWN0LmtleXMoaGFzaCkgfSxcbiAgICAgICAgdmFsdWVzIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGhhc2gpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBoYXNoW2tleV0gfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBhY3QgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggIT09IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvbmUgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBIYXNoKEhhc2guY2xvbmUoaGFzaCkpIH0sXG4gICAgICAgIGNvcHkgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBIYXNoKEhhc2guY29weShoYXNoKSkgfSxcbiAgICAgICAgbGVuZ3RoIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gT2JqZWN0LmtleXMoaGFzaCkubGVuZ3RoIH0sXG4gICAgICAgIHNpemUgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLmxlbmd0aCB9XG4gICAgfTtcbiAgICBcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIC8vIGVzNS1zaGltIGhhcyBhbiBPYmplY3QuZGVmaW5lUHJvcGVydHkgYnV0IGl0IHRocm93cyBmb3IgZ2V0dGVyc1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGtleSwgeyBnZXQgOiBwcm9wc1trZXldIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdjbG9uZScgJiYga2V5ICE9PSAnY29weScgJiYga2V5ICE9PSAnY29tcGFjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gXiB0aG9zZSBrZXlzIHVzZSBIYXNoKCkgc28gY2FuJ3QgY2FsbCB0aGVtIHdpdGhvdXRcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBzdGFjayBvdmVyZmxvd1xuICAgICAgICAgICAgICAgICAgICBzZWxmW2tleV0gPSBwcm9wc1trZXldKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbGYuX19kZWZpbmVHZXR0ZXJfXykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIHNlbGYuX19kZWZpbmVHZXR0ZXJfXyhrZXksIHByb3BzW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBub24tbGF6eSB2ZXJzaW9uIGZvciBicm93c2VycyB0aGF0IHN1Y2sgPl88XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgICAgICAgc2VsZltrZXldID0gcHJvcHNba2V5XSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBzZWxmO1xufTtcblxuLy8gZGVlcCBjb3B5XG5IYXNoLmNsb25lID0gZnVuY3Rpb24gKHJlZikge1xuICAgIHJldHVybiBUcmF2ZXJzZS5jbG9uZShyZWYpO1xufTtcblxuLy8gc2hhbGxvdyBjb3B5XG5IYXNoLmNvcHkgPSBmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGhhc2ggPSB7IF9fcHJvdG9fXyA6IHJlZi5fX3Byb3RvX18gfTtcbiAgICBPYmplY3Qua2V5cyhyZWYpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBoYXNoW2tleV0gPSByZWZba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGFzaDtcbn07XG5cbkhhc2gubWFwID0gZnVuY3Rpb24gKHJlZiwgZikge1xuICAgIHJldHVybiBIYXNoKHJlZikubWFwKGYpLml0ZW1zO1xufTtcblxuSGFzaC5mb3JFYWNoID0gZnVuY3Rpb24gKHJlZiwgZikge1xuICAgIEhhc2gocmVmKS5mb3JFYWNoKGYpO1xufTtcblxuSGFzaC5maWx0ZXIgPSBmdW5jdGlvbiAocmVmLCBmKSB7XG4gICAgcmV0dXJuIEhhc2gocmVmKS5maWx0ZXIoZikuaXRlbXM7XG59O1xuXG5IYXNoLmRldGVjdCA9IGZ1bmN0aW9uIChyZWYsIGYpIHtcbiAgICByZXR1cm4gSGFzaChyZWYpLmRldGVjdChmKTtcbn07XG5cbkhhc2gucmVkdWNlID0gZnVuY3Rpb24gKHJlZiwgZiwgYWNjKSB7XG4gICAgcmV0dXJuIEhhc2gocmVmKS5yZWR1Y2UoZiwgYWNjKTtcbn07XG5cbkhhc2guc29tZSA9IGZ1bmN0aW9uIChyZWYsIGYpIHtcbiAgICByZXR1cm4gSGFzaChyZWYpLnNvbWUoZik7XG59O1xuXG5IYXNoLnVwZGF0ZSA9IGZ1bmN0aW9uIChhIC8qLCBiLCBjLCAuLi4gKi8pIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGhhc2ggPSBIYXNoKGEpO1xuICAgIHJldHVybiBoYXNoLnVwZGF0ZS5hcHBseShoYXNoLCBhcmdzKS5pdGVtcztcbn07XG5cbkhhc2gubWVyZ2UgPSBmdW5jdGlvbiAoYSAvKiwgYiwgYywgLi4uICovKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBoYXNoID0gSGFzaChhKTtcbiAgICByZXR1cm4gaGFzaC5tZXJnZS5hcHBseShoYXNoLCBhcmdzKS5pdGVtcztcbn07XG5cbkhhc2guaGFzID0gZnVuY3Rpb24gKHJlZiwga2V5KSB7XG4gICAgcmV0dXJuIEhhc2gocmVmKS5oYXMoa2V5KTtcbn07XG5cbkhhc2gudmFsdWVzQXQgPSBmdW5jdGlvbiAocmVmLCBrZXlzKSB7XG4gICAgcmV0dXJuIEhhc2gocmVmKS52YWx1ZXNBdChrZXlzKTtcbn07XG5cbkhhc2gudGFwID0gZnVuY3Rpb24gKHJlZiwgZikge1xuICAgIHJldHVybiBIYXNoKHJlZikudGFwKGYpLml0ZW1zO1xufTtcblxuSGFzaC5leHRyYWN0ID0gZnVuY3Rpb24gKHJlZiwga2V5cykge1xuICAgIHJldHVybiBIYXNoKHJlZikuZXh0cmFjdChrZXlzKS5pdGVtcztcbn07XG5cbkhhc2guZXhjbHVkZSA9IGZ1bmN0aW9uIChyZWYsIGtleXMpIHtcbiAgICByZXR1cm4gSGFzaChyZWYpLmV4Y2x1ZGUoa2V5cykuaXRlbXM7XG59O1xuXG5IYXNoLmNvbmNhdCA9IGZ1bmN0aW9uICh4cykge1xuICAgIHZhciBoYXNoID0gSGFzaCh7fSk7XG4gICAgeHMuZm9yRWFjaChmdW5jdGlvbiAoeCkgeyBoYXNoLnVwZGF0ZSh4KSB9KTtcbiAgICByZXR1cm4gaGFzaC5pdGVtcztcbn07XG5cbkhhc2guemlwID0gZnVuY3Rpb24gKHhzLCB5cykge1xuICAgIHJldHVybiBIYXNoKHhzLCB5cykuaXRlbXM7XG59O1xuXG4vLyAubGVuZ3RoIGlzIGFscmVhZHkgZGVmaW5lZCBmb3IgZnVuY3Rpb24gcHJvdG90eXBlc1xuSGFzaC5zaXplID0gZnVuY3Rpb24gKHJlZikge1xuICAgIHJldHVybiBIYXNoKHJlZikuc2l6ZTtcbn07XG5cbkhhc2guY29tcGFjdCA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgICByZXR1cm4gSGFzaChyZWYpLmNvbXBhY3QuaXRlbXM7XG59O1xuIiwidmFyIHRyYXZlcnNlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG5ldyBUcmF2ZXJzZShvYmopO1xufTtcblxuZnVuY3Rpb24gVHJhdmVyc2UgKG9iaikge1xuICAgIHRoaXMudmFsdWUgPSBvYmo7XG59XG5cblRyYXZlcnNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocHMpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMudmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHBzW2ldO1xuICAgICAgICBpZiAoIW5vZGUgfHwgIWhhc093blByb3BlcnR5LmNhbGwobm9kZSwga2V5KSkge1xuICAgICAgICAgICAgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlW2tleV07XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChwcykge1xuICAgIHZhciBub2RlID0gdGhpcy52YWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aDsgaSArKykge1xuICAgICAgICB2YXIga2V5ID0gcHNbaV07XG4gICAgICAgIGlmICghbm9kZSB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHBzLCB2YWx1ZSkge1xuICAgIHZhciBub2RlID0gdGhpcy52YWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aCAtIDE7IGkgKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHBzW2ldO1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwobm9kZSwga2V5KSkgbm9kZVtrZXldID0ge307XG4gICAgICAgIG5vZGUgPSBub2RlW2tleV07XG4gICAgfVxuICAgIG5vZGVbcHNbaV1dID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYikge1xuICAgIHJldHVybiB3YWxrKHRoaXMudmFsdWUsIGNiLCB0cnVlKTtcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgdGhpcy52YWx1ZSA9IHdhbGsodGhpcy52YWx1ZSwgY2IsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoY2IsIGluaXQpIHtcbiAgICB2YXIgc2tpcCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDE7XG4gICAgdmFyIGFjYyA9IHNraXAgPyB0aGlzLnZhbHVlIDogaW5pdDtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUm9vdCB8fCAhc2tpcCkge1xuICAgICAgICAgICAgYWNjID0gY2IuY2FsbCh0aGlzLCBhY2MsIHgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5wYXRocyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWNjID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGFjYy5wdXNoKHRoaXMucGF0aCk7IFxuICAgIH0pO1xuICAgIHJldHVybiBhY2M7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUubm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFjYyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBhY2MucHVzaCh0aGlzLm5vZGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2M7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudHMgPSBbXSwgbm9kZXMgPSBbXTtcbiAgICBcbiAgICByZXR1cm4gKGZ1bmN0aW9uIGNsb25lIChzcmMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50c1tpXSA9PT0gc3JjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ29iamVjdCcgJiYgc3JjICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZHN0ID0gY29weShzcmMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYXJlbnRzLnB1c2goc3JjKTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goZHN0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yRWFjaChvYmplY3RLZXlzKHNyYyksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkc3Rba2V5XSA9IGNsb25lKHNyY1trZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYXJlbnRzLnBvcCgpO1xuICAgICAgICAgICAgbm9kZXMucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gZHN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNyYztcbiAgICAgICAgfVxuICAgIH0pKHRoaXMudmFsdWUpO1xufTtcblxuZnVuY3Rpb24gd2FsayAocm9vdCwgY2IsIGltbXV0YWJsZSkge1xuICAgIHZhciBwYXRoID0gW107XG4gICAgdmFyIHBhcmVudHMgPSBbXTtcbiAgICB2YXIgYWxpdmUgPSB0cnVlO1xuICAgIFxuICAgIHJldHVybiAoZnVuY3Rpb24gd2Fsa2VyIChub2RlXykge1xuICAgICAgICB2YXIgbm9kZSA9IGltbXV0YWJsZSA/IGNvcHkobm9kZV8pIDogbm9kZV87XG4gICAgICAgIHZhciBtb2RpZmllcnMgPSB7fTtcbiAgICAgICAgXG4gICAgICAgIHZhciBrZWVwR29pbmcgPSB0cnVlO1xuICAgICAgICBcbiAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgbm9kZSA6IG5vZGUsXG4gICAgICAgICAgICBub2RlXyA6IG5vZGVfLFxuICAgICAgICAgICAgcGF0aCA6IFtdLmNvbmNhdChwYXRoKSxcbiAgICAgICAgICAgIHBhcmVudCA6IHBhcmVudHNbcGFyZW50cy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhcmVudHMgOiBwYXJlbnRzLFxuICAgICAgICAgICAga2V5IDogcGF0aC5zbGljZSgtMSlbMF0sXG4gICAgICAgICAgICBpc1Jvb3QgOiBwYXRoLmxlbmd0aCA9PT0gMCxcbiAgICAgICAgICAgIGxldmVsIDogcGF0aC5sZW5ndGgsXG4gICAgICAgICAgICBjaXJjdWxhciA6IG51bGwsXG4gICAgICAgICAgICB1cGRhdGUgOiBmdW5jdGlvbiAoeCwgc3RvcEhlcmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmlzUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wYXJlbnQubm9kZVtzdGF0ZS5rZXldID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUubm9kZSA9IHg7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3BIZXJlKSBrZWVwR29pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZGVsZXRlJyA6IGZ1bmN0aW9uIChzdG9wSGVyZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5wYXJlbnQubm9kZVtzdGF0ZS5rZXldO1xuICAgICAgICAgICAgICAgIGlmIChzdG9wSGVyZSkga2VlcEdvaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlIDogZnVuY3Rpb24gKHN0b3BIZXJlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoc3RhdGUucGFyZW50Lm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnBhcmVudC5ub2RlLnNwbGljZShzdGF0ZS5rZXksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLnBhcmVudC5ub2RlW3N0YXRlLmtleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdG9wSGVyZSkga2VlcEdvaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2V5cyA6IG51bGwsXG4gICAgICAgICAgICBiZWZvcmUgOiBmdW5jdGlvbiAoZikgeyBtb2RpZmllcnMuYmVmb3JlID0gZiB9LFxuICAgICAgICAgICAgYWZ0ZXIgOiBmdW5jdGlvbiAoZikgeyBtb2RpZmllcnMuYWZ0ZXIgPSBmIH0sXG4gICAgICAgICAgICBwcmUgOiBmdW5jdGlvbiAoZikgeyBtb2RpZmllcnMucHJlID0gZiB9LFxuICAgICAgICAgICAgcG9zdCA6IGZ1bmN0aW9uIChmKSB7IG1vZGlmaWVycy5wb3N0ID0gZiB9LFxuICAgICAgICAgICAgc3RvcCA6IGZ1bmN0aW9uICgpIHsgYWxpdmUgPSBmYWxzZSB9LFxuICAgICAgICAgICAgYmxvY2sgOiBmdW5jdGlvbiAoKSB7IGtlZXBHb2luZyA9IGZhbHNlIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGlmICghYWxpdmUpIHJldHVybiBzdGF0ZTtcbiAgICAgICAgXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZS5ub2RlID09PSAnb2JqZWN0JyAmJiBzdGF0ZS5ub2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5rZXlzIHx8IHN0YXRlLm5vZGVfICE9PSBzdGF0ZS5ub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmtleXMgPSBvYmplY3RLZXlzKHN0YXRlLm5vZGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHN0YXRlLmlzTGVhZiA9IHN0YXRlLmtleXMubGVuZ3RoID09IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRzW2ldLm5vZGVfID09PSBub2RlXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2lyY3VsYXIgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc0xlYWYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlLmtleXMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzdGF0ZS5ub3RMZWFmID0gIXN0YXRlLmlzTGVhZjtcbiAgICAgICAgICAgIHN0YXRlLm5vdFJvb3QgPSAhc3RhdGUuaXNSb290O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB1cGRhdGVTdGF0ZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gdXNlIHJldHVybiB2YWx1ZXMgdG8gdXBkYXRlIGlmIGRlZmluZWRcbiAgICAgICAgdmFyIHJldCA9IGNiLmNhbGwoc3RhdGUsIHN0YXRlLm5vZGUpO1xuICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQgJiYgc3RhdGUudXBkYXRlKSBzdGF0ZS51cGRhdGUocmV0KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChtb2RpZmllcnMuYmVmb3JlKSBtb2RpZmllcnMuYmVmb3JlLmNhbGwoc3RhdGUsIHN0YXRlLm5vZGUpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFrZWVwR29pbmcpIHJldHVybiBzdGF0ZTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUubm9kZSA9PSAnb2JqZWN0J1xuICAgICAgICAmJiBzdGF0ZS5ub2RlICE9PSBudWxsICYmICFzdGF0ZS5jaXJjdWxhcikge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdXBkYXRlU3RhdGUoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yRWFjaChzdGF0ZS5rZXlzLCBmdW5jdGlvbiAoa2V5LCBpKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5wcmUpIG1vZGlmaWVycy5wcmUuY2FsbChzdGF0ZSwgc3RhdGUubm9kZVtrZXldLCBrZXkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHdhbGtlcihzdGF0ZS5ub2RlW2tleV0pO1xuICAgICAgICAgICAgICAgIGlmIChpbW11dGFibGUgJiYgaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS5ub2RlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm5vZGVba2V5XSA9IGNoaWxkLm5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNoaWxkLmlzTGFzdCA9IGkgPT0gc3RhdGUua2V5cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGNoaWxkLmlzRmlyc3QgPSBpID09IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5wb3N0KSBtb2RpZmllcnMucG9zdC5jYWxsKHN0YXRlLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcGF0aC5wb3AoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyZW50cy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKG1vZGlmaWVycy5hZnRlcikgbW9kaWZpZXJzLmFmdGVyLmNhbGwoc3RhdGUsIHN0YXRlLm5vZGUpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0pKHJvb3QpLm5vZGU7XG59XG5cbmZ1bmN0aW9uIGNvcHkgKHNyYykge1xuICAgIGlmICh0eXBlb2Ygc3JjID09PSAnb2JqZWN0JyAmJiBzcmMgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGRzdDtcbiAgICAgICAgXG4gICAgICAgIGlmIChpc0FycmF5KHNyYykpIHtcbiAgICAgICAgICAgIGRzdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRGF0ZShzcmMpKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgRGF0ZShzcmMuZ2V0VGltZSA/IHNyYy5nZXRUaW1lKCkgOiBzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUmVnRXhwKHNyYykpIHtcbiAgICAgICAgICAgIGRzdCA9IG5ldyBSZWdFeHAoc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Vycm9yKHNyYykpIHtcbiAgICAgICAgICAgIGRzdCA9IHsgbWVzc2FnZTogc3JjLm1lc3NhZ2UgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Jvb2xlYW4oc3JjKSkge1xuICAgICAgICAgICAgZHN0ID0gbmV3IEJvb2xlYW4oc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc051bWJlcihzcmMpKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgTnVtYmVyKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTdHJpbmcoc3JjKSkge1xuICAgICAgICAgICAgZHN0ID0gbmV3IFN0cmluZyhzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKE9iamVjdC5jcmVhdGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgICBkc3QgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihzcmMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzcmMuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgZHN0ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJvdG8gPVxuICAgICAgICAgICAgICAgIChzcmMuY29uc3RydWN0b3IgJiYgc3JjLmNvbnN0cnVjdG9yLnByb3RvdHlwZSlcbiAgICAgICAgICAgICAgICB8fCBzcmMuX19wcm90b19fXG4gICAgICAgICAgICAgICAgfHwge31cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHZhciBUID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICBULnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICAgICAgZHN0ID0gbmV3IFQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZvckVhY2gob2JqZWN0S2V5cyhzcmMpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBkc3Rba2V5XSA9IHNyY1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRzdDtcbiAgICB9XG4gICAgZWxzZSByZXR1cm4gc3JjO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMgKG9iaikge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSByZXMucHVzaChrZXkpXG4gICAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHRvUyAob2JqKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSB9XG5mdW5jdGlvbiBpc0RhdGUgKG9iaikgeyByZXR1cm4gdG9TKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJyB9XG5mdW5jdGlvbiBpc1JlZ0V4cCAob2JqKSB7IHJldHVybiB0b1Mob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScgfVxuZnVuY3Rpb24gaXNFcnJvciAob2JqKSB7IHJldHVybiB0b1Mob2JqKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB9XG5mdW5jdGlvbiBpc0Jvb2xlYW4gKG9iaikgeyByZXR1cm4gdG9TKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJyB9XG5mdW5jdGlvbiBpc051bWJlciAob2JqKSB7IHJldHVybiB0b1Mob2JqKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgfVxuZnVuY3Rpb24gaXNTdHJpbmcgKG9iaikgeyByZXR1cm4gdG9TKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nIH1cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkgKHhzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICh4cywgZm4pIHtcbiAgICBpZiAoeHMuZm9yRWFjaCkgcmV0dXJuIHhzLmZvckVhY2goZm4pXG4gICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZuKHhzW2ldLCBpLCB4cyk7XG4gICAgfVxufTtcblxuZm9yRWFjaChvYmplY3RLZXlzKFRyYXZlcnNlLnByb3RvdHlwZSksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB0cmF2ZXJzZVtrZXldID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgdmFyIHQgPSBuZXcgVHJhdmVyc2Uob2JqKTtcbiAgICAgICAgcmV0dXJuIHRba2V5XS5hcHBseSh0LCBhcmdzKTtcbiAgICB9O1xufSk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICByZXR1cm4ga2V5IGluIG9iajtcbn07XG4iLCIvKipcbiAqIEBwcmVzZXJ2ZSBDb3B5cmlnaHQgMjAxMiBSb2JlcnQgR3VzdC1CYXJkb24gPGh0dHA6Ly9yb2JlcnQuZ3VzdC1iYXJkb24ub3JnLz4uXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gKiBhcmUgbWV0OlxuICpcbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAqICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICAgICBkaXNjbGFpbWVyLlxuICpcbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAqICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIFwiQVMgSVNcIiBBTkQgQU5ZXG4gKiBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gKiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICogT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICogVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gKiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAqIFNVQ0ggREFNQUdFLlxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBFbmhhbmNlcyA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUy9cIlxuICogPlVnbGlmeUpTPC9hPiB3aXRoIGNvbnNvbGlkYXRpb24gb2YgbnVsbCwgQm9vbGVhbiwgYW5kIFN0cmluZyB2YWx1ZXMuXG4gKiA8cD5BbHNvIGtub3duIGFzIGFsaWFzaW5nLCB0aGlzIGZlYXR1cmUgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiA8YSBocmVmPVxuICogXCJodHRwOi8vY2xvc3VyZS1jb21waWxlci5nb29nbGVjb2RlLmNvbS9cIj50aGUgQ2xvc3VyZSBDb21waWxlcjwvYT4gc2luY2UgaXRzXG4gKiBpbml0aWFsIHJlbGVhc2UsIHdoZXJlIGl0IGlzIHVuYXZhaWxhYmxlIGZyb20gdGhlIDxhYmJyIHRpdGxlPVxuICogXCJjb21tYW5kIGxpbmUgaW50ZXJmYWNlXCI+Q0xJPC9hPi4gVGhlIENsb3N1cmUgQ29tcGlsZXIgYWxsb3dzIG9uZSB0byBsb2cgYW5kXG4gKiBpbmZsdWVuY2UgdGhpcyBwcm9jZXNzLiBJbiBjb250cmFzdCwgdGhpcyBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBpbnRyb2R1Y2VcbiAqIGFueSB2YXJpYWJsZSBkZWNsYXJhdGlvbnMgaW4gZ2xvYmFsIGNvZGUgYW5kIGRlcml2ZXMgU3RyaW5nIHZhbHVlcyBmcm9tXG4gKiBpZGVudGlmaWVyIG5hbWVzIHVzZWQgYXMgcHJvcGVydHkgYWNjZXNzb3JzLjwvcD5cbiAqIDxwPkNvbnNvbGlkYXRpbmcgbGl0ZXJhbHMgbWF5IHdvcnNlbiB0aGUgZGF0YSBjb21wcmVzc2lvbiByYXRpbyB3aGVuIGFuIDxhXG4gKiBocmVmPVwiaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjYxNiNzZWN0aW9uLTMuNVwiPmVuY29kaW5nXG4gKiB0cmFuc2Zvcm1hdGlvbjwvYT4gaXMgYXBwbGllZC4gRm9yIGluc3RhbmNlLCA8YSBocmVmPVxuICogXCJodHRwOi8vY29kZS5qcXVlcnkuY29tL2pxdWVyeS0xLjcuMS5qc1wiPmpRdWVyeSAxLjcuMTwvYT4gdGFrZXMgMjQ4MjM1IGJ5dGVzLlxuICogQnVpbGRpbmcgaXQgd2l0aCA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUy90YXJiYWxsL3YxLjIuNVwiPlxuICogVWdsaWZ5SlMgdjEuMi41PC9hPiByZXN1bHRzIGluIDkzNjQ3IGJ5dGVzICgzNy43MyUgb2YgdGhlIG9yaWdpbmFsKSB3aGljaCBhcmVcbiAqIHRoZW4gY29tcHJlc3NlZCB0byAzMzE1NCBieXRlcyAoMTMuMzYlIG9mIHRoZSBvcmlnaW5hbCkgdXNpbmcgPGEgaHJlZj1cbiAqIFwiaHR0cDovL2xpbnV4LmRpZS5uZXQvbWFuLzEvZ3ppcFwiPmd6aXAoMSk8L2E+LiBCdWlsZGluZyBpdCB3aXRoIHRoZSBzYW1lXG4gKiB2ZXJzaW9uIG9mIFVnbGlmeUpTIDEuMi41IHBhdGNoZWQgd2l0aCB0aGUgaW1wbGVtZW50YXRpb24gb2YgY29uc29saWRhdGlvblxuICogcmVzdWx0cyBpbiA4MDc4NCBieXRlcyAoYSBkZWNyZWFzZSBvZiAxMjg2MyBieXRlcywgaS5lLiAxMy43NCUsIGluIGNvbXBhcmlzb25cbiAqIHRvIHRoZSBhZm9yZW1lbnRpb25lZCA5MzY0NyBieXRlcykgd2hpY2ggYXJlIHRoZW4gY29tcHJlc3NlZCB0byAzNDAxMyBieXRlc1xuICogKGFuIGluY3JlYXNlIG9mIDg1OSBieXRlcywgaS5lLiAyLjU5JSwgaW4gY29tcGFyaXNvbiB0byB0aGUgYWZvcmVtZW50aW9uZWRcbiAqIDMzMTU0IGJ5dGVzKS48L3A+XG4gKiA8cD5Xcml0dGVuIGluIDxhIGhyZWY9XCJodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g0LjIuMlwiPnRoZSBzdHJpY3QgdmFyaWFudDwvYT5cbiAqIG9mIDxhIGhyZWY9XCJodHRwOi8vZXM1LmdpdGh1Yi5jb20vXCI+RUNNQS0yNjIgNS4xIEVkaXRpb248L2E+LiBFbmNvZGVkIGluIDxhXG4gKiBocmVmPVwiaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzYyOVwiPlVURi04PC9hPi4gRm9sbG93cyA8YSBocmVmPVxuICogXCJodHRwOi8vZ29vZ2xlLXN0eWxlZ3VpZGUuZ29vZ2xlY29kZS5jb20vc3ZuLWhpc3Rvcnkvcjc2L3RydW5rL2phdmFzY3JpcHRndWlkZS54bWxcIlxuICogPlJldmlzaW9uIDIuMjggb2YgdGhlIEdvb2dsZSBKYXZhU2NyaXB0IFN0eWxlIEd1aWRlPC9hPiAoZXhjZXB0IGZvciB0aGVcbiAqIGRpc2NvdXJhZ2VkIHVzZSBvZiB0aGUge0Bjb2RlIGZ1bmN0aW9ufSB0YWcgYW5kIHRoZSB7QGNvZGUgbmFtZXNwYWNlfSB0YWcpLlxuICogMTAwJSB0eXBlZCBmb3IgdGhlIDxhIGhyZWY9XG4gKiBcImh0dHA6Ly9jbG9zdXJlLWNvbXBpbGVyLmdvb2dsZWNvZGUuY29tL2ZpbGVzL2NvbXBpbGVyLTIwMTIwMTIzLnRhci5nelwiXG4gKiA+Q2xvc3VyZSBDb21waWxlciBWZXJzaW9uIDE3NDE8L2E+LjwvcD5cbiAqIDxwPlNob3VsZCB5b3UgZmluZCB0aGlzIHNvZnR3YXJlIHVzZWZ1bCwgcGxlYXNlIGNvbnNpZGVyIDxhIGhyZWY9XG4gKiBcImh0dHBzOi8vcGF5cGFsLmNvbS9jZ2ktYmluL3dlYnNjcj9jbWQ9X3MteGNsaWNrJmhvc3RlZF9idXR0b25faWQ9SlpMVzcyWDhGRDRXR1wiXG4gKiA+YSBkb25hdGlvbjwvYT4uPC9wPlxuICogQGF1dGhvciBmb2xsb3cubWVAUkd1c3RCYXJkb24gKFJvYmVydCBHdXN0LUJhcmRvbilcbiAqIEBzdXBwb3J0ZWQgVGVzdGVkIHdpdGg6XG4gKiAgICAgPHVsPlxuICogICAgIDxsaT48YSBocmVmPVwiaHR0cDovL25vZGVqcy5vcmcvZGlzdC92MC42LjEwL1wiPk5vZGUgdjAuNi4xMDwvYT4sPC9saT5cbiAqICAgICA8bGk+PGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMvdGFyYmFsbC92MS4yLjVcIj5VZ2xpZnlKU1xuICogICAgICAgdjEuMi41PC9hPi48L2xpPlxuICogICAgIDwvdWw+XG4gKi9cblxuLypnbG9iYWwgY29uc29sZTpmYWxzZSwgZXhwb3J0czp0cnVlLCBtb2R1bGU6ZmFsc2UsIHJlcXVpcmU6ZmFsc2UgKi9cbi8qanNoaW50IHN1Yjp0cnVlICovXG4vKipcbiAqIENvbnNvbGlkYXRlcyBudWxsLCBCb29sZWFuLCBhbmQgU3RyaW5nIHZhbHVlcyBmb3VuZCBpbnNpZGUgYW4gPGFiYnIgdGl0bGU9XG4gKiBcImFic3RyYWN0IHN5bnRheCB0cmVlXCI+QVNUPC9hYmJyPi5cbiAqIEBwYXJhbSB7IVRTeW50YWN0aWNDb2RlVW5pdH0gb0Fic3RyYWN0U3ludGF4VHJlZSBBbiBhcnJheS1saWtlIG9iamVjdFxuICogICAgIHJlcHJlc2VudGluZyBhbiA8YWJiciB0aXRsZT1cImFic3RyYWN0IHN5bnRheCB0cmVlXCI+QVNUPC9hYmJyPi5cbiAqIEByZXR1cm4geyFUU3ludGFjdGljQ29kZVVuaXR9IEFuIGFycmF5LWxpa2Ugb2JqZWN0IHJlcHJlc2VudGluZyBhbiA8YWJiclxuICogICAgIHRpdGxlPVwiYWJzdHJhY3Qgc3ludGF4IHRyZWVcIj5BU1Q8L2FiYnI+IHdpdGggaXRzIG51bGwsIEJvb2xlYW4sIGFuZFxuICogICAgIFN0cmluZyB2YWx1ZXMgY29uc29saWRhdGVkLlxuICovXG4vLyBUT0RPKHVzZXIpIENvbnNvbGlkYXRpb24gb2YgbWF0aGVtYXRpY2FsIHZhbHVlcyBmb3VuZCBpbiBudW1lcmljIGxpdGVyYWxzLlxuLy8gVE9ETyh1c2VyKSBVbmNvbnNvbGlkYXRpb24uXG4vLyBUT0RPKHVzZXIpIENvbnNvbGlkYXRpb24gb2YgRUNNQS0yNjIgNnRoIEVkaXRpb24gcHJvZ3JhbXMuXG4vLyBUT0RPKHVzZXIpIFJld3JpdGUgaW4gRUNNQS0yNjIgNnRoIEVkaXRpb24uXG5leHBvcnRzWydhc3RfY29uc29saWRhdGUnXSA9IGZ1bmN0aW9uKG9BYnN0cmFjdFN5bnRheFRyZWUpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKmpzaGludCBiaXR3aXNlOnRydWUsIGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBmb3Jpbjp0cnVlLCBpbW1lZDp0cnVlLFxuICAgICAgICBsYXRlZGVmOnRydWUsIG5ld2NhcDp0cnVlLCBub2FyZ2U6dHJ1ZSwgbm9lbXB0eTp0cnVlLCBub25ldzp0cnVlLFxuICAgICAgICBvbmV2YXI6dHJ1ZSwgcGx1c3BsdXM6dHJ1ZSwgcmVnZXhwOnRydWUsIHVuZGVmOnRydWUsIHN0cmljdDp0cnVlLFxuICAgICAgICBzdWI6ZmFsc2UsIHRyYWlsaW5nOnRydWUgKi9cblxuICB2YXIgXyxcbiAgICAgIC8qKlxuICAgICAgICogQSByZWNvcmQgY29uc2lzdGluZyBvZiBkYXRhIGFib3V0IG9uZSBvciBtb3JlIHNvdXJjZSBlbGVtZW50cy5cbiAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICogQG5vc2lkZWVmZmVjdHNcbiAgICAgICAqL1xuICAgICAgVFNvdXJjZUVsZW1lbnRzRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNhdGVnb3J5IG9mIHRoZSBlbGVtZW50cy5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHNlZSBFU291cmNlRWxlbWVudENhdGVnb3JpZXNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubkNhdGVnb3J5ID0gRVNvdXJjZUVsZW1lbnRDYXRlZ29yaWVzLk5fT1RIRVI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIG9jY3VycmVuY2VzICh3aXRoaW4gdGhlIGVsZW1lbnRzKSBvZiBlYWNoIHByaW1pdGl2ZVxuICAgICAgICAgKiB2YWx1ZSB0aGF0IGNvdWxkIGJlIGNvbnNvbGlkYXRlZC5cbiAgICAgICAgICogQHR5cGUgeyFBcnJheS48IU9iamVjdC48c3RyaW5nLCBudW1iZXI+Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYUNvdW50ID0gW107XG4gICAgICAgIHRoaXMuYUNvdW50W0VQcmltYXJ5RXhwcmVzc2lvbkNhdGVnb3JpZXMuTl9JREVOVElGSUVSX05BTUVTXSA9IHt9O1xuICAgICAgICB0aGlzLmFDb3VudFtFUHJpbWFyeUV4cHJlc3Npb25DYXRlZ29yaWVzLk5fU1RSSU5HX0xJVEVSQUxTXSA9IHt9O1xuICAgICAgICB0aGlzLmFDb3VudFtFUHJpbWFyeUV4cHJlc3Npb25DYXRlZ29yaWVzLk5fTlVMTF9BTkRfQk9PTEVBTl9MSVRFUkFMU10gPVxuICAgICAgICAgICAge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVudGlmaWVyIG5hbWVzIGZvdW5kIHdpdGhpbiB0aGUgZWxlbWVudHMuXG4gICAgICAgICAqIEB0eXBlIHshQXJyYXkuPHN0cmluZz59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFJZGVudGlmaWVycyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJlZml4ZWQgcmVwcmVzZW50YXRpb24gU3RyaW5ncyBvZiBlYWNoIHByaW1pdGl2ZSB2YWx1ZSB0aGF0IGNvdWxkIGJlXG4gICAgICAgICAqIGNvbnNvbGlkYXRlZCB3aXRoaW4gdGhlIGVsZW1lbnRzLlxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5LjxzdHJpbmc+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hUHJpbWl0aXZlVmFsdWVzID0gW107XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBBIHJlY29yZCBjb25zaXN0aW5nIG9mIGRhdGEgYWJvdXQgYSBwcmltaXRpdmUgdmFsdWUgdGhhdCBjb3VsZCBiZVxuICAgICAgICogY29uc29saWRhdGVkLlxuICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgKiBAbm9zaWRlZWZmZWN0c1xuICAgICAgICovXG4gICAgICBUUHJpbWl0aXZlVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaWZmZXJlbmNlIGluIHRoZSBudW1iZXIgb2YgdGVybWluYWwgc3ltYm9scyBiZXR3ZWVuIHRoZSBvcmlnaW5hbFxuICAgICAgICAgKiBzb3VyY2UgdGV4dCBhbmQgdGhlIG9uZSB3aXRoIHRoZSBwcmltaXRpdmUgdmFsdWUgY29uc29saWRhdGVkLiBJZiB0aGVcbiAgICAgICAgICogZGlmZmVyZW5jZSBpcyBwb3NpdGl2ZSwgdGhlIHByaW1pdGl2ZSB2YWx1ZSBpcyBjb25zaWRlcmVkIHdvcnRod2hpbGUuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5TYXZpbmcgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaWRlbnRpZmllciBuYW1lIG9mIHRoZSB2YXJpYWJsZSB0aGF0IHdpbGwgYmUgZGVjbGFyZWQgYW5kIGFzc2lnbmVkXG4gICAgICAgICAqIHRoZSBwcmltaXRpdmUgdmFsdWUgaWYgdGhlIHByaW1pdGl2ZSB2YWx1ZSBpcyBjb25zb2xpZGF0ZWQuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNOYW1lID0gJyc7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBBIHJlY29yZCBjb25zaXN0aW5nIG9mIGRhdGEgb24gd2hhdCB0byBjb25zb2xpZGF0ZSB3aXRoaW4gdGhlIHJhbmdlIG9mXG4gICAgICAgKiBzb3VyY2UgZWxlbWVudHMgdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgY29uc2lkZXJlZC5cbiAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICogQG5vc2lkZWVmZmVjdHNcbiAgICAgICAqL1xuICAgICAgVFNvbHV0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBvYmplY3Qgd2hvc2Uga2V5cyBhcmUgcHJlZml4ZWQgcmVwcmVzZW50YXRpb24gU3RyaW5ncyBvZiBlYWNoXG4gICAgICAgICAqIHByaW1pdGl2ZSB2YWx1ZSB0aGF0IGNvdWxkIGJlIGNvbnNvbGlkYXRlZCB3aXRoaW4gdGhlIGVsZW1lbnRzIGFuZFxuICAgICAgICAgKiB3aG9zZSB2YWx1ZXMgYXJlIGNvcnJlc3BvbmRpbmcgZGF0YSBhYm91dCB0aG9zZSBwcmltaXRpdmUgdmFsdWVzLlxuICAgICAgICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCB7blNhdmluZzogbnVtYmVyLCBzTmFtZTogc3RyaW5nfT59XG4gICAgICAgICAqIEBzZWUgVFByaW1pdGl2ZVZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9QcmltaXRpdmVWYWx1ZXMgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaWZmZXJlbmNlIGluIHRoZSBudW1iZXIgb2YgdGVybWluYWwgc3ltYm9scyBiZXR3ZWVuIHRoZSBvcmlnaW5hbFxuICAgICAgICAgKiBzb3VyY2UgdGV4dCBhbmQgdGhlIG9uZSB3aXRoIGFsbCB0aGUgd29ydGh3aGlsZSBwcmltaXRpdmUgdmFsdWVzXG4gICAgICAgICAqIGNvbnNvbGlkYXRlZC5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHNlZSBUUHJpbWl0aXZlVmFsdWUjblNhdmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uU2F2aW5ncyA9IDA7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgcHJvY2Vzc29yIG9mIDxhYmJyIHRpdGxlPVwiYWJzdHJhY3Qgc3ludGF4IHRyZWVcIj5BU1Q8L2FiYnI+cyBmb3VuZFxuICAgICAgICogaW4gVWdsaWZ5SlMuXG4gICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgKiBAdHlwZSB7IVRQcm9jZXNzb3J9XG4gICAgICAgKi9cbiAgICAgIG9Qcm9jZXNzb3IgPSAoLyoqIEB0eXBlIHshVFByb2Nlc3Nvcn0gKi8gcmVxdWlyZSgnLi9wcm9jZXNzJykpLFxuICAgICAgLyoqXG4gICAgICAgKiBBIHJlY29yZCBjb25zaXN0aW5nIG9mIGEgbnVtYmVyIG9mIGNvbnN0YW50cyB0aGF0IHJlcHJlc2VudCB0aGVcbiAgICAgICAqIGRpZmZlcmVuY2UgaW4gdGhlIG51bWJlciBvZiB0ZXJtaW5hbCBzeW1ib2xzIGJldHdlZW4gYSBzb3VyY2UgdGV4dCB3aXRoXG4gICAgICAgKiBhIG1vZGlmaWVkIHN5bnRhY3RpYyBjb2RlIHVuaXQgYW5kIHRoZSBvcmlnaW5hbCBvbmUuXG4gICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCBudW1iZXI+fVxuICAgICAgICovXG4gICAgICBvV2VpZ2h0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaWZmZXJlbmNlIGluIHRoZSBudW1iZXIgb2YgcHVuY3R1YXRvcnMgcmVxdWlyZWQgYnkgdGhlIGJyYWNrZXRcbiAgICAgICAgICogbm90YXRpb24gYW5kIHRoZSBkb3Qgbm90YXRpb24uXG4gICAgICAgICAqIDxwPjxjb2RlPidbXScubGVuZ3RoIC0gJy4nLmxlbmd0aDwvY29kZT48L3A+XG4gICAgICAgICAqIEBjb25zdFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgTl9QUk9QRVJUWV9BQ0NFU1NPUjogMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgcHVuY3R1YXRvcnMgcmVxdWlyZWQgYnkgYSB2YXJpYWJsZSBkZWNsYXJhdGlvbiB3aXRoIGFuXG4gICAgICAgICAqIGluaXRpYWxpc2VyLlxuICAgICAgICAgKiA8cD48Y29kZT4nOicubGVuZ3RoICsgJzsnLmxlbmd0aDwvY29kZT48L3A+XG4gICAgICAgICAqIEBjb25zdFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgTl9WQVJJQUJMRV9ERUNMQVJBVElPTjogMixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgdGVybWluYWwgc3ltYm9scyByZXF1aXJlZCB0byBpbnRyb2R1Y2UgYSB2YXJpYWJsZVxuICAgICAgICAgKiBzdGF0ZW1lbnQgKGV4Y2x1ZGluZyBpdHMgdmFyaWFibGUgZGVjbGFyYXRpb24gbGlzdCkuXG4gICAgICAgICAqIDxwPjxjb2RlPid2YXIgJy5sZW5ndGg8L2NvZGU+PC9wPlxuICAgICAgICAgKiBAY29uc3RcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIE5fVkFSSUFCTEVfU1RBVEVNRU5UX0FGRklYQVRJT046IDQsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHRlcm1pbmFsIHN5bWJvbHMgbmVlZGVkIHRvIGVuY2xvc2Ugc291cmNlIGVsZW1lbnRzXG4gICAgICAgICAqIHdpdGhpbiBhIGZ1bmN0aW9uIGNhbGwgd2l0aCBubyBhcmd1bWVudCB2YWx1ZXMgdG8gYSBmdW5jdGlvbiB3aXRoIGFuXG4gICAgICAgICAqIGVtcHR5IHBhcmFtZXRlciBsaXN0LlxuICAgICAgICAgKiA8cD48Y29kZT4nKGZ1bmN0aW9uKCl7fSgpKTsnLmxlbmd0aDwvY29kZT48L3A+XG4gICAgICAgICAqIEBjb25zdFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgTl9DTE9TVVJFOiAxN1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogQ2F0ZWdvcmllcyBvZiBwcmltYXJ5IGV4cHJlc3Npb25zIGZyb20gd2hpY2ggcHJpbWl0aXZlIHZhbHVlcyB0aGF0XG4gICAgICAgKiBjb3VsZCBiZSBjb25zb2xpZGF0ZWQgYXJlIGRlcml2YWJsZS5cbiAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAqIEBlbnVtIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIEVQcmltYXJ5RXhwcmVzc2lvbkNhdGVnb3JpZXMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVudGlmaWVyIG5hbWVzIHVzZWQgYXMgcHJvcGVydHkgYWNjZXNzb3JzLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgTl9JREVOVElGSUVSX05BTUVTOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogU3RyaW5nIGxpdGVyYWxzLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgTl9TVFJJTkdfTElURVJBTFM6IDEsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdWxsIGFuZCBCb29sZWFuIGxpdGVyYWxzLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgTl9OVUxMX0FORF9CT09MRUFOX0xJVEVSQUxTOiAyXG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBQcmVmaXhlcyBvZiBwcmltaXRpdmUgdmFsdWVzIHRoYXQgY291bGQgYmUgY29uc29saWRhdGVkLlxuICAgICAgICogVGhlIFN0cmluZyB2YWx1ZXMgb2YgdGhlIHByZWZpeGVzIG11c3QgaGF2ZSBzYW1lIG51bWJlciBvZiBjaGFyYWN0ZXJzLlxuICAgICAgICogVGhlIHByZWZpeGVzIG11c3Qgbm90IGJlIHVzZWQgaW4gYW55IHByb3BlcnRpZXMgZGVmaW5lZCBpbiBhbnkgdmVyc2lvblxuICAgICAgICogb2YgPGEgaHJlZj1cbiAgICAgICAqIFwiaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9zdGFuZGFyZHMvRWNtYS0yNjIuaHRtXCJcbiAgICAgICAqID5FQ01BLTI2MjwvYT4uXG4gICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgKiBAZW51bSB7c3RyaW5nfVxuICAgICAgICovXG4gICAgICBFVmFsdWVQcmVmaXhlcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElkZW50aWZpZXMgU3RyaW5nIHZhbHVlcy5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIFNfU1RSSU5HOiAnI1MnLFxuICAgICAgICAvKipcbiAgICAgICAgICogSWRlbnRpZmllcyBudWxsIGFuZCBCb29sZWFuIHZhbHVlcy5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIFNfU1lNQk9MSUM6ICcjTydcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIENhdGVnb3JpZXMgb2Ygc291cmNlIGVsZW1lbnRzIGluIHRlcm1zIG9mIHRoZWlyIGFwcHJvcHJpYXRlbmVzcyBvZlxuICAgICAgICogaGF2aW5nIHRoZWlyIHByaW1pdGl2ZSB2YWx1ZXMgY29uc29saWRhdGVkLlxuICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICogQGVudW0ge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgRVNvdXJjZUVsZW1lbnRDYXRlZ29yaWVzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWRlbnRpZmllcyBhIHNvdXJjZSBlbGVtZW50IHRoYXQgaW5jbHVkZXMgdGhlIDxhIGhyZWY9XG4gICAgICAgICAqIFwiaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTIuMTBcIj57QGNvZGUgd2l0aH08L2E+IHN0YXRlbWVudC5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIE5fV0lUSDogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElkZW50aWZpZXMgYSBzb3VyY2UgZWxlbWVudCB0aGF0IGluY2x1ZGVzIHRoZSA8YSBocmVmPVxuICAgICAgICAgKiBcImh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjEuMi4xXCI+e0Bjb2RlIGV2YWx9PC9hPiBpZGVudGlmaWVyIG5hbWUuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBOX0VWQUw6IDEsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVudGlmaWVzIGEgc291cmNlIGVsZW1lbnQgdGhhdCBtdXN0IGJlIGV4Y2x1ZGVkIGZyb20gdGhlIHByb2Nlc3NcbiAgICAgICAgICogdW5sZXNzIGl0cyB3aG9sZSBzY29wZSBpcyBleGFtaW5lZC5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIE5fRVhDTFVEQUJMRTogMixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElkZW50aWZpZXMgc291cmNlIGVsZW1lbnRzIG5vdCBwb3NpbmcgYW55IHByb2JsZW1zLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgTl9PVEhFUjogM1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGxpc3Qgb2YgbGl0ZXJhbHMgKG90aGVyIHRoYW4gdGhlIFN0cmluZyBvbmVzKSB3aG9zZSBwcmltaXRpdmVcbiAgICAgICAqIHZhbHVlcyBjYW4gYmUgY29uc29saWRhdGVkLlxuICAgICAgICogQGNvbnN0XG4gICAgICAgKiBAdHlwZSB7IUFycmF5LjxzdHJpbmc+fVxuICAgICAgICovXG4gICAgICBBX09USEVSX1NVQlNUSVRVVEFCTEVfTElURVJBTFMgPSBbXG4gICAgICAgICdudWxsJywgICAvLyBUaGUgbnVsbCBsaXRlcmFsLlxuICAgICAgICAnZmFsc2UnLCAgLy8gVGhlIEJvb2xlYW4gbGl0ZXJhbCB7QGNvZGUgZmFsc2V9LlxuICAgICAgICAndHJ1ZScgICAgLy8gVGhlIEJvb2xlYW4gbGl0ZXJhbCB7QGNvZGUgdHJ1ZX0uXG4gICAgICBdO1xuXG4gICgvKipcbiAgICAqIENvbnNvbGlkYXRlcyBhbGwgd29ydGh3aGlsZSBwcmltaXRpdmUgdmFsdWVzIGluIGEgc3ludGFjdGljIGNvZGUgdW5pdC5cbiAgICAqIEBwYXJhbSB7IVRTeW50YWN0aWNDb2RlVW5pdH0gb1N5bnRhY3RpY0NvZGVVbml0IEFuIGFycmF5LWxpa2Ugb2JqZWN0XG4gICAgKiAgICAgcmVwcmVzZW50aW5nIHRoZSBicmFuY2ggb2YgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIHJlcHJlc2VudGluZyB0aGVcbiAgICAqICAgICBzeW50YWN0aWMgY29kZSB1bml0IGFsb25nIHdpdGggaXRzIHNjb3BlLlxuICAgICogQHNlZSBUUHJpbWl0aXZlVmFsdWUjblNhdmluZ1xuICAgICovXG4gICBmdW5jdGlvbiBmRXhhbWluZVN5bnRhY3RpY0NvZGVVbml0KG9TeW50YWN0aWNDb2RlVW5pdCkge1xuICAgICB2YXIgXyxcbiAgICAgICAgIC8qKlxuICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN5bnRhY3RpYyBjb2RlIHVuaXQgcmVwcmVzZW50cyBnbG9iYWwgY29kZS5cbiAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgICovXG4gICAgICAgICBiSXNHbG9iYWwgPSAndG9wbGV2ZWwnID09PSBvU3ludGFjdGljQ29kZVVuaXRbMF0sXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB3aG9sZSBzY29wZSBpcyBiZWluZyBleGFtaW5lZC5cbiAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgICovXG4gICAgICAgICBiSXNXaG9sbHlFeGFtaW5hYmxlID0gIWJJc0dsb2JhbCxcbiAgICAgICAgIC8qKlxuICAgICAgICAgICogQW4gYXJyYXktbGlrZSBvYmplY3QgcmVwcmVzZW50aW5nIHNvdXJjZSBlbGVtZW50cyB0aGF0IGNvbnN0aXR1dGUgYVxuICAgICAgICAgICogc3ludGFjdGljIGNvZGUgdW5pdC5cbiAgICAgICAgICAqIEB0eXBlIHshVFN5bnRhY3RpY0NvZGVVbml0fVxuICAgICAgICAgICovXG4gICAgICAgICBvU291cmNlRWxlbWVudHMsXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIEEgcmVjb3JkIGNvbnNpc3Rpbmcgb2YgZGF0YSBhYm91dCB0aGUgc291cmNlIGVsZW1lbnQgdGhhdCBpc1xuICAgICAgICAgICogY3VycmVudGx5IGJlaW5nIGV4YW1pbmVkLlxuICAgICAgICAgICogQHR5cGUgeyFUU291cmNlRWxlbWVudHNEYXRhfVxuICAgICAgICAgICovXG4gICAgICAgICBvU291cmNlRWxlbWVudERhdGEsXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIFRoZSBzY29wZSBvZiB0aGUgc3ludGFjdGljIGNvZGUgdW5pdC5cbiAgICAgICAgICAqIEB0eXBlIHshVFNjb3BlfVxuICAgICAgICAgICovXG4gICAgICAgICBvU2NvcGUsXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIEFuIGluc3RhbmNlIG9mIGFuIG9iamVjdCB0aGF0IGFsbG93cyB0aGUgdHJhdmVyc2FsIG9mIGFuIDxhYmJyXG4gICAgICAgICAgKiB0aXRsZT1cImFic3RyYWN0IHN5bnRheCB0cmVlXCI+QVNUPC9hYmJyPi5cbiAgICAgICAgICAqIEB0eXBlIHshVFdhbGtlcn1cbiAgICAgICAgICAqL1xuICAgICAgICAgb1dhbGtlcixcbiAgICAgICAgIC8qKlxuICAgICAgICAgICogQW4gb2JqZWN0IGVuY29tcGFzc2luZyBjb2xsZWN0aW9ucyBvZiBmdW5jdGlvbnMgdXNlZCBkdXJpbmcgdGhlXG4gICAgICAgICAgKiB0cmF2ZXJzYWwgb2YgYW4gPGFiYnIgdGl0bGU9XCJhYnN0cmFjdCBzeW50YXggdHJlZVwiPkFTVDwvYWJicj4uXG4gICAgICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCAhT2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uKC4uLlsqXSk+Pn1cbiAgICAgICAgICAqL1xuICAgICAgICAgb1dhbGtlcnMgPSB7XG4gICAgICAgICAgIC8qKlxuICAgICAgICAgICAgKiBBIGNvbGxlY3Rpb24gb2YgZnVuY3Rpb25zIHVzZWQgZHVyaW5nIHRoZSBzdXJ2ZXlhbmNlIG9mIHNvdXJjZVxuICAgICAgICAgICAgKiBlbGVtZW50cy5cbiAgICAgICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICAgICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCBmdW5jdGlvbiguLi5bKl0pPn1cbiAgICAgICAgICAgICovXG4gICAgICAgICAgIG9TdXJ2ZXlTb3VyY2VFbGVtZW50OiB7XG4gICAgICAgICAgICAgLyoqI25vY29kZSsqLyAgLy8gSnNEb2MgVG9vbGtpdCAyLjQuMCBoaWRlcyBzb21lIG9mIHRoZSBrZXlzLlxuICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAqIENsYXNzaWZpZXMgdGhlIHNvdXJjZSBlbGVtZW50IGFzIGV4Y2x1ZGFibGUgaWYgaXQgZG9lcyBub3RcbiAgICAgICAgICAgICAgKiBjb250YWluIGEge0Bjb2RlIHdpdGh9IHN0YXRlbWVudCBvciB0aGUge0Bjb2RlIGV2YWx9IGlkZW50aWZpZXJcbiAgICAgICAgICAgICAgKiBuYW1lLiBBZGRzIHRoZSBpZGVudGlmaWVyIG9mIHRoZSBmdW5jdGlvbiBhbmQgaXRzIGZvcm1hbFxuICAgICAgICAgICAgICAqIHBhcmFtZXRlcnMgdG8gdGhlIGxpc3Qgb2YgaWRlbnRpZmllciBuYW1lcyBmb3VuZC5cbiAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc0lkZW50aWZpZXIgVGhlIGlkZW50aWZpZXIgb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAqIEBwYXJhbSB7IUFycmF5LjxzdHJpbmc+fSBhRm9ybWFsUGFyYW1ldGVyTGlzdCBGb3JtYWwgcGFyYW1ldGVycy5cbiAgICAgICAgICAgICAgKiBAcGFyYW0geyFUU3ludGFjdGljQ29kZVVuaXR9IG9GdW5jdGlvbkJvZHkgRnVuY3Rpb24gY29kZS5cbiAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAnZGVmdW4nOiBmdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgc0lkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgIGFGb3JtYWxQYXJhbWV0ZXJMaXN0LFxuICAgICAgICAgICAgICAgICBvRnVuY3Rpb25Cb2R5KSB7XG4gICAgICAgICAgICAgICBmQ2xhc3NpZnlBc0V4Y2x1ZGFibGUoKTtcbiAgICAgICAgICAgICAgIGZBZGRJZGVudGlmaWVyKHNJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgIGFGb3JtYWxQYXJhbWV0ZXJMaXN0LmZvckVhY2goZkFkZElkZW50aWZpZXIpO1xuICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICogSW5jcmVtZW50cyB0aGUgY291bnQgb2YgdGhlIG51bWJlciBvZiBvY2N1cnJlbmNlcyBvZiB0aGUgU3RyaW5nXG4gICAgICAgICAgICAgICogdmFsdWUgdGhhdCBpcyBlcXVpdmFsZW50IHRvIHRoZSBzZXF1ZW5jZSBvZiB0ZXJtaW5hbCBzeW1ib2xzXG4gICAgICAgICAgICAgICogdGhhdCBjb25zdGl0dXRlIHRoZSBlbmNvdW50ZXJlZCBpZGVudGlmaWVyIG5hbWUuXG4gICAgICAgICAgICAgICogQHBhcmFtIHshVFN5bnRhY3RpY0NvZGVVbml0fSBvRXhwcmVzc2lvbiBUaGUgbm9udGVybWluYWxcbiAgICAgICAgICAgICAgKiAgICAgTWVtYmVyRXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc0lkZW50aWZpZXJOYW1lIFRoZSBpZGVudGlmaWVyIG5hbWUgdXNlZCBhcyB0aGVcbiAgICAgICAgICAgICAgKiAgICAgcHJvcGVydHkgYWNjZXNzb3IuXG4gICAgICAgICAgICAgICogQHJldHVybiB7IUFycmF5fSBUaGUgZW5jb3VudGVyZWQgYnJhbmNoIG9mIGFuIDxhYmJyIHRpdGxlPVxuICAgICAgICAgICAgICAqICAgICBcImFic3RyYWN0IHN5bnRheCB0cmVlXCI+QVNUPC9hYmJyPiB3aXRoIGl0cyBub250ZXJtaW5hbFxuICAgICAgICAgICAgICAqICAgICBNZW1iZXJFeHByZXNzaW9uIHRyYXZlcnNlZC5cbiAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAnZG90JzogZnVuY3Rpb24ob0V4cHJlc3Npb24sIHNJZGVudGlmaWVyTmFtZSkge1xuICAgICAgICAgICAgICAgZkNvdW50UHJpbWFyeUV4cHJlc3Npb24oXG4gICAgICAgICAgICAgICAgICAgRVByaW1hcnlFeHByZXNzaW9uQ2F0ZWdvcmllcy5OX0lERU5USUZJRVJfTkFNRVMsXG4gICAgICAgICAgICAgICAgICAgRVZhbHVlUHJlZml4ZXMuU19TVFJJTkcgKyBzSWRlbnRpZmllck5hbWUpO1xuICAgICAgICAgICAgICAgcmV0dXJuIFsnZG90Jywgb1dhbGtlci53YWxrKG9FeHByZXNzaW9uKSwgc0lkZW50aWZpZXJOYW1lXTtcbiAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAqIEFkZHMgdGhlIG9wdGlvbmFsIGlkZW50aWZpZXIgb2YgdGhlIGZ1bmN0aW9uIGFuZCBpdHMgZm9ybWFsXG4gICAgICAgICAgICAgICogcGFyYW1ldGVycyB0byB0aGUgbGlzdCBvZiBpZGVudGlmaWVyIG5hbWVzIGZvdW5kLlxuICAgICAgICAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gc0lkZW50aWZpZXIgVGhlIG9wdGlvbmFsIGlkZW50aWZpZXIgb2YgdGhlXG4gICAgICAgICAgICAgICogICAgIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAqIEBwYXJhbSB7IUFycmF5LjxzdHJpbmc+fSBhRm9ybWFsUGFyYW1ldGVyTGlzdCBGb3JtYWwgcGFyYW1ldGVycy5cbiAgICAgICAgICAgICAgKiBAcGFyYW0geyFUU3ludGFjdGljQ29kZVVuaXR9IG9GdW5jdGlvbkJvZHkgRnVuY3Rpb24gY29kZS5cbiAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAnZnVuY3Rpb24nOiBmdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgc0lkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgIGFGb3JtYWxQYXJhbWV0ZXJMaXN0LFxuICAgICAgICAgICAgICAgICBvRnVuY3Rpb25Cb2R5KSB7XG4gICAgICAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBzSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICBmQWRkSWRlbnRpZmllcihzSWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBhRm9ybWFsUGFyYW1ldGVyTGlzdC5mb3JFYWNoKGZBZGRJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAqIEVpdGhlciBpbmNyZW1lbnRzIHRoZSBjb3VudCBvZiB0aGUgbnVtYmVyIG9mIG9jY3VycmVuY2VzIG9mIHRoZVxuICAgICAgICAgICAgICAqIGVuY291bnRlcmVkIG51bGwgb3IgQm9vbGVhbiB2YWx1ZSBvciBjbGFzc2lmaWVzIGEgc291cmNlIGVsZW1lbnRcbiAgICAgICAgICAgICAgKiBhcyBjb250YWluaW5nIHRoZSB7QGNvZGUgZXZhbH0gaWRlbnRpZmllciBuYW1lLlxuICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzSWRlbnRpZmllciBUaGUgaWRlbnRpZmllciBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAnbmFtZSc6IGZ1bmN0aW9uKHNJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICBpZiAoLTEgIT09IEFfT1RIRVJfU1VCU1RJVFVUQUJMRV9MSVRFUkFMUy5pbmRleE9mKHNJZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgICAgICBmQ291bnRQcmltYXJ5RXhwcmVzc2lvbihcbiAgICAgICAgICAgICAgICAgICAgIEVQcmltYXJ5RXhwcmVzc2lvbkNhdGVnb3JpZXMuTl9OVUxMX0FORF9CT09MRUFOX0xJVEVSQUxTLFxuICAgICAgICAgICAgICAgICAgICAgRVZhbHVlUHJlZml4ZXMuU19TWU1CT0xJQyArIHNJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIGlmICgnZXZhbCcgPT09IHNJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgb1NvdXJjZUVsZW1lbnREYXRhLm5DYXRlZ29yeSA9XG4gICAgICAgICAgICAgICAgICAgICAgIEVTb3VyY2VFbGVtZW50Q2F0ZWdvcmllcy5OX0VWQUw7XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgZkFkZElkZW50aWZpZXIoc0lkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICogQ2xhc3NpZmllcyB0aGUgc291cmNlIGVsZW1lbnQgYXMgZXhjbHVkYWJsZSBpZiBpdCBkb2VzIG5vdFxuICAgICAgICAgICAgICAqIGNvbnRhaW4gYSB7QGNvZGUgd2l0aH0gc3RhdGVtZW50IG9yIHRoZSB7QGNvZGUgZXZhbH0gaWRlbnRpZmllclxuICAgICAgICAgICAgICAqIG5hbWUuXG4gICAgICAgICAgICAgICogQHBhcmFtIHtUU3ludGFjdGljQ29kZVVuaXR9IG9FeHByZXNzaW9uIFRoZSBleHByZXNzaW9uIHdob3NlXG4gICAgICAgICAgICAgICogICAgIHZhbHVlIGlzIHRvIGJlIHJldHVybmVkLlxuICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICdyZXR1cm4nOiBmdW5jdGlvbihvRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgZkNsYXNzaWZ5QXNFeGNsdWRhYmxlKCk7XG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgKiBJbmNyZW1lbnRzIHRoZSBjb3VudCBvZiB0aGUgbnVtYmVyIG9mIG9jY3VycmVuY2VzIG9mIHRoZVxuICAgICAgICAgICAgICAqIGVuY291bnRlcmVkIFN0cmluZyB2YWx1ZS5cbiAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1N0cmluZ1ZhbHVlIFRoZSBTdHJpbmcgdmFsdWUgb2YgdGhlIHN0cmluZ1xuICAgICAgICAgICAgICAqICAgICBsaXRlcmFsIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICdzdHJpbmcnOiBmdW5jdGlvbihzU3RyaW5nVmFsdWUpIHtcbiAgICAgICAgICAgICAgIGlmIChzU3RyaW5nVmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICBmQ291bnRQcmltYXJ5RXhwcmVzc2lvbihcbiAgICAgICAgICAgICAgICAgICAgIEVQcmltYXJ5RXhwcmVzc2lvbkNhdGVnb3JpZXMuTl9TVFJJTkdfTElURVJBTFMsXG4gICAgICAgICAgICAgICAgICAgICBFVmFsdWVQcmVmaXhlcy5TX1NUUklORyArIHNTdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgKiBBZGRzIHRoZSBpZGVudGlmaWVyIHJlc2VydmVkIGZvciBhbiBleGNlcHRpb24gdG8gdGhlIGxpc3Qgb2ZcbiAgICAgICAgICAgICAgKiBpZGVudGlmaWVyIG5hbWVzIGZvdW5kLlxuICAgICAgICAgICAgICAqIEBwYXJhbSB7IVRTeW50YWN0aWNDb2RlVW5pdH0gb1RyeSBBIGJsb2NrIG9mIGNvZGUgaW4gd2hpY2ggYW5cbiAgICAgICAgICAgICAgKiAgICAgZXhjZXB0aW9uIGNhbiBvY2N1ci5cbiAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBhQ2F0Y2ggVGhlIGlkZW50aWZpZXIgcmVzZXJ2ZWQgZm9yIGFuIGV4Y2VwdGlvblxuICAgICAgICAgICAgICAqICAgICBhbmQgYSBibG9jayBvZiBjb2RlIHRvIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgICAgICAqIEBwYXJhbSB7VFN5bnRhY3RpY0NvZGVVbml0fSBvRmluYWxseSBBbiBvcHRpb25hbCBibG9jayBvZiBjb2RlXG4gICAgICAgICAgICAgICogICAgIHRvIGJlIGV2YWx1YXRlZCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgYW4gZXhjZXB0aW9uIG9jY3Vycy5cbiAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAndHJ5JzogZnVuY3Rpb24ob1RyeSwgYUNhdGNoLCBvRmluYWxseSkge1xuICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYUNhdGNoKSkge1xuICAgICAgICAgICAgICAgICBmQWRkSWRlbnRpZmllcihhQ2F0Y2hbMF0pO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICogQ2xhc3NpZmllcyB0aGUgc291cmNlIGVsZW1lbnQgYXMgZXhjbHVkYWJsZSBpZiBpdCBkb2VzIG5vdFxuICAgICAgICAgICAgICAqIGNvbnRhaW4gYSB7QGNvZGUgd2l0aH0gc3RhdGVtZW50IG9yIHRoZSB7QGNvZGUgZXZhbH0gaWRlbnRpZmllclxuICAgICAgICAgICAgICAqIG5hbWUuIEFkZHMgdGhlIGlkZW50aWZpZXIgb2YgZWFjaCBkZWNsYXJlZCB2YXJpYWJsZSB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAqIG9mIGlkZW50aWZpZXIgbmFtZXMgZm91bmQuXG4gICAgICAgICAgICAgICogQHBhcmFtIHshQXJyYXkuPCFBcnJheT59IGFWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCBWYXJpYWJsZVxuICAgICAgICAgICAgICAqICAgICBkZWNsYXJhdGlvbnMuXG4gICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgJ3Zhcic6IGZ1bmN0aW9uKGFWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCkge1xuICAgICAgICAgICAgICAgZkNsYXNzaWZ5QXNFeGNsdWRhYmxlKCk7XG4gICAgICAgICAgICAgICBhVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QuZm9yRWFjaChmQWRkVmFyaWFibGUpO1xuICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICogQ2xhc3NpZmllcyBhIHNvdXJjZSBlbGVtZW50IGFzIGNvbnRhaW5pbmcgdGhlIHtAY29kZSB3aXRofVxuICAgICAgICAgICAgICAqIHN0YXRlbWVudC5cbiAgICAgICAgICAgICAgKiBAcGFyYW0geyFUU3ludGFjdGljQ29kZVVuaXR9IG9FeHByZXNzaW9uIEFuIGV4cHJlc3Npb24gd2hvc2VcbiAgICAgICAgICAgICAgKiAgICAgdmFsdWUgaXMgdG8gYmUgY29udmVydGVkIHRvIGEgdmFsdWUgb2YgdHlwZSBPYmplY3QgYW5kXG4gICAgICAgICAgICAgICogICAgIGJlY29tZSB0aGUgYmluZGluZyBvYmplY3Qgb2YgYSBuZXcgb2JqZWN0IGVudmlyb25tZW50XG4gICAgICAgICAgICAgICogICAgIHJlY29yZCBvZiBhIG5ldyBsZXhpY2FsIGVudmlyb25tZW50IGluIHdoaWNoIHRoZSBzdGF0ZW1lbnRcbiAgICAgICAgICAgICAgKiAgICAgaXMgdG8gYmUgZXhlY3V0ZWQuXG4gICAgICAgICAgICAgICogQHBhcmFtIHshVFN5bnRhY3RpY0NvZGVVbml0fSBvU3RhdGVtZW50IFRoZSBzdGF0ZW1lbnQgdG8gYmVcbiAgICAgICAgICAgICAgKiAgICAgZXhlY3V0ZWQgaW4gdGhlIGF1Z21lbnRlZCBsZXhpY2FsIGVudmlyb25tZW50LlxuICAgICAgICAgICAgICAqIEByZXR1cm4geyFBcnJheX0gQW4gZW1wdHkgYXJyYXkgdG8gc3RvcCB0aGUgdHJhdmVyc2FsLlxuICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICd3aXRoJzogZnVuY3Rpb24ob0V4cHJlc3Npb24sIG9TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgIG9Tb3VyY2VFbGVtZW50RGF0YS5uQ2F0ZWdvcnkgPSBFU291cmNlRWxlbWVudENhdGVnb3JpZXMuTl9XSVRIO1xuICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAvKiojbm9jb2RlLSovICAvLyBKc0RvYyBUb29sa2l0IDIuNC4wIGhpZGVzIHNvbWUgb2YgdGhlIGtleXMuXG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIC8qKlxuICAgICAgICAgICAgKiBBIGNvbGxlY3Rpb24gb2YgZnVuY3Rpb25zIHVzZWQgd2hpbGUgbG9va2luZyBmb3IgbmVzdGVkIGZ1bmN0aW9ucy5cbiAgICAgICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICAgICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCBmdW5jdGlvbiguLi5bKl0pPn1cbiAgICAgICAgICAgICovXG4gICAgICAgICAgIG9FeGFtaW5lRnVuY3Rpb25zOiB7XG4gICAgICAgICAgICAgLyoqI25vY29kZSsqLyAgLy8gSnNEb2MgVG9vbGtpdCAyLjQuMCBoaWRlcyBzb21lIG9mIHRoZSBrZXlzLlxuICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAqIE9yZGVycyBhbiBleGFtaW5hdGlvbiBvZiBhIG5lc3RlZCBmdW5jdGlvbiBkZWNsYXJhdGlvbi5cbiAgICAgICAgICAgICAgKiBAdGhpcyB7IVRTeW50YWN0aWNDb2RlVW5pdH0gQW4gYXJyYXktbGlrZSBvYmplY3QgcmVwcmVzZW50aW5nXG4gICAgICAgICAgICAgICogICAgIHRoZSBicmFuY2ggb2YgYW4gPGFiYnIgdGl0bGU9XCJhYnN0cmFjdCBzeW50YXggdHJlZVwiXG4gICAgICAgICAgICAgICogICAgID5BU1Q8L2FiYnI+IHJlcHJlc2VudGluZyB0aGUgc3ludGFjdGljIGNvZGUgdW5pdCBhbG9uZyB3aXRoXG4gICAgICAgICAgICAgICogICAgIGl0cyBzY29wZS5cbiAgICAgICAgICAgICAgKiBAcmV0dXJuIHshQXJyYXl9IEFuIGVtcHR5IGFycmF5IHRvIHN0b3AgdGhlIHRyYXZlcnNhbC5cbiAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAnZGVmdW4nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgIGZFeGFtaW5lU3ludGFjdGljQ29kZVVuaXQodGhpcyk7XG4gICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgKiBPcmRlcnMgYW4gZXhhbWluYXRpb24gb2YgYSBuZXN0ZWQgZnVuY3Rpb24gZXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAgKiBAdGhpcyB7IVRTeW50YWN0aWNDb2RlVW5pdH0gQW4gYXJyYXktbGlrZSBvYmplY3QgcmVwcmVzZW50aW5nXG4gICAgICAgICAgICAgICogICAgIHRoZSBicmFuY2ggb2YgYW4gPGFiYnIgdGl0bGU9XCJhYnN0cmFjdCBzeW50YXggdHJlZVwiXG4gICAgICAgICAgICAgICogICAgID5BU1Q8L2FiYnI+IHJlcHJlc2VudGluZyB0aGUgc3ludGFjdGljIGNvZGUgdW5pdCBhbG9uZyB3aXRoXG4gICAgICAgICAgICAgICogICAgIGl0cyBzY29wZS5cbiAgICAgICAgICAgICAgKiBAcmV0dXJuIHshQXJyYXl9IEFuIGVtcHR5IGFycmF5IHRvIHN0b3AgdGhlIHRyYXZlcnNhbC5cbiAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAnZnVuY3Rpb24nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgIGZFeGFtaW5lU3ludGFjdGljQ29kZVVuaXQodGhpcyk7XG4gICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgIC8qKiNub2NvZGUtKi8gIC8vIEpzRG9jIFRvb2xraXQgMi40LjAgaGlkZXMgc29tZSBvZiB0aGUga2V5cy5cbiAgICAgICAgICAgfVxuICAgICAgICAgfSxcbiAgICAgICAgIC8qKlxuICAgICAgICAgICogUmVjb3JkcyBjb250YWluaW5nIGRhdGEgYWJvdXQgc291cmNlIGVsZW1lbnRzLlxuICAgICAgICAgICogQHR5cGUge0FycmF5LjxUU291cmNlRWxlbWVudHNEYXRhPn1cbiAgICAgICAgICAqL1xuICAgICAgICAgYVNvdXJjZUVsZW1lbnRzRGF0YSA9IFtdLFxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBUaGUgaW5kZXggKGluIHRoZSBzb3VyY2UgdGV4dCBvcmRlcikgb2YgdGhlIHNvdXJjZSBlbGVtZW50XG4gICAgICAgICAgKiBpbW1lZGlhdGVseSBmb2xsb3dpbmcgYSA8YSBocmVmPVwiaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTQuMVwiXG4gICAgICAgICAgKiA+RGlyZWN0aXZlIFByb2xvZ3VlPC9hPi5cbiAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgKi9cbiAgICAgICAgIG5BZnRlckRpcmVjdGl2ZVByb2xvZ3VlID0gMCxcbiAgICAgICAgIC8qKlxuICAgICAgICAgICogVGhlIGluZGV4IChpbiB0aGUgc291cmNlIHRleHQgb3JkZXIpIG9mIHRoZSBzb3VyY2UgZWxlbWVudCB0aGF0IGlzXG4gICAgICAgICAgKiBjdXJyZW50bHkgYmVpbmcgY29uc2lkZXJlZC5cbiAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgKi9cbiAgICAgICAgIG5Qb3NpdGlvbixcbiAgICAgICAgIC8qKlxuICAgICAgICAgICogVGhlIGluZGV4IChpbiB0aGUgc291cmNlIHRleHQgb3JkZXIpIG9mIHRoZSBzb3VyY2UgZWxlbWVudCB0aGF0IGlzXG4gICAgICAgICAgKiB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSByYW5nZSBvZiBzb3VyY2UgZWxlbWVudHMgdGhhdCBpcyBjdXJyZW50bHlcbiAgICAgICAgICAqIGJlaW5nIGNvbnNpZGVyZWQuXG4gICAgICAgICAgKiBAdHlwZSB7KHVuZGVmaW5lZHxudW1iZXIpfVxuICAgICAgICAgICovXG4gICAgICAgICBuVG8sXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIEluaXRpYXRlcyB0aGUgdHJhdmVyc2FsIG9mIGEgc291cmNlIGVsZW1lbnQuXG4gICAgICAgICAgKiBAcGFyYW0geyFUV2Fsa2VyfSBvV2Fsa2VyIEFuIGluc3RhbmNlIG9mIGFuIG9iamVjdCB0aGF0IGFsbG93cyB0aGVcbiAgICAgICAgICAqICAgICB0cmF2ZXJzYWwgb2YgYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWUuXG4gICAgICAgICAgKiBAcGFyYW0geyFUU3ludGFjdGljQ29kZVVuaXR9IG9Tb3VyY2VFbGVtZW50IEEgc291cmNlIGVsZW1lbnQgZnJvbVxuICAgICAgICAgICogICAgIHdoaWNoIHRoZSB0cmF2ZXJzYWwgc2hvdWxkIGNvbW1lbmNlLlxuICAgICAgICAgICogQHJldHVybiB7ZnVuY3Rpb24oKTogIVRTeW50YWN0aWNDb2RlVW5pdH0gQSBmdW5jdGlvbiB0aGF0IGlzIGFibGUgdG9cbiAgICAgICAgICAqICAgICBpbml0aWF0ZSB0aGUgdHJhdmVyc2FsIGZyb20gYSBnaXZlbiBzb3VyY2UgZWxlbWVudC5cbiAgICAgICAgICAqL1xuICAgICAgICAgY0NvbnRleHQgPSBmdW5jdGlvbihvV2Fsa2VyLCBvU291cmNlRWxlbWVudCkge1xuICAgICAgICAgICAvKipcbiAgICAgICAgICAgICogQHJldHVybiB7IVRTeW50YWN0aWNDb2RlVW5pdH0gQSBmdW5jdGlvbiB0aGF0IGlzIGFibGUgdG9cbiAgICAgICAgICAgICogICAgIGluaXRpYXRlIHRoZSB0cmF2ZXJzYWwgZnJvbSBhIGdpdmVuIHNvdXJjZSBlbGVtZW50LlxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgdmFyIGZMYW1iZGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICByZXR1cm4gb1dhbGtlci53YWxrKG9Tb3VyY2VFbGVtZW50KTtcbiAgICAgICAgICAgfTtcblxuICAgICAgICAgICByZXR1cm4gZkxhbWJkYTtcbiAgICAgICAgIH0sXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIENsYXNzaWZpZXMgdGhlIHNvdXJjZSBlbGVtZW50IGFzIGV4Y2x1ZGFibGUgaWYgaXQgZG9lcyBub3RcbiAgICAgICAgICAqIGNvbnRhaW4gYSB7QGNvZGUgd2l0aH0gc3RhdGVtZW50IG9yIHRoZSB7QGNvZGUgZXZhbH0gaWRlbnRpZmllclxuICAgICAgICAgICogbmFtZS5cbiAgICAgICAgICAqL1xuICAgICAgICAgZkNsYXNzaWZ5QXNFeGNsdWRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIGlmIChvU291cmNlRWxlbWVudERhdGEubkNhdGVnb3J5ID09PVxuICAgICAgICAgICAgICAgRVNvdXJjZUVsZW1lbnRDYXRlZ29yaWVzLk5fT1RIRVIpIHtcbiAgICAgICAgICAgICBvU291cmNlRWxlbWVudERhdGEubkNhdGVnb3J5ID1cbiAgICAgICAgICAgICAgICAgRVNvdXJjZUVsZW1lbnRDYXRlZ29yaWVzLk5fRVhDTFVEQUJMRTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfSxcbiAgICAgICAgIC8qKlxuICAgICAgICAgICogQWRkcyBhbiBpZGVudGlmaWVyIHRvIHRoZSBsaXN0IG9mIGlkZW50aWZpZXIgbmFtZXMgZm91bmQuXG4gICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc0lkZW50aWZpZXIgVGhlIGlkZW50aWZpZXIgdG8gYmUgYWRkZWQuXG4gICAgICAgICAgKi9cbiAgICAgICAgIGZBZGRJZGVudGlmaWVyID0gZnVuY3Rpb24oc0lkZW50aWZpZXIpIHtcbiAgICAgICAgICAgaWYgKC0xID09PSBvU291cmNlRWxlbWVudERhdGEuYUlkZW50aWZpZXJzLmluZGV4T2Yoc0lkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICAgb1NvdXJjZUVsZW1lbnREYXRhLmFJZGVudGlmaWVycy5wdXNoKHNJZGVudGlmaWVyKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfSxcbiAgICAgICAgIC8qKlxuICAgICAgICAgICogQWRkcyB0aGUgaWRlbnRpZmllciBvZiBhIHZhcmlhYmxlIHRvIHRoZSBsaXN0IG9mIGlkZW50aWZpZXIgbmFtZXNcbiAgICAgICAgICAqIGZvdW5kLlxuICAgICAgICAgICogQHBhcmFtIHshQXJyYXl9IGFWYXJpYWJsZURlY2xhcmF0aW9uIEEgdmFyaWFibGUgZGVjbGFyYXRpb24uXG4gICAgICAgICAgKi9cbiAgICAgICAgIGZBZGRWYXJpYWJsZSA9IGZ1bmN0aW9uKGFWYXJpYWJsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgIGZBZGRJZGVudGlmaWVyKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyBhVmFyaWFibGVEZWNsYXJhdGlvblswXSk7XG4gICAgICAgICB9LFxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBJbmNyZW1lbnRzIHRoZSBjb3VudCBvZiB0aGUgbnVtYmVyIG9mIG9jY3VycmVuY2VzIG9mIHRoZSBwcmVmaXhlZFxuICAgICAgICAgICogU3RyaW5nIHJlcHJlc2VudGF0aW9uIGF0dHJpYnV0ZWQgdG8gdGhlIHByaW1hcnkgZXhwcmVzc2lvbi5cbiAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuQ2F0ZWdvcnkgVGhlIGNhdGVnb3J5IG9mIHRoZSBwcmltYXJ5IGV4cHJlc3Npb24uXG4gICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc05hbWUgVGhlIHByZWZpeGVkIFN0cmluZyByZXByZXNlbnRhdGlvbiBhdHRyaWJ1dGVkXG4gICAgICAgICAgKiAgICAgdG8gdGhlIHByaW1hcnkgZXhwcmVzc2lvbi5cbiAgICAgICAgICAqL1xuICAgICAgICAgZkNvdW50UHJpbWFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbihuQ2F0ZWdvcnksIHNOYW1lKSB7XG4gICAgICAgICAgIGlmICghb1NvdXJjZUVsZW1lbnREYXRhLmFDb3VudFtuQ2F0ZWdvcnldLmhhc093blByb3BlcnR5KHNOYW1lKSkge1xuICAgICAgICAgICAgIG9Tb3VyY2VFbGVtZW50RGF0YS5hQ291bnRbbkNhdGVnb3J5XVtzTmFtZV0gPSAwO1xuICAgICAgICAgICAgIGlmICgtMSA9PT0gb1NvdXJjZUVsZW1lbnREYXRhLmFQcmltaXRpdmVWYWx1ZXMuaW5kZXhPZihzTmFtZSkpIHtcbiAgICAgICAgICAgICAgIG9Tb3VyY2VFbGVtZW50RGF0YS5hUHJpbWl0aXZlVmFsdWVzLnB1c2goc05hbWUpO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgICBvU291cmNlRWxlbWVudERhdGEuYUNvdW50W25DYXRlZ29yeV1bc05hbWVdICs9IDE7XG4gICAgICAgICB9LFxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBDb25zb2xpZGF0ZXMgYWxsIHdvcnRod2hpbGUgcHJpbWl0aXZlIHZhbHVlcyBpbiBhIHJhbmdlIG9mIHNvdXJjZVxuICAgICAgICAgICogICAgIGVsZW1lbnRzLlxuICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5Gcm9tIFRoZSBpbmRleCAoaW4gdGhlIHNvdXJjZSB0ZXh0IG9yZGVyKSBvZiB0aGVcbiAgICAgICAgICAqICAgICBzb3VyY2UgZWxlbWVudCB0aGF0IGlzIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSByYW5nZS5cbiAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuVG8gVGhlIGluZGV4IChpbiB0aGUgc291cmNlIHRleHQgb3JkZXIpIG9mIHRoZVxuICAgICAgICAgICogICAgIHNvdXJjZSBlbGVtZW50IHRoYXQgaXMgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgcmFuZ2UuXG4gICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJFbmNsb3NlIEluZGljYXRlcyB3aGV0aGVyIHRoZSByYW5nZSBzaG91bGQgYmVcbiAgICAgICAgICAqICAgICBlbmNsb3NlZCB3aXRoaW4gYSBmdW5jdGlvbiBjYWxsIHdpdGggbm8gYXJndW1lbnQgdmFsdWVzIHRvIGFcbiAgICAgICAgICAqICAgICBmdW5jdGlvbiB3aXRoIGFuIGVtcHR5IHBhcmFtZXRlciBsaXN0IGlmIGFueSBwcmltaXRpdmUgdmFsdWVzXG4gICAgICAgICAgKiAgICAgYXJlIGNvbnNvbGlkYXRlZC5cbiAgICAgICAgICAqIEBzZWUgVFByaW1pdGl2ZVZhbHVlI25TYXZpbmdcbiAgICAgICAgICAqL1xuICAgICAgICAgZkV4YW1pbmVTb3VyY2VFbGVtZW50cyA9IGZ1bmN0aW9uKG5Gcm9tLCBuVG8sIGJFbmNsb3NlKSB7XG4gICAgICAgICAgIHZhciBfLFxuICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGxhc3QgbWFuZ2xlZCBuYW1lLlxuICAgICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgbkluZGV4ID0gb1Njb3BlLmNuYW1lLFxuICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBUaGUgaW5kZXggb2YgdGhlIHNvdXJjZSBlbGVtZW50IHRoYXQgaXMgY3VycmVudGx5IGJlaW5nXG4gICAgICAgICAgICAgICAgKiBjb25zaWRlcmVkLlxuICAgICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgblBvc2l0aW9uLFxuICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBBIGNvbGxlY3Rpb24gb2YgZnVuY3Rpb25zIHVzZWQgZHVyaW5nIHRoZSBjb25zb2xpZGF0aW9uIG9mXG4gICAgICAgICAgICAgICAgKiBwcmltaXRpdmUgdmFsdWVzIGFuZCBpZGVudGlmaWVyIG5hbWVzIHVzZWQgYXMgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAqIGFjY2Vzc29ycy5cbiAgICAgICAgICAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAgICAgICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uKC4uLlsqXSk+fVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICBvV2Fsa2Vyc1RyYW5zZm9ybWVycyA9IHtcbiAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAqIElmIHRoZSBTdHJpbmcgdmFsdWUgdGhhdCBpcyBlcXVpdmFsZW50IHRvIHRoZSBzZXF1ZW5jZSBvZlxuICAgICAgICAgICAgICAgICAgKiB0ZXJtaW5hbCBzeW1ib2xzIHRoYXQgY29uc3RpdHV0ZSB0aGUgZW5jb3VudGVyZWQgaWRlbnRpZmllclxuICAgICAgICAgICAgICAgICAgKiBuYW1lIGlzIHdvcnRod2hpbGUsIGEgc3ludGFjdGljIGNvbnZlcnNpb24gZnJvbSB0aGUgZG90XG4gICAgICAgICAgICAgICAgICAqIG5vdGF0aW9uIHRvIHRoZSBicmFja2V0IG5vdGF0aW9uIGVuc3VlcyB3aXRoIHRoYXQgc2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICogYmVpbmcgc3Vic3RpdHV0ZWQgYnkgYW4gaWRlbnRpZmllciBuYW1lIHRvIHdoaWNoIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgKiBpcyBhc3NpZ25lZC5cbiAgICAgICAgICAgICAgICAgICogQXBwbGllcyB0byBwcm9wZXJ0eSBhY2Nlc3NvcnMgdGhhdCB1c2UgdGhlIGRvdCBub3RhdGlvbi5cbiAgICAgICAgICAgICAgICAgICogQHBhcmFtIHshVFN5bnRhY3RpY0NvZGVVbml0fSBvRXhwcmVzc2lvbiBUaGUgbm9udGVybWluYWxcbiAgICAgICAgICAgICAgICAgICogICAgIE1lbWJlckV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzSWRlbnRpZmllck5hbWUgVGhlIGlkZW50aWZpZXIgbmFtZSB1c2VkIGFzXG4gICAgICAgICAgICAgICAgICAqICAgICB0aGUgcHJvcGVydHkgYWNjZXNzb3IuXG4gICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFBcnJheX0gQSBzeW50YWN0aWMgY29kZSB1bml0IHRoYXQgaXMgZXF1aXZhbGVudCB0b1xuICAgICAgICAgICAgICAgICAgKiAgICAgdGhlIG9uZSBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgICAgICAgICogQHNlZSBUUHJpbWl0aXZlVmFsdWUjblNhdmluZ1xuICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgJ2RvdCc6IGZ1bmN0aW9uKG9FeHByZXNzaW9uLCBzSWRlbnRpZmllck5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgKiBUaGUgcHJlZml4ZWQgU3RyaW5nIHZhbHVlIHRoYXQgaXMgZXF1aXZhbGVudCB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgKiBzZXF1ZW5jZSBvZiB0ZXJtaW5hbCBzeW1ib2xzIHRoYXQgY29uc3RpdHV0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgKiBlbmNvdW50ZXJlZCBpZGVudGlmaWVyIG5hbWUuXG4gICAgICAgICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICB2YXIgc1ByZWZpeGVkID0gRVZhbHVlUHJlZml4ZXMuU19TVFJJTkcgKyBzSWRlbnRpZmllck5hbWU7XG5cbiAgICAgICAgICAgICAgICAgICByZXR1cm4gb1NvbHV0aW9uQmVzdC5vUHJpbWl0aXZlVmFsdWVzLmhhc093blByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAgICBzUHJlZml4ZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgIG9Tb2x1dGlvbkJlc3Qub1ByaW1pdGl2ZVZhbHVlc1tzUHJlZml4ZWRdLm5TYXZpbmcgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgWydzdWInLFxuICAgICAgICAgICAgICAgICAgICAgICAgb1dhbGtlci53YWxrKG9FeHByZXNzaW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFsnbmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgb1NvbHV0aW9uQmVzdC5vUHJpbWl0aXZlVmFsdWVzW3NQcmVmaXhlZF0uc05hbWVdXSA6XG4gICAgICAgICAgICAgICAgICAgICAgIFsnZG90Jywgb1dhbGtlci53YWxrKG9FeHByZXNzaW9uKSwgc0lkZW50aWZpZXJOYW1lXTtcbiAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAqIElmIHRoZSBlbmNvdW50ZXJlZCBpZGVudGlmaWVyIGlzIGEgbnVsbCBvciBCb29sZWFuIGxpdGVyYWxcbiAgICAgICAgICAgICAgICAgICogYW5kIGl0cyB2YWx1ZSBpcyB3b3J0aHdoaWxlLCB0aGUgaWRlbnRpZmllciBpcyBzdWJzdGl0dXRlZFxuICAgICAgICAgICAgICAgICAgKiBieSBhbiBpZGVudGlmaWVyIG5hbWUgdG8gd2hpY2ggdGhhdCB2YWx1ZSBpcyBhc3NpZ25lZC5cbiAgICAgICAgICAgICAgICAgICogQXBwbGllcyB0byBpZGVudGlmaWVyIG5hbWVzLlxuICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc0lkZW50aWZpZXIgVGhlIGlkZW50aWZpZXIgZW5jb3VudGVyZWQuXG4gICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFBcnJheX0gQSBzeW50YWN0aWMgY29kZSB1bml0IHRoYXQgaXMgZXF1aXZhbGVudCB0b1xuICAgICAgICAgICAgICAgICAgKiAgICAgdGhlIG9uZSBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgICAgICAgICogQHNlZSBUUHJpbWl0aXZlVmFsdWUjblNhdmluZ1xuICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgJ25hbWUnOiBmdW5jdGlvbihzSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAqIFRoZSBwcmVmaXhlZCByZXByZXNlbnRhdGlvbiBTdHJpbmcgb2YgdGhlIGlkZW50aWZpZXIuXG4gICAgICAgICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICB2YXIgc1ByZWZpeGVkID0gRVZhbHVlUHJlZml4ZXMuU19TWU1CT0xJQyArIHNJZGVudGlmaWVyO1xuXG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICduYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgIG9Tb2x1dGlvbkJlc3Qub1ByaW1pdGl2ZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eShzUHJlZml4ZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICBvU29sdXRpb25CZXN0Lm9QcmltaXRpdmVWYWx1ZXNbc1ByZWZpeGVkXS5uU2F2aW5nID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICBvU29sdXRpb25CZXN0Lm9QcmltaXRpdmVWYWx1ZXNbc1ByZWZpeGVkXS5zTmFtZSA6XG4gICAgICAgICAgICAgICAgICAgICBzSWRlbnRpZmllclxuICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgZW5jb3VudGVyZWQgU3RyaW5nIHZhbHVlIGlzIHdvcnRod2hpbGUsIGl0IGlzXG4gICAgICAgICAgICAgICAgICAqIHN1YnN0aXR1dGVkIGJ5IGFuIGlkZW50aWZpZXIgbmFtZSB0byB3aGljaCB0aGF0IHZhbHVlIGlzXG4gICAgICAgICAgICAgICAgICAqIGFzc2lnbmVkLlxuICAgICAgICAgICAgICAgICAgKiBBcHBsaWVzIHRvIFN0cmluZyB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzU3RyaW5nVmFsdWUgVGhlIFN0cmluZyB2YWx1ZSBvZiB0aGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAqICAgICBsaXRlcmFsIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshQXJyYXl9IEEgc3ludGFjdGljIGNvZGUgdW5pdCB0aGF0IGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgICAgICAgICAgICAgICogICAgIHRoZSBvbmUgZW5jb3VudGVyZWQuXG4gICAgICAgICAgICAgICAgICAqIEBzZWUgVFByaW1pdGl2ZVZhbHVlI25TYXZpbmdcbiAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICdzdHJpbmcnOiBmdW5jdGlvbihzU3RyaW5nVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgKiBUaGUgcHJlZml4ZWQgcmVwcmVzZW50YXRpb24gU3RyaW5nIG9mIHRoZSBwcmltaXRpdmUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgKiBvZiB0aGUgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgIHZhciBzUHJlZml4ZWQgPVxuICAgICAgICAgICAgICAgICAgICAgICBFVmFsdWVQcmVmaXhlcy5TX1NUUklORyArIHNTdHJpbmdWYWx1ZTtcblxuICAgICAgICAgICAgICAgICAgIHJldHVybiBvU29sdXRpb25CZXN0Lm9QcmltaXRpdmVWYWx1ZXMuaGFzT3duUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgIHNQcmVmaXhlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgb1NvbHV0aW9uQmVzdC5vUHJpbWl0aXZlVmFsdWVzW3NQcmVmaXhlZF0ublNhdmluZyA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICBbJ25hbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgb1NvbHV0aW9uQmVzdC5vUHJpbWl0aXZlVmFsdWVzW3NQcmVmaXhlZF0uc05hbWVdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgWydzdHJpbmcnLCBzU3RyaW5nVmFsdWVdO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBTdWNoIGRhdGEgb24gd2hhdCB0byBjb25zb2xpZGF0ZSB3aXRoaW4gdGhlIHJhbmdlIG9mIHNvdXJjZVxuICAgICAgICAgICAgICAgICogZWxlbWVudHMgdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgY29uc2lkZXJlZCB0aGF0IGxlYWQgdG8gdGhlXG4gICAgICAgICAgICAgICAgKiBncmVhdGVzdCBrbm93biByZWR1Y3Rpb24gb2YgdGhlIG51bWJlciBvZiB0aGUgdGVybWluYWwgc3ltYm9sc1xuICAgICAgICAgICAgICAgICogaW4gY29tcGFyaXNvbiB0byB0aGUgb3JpZ2luYWwgc291cmNlIHRleHQuXG4gICAgICAgICAgICAgICAgKiBAdHlwZSB7IVRTb2x1dGlvbn1cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgb1NvbHV0aW9uQmVzdCA9IG5ldyBUU29sdXRpb24oKSxcbiAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICogRGF0YSByZXByZXNlbnRpbmcgYW4gb25nb2luZyBhdHRlbXB0IHRvIGZpbmQgYSBiZXR0ZXJcbiAgICAgICAgICAgICAgICAqIHJlZHVjdGlvbiBvZiB0aGUgbnVtYmVyIG9mIHRoZSB0ZXJtaW5hbCBzeW1ib2xzIGluIGNvbXBhcmlzb25cbiAgICAgICAgICAgICAgICAqIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGV4dCB0aGFuIHRoZSBiZXN0IG9uZSB0aGF0IGlzXG4gICAgICAgICAgICAgICAgKiBjdXJyZW50bHkga25vd24uXG4gICAgICAgICAgICAgICAgKiBAdHlwZSB7IVRTb2x1dGlvbn1cbiAgICAgICAgICAgICAgICAqIEBzZWUgb1NvbHV0aW9uQmVzdFxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICBvU29sdXRpb25DYW5kaWRhdGUgPSBuZXcgVFNvbHV0aW9uKCksXG4gICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAqIEEgcmVjb3JkIGNvbnNpc3Rpbmcgb2YgZGF0YSBhYm91dCB0aGUgcmFuZ2Ugb2Ygc291cmNlIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgKiB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBleGFtaW5lZC5cbiAgICAgICAgICAgICAgICAqIEB0eXBlIHshVFNvdXJjZUVsZW1lbnRzRGF0YX1cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgb1NvdXJjZUVsZW1lbnRzRGF0YSA9IG5ldyBUU291cmNlRWxlbWVudHNEYXRhKCksXG4gICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAqIFZhcmlhYmxlIGRlY2xhcmF0aW9ucyBmb3IgZWFjaCBwcmltaXRpdmUgdmFsdWUgdGhhdCBpcyB0byBiZVxuICAgICAgICAgICAgICAgICogY29uc29saWRhdGVkIHdpdGhpbiB0aGUgZWxlbWVudHMuXG4gICAgICAgICAgICAgICAgKiBAdHlwZSB7IUFycmF5LjwhQXJyYXk+fVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICBhVmFyaWFibGVEZWNsYXJhdGlvbnMgPSBbXSxcbiAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICogQXVnbWVudHMgYSBsaXN0IHdpdGggYSBwcmVmaXhlZCByZXByZXNlbnRhdGlvbiBTdHJpbmcuXG4gICAgICAgICAgICAgICAgKiBAcGFyYW0geyFBcnJheS48c3RyaW5nPn0gYUxpc3QgQSBsaXN0IHRoYXQgaXMgdG8gYmUgYXVnbWVudGVkLlxuICAgICAgICAgICAgICAgICogQHJldHVybiB7ZnVuY3Rpb24oc3RyaW5nKX0gQSBmdW5jdGlvbiB0aGF0IGF1Z21lbnRzIGEgbGlzdFxuICAgICAgICAgICAgICAgICogICAgIHdpdGggYSBwcmVmaXhlZCByZXByZXNlbnRhdGlvbiBTdHJpbmcuXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgIGNBdWdtZW50TGlzdCA9IGZ1bmN0aW9uKGFMaXN0KSB7XG4gICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1ByZWZpeGVkIFByZWZpeGVkIHJlcHJlc2VudGF0aW9uIFN0cmluZyBvZlxuICAgICAgICAgICAgICAgICAgKiAgICAgYSBwcmltaXRpdmUgdmFsdWUgdGhhdCBjb3VsZCBiZSBjb25zb2xpZGF0ZWQgd2l0aGluIHRoZVxuICAgICAgICAgICAgICAgICAgKiAgICAgZWxlbWVudHMuXG4gICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICB2YXIgZkxhbWJkYSA9IGZ1bmN0aW9uKHNQcmVmaXhlZCkge1xuICAgICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gYUxpc3QuaW5kZXhPZihzUHJlZml4ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICBhTGlzdC5wdXNoKHNQcmVmaXhlZCk7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgIHJldHVybiBmTGFtYmRhO1xuICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICogQWRkcyB0aGUgbnVtYmVyIG9mIG9jY3VycmVuY2VzIG9mIGEgcHJpbWl0aXZlIHZhbHVlIG9mIGEgZ2l2ZW5cbiAgICAgICAgICAgICAgICAqIGNhdGVnb3J5IHRoYXQgY291bGQgYmUgY29uc29saWRhdGVkIGluIHRoZSBzb3VyY2UgZWxlbWVudCB3aXRoXG4gICAgICAgICAgICAgICAgKiBhIGdpdmVuIGluZGV4IHRvIHRoZSBjb3VudCBvZiBvY2N1cnJlbmNlcyBvZiB0aGF0IHByaW1pdGl2ZVxuICAgICAgICAgICAgICAgICogdmFsdWUgd2l0aGluIHRoZSByYW5nZSBvZiBzb3VyY2UgZWxlbWVudHMgdGhhdCBpcyBjdXJyZW50bHlcbiAgICAgICAgICAgICAgICAqIGJlaW5nIGNvbnNpZGVyZWQuXG4gICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gblBvc2l0aW9uIFRoZSBpbmRleCAoaW4gdGhlIHNvdXJjZSB0ZXh0IG9yZGVyKVxuICAgICAgICAgICAgICAgICogICAgIG9mIGEgc291cmNlIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbkNhdGVnb3J5IFRoZSBjYXRlZ29yeSBvZiB0aGUgcHJpbWFyeVxuICAgICAgICAgICAgICAgICogICAgIGV4cHJlc3Npb24gZnJvbSB3aGljaCB0aGUgcHJpbWl0aXZlIHZhbHVlIGlzIGRlcml2ZWQuXG4gICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbihzdHJpbmcpfSBBIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgdGhlXG4gICAgICAgICAgICAgICAgKiAgICAgYWRkaXRpb24uXG4gICAgICAgICAgICAgICAgKiBAc2VlIGNBZGRPY2N1cnJlbmNlc0luQ2F0ZWdvcnlcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgY0FkZE9jY3VycmVuY2VzID0gZnVuY3Rpb24oblBvc2l0aW9uLCBuQ2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzUHJlZml4ZWQgVGhlIHByZWZpeGVkIHJlcHJlc2VudGF0aW9uIFN0cmluZ1xuICAgICAgICAgICAgICAgICAgKiAgICAgb2YgYSBwcmltaXRpdmUgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICB2YXIgZkxhbWJkYSA9IGZ1bmN0aW9uKHNQcmVmaXhlZCkge1xuICAgICAgICAgICAgICAgICAgIGlmICghb1NvdXJjZUVsZW1lbnRzRGF0YS5hQ291bnRbbkNhdGVnb3J5XS5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHNQcmVmaXhlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgIG9Tb3VyY2VFbGVtZW50c0RhdGEuYUNvdW50W25DYXRlZ29yeV1bc1ByZWZpeGVkXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIG9Tb3VyY2VFbGVtZW50c0RhdGEuYUNvdW50W25DYXRlZ29yeV1bc1ByZWZpeGVkXSArPVxuICAgICAgICAgICAgICAgICAgICAgICBhU291cmNlRWxlbWVudHNEYXRhW25Qb3NpdGlvbl0uYUNvdW50W25DYXRlZ29yeV1bXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzUHJlZml4ZWRdO1xuICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgIHJldHVybiBmTGFtYmRhO1xuICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICogQWRkcyB0aGUgbnVtYmVyIG9mIG9jY3VycmVuY2VzIG9mIGVhY2ggcHJpbWl0aXZlIHZhbHVlIG9mIGFcbiAgICAgICAgICAgICAgICAqIGdpdmVuIGNhdGVnb3J5IHRoYXQgY291bGQgYmUgY29uc29saWRhdGVkIGluIHRoZSBzb3VyY2VcbiAgICAgICAgICAgICAgICAqIGVsZW1lbnQgd2l0aCBhIGdpdmVuIGluZGV4IHRvIHRoZSBjb3VudCBvZiBvY2N1cnJlbmNlcyBvZiB0aGF0XG4gICAgICAgICAgICAgICAgKiBwcmltaXRpdmUgdmFsdWVzIHdpdGhpbiB0aGUgcmFuZ2Ugb2Ygc291cmNlIGVsZW1lbnRzIHRoYXQgaXNcbiAgICAgICAgICAgICAgICAqIGN1cnJlbnRseSBiZWluZyBjb25zaWRlcmVkLlxuICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5Qb3NpdGlvbiBUaGUgaW5kZXggKGluIHRoZSBzb3VyY2UgdGV4dCBvcmRlcilcbiAgICAgICAgICAgICAgICAqICAgICBvZiBhIHNvdXJjZSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICogQHJldHVybiB7ZnVuY3Rpb24obnVtYmVyKX0gQSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIHRoZVxuICAgICAgICAgICAgICAgICogICAgIGFkZGl0aW9uLlxuICAgICAgICAgICAgICAgICogQHNlZSBmQWRkT2NjdXJyZW5jZXNcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgY0FkZE9jY3VycmVuY2VzSW5DYXRlZ29yeSA9IGZ1bmN0aW9uKG5Qb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5DYXRlZ29yeSBUaGUgY2F0ZWdvcnkgb2YgdGhlIHByaW1hcnlcbiAgICAgICAgICAgICAgICAgICogICAgIGV4cHJlc3Npb24gZnJvbSB3aGljaCB0aGUgcHJpbWl0aXZlIHZhbHVlIGlzIGRlcml2ZWQuXG4gICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICB2YXIgZkxhbWJkYSA9IGZ1bmN0aW9uKG5DYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKFxuICAgICAgICAgICAgICAgICAgICAgICBhU291cmNlRWxlbWVudHNEYXRhW25Qb3NpdGlvbl0uYUNvdW50W25DYXRlZ29yeV1cbiAgICAgICAgICAgICAgICAgICApLmZvckVhY2goY0FkZE9jY3VycmVuY2VzKG5Qb3NpdGlvbiwgbkNhdGVnb3J5KSk7XG4gICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgcmV0dXJuIGZMYW1iZGE7XG4gICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBBZGRzIHRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgb2YgZWFjaCBwcmltaXRpdmUgdmFsdWUgdGhhdFxuICAgICAgICAgICAgICAgICogY291bGQgYmUgY29uc29saWRhdGVkIGluIHRoZSBzb3VyY2UgZWxlbWVudCB3aXRoIGEgZ2l2ZW4gaW5kZXhcbiAgICAgICAgICAgICAgICAqIHRvIHRoZSBjb3VudCBvZiBvY2N1cnJlbmNlcyBvZiB0aGF0IHByaW1pdGl2ZSB2YWx1ZXMgd2l0aGluXG4gICAgICAgICAgICAgICAgKiB0aGUgcmFuZ2Ugb2Ygc291cmNlIGVsZW1lbnRzIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nXG4gICAgICAgICAgICAgICAgKiBjb25zaWRlcmVkLlxuICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5Qb3NpdGlvbiBUaGUgaW5kZXggKGluIHRoZSBzb3VyY2UgdGV4dCBvcmRlcilcbiAgICAgICAgICAgICAgICAqICAgICBvZiBhIHNvdXJjZSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICBmQWRkT2NjdXJyZW5jZXMgPSBmdW5jdGlvbihuUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoYVNvdXJjZUVsZW1lbnRzRGF0YVtuUG9zaXRpb25dLmFDb3VudCkuZm9yRWFjaChcbiAgICAgICAgICAgICAgICAgICAgIGNBZGRPY2N1cnJlbmNlc0luQ2F0ZWdvcnkoblBvc2l0aW9uKSk7XG4gICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBDcmVhdGVzIGEgdmFyaWFibGUgZGVjbGFyYXRpb24gZm9yIGEgcHJpbWl0aXZlIHZhbHVlIGlmIHRoYXRcbiAgICAgICAgICAgICAgICAqIHByaW1pdGl2ZSB2YWx1ZSBpcyB0byBiZSBjb25zb2xpZGF0ZWQgd2l0aGluIHRoZSBlbGVtZW50cy5cbiAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzUHJlZml4ZWQgUHJlZml4ZWQgcmVwcmVzZW50YXRpb24gU3RyaW5nIG9mIGFcbiAgICAgICAgICAgICAgICAqICAgICBwcmltaXRpdmUgdmFsdWUgdGhhdCBjb3VsZCBiZSBjb25zb2xpZGF0ZWQgd2l0aGluIHRoZVxuICAgICAgICAgICAgICAgICogICAgIGVsZW1lbnRzLlxuICAgICAgICAgICAgICAgICogQHNlZSBhVmFyaWFibGVEZWNsYXJhdGlvbnNcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgY0F1Z21lbnRWYXJpYWJsZURlY2xhcmF0aW9ucyA9IGZ1bmN0aW9uKHNQcmVmaXhlZCkge1xuICAgICAgICAgICAgICAgICBpZiAob1NvbHV0aW9uQmVzdC5vUHJpbWl0aXZlVmFsdWVzW3NQcmVmaXhlZF0ublNhdmluZyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICBhVmFyaWFibGVEZWNsYXJhdGlvbnMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICBvU29sdXRpb25CZXN0Lm9QcmltaXRpdmVWYWx1ZXNbc1ByZWZpeGVkXS5zTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgIFswID09PSBzUHJlZml4ZWQuaW5kZXhPZihFVmFsdWVQcmVmaXhlcy5TX1NZTUJPTElDKSA/XG4gICAgICAgICAgICAgICAgICAgICAgJ25hbWUnIDogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgc1ByZWZpeGVkLnN1YnN0cmluZyhFVmFsdWVQcmVmaXhlcy5TX1NZTUJPTElDLmxlbmd0aCldXG4gICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAqIFNvcnRzIHByaW1pdGl2ZSB2YWx1ZXMgd2l0aCByZWdhcmQgdG8gdGhlIGRpZmZlcmVuY2UgaW4gdGhlXG4gICAgICAgICAgICAgICAgKiBudW1iZXIgb2YgdGVybWluYWwgc3ltYm9scyBiZXR3ZWVuIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGV4dFxuICAgICAgICAgICAgICAgICogYW5kIHRoZSBvbmUgd2l0aCB0aG9zZSBwcmltaXRpdmUgdmFsdWVzIGNvbnNvbGlkYXRlZC5cbiAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzUHJlZml4ZWQwIFRoZSBwcmVmaXhlZCByZXByZXNlbnRhdGlvbiBTdHJpbmdcbiAgICAgICAgICAgICAgICAqICAgICBvZiB0aGUgZmlyc3Qgb2YgdGhlIHR3byBwcmltaXRpdmUgdmFsdWVzIHRoYXQgYXJlIGJlaW5nXG4gICAgICAgICAgICAgICAgKiAgICAgY29tcGFyZWQuXG4gICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1ByZWZpeGVkMSBUaGUgcHJlZml4ZWQgcmVwcmVzZW50YXRpb24gU3RyaW5nXG4gICAgICAgICAgICAgICAgKiAgICAgb2YgdGhlIHNlY29uZCBvZiB0aGUgdHdvIHByaW1pdGl2ZSB2YWx1ZXMgdGhhdCBhcmUgYmVpbmdcbiAgICAgICAgICAgICAgICAqICAgICBjb21wYXJlZC5cbiAgICAgICAgICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICAgICAgICAqICAgICA8ZGw+XG4gICAgICAgICAgICAgICAgKiAgICAgICAgIDxkdD4tMTwvZHQ+XG4gICAgICAgICAgICAgICAgKiAgICAgICAgIDxkZD5pZiB0aGUgZmlyc3QgcHJpbWl0aXZlIHZhbHVlIG11c3QgYmUgcGxhY2VkIGJlZm9yZVxuICAgICAgICAgICAgICAgICogICAgICAgICAgICAgIHRoZSBvdGhlciBvbmUsPC9kZD5cbiAgICAgICAgICAgICAgICAqICAgICAgICAgPGR0PjA8L2R0PlxuICAgICAgICAgICAgICAgICogICAgICAgICA8ZGQ+aWYgdGhlIGZpcnN0IHByaW1pdGl2ZSB2YWx1ZSBtYXkgYmUgcGxhY2VkIGJlZm9yZVxuICAgICAgICAgICAgICAgICogICAgICAgICAgICAgIHRoZSBvdGhlciBvbmUsPC9kZD5cbiAgICAgICAgICAgICAgICAqICAgICAgICAgPGR0PjE8L2R0PlxuICAgICAgICAgICAgICAgICogICAgICAgICA8ZGQ+aWYgdGhlIGZpcnN0IHByaW1pdGl2ZSB2YWx1ZSBtdXN0IG5vdCBiZSBwbGFjZWRcbiAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICBiZWZvcmUgdGhlIG90aGVyIG9uZS48L2RkPlxuICAgICAgICAgICAgICAgICogICAgIDwvZGw+XG4gICAgICAgICAgICAgICAgKiBAc2VlIFRTb2x1dGlvbi5vUHJpbWl0aXZlVmFsdWVzXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgIGNTb3J0UHJpbWl0aXZlVmFsdWVzID0gZnVuY3Rpb24oc1ByZWZpeGVkMCwgc1ByZWZpeGVkMSkge1xuICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbjpcbiAgICAgICAgICAgICAgICAgICogPG9sPlxuICAgICAgICAgICAgICAgICAgKiA8bGk+dGhlIGRpZmZlcmVuY2UgaW4gdGhlIG51bWJlciBvZiB0ZXJtaW5hbCBzeW1ib2xzXG4gICAgICAgICAgICAgICAgICAqICAgICBiZXR3ZWVuIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGV4dCBhbmQgdGhlIG9uZSB3aXRoIHRoZVxuICAgICAgICAgICAgICAgICAgKiAgICAgZmlyc3QgcHJpbWl0aXZlIHZhbHVlIGNvbnNvbGlkYXRlZCwgYW5kPC9saT5cbiAgICAgICAgICAgICAgICAgICogPGxpPnRoZSBkaWZmZXJlbmNlIGluIHRoZSBudW1iZXIgb2YgdGVybWluYWwgc3ltYm9sc1xuICAgICAgICAgICAgICAgICAgKiAgICAgYmV0d2VlbiB0aGUgb3JpZ2luYWwgc291cmNlIHRleHQgYW5kIHRoZSBvbmUgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAgICogICAgIHNlY29uZCBwcmltaXRpdmUgdmFsdWUgY29uc29saWRhdGVkLjwvbGk+XG4gICAgICAgICAgICAgICAgICAqIDwvb2w+XG4gICAgICAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICB2YXIgbkRpZmZlcmVuY2UgPVxuICAgICAgICAgICAgICAgICAgICAgb1NvbHV0aW9uQ2FuZGlkYXRlLm9QcmltaXRpdmVWYWx1ZXNbc1ByZWZpeGVkMF0ublNhdmluZyAtXG4gICAgICAgICAgICAgICAgICAgICBvU29sdXRpb25DYW5kaWRhdGUub1ByaW1pdGl2ZVZhbHVlc1tzUHJlZml4ZWQxXS5uU2F2aW5nO1xuXG4gICAgICAgICAgICAgICAgIHJldHVybiBuRGlmZmVyZW5jZSA+IDAgPyAtMSA6IG5EaWZmZXJlbmNlIDwgMCA/IDEgOiAwO1xuICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICogQXNzaWducyBhbiBpZGVudGlmaWVyIG5hbWUgdG8gYSBwcmltaXRpdmUgdmFsdWUgYW5kIGNhbGN1bGF0ZXNcbiAgICAgICAgICAgICAgICAqIHdoZXRoZXIgaW5zdGFuY2VzIG9mIHRoYXQgcHJpbWl0aXZlIHZhbHVlIGFyZSB3b3J0aFxuICAgICAgICAgICAgICAgICogY29uc29saWRhdGluZy5cbiAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzUHJlZml4ZWQgVGhlIHByZWZpeGVkIHJlcHJlc2VudGF0aW9uIFN0cmluZ1xuICAgICAgICAgICAgICAgICogICAgIG9mIGEgcHJpbWl0aXZlIHZhbHVlIHRoYXQgaXMgYmVpbmcgZXZhbHVhdGVkLlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICBmRXZhbHVhdGVQcmltaXRpdmVWYWx1ZSA9IGZ1bmN0aW9uKHNQcmVmaXhlZCkge1xuICAgICAgICAgICAgICAgICB2YXIgXyxcbiAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICogVGhlIGluZGV4IG9mIHRoZSBsYXN0IG1hbmdsZWQgbmFtZS5cbiAgICAgICAgICAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgIG5JbmRleCxcbiAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICogVGhlIHJlcHJlc2VudGF0aW9uIFN0cmluZyBvZiB0aGUgcHJpbWl0aXZlIHZhbHVlIHRoYXQgaXNcbiAgICAgICAgICAgICAgICAgICAgICAqIGJlaW5nIGV2YWx1YXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgIHNOYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICAgICBzUHJlZml4ZWQuc3Vic3RyaW5nKEVWYWx1ZVByZWZpeGVzLlNfU1lNQk9MSUMubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICogVGhlIG51bWJlciBvZiBzb3VyY2UgY2hhcmFjdGVycyB0YWtlbiB1cCBieSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAqIHJlcHJlc2VudGF0aW9uIFN0cmluZyBvZiB0aGUgcHJpbWl0aXZlIHZhbHVlIHRoYXQgaXNcbiAgICAgICAgICAgICAgICAgICAgICAqIGJlaW5nIGV2YWx1YXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgIG5MZW5ndGhPcmlnaW5hbCA9IHNOYW1lLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICogVGhlIG51bWJlciBvZiBzb3VyY2UgY2hhcmFjdGVycyB0YWtlbiB1cCBieSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAqIGlkZW50aWZpZXIgbmFtZSB0aGF0IGNvdWxkIHN1YnN0aXR1dGUgdGhlIHByaW1pdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICogdmFsdWUgdGhhdCBpcyBiZWluZyBldmFsdWF0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgKiBzdWJzdGl0dXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgIG5MZW5ndGhTdWJzdGl0dXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAqIFRoZSBudW1iZXIgb2Ygc291cmNlIGNoYXJhY3RlcnMgdGFrZW4gdXAgYnkgYnkgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgKiByZXByZXNlbnRhdGlvbiBTdHJpbmcgb2YgdGhlIHByaW1pdGl2ZSB2YWx1ZSB0aGF0IGlzXG4gICAgICAgICAgICAgICAgICAgICAgKiBiZWluZyBldmFsdWF0ZWQgd2hlbiBpdCBpcyByZXByZXNlbnRlZCBieSBhIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICogbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgIG5MZW5ndGhTdHJpbmcgPSBvUHJvY2Vzc29yLm1ha2Vfc3RyaW5nKHNOYW1lKS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgb1NvbHV0aW9uQ2FuZGlkYXRlLm9QcmltaXRpdmVWYWx1ZXNbc1ByZWZpeGVkXSA9XG4gICAgICAgICAgICAgICAgICAgICBuZXcgVFByaW1pdGl2ZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgIGRvIHsgIC8vIEZpbmQgYW4gaWRlbnRpZmllciB1bnVzZWQgaW4gdGhpcyBvciBhbnkgbmVzdGVkIHNjb3BlLlxuICAgICAgICAgICAgICAgICAgIG5JbmRleCA9IG9TY29wZS5jbmFtZTtcbiAgICAgICAgICAgICAgICAgICBvU29sdXRpb25DYW5kaWRhdGUub1ByaW1pdGl2ZVZhbHVlc1tzUHJlZml4ZWRdLnNOYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICAgb1Njb3BlLm5leHRfbWFuZ2xlZCgpO1xuICAgICAgICAgICAgICAgICB9IHdoaWxlICgtMSAhPT0gb1NvdXJjZUVsZW1lbnRzRGF0YS5hSWRlbnRpZmllcnMuaW5kZXhPZihcbiAgICAgICAgICAgICAgICAgICAgIG9Tb2x1dGlvbkNhbmRpZGF0ZS5vUHJpbWl0aXZlVmFsdWVzW3NQcmVmaXhlZF0uc05hbWUpKTtcbiAgICAgICAgICAgICAgICAgbkxlbmd0aFN1YnN0aXR1dGlvbiA9IG9Tb2x1dGlvbkNhbmRpZGF0ZS5vUHJpbWl0aXZlVmFsdWVzW1xuICAgICAgICAgICAgICAgICAgICAgc1ByZWZpeGVkXS5zTmFtZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgIGlmICgwID09PSBzUHJlZml4ZWQuaW5kZXhPZihFVmFsdWVQcmVmaXhlcy5TX1NZTUJPTElDKSkge1xuICAgICAgICAgICAgICAgICAgIC8vIGZvbzpudWxsLCBvciBmb286bnVsbDtcbiAgICAgICAgICAgICAgICAgICBvU29sdXRpb25DYW5kaWRhdGUub1ByaW1pdGl2ZVZhbHVlc1tzUHJlZml4ZWRdLm5TYXZpbmcgLT1cbiAgICAgICAgICAgICAgICAgICAgICAgbkxlbmd0aFN1YnN0aXR1dGlvbiArIG5MZW5ndGhPcmlnaW5hbCArXG4gICAgICAgICAgICAgICAgICAgICAgIG9XZWlnaHRzLk5fVkFSSUFCTEVfREVDTEFSQVRJT047XG4gICAgICAgICAgICAgICAgICAgLy8gbnVsbCB2cyBmb29cbiAgICAgICAgICAgICAgICAgICBvU29sdXRpb25DYW5kaWRhdGUub1ByaW1pdGl2ZVZhbHVlc1tzUHJlZml4ZWRdLm5TYXZpbmcgKz1cbiAgICAgICAgICAgICAgICAgICAgICAgb1NvdXJjZUVsZW1lbnRzRGF0YS5hQ291bnRbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBFUHJpbWFyeUV4cHJlc3Npb25DYXRlZ29yaWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5fTlVMTF9BTkRfQk9PTEVBTl9MSVRFUkFMU11bc1ByZWZpeGVkXSAqXG4gICAgICAgICAgICAgICAgICAgICAgIChuTGVuZ3RoT3JpZ2luYWwgLSBuTGVuZ3RoU3Vic3RpdHV0aW9uKTtcbiAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAvLyBmb286J2Zyb21DaGFyQ29kZSc7XG4gICAgICAgICAgICAgICAgICAgb1NvbHV0aW9uQ2FuZGlkYXRlLm9QcmltaXRpdmVWYWx1ZXNbc1ByZWZpeGVkXS5uU2F2aW5nIC09XG4gICAgICAgICAgICAgICAgICAgICAgIG5MZW5ndGhTdWJzdGl0dXRpb24gKyBuTGVuZ3RoU3RyaW5nICtcbiAgICAgICAgICAgICAgICAgICAgICAgb1dlaWdodHMuTl9WQVJJQUJMRV9ERUNMQVJBVElPTjtcbiAgICAgICAgICAgICAgICAgICAvLyAuZnJvbUNoYXJDb2RlIHZzIFtmb29dXG4gICAgICAgICAgICAgICAgICAgaWYgKG9Tb3VyY2VFbGVtZW50c0RhdGEuYUNvdW50W1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgRVByaW1hcnlFeHByZXNzaW9uQ2F0ZWdvcmllcy5OX0lERU5USUZJRVJfTkFNRVNcbiAgICAgICAgICAgICAgICAgICAgICAgXS5oYXNPd25Qcm9wZXJ0eShzUHJlZml4ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICBvU29sdXRpb25DYW5kaWRhdGUub1ByaW1pdGl2ZVZhbHVlc1tzUHJlZml4ZWRdLm5TYXZpbmcgKz1cbiAgICAgICAgICAgICAgICAgICAgICAgICBvU291cmNlRWxlbWVudHNEYXRhLmFDb3VudFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRVByaW1hcnlFeHByZXNzaW9uQ2F0ZWdvcmllcy5OX0lERU5USUZJRVJfTkFNRVNcbiAgICAgICAgICAgICAgICAgICAgICAgICBdW3NQcmVmaXhlZF0gKlxuICAgICAgICAgICAgICAgICAgICAgICAgIChuTGVuZ3RoT3JpZ2luYWwgLSBuTGVuZ3RoU3Vic3RpdHV0aW9uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgb1dlaWdodHMuTl9QUk9QRVJUWV9BQ0NFU1NPUik7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIC8vICdmcm9tQ2hhckNvZGUnIHZzIGZvb1xuICAgICAgICAgICAgICAgICAgIGlmIChvU291cmNlRWxlbWVudHNEYXRhLmFDb3VudFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEVQcmltYXJ5RXhwcmVzc2lvbkNhdGVnb3JpZXMuTl9TVFJJTkdfTElURVJBTFNcbiAgICAgICAgICAgICAgICAgICAgICAgXS5oYXNPd25Qcm9wZXJ0eShzUHJlZml4ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICBvU29sdXRpb25DYW5kaWRhdGUub1ByaW1pdGl2ZVZhbHVlc1tzUHJlZml4ZWRdLm5TYXZpbmcgKz1cbiAgICAgICAgICAgICAgICAgICAgICAgICBvU291cmNlRWxlbWVudHNEYXRhLmFDb3VudFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRVByaW1hcnlFeHByZXNzaW9uQ2F0ZWdvcmllcy5OX1NUUklOR19MSVRFUkFMU1xuICAgICAgICAgICAgICAgICAgICAgICAgIF1bc1ByZWZpeGVkXSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKG5MZW5ndGhTdHJpbmcgLSBuTGVuZ3RoU3Vic3RpdHV0aW9uKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgaWYgKG9Tb2x1dGlvbkNhbmRpZGF0ZS5vUHJpbWl0aXZlVmFsdWVzW3NQcmVmaXhlZF0ublNhdmluZyA+XG4gICAgICAgICAgICAgICAgICAgICAwKSB7XG4gICAgICAgICAgICAgICAgICAgb1NvbHV0aW9uQ2FuZGlkYXRlLm5TYXZpbmdzICs9XG4gICAgICAgICAgICAgICAgICAgICAgIG9Tb2x1dGlvbkNhbmRpZGF0ZS5vUHJpbWl0aXZlVmFsdWVzW3NQcmVmaXhlZF0ublNhdmluZztcbiAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICBvU2NvcGUuY25hbWUgPSBuSW5kZXg7IC8vIEZyZWUgdGhlIGlkZW50aWZpZXIgbmFtZS5cbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICogQWRkcyBhIHZhcmlhYmxlIGRlY2xhcmF0aW9uIHRvIGFuIGV4aXN0aW5nIHZhcmlhYmxlIHN0YXRlbWVudC5cbiAgICAgICAgICAgICAgICAqIEBwYXJhbSB7IUFycmF5fSBhVmFyaWFibGVEZWNsYXJhdGlvbiBBIHZhcmlhYmxlIGRlY2xhcmF0aW9uXG4gICAgICAgICAgICAgICAgKiAgICAgd2l0aCBhbiBpbml0aWFsaXNlci5cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgY0FkZFZhcmlhYmxlRGVjbGFyYXRpb24gPSBmdW5jdGlvbihhVmFyaWFibGVEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAoLyoqIEB0eXBlIHshQXJyYXl9ICovIG9Tb3VyY2VFbGVtZW50c1tuRnJvbV1bMV0pLnVuc2hpZnQoXG4gICAgICAgICAgICAgICAgICAgICBhVmFyaWFibGVEZWNsYXJhdGlvbik7XG4gICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgIGlmIChuRnJvbSA+IG5Ubykge1xuICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgfVxuICAgICAgICAgICAvLyBJZiB0aGUgcmFuZ2UgaXMgYSBjbG9zdXJlLCByZXVzZSB0aGUgY2xvc3VyZS5cbiAgICAgICAgICAgaWYgKG5Gcm9tID09PSBuVG8gJiZcbiAgICAgICAgICAgICAgICdzdGF0JyA9PT0gb1NvdXJjZUVsZW1lbnRzW25Gcm9tXVswXSAmJlxuICAgICAgICAgICAgICAgJ2NhbGwnID09PSBvU291cmNlRWxlbWVudHNbbkZyb21dWzFdWzBdICYmXG4gICAgICAgICAgICAgICAnZnVuY3Rpb24nID09PSBvU291cmNlRWxlbWVudHNbbkZyb21dWzFdWzFdWzBdKSB7XG4gICAgICAgICAgICAgZkV4YW1pbmVTeW50YWN0aWNDb2RlVW5pdChvU291cmNlRWxlbWVudHNbbkZyb21dWzFdWzFdKTtcbiAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgLy8gQ3JlYXRlIGEgbGlzdCBvZiBhbGwgZGVyaXZlZCBwcmltaXRpdmUgdmFsdWVzIHdpdGhpbiB0aGUgcmFuZ2UuXG4gICAgICAgICAgIGZvciAoblBvc2l0aW9uID0gbkZyb207IG5Qb3NpdGlvbiA8PSBuVG87IG5Qb3NpdGlvbiArPSAxKSB7XG4gICAgICAgICAgICAgYVNvdXJjZUVsZW1lbnRzRGF0YVtuUG9zaXRpb25dLmFQcmltaXRpdmVWYWx1ZXMuZm9yRWFjaChcbiAgICAgICAgICAgICAgICAgY0F1Z21lbnRMaXN0KG9Tb3VyY2VFbGVtZW50c0RhdGEuYVByaW1pdGl2ZVZhbHVlcykpO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIGlmICgwID09PSBvU291cmNlRWxlbWVudHNEYXRhLmFQcmltaXRpdmVWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIGZvciAoblBvc2l0aW9uID0gbkZyb207IG5Qb3NpdGlvbiA8PSBuVG87IG5Qb3NpdGlvbiArPSAxKSB7XG4gICAgICAgICAgICAgLy8gQWRkIHRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgdG8gdGhlIHRvdGFsIGNvdW50LlxuICAgICAgICAgICAgIGZBZGRPY2N1cnJlbmNlcyhuUG9zaXRpb24pO1xuICAgICAgICAgICAgIC8vIEFkZCBpZGVudGlmaWVycyBvZiB0aGlzIG9yIGFueSBuZXN0ZWQgc2NvcGUgdG8gdGhlIGxpc3QuXG4gICAgICAgICAgICAgYVNvdXJjZUVsZW1lbnRzRGF0YVtuUG9zaXRpb25dLmFJZGVudGlmaWVycy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICBjQXVnbWVudExpc3Qob1NvdXJjZUVsZW1lbnRzRGF0YS5hSWRlbnRpZmllcnMpKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICAvLyBEaXN0cmlidXRlIGlkZW50aWZpZXIgbmFtZXMgYW1vbmcgZGVyaXZlZCBwcmltaXRpdmUgdmFsdWVzLlxuICAgICAgICAgICBkbyB7ICAvLyBJZiB0aGVyZSB3YXMgYW55IHByb2dyZXNzLCBmaW5kIGEgYmV0dGVyIGRpc3RyaWJ1dGlvbi5cbiAgICAgICAgICAgICBvU29sdXRpb25CZXN0ID0gb1NvbHV0aW9uQ2FuZGlkYXRlO1xuICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhvU29sdXRpb25DYW5kaWRhdGUub1ByaW1pdGl2ZVZhbHVlcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgLy8gU29ydCBwcmltaXRpdmUgdmFsdWVzIGRlc2NlbmRpbmcgYnkgdGhlaXIgd29ydGh3aGlsZW5lc3MuXG4gICAgICAgICAgICAgICBvU291cmNlRWxlbWVudHNEYXRhLmFQcmltaXRpdmVWYWx1ZXMuc29ydChjU29ydFByaW1pdGl2ZVZhbHVlcyk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgIG9Tb2x1dGlvbkNhbmRpZGF0ZSA9IG5ldyBUU29sdXRpb24oKTtcbiAgICAgICAgICAgICBvU291cmNlRWxlbWVudHNEYXRhLmFQcmltaXRpdmVWYWx1ZXMuZm9yRWFjaChcbiAgICAgICAgICAgICAgICAgZkV2YWx1YXRlUHJpbWl0aXZlVmFsdWUpO1xuICAgICAgICAgICAgIG9TY29wZS5jbmFtZSA9IG5JbmRleDtcbiAgICAgICAgICAgfSB3aGlsZSAob1NvbHV0aW9uQ2FuZGlkYXRlLm5TYXZpbmdzID4gb1NvbHV0aW9uQmVzdC5uU2F2aW5ncyk7XG4gICAgICAgICAgIC8vIFRha2UgdGhlIG5lY2Vzc2l0eSBvZiBhZGRpbmcgYSB2YXJpYWJsZSBzdGF0ZW1lbnQgaW50byBhY2NvdW50LlxuICAgICAgICAgICBpZiAoJ3ZhcicgIT09IG9Tb3VyY2VFbGVtZW50c1tuRnJvbV1bMF0pIHtcbiAgICAgICAgICAgICBvU29sdXRpb25CZXN0Lm5TYXZpbmdzIC09IG9XZWlnaHRzLk5fVkFSSUFCTEVfU1RBVEVNRU5UX0FGRklYQVRJT047XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgaWYgKGJFbmNsb3NlKSB7XG4gICAgICAgICAgICAgLy8gVGFrZSB0aGUgbmVjZXNzaXR5IG9mIGZvcm1pbmcgYSBjbG9zdXJlIGludG8gYWNjb3VudC5cbiAgICAgICAgICAgICBvU29sdXRpb25CZXN0Lm5TYXZpbmdzIC09IG9XZWlnaHRzLk5fQ0xPU1VSRTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICBpZiAob1NvbHV0aW9uQmVzdC5uU2F2aW5ncyA+IDApIHtcbiAgICAgICAgICAgICAvLyBDcmVhdGUgdmFyaWFibGUgZGVjbGFyYXRpb25zIHN1aXRhYmxlIGZvciBVZ2xpZnlKUy5cbiAgICAgICAgICAgICBPYmplY3Qua2V5cyhvU29sdXRpb25CZXN0Lm9QcmltaXRpdmVWYWx1ZXMpLmZvckVhY2goXG4gICAgICAgICAgICAgICAgIGNBdWdtZW50VmFyaWFibGVEZWNsYXJhdGlvbnMpO1xuICAgICAgICAgICAgIC8vIFJld3JpdGUgZXhwcmVzc2lvbnMgdGhhdCBjb250YWluIHdvcnRod2hpbGUgcHJpbWl0aXZlIHZhbHVlcy5cbiAgICAgICAgICAgICBmb3IgKG5Qb3NpdGlvbiA9IG5Gcm9tOyBuUG9zaXRpb24gPD0gblRvOyBuUG9zaXRpb24gKz0gMSkge1xuICAgICAgICAgICAgICAgb1dhbGtlciA9IG9Qcm9jZXNzb3IuYXN0X3dhbGtlcigpO1xuICAgICAgICAgICAgICAgb1NvdXJjZUVsZW1lbnRzW25Qb3NpdGlvbl0gPVxuICAgICAgICAgICAgICAgICAgIG9XYWxrZXIud2l0aF93YWxrZXJzKFxuICAgICAgICAgICAgICAgICAgICAgICBvV2Fsa2Vyc1RyYW5zZm9ybWVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgY0NvbnRleHQob1dhbGtlciwgb1NvdXJjZUVsZW1lbnRzW25Qb3NpdGlvbl0pKTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgaWYgKCd2YXInID09PSBvU291cmNlRWxlbWVudHNbbkZyb21dWzBdKSB7ICAvLyBSZXVzZSB0aGUgc3RhdGVtZW50LlxuICAgICAgICAgICAgICAgKC8qKiBAdHlwZSB7IUFycmF5LjwhQXJyYXk+fSAqLyBhVmFyaWFibGVEZWNsYXJhdGlvbnMucmV2ZXJzZShcbiAgICAgICAgICAgICAgICAgICApKS5mb3JFYWNoKGNBZGRWYXJpYWJsZURlY2xhcmF0aW9uKTtcbiAgICAgICAgICAgICB9IGVsc2UgeyAgLy8gQWRkIGEgdmFyaWFibGUgc3RhdGVtZW50LlxuICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKFxuICAgICAgICAgICAgICAgICAgIG9Tb3VyY2VFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICBuRnJvbSxcbiAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgIFsndmFyJywgYVZhcmlhYmxlRGVjbGFyYXRpb25zXSk7XG4gICAgICAgICAgICAgICBuVG8gKz0gMTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgaWYgKGJFbmNsb3NlKSB7XG4gICAgICAgICAgICAgICAvLyBBZGQgYSBjbG9zdXJlLlxuICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKFxuICAgICAgICAgICAgICAgICAgIG9Tb3VyY2VFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICBuRnJvbSxcbiAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgIFsnc3RhdCcsIFsnY2FsbCcsIFsnZnVuY3Rpb24nLCBudWxsLCBbXSwgW11dLCBbXV1dKTtcbiAgICAgICAgICAgICAgIC8vIENvcHkgc291cmNlIGVsZW1lbnRzIGludG8gdGhlIGNsb3N1cmUuXG4gICAgICAgICAgICAgICBmb3IgKG5Qb3NpdGlvbiA9IG5UbyArIDE7IG5Qb3NpdGlvbiA+IG5Gcm9tOyBuUG9zaXRpb24gLT0gMSkge1xuICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUudW5zaGlmdC5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgb1NvdXJjZUVsZW1lbnRzW25Gcm9tXVsxXVsxXVszXSxcbiAgICAgICAgICAgICAgICAgICAgIG9Tb3VyY2VFbGVtZW50c1tuUG9zaXRpb25dKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIC8vIFJlbW92ZSBzb3VyY2UgZWxlbWVudHMgb3V0c2lkZSB0aGUgY2xvc3VyZS5cbiAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChcbiAgICAgICAgICAgICAgICAgICBvU291cmNlRWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgbkZyb20gKyAxLFxuICAgICAgICAgICAgICAgICAgIG5UbyAtIG5Gcm9tICsgMSk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgICAgICAgIGlmIChiRW5jbG9zZSkge1xuICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIGF2YWlsYWJpbGl0eSBvZiBpZGVudGlmaWVyIG5hbWVzLlxuICAgICAgICAgICAgIG9TY29wZS5jbmFtZSA9IG5JbmRleDtcbiAgICAgICAgICAgfVxuICAgICAgICAgfTtcblxuICAgICBvU291cmNlRWxlbWVudHMgPSAoLyoqIEB0eXBlIHshVFN5bnRhY3RpY0NvZGVVbml0fSAqL1xuICAgICAgICAgb1N5bnRhY3RpY0NvZGVVbml0W2JJc0dsb2JhbCA/IDEgOiAzXSk7XG4gICAgIGlmICgwID09PSBvU291cmNlRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgcmV0dXJuO1xuICAgICB9XG4gICAgIG9TY29wZSA9IGJJc0dsb2JhbCA/IG9TeW50YWN0aWNDb2RlVW5pdC5zY29wZSA6IG9Tb3VyY2VFbGVtZW50cy5zY29wZTtcbiAgICAgLy8gU2tpcCBhIERpcmVjdGl2ZSBQcm9sb2d1ZS5cbiAgICAgd2hpbGUgKG5BZnRlckRpcmVjdGl2ZVByb2xvZ3VlIDwgb1NvdXJjZUVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgJ2RpcmVjdGl2ZScgPT09IG9Tb3VyY2VFbGVtZW50c1tuQWZ0ZXJEaXJlY3RpdmVQcm9sb2d1ZV1bMF0pIHtcbiAgICAgICBuQWZ0ZXJEaXJlY3RpdmVQcm9sb2d1ZSArPSAxO1xuICAgICAgIGFTb3VyY2VFbGVtZW50c0RhdGEucHVzaChudWxsKTtcbiAgICAgfVxuICAgICBpZiAob1NvdXJjZUVsZW1lbnRzLmxlbmd0aCA9PT0gbkFmdGVyRGlyZWN0aXZlUHJvbG9ndWUpIHtcbiAgICAgICByZXR1cm47XG4gICAgIH1cbiAgICAgZm9yIChuUG9zaXRpb24gPSBuQWZ0ZXJEaXJlY3RpdmVQcm9sb2d1ZTtcbiAgICAgICAgICBuUG9zaXRpb24gPCBvU291cmNlRWxlbWVudHMubGVuZ3RoO1xuICAgICAgICAgIG5Qb3NpdGlvbiArPSAxKSB7XG4gICAgICAgb1NvdXJjZUVsZW1lbnREYXRhID0gbmV3IFRTb3VyY2VFbGVtZW50c0RhdGEoKTtcbiAgICAgICBvV2Fsa2VyID0gb1Byb2Nlc3Nvci5hc3Rfd2Fsa2VyKCk7XG4gICAgICAgLy8gQ2xhc3NpZnkgYSBzb3VyY2UgZWxlbWVudC5cbiAgICAgICAvLyBGaW5kIGl0cyBkZXJpdmVkIHByaW1pdGl2ZSB2YWx1ZXMgYW5kIGNvdW50IHRoZWlyIG9jY3VycmVuY2VzLlxuICAgICAgIC8vIEZpbmQgYWxsIGlkZW50aWZpZXJzIHVzZWQgKGluY2x1ZGluZyBuZXN0ZWQgc2NvcGVzKS5cbiAgICAgICBvV2Fsa2VyLndpdGhfd2Fsa2VycyhcbiAgICAgICAgICAgb1dhbGtlcnMub1N1cnZleVNvdXJjZUVsZW1lbnQsXG4gICAgICAgICAgIGNDb250ZXh0KG9XYWxrZXIsIG9Tb3VyY2VFbGVtZW50c1tuUG9zaXRpb25dKSk7XG4gICAgICAgLy8gRXN0YWJsaXNoIHdoZXRoZXIgdGhlIHNjb3BlIGlzIHN0aWxsIHdob2xseSBleGFtaW5hYmxlLlxuICAgICAgIGJJc1dob2xseUV4YW1pbmFibGUgPSBiSXNXaG9sbHlFeGFtaW5hYmxlICYmXG4gICAgICAgICAgIEVTb3VyY2VFbGVtZW50Q2F0ZWdvcmllcy5OX1dJVEggIT09IG9Tb3VyY2VFbGVtZW50RGF0YS5uQ2F0ZWdvcnkgJiZcbiAgICAgICAgICAgRVNvdXJjZUVsZW1lbnRDYXRlZ29yaWVzLk5fRVZBTCAhPT0gb1NvdXJjZUVsZW1lbnREYXRhLm5DYXRlZ29yeTtcbiAgICAgICBhU291cmNlRWxlbWVudHNEYXRhLnB1c2gob1NvdXJjZUVsZW1lbnREYXRhKTtcbiAgICAgfVxuICAgICBpZiAoYklzV2hvbGx5RXhhbWluYWJsZSkgeyAgLy8gRXhhbWluZSB0aGUgd2hvbGUgc2NvcGUuXG4gICAgICAgZkV4YW1pbmVTb3VyY2VFbGVtZW50cyhcbiAgICAgICAgICAgbkFmdGVyRGlyZWN0aXZlUHJvbG9ndWUsXG4gICAgICAgICAgIG9Tb3VyY2VFbGVtZW50cy5sZW5ndGggLSAxLFxuICAgICAgICAgICBmYWxzZSk7XG4gICAgIH0gZWxzZSB7ICAvLyBFeGFtaW5lIHVuZXhjbHVkZWQgcmFuZ2VzIG9mIHNvdXJjZSBlbGVtZW50cy5cbiAgICAgICBmb3IgKG5Qb3NpdGlvbiA9IG9Tb3VyY2VFbGVtZW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgblBvc2l0aW9uID49IG5BZnRlckRpcmVjdGl2ZVByb2xvZ3VlO1xuICAgICAgICAgICAgblBvc2l0aW9uIC09IDEpIHtcbiAgICAgICAgIG9Tb3VyY2VFbGVtZW50RGF0YSA9ICgvKiogQHR5cGUgeyFUU291cmNlRWxlbWVudHNEYXRhfSAqL1xuICAgICAgICAgICAgIGFTb3VyY2VFbGVtZW50c0RhdGFbblBvc2l0aW9uXSk7XG4gICAgICAgICBpZiAoRVNvdXJjZUVsZW1lbnRDYXRlZ29yaWVzLk5fT1RIRVIgPT09XG4gICAgICAgICAgICAgb1NvdXJjZUVsZW1lbnREYXRhLm5DYXRlZ29yeSkge1xuICAgICAgICAgICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiBuVG8pIHtcbiAgICAgICAgICAgICBuVG8gPSBuUG9zaXRpb247ICAvLyBJbmRpY2F0ZSB0aGUgZW5kIG9mIGEgcmFuZ2UuXG4gICAgICAgICAgIH1cbiAgICAgICAgICAgLy8gRXhhbWluZSB0aGUgcmFuZ2UgaWYgaXQgaW1tZWRpYXRlbHkgZm9sbG93cyBhIERpcmVjdGl2ZSBQcm9sb2d1ZS5cbiAgICAgICAgICAgaWYgKG5Qb3NpdGlvbiA9PT0gbkFmdGVyRGlyZWN0aXZlUHJvbG9ndWUpIHtcbiAgICAgICAgICAgICBmRXhhbWluZVNvdXJjZUVsZW1lbnRzKG5Qb3NpdGlvbiwgblRvLCB0cnVlKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgblRvKSB7XG4gICAgICAgICAgICAgLy8gRXhhbWluZSB0aGUgcmFuZ2UgdGhhdCBpbW1lZGlhdGVseSBmb2xsb3dzIHRoaXMgc291cmNlIGVsZW1lbnQuXG4gICAgICAgICAgICAgZkV4YW1pbmVTb3VyY2VFbGVtZW50cyhuUG9zaXRpb24gKyAxLCBuVG8sIHRydWUpO1xuICAgICAgICAgICAgIG5UbyA9IHZvaWQgMDsgIC8vIE9ibGl0ZXJhdGUgdGhlIHJhbmdlLlxuICAgICAgICAgICB9XG4gICAgICAgICAgIC8vIEV4YW1pbmUgbmVzdGVkIGZ1bmN0aW9ucy5cbiAgICAgICAgICAgb1dhbGtlciA9IG9Qcm9jZXNzb3IuYXN0X3dhbGtlcigpO1xuICAgICAgICAgICBvV2Fsa2VyLndpdGhfd2Fsa2VycyhcbiAgICAgICAgICAgICAgIG9XYWxrZXJzLm9FeGFtaW5lRnVuY3Rpb25zLFxuICAgICAgICAgICAgICAgY0NvbnRleHQob1dhbGtlciwgb1NvdXJjZUVsZW1lbnRzW25Qb3NpdGlvbl0pKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH1cbiAgIH0ob0Fic3RyYWN0U3ludGF4VHJlZSA9IG9Qcm9jZXNzb3IuYXN0X2FkZF9zY29wZShvQWJzdHJhY3RTeW50YXhUcmVlKSkpO1xuICByZXR1cm4gb0Fic3RyYWN0U3ludGF4VHJlZTtcbn07XG4vKmpzaGludCBzdWI6ZmFsc2UgKi9cblxuLyogTG9jYWwgVmFyaWFibGVzOiAgICAgICovXG4vKiBtb2RlOiBqcyAgICAgICAgICAgICAgKi9cbi8qIGNvZGluZzogdXRmLTggICAgICAgICAqL1xuLyogaW5kZW50LXRhYnMtbW9kZTogbmlsICovXG4vKiB0YWItd2lkdGg6IDIgICAgICAgICAgKi9cbi8qIEVuZDogICAgICAgICAgICAgICAgICAqL1xuLyogdmltOiBzZXQgZnQ9amF2YXNjcmlwdCBmZW5jPXV0Zi04IGV0IHRzPTIgc3RzPTIgc3c9MjogKi9cbi8qIDptb2RlPWphdmFzY3JpcHQ6bm9UYWJzPXRydWU6dGFiU2l6ZT0yOmluZGVudFNpemU9MjpkZWVwSW5kZW50PXRydWU6ICovXG5cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cblxuICBUaGlzIHZlcnNpb24gaXMgc3VpdGFibGUgZm9yIE5vZGUuanMuICBXaXRoIG1pbmltYWwgY2hhbmdlcyAodGhlXG4gIGV4cG9ydHMgc3R1ZmYpIGl0IHNob3VsZCB3b3JrIG9uIGFueSBKUyBwbGF0Zm9ybS5cblxuICBUaGlzIGZpbGUgY29udGFpbnMgdGhlIHRva2VuaXplci9wYXJzZXIuICBJdCBpcyBhIHBvcnQgdG8gSmF2YVNjcmlwdFxuICBvZiBwYXJzZS1qcyBbMV0sIGEgSmF2YVNjcmlwdCBwYXJzZXIgbGlicmFyeSB3cml0dGVuIGluIENvbW1vbiBMaXNwXG4gIGJ5IE1hcmlqbiBIYXZlcmJla2UuICBUaGFuayB5b3UgTWFyaWpuIVxuXG4gIFsxXSBodHRwOi8vbWFyaWpuLmhhdmVyYmVrZS5ubC9wYXJzZS1qcy9cblxuICBFeHBvcnRlZCBmdW5jdGlvbnM6XG5cbiAgICAtIHRva2VuaXplcihjb2RlKSAtLSByZXR1cm5zIGEgZnVuY3Rpb24uICBDYWxsIHRoZSByZXR1cm5lZFxuICAgICAgZnVuY3Rpb24gdG8gZmV0Y2ggdGhlIG5leHQgdG9rZW4uXG5cbiAgICAtIHBhcnNlKGNvZGUpIC0tIHJldHVybnMgYW4gQVNUIG9mIHRoZSBnaXZlbiBKYXZhU2NyaXB0IGNvZGUuXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTAgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgQmFzZWQgb24gcGFyc2UtanMgKGh0dHA6Ly9tYXJpam4uaGF2ZXJiZWtlLm5sL3BhcnNlLWpzLykuXG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qIC0tLS0tWyBUb2tlbml6ZXIgKGNvbnN0YW50cykgXS0tLS0tICovXG5cbnZhciBLRVlXT1JEUyA9IGFycmF5X3RvX2hhc2goW1xuICAgICAgICBcImJyZWFrXCIsXG4gICAgICAgIFwiY2FzZVwiLFxuICAgICAgICBcImNhdGNoXCIsXG4gICAgICAgIFwiY29uc3RcIixcbiAgICAgICAgXCJjb250aW51ZVwiLFxuICAgICAgICBcImRlYnVnZ2VyXCIsXG4gICAgICAgIFwiZGVmYXVsdFwiLFxuICAgICAgICBcImRlbGV0ZVwiLFxuICAgICAgICBcImRvXCIsXG4gICAgICAgIFwiZWxzZVwiLFxuICAgICAgICBcImZpbmFsbHlcIixcbiAgICAgICAgXCJmb3JcIixcbiAgICAgICAgXCJmdW5jdGlvblwiLFxuICAgICAgICBcImlmXCIsXG4gICAgICAgIFwiaW5cIixcbiAgICAgICAgXCJpbnN0YW5jZW9mXCIsXG4gICAgICAgIFwibmV3XCIsXG4gICAgICAgIFwicmV0dXJuXCIsXG4gICAgICAgIFwic3dpdGNoXCIsXG4gICAgICAgIFwidGhyb3dcIixcbiAgICAgICAgXCJ0cnlcIixcbiAgICAgICAgXCJ0eXBlb2ZcIixcbiAgICAgICAgXCJ2YXJcIixcbiAgICAgICAgXCJ2b2lkXCIsXG4gICAgICAgIFwid2hpbGVcIixcbiAgICAgICAgXCJ3aXRoXCJcbl0pO1xuXG52YXIgUkVTRVJWRURfV09SRFMgPSBhcnJheV90b19oYXNoKFtcbiAgICAgICAgXCJhYnN0cmFjdFwiLFxuICAgICAgICBcImJvb2xlYW5cIixcbiAgICAgICAgXCJieXRlXCIsXG4gICAgICAgIFwiY2hhclwiLFxuICAgICAgICBcImNsYXNzXCIsXG4gICAgICAgIFwiZG91YmxlXCIsXG4gICAgICAgIFwiZW51bVwiLFxuICAgICAgICBcImV4cG9ydFwiLFxuICAgICAgICBcImV4dGVuZHNcIixcbiAgICAgICAgXCJmaW5hbFwiLFxuICAgICAgICBcImZsb2F0XCIsXG4gICAgICAgIFwiZ290b1wiLFxuICAgICAgICBcImltcGxlbWVudHNcIixcbiAgICAgICAgXCJpbXBvcnRcIixcbiAgICAgICAgXCJpbnRcIixcbiAgICAgICAgXCJpbnRlcmZhY2VcIixcbiAgICAgICAgXCJsb25nXCIsXG4gICAgICAgIFwibmF0aXZlXCIsXG4gICAgICAgIFwicGFja2FnZVwiLFxuICAgICAgICBcInByaXZhdGVcIixcbiAgICAgICAgXCJwcm90ZWN0ZWRcIixcbiAgICAgICAgXCJwdWJsaWNcIixcbiAgICAgICAgXCJzaG9ydFwiLFxuICAgICAgICBcInN0YXRpY1wiLFxuICAgICAgICBcInN1cGVyXCIsXG4gICAgICAgIFwic3luY2hyb25pemVkXCIsXG4gICAgICAgIFwidGhyb3dzXCIsXG4gICAgICAgIFwidHJhbnNpZW50XCIsXG4gICAgICAgIFwidm9sYXRpbGVcIlxuXSk7XG5cbnZhciBLRVlXT1JEU19CRUZPUkVfRVhQUkVTU0lPTiA9IGFycmF5X3RvX2hhc2goW1xuICAgICAgICBcInJldHVyblwiLFxuICAgICAgICBcIm5ld1wiLFxuICAgICAgICBcImRlbGV0ZVwiLFxuICAgICAgICBcInRocm93XCIsXG4gICAgICAgIFwiZWxzZVwiLFxuICAgICAgICBcImNhc2VcIlxuXSk7XG5cbnZhciBLRVlXT1JEU19BVE9NID0gYXJyYXlfdG9faGFzaChbXG4gICAgICAgIFwiZmFsc2VcIixcbiAgICAgICAgXCJudWxsXCIsXG4gICAgICAgIFwidHJ1ZVwiLFxuICAgICAgICBcInVuZGVmaW5lZFwiXG5dKTtcblxudmFyIE9QRVJBVE9SX0NIQVJTID0gYXJyYXlfdG9faGFzaChjaGFyYWN0ZXJzKFwiKy0qJiU9PD4hP3x+XlwiKSk7XG5cbnZhciBSRV9IRVhfTlVNQkVSID0gL14weFswLTlhLWZdKyQvaTtcbnZhciBSRV9PQ1RfTlVNQkVSID0gL14wWzAtN10rJC87XG52YXIgUkVfREVDX05VTUJFUiA9IC9eXFxkKlxcLj9cXGQqKD86ZVsrLV0/XFxkKig/OlxcZFxcLj98XFwuP1xcZClcXGQqKT8kL2k7XG5cbnZhciBPUEVSQVRPUlMgPSBhcnJheV90b19oYXNoKFtcbiAgICAgICAgXCJpblwiLFxuICAgICAgICBcImluc3RhbmNlb2ZcIixcbiAgICAgICAgXCJ0eXBlb2ZcIixcbiAgICAgICAgXCJuZXdcIixcbiAgICAgICAgXCJ2b2lkXCIsXG4gICAgICAgIFwiZGVsZXRlXCIsXG4gICAgICAgIFwiKytcIixcbiAgICAgICAgXCItLVwiLFxuICAgICAgICBcIitcIixcbiAgICAgICAgXCItXCIsXG4gICAgICAgIFwiIVwiLFxuICAgICAgICBcIn5cIixcbiAgICAgICAgXCImXCIsXG4gICAgICAgIFwifFwiLFxuICAgICAgICBcIl5cIixcbiAgICAgICAgXCIqXCIsXG4gICAgICAgIFwiL1wiLFxuICAgICAgICBcIiVcIixcbiAgICAgICAgXCI+PlwiLFxuICAgICAgICBcIjw8XCIsXG4gICAgICAgIFwiPj4+XCIsXG4gICAgICAgIFwiPFwiLFxuICAgICAgICBcIj5cIixcbiAgICAgICAgXCI8PVwiLFxuICAgICAgICBcIj49XCIsXG4gICAgICAgIFwiPT1cIixcbiAgICAgICAgXCI9PT1cIixcbiAgICAgICAgXCIhPVwiLFxuICAgICAgICBcIiE9PVwiLFxuICAgICAgICBcIj9cIixcbiAgICAgICAgXCI9XCIsXG4gICAgICAgIFwiKz1cIixcbiAgICAgICAgXCItPVwiLFxuICAgICAgICBcIi89XCIsXG4gICAgICAgIFwiKj1cIixcbiAgICAgICAgXCIlPVwiLFxuICAgICAgICBcIj4+PVwiLFxuICAgICAgICBcIjw8PVwiLFxuICAgICAgICBcIj4+Pj1cIixcbiAgICAgICAgXCJ8PVwiLFxuICAgICAgICBcIl49XCIsXG4gICAgICAgIFwiJj1cIixcbiAgICAgICAgXCImJlwiLFxuICAgICAgICBcInx8XCJcbl0pO1xuXG52YXIgV0hJVEVTUEFDRV9DSEFSUyA9IGFycmF5X3RvX2hhc2goY2hhcmFjdGVycyhcIiBcXHUwMGEwXFxuXFxyXFx0XFxmXFx1MDAwYlxcdTIwMGJcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcIikpO1xuXG52YXIgUFVOQ19CRUZPUkVfRVhQUkVTU0lPTiA9IGFycmF5X3RvX2hhc2goY2hhcmFjdGVycyhcIlt7KCwuOzpcIikpO1xuXG52YXIgUFVOQ19DSEFSUyA9IGFycmF5X3RvX2hhc2goY2hhcmFjdGVycyhcIltde30oKSw7OlwiKSk7XG5cbnZhciBSRUdFWFBfTU9ESUZJRVJTID0gYXJyYXlfdG9faGFzaChjaGFyYWN0ZXJzKFwiZ21zaXlcIikpO1xuXG4vKiAtLS0tLVsgVG9rZW5pemVyIF0tLS0tLSAqL1xuXG52YXIgVU5JQ09ERSA9IHsgIC8vIFVuaWNvZGUgNi4xXG4gICAgICAgIGxldHRlcjogbmV3IFJlZ0V4cChcIltcXFxcdTAwNDEtXFxcXHUwMDVBXFxcXHUwMDYxLVxcXFx1MDA3QVxcXFx1MDBBQVxcXFx1MDBCNVxcXFx1MDBCQVxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJDMVxcXFx1MDJDNi1cXFxcdTAyRDFcXFxcdTAyRTAtXFxcXHUwMkU0XFxcXHUwMkVDXFxcXHUwMkVFXFxcXHUwMzcwLVxcXFx1MDM3NFxcXFx1MDM3NlxcXFx1MDM3N1xcXFx1MDM3QS1cXFxcdTAzN0RcXFxcdTAzODZcXFxcdTAzODgtXFxcXHUwMzhBXFxcXHUwMzhDXFxcXHUwMzhFLVxcXFx1MDNBMVxcXFx1MDNBMy1cXFxcdTAzRjVcXFxcdTAzRjctXFxcXHUwNDgxXFxcXHUwNDhBLVxcXFx1MDUyN1xcXFx1MDUzMS1cXFxcdTA1NTZcXFxcdTA1NTlcXFxcdTA1NjEtXFxcXHUwNTg3XFxcXHUwNUQwLVxcXFx1MDVFQVxcXFx1MDVGMC1cXFxcdTA1RjJcXFxcdTA2MjAtXFxcXHUwNjRBXFxcXHUwNjZFXFxcXHUwNjZGXFxcXHUwNjcxLVxcXFx1MDZEM1xcXFx1MDZENVxcXFx1MDZFNVxcXFx1MDZFNlxcXFx1MDZFRVxcXFx1MDZFRlxcXFx1MDZGQS1cXFxcdTA2RkNcXFxcdTA2RkZcXFxcdTA3MTBcXFxcdTA3MTItXFxcXHUwNzJGXFxcXHUwNzRELVxcXFx1MDdBNVxcXFx1MDdCMVxcXFx1MDdDQS1cXFxcdTA3RUFcXFxcdTA3RjRcXFxcdTA3RjVcXFxcdTA3RkFcXFxcdTA4MDAtXFxcXHUwODE1XFxcXHUwODFBXFxcXHUwODI0XFxcXHUwODI4XFxcXHUwODQwLVxcXFx1MDg1OFxcXFx1MDhBMFxcXFx1MDhBMi1cXFxcdTA4QUNcXFxcdTA5MDQtXFxcXHUwOTM5XFxcXHUwOTNEXFxcXHUwOTUwXFxcXHUwOTU4LVxcXFx1MDk2MVxcXFx1MDk3MS1cXFxcdTA5NzdcXFxcdTA5NzktXFxcXHUwOTdGXFxcXHUwOTg1LVxcXFx1MDk4Q1xcXFx1MDk4RlxcXFx1MDk5MFxcXFx1MDk5My1cXFxcdTA5QThcXFxcdTA5QUEtXFxcXHUwOUIwXFxcXHUwOUIyXFxcXHUwOUI2LVxcXFx1MDlCOVxcXFx1MDlCRFxcXFx1MDlDRVxcXFx1MDlEQ1xcXFx1MDlERFxcXFx1MDlERi1cXFxcdTA5RTFcXFxcdTA5RjBcXFxcdTA5RjFcXFxcdTBBMDUtXFxcXHUwQTBBXFxcXHUwQTBGXFxcXHUwQTEwXFxcXHUwQTEzLVxcXFx1MEEyOFxcXFx1MEEyQS1cXFxcdTBBMzBcXFxcdTBBMzJcXFxcdTBBMzNcXFxcdTBBMzVcXFxcdTBBMzZcXFxcdTBBMzhcXFxcdTBBMzlcXFxcdTBBNTktXFxcXHUwQTVDXFxcXHUwQTVFXFxcXHUwQTcyLVxcXFx1MEE3NFxcXFx1MEE4NS1cXFxcdTBBOERcXFxcdTBBOEYtXFxcXHUwQTkxXFxcXHUwQTkzLVxcXFx1MEFBOFxcXFx1MEFBQS1cXFxcdTBBQjBcXFxcdTBBQjJcXFxcdTBBQjNcXFxcdTBBQjUtXFxcXHUwQUI5XFxcXHUwQUJEXFxcXHUwQUQwXFxcXHUwQUUwXFxcXHUwQUUxXFxcXHUwQjA1LVxcXFx1MEIwQ1xcXFx1MEIwRlxcXFx1MEIxMFxcXFx1MEIxMy1cXFxcdTBCMjhcXFxcdTBCMkEtXFxcXHUwQjMwXFxcXHUwQjMyXFxcXHUwQjMzXFxcXHUwQjM1LVxcXFx1MEIzOVxcXFx1MEIzRFxcXFx1MEI1Q1xcXFx1MEI1RFxcXFx1MEI1Ri1cXFxcdTBCNjFcXFxcdTBCNzFcXFxcdTBCODNcXFxcdTBCODUtXFxcXHUwQjhBXFxcXHUwQjhFLVxcXFx1MEI5MFxcXFx1MEI5Mi1cXFxcdTBCOTVcXFxcdTBCOTlcXFxcdTBCOUFcXFxcdTBCOUNcXFxcdTBCOUVcXFxcdTBCOUZcXFxcdTBCQTNcXFxcdTBCQTRcXFxcdTBCQTgtXFxcXHUwQkFBXFxcXHUwQkFFLVxcXFx1MEJCOVxcXFx1MEJEMFxcXFx1MEMwNS1cXFxcdTBDMENcXFxcdTBDMEUtXFxcXHUwQzEwXFxcXHUwQzEyLVxcXFx1MEMyOFxcXFx1MEMyQS1cXFxcdTBDMzNcXFxcdTBDMzUtXFxcXHUwQzM5XFxcXHUwQzNEXFxcXHUwQzU4XFxcXHUwQzU5XFxcXHUwQzYwXFxcXHUwQzYxXFxcXHUwQzg1LVxcXFx1MEM4Q1xcXFx1MEM4RS1cXFxcdTBDOTBcXFxcdTBDOTItXFxcXHUwQ0E4XFxcXHUwQ0FBLVxcXFx1MENCM1xcXFx1MENCNS1cXFxcdTBDQjlcXFxcdTBDQkRcXFxcdTBDREVcXFxcdTBDRTBcXFxcdTBDRTFcXFxcdTBDRjFcXFxcdTBDRjJcXFxcdTBEMDUtXFxcXHUwRDBDXFxcXHUwRDBFLVxcXFx1MEQxMFxcXFx1MEQxMi1cXFxcdTBEM0FcXFxcdTBEM0RcXFxcdTBENEVcXFxcdTBENjBcXFxcdTBENjFcXFxcdTBEN0EtXFxcXHUwRDdGXFxcXHUwRDg1LVxcXFx1MEQ5NlxcXFx1MEQ5QS1cXFxcdTBEQjFcXFxcdTBEQjMtXFxcXHUwREJCXFxcXHUwREJEXFxcXHUwREMwLVxcXFx1MERDNlxcXFx1MEUwMS1cXFxcdTBFMzBcXFxcdTBFMzJcXFxcdTBFMzNcXFxcdTBFNDAtXFxcXHUwRTQ2XFxcXHUwRTgxXFxcXHUwRTgyXFxcXHUwRTg0XFxcXHUwRTg3XFxcXHUwRTg4XFxcXHUwRThBXFxcXHUwRThEXFxcXHUwRTk0LVxcXFx1MEU5N1xcXFx1MEU5OS1cXFxcdTBFOUZcXFxcdTBFQTEtXFxcXHUwRUEzXFxcXHUwRUE1XFxcXHUwRUE3XFxcXHUwRUFBXFxcXHUwRUFCXFxcXHUwRUFELVxcXFx1MEVCMFxcXFx1MEVCMlxcXFx1MEVCM1xcXFx1MEVCRFxcXFx1MEVDMC1cXFxcdTBFQzRcXFxcdTBFQzZcXFxcdTBFREMtXFxcXHUwRURGXFxcXHUwRjAwXFxcXHUwRjQwLVxcXFx1MEY0N1xcXFx1MEY0OS1cXFxcdTBGNkNcXFxcdTBGODgtXFxcXHUwRjhDXFxcXHUxMDAwLVxcXFx1MTAyQVxcXFx1MTAzRlxcXFx1MTA1MC1cXFxcdTEwNTVcXFxcdTEwNUEtXFxcXHUxMDVEXFxcXHUxMDYxXFxcXHUxMDY1XFxcXHUxMDY2XFxcXHUxMDZFLVxcXFx1MTA3MFxcXFx1MTA3NS1cXFxcdTEwODFcXFxcdTEwOEVcXFxcdTEwQTAtXFxcXHUxMEM1XFxcXHUxMEM3XFxcXHUxMENEXFxcXHUxMEQwLVxcXFx1MTBGQVxcXFx1MTBGQy1cXFxcdTEyNDhcXFxcdTEyNEEtXFxcXHUxMjREXFxcXHUxMjUwLVxcXFx1MTI1NlxcXFx1MTI1OFxcXFx1MTI1QS1cXFxcdTEyNURcXFxcdTEyNjAtXFxcXHUxMjg4XFxcXHUxMjhBLVxcXFx1MTI4RFxcXFx1MTI5MC1cXFxcdTEyQjBcXFxcdTEyQjItXFxcXHUxMkI1XFxcXHUxMkI4LVxcXFx1MTJCRVxcXFx1MTJDMFxcXFx1MTJDMi1cXFxcdTEyQzVcXFxcdTEyQzgtXFxcXHUxMkQ2XFxcXHUxMkQ4LVxcXFx1MTMxMFxcXFx1MTMxMi1cXFxcdTEzMTVcXFxcdTEzMTgtXFxcXHUxMzVBXFxcXHUxMzgwLVxcXFx1MTM4RlxcXFx1MTNBMC1cXFxcdTEzRjRcXFxcdTE0MDEtXFxcXHUxNjZDXFxcXHUxNjZGLVxcXFx1MTY3RlxcXFx1MTY4MS1cXFxcdTE2OUFcXFxcdTE2QTAtXFxcXHUxNkVBXFxcXHUxNkVFLVxcXFx1MTZGMFxcXFx1MTcwMC1cXFxcdTE3MENcXFxcdTE3MEUtXFxcXHUxNzExXFxcXHUxNzIwLVxcXFx1MTczMVxcXFx1MTc0MC1cXFxcdTE3NTFcXFxcdTE3NjAtXFxcXHUxNzZDXFxcXHUxNzZFLVxcXFx1MTc3MFxcXFx1MTc4MC1cXFxcdTE3QjNcXFxcdTE3RDdcXFxcdTE3RENcXFxcdTE4MjAtXFxcXHUxODc3XFxcXHUxODgwLVxcXFx1MThBOFxcXFx1MThBQVxcXFx1MThCMC1cXFxcdTE4RjVcXFxcdTE5MDAtXFxcXHUxOTFDXFxcXHUxOTUwLVxcXFx1MTk2RFxcXFx1MTk3MC1cXFxcdTE5NzRcXFxcdTE5ODAtXFxcXHUxOUFCXFxcXHUxOUMxLVxcXFx1MTlDN1xcXFx1MUEwMC1cXFxcdTFBMTZcXFxcdTFBMjAtXFxcXHUxQTU0XFxcXHUxQUE3XFxcXHUxQjA1LVxcXFx1MUIzM1xcXFx1MUI0NS1cXFxcdTFCNEJcXFxcdTFCODMtXFxcXHUxQkEwXFxcXHUxQkFFXFxcXHUxQkFGXFxcXHUxQkJBLVxcXFx1MUJFNVxcXFx1MUMwMC1cXFxcdTFDMjNcXFxcdTFDNEQtXFxcXHUxQzRGXFxcXHUxQzVBLVxcXFx1MUM3RFxcXFx1MUNFOS1cXFxcdTFDRUNcXFxcdTFDRUUtXFxcXHUxQ0YxXFxcXHUxQ0Y1XFxcXHUxQ0Y2XFxcXHUxRDAwLVxcXFx1MURCRlxcXFx1MUUwMC1cXFxcdTFGMTVcXFxcdTFGMTgtXFxcXHUxRjFEXFxcXHUxRjIwLVxcXFx1MUY0NVxcXFx1MUY0OC1cXFxcdTFGNERcXFxcdTFGNTAtXFxcXHUxRjU3XFxcXHUxRjU5XFxcXHUxRjVCXFxcXHUxRjVEXFxcXHUxRjVGLVxcXFx1MUY3RFxcXFx1MUY4MC1cXFxcdTFGQjRcXFxcdTFGQjYtXFxcXHUxRkJDXFxcXHUxRkJFXFxcXHUxRkMyLVxcXFx1MUZDNFxcXFx1MUZDNi1cXFxcdTFGQ0NcXFxcdTFGRDAtXFxcXHUxRkQzXFxcXHUxRkQ2LVxcXFx1MUZEQlxcXFx1MUZFMC1cXFxcdTFGRUNcXFxcdTFGRjItXFxcXHUxRkY0XFxcXHUxRkY2LVxcXFx1MUZGQ1xcXFx1MjA3MVxcXFx1MjA3RlxcXFx1MjA5MC1cXFxcdTIwOUNcXFxcdTIxMDJcXFxcdTIxMDdcXFxcdTIxMEEtXFxcXHUyMTEzXFxcXHUyMTE1XFxcXHUyMTE5LVxcXFx1MjExRFxcXFx1MjEyNFxcXFx1MjEyNlxcXFx1MjEyOFxcXFx1MjEyQS1cXFxcdTIxMkRcXFxcdTIxMkYtXFxcXHUyMTM5XFxcXHUyMTNDLVxcXFx1MjEzRlxcXFx1MjE0NS1cXFxcdTIxNDlcXFxcdTIxNEVcXFxcdTIxNjAtXFxcXHUyMTg4XFxcXHUyQzAwLVxcXFx1MkMyRVxcXFx1MkMzMC1cXFxcdTJDNUVcXFxcdTJDNjAtXFxcXHUyQ0U0XFxcXHUyQ0VCLVxcXFx1MkNFRVxcXFx1MkNGMlxcXFx1MkNGM1xcXFx1MkQwMC1cXFxcdTJEMjVcXFxcdTJEMjdcXFxcdTJEMkRcXFxcdTJEMzAtXFxcXHUyRDY3XFxcXHUyRDZGXFxcXHUyRDgwLVxcXFx1MkQ5NlxcXFx1MkRBMC1cXFxcdTJEQTZcXFxcdTJEQTgtXFxcXHUyREFFXFxcXHUyREIwLVxcXFx1MkRCNlxcXFx1MkRCOC1cXFxcdTJEQkVcXFxcdTJEQzAtXFxcXHUyREM2XFxcXHUyREM4LVxcXFx1MkRDRVxcXFx1MkREMC1cXFxcdTJERDZcXFxcdTJERDgtXFxcXHUyRERFXFxcXHUyRTJGXFxcXHUzMDA1LVxcXFx1MzAwN1xcXFx1MzAyMS1cXFxcdTMwMjlcXFxcdTMwMzEtXFxcXHUzMDM1XFxcXHUzMDM4LVxcXFx1MzAzQ1xcXFx1MzA0MS1cXFxcdTMwOTZcXFxcdTMwOUQtXFxcXHUzMDlGXFxcXHUzMEExLVxcXFx1MzBGQVxcXFx1MzBGQy1cXFxcdTMwRkZcXFxcdTMxMDUtXFxcXHUzMTJEXFxcXHUzMTMxLVxcXFx1MzE4RVxcXFx1MzFBMC1cXFxcdTMxQkFcXFxcdTMxRjAtXFxcXHUzMUZGXFxcXHUzNDAwLVxcXFx1NERCNVxcXFx1NEUwMC1cXFxcdTlGQ0NcXFxcdUEwMDAtXFxcXHVBNDhDXFxcXHVBNEQwLVxcXFx1QTRGRFxcXFx1QTUwMC1cXFxcdUE2MENcXFxcdUE2MTAtXFxcXHVBNjFGXFxcXHVBNjJBXFxcXHVBNjJCXFxcXHVBNjQwLVxcXFx1QTY2RVxcXFx1QTY3Ri1cXFxcdUE2OTdcXFxcdUE2QTAtXFxcXHVBNkVGXFxcXHVBNzE3LVxcXFx1QTcxRlxcXFx1QTcyMi1cXFxcdUE3ODhcXFxcdUE3OEItXFxcXHVBNzhFXFxcXHVBNzkwLVxcXFx1QTc5M1xcXFx1QTdBMC1cXFxcdUE3QUFcXFxcdUE3RjgtXFxcXHVBODAxXFxcXHVBODAzLVxcXFx1QTgwNVxcXFx1QTgwNy1cXFxcdUE4MEFcXFxcdUE4MEMtXFxcXHVBODIyXFxcXHVBODQwLVxcXFx1QTg3M1xcXFx1QTg4Mi1cXFxcdUE4QjNcXFxcdUE4RjItXFxcXHVBOEY3XFxcXHVBOEZCXFxcXHVBOTBBLVxcXFx1QTkyNVxcXFx1QTkzMC1cXFxcdUE5NDZcXFxcdUE5NjAtXFxcXHVBOTdDXFxcXHVBOTg0LVxcXFx1QTlCMlxcXFx1QTlDRlxcXFx1QUEwMC1cXFxcdUFBMjhcXFxcdUFBNDAtXFxcXHVBQTQyXFxcXHVBQTQ0LVxcXFx1QUE0QlxcXFx1QUE2MC1cXFxcdUFBNzZcXFxcdUFBN0FcXFxcdUFBODAtXFxcXHVBQUFGXFxcXHVBQUIxXFxcXHVBQUI1XFxcXHVBQUI2XFxcXHVBQUI5LVxcXFx1QUFCRFxcXFx1QUFDMFxcXFx1QUFDMlxcXFx1QUFEQi1cXFxcdUFBRERcXFxcdUFBRTAtXFxcXHVBQUVBXFxcXHVBQUYyLVxcXFx1QUFGNFxcXFx1QUIwMS1cXFxcdUFCMDZcXFxcdUFCMDktXFxcXHVBQjBFXFxcXHVBQjExLVxcXFx1QUIxNlxcXFx1QUIyMC1cXFxcdUFCMjZcXFxcdUFCMjgtXFxcXHVBQjJFXFxcXHVBQkMwLVxcXFx1QUJFMlxcXFx1QUMwMC1cXFxcdUQ3QTNcXFxcdUQ3QjAtXFxcXHVEN0M2XFxcXHVEN0NCLVxcXFx1RDdGQlxcXFx1RjkwMC1cXFxcdUZBNkRcXFxcdUZBNzAtXFxcXHVGQUQ5XFxcXHVGQjAwLVxcXFx1RkIwNlxcXFx1RkIxMy1cXFxcdUZCMTdcXFxcdUZCMURcXFxcdUZCMUYtXFxcXHVGQjI4XFxcXHVGQjJBLVxcXFx1RkIzNlxcXFx1RkIzOC1cXFxcdUZCM0NcXFxcdUZCM0VcXFxcdUZCNDBcXFxcdUZCNDFcXFxcdUZCNDNcXFxcdUZCNDRcXFxcdUZCNDYtXFxcXHVGQkIxXFxcXHVGQkQzLVxcXFx1RkQzRFxcXFx1RkQ1MC1cXFxcdUZEOEZcXFxcdUZEOTItXFxcXHVGREM3XFxcXHVGREYwLVxcXFx1RkRGQlxcXFx1RkU3MC1cXFxcdUZFNzRcXFxcdUZFNzYtXFxcXHVGRUZDXFxcXHVGRjIxLVxcXFx1RkYzQVxcXFx1RkY0MS1cXFxcdUZGNUFcXFxcdUZGNjYtXFxcXHVGRkJFXFxcXHVGRkMyLVxcXFx1RkZDN1xcXFx1RkZDQS1cXFxcdUZGQ0ZcXFxcdUZGRDItXFxcXHVGRkQ3XFxcXHVGRkRBLVxcXFx1RkZEQ11cIiksXG4gICAgICAgIGNvbWJpbmluZ19tYXJrOiBuZXcgUmVnRXhwKFwiW1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTA0ODMtXFxcXHUwNDg3XFxcXHUwNTkxLVxcXFx1MDVCRFxcXFx1MDVCRlxcXFx1MDVDMVxcXFx1MDVDMlxcXFx1MDVDNFxcXFx1MDVDNVxcXFx1MDVDN1xcXFx1MDYxMC1cXFxcdTA2MUFcXFxcdTA2NEItXFxcXHUwNjVGXFxcXHUwNjcwXFxcXHUwNkQ2LVxcXFx1MDZEQ1xcXFx1MDZERi1cXFxcdTA2RTRcXFxcdTA2RTdcXFxcdTA2RThcXFxcdTA2RUEtXFxcXHUwNkVEXFxcXHUwNzExXFxcXHUwNzMwLVxcXFx1MDc0QVxcXFx1MDdBNi1cXFxcdTA3QjBcXFxcdTA3RUItXFxcXHUwN0YzXFxcXHUwODE2LVxcXFx1MDgxOVxcXFx1MDgxQi1cXFxcdTA4MjNcXFxcdTA4MjUtXFxcXHUwODI3XFxcXHUwODI5LVxcXFx1MDgyRFxcXFx1MDg1OS1cXFxcdTA4NUJcXFxcdTA4RTQtXFxcXHUwOEZFXFxcXHUwOTAwLVxcXFx1MDkwM1xcXFx1MDkzQS1cXFxcdTA5M0NcXFxcdTA5M0UtXFxcXHUwOTRGXFxcXHUwOTUxLVxcXFx1MDk1N1xcXFx1MDk2MlxcXFx1MDk2M1xcXFx1MDk4MS1cXFxcdTA5ODNcXFxcdTA5QkNcXFxcdTA5QkUtXFxcXHUwOUM0XFxcXHUwOUM3XFxcXHUwOUM4XFxcXHUwOUNCLVxcXFx1MDlDRFxcXFx1MDlEN1xcXFx1MDlFMlxcXFx1MDlFM1xcXFx1MEEwMS1cXFxcdTBBMDNcXFxcdTBBM0NcXFxcdTBBM0UtXFxcXHUwQTQyXFxcXHUwQTQ3XFxcXHUwQTQ4XFxcXHUwQTRCLVxcXFx1MEE0RFxcXFx1MEE1MVxcXFx1MEE3MFxcXFx1MEE3MVxcXFx1MEE3NVxcXFx1MEE4MS1cXFxcdTBBODNcXFxcdTBBQkNcXFxcdTBBQkUtXFxcXHUwQUM1XFxcXHUwQUM3LVxcXFx1MEFDOVxcXFx1MEFDQi1cXFxcdTBBQ0RcXFxcdTBBRTJcXFxcdTBBRTNcXFxcdTBCMDEtXFxcXHUwQjAzXFxcXHUwQjNDXFxcXHUwQjNFLVxcXFx1MEI0NFxcXFx1MEI0N1xcXFx1MEI0OFxcXFx1MEI0Qi1cXFxcdTBCNERcXFxcdTBCNTZcXFxcdTBCNTdcXFxcdTBCNjJcXFxcdTBCNjNcXFxcdTBCODJcXFxcdTBCQkUtXFxcXHUwQkMyXFxcXHUwQkM2LVxcXFx1MEJDOFxcXFx1MEJDQS1cXFxcdTBCQ0RcXFxcdTBCRDdcXFxcdTBDMDEtXFxcXHUwQzAzXFxcXHUwQzNFLVxcXFx1MEM0NFxcXFx1MEM0Ni1cXFxcdTBDNDhcXFxcdTBDNEEtXFxcXHUwQzREXFxcXHUwQzU1XFxcXHUwQzU2XFxcXHUwQzYyXFxcXHUwQzYzXFxcXHUwQzgyXFxcXHUwQzgzXFxcXHUwQ0JDXFxcXHUwQ0JFLVxcXFx1MENDNFxcXFx1MENDNi1cXFxcdTBDQzhcXFxcdTBDQ0EtXFxcXHUwQ0NEXFxcXHUwQ0Q1XFxcXHUwQ0Q2XFxcXHUwQ0UyXFxcXHUwQ0UzXFxcXHUwRDAyXFxcXHUwRDAzXFxcXHUwRDNFLVxcXFx1MEQ0NFxcXFx1MEQ0Ni1cXFxcdTBENDhcXFxcdTBENEEtXFxcXHUwRDREXFxcXHUwRDU3XFxcXHUwRDYyXFxcXHUwRDYzXFxcXHUwRDgyXFxcXHUwRDgzXFxcXHUwRENBXFxcXHUwRENGLVxcXFx1MERENFxcXFx1MERENlxcXFx1MEREOC1cXFxcdTBEREZcXFxcdTBERjJcXFxcdTBERjNcXFxcdTBFMzFcXFxcdTBFMzQtXFxcXHUwRTNBXFxcXHUwRTQ3LVxcXFx1MEU0RVxcXFx1MEVCMVxcXFx1MEVCNC1cXFxcdTBFQjlcXFxcdTBFQkJcXFxcdTBFQkNcXFxcdTBFQzgtXFxcXHUwRUNEXFxcXHUwRjE4XFxcXHUwRjE5XFxcXHUwRjM1XFxcXHUwRjM3XFxcXHUwRjM5XFxcXHUwRjNFXFxcXHUwRjNGXFxcXHUwRjcxLVxcXFx1MEY4NFxcXFx1MEY4NlxcXFx1MEY4N1xcXFx1MEY4RC1cXFxcdTBGOTdcXFxcdTBGOTktXFxcXHUwRkJDXFxcXHUwRkM2XFxcXHUxMDJCLVxcXFx1MTAzRVxcXFx1MTA1Ni1cXFxcdTEwNTlcXFxcdTEwNUUtXFxcXHUxMDYwXFxcXHUxMDYyLVxcXFx1MTA2NFxcXFx1MTA2Ny1cXFxcdTEwNkRcXFxcdTEwNzEtXFxcXHUxMDc0XFxcXHUxMDgyLVxcXFx1MTA4RFxcXFx1MTA4RlxcXFx1MTA5QS1cXFxcdTEwOURcXFxcdTEzNUQtXFxcXHUxMzVGXFxcXHUxNzEyLVxcXFx1MTcxNFxcXFx1MTczMi1cXFxcdTE3MzRcXFxcdTE3NTJcXFxcdTE3NTNcXFxcdTE3NzJcXFxcdTE3NzNcXFxcdTE3QjQtXFxcXHUxN0QzXFxcXHUxN0REXFxcXHUxODBCLVxcXFx1MTgwRFxcXFx1MThBOVxcXFx1MTkyMC1cXFxcdTE5MkJcXFxcdTE5MzAtXFxcXHUxOTNCXFxcXHUxOUIwLVxcXFx1MTlDMFxcXFx1MTlDOFxcXFx1MTlDOVxcXFx1MUExNy1cXFxcdTFBMUJcXFxcdTFBNTUtXFxcXHUxQTVFXFxcXHUxQTYwLVxcXFx1MUE3Q1xcXFx1MUE3RlxcXFx1MUIwMC1cXFxcdTFCMDRcXFxcdTFCMzQtXFxcXHUxQjQ0XFxcXHUxQjZCLVxcXFx1MUI3M1xcXFx1MUI4MC1cXFxcdTFCODJcXFxcdTFCQTEtXFxcXHUxQkFEXFxcXHUxQkU2LVxcXFx1MUJGM1xcXFx1MUMyNC1cXFxcdTFDMzdcXFxcdTFDRDAtXFxcXHUxQ0QyXFxcXHUxQ0Q0LVxcXFx1MUNFOFxcXFx1MUNFRFxcXFx1MUNGMi1cXFxcdTFDRjRcXFxcdTFEQzAtXFxcXHUxREU2XFxcXHUxREZDLVxcXFx1MURGRlxcXFx1MjBEMC1cXFxcdTIwRENcXFxcdTIwRTFcXFxcdTIwRTUtXFxcXHUyMEYwXFxcXHUyQ0VGLVxcXFx1MkNGMVxcXFx1MkQ3RlxcXFx1MkRFMC1cXFxcdTJERkZcXFxcdTMwMkEtXFxcXHUzMDJGXFxcXHUzMDk5XFxcXHUzMDlBXFxcXHVBNjZGXFxcXHVBNjc0LVxcXFx1QTY3RFxcXFx1QTY5RlxcXFx1QTZGMFxcXFx1QTZGMVxcXFx1QTgwMlxcXFx1QTgwNlxcXFx1QTgwQlxcXFx1QTgyMy1cXFxcdUE4MjdcXFxcdUE4ODBcXFxcdUE4ODFcXFxcdUE4QjQtXFxcXHVBOEM0XFxcXHVBOEUwLVxcXFx1QThGMVxcXFx1QTkyNi1cXFxcdUE5MkRcXFxcdUE5NDctXFxcXHVBOTUzXFxcXHVBOTgwLVxcXFx1QTk4M1xcXFx1QTlCMy1cXFxcdUE5QzBcXFxcdUFBMjktXFxcXHVBQTM2XFxcXHVBQTQzXFxcXHVBQTRDXFxcXHVBQTREXFxcXHVBQTdCXFxcXHVBQUIwXFxcXHVBQUIyLVxcXFx1QUFCNFxcXFx1QUFCN1xcXFx1QUFCOFxcXFx1QUFCRVxcXFx1QUFCRlxcXFx1QUFDMVxcXFx1QUFFQi1cXFxcdUFBRUZcXFxcdUFBRjVcXFxcdUFBRjZcXFxcdUFCRTMtXFxcXHVBQkVBXFxcXHVBQkVDXFxcXHVBQkVEXFxcXHVGQjFFXFxcXHVGRTAwLVxcXFx1RkUwRlxcXFx1RkUyMC1cXFxcdUZFMjZdXCIpLFxuICAgICAgICBjb25uZWN0b3JfcHVuY3R1YXRpb246IG5ldyBSZWdFeHAoXCJbXFxcXHUwMDVGXFxcXHUyMDNGXFxcXHUyMDQwXFxcXHUyMDU0XFxcXHVGRTMzXFxcXHVGRTM0XFxcXHVGRTRELVxcXFx1RkU0RlxcXFx1RkYzRl1cIiksXG4gICAgICAgIGRpZ2l0OiBuZXcgUmVnRXhwKFwiW1xcXFx1MDAzMC1cXFxcdTAwMzlcXFxcdTA2NjAtXFxcXHUwNjY5XFxcXHUwNkYwLVxcXFx1MDZGOVxcXFx1MDdDMC1cXFxcdTA3QzlcXFxcdTA5NjYtXFxcXHUwOTZGXFxcXHUwOUU2LVxcXFx1MDlFRlxcXFx1MEE2Ni1cXFxcdTBBNkZcXFxcdTBBRTYtXFxcXHUwQUVGXFxcXHUwQjY2LVxcXFx1MEI2RlxcXFx1MEJFNi1cXFxcdTBCRUZcXFxcdTBDNjYtXFxcXHUwQzZGXFxcXHUwQ0U2LVxcXFx1MENFRlxcXFx1MEQ2Ni1cXFxcdTBENkZcXFxcdTBFNTAtXFxcXHUwRTU5XFxcXHUwRUQwLVxcXFx1MEVEOVxcXFx1MEYyMC1cXFxcdTBGMjlcXFxcdTEwNDAtXFxcXHUxMDQ5XFxcXHUxMDkwLVxcXFx1MTA5OVxcXFx1MTdFMC1cXFxcdTE3RTlcXFxcdTE4MTAtXFxcXHUxODE5XFxcXHUxOTQ2LVxcXFx1MTk0RlxcXFx1MTlEMC1cXFxcdTE5RDlcXFxcdTFBODAtXFxcXHUxQTg5XFxcXHUxQTkwLVxcXFx1MUE5OVxcXFx1MUI1MC1cXFxcdTFCNTlcXFxcdTFCQjAtXFxcXHUxQkI5XFxcXHUxQzQwLVxcXFx1MUM0OVxcXFx1MUM1MC1cXFxcdTFDNTlcXFxcdUE2MjAtXFxcXHVBNjI5XFxcXHVBOEQwLVxcXFx1QThEOVxcXFx1QTkwMC1cXFxcdUE5MDlcXFxcdUE5RDAtXFxcXHVBOUQ5XFxcXHVBQTUwLVxcXFx1QUE1OVxcXFx1QUJGMC1cXFxcdUFCRjlcXFxcdUZGMTAtXFxcXHVGRjE5XVwiKVxufTtcblxuZnVuY3Rpb24gaXNfbGV0dGVyKGNoKSB7XG4gICAgICAgIHJldHVybiBVTklDT0RFLmxldHRlci50ZXN0KGNoKTtcbn07XG5cbmZ1bmN0aW9uIGlzX2RpZ2l0KGNoKSB7XG4gICAgICAgIGNoID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgcmV0dXJuIGNoID49IDQ4ICYmIGNoIDw9IDU3O1xufTtcblxuZnVuY3Rpb24gaXNfdW5pY29kZV9kaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gVU5JQ09ERS5kaWdpdC50ZXN0KGNoKTtcbn1cblxuZnVuY3Rpb24gaXNfYWxwaGFudW1lcmljX2NoYXIoY2gpIHtcbiAgICAgICAgcmV0dXJuIGlzX2RpZ2l0KGNoKSB8fCBpc19sZXR0ZXIoY2gpO1xufTtcblxuZnVuY3Rpb24gaXNfdW5pY29kZV9jb21iaW5pbmdfbWFyayhjaCkge1xuICAgICAgICByZXR1cm4gVU5JQ09ERS5jb21iaW5pbmdfbWFyay50ZXN0KGNoKTtcbn07XG5cbmZ1bmN0aW9uIGlzX3VuaWNvZGVfY29ubmVjdG9yX3B1bmN0dWF0aW9uKGNoKSB7XG4gICAgICAgIHJldHVybiBVTklDT0RFLmNvbm5lY3Rvcl9wdW5jdHVhdGlvbi50ZXN0KGNoKTtcbn07XG5cbmZ1bmN0aW9uIGlzX2lkZW50aWZpZXJfc3RhcnQoY2gpIHtcbiAgICAgICAgcmV0dXJuIGNoID09IFwiJFwiIHx8IGNoID09IFwiX1wiIHx8IGlzX2xldHRlcihjaCk7XG59O1xuXG5mdW5jdGlvbiBpc19pZGVudGlmaWVyX2NoYXIoY2gpIHtcbiAgICAgICAgcmV0dXJuIGlzX2lkZW50aWZpZXJfc3RhcnQoY2gpXG4gICAgICAgICAgICAgICAgfHwgaXNfdW5pY29kZV9jb21iaW5pbmdfbWFyayhjaClcbiAgICAgICAgICAgICAgICB8fCBpc191bmljb2RlX2RpZ2l0KGNoKVxuICAgICAgICAgICAgICAgIHx8IGlzX3VuaWNvZGVfY29ubmVjdG9yX3B1bmN0dWF0aW9uKGNoKVxuICAgICAgICAgICAgICAgIHx8IGNoID09IFwiXFx1MjAwY1wiIC8vIHplcm8td2lkdGggbm9uLWpvaW5lciA8WldOSj5cbiAgICAgICAgICAgICAgICB8fCBjaCA9PSBcIlxcdTIwMGRcIiAvLyB6ZXJvLXdpZHRoIGpvaW5lciA8WldKPiAoaW4gbXkgRUNNQS0yNjIgUERGLCB0aGlzIGlzIGFsc28gMjAwYylcbiAgICAgICAgO1xufTtcblxuZnVuY3Rpb24gcGFyc2VfanNfbnVtYmVyKG51bSkge1xuICAgICAgICBpZiAoUkVfSEVYX05VTUJFUi50ZXN0KG51bSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtLnN1YnN0cigyKSwgMTYpO1xuICAgICAgICB9IGVsc2UgaWYgKFJFX09DVF9OVU1CRVIudGVzdChudW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bS5zdWJzdHIoMSksIDgpO1xuICAgICAgICB9IGVsc2UgaWYgKFJFX0RFQ19OVU1CRVIudGVzdChudW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobnVtKTtcbiAgICAgICAgfVxufTtcblxuZnVuY3Rpb24gSlNfUGFyc2VfRXJyb3IobWVzc2FnZSwgbGluZSwgY29sLCBwb3MpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5saW5lID0gbGluZSArIDE7XG4gICAgICAgIHRoaXMuY29sID0gY29sICsgMTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3MgKyAxO1xuICAgICAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG59O1xuXG5KU19QYXJzZV9FcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZSArIFwiIChsaW5lOiBcIiArIHRoaXMubGluZSArIFwiLCBjb2w6IFwiICsgdGhpcy5jb2wgKyBcIiwgcG9zOiBcIiArIHRoaXMucG9zICsgXCIpXCIgKyBcIlxcblxcblwiICsgdGhpcy5zdGFjaztcbn07XG5cbmZ1bmN0aW9uIGpzX2Vycm9yKG1lc3NhZ2UsIGxpbmUsIGNvbCwgcG9zKSB7XG4gICAgICAgIHRocm93IG5ldyBKU19QYXJzZV9FcnJvcihtZXNzYWdlLCBsaW5lLCBjb2wsIHBvcyk7XG59O1xuXG5mdW5jdGlvbiBpc190b2tlbih0b2tlbiwgdHlwZSwgdmFsKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi50eXBlID09IHR5cGUgJiYgKHZhbCA9PSBudWxsIHx8IHRva2VuLnZhbHVlID09IHZhbCk7XG59O1xuXG52YXIgRVhfRU9GID0ge307XG5cbmZ1bmN0aW9uIHRva2VuaXplcigkVEVYVCkge1xuXG4gICAgICAgIHZhciBTID0ge1xuICAgICAgICAgICAgICAgIHRleHQgICAgICAgICAgICA6ICRURVhULnJlcGxhY2UoL1xcclxcbj98W1xcblxcdTIwMjhcXHUyMDI5XS9nLCBcIlxcblwiKS5yZXBsYWNlKC9eXFx1RkVGRi8sICcnKSxcbiAgICAgICAgICAgICAgICBwb3MgICAgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgICAgIHRva3BvcyAgICAgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgbGluZSAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgICAgICB0b2tsaW5lICAgICAgICAgOiAwLFxuICAgICAgICAgICAgICAgIGNvbCAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgdG9rY29sICAgICAgICAgIDogMCxcbiAgICAgICAgICAgICAgICBuZXdsaW5lX2JlZm9yZSAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZWdleF9hbGxvd2VkICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb21tZW50c19iZWZvcmUgOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHBlZWsoKSB7IHJldHVybiBTLnRleHQuY2hhckF0KFMucG9zKTsgfTtcblxuICAgICAgICBmdW5jdGlvbiBuZXh0KHNpZ25hbF9lb2YsIGluX3N0cmluZykge1xuICAgICAgICAgICAgICAgIHZhciBjaCA9IFMudGV4dC5jaGFyQXQoUy5wb3MrKyk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25hbF9lb2YgJiYgIWNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRVhfRU9GO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBTLm5ld2xpbmVfYmVmb3JlID0gUy5uZXdsaW5lX2JlZm9yZSB8fCAhaW5fc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgKytTLmxpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBTLmNvbCA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrUy5jb2w7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaDtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBlb2YoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFTLnBlZWsoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBmaW5kKHdoYXQsIHNpZ25hbF9lb2YpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gUy50ZXh0LmluZGV4T2Yod2hhdCwgUy5wb3MpO1xuICAgICAgICAgICAgICAgIGlmIChzaWduYWxfZW9mICYmIHBvcyA9PSAtMSkgdGhyb3cgRVhfRU9GO1xuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gc3RhcnRfdG9rZW4oKSB7XG4gICAgICAgICAgICAgICAgUy50b2tsaW5lID0gUy5saW5lO1xuICAgICAgICAgICAgICAgIFMudG9rY29sID0gUy5jb2w7XG4gICAgICAgICAgICAgICAgUy50b2twb3MgPSBTLnBvcztcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiB0b2tlbih0eXBlLCB2YWx1ZSwgaXNfY29tbWVudCkge1xuICAgICAgICAgICAgICAgIFMucmVnZXhfYWxsb3dlZCA9ICgodHlwZSA9PSBcIm9wZXJhdG9yXCIgJiYgIUhPUChVTkFSWV9QT1NURklYLCB2YWx1ZSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlID09IFwia2V5d29yZFwiICYmIEhPUChLRVlXT1JEU19CRUZPUkVfRVhQUkVTU0lPTiwgdmFsdWUpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZSA9PSBcInB1bmNcIiAmJiBIT1AoUFVOQ19CRUZPUkVfRVhQUkVTU0lPTiwgdmFsdWUpKSk7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgICA6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgICA6IFMudG9rbGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbCAgICA6IFMudG9rY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zICAgIDogUy50b2twb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRwb3MgOiBTLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5sYiAgICA6IFMubmV3bGluZV9iZWZvcmVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICghaXNfY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LmNvbW1lbnRzX2JlZm9yZSA9IFMuY29tbWVudHNfYmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgUy5jb21tZW50c19iZWZvcmUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugbm90ZSBvZiBhbnkgbmV3bGluZXMgaW4gdGhlIGNvbW1lbnRzIHRoYXQgY2FtZSBiZWZvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZXQuY29tbWVudHNfYmVmb3JlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5ubGIgPSByZXQubmxiIHx8IHJldC5jb21tZW50c19iZWZvcmVbaV0ubmxiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBTLm5ld2xpbmVfYmVmb3JlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBza2lwX3doaXRlc3BhY2UoKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKEhPUChXSElURVNQQUNFX0NIQVJTLCBwZWVrKCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRfd2hpbGUocHJlZCkge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBcIlwiLCBjaCA9IHBlZWsoKSwgaSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNoICYmIHByZWQoY2gsIGkrKykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCArPSBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHBlZWsoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBwYXJzZV9lcnJvcihlcnIpIHtcbiAgICAgICAgICAgICAgICBqc19lcnJvcihlcnIsIFMudG9rbGluZSwgUy50b2tjb2wsIFMudG9rcG9zKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiByZWFkX251bShwcmVmaXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFzX2UgPSBmYWxzZSwgYWZ0ZXJfZSA9IGZhbHNlLCBoYXNfeCA9IGZhbHNlLCBoYXNfZG90ID0gcHJlZml4ID09IFwiLlwiO1xuICAgICAgICAgICAgICAgIHZhciBudW0gPSByZWFkX3doaWxlKGZ1bmN0aW9uKGNoLCBpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PSBcInhcIiB8fCBjaCA9PSBcIlhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzX3gpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc194ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzX3ggJiYgKGNoID09IFwiRVwiIHx8IGNoID09IFwiZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzX2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc19lID0gYWZ0ZXJfZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFmdGVyX2UgfHwgKGkgPT0gMCAmJiAhcHJlZml4KSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PSBcIitcIikgcmV0dXJuIGFmdGVyX2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlcl9lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNfZG90ICYmICFoYXNfeCAmJiAhaGFzX2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc19kb3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNfYWxwaGFudW1lcmljX2NoYXIoY2gpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChwcmVmaXgpXG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSBwcmVmaXggKyBudW07XG4gICAgICAgICAgICAgICAgdmFyIHZhbGlkID0gcGFyc2VfanNfbnVtYmVyKG51bSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTih2YWxpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbihcIm51bVwiLCB2YWxpZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlX2Vycm9yKFwiSW52YWxpZCBzeW50YXg6IFwiICsgbnVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZF9lc2NhcGVkX2NoYXIoaW5fc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoID0gbmV4dCh0cnVlLCBpbl9zdHJpbmcpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5cIiA6IHJldHVybiBcIlxcblwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiclwiIDogcmV0dXJuIFwiXFxyXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0XCIgOiByZXR1cm4gXCJcXHRcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJcIiA6IHJldHVybiBcIlxcYlwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidlwiIDogcmV0dXJuIFwiXFx1MDAwYlwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZlwiIDogcmV0dXJuIFwiXFxmXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCIwXCIgOiByZXR1cm4gXCJcXDBcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInhcIiA6IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGhleF9ieXRlcygyKSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1XCIgOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShoZXhfYnl0ZXMoNCkpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXFxuXCI6IHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0ICA6IHJldHVybiBjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gaGV4X2J5dGVzKG4pIHtcbiAgICAgICAgICAgICAgICB2YXIgbnVtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKDsgbiA+IDA7IC0tbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpZ2l0ID0gcGFyc2VJbnQobmV4dCh0cnVlKSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGRpZ2l0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VfZXJyb3IoXCJJbnZhbGlkIGhleC1jaGFyYWN0ZXIgcGF0dGVybiBpbiBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSAobnVtIDw8IDQpIHwgZGlnaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZF9zdHJpbmcoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpdGhfZW9mX2Vycm9yKFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHF1b3RlID0gbmV4dCgpLCByZXQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2ggPSBuZXh0KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWFkIE9jdGFsRXNjYXBlU2VxdWVuY2UgKFhYWDogZGVwcmVjYXRlZCBpZiBcInN0cmljdCBtb2RlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUy9pc3N1ZXMvMTc4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9jdGFsX2xlbiA9IDAsIGZpcnN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHJlYWRfd2hpbGUoZnVuY3Rpb24oY2gpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID49IFwiMFwiICYmIGNoIDw9IFwiN1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiArK29jdGFsX2xlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaXJzdCA8PSBcIjNcIiAmJiBvY3RhbF9sZW4gPD0gMikgcmV0dXJuICsrb2N0YWxfbGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaXJzdCA+PSBcIjRcIiAmJiBvY3RhbF9sZW4gPD0gMSkgcmV0dXJuICsrb2N0YWxfbGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvY3RhbF9sZW4gPiAwKSBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoY2gsIDgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGNoID0gcmVhZF9lc2NhcGVkX2NoYXIodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT0gcXVvdGUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4oXCJzdHJpbmdcIiwgcmV0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiByZWFkX2xpbmVfY29tbWVudCgpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBmaW5kKFwiXFxuXCIpLCByZXQ7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IFMudGV4dC5zdWJzdHIoUy5wb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgUy5wb3MgPSBTLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBTLnRleHQuc3Vic3RyaW5nKFMucG9zLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMucG9zID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuKFwiY29tbWVudDFcIiwgcmV0LCB0cnVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiByZWFkX211bHRpbGluZV9jb21tZW50KCkge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aF9lb2ZfZXJyb3IoXCJVbnRlcm1pbmF0ZWQgbXVsdGlsaW5lIGNvbW1lbnRcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gZmluZChcIiovXCIsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBTLnRleHQuc3Vic3RyaW5nKFMucG9zLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMucG9zID0gaSArIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBTLmxpbmUgKz0gdGV4dC5zcGxpdChcIlxcblwiKS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgUy5uZXdsaW5lX2JlZm9yZSA9IFMubmV3bGluZV9iZWZvcmUgfHwgdGV4dC5pbmRleE9mKFwiXFxuXCIpID49IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMvaXNzdWVzLyNpc3N1ZS8xMDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXkBjY19vbi9pLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybihcIldBUk5JTkc6IGF0IGxpbmUgXCIgKyBTLmxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuKFwiKioqIEZvdW5kIFxcXCJjb25kaXRpb25hbCBjb21tZW50XFxcIjogXCIgKyB0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybihcIioqKiBVZ2xpZnlKUyBESVNDQVJEUyBBTEwgQ09NTUVOVFMuICBUaGlzIG1lYW5zIHlvdXIgY29kZSBtaWdodCBubyBsb25nZXIgd29yayBwcm9wZXJseSBpbiBJbnRlcm5ldCBFeHBsb3Jlci5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbihcImNvbW1lbnQyXCIsIHRleHQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRfbmFtZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmFja3NsYXNoID0gZmFsc2UsIG5hbWUgPSBcIlwiLCBjaCwgZXNjYXBlZCA9IGZhbHNlLCBoZXg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChjaCA9IHBlZWsoKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiYWNrc2xhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09IFwiXFxcXFwiKSBlc2NhcGVkID0gYmFja3NsYXNoID0gdHJ1ZSwgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc19pZGVudGlmaWVyX2NoYXIoY2gpKSBuYW1lICs9IG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggIT0gXCJ1XCIpIHBhcnNlX2Vycm9yKFwiRXhwZWN0aW5nIFVuaWNvZGVFc2NhcGVTZXF1ZW5jZSAtLSB1WFhYWFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSByZWFkX2VzY2FwZWRfY2hhcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzX2lkZW50aWZpZXJfY2hhcihjaCkpIHBhcnNlX2Vycm9yKFwiVW5pY29kZSBjaGFyOiBcIiArIGNoLmNoYXJDb2RlQXQoMCkgKyBcIiBpcyBub3QgdmFsaWQgaW4gaWRlbnRpZmllclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja3NsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChIT1AoS0VZV09SRFMsIG5hbWUpICYmIGVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhleCA9IG5hbWUuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIlxcXFx1XCIgKyBcIjAwMDBcIi5zdWJzdHIoaGV4Lmxlbmd0aCkgKyBoZXggKyBuYW1lLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiByZWFkX3JlZ2V4cChyZWdleHApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aF9lb2ZfZXJyb3IoXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldl9iYWNrc2xhc2ggPSBmYWxzZSwgY2gsIGluX2NsYXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGNoID0gbmV4dCh0cnVlKSkpIGlmIChwcmV2X2JhY2tzbGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleHAgKz0gXCJcXFxcXCIgKyBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldl9iYWNrc2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5fY2xhc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleHAgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiXVwiICYmIGluX2NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluX2NsYXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4cCArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIvXCIgJiYgIWluX2NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2X2JhY2tzbGFzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleHAgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kcyA9IHJlYWRfbmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuKFwicmVnZXhwXCIsIFsgcmVnZXhwLCBtb2RzIF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRfb3BlcmF0b3IocHJlZml4KSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ3JvdyhvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwZWVrKCkpIHJldHVybiBvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiaWdnZXIgPSBvcCArIHBlZWsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChIT1AoT1BFUkFUT1JTLCBiaWdnZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyb3coYmlnZ2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbihcIm9wZXJhdG9yXCIsIGdyb3cocHJlZml4IHx8IG5leHQoKSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZV9zbGFzaCgpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4X2FsbG93ZWQgPSBTLnJlZ2V4X2FsbG93ZWQ7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwZWVrKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIFMuY29tbWVudHNfYmVmb3JlLnB1c2gocmVhZF9saW5lX2NvbW1lbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBTLnJlZ2V4X2FsbG93ZWQgPSByZWdleF9hbGxvd2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRfdG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIFMuY29tbWVudHNfYmVmb3JlLnB1c2gocmVhZF9tdWx0aWxpbmVfY29tbWVudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMucmVnZXhfYWxsb3dlZCA9IHJlZ2V4X2FsbG93ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dF90b2tlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUy5yZWdleF9hbGxvd2VkID8gcmVhZF9yZWdleHAoXCJcIikgOiByZWFkX29wZXJhdG9yKFwiL1wiKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVfZG90KCkge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNfZGlnaXQocGVlaygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZWFkX251bShcIi5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdG9rZW4oXCJwdW5jXCIsIFwiLlwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiByZWFkX3dvcmQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdvcmQgPSByZWFkX25hbWUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIUhPUChLRVlXT1JEUywgd29yZClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdG9rZW4oXCJuYW1lXCIsIHdvcmQpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IEhPUChPUEVSQVRPUlMsIHdvcmQpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRva2VuKFwib3BlcmF0b3JcIiwgd29yZClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogSE9QKEtFWVdPUkRTX0FUT00sIHdvcmQpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRva2VuKFwiYXRvbVwiLCB3b3JkKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0b2tlbihcImtleXdvcmRcIiwgd29yZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gd2l0aF9lb2ZfZXJyb3IoZW9mX2Vycm9yLCBjb250KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250KCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4ID09PSBFWF9FT0YpIHBhcnNlX2Vycm9yKGVvZl9lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHRocm93IGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBuZXh0X3Rva2VuKGZvcmNlX3JlZ2V4cCkge1xuICAgICAgICAgICAgICAgIGlmIChmb3JjZV9yZWdleHAgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkX3JlZ2V4cChmb3JjZV9yZWdleHApO1xuICAgICAgICAgICAgICAgIHNraXBfd2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIHN0YXJ0X3Rva2VuKCk7XG4gICAgICAgICAgICAgICAgdmFyIGNoID0gcGVlaygpO1xuICAgICAgICAgICAgICAgIGlmICghY2gpIHJldHVybiB0b2tlbihcImVvZlwiKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNfZGlnaXQoY2gpKSByZXR1cm4gcmVhZF9udW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT0gJ1wiJyB8fCBjaCA9PSBcIidcIikgcmV0dXJuIHJlYWRfc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKEhPUChQVU5DX0NIQVJTLCBjaCkpIHJldHVybiB0b2tlbihcInB1bmNcIiwgbmV4dCgpKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT0gXCIuXCIpIHJldHVybiBoYW5kbGVfZG90KCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09IFwiL1wiKSByZXR1cm4gaGFuZGxlX3NsYXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKEhPUChPUEVSQVRPUl9DSEFSUywgY2gpKSByZXR1cm4gcmVhZF9vcGVyYXRvcigpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PSBcIlxcXFxcIiB8fCBpc19pZGVudGlmaWVyX3N0YXJ0KGNoKSkgcmV0dXJuIHJlYWRfd29yZCgpO1xuICAgICAgICAgICAgICAgIHBhcnNlX2Vycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY2ggKyBcIidcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgbmV4dF90b2tlbi5jb250ZXh0ID0gZnVuY3Rpb24obmMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmMpIFMgPSBuYztcbiAgICAgICAgICAgICAgICByZXR1cm4gUztcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dF90b2tlbjtcblxufTtcblxuLyogLS0tLS1bIFBhcnNlciAoY29uc3RhbnRzKSBdLS0tLS0gKi9cblxudmFyIFVOQVJZX1BSRUZJWCA9IGFycmF5X3RvX2hhc2goW1xuICAgICAgICBcInR5cGVvZlwiLFxuICAgICAgICBcInZvaWRcIixcbiAgICAgICAgXCJkZWxldGVcIixcbiAgICAgICAgXCItLVwiLFxuICAgICAgICBcIisrXCIsXG4gICAgICAgIFwiIVwiLFxuICAgICAgICBcIn5cIixcbiAgICAgICAgXCItXCIsXG4gICAgICAgIFwiK1wiXG5dKTtcblxudmFyIFVOQVJZX1BPU1RGSVggPSBhcnJheV90b19oYXNoKFsgXCItLVwiLCBcIisrXCIgXSk7XG5cbnZhciBBU1NJR05NRU5UID0gKGZ1bmN0aW9uKGEsIHJldCwgaSl7XG4gICAgICAgIHdoaWxlIChpIDwgYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXRbYVtpXV0gPSBhW2ldLnN1YnN0cigwLCBhW2ldLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xufSkoXG4gICAgICAgIFtcIis9XCIsIFwiLT1cIiwgXCIvPVwiLCBcIio9XCIsIFwiJT1cIiwgXCI+Pj1cIiwgXCI8PD1cIiwgXCI+Pj49XCIsIFwifD1cIiwgXCJePVwiLCBcIiY9XCJdLFxuICAgICAgICB7IFwiPVwiOiB0cnVlIH0sXG4gICAgICAgIDBcbik7XG5cbnZhciBQUkVDRURFTkNFID0gKGZ1bmN0aW9uKGEsIHJldCl7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gMTsgaSA8IGEubGVuZ3RoOyArK2ksICsrbikge1xuICAgICAgICAgICAgICAgIHZhciBiID0gYVtpXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGIubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldFtiW2pdXSA9IG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG59KShcbiAgICAgICAgW1xuICAgICAgICAgICAgICAgIFtcInx8XCJdLFxuICAgICAgICAgICAgICAgIFtcIiYmXCJdLFxuICAgICAgICAgICAgICAgIFtcInxcIl0sXG4gICAgICAgICAgICAgICAgW1wiXlwiXSxcbiAgICAgICAgICAgICAgICBbXCImXCJdLFxuICAgICAgICAgICAgICAgIFtcIj09XCIsIFwiPT09XCIsIFwiIT1cIiwgXCIhPT1cIl0sXG4gICAgICAgICAgICAgICAgW1wiPFwiLCBcIj5cIiwgXCI8PVwiLCBcIj49XCIsIFwiaW5cIiwgXCJpbnN0YW5jZW9mXCJdLFxuICAgICAgICAgICAgICAgIFtcIj4+XCIsIFwiPDxcIiwgXCI+Pj5cIl0sXG4gICAgICAgICAgICAgICAgW1wiK1wiLCBcIi1cIl0sXG4gICAgICAgICAgICAgICAgW1wiKlwiLCBcIi9cIiwgXCIlXCJdXG4gICAgICAgIF0sXG4gICAgICAgIHt9XG4pO1xuXG52YXIgU1RBVEVNRU5UU19XSVRIX0xBQkVMUyA9IGFycmF5X3RvX2hhc2goWyBcImZvclwiLCBcImRvXCIsIFwid2hpbGVcIiwgXCJzd2l0Y2hcIiBdKTtcblxudmFyIEFUT01JQ19TVEFSVF9UT0tFTiA9IGFycmF5X3RvX2hhc2goWyBcImF0b21cIiwgXCJudW1cIiwgXCJzdHJpbmdcIiwgXCJyZWdleHBcIiwgXCJuYW1lXCIgXSk7XG5cbi8qIC0tLS0tWyBQYXJzZXIgXS0tLS0tICovXG5cbmZ1bmN0aW9uIE5vZGVXaXRoVG9rZW4oc3RyLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IHN0cjtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbn07XG5cbk5vZGVXaXRoVG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm5hbWU7IH07XG5cbmZ1bmN0aW9uIHBhcnNlKCRURVhULCBleGlnZW50X21vZGUsIGVtYmVkX3Rva2Vucykge1xuXG4gICAgICAgIHZhciBTID0ge1xuICAgICAgICAgICAgICAgIGlucHV0ICAgICAgICAgOiB0eXBlb2YgJFRFWFQgPT0gXCJzdHJpbmdcIiA/IHRva2VuaXplcigkVEVYVCwgdHJ1ZSkgOiAkVEVYVCxcbiAgICAgICAgICAgICAgICB0b2tlbiAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBwcmV2ICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBwZWVrZWQgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBpbl9mdW5jdGlvbiAgIDogMCxcbiAgICAgICAgICAgICAgICBpbl9kaXJlY3RpdmVzIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbl9sb29wICAgICAgIDogMCxcbiAgICAgICAgICAgICAgICBsYWJlbHMgICAgICAgIDogW11cbiAgICAgICAgfTtcblxuICAgICAgICBTLnRva2VuID0gbmV4dCgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlzKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzX3Rva2VuKFMudG9rZW4sIHR5cGUsIHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBwZWVrKCkgeyByZXR1cm4gUy5wZWVrZWQgfHwgKFMucGVla2VkID0gUy5pbnB1dCgpKTsgfTtcblxuICAgICAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgICAgIFMucHJldiA9IFMudG9rZW47XG4gICAgICAgICAgICAgICAgaWYgKFMucGVla2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBTLnRva2VuID0gUy5wZWVrZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBTLnBlZWtlZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMudG9rZW4gPSBTLmlucHV0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFMuaW5fZGlyZWN0aXZlcyA9IFMuaW5fZGlyZWN0aXZlcyAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBTLnRva2VuLnR5cGUgPT0gXCJzdHJpbmdcIiB8fCBpcyhcInB1bmNcIiwgXCI7XCIpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUy50b2tlbjtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBwcmV2KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTLnByZXY7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gY3JvYWsobXNnLCBsaW5lLCBjb2wsIHBvcykge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSBTLmlucHV0LmNvbnRleHQoKTtcbiAgICAgICAgICAgICAgICBqc19lcnJvcihtc2csXG4gICAgICAgICAgICAgICAgICAgICAgICAgbGluZSAhPSBudWxsID8gbGluZSA6IGN0eC50b2tsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGNvbCAhPSBudWxsID8gY29sIDogY3R4LnRva2NvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgIT0gbnVsbCA/IHBvcyA6IGN0eC50b2twb3MpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHRva2VuX2Vycm9yKHRva2VuLCBtc2cpIHtcbiAgICAgICAgICAgICAgICBjcm9hayhtc2csIHRva2VuLmxpbmUsIHRva2VuLmNvbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gdW5leHBlY3RlZCh0b2tlbikge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBTLnRva2VuO1xuICAgICAgICAgICAgICAgIHRva2VuX2Vycm9yKHRva2VuLCBcIlVuZXhwZWN0ZWQgdG9rZW46IFwiICsgdG9rZW4udHlwZSArIFwiIChcIiArIHRva2VuLnZhbHVlICsgXCIpXCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGV4cGVjdF90b2tlbih0eXBlLCB2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXModHlwZSwgdmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW5fZXJyb3IoUy50b2tlbiwgXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgUy50b2tlbi50eXBlICsgXCIsIGV4cGVjdGVkIFwiICsgdHlwZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZXhwZWN0KHB1bmMpIHsgcmV0dXJuIGV4cGVjdF90b2tlbihcInB1bmNcIiwgcHVuYyk7IH07XG5cbiAgICAgICAgZnVuY3Rpb24gY2FuX2luc2VydF9zZW1pY29sb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFleGlnZW50X21vZGUgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgUy50b2tlbi5ubGIgfHwgaXMoXCJlb2ZcIikgfHwgaXMoXCJwdW5jXCIsIFwifVwiKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gc2VtaWNvbG9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCI7XCIpKSBuZXh0KCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWNhbl9pbnNlcnRfc2VtaWNvbG9uKCkpIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBhcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2xpY2UoYXJndW1lbnRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBwYXJlbnRoZXNpc2VkKCkge1xuICAgICAgICAgICAgICAgIGV4cGVjdChcIihcIik7XG4gICAgICAgICAgICAgICAgdmFyIGV4ID0gZXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChcIilcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4O1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGFkZF90b2tlbnMoc3RyLCBzdGFydCwgZW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0ciBpbnN0YW5jZW9mIE5vZGVXaXRoVG9rZW4gPyBzdHIgOiBuZXcgTm9kZVdpdGhUb2tlbihzdHIsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG1heWJlX2VtYmVkX3Rva2VucyhwYXJzZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW1iZWRfdG9rZW5zKSByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFzdCA9IHBhcnNlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXN0WzBdID0gYWRkX3Rva2Vucyhhc3RbMF0sIHN0YXJ0LCBwcmV2KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIHBhcnNlcjtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc3RhdGVtZW50ID0gbWF5YmVfZW1iZWRfdG9rZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChpcyhcIm9wZXJhdG9yXCIsIFwiL1wiKSB8fCBpcyhcIm9wZXJhdG9yXCIsIFwiLz1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMucGVla2VkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMudG9rZW4gPSBTLmlucHV0KFMudG9rZW4udmFsdWUuc3Vic3RyKDEpKTsgLy8gZm9yY2UgcmVnZXhwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoUy50b2tlbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXIgPSBTLmluX2RpcmVjdGl2ZXMsIHN0YXQgPSBzaW1wbGVfc3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyICYmIHN0YXRbMV1bMF0gPT0gXCJzdHJpbmdcIiAmJiAhaXMoXCJwdW5jXCIsIFwiLFwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJkaXJlY3RpdmVcIiwgc3RhdFsxXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm51bVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVnZXhwXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvcGVyYXRvclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXRvbVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsZV9zdGF0ZW1lbnQoKTtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzX3Rva2VuKHBlZWsoKSwgXCJwdW5jXCIsIFwiOlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGxhYmVsZWRfc3RhdGVtZW50KHByb2cxKFMudG9rZW4udmFsdWUsIG5leHQsIG5leHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNpbXBsZV9zdGF0ZW1lbnQoKTtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicHVuY1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChTLnRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIntcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwiYmxvY2tcIiwgYmxvY2tfKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJbXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIihcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsZV9zdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiO1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcyhcImJsb2NrXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwia2V5d29yZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwcm9nMShTLnRva2VuLnZhbHVlLCBuZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJicmVha1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnJlYWtfY29udChcImJyZWFrXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNvbnRpbnVlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBicmVha19jb250KFwiY29udGludWVcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGVidWdnZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcyhcImRlYnVnZ2VyXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRvXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24oYm9keSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0X3Rva2VuKFwia2V5d29yZFwiLCBcIndoaWxlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcyhcImRvXCIsIHByb2cxKHBhcmVudGhlc2lzZWQsIHNlbWljb2xvbiksIGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KShpbl9sb29wKHN0YXRlbWVudCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZvclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9yXygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbl8odHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaWZcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlmXygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJldHVyblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoUy5pbl9mdW5jdGlvbiA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwicmV0dXJuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyhcInB1bmNcIiwgXCI7XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChuZXh0KCksIG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNhbl9pbnNlcnRfc2VtaWNvbG9uKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBwcm9nMShleHByZXNzaW9uLCBzZW1pY29sb24pKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzd2l0Y2hcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwic3dpdGNoXCIsIHBhcmVudGhlc2lzZWQoKSwgc3dpdGNoX2Jsb2NrXygpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0aHJvd1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoUy50b2tlbi5ubGIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgJ3Rocm93J1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwidGhyb3dcIiwgcHJvZzEoZXhwcmVzc2lvbiwgc2VtaWNvbG9uKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidHJ5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlfKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidmFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9nMSh2YXJfLCBzZW1pY29sb24pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9nMShjb25zdF8sIHNlbWljb2xvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwid2hpbGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwid2hpbGVcIiwgcGFyZW50aGVzaXNlZCgpLCBpbl9sb29wKHN0YXRlbWVudCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIndpdGhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwid2l0aFwiLCBwYXJlbnRoZXNpc2VkKCksIHN0YXRlbWVudCgpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGxhYmVsZWRfc3RhdGVtZW50KGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgUy5sYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbiwgc3RhdCA9IHN0YXRlbWVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChleGlnZW50X21vZGUgJiYgIUhPUChTVEFURU1FTlRTX1dJVEhfTEFCRUxTLCBzdGF0WzBdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoc3RhcnQpO1xuICAgICAgICAgICAgICAgIFMubGFiZWxzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcyhcImxhYmVsXCIsIGxhYmVsLCBzdGF0KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBzaW1wbGVfc3RhdGVtZW50KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcyhcInN0YXRcIiwgcHJvZzEoZXhwcmVzc2lvbiwgc2VtaWNvbG9uKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gYnJlYWtfY29udCh0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCFjYW5faW5zZXJ0X3NlbWljb2xvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gaXMoXCJuYW1lXCIpID8gUy50b2tlbi52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWVtYmVyKG5hbWUsIFMubGFiZWxzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJMYWJlbCBcIiArIG5hbWUgKyBcIiB3aXRob3V0IG1hdGNoaW5nIGxvb3Agb3Igc3RhdGVtZW50XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChTLmluX2xvb3AgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb2FrKHR5cGUgKyBcIiBub3QgaW5zaWRlIGEgbG9vcCBvciBzd2l0Y2hcIik7XG4gICAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzKHR5cGUsIG5hbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGZvcl8oKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFwiKFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFpcyhcInB1bmNcIiwgXCI7XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gaXMoXCJrZXl3b3JkXCIsIFwidmFyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKG5leHQoKSwgdmFyXyh0cnVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBleHByZXNzaW9uKHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCJpblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdFswXSA9PSBcInZhclwiICYmIGluaXRbMV0ubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcm9hayhcIk9ubHkgb25lIHZhcmlhYmxlIGRlY2xhcmF0aW9uIGFsbG93ZWQgaW4gZm9yLi5pbiBsb29wXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9yX2luKGluaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVndWxhcl9mb3IoaW5pdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcmVndWxhcl9mb3IoaW5pdCkge1xuICAgICAgICAgICAgICAgIGV4cGVjdChcIjtcIik7XG4gICAgICAgICAgICAgICAgdmFyIHRlc3QgPSBpcyhcInB1bmNcIiwgXCI7XCIpID8gbnVsbCA6IGV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoXCI7XCIpO1xuICAgICAgICAgICAgICAgIHZhciBzdGVwID0gaXMoXCJwdW5jXCIsIFwiKVwiKSA/IG51bGwgOiBleHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFwiKVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJmb3JcIiwgaW5pdCwgdGVzdCwgc3RlcCwgaW5fbG9vcChzdGF0ZW1lbnQpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBmb3JfaW4oaW5pdCkge1xuICAgICAgICAgICAgICAgIHZhciBsaHMgPSBpbml0WzBdID09IFwidmFyXCIgPyBhcyhcIm5hbWVcIiwgaW5pdFsxXVswXSkgOiBpbml0O1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gZXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChcIilcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwiZm9yLWluXCIsIGluaXQsIGxocywgb2JqLCBpbl9sb29wKHN0YXRlbWVudCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBmdW5jdGlvbl8gPSBmdW5jdGlvbihpbl9zdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGlzKFwibmFtZVwiKSA/IHByb2cxKFMudG9rZW4udmFsdWUsIG5leHQpIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoaW5fc3RhdGVtZW50ICYmICFuYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChcIihcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzKGluX3N0YXRlbWVudCA/IFwiZGVmdW5cIiA6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbihmaXJzdCwgYSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFpcyhcInB1bmNcIiwgXCIpXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIGZpcnN0ID0gZmFsc2U7IGVsc2UgZXhwZWN0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXMoXCJuYW1lXCIpKSB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goUy50b2tlbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSkodHJ1ZSwgW10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBib2R5XG4gICAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrUy5pbl9mdW5jdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9vcCA9IFMuaW5fbG9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTLmluX2RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFMuaW5fbG9vcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBibG9ja18oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLVMuaW5fZnVuY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUy5pbl9sb29wID0gbG9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gaWZfKCkge1xuICAgICAgICAgICAgICAgIHZhciBjb25kID0gcGFyZW50aGVzaXNlZCgpLCBib2R5ID0gc3RhdGVtZW50KCksIGJlbHNlO1xuICAgICAgICAgICAgICAgIGlmIChpcyhcImtleXdvcmRcIiwgXCJlbHNlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWxzZSA9IHN0YXRlbWVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJpZlwiLCBjb25kLCBib2R5LCBiZWxzZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gYmxvY2tfKCkge1xuICAgICAgICAgICAgICAgIGV4cGVjdChcIntcIik7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWlzKFwicHVuY1wiLCBcIn1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyhcImVvZlwiKSkgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHN0YXRlbWVudCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzd2l0Y2hfYmxvY2tfID0gY3VycnkoaW5fbG9vcCwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBleHBlY3QoXCJ7XCIpO1xuICAgICAgICAgICAgICAgIHZhciBhID0gW10sIGN1ciA9IG51bGw7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFpcyhcInB1bmNcIiwgXCJ9XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMoXCJlb2ZcIikpIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyhcImtleXdvcmRcIiwgXCJjYXNlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChbIGV4cHJlc3Npb24oKSwgY3VyIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QoXCI6XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiZGVmYXVsdFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChcIjpcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goWyBudWxsLCBjdXIgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXIpIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyLnB1c2goc3RhdGVtZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIHRyeV8oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBibG9ja18oKSwgYmNhdGNoLCBiZmluYWxseTtcbiAgICAgICAgICAgICAgICBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiY2F0Y2hcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChcIihcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzKFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJOYW1lIGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBTLnRva2VuLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KFwiKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJjYXRjaCA9IFsgbmFtZSwgYmxvY2tfKCkgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzKFwia2V5d29yZFwiLCBcImZpbmFsbHlcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJmaW5hbGx5ID0gYmxvY2tfKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghYmNhdGNoICYmICFiZmluYWxseSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiTWlzc2luZyBjYXRjaC9maW5hbGx5IGJsb2Nrc1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJ0cnlcIiwgYm9keSwgYmNhdGNoLCBiZmluYWxseSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gdmFyZGVmcyhub19pbikge1xuICAgICAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpcyhcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gUy50b2tlbi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyhcIm9wZXJhdG9yXCIsIFwiPVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChbIG5hbWUsIGV4cHJlc3Npb24oZmFsc2UsIG5vX2luKSBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChbIG5hbWUgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzKFwicHVuY1wiLCBcIixcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiB2YXJfKG5vX2luKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwidmFyXCIsIHZhcmRlZnMobm9faW4pKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBjb25zdF8oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwiY29uc3RcIiwgdmFyZGVmcygpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBuZXdfKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdleHAgPSBleHByX2F0b20oZmFsc2UpLCBhcmdzO1xuICAgICAgICAgICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCIoXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gZXhwcl9saXN0KFwiKVwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhhcyhcIm5ld1wiLCBuZXdleHAsIGFyZ3MpLCB0cnVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZXhwcl9hdG9tID0gbWF5YmVfZW1iZWRfdG9rZW5zKGZ1bmN0aW9uKGFsbG93X2NhbGxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCJuZXdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdfKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpcyhcInB1bmNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoUy50b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMocHJvZzEoZXhwcmVzc2lvbiwgY3VycnkoZXhwZWN0LCBcIilcIikpLCBhbGxvd19jYWxscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhhcnJheV8oKSwgYWxsb3dfY2FsbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ7XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMob2JqZWN0XygpLCBhbGxvd19jYWxscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpcyhcImtleXdvcmRcIiwgXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoZnVuY3Rpb25fKGZhbHNlKSwgYWxsb3dfY2FsbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoSE9QKEFUT01JQ19TVEFSVF9UT0tFTiwgUy50b2tlbi50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0b20gPSBTLnRva2VuLnR5cGUgPT0gXCJyZWdleHBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGFzKFwicmVnZXhwXCIsIFMudG9rZW4udmFsdWVbMF0sIFMudG9rZW4udmFsdWVbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYXMoUy50b2tlbi50eXBlLCBTLnRva2VuLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKHByb2cxKGF0b20sIG5leHQpLCBhbGxvd19jYWxscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gZXhwcl9saXN0KGNsb3NpbmcsIGFsbG93X3RyYWlsaW5nX2NvbW1hLCBhbGxvd19lbXB0eSkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IHRydWUsIGEgPSBbXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWlzKFwicHVuY1wiLCBjbG9zaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KSBmaXJzdCA9IGZhbHNlOyBlbHNlIGV4cGVjdChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxsb3dfdHJhaWxpbmdfY29tbWEgJiYgaXMoXCJwdW5jXCIsIGNsb3NpbmcpKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCIsXCIpICYmIGFsbG93X2VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChbIFwiYXRvbVwiLCBcInVuZGVmaW5lZFwiIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGV4cHJlc3Npb24oZmFsc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGFycmF5XygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJhcnJheVwiLCBleHByX2xpc3QoXCJdXCIsICFleGlnZW50X21vZGUsIHRydWUpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBvYmplY3RfKCkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IHRydWUsIGEgPSBbXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWlzKFwicHVuY1wiLCBcIn1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdCkgZmlyc3QgPSBmYWxzZTsgZWxzZSBleHBlY3QoXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlnZW50X21vZGUgJiYgaXMoXCJwdW5jXCIsIFwifVwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsb3cgdHJhaWxpbmcgY29tbWFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IFMudG9rZW4udHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gYXNfcHJvcGVydHlfbmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gXCJuYW1lXCIgJiYgKG5hbWUgPT0gXCJnZXRcIiB8fCBuYW1lID09IFwic2V0XCIpICYmICFpcyhcInB1bmNcIiwgXCI6XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChbIGFzX25hbWUoKSwgZnVuY3Rpb25fKGZhbHNlKSwgbmFtZSBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChcIjpcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChbIG5hbWUsIGV4cHJlc3Npb24oZmFsc2UpIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwib2JqZWN0XCIsIGEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGFzX3Byb3BlcnR5X25hbWUoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChTLnRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm51bVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvZzEoUy50b2tlbi52YWx1ZSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhc19uYW1lKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gYXNfbmFtZSgpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKFMudG9rZW4udHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwib3BlcmF0b3JcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImtleXdvcmRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImF0b21cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9nMShTLnRva2VuLnZhbHVlLCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gc3Vic2NyaXB0cyhleHByLCBhbGxvd19jYWxscykge1xuICAgICAgICAgICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCIuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhhcyhcImRvdFwiLCBleHByLCBhc19uYW1lKCkpLCBhbGxvd19jYWxscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCJbXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhhcyhcInN1YlwiLCBleHByLCBwcm9nMShleHByZXNzaW9uLCBjdXJyeShleHBlY3QsIFwiXVwiKSkpLCBhbGxvd19jYWxscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhbGxvd19jYWxscyAmJiBpcyhcInB1bmNcIiwgXCIoXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhhcyhcImNhbGxcIiwgZXhwciwgZXhwcl9saXN0KFwiKVwiKSksIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBtYXliZV91bmFyeShhbGxvd19jYWxscykge1xuICAgICAgICAgICAgICAgIGlmIChpcyhcIm9wZXJhdG9yXCIpICYmIEhPUChVTkFSWV9QUkVGSVgsIFMudG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV91bmFyeShcInVuYXJ5LXByZWZpeFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZzEoUy50b2tlbi52YWx1ZSwgbmV4dCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXliZV91bmFyeShhbGxvd19jYWxscykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gZXhwcl9hdG9tKGFsbG93X2NhbGxzKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXMoXCJvcGVyYXRvclwiKSAmJiBIT1AoVU5BUllfUE9TVEZJWCwgUy50b2tlbi52YWx1ZSkgJiYgIVMudG9rZW4ubmxiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBtYWtlX3VuYXJ5KFwidW5hcnktcG9zdGZpeFwiLCBTLnRva2VuLnZhbHVlLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VfdW5hcnkodGFnLCBvcCwgZXhwcikge1xuICAgICAgICAgICAgICAgIGlmICgob3AgPT0gXCIrK1wiIHx8IG9wID09IFwiLS1cIikgJiYgIWlzX2Fzc2lnbmFibGUoZXhwcikpXG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9hayhcIkludmFsaWQgdXNlIG9mIFwiICsgb3AgKyBcIiBvcGVyYXRvclwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXModGFnLCBvcCwgZXhwcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZXhwcl9vcChsZWZ0LCBtaW5fcHJlYywgbm9faW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgb3AgPSBpcyhcIm9wZXJhdG9yXCIpID8gUy50b2tlbi52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKG9wICYmIG9wID09IFwiaW5cIiAmJiBub19pbikgb3AgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBwcmVjID0gb3AgIT0gbnVsbCA/IFBSRUNFREVOQ0Vbb3BdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocHJlYyAhPSBudWxsICYmIHByZWMgPiBtaW5fcHJlYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gZXhwcl9vcChtYXliZV91bmFyeSh0cnVlKSwgcHJlYywgbm9faW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cHJfb3AoYXMoXCJiaW5hcnlcIiwgb3AsIGxlZnQsIHJpZ2h0KSwgbWluX3ByZWMsIG5vX2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZXhwcl9vcHMobm9faW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwcl9vcChtYXliZV91bmFyeSh0cnVlKSwgMCwgbm9faW4pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG1heWJlX2NvbmRpdGlvbmFsKG5vX2luKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4cHIgPSBleHByX29wcyhub19pbik7XG4gICAgICAgICAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCI/XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeWVzID0gZXhwcmVzc2lvbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QoXCI6XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwiY29uZGl0aW9uYWxcIiwgZXhwciwgeWVzLCBleHByZXNzaW9uKGZhbHNlLCBub19pbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBpc19hc3NpZ25hYmxlKGV4cHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWV4aWdlbnRfbW9kZSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChleHByWzBdK1wiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRvdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3ViXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJuZXdcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNhbGxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cHJbMV0gIT0gXCJ0aGlzXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG1heWJlX2Fzc2lnbihub19pbikge1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gbWF5YmVfY29uZGl0aW9uYWwobm9faW4pLCB2YWwgPSBTLnRva2VuLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChpcyhcIm9wZXJhdG9yXCIpICYmIEhPUChBU1NJR05NRU5ULCB2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfYXNzaWduYWJsZShsZWZ0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcyhcImFzc2lnblwiLCBBU1NJR05NRU5UW3ZhbF0sIGxlZnQsIG1heWJlX2Fzc2lnbihub19pbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJJbnZhbGlkIGFzc2lnbm1lbnRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBleHByZXNzaW9uID0gbWF5YmVfZW1iZWRfdG9rZW5zKGZ1bmN0aW9uKGNvbW1hcywgbm9faW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgZXhwciA9IG1heWJlX2Fzc2lnbihub19pbik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1hcyAmJiBpcyhcInB1bmNcIiwgXCIsXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJzZXFcIiwgZXhwciwgZXhwcmVzc2lvbih0cnVlLCBub19pbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5fbG9vcChjb250KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrUy5pbl9sb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnQoKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLS1TLmluX2xvb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBhcyhcInRvcGxldmVsXCIsIChmdW5jdGlvbihhKXtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWlzKFwiZW9mXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHN0YXRlbWVudCgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSkoW10pKTtcblxufTtcblxuLyogLS0tLS1bIFV0aWxpdGllcyBdLS0tLS0gKi9cblxuZnVuY3Rpb24gY3VycnkoZikge1xuICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHsgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJncy5jb25jYXQoc2xpY2UoYXJndW1lbnRzKSkpOyB9O1xufTtcblxuZnVuY3Rpb24gcHJvZzEocmV0KSB7XG4gICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgICAgICAgICByZXQgPSByZXQoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyAtLW4gPiAwOyArK2kpXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzW2ldKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBhcnJheV90b19oYXNoKGEpIHtcbiAgICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgcmV0W2FbaV1dID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIHNsaWNlKGEsIHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhLCBzdGFydCB8fCAwKTtcbn07XG5cbmZ1bmN0aW9uIGNoYXJhY3RlcnMoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIuc3BsaXQoXCJcIik7XG59O1xuXG5mdW5jdGlvbiBtZW1iZXIobmFtZSwgYXJyYXkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aDsgLS1pID49IDA7KVxuICAgICAgICAgICAgICAgIGlmIChhcnJheVtpXSA9PSBuYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIEhPUChvYmosIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufTtcblxudmFyIHdhcm4gPSBmdW5jdGlvbigpIHt9O1xuXG4vKiAtLS0tLVsgRXhwb3J0cyBdLS0tLS0gKi9cblxuZXhwb3J0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLnNsaWNlID0gc2xpY2U7XG5leHBvcnRzLmN1cnJ5ID0gY3Vycnk7XG5leHBvcnRzLm1lbWJlciA9IG1lbWJlcjtcbmV4cG9ydHMuYXJyYXlfdG9faGFzaCA9IGFycmF5X3RvX2hhc2g7XG5leHBvcnRzLlBSRUNFREVOQ0UgPSBQUkVDRURFTkNFO1xuZXhwb3J0cy5LRVlXT1JEU19BVE9NID0gS0VZV09SRFNfQVRPTTtcbmV4cG9ydHMuUkVTRVJWRURfV09SRFMgPSBSRVNFUlZFRF9XT1JEUztcbmV4cG9ydHMuS0VZV09SRFMgPSBLRVlXT1JEUztcbmV4cG9ydHMuQVRPTUlDX1NUQVJUX1RPS0VOID0gQVRPTUlDX1NUQVJUX1RPS0VOO1xuZXhwb3J0cy5PUEVSQVRPUlMgPSBPUEVSQVRPUlM7XG5leHBvcnRzLmlzX2FscGhhbnVtZXJpY19jaGFyID0gaXNfYWxwaGFudW1lcmljX2NoYXI7XG5leHBvcnRzLmlzX2lkZW50aWZpZXJfc3RhcnQgPSBpc19pZGVudGlmaWVyX3N0YXJ0O1xuZXhwb3J0cy5pc19pZGVudGlmaWVyX2NoYXIgPSBpc19pZGVudGlmaWVyX2NoYXI7XG5leHBvcnRzLnNldF9sb2dnZXIgPSBmdW5jdGlvbihsb2dnZXIpIHtcbiAgICAgICAgd2FybiA9IGxvZ2dlcjtcbn07XG5cbi8vIExvY2FsIHZhcmlhYmxlczpcbi8vIGpzLWluZGVudC1sZXZlbDogOFxuLy8gRW5kOlxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuXG4gIFRoaXMgdmVyc2lvbiBpcyBzdWl0YWJsZSBmb3IgTm9kZS5qcy4gIFdpdGggbWluaW1hbCBjaGFuZ2VzICh0aGVcbiAgZXhwb3J0cyBzdHVmZikgaXQgc2hvdWxkIHdvcmsgb24gYW55IEpTIHBsYXRmb3JtLlxuXG4gIFRoaXMgZmlsZSBpbXBsZW1lbnRzIHNvbWUgQVNUIHByb2Nlc3NvcnMuICBUaGV5IHdvcmsgb24gZGF0YSBidWlsdFxuICBieSBwYXJzZS1qcy5cblxuICBFeHBvcnRlZCBmdW5jdGlvbnM6XG5cbiAgICAtIGFzdF9tYW5nbGUoYXN0LCBvcHRpb25zKSAtLSBtYW5nbGVzIHRoZSB2YXJpYWJsZS9mdW5jdGlvbiBuYW1lc1xuICAgICAgaW4gdGhlIEFTVC4gIFJldHVybnMgYW4gQVNULlxuXG4gICAgLSBhc3Rfc3F1ZWV6ZShhc3QpIC0tIGVtcGxveXMgdmFyaW91cyBvcHRpbWl6YXRpb25zIHRvIG1ha2UgdGhlXG4gICAgICBmaW5hbCBnZW5lcmF0ZWQgY29kZSBldmVuIHNtYWxsZXIuICBSZXR1cm5zIGFuIEFTVC5cblxuICAgIC0gZ2VuX2NvZGUoYXN0LCBvcHRpb25zKSAtLSBnZW5lcmF0ZXMgSlMgY29kZSBmcm9tIHRoZSBBU1QuICBQYXNzXG4gICAgICB0cnVlIChvciBhbiBvYmplY3QsIHNlZSB0aGUgY29kZSBmb3Igc29tZSBvcHRpb25zKSBhcyBzZWNvbmRcbiAgICAgIGFyZ3VtZW50IHRvIGdldCBcInByZXR0eVwiIChpbmRlbnRlZCkgY29kZS5cblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMCAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIGpzcCA9IHJlcXVpcmUoXCIuL3BhcnNlLWpzXCIpLFxuICAgIGN1cnJ5ID0ganNwLmN1cnJ5LFxuICAgIHNsaWNlID0ganNwLnNsaWNlLFxuICAgIG1lbWJlciA9IGpzcC5tZW1iZXIsXG4gICAgaXNfaWRlbnRpZmllcl9jaGFyID0ganNwLmlzX2lkZW50aWZpZXJfY2hhcixcbiAgICBQUkVDRURFTkNFID0ganNwLlBSRUNFREVOQ0UsXG4gICAgT1BFUkFUT1JTID0ganNwLk9QRVJBVE9SUztcblxuLyogLS0tLS1bIGhlbHBlciBmb3IgQVNUIHRyYXZlcnNhbCBdLS0tLS0gKi9cblxuZnVuY3Rpb24gYXN0X3dhbGtlcigpIHtcbiAgICAgICAgZnVuY3Rpb24gX3ZhcmRlZnMoZGVmcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIE1BUChkZWZzLCBmdW5jdGlvbihkZWYpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBbIGRlZlswXSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhWzFdID0gd2FsayhkZWZbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgfSkgXTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gX2Jsb2NrKHN0YXRlbWVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0ID0gWyB0aGlzWzBdIF07XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlbWVudHMgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKE1BUChzdGF0ZW1lbnRzLCB3YWxrKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHdhbGtlcnMgPSB7XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIjogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBzdHIgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwibnVtXCI6IGZ1bmN0aW9uKG51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgbnVtIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgbmFtZSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ0b3BsZXZlbFwiOiBmdW5jdGlvbihzdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBNQVAoc3RhdGVtZW50cywgd2FsaykgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYmxvY2tcIjogX2Jsb2NrLFxuICAgICAgICAgICAgICAgIFwic3BsaWNlXCI6IF9ibG9jayxcbiAgICAgICAgICAgICAgICBcInZhclwiOiBfdmFyZGVmcyxcbiAgICAgICAgICAgICAgICBcImNvbnN0XCI6IF92YXJkZWZzLFxuICAgICAgICAgICAgICAgIFwidHJ5XCI6IGZ1bmN0aW9uKHQsIGMsIGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1BUCh0LCB3YWxrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyAhPSBudWxsID8gWyBjWzBdLCBNQVAoY1sxXSwgd2FsaykgXSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgIT0gbnVsbCA/IE1BUChmLCB3YWxrKSA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInRocm93XCI6IGZ1bmN0aW9uKGV4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHdhbGsoZXhwcikgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwibmV3XCI6IGZ1bmN0aW9uKGN0b3IsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHdhbGsoY3RvciksIE1BUChhcmdzLCB3YWxrKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJzd2l0Y2hcIjogZnVuY3Rpb24oZXhwciwgYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgd2FsayhleHByKSwgTUFQKGJvZHksIGZ1bmN0aW9uKGJyYW5jaCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIGJyYW5jaFswXSA/IHdhbGsoYnJhbmNoWzBdKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1BUChicmFuY2hbMV0sIHdhbGspIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJicmVha1wiOiBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgbGFiZWwgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiY29udGludWVcIjogZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIGxhYmVsIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImNvbmRpdGlvbmFsXCI6IGZ1bmN0aW9uKGNvbmQsIHQsIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHdhbGsoY29uZCksIHdhbGsodCksIHdhbGsoZSkgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYXNzaWduXCI6IGZ1bmN0aW9uKG9wLCBsdmFsdWUsIHJ2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgb3AsIHdhbGsobHZhbHVlKSwgd2FsayhydmFsdWUpIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImRvdFwiOiBmdW5jdGlvbihleHByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCB3YWxrKGV4cHIpIF0uY29uY2F0KHNsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJjYWxsXCI6IGZ1bmN0aW9uKGV4cHIsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHdhbGsoZXhwciksIE1BUChhcmdzLCB3YWxrKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiOiBmdW5jdGlvbihuYW1lLCBhcmdzLCBib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBuYW1lLCBhcmdzLnNsaWNlKCksIE1BUChib2R5LCB3YWxrKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJkZWJ1Z2dlclwiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0gXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZGVmdW5cIjogZnVuY3Rpb24obmFtZSwgYXJncywgYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgbmFtZSwgYXJncy5zbGljZSgpLCBNQVAoYm9keSwgd2FsaykgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiaWZcIjogZnVuY3Rpb24oY29uZGl0aW9uYWwsIHQsIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHdhbGsoY29uZGl0aW9uYWwpLCB3YWxrKHQpLCB3YWxrKGUpIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImZvclwiOiBmdW5jdGlvbihpbml0LCBjb25kLCBzdGVwLCBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgd2Fsayhpbml0KSwgd2Fsayhjb25kKSwgd2FsayhzdGVwKSwgd2FsayhibG9jaykgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZm9yLWluXCI6IGZ1bmN0aW9uKHZ2YXIsIGtleSwgaGFzaCwgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHdhbGsodnZhciksIHdhbGsoa2V5KSwgd2FsayhoYXNoKSwgd2FsayhibG9jaykgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwid2hpbGVcIjogZnVuY3Rpb24oY29uZCwgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHdhbGsoY29uZCksIHdhbGsoYmxvY2spIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImRvXCI6IGZ1bmN0aW9uKGNvbmQsIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCB3YWxrKGNvbmQpLCB3YWxrKGJsb2NrKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJyZXR1cm5cIjogZnVuY3Rpb24oZXhwcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgd2FsayhleHByKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJiaW5hcnlcIjogZnVuY3Rpb24ob3AsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBvcCwgd2FsayhsZWZ0KSwgd2FsayhyaWdodCkgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwidW5hcnktcHJlZml4XCI6IGZ1bmN0aW9uKG9wLCBleHByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBvcCwgd2FsayhleHByKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ1bmFyeS1wb3N0Zml4XCI6IGZ1bmN0aW9uKG9wLCBleHByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBvcCwgd2FsayhleHByKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJzdWJcIjogZnVuY3Rpb24oZXhwciwgc3Vic2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCB3YWxrKGV4cHIpLCB3YWxrKHN1YnNjcmlwdCkgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCI6IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBNQVAocHJvcHMsIGZ1bmN0aW9uKHApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcC5sZW5ndGggPT0gMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gWyBwWzBdLCB3YWxrKHBbMV0pIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFsgcFswXSwgd2FsayhwWzFdKSwgcFsyXSBdOyAvLyBnZXQvc2V0LXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwicmVnZXhwXCI6IGZ1bmN0aW9uKHJ4LCBtb2RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCByeCwgbW9kcyBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhcnJheVwiOiBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgTUFQKGVsZW1lbnRzLCB3YWxrKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJzdGF0XCI6IGZ1bmN0aW9uKHN0YXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHdhbGsoc3RhdCkgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwic2VxXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSBdLmNvbmNhdChNQVAoc2xpY2UoYXJndW1lbnRzKSwgd2FsaykpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJsYWJlbFwiOiBmdW5jdGlvbihuYW1lLCBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgbmFtZSwgd2FsayhibG9jaykgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwid2l0aFwiOiBmdW5jdGlvbihleHByLCBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgd2FsayhleHByKSwgd2FsayhibG9jaykgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYXRvbVwiOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBuYW1lIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImRpcmVjdGl2ZVwiOiBmdW5jdGlvbihkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIGRpciBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdXNlciA9IHt9O1xuICAgICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gd2Fsayhhc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXN0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChhc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBhc3RbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2VuID0gdXNlclt0eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IGdlbi5hcHBseShhc3QsIGFzdC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuID0gd2Fsa2Vyc1t0eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZW4uYXBwbHkoYXN0LCBhc3Quc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZGl2ZShhc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXN0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChhc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGtlcnNbYXN0WzBdXS5hcHBseShhc3QsIGFzdC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiB3aXRoX3dhbGtlcnMod2Fsa2VycywgY29udCl7XG4gICAgICAgICAgICAgICAgdmFyIHNhdmUgPSB7fSwgaTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4gd2Fsa2VycykgaWYgKEhPUCh3YWxrZXJzLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZVtpXSA9IHVzZXJbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyW2ldID0gd2Fsa2Vyc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IGNvbnQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4gc2F2ZSkgaWYgKEhPUChzYXZlLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzYXZlW2ldKSBkZWxldGUgdXNlcltpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgdXNlcltpXSA9IHNhdmVbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3YWxrOiB3YWxrLFxuICAgICAgICAgICAgICAgIGRpdmU6IGRpdmUsXG4gICAgICAgICAgICAgICAgd2l0aF93YWxrZXJzOiB3aXRoX3dhbGtlcnMsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAyXTsgLy8gbGFzdCBvbmUgaXMgY3VycmVudCBub2RlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdGFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9O1xufTtcblxuLyogLS0tLS1bIFNjb3BlIGFuZCBtYW5nbGluZyBdLS0tLS0gKi9cblxuZnVuY3Rpb24gU2NvcGUocGFyZW50KSB7XG4gICAgICAgIHRoaXMubmFtZXMgPSB7fTsgICAgICAgIC8vIG5hbWVzIGRlZmluZWQgaW4gdGhpcyBzY29wZVxuICAgICAgICB0aGlzLm1hbmdsZWQgPSB7fTsgICAgICAvLyBtYW5nbGVkIG5hbWVzIChvcmlnLm5hbWUgPT4gbWFuZ2xlZClcbiAgICAgICAgdGhpcy5yZXZfbWFuZ2xlZCA9IHt9OyAgLy8gcmV2ZXJzZSBsb29rdXAgKG1hbmdsZWQgPT4gb3JpZy5uYW1lKVxuICAgICAgICB0aGlzLmNuYW1lID0gLTE7ICAgICAgICAvLyBjdXJyZW50IG1hbmdsZWQgbmFtZVxuICAgICAgICB0aGlzLnJlZnMgPSB7fTsgICAgICAgICAvLyBuYW1lcyByZWZlcmVuY2VkIGZyb20gdGhpcyBzY29wZVxuICAgICAgICB0aGlzLnVzZXNfd2l0aCA9IGZhbHNlOyAvLyB3aWxsIGJlY29tZSBUUlVFIGlmIHdpdGgoKSBpcyBkZXRlY3RlZCBpbiB0aGlzIG9yIGFueSBzdWJzY29wZXNcbiAgICAgICAgdGhpcy51c2VzX2V2YWwgPSBmYWxzZTsgLy8gd2lsbCBiZWNvbWUgVFJVRSBpZiBldmFsKCkgaXMgZGV0ZWN0ZWQgaW4gdGhpcyBvciBhbnkgc3Vic2NvcGVzXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IFtdOyAgIC8vIGRpcmVjdGl2ZXMgYWN0aXZhdGVkIGZyb20gdGhpcyBzY29wZVxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDsgICAvLyBwYXJlbnQgc2NvcGVcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdOyAgICAgLy8gc3ViLXNjb3Blc1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXZlbCA9IHBhcmVudC5sZXZlbCArIDE7XG4gICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXZlbCA9IDA7XG4gICAgICAgIH1cbn07XG5cbmZ1bmN0aW9uIGJhc2U1NF9kaWdpdHMoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRElHSVRTX09WRVJSSURFX0ZPUl9URVNUSU5HICE9IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIERJR0lUU19PVkVSUklERV9GT1JfVEVTVElORztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBcImV0bnJpc291YWZsY2hwZHZtZ3lid0VTeFROQ2tMQU9NX0RQSEJqRklxUlV6V1hWJEpLUUdZWjA1MTYzNzI5ODRcIjtcbn1cblxudmFyIGJhc2U1NCA9IChmdW5jdGlvbigpe1xuICAgICAgICB2YXIgRElHSVRTID0gYmFzZTU0X2RpZ2l0cygpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24obnVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IFwiXCIsIGJhc2UgPSA1NDtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgKz0gRElHSVRTLmNoYXJBdChudW0gJSBiYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gYmFzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlID0gNjQ7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAobnVtID4gMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbn0pKCk7XG5cblNjb3BlLnByb3RvdHlwZSA9IHtcbiAgICAgICAgaGFzOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcyA9IHRoaXM7IHM7IHMgPSBzLnBhcmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChIT1Aocy5uYW1lcywgbmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9LFxuICAgICAgICBoYXNfbWFuZ2xlZDogZnVuY3Rpb24obW5hbWUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gdGhpczsgczsgcyA9IHMucGFyZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEhPUChzLnJldl9tYW5nbGVkLCBtbmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9LFxuICAgICAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lczogdGhpcy5uYW1lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXNfZXZhbDogdGhpcy51c2VzX2V2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VzX3dpdGg6IHRoaXMudXNlc193aXRoXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBuZXh0X21hbmdsZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIHdlIG11c3QgYmUgY2FyZWZ1bCB0aGF0IHRoZSBuZXcgbWFuZ2xlZCBuYW1lOlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gMS4gZG9lc24ndCBzaGFkb3cgYSBtYW5nbGVkIG5hbWUgZnJvbSBhIHBhcmVudFxuICAgICAgICAgICAgICAgIC8vICAgIHNjb3BlLCB1bmxlc3Mgd2UgZG9uJ3QgcmVmZXJlbmNlIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgIC8vICAgIG5hbWUgZnJvbSB0aGlzIHNjb3BlIE9SIGZyb20gYW55IHN1Yi1zY29wZXMhXG4gICAgICAgICAgICAgICAgLy8gICAgVGhpcyB3aWxsIGdldCBzbG93LlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gMi4gZG9lc24ndCBzaGFkb3cgYW4gb3JpZ2luYWwgbmFtZSBmcm9tIGEgcGFyZW50XG4gICAgICAgICAgICAgICAgLy8gICAgc2NvcGUsIGluIHRoZSBldmVudCB0aGF0IHRoZSBuYW1lIGlzIG5vdCBtYW5nbGVkXG4gICAgICAgICAgICAgICAgLy8gICAgaW4gdGhlIHBhcmVudCBzY29wZSBhbmQgd2UgcmVmZXJlbmNlIHRoYXQgbmFtZVxuICAgICAgICAgICAgICAgIC8vICAgIGhlcmUgT1IgSU4gQU5ZIFNVQlNDT1BFUyFcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIDMuIGRvZXNuJ3Qgc2hhZG93IGEgbmFtZSB0aGF0IGlzIHJlZmVyZW5jZWQgYnV0IG5vdFxuICAgICAgICAgICAgICAgIC8vICAgIGRlZmluZWQgKHBvc3NpYmx5IGdsb2JhbCBkZWZpbmVkIGVsc2V3aGVyZSkuXG4gICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBiYXNlNTQoKyt0aGlzLmNuYW1lKSwgcHJpb3I7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgMS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yID0gdGhpcy5oYXNfbWFuZ2xlZChtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmlvciAmJiB0aGlzLnJlZnNbcHJpb3IucmV2X21hbmdsZWRbbV1dID09PSBwcmlvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgMi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yID0gdGhpcy5oYXMobSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJpb3IgJiYgcHJpb3IgIT09IHRoaXMgJiYgdGhpcy5yZWZzW21dID09PSBwcmlvciAmJiAhcHJpb3IuaGFzX21hbmdsZWQobSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIDMuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoSE9QKHRoaXMucmVmcywgbSkgJiYgdGhpcy5yZWZzW21dID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJIGdvdCBcImRvXCIgb25jZS4gOi0vXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzX2lkZW50aWZpZXIobSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldF9tYW5nbGU6IGZ1bmN0aW9uKG5hbWUsIG0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJldl9tYW5nbGVkW21dID0gbmFtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYW5nbGVkW25hbWVdID0gbTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0X21hbmdsZWQ6IGZ1bmN0aW9uKG5hbWUsIG5ld01hbmdsZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZXNfZXZhbCB8fCB0aGlzLnVzZXNfd2l0aCkgcmV0dXJuIG5hbWU7IC8vIG5vIG1hbmdsZSBpZiBldmFsIG9yIHdpdGggaXMgaW4gdXNlXG4gICAgICAgICAgICAgICAgdmFyIHMgPSB0aGlzLmhhcyhuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIXMpIHJldHVybiBuYW1lOyAvLyBub3QgaW4gdmlzaWJsZSBzY29wZSwgbm8gbWFuZ2xlXG4gICAgICAgICAgICAgICAgaWYgKEhPUChzLm1hbmdsZWQsIG5hbWUpKSByZXR1cm4gcy5tYW5nbGVkW25hbWVdOyAvLyBhbHJlYWR5IG1hbmdsZWQgaW4gdGhpcyBzY29wZVxuICAgICAgICAgICAgICAgIGlmICghbmV3TWFuZ2xlKSByZXR1cm4gbmFtZTsgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGZvdW5kIGFuZCBubyBtYW5nbGluZyByZXF1ZXN0ZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gcy5zZXRfbWFuZ2xlKG5hbWUsIHMubmV4dF9tYW5nbGVkKCkpO1xuICAgICAgICB9LFxuICAgICAgICByZWZlcmVuY2VzOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgJiYgIXRoaXMucGFyZW50IHx8IHRoaXMudXNlc193aXRoIHx8IHRoaXMudXNlc19ldmFsIHx8IHRoaXMucmVmc1tuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVmaW5lOiBmdW5jdGlvbihuYW1lLCB0eXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gXCJ2YXJcIiB8fCAhSE9QKHRoaXMubmFtZXMsIG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWVzW25hbWVdID0gdHlwZSB8fCBcInZhclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhY3RpdmVfZGlyZWN0aXZlOiBmdW5jdGlvbihkaXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVtYmVyKGRpciwgdGhpcy5kaXJlY3RpdmVzKSB8fCB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5hY3RpdmVfZGlyZWN0aXZlKGRpcik7XG4gICAgICAgIH1cbn07XG5cbmZ1bmN0aW9uIGFzdF9hZGRfc2NvcGUoYXN0KSB7XG5cbiAgICAgICAgdmFyIGN1cnJlbnRfc2NvcGUgPSBudWxsO1xuICAgICAgICB2YXIgdyA9IGFzdF93YWxrZXIoKSwgd2FsayA9IHcud2FsaztcbiAgICAgICAgdmFyIGhhdmluZ19ldmFsID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gd2l0aF9uZXdfc2NvcGUoY29udCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfc2NvcGUgPSBuZXcgU2NvcGUoY3VycmVudF9zY29wZSk7XG4gICAgICAgICAgICAgICAgY3VycmVudF9zY29wZS5sYWJlbHMgPSBuZXcgU2NvcGUoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gY3VycmVudF9zY29wZS5ib2R5ID0gY29udCgpO1xuICAgICAgICAgICAgICAgIHJldC5zY29wZSA9IGN1cnJlbnRfc2NvcGU7XG4gICAgICAgICAgICAgICAgY3VycmVudF9zY29wZSA9IGN1cnJlbnRfc2NvcGUucGFyZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZGVmaW5lKG5hbWUsIHR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudF9zY29wZS5kZWZpbmUobmFtZSwgdHlwZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcmVmZXJlbmNlKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50X3Njb3BlLnJlZnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIF9sYW1iZGEobmFtZSwgYXJncywgYm9keSkge1xuICAgICAgICAgICAgICAgIHZhciBpc19kZWZ1biA9IHRoaXNbMF0gPT0gXCJkZWZ1blwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIGlzX2RlZnVuID8gZGVmaW5lKG5hbWUsIFwiZGVmdW5cIikgOiBuYW1lLCBhcmdzLCB3aXRoX25ld19zY29wZShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc19kZWZ1bikgZGVmaW5lKG5hbWUsIFwibGFtYmRhXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgTUFQKGFyZ3MsIGZ1bmN0aW9uKG5hbWUpeyBkZWZpbmUobmFtZSwgXCJhcmdcIikgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTUFQKGJvZHksIHdhbGspO1xuICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBfdmFyZGVmcyh0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRlZnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1BUChkZWZzLCBmdW5jdGlvbihkKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lKGRbMF0sIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZFsxXSkgcmVmZXJlbmNlKGRbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBfYnJlYWNvbnQobGFiZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50X3Njb3BlLmxhYmVscy5yZWZzW2xhYmVsXSA9IHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHdpdGhfbmV3X3Njb3BlKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLy8gcHJvY2VzcyBBU1RcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gdy53aXRoX3dhbGtlcnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiOiBfbGFtYmRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkZWZ1blwiOiBfbGFtYmRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJsYWJlbFwiOiBmdW5jdGlvbihuYW1lLCBzdGF0KSB7IGN1cnJlbnRfc2NvcGUubGFiZWxzLmRlZmluZShuYW1lKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJicmVha1wiOiBfYnJlYWNvbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImNvbnRpbnVlXCI6IF9icmVhY29udCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2l0aFwiOiBmdW5jdGlvbihleHByLCBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gY3VycmVudF9zY29wZTsgczsgcyA9IHMucGFyZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMudXNlc193aXRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhclwiOiBfdmFyZGVmcyhcInZhclwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY29uc3RcIjogX3ZhcmRlZnMoXCJjb25zdFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHJ5XCI6IGZ1bmN0aW9uKHQsIGMsIGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgIT0gbnVsbCkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1BUCh0LCB3YWxrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIGRlZmluZShjWzBdLCBcImNhdGNoXCIpLCBNQVAoY1sxXSwgd2FsaykgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmICE9IG51bGwgPyBNQVAoZiwgd2FsaykgOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJldmFsXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGF2aW5nX2V2YWwucHVzaChjdXJyZW50X3Njb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2Fsayhhc3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJlYXNvbiB3aHkgd2UgbmVlZCBhbiBhZGRpdGlvbmFsIHBhc3MgaGVyZSBpc1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgbmFtZXMgY2FuIGJlIHVzZWQgcHJpb3IgdG8gdGhlaXIgZGVmaW5pdGlvbi5cblxuICAgICAgICAgICAgICAgIC8vIHNjb3BlcyB3aGVyZSBldmFsIHdhcyBkZXRlY3RlZCBhbmQgdGhlaXIgcGFyZW50c1xuICAgICAgICAgICAgICAgIC8vIGFyZSBtYXJrZWQgd2l0aCB1c2VzX2V2YWwsIHVubGVzcyB0aGV5IGRlZmluZSB0aGVcbiAgICAgICAgICAgICAgICAvLyBcImV2YWxcIiBuYW1lLlxuICAgICAgICAgICAgICAgIE1BUChoYXZpbmdfZXZhbCwgZnVuY3Rpb24oc2NvcGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY29wZS5oYXMoXCJldmFsXCIpKSB3aGlsZSAoc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUudXNlc19ldmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSBzY29wZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBmb3IgcmVmZXJlbmNlZCBuYW1lcyBpdCBtaWdodCBiZSB1c2VmdWwgdG8ga25vd1xuICAgICAgICAgICAgICAgIC8vIHRoZWlyIG9yaWdpbiBzY29wZS4gIGN1cnJlbnRfc2NvcGUgaGVyZSBpcyB0aGVcbiAgICAgICAgICAgICAgICAvLyB0b3BsZXZlbCBvbmUuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZml4cmVmcyhzY29wZSwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gY2hpbGRyZW4gZmlyc3Q7IG9yZGVyIHNob3VsZG4ndCBtYXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IHNjb3BlLmNoaWxkcmVuLmxlbmd0aDsgLS1pID49IDA7KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXhyZWZzKHNjb3BlLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSBpbiBzY29wZS5yZWZzKSBpZiAoSE9QKHNjb3BlLnJlZnMsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgb3JpZ2luIHNjb3BlIGFuZCBwcm9wYWdhdGUgdGhlIHJlZmVyZW5jZSB0byBvcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgb3JpZ2luID0gc2NvcGUuaGFzKGkpLCBzID0gc2NvcGU7IHM7IHMgPSBzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMucmVmc1tpXSA9IG9yaWdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA9PT0gb3JpZ2luKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZml4cmVmcyhjdXJyZW50X3Njb3BlKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0pO1xuXG59O1xuXG4vKiAtLS0tLVsgbWFuZ2xlIG5hbWVzIF0tLS0tLSAqL1xuXG5mdW5jdGlvbiBhc3RfbWFuZ2xlKGFzdCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdyA9IGFzdF93YWxrZXIoKSwgd2FsayA9IHcud2Fsaywgc2NvcGU7XG4gICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgbWFuZ2xlICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0b3BsZXZlbCAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkZWZpbmVzICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIGV4Y2VwdCAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgbm9fZnVuY3Rpb25zIDogZmFsc2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0X21hbmdsZWQobmFtZSwgbmV3TWFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLm1hbmdsZSkgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLnRvcGxldmVsICYmICFzY29wZS5wYXJlbnQpIHJldHVybiBuYW1lOyAvLyBkb24ndCBtYW5nbGUgdG9wbGV2ZWxcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5leGNlcHQgJiYgbWVtYmVyKG5hbWUsIG9wdGlvbnMuZXhjZXB0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm5vX2Z1bmN0aW9ucyAmJiBIT1Aoc2NvcGUubmFtZXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICAgICAgIChzY29wZS5uYW1lc1tuYW1lXSA9PSAnZGVmdW4nIHx8IHNjb3BlLm5hbWVzW25hbWVdID09ICdsYW1iZGEnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5nZXRfbWFuZ2xlZChuYW1lLCBuZXdNYW5nbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldF9kZWZpbmUobmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGFsd2F5cyBsb29rdXAgYSBkZWZpbmVkIHN5bWJvbCBmb3IgdGhlIGN1cnJlbnQgc2NvcGUgRklSU1QsIHNvIGRlY2xhcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2YXJzIHRydW1wIGEgREVGSU5FIHN5bWJvbCwgYnV0IGlmIG5vIHN1Y2ggdmFyIGlzIGZvdW5kLCB0aGVuIG1hdGNoIGEgREVGSU5FIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNjb3BlLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoSE9QKG9wdGlvbnMuZGVmaW5lcywgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kZWZpbmVzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gX2xhbWJkYShuYW1lLCBhcmdzLCBib2R5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLm5vX2Z1bmN0aW9ucyAmJiBvcHRpb25zLm1hbmdsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzX2RlZnVuID0gdGhpc1swXSA9PSBcImRlZnVuXCIsIGV4dHJhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2RlZnVuKSBuYW1lID0gZ2V0X21hbmdsZWQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJvZHkuc2NvcGUucmVmZXJlbmNlcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoc2NvcGUudXNlc19ldmFsIHx8IHNjb3BlLnVzZXNfd2l0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gZXh0cmFbbmFtZV0gPSBzY29wZS5uZXh0X21hbmdsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYVtuYW1lXSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBuYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYm9keSA9IHdpdGhfc2NvcGUoYm9keS5zY29wZSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBNQVAoYXJncywgZnVuY3Rpb24obmFtZSl7IHJldHVybiBnZXRfbWFuZ2xlZChuYW1lKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNQVAoYm9keSwgd2Fsayk7XG4gICAgICAgICAgICAgICAgfSwgZXh0cmEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIG5hbWUsIGFyZ3MsIGJvZHkgXTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiB3aXRoX3Njb3BlKHMsIGNvbnQsIGV4dHJhKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9zY29wZSA9IHNjb3BlO1xuICAgICAgICAgICAgICAgIHNjb3BlID0gcztcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmEpIGZvciAodmFyIGkgaW4gZXh0cmEpIGlmIChIT1AoZXh0cmEsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzLnNldF9tYW5nbGUoaSwgZXh0cmFbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHMubmFtZXMpIGlmIChIT1Aocy5uYW1lcywgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldF9tYW5nbGVkKGksIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gY29udCgpO1xuICAgICAgICAgICAgICAgIHJldC5zY29wZSA9IHM7XG4gICAgICAgICAgICAgICAgc2NvcGUgPSBfc2NvcGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBfdmFyZGVmcyhkZWZzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgTUFQKGRlZnMsIGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgZ2V0X21hbmdsZWQoZFswXSksIHdhbGsoZFsxXSkgXTtcbiAgICAgICAgICAgICAgICB9KSBdO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIF9icmVhY29udChsYWJlbCkge1xuICAgICAgICAgICAgICAgIGlmIChsYWJlbCkgcmV0dXJuIFsgdGhpc1swXSwgc2NvcGUubGFiZWxzLmdldF9tYW5nbGVkKGxhYmVsKSBdO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB3LndpdGhfd2Fsa2Vycyh7XG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiOiBfbGFtYmRhLFxuICAgICAgICAgICAgICAgIFwiZGVmdW5cIjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGZ1bmN0aW9uIGRlY2xhcmF0aW9ucyB0byB0aGUgdG9wIHdoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZXkgYXJlIG5vdCBpbiBzb21lIGJsb2NrLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFzdCA9IF9sYW1iZGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAody5wYXJlbnQoKVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b3BsZXZlbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZ1blwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTUFQLmF0X3RvcChhc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwibGFiZWxcIjogZnVuY3Rpb24obGFiZWwsIHN0YXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY29wZS5sYWJlbHMucmVmc1tsYWJlbF0pIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmxhYmVscy5nZXRfbWFuZ2xlZChsYWJlbCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbGsoc3RhdClcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2FsayhzdGF0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYnJlYWtcIjogX2JyZWFjb250LFxuICAgICAgICAgICAgICAgIFwiY29udGludWVcIjogX2JyZWFjb250LFxuICAgICAgICAgICAgICAgIFwidmFyXCI6IF92YXJkZWZzLFxuICAgICAgICAgICAgICAgIFwiY29uc3RcIjogX3ZhcmRlZnMsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRfZGVmaW5lKG5hbWUpIHx8IFsgdGhpc1swXSwgZ2V0X21hbmdsZWQobmFtZSkgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwidHJ5XCI6IGZ1bmN0aW9uKHQsIGMsIGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNQVAodCwgd2FsayksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjICE9IG51bGwgPyBbIGdldF9tYW5nbGVkKGNbMF0pLCBNQVAoY1sxXSwgd2FsaykgXSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmICE9IG51bGwgPyBNQVAoZiwgd2FsaykgOiBudWxsIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInRvcGxldmVsXCI6IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aXRoX3Njb3BlKHNlbGYuc2NvcGUsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHNlbGZbMF0sIE1BUChib2R5LCB3YWxrKSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImRpcmVjdGl2ZVwiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNQVAuYXRfdG9wKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhbGsoYXN0X2FkZF9zY29wZShhc3QpKTtcbiAgICAgICAgfSk7XG59O1xuXG4vKiAtLS0tLVtcbiAgIC0gY29tcHJlc3MgZm9vW1wiYmFyXCJdIGludG8gZm9vLmJhcixcbiAgIC0gcmVtb3ZlIGJsb2NrIGJyYWNrZXRzIHt9IHdoZXJlIHBvc3NpYmxlXG4gICAtIGpvaW4gY29uc2VjdXRpdmUgdmFyIGRlY2xhcmF0aW9uc1xuICAgLSB2YXJpb3VzIG9wdGltaXphdGlvbnMgZm9yIElGczpcbiAgICAgLSBpZiAoY29uZCkgZm9vKCk7IGVsc2UgYmFyKCk7ICA9PT4gIGNvbmQ/Zm9vKCk6YmFyKCk7XG4gICAgIC0gaWYgKGNvbmQpIGZvbygpOyAgPT0+ICBjb25kJiZmb28oKTtcbiAgICAgLSBpZiAoZm9vKSByZXR1cm4gYmFyKCk7IGVsc2UgcmV0dXJuIGJheigpOyAgPT0+IHJldHVybiBmb28/YmFyKCk6YmF6KCk7IC8vIGFsc28gZm9yIHRocm93XG4gICAgIC0gaWYgKGZvbykgcmV0dXJuIGJhcigpOyBlbHNlIHNvbWV0aGluZygpOyAgPT0+IHtpZihmb28pcmV0dXJuIGJhcigpO3NvbWV0aGluZygpfVxuICAgXS0tLS0tICovXG5cbnZhciB3YXJuID0gZnVuY3Rpb24oKXt9O1xuXG5mdW5jdGlvbiBiZXN0X29mKGFzdDEsIGFzdDIpIHtcbiAgICAgICAgcmV0dXJuIGdlbl9jb2RlKGFzdDEpLmxlbmd0aCA+IGdlbl9jb2RlKGFzdDJbMF0gPT0gXCJzdGF0XCIgPyBhc3QyWzFdIDogYXN0MikubGVuZ3RoID8gYXN0MiA6IGFzdDE7XG59O1xuXG5mdW5jdGlvbiBsYXN0X3N0YXQoYikge1xuICAgICAgICBpZiAoYlswXSA9PSBcImJsb2NrXCIgJiYgYlsxXSAmJiBiWzFdLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJbMV1bYlsxXS5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIGI7XG59XG5cbmZ1bmN0aW9uIGFib3J0cyh0KSB7XG4gICAgICAgIGlmICh0KSBzd2l0Y2ggKGxhc3Rfc3RhdCh0KVswXSkge1xuICAgICAgICAgICAgY2FzZSBcInJldHVyblwiOlxuICAgICAgICAgICAgY2FzZSBcImJyZWFrXCI6XG4gICAgICAgICAgICBjYXNlIFwiY29udGludWVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ0aHJvd1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG59O1xuXG5mdW5jdGlvbiBib29sZWFuX2V4cHIoZXhwcikge1xuICAgICAgICByZXR1cm4gKCAoZXhwclswXSA9PSBcInVuYXJ5LXByZWZpeFwiXG4gICAgICAgICAgICAgICAgICAmJiBtZW1iZXIoZXhwclsxXSwgWyBcIiFcIiwgXCJkZWxldGVcIiBdKSkgfHxcblxuICAgICAgICAgICAgICAgICAoZXhwclswXSA9PSBcImJpbmFyeVwiXG4gICAgICAgICAgICAgICAgICAmJiBtZW1iZXIoZXhwclsxXSwgWyBcImluXCIsIFwiaW5zdGFuY2VvZlwiLCBcIj09XCIsIFwiIT1cIiwgXCI9PT1cIiwgXCIhPT1cIiwgXCI8XCIsIFwiPD1cIiwgXCI+PVwiLCBcIj5cIiBdKSkgfHxcblxuICAgICAgICAgICAgICAgICAoZXhwclswXSA9PSBcImJpbmFyeVwiXG4gICAgICAgICAgICAgICAgICAmJiBtZW1iZXIoZXhwclsxXSwgWyBcIiYmXCIsIFwifHxcIiBdKVxuICAgICAgICAgICAgICAgICAgJiYgYm9vbGVhbl9leHByKGV4cHJbMl0pXG4gICAgICAgICAgICAgICAgICAmJiBib29sZWFuX2V4cHIoZXhwclszXSkpIHx8XG5cbiAgICAgICAgICAgICAgICAgKGV4cHJbMF0gPT0gXCJjb25kaXRpb25hbFwiXG4gICAgICAgICAgICAgICAgICAmJiBib29sZWFuX2V4cHIoZXhwclsyXSlcbiAgICAgICAgICAgICAgICAgICYmIGJvb2xlYW5fZXhwcihleHByWzNdKSkgfHxcblxuICAgICAgICAgICAgICAgICAoZXhwclswXSA9PSBcImFzc2lnblwiXG4gICAgICAgICAgICAgICAgICAmJiBleHByWzFdID09PSB0cnVlXG4gICAgICAgICAgICAgICAgICAmJiBib29sZWFuX2V4cHIoZXhwclszXSkpIHx8XG5cbiAgICAgICAgICAgICAgICAgKGV4cHJbMF0gPT0gXCJzZXFcIlxuICAgICAgICAgICAgICAgICAgJiYgYm9vbGVhbl9leHByKGV4cHJbZXhwci5sZW5ndGggLSAxXSkpXG4gICAgICAgICAgICAgICApO1xufTtcblxuZnVuY3Rpb24gZW1wdHkoYikge1xuICAgICAgICByZXR1cm4gIWIgfHwgKGJbMF0gPT0gXCJibG9ja1wiICYmICghYlsxXSB8fCBiWzFdLmxlbmd0aCA9PSAwKSk7XG59O1xuXG5mdW5jdGlvbiBpc19zdHJpbmcobm9kZSkge1xuICAgICAgICByZXR1cm4gKG5vZGVbMF0gPT0gXCJzdHJpbmdcIiB8fFxuICAgICAgICAgICAgICAgIG5vZGVbMF0gPT0gXCJ1bmFyeS1wcmVmaXhcIiAmJiBub2RlWzFdID09IFwidHlwZW9mXCIgfHxcbiAgICAgICAgICAgICAgICBub2RlWzBdID09IFwiYmluYXJ5XCIgJiYgbm9kZVsxXSA9PSBcIitcIiAmJlxuICAgICAgICAgICAgICAgIChpc19zdHJpbmcobm9kZVsyXSkgfHwgaXNfc3RyaW5nKG5vZGVbM10pKSk7XG59O1xuXG52YXIgd2hlbl9jb25zdGFudCA9IChmdW5jdGlvbigpe1xuXG4gICAgICAgIHZhciAkTk9UX0NPTlNUQU5UID0ge307XG5cbiAgICAgICAgLy8gdGhpcyBjYW4gb25seSBldmFsdWF0ZSBjb25zdGFudCBleHByZXNzaW9ucy4gIElmIGl0IGZpbmRzIGFueXRoaW5nXG4gICAgICAgIC8vIG5vdCBjb25zdGFudCwgaXQgdGhyb3dzICROT1RfQ09OU1RBTlQuXG4gICAgICAgIGZ1bmN0aW9uIGV2YWx1YXRlKGV4cHIpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4cHJbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwclsxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImF0b21cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXhwclsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0cnVlXCI6IHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmYWxzZVwiOiByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm51bGxcIjogcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInVuYXJ5LXByZWZpeFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChleHByWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFcIjogcmV0dXJuICFldmFsdWF0ZShleHByWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidHlwZW9mXCI6IHJldHVybiB0eXBlb2YgZXZhbHVhdGUoZXhwclsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIn5cIjogcmV0dXJuIH5ldmFsdWF0ZShleHByWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiLVwiOiByZXR1cm4gLWV2YWx1YXRlKGV4cHJbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIrXCI6IHJldHVybiArZXZhbHVhdGUoZXhwclsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJpbmFyeVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBleHByWzJdLCByaWdodCA9IGV4cHJbM107XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4cHJbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiJiZcIiAgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpICYmICAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ8fFwiICAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgfHwgICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInxcIiAgICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSB8ICAgICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiJlwiICAgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpICYgICAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJeXCIgICAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgXiAgICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIitcIiAgICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSArICAgICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiKlwiICAgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpICogICAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIvXCIgICAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgLyAgICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiVcIiAgICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSAlICAgICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiLVwiICAgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpIC0gICAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI8PFwiICAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgPDwgICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj4+XCIgICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSA+PiAgICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPj4+XCIgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpID4+PiAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI9PVwiICAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgPT0gICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj09PVwiICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSA9PT0gICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIT1cIiAgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpICE9ICAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhPT1cIiAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgIT09ICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIjxcIiAgICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSA8ICAgICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPD1cIiAgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpIDw9ICAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI+XCIgICAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgPiAgICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj49XCIgICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSA+PSAgICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5cIiAgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpIGluICAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnN0YW5jZW9mXCIgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgaW5zdGFuY2VvZiBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93ICROT1RfQ09OU1RBTlQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGV4cHIsIHllcywgbm8pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGV2YWx1YXRlKGV4cHIpLCBhc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6IGFzdCA9ICBbIFwic3RyaW5nXCIsIHZhbCBdOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6IGFzdCA9ICBbIFwibnVtXCIsIHZhbCBdOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOiBhc3QgPSAgWyBcIm5hbWVcIiwgU3RyaW5nKHZhbCkgXTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCkgeyBhc3QgPSBbIFwiYXRvbVwiLCBcIm51bGxcIiBdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBoYW5kbGUgY29uc3RhbnQgb2YgdHlwZTogXCIgKyAodHlwZW9mIHZhbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHllcy5jYWxsKGV4cHIsIGFzdCwgdmFsKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXggPT09ICROT1RfQ09OU1RBTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJbMF0gPT0gXCJiaW5hcnlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKGV4cHJbMV0gPT0gXCI9PT1cIiB8fCBleHByWzFdID09IFwiIT09XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoKGlzX3N0cmluZyhleHByWzJdKSAmJiBpc19zdHJpbmcoZXhwclszXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgKGJvb2xlYW5fZXhwcihleHByWzJdKSAmJiBib29sZWFuX2V4cHIoZXhwclszXSkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJbMV0gPSBleHByWzFdLnN1YnN0cigwLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChubyAmJiBleHByWzBdID09IFwiYmluYXJ5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKGV4cHJbMV0gPT0gXCJ8fFwiIHx8IGV4cHJbMV0gPT0gXCImJlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHdob2xlIGV4cHJlc3Npb24gaXMgbm90IGNvbnN0YW50IGJ1dCB0aGUgbHZhbCBtYXkgYmUuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGx2YWwgPSBldmFsdWF0ZShleHByWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gKChleHByWzFdID09IFwiJiZcIiAmJiAobHZhbCA/IGV4cHJbM10gOiBsdmFsKSkgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChleHByWzFdID09IFwifHxcIiAmJiAobHZhbCA/IGx2YWwgICAgOiBleHByWzNdKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChleDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJR05PUkUuLi4gbHZhbCBpcyBub3QgY29uc3RhbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm8gPyBuby5jYWxsKGV4cHIsIGV4cHIpIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG59KSgpO1xuXG5mdW5jdGlvbiB3YXJuX3VucmVhY2hhYmxlKGFzdCkge1xuICAgICAgICBpZiAoIWVtcHR5KGFzdCkpXG4gICAgICAgICAgICAgICAgd2FybihcIkRyb3BwaW5nIHVucmVhY2hhYmxlIGNvZGU6IFwiICsgZ2VuX2NvZGUoYXN0LCB0cnVlKSk7XG59O1xuXG5mdW5jdGlvbiBwcmVwYXJlX2lmcyhhc3QpIHtcbiAgICAgICAgdmFyIHcgPSBhc3Rfd2Fsa2VyKCksIHdhbGsgPSB3LndhbGs7XG4gICAgICAgIC8vIEluIHRoaXMgZmlyc3QgcGFzcywgd2UgcmV3cml0ZSBpZnMgd2hpY2ggYWJvcnQgd2l0aCBubyBlbHNlIHdpdGggYW5cbiAgICAgICAgLy8gaWYtZWxzZS4gIEZvciBleGFtcGxlOlxuICAgICAgICAvL1xuICAgICAgICAvLyBpZiAoeCkge1xuICAgICAgICAvLyAgICAgYmxhaCgpO1xuICAgICAgICAvLyAgICAgcmV0dXJuIHk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gZm9vYmFyKCk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGlzIHJld3JpdHRlbiBpbnRvOlxuICAgICAgICAvL1xuICAgICAgICAvLyBpZiAoeCkge1xuICAgICAgICAvLyAgICAgYmxhaCgpO1xuICAgICAgICAvLyAgICAgcmV0dXJuIHk7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgICBmb29iYXIoKTtcbiAgICAgICAgLy8gfVxuICAgICAgICBmdW5jdGlvbiByZWRvX2lmKHN0YXRlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzID0gTUFQKHN0YXRlbWVudHMsIHdhbGspO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmkgPSBzdGF0ZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpWzBdICE9IFwiaWZcIikgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaVszXSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZmlbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFib3J0cyh0KSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25kaXRpb25hbCA9IHdhbGsoZmlbMV0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZV9ib2R5ID0gcmVkb19pZihzdGF0ZW1lbnRzLnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGVfYm9keS5sZW5ndGggPT0gMSA/IGVfYm9keVswXSA6IFsgXCJibG9ja1wiLCBlX2JvZHkgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlbWVudHMuc2xpY2UoMCwgaSkuY29uY2F0KFsgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaVswXSwgICAgICAgICAgLy8gXCJpZlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbmFsLCAgICAvLyBjb25kaXRpb25hbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LCAgICAgICAgICAgICAgLy8gdGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlICAgICAgICAgICAgICAgLy8gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgXSBdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVtZW50cztcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiByZWRvX2lmX2xhbWJkYShuYW1lLCBhcmdzLCBib2R5KSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IHJlZG9faWYoYm9keSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgbmFtZSwgYXJncywgYm9keSBdO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlZG9faWZfYmxvY2soc3RhdGVtZW50cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHN0YXRlbWVudHMgIT0gbnVsbCA/IHJlZG9faWYoc3RhdGVtZW50cykgOiBudWxsIF07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHcud2l0aF93YWxrZXJzKHtcbiAgICAgICAgICAgICAgICBcImRlZnVuXCI6IHJlZG9faWZfbGFtYmRhLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIjogcmVkb19pZl9sYW1iZGEsXG4gICAgICAgICAgICAgICAgXCJibG9ja1wiOiByZWRvX2lmX2Jsb2NrLFxuICAgICAgICAgICAgICAgIFwic3BsaWNlXCI6IHJlZG9faWZfYmxvY2ssXG4gICAgICAgICAgICAgICAgXCJ0b3BsZXZlbFwiOiBmdW5jdGlvbihzdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCByZWRvX2lmKHN0YXRlbWVudHMpIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInRyeVwiOiBmdW5jdGlvbih0LCBjLCBmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWRvX2lmKHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjICE9IG51bGwgPyBbIGNbMF0sIHJlZG9faWYoY1sxXSkgXSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgIT0gbnVsbCA/IHJlZG9faWYoZikgOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhbGsoYXN0KTtcbiAgICAgICAgfSk7XG59O1xuXG5mdW5jdGlvbiBmb3Jfc2lkZV9lZmZlY3RzKGFzdCwgaGFuZGxlcikge1xuICAgICAgICB2YXIgdyA9IGFzdF93YWxrZXIoKSwgd2FsayA9IHcud2FsaztcbiAgICAgICAgdmFyICRzdG9wID0ge30sICRyZXN0YXJ0ID0ge307XG4gICAgICAgIGZ1bmN0aW9uIHN0b3AoKSB7IHRocm93ICRzdG9wIH07XG4gICAgICAgIGZ1bmN0aW9uIHJlc3RhcnQoKSB7IHRocm93ICRyZXN0YXJ0IH07XG4gICAgICAgIGZ1bmN0aW9uIGZvdW5kKCl7IHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgdGhpcywgdywgc3RvcCwgcmVzdGFydCkgfTtcbiAgICAgICAgZnVuY3Rpb24gdW5hcnkob3ApIHtcbiAgICAgICAgICAgICAgICBpZiAob3AgPT0gXCIrK1wiIHx8IG9wID09IFwiLS1cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBiaW5hcnkob3ApIHtcbiAgICAgICAgICAgICAgICBpZiAob3AgPT0gXCImJlwiIHx8IG9wID09IFwifHxcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdy53aXRoX3dhbGtlcnMoe1xuICAgICAgICAgICAgICAgIFwidHJ5XCI6IGZvdW5kLFxuICAgICAgICAgICAgICAgIFwidGhyb3dcIjogZm91bmQsXG4gICAgICAgICAgICAgICAgXCJyZXR1cm5cIjogZm91bmQsXG4gICAgICAgICAgICAgICAgXCJuZXdcIjogZm91bmQsXG4gICAgICAgICAgICAgICAgXCJzd2l0Y2hcIjogZm91bmQsXG4gICAgICAgICAgICAgICAgXCJicmVha1wiOiBmb3VuZCxcbiAgICAgICAgICAgICAgICBcImNvbnRpbnVlXCI6IGZvdW5kLFxuICAgICAgICAgICAgICAgIFwiYXNzaWduXCI6IGZvdW5kLFxuICAgICAgICAgICAgICAgIFwiY2FsbFwiOiBmb3VuZCxcbiAgICAgICAgICAgICAgICBcImlmXCI6IGZvdW5kLFxuICAgICAgICAgICAgICAgIFwiZm9yXCI6IGZvdW5kLFxuICAgICAgICAgICAgICAgIFwiZm9yLWluXCI6IGZvdW5kLFxuICAgICAgICAgICAgICAgIFwid2hpbGVcIjogZm91bmQsXG4gICAgICAgICAgICAgICAgXCJkb1wiOiBmb3VuZCxcbiAgICAgICAgICAgICAgICBcInJldHVyblwiOiBmb3VuZCxcbiAgICAgICAgICAgICAgICBcInVuYXJ5LXByZWZpeFwiOiB1bmFyeSxcbiAgICAgICAgICAgICAgICBcInVuYXJ5LXBvc3RmaXhcIjogdW5hcnksXG4gICAgICAgICAgICAgICAgXCJjb25kaXRpb25hbFwiOiBmb3VuZCxcbiAgICAgICAgICAgICAgICBcImJpbmFyeVwiOiBiaW5hcnksXG4gICAgICAgICAgICAgICAgXCJkZWZ1blwiOiBmb3VuZFxuICAgICAgICB9LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2Fsayhhc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4ID09PSAkc3RvcCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXggPT09ICRyZXN0YXJ0KSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG59O1xuXG5mdW5jdGlvbiBhc3RfbGlmdF92YXJpYWJsZXMoYXN0KSB7XG4gICAgICAgIHZhciB3ID0gYXN0X3dhbGtlcigpLCB3YWxrID0gdy53YWxrLCBzY29wZTtcbiAgICAgICAgZnVuY3Rpb24gZG9fYm9keShib2R5LCBlbnYpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3Njb3BlID0gc2NvcGU7XG4gICAgICAgICAgICAgICAgc2NvcGUgPSBlbnY7XG4gICAgICAgICAgICAgICAgYm9keSA9IE1BUChib2R5LCB3YWxrKTtcbiAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IHt9LCBuYW1lcyA9IE1BUChlbnYubmFtZXMsIGZ1bmN0aW9uKHR5cGUsIG5hbWUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT0gXCJ2YXJcIikgcmV0dXJuIE1BUC5za2lwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbnYucmVmZXJlbmNlcyhuYW1lKSkgcmV0dXJuIE1BUC5za2lwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzaFtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBuYW1lIF07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvb2tpbmcgZm9yIGFzc2lnbm1lbnRzIHRvIGFueSBvZiB0aGVzZSB2YXJpYWJsZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gc2F2ZSBjb25zaWRlcmFibGUgc3BhY2UgYnkgbW92aW5nIHRoZSBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIHZhciBkZWNsYXJhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcl9zaWRlX2VmZmVjdHMoWyBcImJsb2NrXCIsIGJvZHkgXSwgZnVuY3Rpb24oYXN0LCB3YWxrZXIsIHN0b3AsIHJlc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFzdFswXSA9PSBcImFzc2lnblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBhc3RbMV0gPT09IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGFzdFsyXVswXSA9PSBcIm5hbWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgSE9QKGhhc2gsIGFzdFsyXVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlcnQgdGhlIGRlZmluaXRpb24gaW50byB0aGUgdmFyIGRlY2xhcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG5hbWVzLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZXNbaV1bMF0gPT0gYXN0WzJdWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lc1tpXVsxXSkgLy8gdGhpcyBuYW1lIGFscmVhZHkgZGVmaW5lZCwgd2UgbXVzdCBzdG9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc1tpXVsxXSA9IGFzdFszXTsgLy8gZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKG5hbWVzLnNwbGljZShpLCAxKVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhpcyBhc3NpZ25tZW50IGZyb20gdGhlIEFTVC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHdhbGtlci5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocFswXSA9PSBcInNlcVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHBbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnVuc2hpZnQoMCwgcC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5zcGxpY2UuYXBwbHkocCwgYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBbMF0gPT0gXCJzdGF0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuc3BsaWNlKDAsIHAubGVuZ3RoLCBcImJsb2NrXCIpOyAvLyBlbXB0eSBzdGF0ZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkudW5zaGlmdChbIFwidmFyXCIsIG5hbWVzIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzY29wZSA9IF9zY29wZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm9keTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gX3ZhcmRlZnMoZGVmcykge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBkZWZzLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGRlZnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRbMV0pIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IFsgXCJhc3NpZ25cIiwgdHJ1ZSwgWyBcIm5hbWVcIiwgZFswXSBdLCBkWzFdIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09IG51bGwpIHJldCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHJldCA9IFsgXCJzZXFcIiwgZCwgcmV0IF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXQgPT0gbnVsbCAmJiB3LnBhcmVudCgpWzBdICE9IFwiZm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3LnBhcmVudCgpWzBdID09IFwiZm9yLWluXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIFwibmFtZVwiLCBkZWZzWzBdWzBdIF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTUFQLnNraXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbIFwic3RhdFwiLCByZXQgXTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gX3RvcGxldmVsKGJvZHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBkb19ib2R5KGJvZHksIHRoaXMuc2NvcGUpIF07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB3LndpdGhfd2Fsa2Vycyh7XG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiOiBmdW5jdGlvbihuYW1lLCBhcmdzLCBib2R5KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBhcmdzLmxlbmd0aDsgLS1pID49IDAgJiYgIWJvZHkuc2NvcGUucmVmZXJlbmNlcyhhcmdzW2ldKTspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJvZHkuc2NvcGUucmVmZXJlbmNlcyhuYW1lKSkgbmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBuYW1lLCBhcmdzLCBkb19ib2R5KGJvZHksIGJvZHkuc2NvcGUpIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImRlZnVuXCI6IGZ1bmN0aW9uKG5hbWUsIGFyZ3MsIGJvZHkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY29wZS5yZWZlcmVuY2VzKG5hbWUpKSByZXR1cm4gTUFQLnNraXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gYXJncy5sZW5ndGg7IC0taSA+PSAwICYmICFib2R5LnNjb3BlLnJlZmVyZW5jZXMoYXJnc1tpXSk7KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgbmFtZSwgYXJncywgZG9fYm9keShib2R5LCBib2R5LnNjb3BlKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ2YXJcIjogX3ZhcmRlZnMsXG4gICAgICAgICAgICAgICAgXCJ0b3BsZXZlbFwiOiBfdG9wbGV2ZWxcbiAgICAgICAgfSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2Fsayhhc3RfYWRkX3Njb3BlKGFzdCkpO1xuICAgICAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGFzdF9zcXVlZXplKGFzdCwgb3B0aW9ucykge1xuICAgICAgICBhc3QgPSBzcXVlZXplXzEoYXN0LCBvcHRpb25zKTtcbiAgICAgICAgYXN0ID0gc3F1ZWV6ZV8yKGFzdCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBhc3Q7XG59O1xuXG5mdW5jdGlvbiBzcXVlZXplXzEoYXN0LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgbWFrZV9zZXFzICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRlYWRfY29kZSAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBub193YXJuaW5ncyA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGtlZXBfY29tcHMgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB1bnNhZmUgICAgICA6IGZhbHNlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB3ID0gYXN0X3dhbGtlcigpLCB3YWxrID0gdy53YWxrLCBzY29wZTtcblxuICAgICAgICBmdW5jdGlvbiBuZWdhdGUoYykge1xuICAgICAgICAgICAgICAgIHZhciBub3RfYyA9IFsgXCJ1bmFyeS1wcmVmaXhcIiwgXCIhXCIsIGMgXTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInVuYXJ5LXByZWZpeFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNbMV0gPT0gXCIhXCIgJiYgYm9vbGVhbl9leHByKGNbMl0pID8gY1syXSA6IG5vdF9jO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2VxXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gc2xpY2UoYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjW2MubGVuZ3RoIC0gMV0gPSBuZWdhdGUoY1tjLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY29uZGl0aW9uYWxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0X29mKG5vdF9jLCBbIFwiY29uZGl0aW9uYWxcIiwgY1sxXSwgbmVnYXRlKGNbMl0pLCBuZWdhdGUoY1szXSkgXSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJiaW5hcnlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcCA9IGNbMV0sIGxlZnQgPSBjWzJdLCByaWdodCA9IGNbM107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMua2VlcF9jb21wcykgc3dpdGNoIChvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI8PVwiICA6IHJldHVybiBbIFwiYmluYXJ5XCIsIFwiPlwiLCBsZWZ0LCByaWdodCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI8XCIgICA6IHJldHVybiBbIFwiYmluYXJ5XCIsIFwiPj1cIiwgbGVmdCwgcmlnaHQgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPj1cIiAgOiByZXR1cm4gWyBcImJpbmFyeVwiLCBcIjxcIiwgbGVmdCwgcmlnaHQgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPlwiICAgOiByZXR1cm4gWyBcImJpbmFyeVwiLCBcIjw9XCIsIGxlZnQsIHJpZ2h0IF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj09XCIgIDogcmV0dXJuIFsgXCJiaW5hcnlcIiwgXCIhPVwiLCBsZWZ0LCByaWdodCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhPVwiICA6IHJldHVybiBbIFwiYmluYXJ5XCIsIFwiPT1cIiwgbGVmdCwgcmlnaHQgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPT09XCIgOiByZXR1cm4gWyBcImJpbmFyeVwiLCBcIiE9PVwiLCBsZWZ0LCByaWdodCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhPT1cIiA6IHJldHVybiBbIFwiYmluYXJ5XCIsIFwiPT09XCIsIGxlZnQsIHJpZ2h0IF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiYmXCIgIDogcmV0dXJuIGJlc3Rfb2Yobm90X2MsIFsgXCJiaW5hcnlcIiwgXCJ8fFwiLCBuZWdhdGUobGVmdCksIG5lZ2F0ZShyaWdodCkgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInx8XCIgIDogcmV0dXJuIGJlc3Rfb2Yobm90X2MsIFsgXCJiaW5hcnlcIiwgXCImJlwiLCBuZWdhdGUobGVmdCksIG5lZ2F0ZShyaWdodCkgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdF9jO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VfY29uZGl0aW9uYWwoYywgdCwgZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYWtlX3JlYWxfY29uZGl0aW9uYWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjWzBdID09IFwidW5hcnktcHJlZml4XCIgJiYgY1sxXSA9PSBcIiFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSA/IFsgXCJjb25kaXRpb25hbFwiLCBjWzJdLCBlLCB0IF0gOiBbIFwiYmluYXJ5XCIsIFwifHxcIiwgY1syXSwgdCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgPyBiZXN0X29mKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgXCJjb25kaXRpb25hbFwiLCBjLCB0LCBlIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBcImNvbmRpdGlvbmFsXCIsIG5lZ2F0ZShjKSwgZSwgdCBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgOiBbIFwiYmluYXJ5XCIsIFwiJiZcIiwgYywgdCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gc2hvcnRjdXQgdGhlIGNvbmRpdGlvbmFsIGlmIHRoZSBleHByZXNzaW9uIGhhcyBhIGNvbnN0YW50IHZhbHVlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdoZW5fY29uc3RhbnQoYywgZnVuY3Rpb24oYXN0LCB2YWwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgd2Fybl91bnJlYWNoYWJsZSh2YWwgPyBlIDogdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gICAgICAgICAgKHZhbCA/IHQgOiBlKTtcbiAgICAgICAgICAgICAgICB9LCBtYWtlX3JlYWxfY29uZGl0aW9uYWwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJtYmxvY2soYmxvY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sgIT0gbnVsbCAmJiBibG9ja1swXSA9PSBcImJsb2NrXCIgJiYgYmxvY2tbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja1sxXS5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBibG9ja1sxXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJsb2NrWzFdLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jayA9IFsgXCJibG9ja1wiIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBibG9jaztcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBfbGFtYmRhKG5hbWUsIGFyZ3MsIGJvZHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBuYW1lLCBhcmdzLCB0aWdodGVuKGJvZHksIFwibGFtYmRhXCIpIF07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBkb2VzIGEgZmV3IHRoaW5nczpcbiAgICAgICAgLy8gMS4gZGlzY2FyZCB1c2VsZXNzIGJsb2Nrc1xuICAgICAgICAvLyAyLiBqb2luIGNvbnNlY3V0aXZlIHZhciBkZWNsYXJhdGlvbnNcbiAgICAgICAgLy8gMy4gcmVtb3ZlIG9idmlvdXNseSBkZWFkIGNvZGVcbiAgICAgICAgLy8gNC4gdHJhbnNmb3JtIGNvbnNlY3V0aXZlIHN0YXRlbWVudHMgdXNpbmcgdGhlIGNvbW1hIG9wZXJhdG9yXG4gICAgICAgIC8vIDUuIGlmIGJsb2NrX3R5cGUgPT0gXCJsYW1iZGFcIiBhbmQgaXQgZGV0ZWN0cyBjb25zdHJ1Y3RzIGxpa2UgaWYoZm9vKSByZXR1cm4gLi4uIC0gcmV3cml0ZSBsaWtlIGlmICghZm9vKSB7IC4uLiB9XG4gICAgICAgIGZ1bmN0aW9uIHRpZ2h0ZW4oc3RhdGVtZW50cywgYmxvY2tfdHlwZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlbWVudHMgPSBNQVAoc3RhdGVtZW50cywgd2Fsayk7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzID0gc3RhdGVtZW50cy5yZWR1Y2UoZnVuY3Rpb24oYSwgc3RhdCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdFswXSA9PSBcImJsb2NrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2guYXBwbHkoYSwgc3RhdFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICAgIH0sIFtdKTtcblxuICAgICAgICAgICAgICAgIHN0YXRlbWVudHMgPSAoZnVuY3Rpb24oYSwgcHJldil7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oY3VyKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYgJiYgKChjdXJbMF0gPT0gXCJ2YXJcIiAmJiBwcmV2WzBdID09IFwidmFyXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY3VyWzBdID09IFwiY29uc3RcIiAmJiBwcmV2WzBdID09IFwiY29uc3RcIikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldlsxXSA9IHByZXZbMV0uY29uY2F0KGN1clsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGN1cik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IGN1cjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgICB9KShbXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWFkX2NvZGUpIHN0YXRlbWVudHMgPSAoZnVuY3Rpb24oYSwgaGFzX3F1aXQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHN0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc19xdWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0WzBdID09IFwiZnVuY3Rpb25cIiB8fCBzdFswXSA9PSBcImRlZnVuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0WzBdID09IFwidmFyXCIgfHwgc3RbMF0gPT0gXCJjb25zdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMubm9fd2FybmluZ3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oXCJWYXJpYWJsZXMgZGVjbGFyZWQgaW4gdW5yZWFjaGFibGUgY29kZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0WzFdID0gTUFQKHN0WzFdLCBmdW5jdGlvbihkZWYpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmWzFdICYmICFvcHRpb25zLm5vX3dhcm5pbmdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5fdW5yZWFjaGFibGUoWyBcImFzc2lnblwiLCB0cnVlLCBbIFwibmFtZVwiLCBkZWZbMF0gXSwgZGVmWzFdIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBkZWZbMF0gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIW9wdGlvbnMubm9fd2FybmluZ3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuX3VucmVhY2hhYmxlKHN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXIoc3RbMF0sIFsgXCJyZXR1cm5cIiwgXCJ0aHJvd1wiLCBcImJyZWFrXCIsIFwiY29udGludWVcIiBdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc19xdWl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgICB9KShbXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tYWtlX3NlcXMpIHN0YXRlbWVudHMgPSAoZnVuY3Rpb24oYSwgcHJldikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGN1cil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2ICYmIHByZXZbMF0gPT0gXCJzdGF0XCIgJiYgY3VyWzBdID09IFwic3RhdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldlsxXSA9IFsgXCJzZXFcIiwgcHJldlsxXSwgY3VyWzFdIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGN1cik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IGN1cjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYS5sZW5ndGggPj0gMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGFbYS5sZW5ndGgtMl1bMF0gPT0gXCJzdGF0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoYVthLmxlbmd0aC0xXVswXSA9PSBcInJldHVyblwiIHx8IGFbYS5sZW5ndGgtMV1bMF0gPT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGFbYS5sZW5ndGgtMV1bMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuc3BsaWNlKGEubGVuZ3RoIC0gMiwgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBhW2EubGVuZ3RoLTFdWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgXCJzZXFcIiwgYVthLmxlbmd0aC0yXVsxXSwgYVthLmxlbmd0aC0xXVsxXSBdXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgICB9KShbXSk7XG5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIGluY3JlYXNlcyBqUXVlcnkgYnkgMUsuICBQcm9iYWJseSBub3Qgc3VjaCBhIGdvb2QgaWRlYSBhZnRlciBhbGwuLlxuICAgICAgICAgICAgICAgIC8vIHBhcnQgb2YgdGhpcyBpcyBkb25lIGluIHByZXBhcmVfaWZzIGFueXdheS5cbiAgICAgICAgICAgICAgICAvLyBpZiAoYmxvY2tfdHlwZSA9PSBcImxhbWJkYVwiKSBzdGF0ZW1lbnRzID0gKGZ1bmN0aW9uKGksIGEsIHN0YXQpe1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgd2hpbGUgKGkgPCBzdGF0ZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICBzdGF0ID0gc3RhdGVtZW50c1tpKytdO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICBpZiAoc3RhdFswXSA9PSBcImlmXCIgJiYgIXN0YXRbM10pIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdFsyXVswXSA9PSBcInJldHVyblwiICYmIHN0YXRbMl1bMV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKG1ha2VfaWYobmVnYXRlKHN0YXRbMV0pLCBbIFwiYmxvY2tcIiwgc3RhdGVtZW50cy5zbGljZShpKSBdKSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3QgPSBsYXN0X3N0YXQoc3RhdFsyXSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RbMF0gPT0gXCJyZXR1cm5cIiAmJiBsYXN0WzFdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChtYWtlX2lmKHN0YXRbMV0sIFsgXCJibG9ja1wiLCBzdGF0WzJdWzFdLnNsaWNlKDAsIC0xKSBdLCBbIFwiYmxvY2tcIiwgc3RhdGVtZW50cy5zbGljZShpKSBdKSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgYS5wdXNoKHN0YXQpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgLy8gfSkoMCwgW10pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlbWVudHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZV9pZihjLCB0LCBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdoZW5fY29uc3RhbnQoYywgZnVuY3Rpb24oYXN0LCB2YWwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gd2Fsayh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Fybl91bnJlYWNoYWJsZShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgfHwgWyBcImJsb2NrXCIgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB3YWxrKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuX3VucmVhY2hhYmxlKHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSB8fCBbIFwiYmxvY2tcIiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VfcmVhbF9pZihjLCB0LCBlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBhYm9ydF9lbHNlKGMsIHQsIGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gWyBbIFwiaWZcIiwgbmVnYXRlKGMpLCBlIF0gXTtcbiAgICAgICAgICAgICAgICBpZiAodFswXSA9PSBcImJsb2NrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0WzFdKSByZXQgPSByZXQuY29uY2F0KHRbMV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaCh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhbGsoWyBcImJsb2NrXCIsIHJldCBdKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBtYWtlX3JlYWxfaWYoYywgdCwgZSkge1xuICAgICAgICAgICAgICAgIGMgPSB3YWxrKGMpO1xuICAgICAgICAgICAgICAgIHQgPSB3YWxrKHQpO1xuICAgICAgICAgICAgICAgIGUgPSB3YWxrKGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVtcHR5KGUpICYmIGVtcHR5KHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgXCJzdGF0XCIsIGMgXTtcblxuICAgICAgICAgICAgICAgIGlmIChlbXB0eSh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IG5lZ2F0ZShjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbXB0eShlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYm90aCBlbHNlIGFuZCB0aGVuLCBtYXliZSBpdCBtYWtlcyBzZW5zZSB0byBzd2l0Y2ggdGhlbT9cbiAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGdlbl9jb2RlKGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IG5lZ2F0ZShjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBnZW5fY29kZShuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIubGVuZ3RoIDwgYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gdG1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gWyBcImlmXCIsIGMsIHQsIGUgXTtcbiAgICAgICAgICAgICAgICBpZiAodFswXSA9PSBcImlmXCIgJiYgZW1wdHkodFszXSkgJiYgZW1wdHkoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IGJlc3Rfb2YocmV0LCB3YWxrKFsgXCJpZlwiLCBbIFwiYmluYXJ5XCIsIFwiJiZcIiwgYywgdFsxXSBdLCB0WzJdIF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodFswXSA9PSBcInN0YXRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVbMF0gPT0gXCJzdGF0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gYmVzdF9vZihyZXQsIFsgXCJzdGF0XCIsIG1ha2VfY29uZGl0aW9uYWwoYywgdFsxXSwgZVsxXSkgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFib3J0cyhlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBhYm9ydF9lbHNlKGMsIHQsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IGJlc3Rfb2YocmV0LCBbIFwic3RhdFwiLCBtYWtlX2NvbmRpdGlvbmFsKGMsIHRbMV0pIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlICYmIHRbMF0gPT0gZVswXSAmJiAodFswXSA9PSBcInJldHVyblwiIHx8IHRbMF0gPT0gXCJ0aHJvd1wiKSAmJiB0WzFdICYmIGVbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IGJlc3Rfb2YocmV0LCBbIHRbMF0sIG1ha2VfY29uZGl0aW9uYWwoYywgdFsxXSwgZVsxXSApIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlICYmIGFib3J0cyh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gWyBbIFwiaWZcIiwgYywgdCBdIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZVswXSA9PSBcImJsb2NrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVbMV0pIHJldCA9IHJldC5jb25jYXQoZVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSB3YWxrKFsgXCJibG9ja1wiLCByZXQgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQgJiYgYWJvcnRzKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBhYm9ydF9lbHNlKGMsIHQsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIF9kb193aGlsZShjb25kLCBib2R5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdoZW5fY29uc3RhbnQoY29uZCwgZnVuY3Rpb24oY29uZCwgdmFsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5fdW5yZWFjaGFibGUoYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIFwiYmxvY2tcIiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgXCJmb3JcIiwgbnVsbCwgbnVsbCwgbnVsbCwgd2Fsayhib2R5KSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB3LndpdGhfd2Fsa2Vycyh7XG4gICAgICAgICAgICAgICAgXCJzdWJcIjogZnVuY3Rpb24oZXhwciwgc3Vic2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0WzBdID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBzdWJzY3JpcHRbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc19pZGVudGlmaWVyKG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIFwiZG90XCIsIHdhbGsoZXhwciksIG5hbWUgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoL15bMS05XVswLTldKiQvLnRlc3QobmFtZSkgfHwgbmFtZSA9PT0gXCIwXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgXCJzdWJcIiwgd2FsayhleHByKSwgWyBcIm51bVwiLCBwYXJzZUludChuYW1lLCAxMCkgXSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJpZlwiOiBtYWtlX2lmLFxuICAgICAgICAgICAgICAgIFwidG9wbGV2ZWxcIjogZnVuY3Rpb24oYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgXCJ0b3BsZXZlbFwiLCB0aWdodGVuKGJvZHkpIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInN3aXRjaFwiOiBmdW5jdGlvbihleHByLCBib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IGJvZHkubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIFwic3dpdGNoXCIsIHdhbGsoZXhwciksIE1BUChib2R5LCBmdW5jdGlvbihicmFuY2gsIGkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSB0aWdodGVuKGJyYW5jaFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09IGxhc3QgJiYgYmxvY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gYmxvY2tbYmxvY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVbMF0gPT0gXCJicmVha1wiICYmICFub2RlWzFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgYnJhbmNoWzBdID8gd2FsayhicmFuY2hbMF0pIDogbnVsbCwgYmxvY2sgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCI6IF9sYW1iZGEsXG4gICAgICAgICAgICAgICAgXCJkZWZ1blwiOiBfbGFtYmRhLFxuICAgICAgICAgICAgICAgIFwiYmxvY2tcIjogZnVuY3Rpb24oYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkpIHJldHVybiBybWJsb2NrKFsgXCJibG9ja1wiLCB0aWdodGVuKGJvZHkpIF0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJiaW5hcnlcIjogZnVuY3Rpb24ob3AsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2hlbl9jb25zdGFudChbIFwiYmluYXJ5XCIsIG9wLCB3YWxrKGxlZnQpLCB3YWxrKHJpZ2h0KSBdLCBmdW5jdGlvbiB5ZXMoYyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0X29mKHdhbGsoYyksIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gbm8oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG9wICE9IFwiPT1cIiAmJiBvcCAhPSBcIiE9XCIpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IHdhbGsobGVmdCksIHIgPSB3YWxrKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihsICYmIGxbMF0gPT0gXCJ1bmFyeS1wcmVmaXhcIiAmJiBsWzFdID09IFwiIVwiICYmIGxbMl1bMF0gPT0gXCJudW1cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBbJ251bScsICshbFsyXVsxXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAociAmJiByWzBdID09IFwidW5hcnktcHJlZml4XCIgJiYgclsxXSA9PSBcIiFcIiAmJiByWzJdWzBdID09IFwibnVtXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IFsnbnVtJywgKyFyWzJdWzFdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiYmluYXJ5XCIsIG9wLCBsZWZ0LCByaWdodF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oKSB8fCB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImNvbmRpdGlvbmFsXCI6IGZ1bmN0aW9uKGMsIHQsIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX2NvbmRpdGlvbmFsKHdhbGsoYyksIHdhbGsodCksIHdhbGsoZSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ0cnlcIjogZnVuY3Rpb24odCwgYywgZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0cnlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlnaHRlbih0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyAhPSBudWxsID8gWyBjWzBdLCB0aWdodGVuKGNbMV0pIF0gOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmICE9IG51bGwgPyB0aWdodGVuKGYpIDogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwidW5hcnktcHJlZml4XCI6IGZ1bmN0aW9uKG9wLCBleHByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByID0gd2FsayhleHByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBbIFwidW5hcnktcHJlZml4XCIsIG9wLCBleHByIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AgPT0gXCIhXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IGJlc3Rfb2YocmV0LCBuZWdhdGUoZXhwcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdoZW5fY29uc3RhbnQocmV0LCBmdW5jdGlvbihhc3QsIHZhbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3YWxrKGFzdCk7IC8vIGl0J3MgZWl0aGVyIHRydWUgb3IgZmFsc2UsIHNvIG1pbmlmaWVzIHRvICEwIG9yICExXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHsgcmV0dXJuIHJldCB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidHJ1ZVwiOiByZXR1cm4gWyBcInVuYXJ5LXByZWZpeFwiLCBcIiFcIiwgWyBcIm51bVwiLCAwIF1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmYWxzZVwiOiByZXR1cm4gWyBcInVuYXJ5LXByZWZpeFwiLCBcIiFcIiwgWyBcIm51bVwiLCAxIF1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ3aGlsZVwiOiBfZG9fd2hpbGUsXG4gICAgICAgICAgICAgICAgXCJhc3NpZ25cIjogZnVuY3Rpb24ob3AsIGx2YWx1ZSwgcnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsdmFsdWUgPSB3YWxrKGx2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBydmFsdWUgPSB3YWxrKHJ2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2tPcHMgPSBbICcrJywgJy0nLCAnLycsICcqJywgJyUnLCAnPj4nLCAnPDwnLCAnPj4+JywgJ3wnLCAnXicsICcmJyBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wID09PSB0cnVlICYmIGx2YWx1ZVswXSA9PT0gXCJuYW1lXCIgJiYgcnZhbHVlWzBdID09PSBcImJpbmFyeVwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfm9rT3BzLmluZGV4T2YocnZhbHVlWzFdKSAmJiBydmFsdWVbMl1bMF0gPT09IFwibmFtZVwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnZhbHVlWzJdWzFdID09PSBsdmFsdWVbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgcnZhbHVlWzFdLCBsdmFsdWUsIHJ2YWx1ZVszXSBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBvcCwgbHZhbHVlLCBydmFsdWUgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiY2FsbFwiOiBmdW5jdGlvbihleHByLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByID0gd2FsayhleHByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnVuc2FmZSAmJiBleHByWzBdID09IFwiZG90XCIgJiYgZXhwclsxXVswXSA9PSBcInN0cmluZ1wiICYmIGV4cHJbMl0gPT0gXCJ0b1N0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHByWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgZXhwciwgIE1BUChhcmdzLCB3YWxrKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJudW1cIjogZnVuY3Rpb24gKG51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShudW0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBcImJpbmFyeVwiLCBcIi9cIiwgbnVtID09PSAxIC8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFsgXCJudW1cIiwgMSBdIDogbnVtID09PSAtMSAvIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbIFwidW5hcnktcHJlZml4XCIsIFwiLVwiLCBbIFwibnVtXCIsIDEgXSBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogWyBcIm51bVwiLCAwIF0sIFsgXCJudW1cIiwgMCBdIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIG51bSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhbGsocHJlcGFyZV9pZnMod2FsayhwcmVwYXJlX2lmcyhhc3QpKSkpO1xuICAgICAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIHNxdWVlemVfMihhc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHcgPSBhc3Rfd2Fsa2VyKCksIHdhbGsgPSB3LndhbGssIHNjb3BlO1xuICAgICAgICBmdW5jdGlvbiB3aXRoX3Njb3BlKHMsIGNvbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2F2ZSA9IHNjb3BlLCByZXQ7XG4gICAgICAgICAgICAgICAgc2NvcGUgPSBzO1xuICAgICAgICAgICAgICAgIHJldCA9IGNvbnQoKTtcbiAgICAgICAgICAgICAgICBzY29wZSA9IHNhdmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gbGFtYmRhKG5hbWUsIGFyZ3MsIGJvZHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBuYW1lLCBhcmdzLCB3aXRoX3Njb3BlKGJvZHkuc2NvcGUsIGN1cnJ5KE1BUCwgYm9keSwgd2FsaykpIF07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB3LndpdGhfd2Fsa2Vycyh7XG4gICAgICAgICAgICAgICAgXCJkaXJlY3RpdmVcIjogZnVuY3Rpb24oZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGUuYWN0aXZlX2RpcmVjdGl2ZShkaXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBcImJsb2NrXCIgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmRpcmVjdGl2ZXMucHVzaChkaXIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ0b3BsZXZlbFwiOiBmdW5jdGlvbihib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCB3aXRoX3Njb3BlKHRoaXMuc2NvcGUsIGN1cnJ5KE1BUCwgYm9keSwgd2FsaykpIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCI6IGxhbWJkYSxcbiAgICAgICAgICAgICAgICBcImRlZnVuXCI6IGxhbWJkYVxuICAgICAgICB9LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHJldHVybiB3YWxrKGFzdF9hZGRfc2NvcGUoYXN0KSk7XG4gICAgICAgIH0pO1xufTtcblxuLyogLS0tLS1bIHJlLWdlbmVyYXRlIGNvZGUgZnJvbSB0aGUgQVNUIF0tLS0tLSAqL1xuXG52YXIgRE9UX0NBTExfTk9fUEFSRU5TID0ganNwLmFycmF5X3RvX2hhc2goW1xuICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgXCJhcnJheVwiLFxuICAgICAgICBcIm9iamVjdFwiLFxuICAgICAgICBcInN0cmluZ1wiLFxuICAgICAgICBcImRvdFwiLFxuICAgICAgICBcInN1YlwiLFxuICAgICAgICBcImNhbGxcIixcbiAgICAgICAgXCJyZWdleHBcIixcbiAgICAgICAgXCJkZWZ1blwiXG5dKTtcblxuZnVuY3Rpb24gbWFrZV9zdHJpbmcoc3RyLCBhc2NpaV9vbmx5KSB7XG4gICAgICAgIHZhciBkcSA9IDAsIHNxID0gMDtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL1tcXFxcXFxiXFxmXFxuXFxyXFx0XFx4MjJcXHgyN1xcdTIwMjhcXHUyMDI5XFwwXS9nLCBmdW5jdGlvbihzKXtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjogcmV0dXJuIFwiXFxcXFxcXFxcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlxcYlwiOiByZXR1cm4gXCJcXFxcYlwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXFxmXCI6IHJldHVybiBcIlxcXFxmXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJcXG5cIjogcmV0dXJuIFwiXFxcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlxcclwiOiByZXR1cm4gXCJcXFxcclwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXFx1MjAyOFwiOiByZXR1cm4gXCJcXFxcdTIwMjhcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjlcIjogcmV0dXJuIFwiXFxcXHUyMDI5XCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1wiJzogKytkcTsgcmV0dXJuICdcIic7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCInXCI6ICsrc3E7IHJldHVybiBcIidcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlxcMFwiOiByZXR1cm4gXCJcXFxcMFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhc2NpaV9vbmx5KSBzdHIgPSB0b19hc2NpaShzdHIpO1xuICAgICAgICBpZiAoZHEgPiBzcSkgcmV0dXJuIFwiJ1wiICsgc3RyLnJlcGxhY2UoL1xceDI3L2csIFwiXFxcXCdcIikgKyBcIidcIjtcbiAgICAgICAgZWxzZSByZXR1cm4gJ1wiJyArIHN0ci5yZXBsYWNlKC9cXHgyMi9nLCAnXFxcXFwiJykgKyAnXCInO1xufTtcblxuZnVuY3Rpb24gdG9fYXNjaWkoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcdTAwODAtXFx1ZmZmZl0vZywgZnVuY3Rpb24oY2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjb2RlLmxlbmd0aCA8IDQpIGNvZGUgPSBcIjBcIiArIGNvZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHVcIiArIGNvZGU7XG4gICAgICAgIH0pO1xufTtcblxudmFyIFNQTElDRV9ORUVEU19CUkFDS0VUUyA9IGpzcC5hcnJheV90b19oYXNoKFsgXCJpZlwiLCBcIndoaWxlXCIsIFwiZG9cIiwgXCJmb3JcIiwgXCJmb3ItaW5cIiwgXCJ3aXRoXCIgXSk7XG5cbmZ1bmN0aW9uIGdlbl9jb2RlKGFzdCwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICAgICAgICAgIGluZGVudF9zdGFydCA6IDAsXG4gICAgICAgICAgICAgICAgaW5kZW50X2xldmVsIDogNCxcbiAgICAgICAgICAgICAgICBxdW90ZV9rZXlzICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzcGFjZV9jb2xvbiAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBiZWF1dGlmeSAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhc2NpaV9vbmx5ICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbmxpbmVfc2NyaXB0OiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGJlYXV0aWZ5ID0gISFvcHRpb25zLmJlYXV0aWZ5O1xuICAgICAgICB2YXIgaW5kZW50YXRpb24gPSAwLFxuICAgICAgICAgICAgbmV3bGluZSA9IGJlYXV0aWZ5ID8gXCJcXG5cIiA6IFwiXCIsXG4gICAgICAgICAgICBzcGFjZSA9IGJlYXV0aWZ5ID8gXCIgXCIgOiBcIlwiO1xuXG4gICAgICAgIGZ1bmN0aW9uIGVuY29kZV9zdHJpbmcoc3RyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IG1ha2Vfc3RyaW5nKHN0ciwgb3B0aW9ucy5hc2NpaV9vbmx5KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5pbmxpbmVfc2NyaXB0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gcmV0LnJlcGxhY2UoLzxcXHgyZnNjcmlwdChbPlxcL1xcdFxcblxcZlxcciBdKS9naSwgXCI8XFxcXC9zY3JpcHQkMVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VfbmFtZShuYW1lKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hc2NpaV9vbmx5KVxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHRvX2FzY2lpKG5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGluZGVudChsaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChiZWF1dGlmeSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSByZXBlYXRfc3RyaW5nKFwiIFwiLCBvcHRpb25zLmluZGVudF9zdGFydCArIGluZGVudGF0aW9uICogb3B0aW9ucy5pbmRlbnRfbGV2ZWwpICsgbGluZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiB3aXRoX2luZGVudChjb250LCBpbmNyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluY3IgPT0gbnVsbCkgaW5jciA9IDE7XG4gICAgICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gaW5jcjtcbiAgICAgICAgICAgICAgICB0cnkgeyByZXR1cm4gY29udC5hcHBseShudWxsLCBzbGljZShhcmd1bWVudHMsIDEpKTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpbmRlbnRhdGlvbiAtPSBpbmNyOyB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbGFzdF9jaGFyKHN0cikge1xuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBmaXJzdF9jaGFyKHN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHIudG9TdHJpbmcoKS5jaGFyQXQoMCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkX3NwYWNlcyhhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJlYXV0aWZ5KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuam9pbihcIiBcIik7XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gYVtpICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goYVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoaXNfaWRlbnRpZmllcl9jaGFyKGxhc3RfY2hhcihhW2ldKSkgJiYgKGlzX2lkZW50aWZpZXJfY2hhcihmaXJzdF9jaGFyKG5leHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGZpcnN0X2NoYXIobmV4dCkgPT0gXCJcXFxcXCIpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoL1tcXCtcXC1dJC8udGVzdChhW2ldLnRvU3RyaW5nKCkpICYmIC9eW1xcK1xcLV0vLnRlc3QobmV4dC50b1N0cmluZygpKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaChcIiBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiLmpvaW4oXCJcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkX2NvbW1hcyhhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuam9pbihcIixcIiArIHNwYWNlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBwYXJlbnRoZXNpemUoZXhwcikge1xuICAgICAgICAgICAgICAgIHZhciBnZW4gPSBtYWtlKGV4cHIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGVsIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgZWwoZXhwcikpIHx8IGV4cHJbMF0gPT0gZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIihcIiArIGdlbiArIFwiKVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGJlc3Rfb2YoYSkge1xuICAgICAgICAgICAgICAgIGlmIChhLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGEubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBhWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoIDw9IGIubGVuZ3RoID8gYSA6IGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiZXN0X29mKFsgYVswXSwgYmVzdF9vZihhLnNsaWNlKDEpKSBdKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBuZWVkc19wYXJlbnMoZXhwcikge1xuICAgICAgICAgICAgICAgIGlmIChleHByWzBdID09IFwiZnVuY3Rpb25cIiB8fCBleHByWzBdID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvdC9jYWxsIG9uIGEgbGl0ZXJhbCBmdW5jdGlvbiByZXF1aXJlcyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uIGxpdGVyYWwgaXRzZWxmIHRvIGJlIHBhcmVudGhlc2l6ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgaWYgaXQncyB0aGUgZmlyc3QgXCJ0aGluZ1wiIGluIGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXRlbWVudC4gIFRoaXMgbWVhbnMgdGhhdCB0aGUgcGFyZW50IGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBcInN0YXRcIiwgYnV0IGl0IGNvdWxkIGFsc28gYmUgYSBcInNlcVwiIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUgdGhlIGZpcnN0IGluIHRoaXMgXCJzZXFcIiBhbmQgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJlbnQgaXMgXCJzdGF0XCIsIGFuZCBzbyBvbi4gIE1lc3N5IHN0dWZmLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGl0IHdvcnRocyB0aGUgdHJvdWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gc2xpY2Uody5zdGFjaygpKSwgc2VsZiA9IGEucG9wKCksIHAgPSBhLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBbMF0gPT0gXCJzdGF0XCIpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChwWzBdID09IFwic2VxXCIgfHwgcFswXSA9PSBcImNhbGxcIiB8fCBwWzBdID09IFwiZG90XCIgfHwgcFswXSA9PSBcInN1YlwiIHx8IHBbMF0gPT0gXCJjb25kaXRpb25hbFwiKSAmJiBwWzFdID09PSBzZWxmKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChwWzBdID09IFwiYmluYXJ5XCIgfHwgcFswXSA9PSBcImFzc2lnblwiIHx8IHBbMF0gPT0gXCJ1bmFyeS1wb3N0Zml4XCIpICYmIHBbMl0gPT09IHNlbGYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZiA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGEucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAhSE9QKERPVF9DQUxMX05PX1BBUkVOUywgZXhwclswXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZV9udW0obnVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0ciA9IG51bS50b1N0cmluZygxMCksIGEgPSBbIHN0ci5yZXBsYWNlKC9eMFxcLi8sIFwiLlwiKS5yZXBsYWNlKCdlKycsICdlJykgXSwgbTtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5mbG9vcihudW0pID09PSBudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW0gPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goXCIweFwiICsgbnVtLnRvU3RyaW5nKDE2KS50b0xvd2VyQ2FzZSgpLCAvLyBwcm9iYWJseSBwb2ludGxlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiMFwiICsgbnVtLnRvU3RyaW5nKDgpKTsgLy8gc2FtZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChcIi0weFwiICsgKC1udW0pLnRvU3RyaW5nKDE2KS50b0xvd2VyQ2FzZSgpLCAvLyBwcm9iYWJseSBwb2ludGxlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLTBcIiArICgtbnVtKS50b1N0cmluZyg4KSk7IC8vIHNhbWUuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG0gPSAvXiguKj8pKDArKSQvLmV4ZWMobnVtKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKG1bMV0gKyBcImVcIiArIG1bMl0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChtID0gL14wP1xcLigwKykoLiopJC8uZXhlYyhudW0pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKG1bMl0gKyBcImUtXCIgKyAobVsxXS5sZW5ndGggKyBtWzJdLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyLnN1YnN0cihzdHIuaW5kZXhPZihcIi5cIikpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlc3Rfb2YoYSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHcgPSBhc3Rfd2Fsa2VyKCk7XG4gICAgICAgIHZhciBtYWtlID0gdy53YWxrO1xuICAgICAgICByZXR1cm4gdy53aXRoX3dhbGtlcnMoe1xuICAgICAgICAgICAgICAgIFwic3RyaW5nXCI6IGVuY29kZV9zdHJpbmcsXG4gICAgICAgICAgICAgICAgXCJudW1cIjogbWFrZV9udW0sXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IG1ha2VfbmFtZSxcbiAgICAgICAgICAgICAgICBcImRlYnVnZ2VyXCI6IGZ1bmN0aW9uKCl7IHJldHVybiBcImRlYnVnZ2VyO1wiIH0sXG4gICAgICAgICAgICAgICAgXCJ0b3BsZXZlbFwiOiBmdW5jdGlvbihzdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ibG9ja19zdGF0ZW1lbnRzKHN0YXRlbWVudHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKG5ld2xpbmUgKyBuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwic3BsaWNlXCI6IGZ1bmN0aW9uKHN0YXRlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSB3LnBhcmVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEhPUChTUExJQ0VfTkVFRFNfQlJBQ0tFVFMsIHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCBibG9jayBicmFja2V0cyBpbiB0aGlzIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VfYmxvY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNQVAobWFrZV9ibG9ja19zdGF0ZW1lbnRzKHN0YXRlbWVudHMsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGxpbmUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmaXJzdCBsaW5lIGlzIGFscmVhZHkgaW5kZW50ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpID4gMCA/IGluZGVudChsaW5lKSA6IGxpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbihuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYmxvY2tcIjogbWFrZV9ibG9jayxcbiAgICAgICAgICAgICAgICBcInZhclwiOiBmdW5jdGlvbihkZWZzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YXIgXCIgKyBhZGRfY29tbWFzKE1BUChkZWZzLCBtYWtlXzF2YXJkZWYpKSArIFwiO1wiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJjb25zdFwiOiBmdW5jdGlvbihkZWZzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb25zdCBcIiArIGFkZF9jb21tYXMoTUFQKGRlZnMsIG1ha2VfMXZhcmRlZikpICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInRyeVwiOiBmdW5jdGlvbih0ciwgY2EsIGZpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0gWyBcInRyeVwiLCBtYWtlX2Jsb2NrKHRyKSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhKSBvdXQucHVzaChcImNhdGNoXCIsIFwiKFwiICsgY2FbMF0gKyBcIilcIiwgbWFrZV9ibG9jayhjYVsxXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpKSBvdXQucHVzaChcImZpbmFsbHlcIiwgbWFrZV9ibG9jayhmaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZF9zcGFjZXMob3V0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwidGhyb3dcIjogZnVuY3Rpb24oZXhwcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZF9zcGFjZXMoWyBcInRocm93XCIsIG1ha2UoZXhwcikgXSkgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwibmV3XCI6IGZ1bmN0aW9uKGN0b3IsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzLmxlbmd0aCA+IDAgPyBcIihcIiArIGFkZF9jb21tYXMoTUFQKGFyZ3MsIGZ1bmN0aW9uKGV4cHIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKGV4cHIsIFwic2VxXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpICsgXCIpXCIgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZF9zcGFjZXMoWyBcIm5ld1wiLCBwYXJlbnRoZXNpemUoY3RvciwgXCJzZXFcIiwgXCJiaW5hcnlcIiwgXCJjb25kaXRpb25hbFwiLCBcImFzc2lnblwiLCBmdW5jdGlvbihleHByKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSBhc3Rfd2Fsa2VyKCksIGhhc19jYWxsID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdy53aXRoX3dhbGtlcnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjYWxsXCI6IGZ1bmN0aW9uKCkgeyB0aHJvdyBoYXNfY2FsbCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3LndhbGsoZXhwcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXggPT09IGhhc19jYWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pICsgYXJncyBdKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwic3dpdGNoXCI6IGZ1bmN0aW9uKGV4cHIsIGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRfc3BhY2VzKFsgXCJzd2l0Y2hcIiwgXCIoXCIgKyBtYWtlKGV4cHIpICsgXCIpXCIsIG1ha2Vfc3dpdGNoX2Jsb2NrKGJvZHkpIF0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJicmVha1wiOiBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9IFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCIgXCIgKyBtYWtlX25hbWUobGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dCArIFwiO1wiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJjb250aW51ZVwiOiBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9IFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCIgXCIgKyBtYWtlX25hbWUobGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dCArIFwiO1wiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJjb25kaXRpb25hbFwiOiBmdW5jdGlvbihjbywgdGgsIGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkX3NwYWNlcyhbIHBhcmVudGhlc2l6ZShjbywgXCJhc3NpZ25cIiwgXCJzZXFcIiwgXCJjb25kaXRpb25hbFwiKSwgXCI/XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudGhlc2l6ZSh0aCwgXCJzZXFcIiksIFwiOlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRoZXNpemUoZWwsIFwic2VxXCIpIF0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhc3NpZ25cIjogZnVuY3Rpb24ob3AsIGx2YWx1ZSwgcnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AgJiYgb3AgIT09IHRydWUpIG9wICs9IFwiPVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBvcCA9IFwiPVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZF9zcGFjZXMoWyBtYWtlKGx2YWx1ZSksIG9wLCBwYXJlbnRoZXNpemUocnZhbHVlLCBcInNlcVwiKSBdKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZG90XCI6IGZ1bmN0aW9uKGV4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXQgPSBtYWtlKGV4cHIpLCBpID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByWzBdID09IFwibnVtXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEvW2EtZi5dL2kudGVzdChvdXQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSBcIi5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwclswXSAhPSBcImZ1bmN0aW9uXCIgJiYgbmVlZHNfcGFyZW5zKGV4cHIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSBcIihcIiArIG91dCArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCIuXCIgKyBtYWtlX25hbWUoYXJndW1lbnRzW2krK10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiY2FsbFwiOiBmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IG1ha2UoZnVuYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZi5jaGFyQXQoMCkgIT0gXCIoXCIgJiYgbmVlZHNfcGFyZW5zKGZ1bmMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gXCIoXCIgKyBmICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZiArIFwiKFwiICsgYWRkX2NvbW1hcyhNQVAoYXJncywgZnVuY3Rpb24oZXhwcil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUoZXhwciwgXCJzZXFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkgKyBcIilcIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIjogbWFrZV9mdW5jdGlvbixcbiAgICAgICAgICAgICAgICBcImRlZnVuXCI6IG1ha2VfZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgXCJpZlwiOiBmdW5jdGlvbihjbywgdGgsIGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0gWyBcImlmXCIsIFwiKFwiICsgbWFrZShjbykgKyBcIilcIiwgZWwgPyBtYWtlX3RoZW4odGgpIDogbWFrZSh0aCkgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChcImVsc2VcIiwgbWFrZShlbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZF9zcGFjZXMob3V0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZm9yXCI6IGZ1bmN0aW9uKGluaXQsIGNvbmQsIHN0ZXAsIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0gWyBcImZvclwiIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gKGluaXQgIT0gbnVsbCA/IG1ha2UoaW5pdCkgOiBcIlwiKS5yZXBsYWNlKC87KlxccyokLywgXCI7XCIgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25kID0gKGNvbmQgIT0gbnVsbCA/IG1ha2UoY29uZCkgOiBcIlwiKS5yZXBsYWNlKC87KlxccyokLywgXCI7XCIgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwID0gKHN0ZXAgIT0gbnVsbCA/IG1ha2Uoc3RlcCkgOiBcIlwiKS5yZXBsYWNlKC87KlxccyokLywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGluaXQgKyBjb25kICsgc3RlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzID09IFwiOyA7IFwiKSBhcmdzID0gXCI7O1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goXCIoXCIgKyBhcmdzICsgXCIpXCIsIG1ha2UoYmxvY2spKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRfc3BhY2VzKG91dCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImZvci1pblwiOiBmdW5jdGlvbih2dmFyLCBrZXksIGhhc2gsIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkX3NwYWNlcyhbIFwiZm9yXCIsIFwiKFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZ2YXIgPyBtYWtlKHZ2YXIpLnJlcGxhY2UoLzsrJC8sIFwiXCIpIDogbWFrZShrZXkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWtlKGhhc2gpICsgXCIpXCIsIG1ha2UoYmxvY2spIF0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ3aGlsZVwiOiBmdW5jdGlvbihjb25kaXRpb24sIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkX3NwYWNlcyhbIFwid2hpbGVcIiwgXCIoXCIgKyBtYWtlKGNvbmRpdGlvbikgKyBcIilcIiwgbWFrZShibG9jaykgXSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImRvXCI6IGZ1bmN0aW9uKGNvbmRpdGlvbiwgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRfc3BhY2VzKFsgXCJkb1wiLCBtYWtlKGJsb2NrKSwgXCJ3aGlsZVwiLCBcIihcIiArIG1ha2UoY29uZGl0aW9uKSArIFwiKVwiIF0pICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInJldHVyblwiOiBmdW5jdGlvbihleHByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0gWyBcInJldHVyblwiIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwciAhPSBudWxsKSBvdXQucHVzaChtYWtlKGV4cHIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRfc3BhY2VzKG91dCkgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYmluYXJ5XCI6IGZ1bmN0aW9uKG9wZXJhdG9yLCBsdmFsdWUsIHJ2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBtYWtlKGx2YWx1ZSksIHJpZ2h0ID0gbWFrZShydmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gWFhYOiBJJ20gcHJldHR5IHN1cmUgb3RoZXIgY2FzZXMgd2lsbCBiaXRlIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgIHdlIG5lZWQgdG8gYmUgc21hcnRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgYWRkaW5nIHBhcmVucyBhbGwgdGhlIHRpbWUgaXMgdGhlIHNhZmVzdCBiZXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyKGx2YWx1ZVswXSwgWyBcImFzc2lnblwiLCBcImNvbmRpdGlvbmFsXCIsIFwic2VxXCIgXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsdmFsdWVbMF0gPT0gXCJiaW5hcnlcIiAmJiBQUkVDRURFTkNFW29wZXJhdG9yXSA+IFBSRUNFREVOQ0VbbHZhbHVlWzFdXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGx2YWx1ZVswXSA9PSBcImZ1bmN0aW9uXCIgJiYgbmVlZHNfcGFyZW5zKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBcIihcIiArIGxlZnQgKyBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXIocnZhbHVlWzBdLCBbIFwiYXNzaWduXCIsIFwiY29uZGl0aW9uYWxcIiwgXCJzZXFcIiBdKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ2YWx1ZVswXSA9PSBcImJpbmFyeVwiICYmIFBSRUNFREVOQ0Vbb3BlcmF0b3JdID49IFBSRUNFREVOQ0VbcnZhbHVlWzFdXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEocnZhbHVlWzFdID09IG9wZXJhdG9yICYmIG1lbWJlcihvcGVyYXRvciwgWyBcIiYmXCIsIFwifHxcIiwgXCIqXCIgXSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gXCIoXCIgKyByaWdodCArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWJlYXV0aWZ5ICYmIG9wdGlvbnMuaW5saW5lX3NjcmlwdCAmJiAob3BlcmF0b3IgPT0gXCI8XCIgfHwgb3BlcmF0b3IgPT0gXCI8PFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgcnZhbHVlWzBdID09IFwicmVnZXhwXCIgJiYgL15zY3JpcHQvaS50ZXN0KHJ2YWx1ZVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBcIiBcIiArIHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZF9zcGFjZXMoWyBsZWZ0LCBvcGVyYXRvciwgcmlnaHQgXSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInVuYXJ5LXByZWZpeFwiOiBmdW5jdGlvbihvcGVyYXRvciwgZXhwcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IG1ha2UoZXhwcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShleHByWzBdID09IFwibnVtXCIgfHwgKGV4cHJbMF0gPT0gXCJ1bmFyeS1wcmVmaXhcIiAmJiAhSE9QKE9QRVJBVE9SUywgb3BlcmF0b3IgKyBleHByWzFdKSkgfHwgIW5lZWRzX3BhcmVucyhleHByKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IFwiKFwiICsgdmFsICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IgKyAoanNwLmlzX2FscGhhbnVtZXJpY19jaGFyKG9wZXJhdG9yLmNoYXJBdCgwKSkgPyBcIiBcIiA6IFwiXCIpICsgdmFsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ1bmFyeS1wb3N0Zml4XCI6IGZ1bmN0aW9uKG9wZXJhdG9yLCBleHByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gbWFrZShleHByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGV4cHJbMF0gPT0gXCJudW1cIiB8fCAoZXhwclswXSA9PSBcInVuYXJ5LXBvc3RmaXhcIiAmJiAhSE9QKE9QRVJBVE9SUywgb3BlcmF0b3IgKyBleHByWzFdKSkgfHwgIW5lZWRzX3BhcmVucyhleHByKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IFwiKFwiICsgdmFsICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsICsgb3BlcmF0b3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInN1YlwiOiBmdW5jdGlvbihleHByLCBzdWJzY3JpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gbWFrZShleHByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWVkc19wYXJlbnMoZXhwcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2ggPSBcIihcIiArIGhhc2ggKyBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNoICsgXCJbXCIgKyBtYWtlKHN1YnNjcmlwdCkgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCI6IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqX25lZWRzX3BhcmVucyA9IG5lZWRzX3BhcmVucyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ial9uZWVkc19wYXJlbnMgPyBcIih7fSlcIiA6IFwie31cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXQgPSBcIntcIiArIG5ld2xpbmUgKyB3aXRoX2luZGVudChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTUFQKHByb3BzLCBmdW5jdGlvbihwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0dGVyL3NldHRlci4gIFRoZSBuYW1lIGlzIGluIHBbMF0sIHRoZSBhcmcubGlzdCBpbiBwWzFdWzJdLCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvZHkgaW4gcFsxXVszXSBhbmQgdHlwZSAoXCJnZXRcIiAvIFwic2V0XCIpIGluIHBbMl0uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZW50KG1ha2VfZnVuY3Rpb24ocFswXSwgcFsxXVsyXSwgcFsxXVszXSwgcFsyXSwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gcFswXSwgdmFsID0gcGFyZW50aGVzaXplKHBbMV0sIFwic2VxXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnF1b3RlX2tleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGVuY29kZV9zdHJpbmcoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2Yga2V5ID09IFwibnVtYmVyXCIgfHwgIWJlYXV0aWZ5ICYmICtrZXkgKyBcIlwiID09IGtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHBhcnNlRmxvYXQoa2V5KSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBtYWtlX251bSgra2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpc19pZGVudGlmaWVyKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGVuY29kZV9zdHJpbmcoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGVudChhZGRfc3BhY2VzKGJlYXV0aWZ5ICYmIG9wdGlvbnMuc3BhY2VfY29sb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbIGtleSwgXCI6XCIsIHZhbCBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogWyBrZXkgKyBcIjpcIiwgdmFsIF0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbihcIixcIiArIG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkgKyBuZXdsaW5lICsgaW5kZW50KFwifVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmpfbmVlZHNfcGFyZW5zID8gXCIoXCIgKyBvdXQgKyBcIilcIiA6IG91dDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwicmVnZXhwXCI6IGZ1bmN0aW9uKHJ4LCBtb2RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hc2NpaV9vbmx5KSByeCA9IHRvX2FzY2lpKHJ4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIi9cIiArIHJ4ICsgXCIvXCIgKyBtb2RzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhcnJheVwiOiBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PSAwKSByZXR1cm4gXCJbXVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZF9zcGFjZXMoWyBcIltcIiwgYWRkX2NvbW1hcyhNQVAoZWxlbWVudHMsIGZ1bmN0aW9uKGVsLCBpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiZWF1dGlmeSAmJiBlbFswXSA9PSBcImF0b21cIiAmJiBlbFsxXSA9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gaSA9PT0gZWxlbWVudHMubGVuZ3RoIC0gMSA/IFwiLFwiIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShlbCwgXCJzZXFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSksIFwiXVwiIF0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJzdGF0XCI6IGZ1bmN0aW9uKHN0bXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG10ICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBtYWtlKHN0bXQpLnJlcGxhY2UoLzsqXFxzKiQvLCBcIjtcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjtcIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwic2VxXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZF9jb21tYXMoTUFQKHNsaWNlKGFyZ3VtZW50cyksIG1ha2UpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwibGFiZWxcIjogZnVuY3Rpb24obmFtZSwgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRfc3BhY2VzKFsgbWFrZV9uYW1lKG5hbWUpLCBcIjpcIiwgbWFrZShibG9jaykgXSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIndpdGhcIjogZnVuY3Rpb24oZXhwciwgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRfc3BhY2VzKFsgXCJ3aXRoXCIsIFwiKFwiICsgbWFrZShleHByKSArIFwiKVwiLCBtYWtlKGJsb2NrKSBdKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYXRvbVwiOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9uYW1lKG5hbWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJkaXJlY3RpdmVcIjogZnVuY3Rpb24oZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9zdHJpbmcoZGlyKSArIFwiO1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24oKXsgcmV0dXJuIG1ha2UoYXN0KSB9KTtcblxuICAgICAgICAvLyBUaGUgc3F1ZWV6ZXIgcmVwbGFjZXMgXCJibG9ja1wiLXMgdGhhdCBjb250YWluIG9ubHkgYSBzaW5nbGVcbiAgICAgICAgLy8gc3RhdGVtZW50IHdpdGggdGhlIHN0YXRlbWVudCBpdHNlbGY7IHRlY2huaWNhbGx5LCB0aGUgQVNUXG4gICAgICAgIC8vIGlzIGNvcnJlY3QsIGJ1dCB0aGlzIGNhbiBjcmVhdGUgcHJvYmxlbXMgd2hlbiB3ZSBvdXRwdXQgYW5cbiAgICAgICAgLy8gSUYgaGF2aW5nIGFuIEVMU0UgY2xhdXNlIHdoZXJlIHRoZSBUSEVOIGNsYXVzZSBlbmRzIGluIGFuXG4gICAgICAgIC8vIElGICp3aXRob3V0KiBhbiBFTFNFIGJsb2NrICh0aGVuIHRoZSBvdXRlciBFTFNFIHdvdWxkIHJlZmVyXG4gICAgICAgIC8vIHRvIHRoZSBpbm5lciBJRikuICBUaGlzIGZ1bmN0aW9uIGNoZWNrcyBmb3IgdGhpcyBjYXNlIGFuZFxuICAgICAgICAvLyBhZGRzIHRoZSBibG9jayBicmFja2V0cyBpZiBuZWVkZWQuXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VfdGhlbih0aCkge1xuICAgICAgICAgICAgICAgIGlmICh0aCA9PSBudWxsKSByZXR1cm4gXCI7XCI7XG4gICAgICAgICAgICAgICAgaWYgKHRoWzBdID09IFwiZG9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUy9pc3N1ZXMvI2lzc3VlLzU3XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJRSBjcm9ha3Mgd2l0aCBcInN5bnRheCBlcnJvclwiIG9uIGNvZGUgbGlrZSB0aGlzOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGlmIChmb28pIGRvIC4uLiB3aGlsZShjb25kKTsgZWxzZSAuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgYmxvY2sgYnJhY2tldHMgYXJvdW5kIGRvL3doaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ibG9jayhbIHRoIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYiA9IHRoO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGJbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBcImlmXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiWzNdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIGVsc2UsIHdlIG11c3QgYWRkIHRoZSBibG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlKFsgXCJibG9ja1wiLCBbIHRoIF1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGJbM107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IFwid2hpbGVcIiB8fCB0eXBlID09IFwiZG9cIikgYiA9IGJbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IFwiZm9yXCIgfHwgdHlwZSA9PSBcImZvci1pblwiKSBiID0gYls0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlKHRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBtYWtlX2Z1bmN0aW9uKG5hbWUsIGFyZ3MsIGJvZHksIGtleXdvcmQsIG5vX3BhcmVucykge1xuICAgICAgICAgICAgICAgIHZhciBvdXQgPSBrZXl3b3JkIHx8IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiIFwiICsgbWFrZV9uYW1lKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQgKz0gXCIoXCIgKyBhZGRfY29tbWFzKE1BUChhcmdzLCBtYWtlX25hbWUpKSArIFwiKVwiO1xuICAgICAgICAgICAgICAgIG91dCA9IGFkZF9zcGFjZXMoWyBvdXQsIG1ha2VfYmxvY2soYm9keSkgXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICghbm9fcGFyZW5zICYmIG5lZWRzX3BhcmVucyh0aGlzKSkgPyBcIihcIiArIG91dCArIFwiKVwiIDogb3V0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG11c3RfaGFzX3NlbWljb2xvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChub2RlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ3aXRoXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ3aGlsZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5KG5vZGVbMl0pIHx8IG11c3RfaGFzX3NlbWljb2xvbihub2RlWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZvclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZm9yLWluXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHkobm9kZVs0XSkgfHwgbXVzdF9oYXNfc2VtaWNvbG9uKG5vZGVbNF0pO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaWZcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbXB0eShub2RlWzJdKSAmJiAhbm9kZVszXSkgcmV0dXJuIHRydWU7IC8vIGBpZicgd2l0aCBlbXB0eSBgdGhlbicgYW5kIG5vIGBlbHNlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVbM10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVtcHR5KG5vZGVbM10pKSByZXR1cm4gdHJ1ZTsgLy8gYGVsc2UnIHByZXNlbnQgYnV0IGVtcHR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtdXN0X2hhc19zZW1pY29sb24obm9kZVszXSk7IC8vIGRpdmUgaW50byB0aGUgYGVsc2UnIGJyYW5jaFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG11c3RfaGFzX3NlbWljb2xvbihub2RlWzJdKTsgLy8gZGl2ZSBpbnRvIHRoZSBgdGhlbicgYnJhbmNoXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkaXJlY3RpdmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBtYWtlX2Jsb2NrX3N0YXRlbWVudHMoc3RhdGVtZW50cywgbm9pbmRlbnQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gW10sIGxhc3QgPSBzdGF0ZW1lbnRzLmxlbmd0aCAtIDEsIGkgPSAwOyBpIDw9IGxhc3Q7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXQgPSBzdGF0ZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBtYWtlKHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT0gXCI7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiZWF1dGlmeSAmJiBpID09IGxhc3QgJiYgIW11c3RfaGFzX3NlbWljb2xvbihzdGF0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UoLzsrXFxzKiQvLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goY29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2luZGVudCA/IGEgOiBNQVAoYSwgaW5kZW50KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBtYWtlX3N3aXRjaF9ibG9jayhib2R5KSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBib2R5Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobiA9PSAwKSByZXR1cm4gXCJ7fVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIntcIiArIG5ld2xpbmUgKyBNQVAoYm9keSwgZnVuY3Rpb24oYnJhbmNoLCBpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNfYm9keSA9IGJyYW5jaFsxXS5sZW5ndGggPiAwLCBjb2RlID0gd2l0aF9pbmRlbnQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGVudChicmFuY2hbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGFkZF9zcGFjZXMoWyBcImNhc2VcIiwgbWFrZShicmFuY2hbMF0pICsgXCI6XCIgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiZGVmYXVsdDpcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwLjUpICsgKGhhc19ib2R5ID8gbmV3bGluZSArIHdpdGhfaW5kZW50KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX2Jsb2NrX3N0YXRlbWVudHMoYnJhbmNoWzFdKS5qb2luKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmVhdXRpZnkgJiYgaGFzX2JvZHkgJiYgaSA8IG4gLSAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlICs9IFwiO1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICAgICAgICAgICAgfSkuam9pbihuZXdsaW5lKSArIG5ld2xpbmUgKyBpbmRlbnQoXCJ9XCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VfYmxvY2soc3RhdGVtZW50cykge1xuICAgICAgICAgICAgICAgIGlmICghc3RhdGVtZW50cykgcmV0dXJuIFwiO1wiO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZW1lbnRzLmxlbmd0aCA9PSAwKSByZXR1cm4gXCJ7fVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIntcIiArIG5ld2xpbmUgKyB3aXRoX2luZGVudChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VfYmxvY2tfc3RhdGVtZW50cyhzdGF0ZW1lbnRzKS5qb2luKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgIH0pICsgbmV3bGluZSArIGluZGVudChcIn1cIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZV8xdmFyZGVmKGRlZikge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZGVmWzBdLCB2YWwgPSBkZWZbMV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGFkZF9zcGFjZXMoWyBtYWtlX25hbWUobmFtZSksIFwiPVwiLCBwYXJlbnRoZXNpemUodmFsLCBcInNlcVwiKSBdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfTtcblxufTtcblxuZnVuY3Rpb24gc3BsaXRfbGluZXMoY29kZSwgbWF4X2xpbmVfbGVuZ3RoKSB7XG4gICAgICAgIHZhciBzcGxpdHMgPSBbIDAgXTtcbiAgICAgICAganNwLnBhcnNlKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRfdG9rZW4gPSBqc3AudG9rZW5pemVyKGNvZGUpO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0X3NwbGl0ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgcHJldl90b2tlbjtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjdXJyZW50X2xlbmd0aCh0b2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2sucG9zIC0gbGFzdF9zcGxpdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNwbGl0X2hlcmUodG9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0X3NwbGl0ID0gdG9rLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0cy5wdXNoKGxhc3Rfc3BsaXQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY3VzdG9tKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9rID0gbmV4dF90b2tlbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2X3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZfdG9rZW4udHlwZSA9PSBcImtleXdvcmRcIikgYnJlYWsgb3V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50X2xlbmd0aCh0b2spID4gbWF4X2xpbmVfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0b2sudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwia2V5d29yZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXRvbVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicHVuY1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRfaGVyZSh0b2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldl90b2tlbiA9IHRvaztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2s7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjdXN0b20uY29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRfdG9rZW4uY29udGV4dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbTtcbiAgICAgICAgfSgpKTtcbiAgICAgICAgcmV0dXJuIHNwbGl0cy5tYXAoZnVuY3Rpb24ocG9zLCBpKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZS5zdWJzdHJpbmcocG9zLCBzcGxpdHNbaSArIDFdIHx8IGNvZGUubGVuZ3RoKTtcbiAgICAgICAgfSkuam9pbihcIlxcblwiKTtcbn07XG5cbi8qIC0tLS0tWyBVdGlsaXRpZXMgXS0tLS0tICovXG5cbmZ1bmN0aW9uIHJlcGVhdF9zdHJpbmcoc3RyLCBpKSB7XG4gICAgICAgIGlmIChpIDw9IDApIHJldHVybiBcIlwiO1xuICAgICAgICBpZiAoaSA9PSAxKSByZXR1cm4gc3RyO1xuICAgICAgICB2YXIgZCA9IHJlcGVhdF9zdHJpbmcoc3RyLCBpID4+IDEpO1xuICAgICAgICBkICs9IGQ7XG4gICAgICAgIGlmIChpICYgMSkgZCArPSBzdHI7XG4gICAgICAgIHJldHVybiBkO1xufTtcblxuZnVuY3Rpb24gZGVmYXVsdHMoYXJncywgZGVmcykge1xuICAgICAgICB2YXIgcmV0ID0ge307XG4gICAgICAgIGlmIChhcmdzID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIGFyZ3MgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBkZWZzKSBpZiAoSE9QKGRlZnMsIGkpKSB7XG4gICAgICAgICAgICAgICAgcmV0W2ldID0gKGFyZ3MgJiYgSE9QKGFyZ3MsIGkpKSA/IGFyZ3NbaV0gOiBkZWZzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBpc19pZGVudGlmaWVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIC9eW2Etel8kXVthLXowLTlfJF0qJC9pLnRlc3QobmFtZSlcbiAgICAgICAgICAgICAgICAmJiBuYW1lICE9IFwidGhpc1wiXG4gICAgICAgICAgICAgICAgJiYgIUhPUChqc3AuS0VZV09SRFNfQVRPTSwgbmFtZSlcbiAgICAgICAgICAgICAgICAmJiAhSE9QKGpzcC5SRVNFUlZFRF9XT1JEUywgbmFtZSlcbiAgICAgICAgICAgICAgICAmJiAhSE9QKGpzcC5LRVlXT1JEUywgbmFtZSk7XG59O1xuXG5mdW5jdGlvbiBIT1Aob2JqLCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn07XG5cbi8vIHNvbWUgdXRpbGl0aWVzXG5cbnZhciBNQVA7XG5cbihmdW5jdGlvbigpe1xuICAgICAgICBNQVAgPSBmdW5jdGlvbihhLCBmLCBvKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IFtdLCB0b3AgPSBbXSwgaTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb2l0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGYuY2FsbChvLCBhW2ldLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBdFRvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWwudjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFNwbGljZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5wdXNoLmFwcGx5KHRvcCwgdmFsLnYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbCAhPSBza2lwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBTcGxpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaC5hcHBseShyZXQsIHZhbC52KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIEFycmF5KSBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkgZG9pdCgpO1xuICAgICAgICAgICAgICAgIGVsc2UgZm9yIChpIGluIGEpIGlmIChIT1AoYSwgaSkpIGRvaXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9wLmNvbmNhdChyZXQpO1xuICAgICAgICB9O1xuICAgICAgICBNQVAuYXRfdG9wID0gZnVuY3Rpb24odmFsKSB7IHJldHVybiBuZXcgQXRUb3AodmFsKSB9O1xuICAgICAgICBNQVAuc3BsaWNlID0gZnVuY3Rpb24odmFsKSB7IHJldHVybiBuZXcgU3BsaWNlKHZhbCkgfTtcbiAgICAgICAgdmFyIHNraXAgPSBNQVAuc2tpcCA9IHt9O1xuICAgICAgICBmdW5jdGlvbiBBdFRvcCh2YWwpIHsgdGhpcy52ID0gdmFsIH07XG4gICAgICAgIGZ1bmN0aW9uIFNwbGljZSh2YWwpIHsgdGhpcy52ID0gdmFsIH07XG59KSgpO1xuXG4vKiAtLS0tLVsgRXhwb3J0cyBdLS0tLS0gKi9cblxuZXhwb3J0cy5hc3Rfd2Fsa2VyID0gYXN0X3dhbGtlcjtcbmV4cG9ydHMuYXN0X21hbmdsZSA9IGFzdF9tYW5nbGU7XG5leHBvcnRzLmFzdF9zcXVlZXplID0gYXN0X3NxdWVlemU7XG5leHBvcnRzLmFzdF9saWZ0X3ZhcmlhYmxlcyA9IGFzdF9saWZ0X3ZhcmlhYmxlcztcbmV4cG9ydHMuZ2VuX2NvZGUgPSBnZW5fY29kZTtcbmV4cG9ydHMuYXN0X2FkZF9zY29wZSA9IGFzdF9hZGRfc2NvcGU7XG5leHBvcnRzLnNldF9sb2dnZXIgPSBmdW5jdGlvbihsb2dnZXIpIHsgd2FybiA9IGxvZ2dlciB9O1xuZXhwb3J0cy5tYWtlX3N0cmluZyA9IG1ha2Vfc3RyaW5nO1xuZXhwb3J0cy5zcGxpdF9saW5lcyA9IHNwbGl0X2xpbmVzO1xuZXhwb3J0cy5NQVAgPSBNQVA7XG5cbi8vIGtlZXAgdGhpcyBsYXN0IVxuZXhwb3J0cy5hc3Rfc3F1ZWV6ZV9tb3JlID0gcmVxdWlyZShcIi4vc3F1ZWV6ZS1tb3JlXCIpLmFzdF9zcXVlZXplX21vcmU7XG5cbi8vIExvY2FsIHZhcmlhYmxlczpcbi8vIGpzLWluZGVudC1sZXZlbDogOFxuLy8gRW5kOlxuIiwidmFyIGpzcCA9IHJlcXVpcmUoXCIuL3BhcnNlLWpzXCIpLFxuICAgIHBybyA9IHJlcXVpcmUoXCIuL3Byb2Nlc3NcIiksXG4gICAgc2xpY2UgPSBqc3Auc2xpY2UsXG4gICAgbWVtYmVyID0ganNwLm1lbWJlcixcbiAgICBjdXJyeSA9IGpzcC5jdXJyeSxcbiAgICBNQVAgPSBwcm8uTUFQLFxuICAgIFBSRUNFREVOQ0UgPSBqc3AuUFJFQ0VERU5DRSxcbiAgICBPUEVSQVRPUlMgPSBqc3AuT1BFUkFUT1JTO1xuXG5mdW5jdGlvbiBhc3Rfc3F1ZWV6ZV9tb3JlKGFzdCkge1xuICAgICAgICB2YXIgdyA9IHByby5hc3Rfd2Fsa2VyKCksIHdhbGsgPSB3LndhbGssIHNjb3BlO1xuICAgICAgICBmdW5jdGlvbiB3aXRoX3Njb3BlKHMsIGNvbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2F2ZSA9IHNjb3BlLCByZXQ7XG4gICAgICAgICAgICAgICAgc2NvcGUgPSBzO1xuICAgICAgICAgICAgICAgIHJldCA9IGNvbnQoKTtcbiAgICAgICAgICAgICAgICBzY29wZSA9IHNhdmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gX2xhbWJkYShuYW1lLCBhcmdzLCBib2R5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgbmFtZSwgYXJncywgd2l0aF9zY29wZShib2R5LnNjb3BlLCBjdXJyeShNQVAsIGJvZHksIHdhbGspKSBdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdy53aXRoX3dhbGtlcnMoe1xuICAgICAgICAgICAgICAgIFwidG9wbGV2ZWxcIjogZnVuY3Rpb24oYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgd2l0aF9zY29wZSh0aGlzLnNjb3BlLCBjdXJyeShNQVAsIGJvZHksIHdhbGspKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiOiBfbGFtYmRhLFxuICAgICAgICAgICAgICAgIFwiZGVmdW5cIjogX2xhbWJkYSxcbiAgICAgICAgICAgICAgICBcIm5ld1wiOiBmdW5jdGlvbihjdG9yLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RvclswXSA9PSBcIm5hbWVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RvclsxXSA9PSBcIkFycmF5XCIgJiYgIXNjb3BlLmhhcyhcIkFycmF5XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIFwiYXJyYXlcIiwgYXJncyBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2FsayhbIFwiY2FsbFwiLCBbIFwibmFtZVwiLCBcIkFycmF5XCIgXSwgYXJncyBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3RvclsxXSA9PSBcIk9iamVjdFwiICYmICFzY29wZS5oYXMoXCJPYmplY3RcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBcIm9iamVjdFwiLCBbXSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2FsayhbIFwiY2FsbFwiLCBbIFwibmFtZVwiLCBcIk9iamVjdFwiIF0sIGFyZ3MgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChjdG9yWzFdID09IFwiUmVnRXhwXCIgfHwgY3RvclsxXSA9PSBcIkZ1bmN0aW9uXCIgfHwgY3RvclsxXSA9PSBcIkVycm9yXCIpICYmICFzY29wZS5oYXMoY3RvclsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2FsayhbIFwiY2FsbFwiLCBbIFwibmFtZVwiLCBjdG9yWzFdIF0sIGFyZ3NdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJjYWxsXCI6IGZ1bmN0aW9uKGV4cHIsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByWzBdID09IFwiZG90XCIgJiYgZXhwclsxXVswXSA9PSBcInN0cmluZ1wiICYmIGFyZ3MubGVuZ3RoID09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoYXJnc1swXVsxXSA+IDAgJiYgZXhwclsyXSA9PSBcInN1YnN0cmluZ1wiIHx8IGV4cHJbMl0gPT0gXCJzdWJzdHJcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgXCJjYWxsXCIsIFsgXCJkb3RcIiwgZXhwclsxXSwgXCJzbGljZVwiXSwgYXJnc107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwclswXSA9PSBcImRvdFwiICYmIGV4cHJbMl0gPT0gXCJ0b1N0cmluZ1wiICYmIGFyZ3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9vLnRvU3RyaW5nKCkgID09PiAgZm9vK1wiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJbMV1bMF0gPT0gXCJzdHJpbmdcIikgcmV0dXJuIGV4cHJbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIFwiYmluYXJ5XCIsIFwiK1wiLCBleHByWzFdLCBbIFwic3RyaW5nXCIsIFwiXCIgXV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwclswXSA9PSBcIm5hbWVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwclsxXSA9PSBcIkFycmF5XCIgJiYgYXJncy5sZW5ndGggIT0gMSAmJiAhc2NvcGUuaGFzKFwiQXJyYXlcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBcImFycmF5XCIsIGFyZ3MgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwclsxXSA9PSBcIk9iamVjdFwiICYmICFhcmdzLmxlbmd0aCAmJiAhc2NvcGUuaGFzKFwiT2JqZWN0XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgXCJvYmplY3RcIiwgW10gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwclsxXSA9PSBcIlN0cmluZ1wiICYmICFzY29wZS5oYXMoXCJTdHJpbmdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBcImJpbmFyeVwiLCBcIitcIiwgYXJnc1swXSwgWyBcInN0cmluZ1wiLCBcIlwiIF1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2Fsayhwcm8uYXN0X2FkZF9zY29wZShhc3QpKTtcbiAgICAgICAgfSk7XG59O1xuXG5leHBvcnRzLmFzdF9zcXVlZXplX21vcmUgPSBhc3Rfc3F1ZWV6ZV9tb3JlO1xuXG4vLyBMb2NhbCB2YXJpYWJsZXM6XG4vLyBqcy1pbmRlbnQtbGV2ZWw6IDhcbi8vIEVuZDpcbiIsIi8vY29udmllbmVuY2UgZnVuY3Rpb24oc3JjLCBbb3B0aW9uc10pO1xuZnVuY3Rpb24gdWdsaWZ5KG9yaWdfY29kZSwgb3B0aW9ucyl7XG4gIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gIHZhciBqc3AgPSB1Z2xpZnkucGFyc2VyO1xuICB2YXIgcHJvID0gdWdsaWZ5LnVnbGlmeTtcblxuICB2YXIgYXN0ID0ganNwLnBhcnNlKG9yaWdfY29kZSwgb3B0aW9ucy5zdHJpY3Rfc2VtaWNvbG9ucyk7IC8vIHBhcnNlIGNvZGUgYW5kIGdldCB0aGUgaW5pdGlhbCBBU1RcbiAgYXN0ID0gcHJvLmFzdF9tYW5nbGUoYXN0LCBvcHRpb25zLm1hbmdsZV9vcHRpb25zKTsgLy8gZ2V0IGEgbmV3IEFTVCB3aXRoIG1hbmdsZWQgbmFtZXNcbiAgYXN0ID0gcHJvLmFzdF9zcXVlZXplKGFzdCwgb3B0aW9ucy5zcXVlZXplX29wdGlvbnMpOyAvLyBnZXQgYW4gQVNUIHdpdGggY29tcHJlc3Npb24gb3B0aW1pemF0aW9uc1xuICB2YXIgZmluYWxfY29kZSA9IHByby5nZW5fY29kZShhc3QsIG9wdGlvbnMuZ2VuX29wdGlvbnMpOyAvLyBjb21wcmVzc2VkIGNvZGUgaGVyZVxuICByZXR1cm4gZmluYWxfY29kZTtcbn07XG5cbnVnbGlmeS5wYXJzZXIgPSByZXF1aXJlKFwiLi9saWIvcGFyc2UtanNcIik7XG51Z2xpZnkudWdsaWZ5ID0gcmVxdWlyZShcIi4vbGliL3Byb2Nlc3NcIik7XG51Z2xpZnkuY29uc29saWRhdG9yID0gcmVxdWlyZShcIi4vbGliL2NvbnNvbGlkYXRvclwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1Z2xpZnlcbiIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuMy4zXG4vLyAgICAgKGMpIDIwMDktMjAxMiBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgSW5jLlxuLy8gICAgIFVuZGVyc2NvcmUgaXMgZnJlZWx5IGRpc3RyaWJ1dGFibGUgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLy8gICAgIFBvcnRpb25zIG9mIFVuZGVyc2NvcmUgYXJlIGluc3BpcmVkIG9yIGJvcnJvd2VkIGZyb20gUHJvdG90eXBlLFxuLy8gICAgIE9saXZlciBTdGVlbGUncyBGdW5jdGlvbmFsLCBhbmQgSm9obiBSZXNpZydzIE1pY3JvLVRlbXBsYXRpbmcuXG4vLyAgICAgRm9yIGFsbCBkZXRhaWxzIGFuZCBkb2N1bWVudGF0aW9uOlxuLy8gICAgIGh0dHA6Ly9kb2N1bWVudGNsb3VkLmdpdGh1Yi5jb20vdW5kZXJzY29yZVxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLy8gQmFzZWxpbmUgc2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCBpbiB0aGUgYnJvd3Nlciwgb3IgYGdsb2JhbGAgb24gdGhlIHNlcnZlci5cbiAgdmFyIHJvb3QgPSB0aGlzO1xuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgX2AgdmFyaWFibGUuXG4gIHZhciBwcmV2aW91c1VuZGVyc2NvcmUgPSByb290Ll87XG5cbiAgLy8gRXN0YWJsaXNoIHRoZSBvYmplY3QgdGhhdCBnZXRzIHJldHVybmVkIHRvIGJyZWFrIG91dCBvZiBhIGxvb3AgaXRlcmF0aW9uLlxuICB2YXIgYnJlYWtlciA9IHt9O1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbiAgdmFyIHNsaWNlICAgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgICAgdW5zaGlmdCAgICAgICAgICA9IEFycmF5UHJvdG8udW5zaGlmdCxcbiAgICAgIHRvU3RyaW5nICAgICAgICAgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUZvckVhY2ggICAgICA9IEFycmF5UHJvdG8uZm9yRWFjaCxcbiAgICBuYXRpdmVNYXAgICAgICAgICAgPSBBcnJheVByb3RvLm1hcCxcbiAgICBuYXRpdmVSZWR1Y2UgICAgICAgPSBBcnJheVByb3RvLnJlZHVjZSxcbiAgICBuYXRpdmVSZWR1Y2VSaWdodCAgPSBBcnJheVByb3RvLnJlZHVjZVJpZ2h0LFxuICAgIG5hdGl2ZUZpbHRlciAgICAgICA9IEFycmF5UHJvdG8uZmlsdGVyLFxuICAgIG5hdGl2ZUV2ZXJ5ICAgICAgICA9IEFycmF5UHJvdG8uZXZlcnksXG4gICAgbmF0aXZlU29tZSAgICAgICAgID0gQXJyYXlQcm90by5zb21lLFxuICAgIG5hdGl2ZUluZGV4T2YgICAgICA9IEFycmF5UHJvdG8uaW5kZXhPZixcbiAgICBuYXRpdmVMYXN0SW5kZXhPZiAgPSBBcnJheVByb3RvLmxhc3RJbmRleE9mLFxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQ7XG5cbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG4gIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7IHJldHVybiBuZXcgd3JhcHBlcihvYmopOyB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cbiAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0IHZpYSBhIHN0cmluZyBpZGVudGlmaWVyLFxuICAvLyBmb3IgQ2xvc3VyZSBDb21waWxlciBcImFkdmFuY2VkXCIgbW9kZS5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290WydfJ10gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS4zLjMnO1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgb2JqZWN0cyB3aXRoIHRoZSBidWlsdC1pbiBgZm9yRWFjaGAsIGFycmF5cywgYW5kIHJhdyBvYmplY3RzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgZm9yRWFjaGAgaWYgYXZhaWxhYmxlLlxuICB2YXIgZWFjaCA9IF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybjtcbiAgICBpZiAobmF0aXZlRm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoaSBpbiBvYmogJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGJyZWFrZXIpIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoXy5oYXMob2JqLCBrZXkpKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKSA9PT0gYnJlYWtlcikgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0b3IgdG8gZWFjaCBlbGVtZW50LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgbWFwYCBpZiBhdmFpbGFibGUuXG4gIF8ubWFwID0gXy5jb2xsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0cztcbiAgICBpZiAobmF0aXZlTWFwICYmIG9iai5tYXAgPT09IG5hdGl2ZU1hcCkgcmV0dXJuIG9iai5tYXAoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGhdID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgIH0pO1xuICAgIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkgcmVzdWx0cy5sZW5ndGggPSBvYmoubGVuZ3RoO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vICoqUmVkdWNlKiogYnVpbGRzIHVwIGEgc2luZ2xlIHJlc3VsdCBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMsIGFrYSBgaW5qZWN0YCxcbiAgLy8gb3IgYGZvbGRsYC4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHJlZHVjZWAgaWYgYXZhaWxhYmxlLlxuICBfLnJlZHVjZSA9IF8uZm9sZGwgPSBfLmluamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIG1lbW8sIGNvbnRleHQpIHtcbiAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIGlmIChvYmogPT0gbnVsbCkgb2JqID0gW107XG4gICAgaWYgKG5hdGl2ZVJlZHVjZSAmJiBvYmoucmVkdWNlID09PSBuYXRpdmVSZWR1Y2UpIHtcbiAgICAgIGlmIChjb250ZXh0KSBpdGVyYXRvciA9IF8uYmluZChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgICByZXR1cm4gaW5pdGlhbCA/IG9iai5yZWR1Y2UoaXRlcmF0b3IsIG1lbW8pIDogb2JqLnJlZHVjZShpdGVyYXRvcik7XG4gICAgfVxuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmICghaW5pdGlhbCkge1xuICAgICAgICBtZW1vID0gdmFsdWU7XG4gICAgICAgIGluaXRpYWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVtbyA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgbWVtbywgdmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWluaXRpYWwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICByZXR1cm4gbWVtbztcbiAgfTtcblxuICAvLyBUaGUgcmlnaHQtYXNzb2NpYXRpdmUgdmVyc2lvbiBvZiByZWR1Y2UsIGFsc28ga25vd24gYXMgYGZvbGRyYC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHJlZHVjZVJpZ2h0YCBpZiBhdmFpbGFibGUuXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgbWVtbywgY29udGV4dCkge1xuICAgIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgaWYgKG9iaiA9PSBudWxsKSBvYmogPSBbXTtcbiAgICBpZiAobmF0aXZlUmVkdWNlUmlnaHQgJiYgb2JqLnJlZHVjZVJpZ2h0ID09PSBuYXRpdmVSZWR1Y2VSaWdodCkge1xuICAgICAgaWYgKGNvbnRleHQpIGl0ZXJhdG9yID0gXy5iaW5kKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBpbml0aWFsID8gb2JqLnJlZHVjZVJpZ2h0KGl0ZXJhdG9yLCBtZW1vKSA6IG9iai5yZWR1Y2VSaWdodChpdGVyYXRvcik7XG4gICAgfVxuICAgIHZhciByZXZlcnNlZCA9IF8udG9BcnJheShvYmopLnJldmVyc2UoKTtcbiAgICBpZiAoY29udGV4dCAmJiAhaW5pdGlhbCkgaXRlcmF0b3IgPSBfLmJpbmQoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIHJldHVybiBpbml0aWFsID8gXy5yZWR1Y2UocmV2ZXJzZWQsIGl0ZXJhdG9yLCBtZW1vLCBjb250ZXh0KSA6IF8ucmVkdWNlKHJldmVyc2VkLCBpdGVyYXRvcik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGFueShvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkge1xuICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgYSB0cnV0aCB0ZXN0LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgZmlsdGVyYCBpZiBhdmFpbGFibGUuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHRzO1xuICAgIGlmIChuYXRpdmVGaWx0ZXIgJiYgb2JqLmZpbHRlciA9PT0gbmF0aXZlRmlsdGVyKSByZXR1cm4gb2JqLmZpbHRlcihpdGVyYXRvciwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdHM7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKCFpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGhdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBtYXRjaCBhIHRydXRoIHRlc3QuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBldmVyeWAgaWYgYXZhaWxhYmxlLlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChuYXRpdmVFdmVyeSAmJiBvYmouZXZlcnkgPT09IG5hdGl2ZUV2ZXJ5KSByZXR1cm4gb2JqLmV2ZXJ5KGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAoIShyZXN1bHQgPSByZXN1bHQgJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSkgcmV0dXJuIGJyZWFrZXI7XG4gICAgfSk7XG4gICAgcmV0dXJuICEhcmVzdWx0O1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgb2JqZWN0IG1hdGNoZXMgYSB0cnV0aCB0ZXN0LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgc29tZWAgaWYgYXZhaWxhYmxlLlxuICAvLyBBbGlhc2VkIGFzIGBhbnlgLlxuICB2YXIgYW55ID0gXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0b3IgfHwgKGl0ZXJhdG9yID0gXy5pZGVudGl0eSk7XG4gICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAobmF0aXZlU29tZSAmJiBvYmouc29tZSA9PT0gbmF0aXZlU29tZSkgcmV0dXJuIG9iai5zb21lKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAocmVzdWx0IHx8IChyZXN1bHQgPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpKSByZXR1cm4gYnJlYWtlcjtcbiAgICB9KTtcbiAgICByZXR1cm4gISFyZXN1bHQ7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgaW5jbHVkZWQgaW4gdGhlIGFycmF5IG9yIG9iamVjdCB1c2luZyBgPT09YC5cbiAgLy8gQWxpYXNlZCBhcyBgY29udGFpbnNgLlxuICBfLmluY2x1ZGUgPSBfLmNvbnRhaW5zID0gZnVuY3Rpb24ob2JqLCB0YXJnZXQpIHtcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiBmb3VuZDtcbiAgICBpZiAobmF0aXZlSW5kZXhPZiAmJiBvYmouaW5kZXhPZiA9PT0gbmF0aXZlSW5kZXhPZikgcmV0dXJuIG9iai5pbmRleE9mKHRhcmdldCkgIT0gLTE7XG4gICAgZm91bmQgPSBhbnkob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0YXJnZXQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9O1xuXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxuICBfLmludm9rZSA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiAoXy5pc0Z1bmN0aW9uKG1ldGhvZCkgPyBtZXRob2QgfHwgdmFsdWUgOiB2YWx1ZVttZXRob2RdKS5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgbWFwYDogZmV0Y2hpbmcgYSBwcm9wZXJ0eS5cbiAgXy5wbHVjayA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpeyByZXR1cm4gdmFsdWVba2V5XTsgfSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtYXhpbXVtIGVsZW1lbnQgb3IgKGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1heCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNBcnJheShvYmopICYmIG9ialswXSA9PT0gK29ialswXSkgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIG9iaik7XG4gICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzRW1wdHkob2JqKSkgcmV0dXJuIC1JbmZpbml0eTtcbiAgICB2YXIgcmVzdWx0ID0ge2NvbXB1dGVkIDogLUluZmluaXR5fTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBpdGVyYXRvciA/IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSA6IHZhbHVlO1xuICAgICAgY29tcHV0ZWQgPj0gcmVzdWx0LmNvbXB1dGVkICYmIChyZXN1bHQgPSB7dmFsdWUgOiB2YWx1ZSwgY29tcHV0ZWQgOiBjb21wdXRlZH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNBcnJheShvYmopICYmIG9ialswXSA9PT0gK29ialswXSkgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIG9iaik7XG4gICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzRW1wdHkob2JqKSkgcmV0dXJuIEluZmluaXR5O1xuICAgIHZhciByZXN1bHQgPSB7Y29tcHV0ZWQgOiBJbmZpbml0eX07XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgdmFyIGNvbXB1dGVkID0gaXRlcmF0b3IgPyBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkgOiB2YWx1ZTtcbiAgICAgIGNvbXB1dGVkIDwgcmVzdWx0LmNvbXB1dGVkICYmIChyZXN1bHQgPSB7dmFsdWUgOiB2YWx1ZSwgY29tcHV0ZWQgOiBjb21wdXRlZH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhbiBhcnJheS5cbiAgXy5zaHVmZmxlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHNodWZmbGVkID0gW10sIHJhbmQ7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmFuZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpbmRleCArIDEpKTtcbiAgICAgIHNodWZmbGVkW2luZGV4XSA9IHNodWZmbGVkW3JhbmRdO1xuICAgICAgc2h1ZmZsZWRbcmFuZF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2h1ZmZsZWQ7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdG9yLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgdmFsLCBjb250ZXh0KSB7XG4gICAgdmFyIGl0ZXJhdG9yID0gXy5pc0Z1bmN0aW9uKHZhbCkgPyB2YWwgOiBmdW5jdGlvbihvYmopIHsgcmV0dXJuIG9ialt2YWxdOyB9O1xuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSA6IHZhbHVlLFxuICAgICAgICBjcml0ZXJpYSA6IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KVxuICAgICAgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWEsIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgIGlmIChhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgaWYgKGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgIH0pLCAndmFsdWUnKTtcbiAgfTtcblxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuICBfLmdyb3VwQnkgPSBmdW5jdGlvbihvYmosIHZhbCkge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgaXRlcmF0b3IgPSBfLmlzRnVuY3Rpb24odmFsKSA/IHZhbCA6IGZ1bmN0aW9uKG9iaikgeyByZXR1cm4gb2JqW3ZhbF07IH07XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgdmFyIGtleSA9IGl0ZXJhdG9yKHZhbHVlLCBpbmRleCk7XG4gICAgICAocmVzdWx0W2tleV0gfHwgKHJlc3VsdFtrZXldID0gW10pKS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCBhdCB3aGF0IGluZGV4IGFuIG9iamVjdCBzaG91bGRcbiAgLy8gYmUgaW5zZXJ0ZWQgc28gYXMgdG8gbWFpbnRhaW4gb3JkZXIuIFVzZXMgYmluYXJ5IHNlYXJjaC5cbiAgXy5zb3J0ZWRJbmRleCA9IGZ1bmN0aW9uKGFycmF5LCBvYmosIGl0ZXJhdG9yKSB7XG4gICAgaXRlcmF0b3IgfHwgKGl0ZXJhdG9yID0gXy5pZGVudGl0eSk7XG4gICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4gMTtcbiAgICAgIGl0ZXJhdG9yKGFycmF5W21pZF0pIDwgaXRlcmF0b3Iob2JqKSA/IGxvdyA9IG1pZCArIDEgOiBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIFNhZmVseSBjb252ZXJ0IGFueXRoaW5nIGl0ZXJhYmxlIGludG8gYSByZWFsLCBsaXZlIGFycmF5LlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChfLmlzQXJndW1lbnRzKG9iaikpICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChvYmoudG9BcnJheSAmJiBfLmlzRnVuY3Rpb24ob2JqLnRvQXJyYXkpKSByZXR1cm4gb2JqLnRvQXJyYXkoKTtcbiAgICByZXR1cm4gXy52YWx1ZXMob2JqKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYmplY3QuXG4gIF8uc2l6ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5sZW5ndGggOiBfLmtleXMob2JqKS5sZW5ndGg7XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiAobiAhPSBudWxsKSAmJiAhZ3VhcmQgPyBzbGljZS5jYWxsKGFycmF5LCAwLCBuKSA6IGFycmF5WzBdO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2NpYWx5IHVzZWZ1bCBvblxuICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxuICAvLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLiBUaGUgKipndWFyZCoqIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGhcbiAgLy8gYF8ubWFwYC5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIGFycmF5Lmxlbmd0aCAtICgobiA9PSBudWxsKSB8fCBndWFyZCA/IDEgOiBuKSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGxhc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBUaGUgKipndWFyZCoqIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5sYXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKChuICE9IG51bGwpICYmICFndWFyZCkge1xuICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIE1hdGgubWF4KGFycmF5Lmxlbmd0aCAtIG4sIDApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKmluZGV4Kiogd2lsbCByZXR1cm5cbiAgLy8gdGhlIHJlc3Qgb2YgdGhlIHZhbHVlcyBpbiB0aGUgYXJyYXkgZnJvbSB0aGF0IGluZGV4IG9ud2FyZC4gVGhlICoqZ3VhcmQqKlxuICAvLyBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8ucmVzdCA9IF8udGFpbCA9IGZ1bmN0aW9uKGFycmF5LCBpbmRleCwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgKGluZGV4ID09IG51bGwpIHx8IGd1YXJkID8gMSA6IGluZGV4KTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7IHJldHVybiAhIXZhbHVlOyB9KTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb21wbGV0ZWx5IGZsYXR0ZW5lZCB2ZXJzaW9uIG9mIGFuIGFycmF5LlxuICBfLmZsYXR0ZW4gPSBmdW5jdGlvbihhcnJheSwgc2hhbGxvdykge1xuICAgIHJldHVybiBfLnJlZHVjZShhcnJheSwgZnVuY3Rpb24obWVtbywgdmFsdWUpIHtcbiAgICAgIGlmIChfLmlzQXJyYXkodmFsdWUpKSByZXR1cm4gbWVtby5jb25jYXQoc2hhbGxvdyA/IHZhbHVlIDogXy5mbGF0dGVuKHZhbHVlKSk7XG4gICAgICBtZW1vW21lbW8ubGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSwgW10pO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICBfLndpdGhvdXQgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLlxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0b3IpIHtcbiAgICB2YXIgaW5pdGlhbCA9IGl0ZXJhdG9yID8gXy5tYXAoYXJyYXksIGl0ZXJhdG9yKSA6IGFycmF5O1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgLy8gVGhlIGBpc1NvcnRlZGAgZmxhZyBpcyBpcnJlbGV2YW50IGlmIHRoZSBhcnJheSBvbmx5IGNvbnRhaW5zIHR3byBlbGVtZW50cy5cbiAgICBpZiAoYXJyYXkubGVuZ3RoIDwgMykgaXNTb3J0ZWQgPSB0cnVlO1xuICAgIF8ucmVkdWNlKGluaXRpYWwsIGZ1bmN0aW9uIChtZW1vLCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgIGlmIChpc1NvcnRlZCA/IF8ubGFzdChtZW1vKSAhPT0gdmFsdWUgfHwgIW1lbW8ubGVuZ3RoIDogIV8uaW5jbHVkZShtZW1vLCB2YWx1ZSkpIHtcbiAgICAgICAgbWVtby5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGFycmF5W2luZGV4XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW5pcShfLmZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGV2ZXJ5IGl0ZW0gc2hhcmVkIGJldHdlZW4gYWxsIHRoZVxuICAvLyBwYXNzZWQtaW4gYXJyYXlzLiAoQWxpYXNlZCBhcyBcImludGVyc2VjdFwiIGZvciBiYWNrLWNvbXBhdC4pXG4gIF8uaW50ZXJzZWN0aW9uID0gXy5pbnRlcnNlY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN0ID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBfLmZpbHRlcihfLnVuaXEoYXJyYXkpLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4gXy5ldmVyeShyZXN0LCBmdW5jdGlvbihvdGhlcikge1xuICAgICAgICByZXR1cm4gXy5pbmRleE9mKG90aGVyLCBpdGVtKSA+PSAwO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVGFrZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9uZSBhcnJheSBhbmQgYSBudW1iZXIgb2Ygb3RoZXIgYXJyYXlzLlxuICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxuICBfLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN0ID0gXy5mbGF0dGVuKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgdHJ1ZSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7IHJldHVybiAhXy5pbmNsdWRlKHJlc3QsIHZhbHVlKTsgfSk7XG4gIH07XG5cbiAgLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZVxuICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cbiAgXy56aXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgbGVuZ3RoID0gXy5tYXgoXy5wbHVjayhhcmdzLCAnbGVuZ3RoJykpO1xuICAgIHZhciByZXN1bHRzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgcmVzdWx0c1tpXSA9IF8ucGx1Y2soYXJncywgXCJcIiArIGkpO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIElmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcGx5IHVzIHdpdGggaW5kZXhPZiAoSSdtIGxvb2tpbmcgYXQgeW91LCAqKk1TSUUqKiksXG4gIC8vIHdlIG5lZWQgdGhpcyBmdW5jdGlvbi4gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhblxuICAvLyBpdGVtIGluIGFuIGFycmF5LCBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgaW5kZXhPZmAgaWYgYXZhaWxhYmxlLlxuICAvLyBJZiB0aGUgYXJyYXkgaXMgbGFyZ2UgYW5kIGFscmVhZHkgaW4gc29ydCBvcmRlciwgcGFzcyBgdHJ1ZWBcbiAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC5cbiAgXy5pbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGlzU29ydGVkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiAtMTtcbiAgICB2YXIgaSwgbDtcbiAgICBpZiAoaXNTb3J0ZWQpIHtcbiAgICAgIGkgPSBfLnNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgIHJldHVybiBhcnJheVtpXSA9PT0gaXRlbSA/IGkgOiAtMTtcbiAgICB9XG4gICAgaWYgKG5hdGl2ZUluZGV4T2YgJiYgYXJyYXkuaW5kZXhPZiA9PT0gbmF0aXZlSW5kZXhPZikgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSk7XG4gICAgZm9yIChpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykgaWYgKGkgaW4gYXJyYXkgJiYgYXJyYXlbaV0gPT09IGl0ZW0pIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgbGFzdEluZGV4T2ZgIGlmIGF2YWlsYWJsZS5cbiAgXy5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiAtMTtcbiAgICBpZiAobmF0aXZlTGFzdEluZGV4T2YgJiYgYXJyYXkubGFzdEluZGV4T2YgPT09IG5hdGl2ZUxhc3RJbmRleE9mKSByZXR1cm4gYXJyYXkubGFzdEluZGV4T2YoaXRlbSk7XG4gICAgdmFyIGkgPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgaWYgKGkgaW4gYXJyYXkgJiYgYXJyYXlbaV0gPT09IGl0ZW0pIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhbiBpbnRlZ2VyIEFycmF5IGNvbnRhaW5pbmcgYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi4gQSBwb3J0IG9mXG4gIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4gIC8vIFt0aGUgUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNyYW5nZSkuXG4gIF8ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBzdGVwID0gYXJndW1lbnRzWzJdIHx8IDE7XG5cbiAgICB2YXIgbGVuID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciBpZHggPSAwO1xuICAgIHZhciByYW5nZSA9IG5ldyBBcnJheShsZW4pO1xuXG4gICAgd2hpbGUoaWR4IDwgbGVuKSB7XG4gICAgICByYW5nZVtpZHgrK10gPSBzdGFydDtcbiAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUmV1c2FibGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHByb3RvdHlwZSBzZXR0aW5nLlxuICB2YXIgY3RvciA9IGZ1bmN0aW9uKCl7fTtcblxuICAvLyBDcmVhdGUgYSBmdW5jdGlvbiBib3VuZCB0byBhIGdpdmVuIG9iamVjdCAoYXNzaWduaW5nIGB0aGlzYCwgYW5kIGFyZ3VtZW50cyxcbiAgLy8gb3B0aW9uYWxseSkuIEJpbmRpbmcgd2l0aCBhcmd1bWVudHMgaXMgYWxzbyBrbm93biBhcyBgY3VycnlgLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWYgYXZhaWxhYmxlLlxuICAvLyBXZSBjaGVjayBmb3IgYGZ1bmMuYmluZGAgZmlyc3QsIHRvIGZhaWwgZmFzdCB3aGVuIGBmdW5jYCBpcyB1bmRlZmluZWQuXG4gIF8uYmluZCA9IGZ1bmN0aW9uIGJpbmQoZnVuYywgY29udGV4dCkge1xuICAgIHZhciBib3VuZCwgYXJncztcbiAgICBpZiAoZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kICYmIG5hdGl2ZUJpbmQpIHJldHVybiBuYXRpdmVCaW5kLmFwcGx5KGZ1bmMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkpIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgY3Rvci5wcm90b3R5cGUgPSBmdW5jLnByb3RvdHlwZTtcbiAgICAgIHZhciBzZWxmID0gbmV3IGN0b3I7XG4gICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseShzZWxmLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgfTtcblxuICAvLyBCaW5kIGFsbCBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXRcbiAgLy8gYWxsIGNhbGxiYWNrcyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBmdW5jcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBpZiAoZnVuY3MubGVuZ3RoID09IDApIGZ1bmNzID0gXy5mdW5jdGlvbnMob2JqKTtcbiAgICBlYWNoKGZ1bmNzLCBmdW5jdGlvbihmKSB7IG9ialtmXSA9IF8uYmluZChvYmpbZl0sIG9iaik7IH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cbiAgXy5tZW1vaXplID0gZnVuY3Rpb24oZnVuYywgaGFzaGVyKSB7XG4gICAgdmFyIG1lbW8gPSB7fTtcbiAgICBoYXNoZXIgfHwgKGhhc2hlciA9IF8uaWRlbnRpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrZXkgPSBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfLmhhcyhtZW1vLCBrZXkpID8gbWVtb1trZXldIDogKG1lbW9ba2V5XSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBEZWxheXMgYSBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGFuZCB0aGVuIGNhbGxzXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cbiAgXy5kZWxheSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpeyByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTsgfSwgd2FpdCk7XG4gIH07XG5cbiAgLy8gRGVmZXJzIGEgZnVuY3Rpb24sIHNjaGVkdWxpbmcgaXQgdG8gcnVuIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzXG4gIC8vIGNsZWFyZWQuXG4gIF8uZGVmZXIgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgcmV0dXJuIF8uZGVsYXkuYXBwbHkoXywgW2Z1bmMsIDFdLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHRpbWVvdXQsIHRocm90dGxpbmcsIG1vcmUsIHJlc3VsdDtcbiAgICB2YXIgd2hlbkRvbmUgPSBfLmRlYm91bmNlKGZ1bmN0aW9uKCl7IG1vcmUgPSB0aHJvdHRsaW5nID0gZmFsc2U7IH0sIHdhaXQpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzOyBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAobW9yZSkgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgd2hlbkRvbmUoKTtcbiAgICAgIH07XG4gICAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgIGlmICh0aHJvdHRsaW5nKSB7XG4gICAgICAgIG1vcmUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHdoZW5Eb25lKCk7XG4gICAgICB0aHJvdHRsaW5nID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4gIC8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcbiAgLy8gTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4gIC8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXG4gIF8uZGVib3VuY2UgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmICghaW1tZWRpYXRlKSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgfTtcbiAgICAgIGlmIChpbW1lZGlhdGUgJiYgIXRpbWVvdXQpIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciByYW4gPSBmYWxzZSwgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocmFuKSByZXR1cm4gbWVtbztcbiAgICAgIHJhbiA9IHRydWU7XG4gICAgICByZXR1cm4gbWVtbyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxuICAvLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4gIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IFtmdW5jXS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgICAgIHJldHVybiB3cmFwcGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgZm9yICh2YXIgaSA9IGZ1bmNzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGFyZ3MgPSBbZnVuY3NbaV0uYXBwbHkodGhpcywgYXJncyldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgYWZ0ZXIgYmVpbmcgY2FsbGVkIE4gdGltZXMuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIGlmICh0aW1lcyA8PSAwKSByZXR1cm4gZnVuYygpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkgeyByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSZXRyaWV2ZSB0aGUgbmFtZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBuYXRpdmVLZXlzIHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogIT09IE9iamVjdChvYmopKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG9iamVjdCcpO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5c1trZXlzLmxlbmd0aF0gPSBrZXk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICBfLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLm1hcChvYmosIF8uaWRlbnRpdHkpO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGVhY2goc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBlYWNoKF8uZmxhdHRlbihzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGlmIChrZXkgaW4gb2JqKSByZXN1bHRba2V5XSA9IG9ialtrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGVhY2goc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChvYmpbcHJvcF0gPT0gbnVsbCkgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uLlxuICBmdW5jdGlvbiBlcShhLCBiLCBzdGFjaykge1xuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgICAvLyBTZWUgdGhlIEhhcm1vbnkgYGVnYWxgIHByb3Bvc2FsOiBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09IDEgLyBiO1xuICAgIC8vIEEgc3RyaWN0IGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYG51bGwgPT0gdW5kZWZpbmVkYC5cbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGEgPT09IGI7XG4gICAgLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXG4gICAgaWYgKGEuX2NoYWluKSBhID0gYS5fd3JhcHBlZDtcbiAgICBpZiAoYi5fY2hhaW4pIGIgPSBiLl93cmFwcGVkO1xuICAgIC8vIEludm9rZSBhIGN1c3RvbSBgaXNFcXVhbGAgbWV0aG9kIGlmIG9uZSBpcyBwcm92aWRlZC5cbiAgICBpZiAoYS5pc0VxdWFsICYmIF8uaXNGdW5jdGlvbihhLmlzRXF1YWwpKSByZXR1cm4gYS5pc0VxdWFsKGIpO1xuICAgIGlmIChiLmlzRXF1YWwgJiYgXy5pc0Z1bmN0aW9uKGIuaXNFcXVhbCkpIHJldHVybiBiLmlzRXF1YWwoYSk7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiBhID09IFN0cmluZyhiKTtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3JcbiAgICAgICAgLy8gb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiBhICE9ICthID8gYiAhPSArYiA6IChhID09IDAgPyAxIC8gYSA9PSAxIC8gYiA6IGEgPT0gK2IpO1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgICAgcmV0dXJuICthID09ICtiO1xuICAgICAgLy8gUmVnRXhwcyBhcmUgY29tcGFyZWQgYnkgdGhlaXIgc291cmNlIHBhdHRlcm5zIGFuZCBmbGFncy5cbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICAgIHJldHVybiBhLnNvdXJjZSA9PSBiLnNvdXJjZSAmJlxuICAgICAgICAgICAgICAgYS5nbG9iYWwgPT0gYi5nbG9iYWwgJiZcbiAgICAgICAgICAgICAgIGEubXVsdGlsaW5lID09IGIubXVsdGlsaW5lICYmXG4gICAgICAgICAgICAgICBhLmlnbm9yZUNhc2UgPT0gYi5pZ25vcmVDYXNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG4gICAgdmFyIGxlbmd0aCA9IHN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgICAgaWYgKHN0YWNrW2xlbmd0aF0gPT0gYSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBzdGFjay5wdXNoKGEpO1xuICAgIHZhciBzaXplID0gMCwgcmVzdWx0ID0gdHJ1ZTtcbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICBpZiAoY2xhc3NOYW1lID09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgc2l6ZSA9IGEubGVuZ3RoO1xuICAgICAgcmVzdWx0ID0gc2l6ZSA9PSBiLmxlbmd0aDtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgICAgd2hpbGUgKHNpemUtLSkge1xuICAgICAgICAgIC8vIEVuc3VyZSBjb21tdXRhdGl2ZSBlcXVhbGl0eSBmb3Igc3BhcnNlIGFycmF5cy5cbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSBzaXplIGluIGEgPT0gc2l6ZSBpbiBiICYmIGVxKGFbc2l6ZV0sIGJbc2l6ZV0sIHN0YWNrKSkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgIGlmICgnY29uc3RydWN0b3InIGluIGEgIT0gJ2NvbnN0cnVjdG9yJyBpbiBiIHx8IGEuY29uc3RydWN0b3IgIT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gYSkge1xuICAgICAgICBpZiAoXy5oYXMoYSwga2V5KSkge1xuICAgICAgICAgIC8vIENvdW50IHRoZSBleHBlY3RlZCBudW1iZXIgb2YgcHJvcGVydGllcy5cbiAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyLlxuICAgICAgICAgIGlmICghKHJlc3VsdCA9IF8uaGFzKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIHN0YWNrKSkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcy5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgZm9yIChrZXkgaW4gYikge1xuICAgICAgICAgIGlmIChfLmhhcyhiLCBrZXkpICYmICEoc2l6ZS0tKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gIXNpemU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIHN0YWNrLnBvcCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBQZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHR3byBvYmplY3RzIGFyZSBlcXVhbC5cbiAgXy5pc0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBlcShhLCBiLCBbXSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PSAxKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGFuIGFycmF5P1xuICAvLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgQXJyYXkuaXNBcnJheVxuICBfLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gYXJndW1lbnRzIG9iamVjdD9cbiAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG4gIH07XG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuICEhKG9iaiAmJiBfLmhhcyhvYmosICdjYWxsZWUnKSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBmdW5jdGlvbj9cbiAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBzdHJpbmc/XG4gIF8uaXNTdHJpbmcgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IFN0cmluZ10nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBudW1iZXI/XG4gIF8uaXNOdW1iZXIgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IE51bWJlcl0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cbiAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLmlzTnVtYmVyKG9iaikgJiYgaXNGaW5pdGUob2JqKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/XG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICAvLyBgTmFOYCBpcyB0aGUgb25seSB2YWx1ZSBmb3Igd2hpY2ggYD09PWAgaXMgbm90IHJlZmxleGl2ZS5cbiAgICByZXR1cm4gb2JqICE9PSBvYmo7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGJvb2xlYW4/XG4gIF8uaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGRhdGU/XG4gIF8uaXNEYXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBEYXRlXSc7XG4gIH07XG5cbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGEgcmVndWxhciBleHByZXNzaW9uP1xuICBfLmlzUmVnRXhwID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBSZWdFeHBdJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBIYXMgb3duIHByb3BlcnR5P1xuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0b3JzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUnVuIGEgZnVuY3Rpb24gKipuKiogdGltZXMuXG4gIF8udGltZXMgPSBmdW5jdGlvbiAobiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBpKTtcbiAgfTtcblxuICAvLyBFc2NhcGUgYSBzdHJpbmcgZm9yIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgXy5lc2NhcGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gKCcnK3N0cmluZykucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKS5yZXBsYWNlKC8nL2csICcmI3gyNzsnKS5yZXBsYWNlKC9cXC8vZywnJiN4MkY7Jyk7XG4gIH07XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBwcm9wZXJ0eSBpcyBhIGZ1bmN0aW9uIHRoZW4gaW52b2tlIGl0O1xuICAvLyBvdGhlcndpc2UsIHJldHVybiBpdC5cbiAgXy5yZXN1bHQgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gQWRkIHlvdXIgb3duIGN1c3RvbSBmdW5jdGlvbnMgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LCBlbnN1cmluZyB0aGF0XG4gIC8vIHRoZXkncmUgY29ycmVjdGx5IGFkZGVkIHRvIHRoZSBPT1Agd3JhcHBlciBhcyB3ZWxsLlxuICBfLm1peGluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgZWFjaChfLmZ1bmN0aW9ucyhvYmopLCBmdW5jdGlvbihuYW1lKXtcbiAgICAgIGFkZFRvV3JhcHBlcihuYW1lLCBfW25hbWVdID0gb2JqW25hbWVdKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9IGlkQ291bnRlcisrO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8uXi87XG5cbiAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcbiAgLy8gc3RyaW5nIGxpdGVyYWwuXG4gIHZhciBlc2NhcGVzID0ge1xuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgIFwiJ1wiOiBcIidcIixcbiAgICAncic6ICdcXHInLFxuICAgICduJzogJ1xcbicsXG4gICAgJ3QnOiAnXFx0JyxcbiAgICAndTIwMjgnOiAnXFx1MjAyOCcsXG4gICAgJ3UyMDI5JzogJ1xcdTIwMjknXG4gIH07XG5cbiAgZm9yICh2YXIgcCBpbiBlc2NhcGVzKSBlc2NhcGVzW2VzY2FwZXNbcF1dID0gcDtcbiAgdmFyIGVzY2FwZXIgPSAvXFxcXHwnfFxccnxcXG58XFx0fFxcdTIwMjh8XFx1MjAyOS9nO1xuICB2YXIgdW5lc2NhcGVyID0gL1xcXFwoXFxcXHwnfHJ8bnx0fHUyMDI4fHUyMDI5KS9nO1xuXG4gIC8vIFdpdGhpbiBhbiBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uLCBvciBlc2NhcGluZywgcmVtb3ZlIEhUTUwgZXNjYXBpbmdcbiAgLy8gdGhhdCBoYWQgYmVlbiBwcmV2aW91c2x5IGFkZGVkLlxuICB2YXIgdW5lc2NhcGUgPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUucmVwbGFjZSh1bmVzY2FwZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUpIHtcbiAgICAgIHJldHVybiBlc2NhcGVzW2VzY2FwZV07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbiAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxuICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIGRhdGEsIHNldHRpbmdzKSB7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHNldHRpbmdzIHx8IHt9LCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCB0YWtpbmcgY2FyZSB0byBlc2NhcGUgY2hhcmFjdGVycyB0aGF0XG4gICAgLy8gY2Fubm90IGJlIGluY2x1ZGVkIGluIGEgc3RyaW5nIGxpdGVyYWwgYW5kIHRoZW4gdW5lc2NhcGUgdGhlbSBpbiBjb2RlXG4gICAgLy8gYmxvY2tzLlxuICAgIHZhciBzb3VyY2UgPSBcIl9fcCs9J1wiICsgdGV4dFxuICAgICAgLnJlcGxhY2UoZXNjYXBlciwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICAgICAgfSlcbiAgICAgIC5yZXBsYWNlKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoLCBmdW5jdGlvbihtYXRjaCwgY29kZSkge1xuICAgICAgICByZXR1cm4gXCInK1xcbl8uZXNjYXBlKFwiICsgdW5lc2NhcGUoY29kZSkgKyBcIikrXFxuJ1wiO1xuICAgICAgfSlcbiAgICAgIC5yZXBsYWNlKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gsIGZ1bmN0aW9uKG1hdGNoLCBjb2RlKSB7XG4gICAgICAgIHJldHVybiBcIicrXFxuKFwiICsgdW5lc2NhcGUoY29kZSkgKyBcIikrXFxuJ1wiO1xuICAgICAgfSlcbiAgICAgIC5yZXBsYWNlKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gsIGZ1bmN0aW9uKG1hdGNoLCBjb2RlKSB7XG4gICAgICAgIHJldHVybiBcIic7XFxuXCIgKyB1bmVzY2FwZShjb2RlKSArIFwiXFxuO19fcCs9J1wiO1xuICAgICAgfSkgKyBcIic7XFxuXCI7XG5cbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxuICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICBzb3VyY2UgPSBcInZhciBfX3A9Jyc7XCIgK1xuICAgICAgXCJ2YXIgcHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPUFycmF5LnByb3RvdHlwZS5qb2luLmNhbGwoYXJndW1lbnRzLCAnJyl9O1xcblwiICtcbiAgICAgIHNvdXJjZSArIFwicmV0dXJuIF9fcDtcXG5cIjtcblxuICAgIHZhciByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsICdfJywgc291cmNlKTtcbiAgICBpZiAoZGF0YSkgcmV0dXJuIHJlbmRlcihkYXRhLCBfKTtcbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBidWlsZCB0aW1lXG4gICAgLy8gcHJlY29tcGlsYXRpb24uXG4gICAgdGVtcGxhdGUuc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAoc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicpICsgJyl7XFxuJyArXG4gICAgICBzb3VyY2UgKyAnfSc7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH07XG5cbiAgLy8gQWRkIGEgXCJjaGFpblwiIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGRlbGVnYXRlIHRvIHRoZSB3cmFwcGVyLlxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8ob2JqKS5jaGFpbigpO1xuICB9O1xuXG4gIC8vIFRoZSBPT1AgV3JhcHBlclxuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdFxuICAvLyBjYW4gYmUgdXNlZCBPTy1zdHlsZS4gVGhpcyB3cmFwcGVyIGhvbGRzIGFsdGVyZWQgdmVyc2lvbnMgb2YgYWxsIHRoZVxuICAvLyB1bmRlcnNjb3JlIGZ1bmN0aW9ucy4gV3JhcHBlZCBvYmplY3RzIG1heSBiZSBjaGFpbmVkLlxuICB2YXIgd3JhcHBlciA9IGZ1bmN0aW9uKG9iaikgeyB0aGlzLl93cmFwcGVkID0gb2JqOyB9O1xuXG4gIC8vIEV4cG9zZSBgd3JhcHBlci5wcm90b3R5cGVgIGFzIGBfLnByb3RvdHlwZWBcbiAgXy5wcm90b3R5cGUgPSB3cmFwcGVyLnByb3RvdHlwZTtcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbihvYmosIGNoYWluKSB7XG4gICAgcmV0dXJuIGNoYWluID8gXyhvYmopLmNoYWluKCkgOiBvYmo7XG4gIH07XG5cbiAgLy8gQSBtZXRob2QgdG8gZWFzaWx5IGFkZCBmdW5jdGlvbnMgdG8gdGhlIE9PUCB3cmFwcGVyLlxuICB2YXIgYWRkVG9XcmFwcGVyID0gZnVuY3Rpb24obmFtZSwgZnVuYykge1xuICAgIHdyYXBwZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIHVuc2hpZnQuY2FsbChhcmdzLCB0aGlzLl93cmFwcGVkKTtcbiAgICAgIHJldHVybiByZXN1bHQoZnVuYy5hcHBseShfLCBhcmdzKSwgdGhpcy5fY2hhaW4pO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIGVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIHdyYXBwZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgd3JhcHBlZCA9IHRoaXMuX3dyYXBwZWQ7XG4gICAgICBtZXRob2QuYXBwbHkod3JhcHBlZCwgYXJndW1lbnRzKTtcbiAgICAgIHZhciBsZW5ndGggPSB3cmFwcGVkLmxlbmd0aDtcbiAgICAgIGlmICgobmFtZSA9PSAnc2hpZnQnIHx8IG5hbWUgPT0gJ3NwbGljZScpICYmIGxlbmd0aCA9PT0gMCkgZGVsZXRlIHdyYXBwZWRbMF07XG4gICAgICByZXR1cm4gcmVzdWx0KHdyYXBwZWQsIHRoaXMuX2NoYWluKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICB3cmFwcGVyLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdChtZXRob2QuYXBwbHkodGhpcy5fd3JhcHBlZCwgYXJndW1lbnRzKSwgdGhpcy5fY2hhaW4pO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgd3JhcHBlci5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jaGFpbiA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gRXh0cmFjdHMgdGhlIHJlc3VsdCBmcm9tIGEgd3JhcHBlZCBhbmQgY2hhaW5lZCBvYmplY3QuXG4gIHdyYXBwZXIucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAvLyBleHBvc2UgdW5pY29kZVJlZ0V4cCBhc1xuICAgIC8vIC0gYW4gQU1EIG1vZHVsZSAocmVxdWlyZSlcbiAgICAvLyAtIGEgbm9kZSBtb2R1bGVcblxuICAgIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGZhY3RvcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QudW5pY29kZVJlZ0V4cCA9IGZhY3RvcnkoKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICh4cmVnZXhwKSB7XG4gICAgdmFyIHVuaWNvZGVSZWdFeHAgPSB7fTtcblxuICAgIC8vIFRoZXNlIGFyZSB0YWtlbiBmcm9tIHRoZSBYUmVnRXhwIGxpYnJhcnkgKHNlZSAuLi9leHRyYWN0UmVnRXhwc0Zyb21YUmVnRXhwLmpzKTpcbiAgICB1bmljb2RlUmVnRXhwLmxldHRlciA9IC9bQS1aYS16wqrCtcK6w4Atw5bDmC3DtsO4LcuBy4Yty5HLoC3LpMusy67NsC3NtM22zbfNui3Nvc6GzogtzorOjM6OLc6hzqMtz7XPty3SgdKKLdSn1LEt1ZbVmdWhLdaH15At16rXsC3XstigLdmK2a7Zr9mxLduT25Xbpdum267br9u6Ldu827/ckNySLdyv3Y0t3qXesd+KLd+q37Tftd+64KCALeCgleCgmuCgpOCgqOChgC3goZjgoqDgoqIt4KKs4KSELeCkueCkveClkOClmC3gpaHgpbEt4KW34KW5LeClv+CmhS3gpozgpo/gppDgppMt4Kao4KaqLeCmsOCmsuCmti3gprngpr3gp47gp5zgp53gp58t4Keh4Kew4Kex4KiFLeCoiuCoj+CokOCoky3gqKjgqKot4Kiw4Kiy4Kiz4Ki14Ki24Ki44Ki54KmZLeCpnOCpnuCpsi3gqbTgqoUt4KqN4KqPLeCqkeCqky3gqqjgqqot4Kqw4Kqy4Kqz4Kq1LeCqueCqveCrkOCroOCroeCshS3grIzgrI/grJDgrJMt4Kyo4KyqLeCssOCssuCss+CstS3grLngrL3grZzgrZ3grZ8t4K2h4K2x4K6D4K6FLeCuiuCuji3grpDgrpIt4K6V4K6Z4K6a4K6c4K6e4K6f4K6j4K6k4K6oLeCuquCuri3grrngr5DgsIUt4LCM4LCOLeCwkOCwki3gsKjgsKot4LCz4LC1LeCwueCwveCxmOCxmeCxoOCxoeCyhS3gsozgso4t4LKQ4LKSLeCyqOCyqi3gsrPgsrUt4LK54LK94LOe4LOg4LOh4LOx4LOy4LSFLeC0jOC0ji3gtJDgtJIt4LS64LS94LWO4LWg4LWh4LW6LeC1v+C2hS3gtpbgtpot4Lax4LazLeC2u+C2veC3gC3gt4bguIEt4Liw4Liy4Liz4LmALeC5huC6geC6guC6hOC6h+C6iOC6iuC6jeC6lC3gupfgupkt4Lqf4LqhLeC6o+C6peC6p+C6quC6q+C6rS3gurDgurLgurPgur3gu4At4LuE4LuG4LucLeC7n+C8gOC9gC3gvYfgvYkt4L2s4L6ILeC+jOGAgC3hgKrhgL/hgZAt4YGV4YGaLeGBneGBoeGBpeGBpuGBri3hgbDhgbUt4YKB4YKO4YKgLeGDheGDh+GDjeGDkC3hg7rhg7wt4YmI4YmKLeGJjeGJkC3hiZbhiZjhiZot4Ymd4YmgLeGKiOGKii3hio3hipAt4Yqw4YqyLeGKteGKuC3hir7hi4Dhi4It4YuF4YuILeGLluGLmC3hjJDhjJIt4YyV4YyYLeGNmuGOgC3hjo/hjqAt4Y+04ZCBLeGZrOGZry3hmb/hmoEt4Zqa4ZqgLeGbquGcgC3hnIzhnI4t4ZyR4ZygLeGcseGdgC3hnZHhnaAt4Z2s4Z2uLeGdsOGegC3hnrPhn5fhn5zhoKAt4aG34aKALeGiqOGiquGisC3ho7XhpIAt4aSc4aWQLeGlreGlsC3hpbThpoAt4aar4aeBLeGnh+GogC3hqJbhqKAt4amU4aqn4ayFLeGss+GthS3hrYvhroMt4a6g4a6u4a6v4a66LeGvpeGwgC3hsKPhsY0t4bGP4bGaLeGxveGzqS3hs6zhs64t4bOx4bO14bO24bSALeG2v+G4gC3hvJXhvJgt4byd4bygLeG9heG9iC3hvY3hvZAt4b2X4b2Z4b2b4b2d4b2fLeG9veG+gC3hvrThvrYt4b684b6+4b+CLeG/hOG/hi3hv4zhv5At4b+T4b+WLeG/m+G/oC3hv6zhv7It4b+04b+2LeG/vOKBseKBv+KCkC3igpzihILihIfihIot4oST4oSV4oSZLeKEneKEpOKEpuKEqOKEqi3ihK3ihK8t4oS54oS8LeKEv+KFhS3ihYnihY7ihoPihoTisIAt4rCu4rCwLeKxnuKxoC3is6Tis6st4rOu4rOy4rOz4rSALeK0peK0p+K0reK0sC3itafita/itoAt4raW4ragLeK2puK2qC3itq7itrAt4ra24ra4LeK2vuK3gC3it4bit4gt4reO4reQLeK3luK3mC3it57iuK/jgIXjgIbjgLEt44C144C744C844GBLeOCluOCnS3jgp/jgqEt44O644O8LeODv+OEhS3jhK3jhLEt44aO44agLeOGuuOHsC3jh7/jkIAt5La15LiALem/jOqAgC3qkozqk5At6pO96pSALeqYjOqYkC3qmJ/qmKrqmKvqmYAt6pmu6pm/Leqal+qaoC3qm6XqnJct6pyf6pyiLeqeiOqeiy3qno7qnpAt6p6T6p6gLeqequqfuC3qoIHqoIMt6qCF6qCHLeqgiuqgjC3qoKLqoYAt6qGz6qKCLeqis+qjsi3qo7fqo7vqpIot6qSl6qSwLeqlhuqloC3qpbzqpoQt6qay6qeP6qiALeqoqOqpgC3qqYLqqYQt6qmL6qmgLeqptuqpuuqqgC3qqq/qqrHqqrXqqrbqqrkt6qq96quA6quC6qubLeqrneqroC3qq6rqq7It6qu06qyBLeqshuqsiS3qrI7qrJEt6qyW6qygLeqspuqsqC3qrK7qr4At6q+i6rCALe2eo+2esC3tn4btn4st7Z+776SALe+pre+psC3vq5nvrIAt76yG76yTLe+sl++sne+sny3vrKjvrKot76y276y4Le+svO+svu+tgO+tge+tg++thO+thi3vrrHvr5Mt77S977WQLe+2j++2ki3vt4fvt7At77e777mwLe+5tO+5ti3vu7zvvKEt77y6772BLe+9mu+9pi3vvr7vv4It77+H77+KLe+/j++/ki3vv5fvv5ot77+cXS87XG4gICAgdW5pY29kZVJlZ0V4cC5tYXJrID0gL1tcXHUwMzAwLVxcdTAzNkZcXHUwNDgzLVxcdTA0ODlcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNjEwLVxcdTA2MUFcXHUwNjRCLVxcdTA2NUZcXHUwNjcwXFx1MDZENi1cXHUwNkRDXFx1MDZERi1cXHUwNkU0XFx1MDZFN1xcdTA2RThcXHUwNkVBLVxcdTA2RURcXHUwNzExXFx1MDczMC1cXHUwNzRBXFx1MDdBNi1cXHUwN0IwXFx1MDdFQi1cXHUwN0YzXFx1MDgxNi1cXHUwODE5XFx1MDgxQi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJEXFx1MDg1OS1cXHUwODVCXFx1MDhFNC1cXHUwOEZFXFx1MDkwMC1cXHUwOTAzXFx1MDkzQS1cXHUwOTNDXFx1MDkzRS1cXHUwOTRGXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTgxLVxcdTA5ODNcXHUwOUJDXFx1MDlCRS1cXHUwOUM0XFx1MDlDN1xcdTA5QzhcXHUwOUNCLVxcdTA5Q0RcXHUwOUQ3XFx1MDlFMlxcdTA5RTNcXHUwQTAxLVxcdTBBMDNcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE3MFxcdTBBNzFcXHUwQTc1XFx1MEE4MS1cXHUwQTgzXFx1MEFCQ1xcdTBBQkUtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRTJcXHUwQUUzXFx1MEIwMS1cXHUwQjAzXFx1MEIzQ1xcdTBCM0UtXFx1MEI0NFxcdTBCNDdcXHUwQjQ4XFx1MEI0Qi1cXHUwQjREXFx1MEI1NlxcdTBCNTdcXHUwQjYyXFx1MEI2M1xcdTBCODJcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0RcXHUwQkQ3XFx1MEMwMS1cXHUwQzAzXFx1MEMzRS1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzYyXFx1MEM2M1xcdTBDODJcXHUwQzgzXFx1MENCQ1xcdTBDQkUtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENFMlxcdTBDRTNcXHUwRDAyXFx1MEQwM1xcdTBEM0UtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RFxcdTBENTdcXHUwRDYyXFx1MEQ2M1xcdTBEODJcXHUwRDgzXFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREYyXFx1MERGM1xcdTBFMzFcXHUwRTM0LVxcdTBFM0FcXHUwRTQ3LVxcdTBFNEVcXHUwRUIxXFx1MEVCNC1cXHUwRUI5XFx1MEVCQlxcdTBFQkNcXHUwRUM4LVxcdTBFQ0RcXHUwRjE4XFx1MEYxOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0VcXHUwRjNGXFx1MEY3MS1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyQi1cXHUxMDNFXFx1MTA1Ni1cXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA2Mi1cXHUxMDY0XFx1MTA2Ny1cXHUxMDZEXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhEXFx1MTA4RlxcdTEwOUEtXFx1MTA5RFxcdTEzNUQtXFx1MTM1RlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN0I0LVxcdTE3RDNcXHUxN0REXFx1MTgwQi1cXHUxODBEXFx1MThBOVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5QjAtXFx1MTlDMFxcdTE5QzhcXHUxOUM5XFx1MUExNy1cXHUxQTFCXFx1MUE1NS1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3RlxcdTFCMDAtXFx1MUIwNFxcdTFCMzQtXFx1MUI0NFxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUI4MlxcdTFCQTEtXFx1MUJBRFxcdTFCRTYtXFx1MUJGM1xcdTFDMjQtXFx1MUMzN1xcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNFOFxcdTFDRURcXHUxQ0YyLVxcdTFDRjRcXHUxREMwLVxcdTFERTZcXHUxREZDLVxcdTFERkZcXHUyMEQwLVxcdTIwRjBcXHUyQ0VGLVxcdTJDRjFcXHUyRDdGXFx1MkRFMC1cXHUyREZGXFx1MzAyQS1cXHUzMDJGXFx1MzA5OVxcdTMwOUFcXHVBNjZGLVxcdUE2NzJcXHVBNjc0LVxcdUE2N0RcXHVBNjlGXFx1QTZGMFxcdUE2RjFcXHVBODAyXFx1QTgwNlxcdUE4MEJcXHVBODIzLVxcdUE4MjdcXHVBODgwXFx1QTg4MVxcdUE4QjQtXFx1QThDNFxcdUE4RTAtXFx1QThGMVxcdUE5MjYtXFx1QTkyRFxcdUE5NDctXFx1QTk1M1xcdUE5ODAtXFx1QTk4M1xcdUE5QjMtXFx1QTlDMFxcdUFBMjktXFx1QUEzNlxcdUFBNDNcXHVBQTRDXFx1QUE0RFxcdUFBN0JcXHVBQUIwXFx1QUFCMi1cXHVBQUI0XFx1QUFCN1xcdUFBQjhcXHVBQUJFXFx1QUFCRlxcdUFBQzFcXHVBQUVCLVxcdUFBRUZcXHVBQUY1XFx1QUFGNlxcdUFCRTMtXFx1QUJFQVxcdUFCRUNcXHVBQkVEXFx1RkIxRVxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyNl0vO1xuICAgIHVuaWNvZGVSZWdFeHAubnVtYmVyID0gL1swLTnCssKzwrnCvC3CvtmgLdmp27At27nfgC3fieClpi3gpa/gp6Yt4Kev4Ke0LeCnueCppi3gqa/gq6Yt4Kuv4K2mLeCtr+Ctsi3grbfgr6Yt4K+y4LGmLeCxr+CxuC3gsb7gs6Yt4LOv4LWmLeC1teC5kC3guZngu5At4LuZ4LygLeC8s+GBgC3hgYnhgpAt4YKZ4Y2pLeGNvOGbri3hm7Dhn6At4Z+p4Z+wLeGfueGgkC3hoJnhpYYt4aWP4aeQLeGnmuGqgC3hqonhqpAt4aqZ4a2QLeGtmeGusC3hrrnhsYAt4bGJ4bGQLeGxmeKBsOKBtC3igbnigoAt4oKJ4oWQLeKGguKGhS3ihonikaAt4pKb4pOqLeKTv+Kdti3inpPis73jgIfjgKEt44Cp44C4LeOAuuOGki3jhpXjiKAt44ip44mILeOJj+OJkS3jiZ/jioAt44qJ44qxLeOKv+qYoC3qmKnqm6Yt6puv6qCwLeqgteqjkC3qo5nqpIAt6qSJ6qeQLeqnmeqpkC3qqZnqr7At6q+577yQLe+8mV0vO1xuICAgIHVuaWNvZGVSZWdFeHAucHVuY3R1YXRpb24gPSAvW1xcdTAwMjEtXFx1MDAyM1xcdTAwMjUtXFx1MDAyQVxcdTAwMkMtXFx1MDAyRlxcdTAwM0FcXHUwMDNCXFx1MDAzRlxcdTAwNDBcXHUwMDVCLVxcdTAwNURcXHUwMDVGXFx1MDA3QlxcdTAwN0RcXHUwMEExXFx1MDBBN1xcdTAwQUJcXHUwMEI2XFx1MDBCN1xcdTAwQkJcXHUwMEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTBBRjBcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFM0JcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QTkyRVxcdUE5MkZcXHVBOTVGXFx1QTlDMS1cXHVBOUNEXFx1QTlERVxcdUE5REZcXHVBQTVDLVxcdUFBNUZcXHVBQURFXFx1QUFERlxcdUFBRjBcXHVBQUYxXFx1QUJFQlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTYxXFx1RkU2M1xcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwQVxcdUZGMEMtXFx1RkYwRlxcdUZGMUFcXHVGRjFCXFx1RkYxRlxcdUZGMjBcXHVGRjNCLVxcdUZGM0RcXHVGRjNGXFx1RkY1QlxcdUZGNURcXHVGRjVGLVxcdUZGNjVdLztcbiAgICB1bmljb2RlUmVnRXhwLnN5bWJvbCA9IC9bXFx1MDAyNCs8LT5cXHUwMDVFYFxcdTAwN0N+wqItwqbCqMKpwqzCri3CscK0wrjDl8O3y4Ity4XLki3Ln8ulLcury63Lry3Lv821zoTOhc+20oLWj9iGLdiI2IvYjtiP257bqdu9277ftuCnsuCns+CnuuCnu+CrseCtsOCvsy3gr7rgsb/gtbnguL/gvIEt4LyD4LyT4LyVLeC8l+C8mi3gvJ/gvLTgvLbgvLjgvr4t4L+F4L+HLeC/jOC/juC/j+C/lS3gv5jhgp7hgp/hjpAt4Y6Z4Z+b4aWA4aeeLeGnv+GtoS3hrarhrbQt4a284b694b6/LeG/geG/jS3hv4/hv50t4b+f4b+tLeG/r+G/veG/vuKBhOKBkuKBui3igbzigoot4oKM4oKgLeKCueKEgOKEgeKEgy3ihIbihIjihInihJTihJYt4oSY4oSeLeKEo+KEpeKEp+KEqeKEruKEuuKEu+KFgC3ihYTihYot4oWN4oWP4oaQLeKMqOKMqy3ij7PikIAt4pCm4pGALeKRiuKSnC3ik6nilIAt4pu/4pyBLeKdp+KelC3in4Tin4ct4p+l4p+wLeKmguKmmS3ip5fip5wt4qe74qe+LeKtjOKtkC3irZnis6Ut4rOq4rqALeK6meK6my3iu7PivIAt4r+V4r+wLeK/u+OAhOOAkuOAk+OAoOOAtuOAt+OAvuOAv+OCm+OCnOOGkOOGkeOGli3jhp/jh4At44ej44iALeOInuOIqi3jiYfjiZDjiaAt44m/44qKLeOKsOOLgC3ji77jjIAt44+/5LeALeS3v+qSkC3qk4bqnIAt6pyW6pyg6pyh6p6J6p6K6qCoLeqgq+qgti3qoLnqqbct6qm576yp766yLe+vge+3vO+3ve+5ou+5pC3vuabvuanvvITvvIvvvJwt77ye77y+772A772c772e77+gLe+/pu+/qC3vv67vv7zvv71dLztcbiAgICB1bmljb2RlUmVnRXhwLnNlcGFyYXRvciA9IC9bXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MTgwRVxcdTIwMDAtXFx1MjAwQVxcdTIwMjhcXHUyMDI5XFx1MjAyRlxcdTIwNUZcXHUzMDAwXS87XG4gICAgdW5pY29kZVJlZ0V4cC5vdGhlciA9IC9bXFx1MDAwMC1cXHUwMDFGXFx1MDA3Ri1cXHUwMDlGXFx1MDBBRFxcdTAzNzhcXHUwMzc5XFx1MDM3Ri1cXHUwMzgzXFx1MDM4QlxcdTAzOERcXHUwM0EyXFx1MDUyOC1cXHUwNTMwXFx1MDU1N1xcdTA1NThcXHUwNTYwXFx1MDU4OFxcdTA1OEItXFx1MDU4RVxcdTA1OTBcXHUwNUM4LVxcdTA1Q0ZcXHUwNUVCLVxcdTA1RUZcXHUwNUY1LVxcdTA2MDVcXHUwNjFDXFx1MDYxRFxcdTA2RERcXHUwNzBFXFx1MDcwRlxcdTA3NEJcXHUwNzRDXFx1MDdCMi1cXHUwN0JGXFx1MDdGQi1cXHUwN0ZGXFx1MDgyRVxcdTA4MkZcXHUwODNGXFx1MDg1Q1xcdTA4NURcXHUwODVGLVxcdTA4OUZcXHUwOEExXFx1MDhBRC1cXHUwOEUzXFx1MDhGRlxcdTA5NzhcXHUwOTgwXFx1MDk4NFxcdTA5OERcXHUwOThFXFx1MDk5MVxcdTA5OTJcXHUwOUE5XFx1MDlCMVxcdTA5QjMtXFx1MDlCNVxcdTA5QkFcXHUwOUJCXFx1MDlDNVxcdTA5QzZcXHUwOUM5XFx1MDlDQVxcdTA5Q0YtXFx1MDlENlxcdTA5RDgtXFx1MDlEQlxcdTA5REVcXHUwOUU0XFx1MDlFNVxcdTA5RkMtXFx1MEEwMFxcdTBBMDRcXHUwQTBCLVxcdTBBMEVcXHUwQTExXFx1MEExMlxcdTBBMjlcXHUwQTMxXFx1MEEzNFxcdTBBMzdcXHUwQTNBXFx1MEEzQlxcdTBBM0RcXHUwQTQzLVxcdTBBNDZcXHUwQTQ5XFx1MEE0QVxcdTBBNEUtXFx1MEE1MFxcdTBBNTItXFx1MEE1OFxcdTBBNURcXHUwQTVGLVxcdTBBNjVcXHUwQTc2LVxcdTBBODBcXHUwQTg0XFx1MEE4RVxcdTBBOTJcXHUwQUE5XFx1MEFCMVxcdTBBQjRcXHUwQUJBXFx1MEFCQlxcdTBBQzZcXHUwQUNBXFx1MEFDRVxcdTBBQ0ZcXHUwQUQxLVxcdTBBREZcXHUwQUU0XFx1MEFFNVxcdTBBRjItXFx1MEIwMFxcdTBCMDRcXHUwQjBEXFx1MEIwRVxcdTBCMTFcXHUwQjEyXFx1MEIyOVxcdTBCMzFcXHUwQjM0XFx1MEIzQVxcdTBCM0JcXHUwQjQ1XFx1MEI0NlxcdTBCNDlcXHUwQjRBXFx1MEI0RS1cXHUwQjU1XFx1MEI1OC1cXHUwQjVCXFx1MEI1RVxcdTBCNjRcXHUwQjY1XFx1MEI3OC1cXHUwQjgxXFx1MEI4NFxcdTBCOEItXFx1MEI4RFxcdTBCOTFcXHUwQjk2LVxcdTBCOThcXHUwQjlCXFx1MEI5RFxcdTBCQTAtXFx1MEJBMlxcdTBCQTUtXFx1MEJBN1xcdTBCQUItXFx1MEJBRFxcdTBCQkEtXFx1MEJCRFxcdTBCQzMtXFx1MEJDNVxcdTBCQzlcXHUwQkNFXFx1MEJDRlxcdTBCRDEtXFx1MEJENlxcdTBCRDgtXFx1MEJFNVxcdTBCRkItXFx1MEMwMFxcdTBDMDRcXHUwQzBEXFx1MEMxMVxcdTBDMjlcXHUwQzM0XFx1MEMzQS1cXHUwQzNDXFx1MEM0NVxcdTBDNDlcXHUwQzRFLVxcdTBDNTRcXHUwQzU3XFx1MEM1QS1cXHUwQzVGXFx1MEM2NFxcdTBDNjVcXHUwQzcwLVxcdTBDNzdcXHUwQzgwXFx1MEM4MVxcdTBDODRcXHUwQzhEXFx1MEM5MVxcdTBDQTlcXHUwQ0I0XFx1MENCQVxcdTBDQkJcXHUwQ0M1XFx1MENDOVxcdTBDQ0UtXFx1MENENFxcdTBDRDctXFx1MENERFxcdTBDREZcXHUwQ0U0XFx1MENFNVxcdTBDRjBcXHUwQ0YzLVxcdTBEMDFcXHUwRDA0XFx1MEQwRFxcdTBEMTFcXHUwRDNCXFx1MEQzQ1xcdTBENDVcXHUwRDQ5XFx1MEQ0Ri1cXHUwRDU2XFx1MEQ1OC1cXHUwRDVGXFx1MEQ2NFxcdTBENjVcXHUwRDc2LVxcdTBENzhcXHUwRDgwXFx1MEQ4MVxcdTBEODRcXHUwRDk3LVxcdTBEOTlcXHUwREIyXFx1MERCQ1xcdTBEQkVcXHUwREJGXFx1MERDNy1cXHUwREM5XFx1MERDQi1cXHUwRENFXFx1MERENVxcdTBERDdcXHUwREUwLVxcdTBERjFcXHUwREY1LVxcdTBFMDBcXHUwRTNCLVxcdTBFM0VcXHUwRTVDLVxcdTBFODBcXHUwRTgzXFx1MEU4NVxcdTBFODZcXHUwRTg5XFx1MEU4QlxcdTBFOENcXHUwRThFLVxcdTBFOTNcXHUwRTk4XFx1MEVBMFxcdTBFQTRcXHUwRUE2XFx1MEVBOFxcdTBFQTlcXHUwRUFDXFx1MEVCQVxcdTBFQkVcXHUwRUJGXFx1MEVDNVxcdTBFQzdcXHUwRUNFXFx1MEVDRlxcdTBFREFcXHUwRURCXFx1MEVFMC1cXHUwRUZGXFx1MEY0OFxcdTBGNkQtXFx1MEY3MFxcdTBGOThcXHUwRkJEXFx1MEZDRFxcdTBGREItXFx1MEZGRlxcdTEwQzZcXHUxMEM4LVxcdTEwQ0NcXHUxMENFXFx1MTBDRlxcdTEyNDlcXHUxMjRFXFx1MTI0RlxcdTEyNTdcXHUxMjU5XFx1MTI1RVxcdTEyNUZcXHUxMjg5XFx1MTI4RVxcdTEyOEZcXHUxMkIxXFx1MTJCNlxcdTEyQjdcXHUxMkJGXFx1MTJDMVxcdTEyQzZcXHUxMkM3XFx1MTJEN1xcdTEzMTFcXHUxMzE2XFx1MTMxN1xcdTEzNUJcXHUxMzVDXFx1MTM3RC1cXHUxMzdGXFx1MTM5QS1cXHUxMzlGXFx1MTNGNS1cXHUxM0ZGXFx1MTY5RC1cXHUxNjlGXFx1MTZGMS1cXHUxNkZGXFx1MTcwRFxcdTE3MTUtXFx1MTcxRlxcdTE3MzctXFx1MTczRlxcdTE3NTQtXFx1MTc1RlxcdTE3NkRcXHUxNzcxXFx1MTc3NC1cXHUxNzdGXFx1MTdERVxcdTE3REZcXHUxN0VBLVxcdTE3RUZcXHUxN0ZBLVxcdTE3RkZcXHUxODBGXFx1MTgxQS1cXHUxODFGXFx1MTg3OC1cXHUxODdGXFx1MThBQi1cXHUxOEFGXFx1MThGNi1cXHUxOEZGXFx1MTkxRC1cXHUxOTFGXFx1MTkyQy1cXHUxOTJGXFx1MTkzQy1cXHUxOTNGXFx1MTk0MS1cXHUxOTQzXFx1MTk2RVxcdTE5NkZcXHUxOTc1LVxcdTE5N0ZcXHUxOUFDLVxcdTE5QUZcXHUxOUNBLVxcdTE5Q0ZcXHUxOURCLVxcdTE5RERcXHUxQTFDXFx1MUExRFxcdTFBNUZcXHUxQTdEXFx1MUE3RVxcdTFBOEEtXFx1MUE4RlxcdTFBOUEtXFx1MUE5RlxcdTFBQUUtXFx1MUFGRlxcdTFCNEMtXFx1MUI0RlxcdTFCN0QtXFx1MUI3RlxcdTFCRjQtXFx1MUJGQlxcdTFDMzgtXFx1MUMzQVxcdTFDNEEtXFx1MUM0Q1xcdTFDODAtXFx1MUNCRlxcdTFDQzgtXFx1MUNDRlxcdTFDRjctXFx1MUNGRlxcdTFERTctXFx1MURGQlxcdTFGMTZcXHUxRjE3XFx1MUYxRVxcdTFGMUZcXHUxRjQ2XFx1MUY0N1xcdTFGNEVcXHUxRjRGXFx1MUY1OFxcdTFGNUFcXHUxRjVDXFx1MUY1RVxcdTFGN0VcXHUxRjdGXFx1MUZCNVxcdTFGQzVcXHUxRkQ0XFx1MUZENVxcdTFGRENcXHUxRkYwXFx1MUZGMVxcdTFGRjVcXHUxRkZGXFx1MjAwQi1cXHUyMDBGXFx1MjAyQS1cXHUyMDJFXFx1MjA2MC1cXHUyMDZGXFx1MjA3MlxcdTIwNzNcXHUyMDhGXFx1MjA5RC1cXHUyMDlGXFx1MjBCQS1cXHUyMENGXFx1MjBGMS1cXHUyMEZGXFx1MjE4QS1cXHUyMThGXFx1MjNGNC1cXHUyM0ZGXFx1MjQyNy1cXHUyNDNGXFx1MjQ0Qi1cXHUyNDVGXFx1MjcwMFxcdTJCNEQtXFx1MkI0RlxcdTJCNUEtXFx1MkJGRlxcdTJDMkZcXHUyQzVGXFx1MkNGNC1cXHUyQ0Y4XFx1MkQyNlxcdTJEMjgtXFx1MkQyQ1xcdTJEMkVcXHUyRDJGXFx1MkQ2OC1cXHUyRDZFXFx1MkQ3MS1cXHUyRDdFXFx1MkQ5Ny1cXHUyRDlGXFx1MkRBN1xcdTJEQUZcXHUyREI3XFx1MkRCRlxcdTJEQzdcXHUyRENGXFx1MkREN1xcdTJEREZcXHUyRTNDLVxcdTJFN0ZcXHUyRTlBXFx1MkVGNC1cXHUyRUZGXFx1MkZENi1cXHUyRkVGXFx1MkZGQy1cXHUyRkZGXFx1MzA0MFxcdTMwOTdcXHUzMDk4XFx1MzEwMC1cXHUzMTA0XFx1MzEyRS1cXHUzMTMwXFx1MzE4RlxcdTMxQkItXFx1MzFCRlxcdTMxRTQtXFx1MzFFRlxcdTMyMUZcXHUzMkZGXFx1NERCNi1cXHU0REJGXFx1OUZDRC1cXHU5RkZGXFx1QTQ4RC1cXHVBNDhGXFx1QTRDNy1cXHVBNENGXFx1QTYyQy1cXHVBNjNGXFx1QTY5OC1cXHVBNjlFXFx1QTZGOC1cXHVBNkZGXFx1QTc4RlxcdUE3OTQtXFx1QTc5RlxcdUE3QUItXFx1QTdGN1xcdUE4MkMtXFx1QTgyRlxcdUE4M0EtXFx1QTgzRlxcdUE4NzgtXFx1QTg3RlxcdUE4QzUtXFx1QThDRFxcdUE4REEtXFx1QThERlxcdUE4RkMtXFx1QThGRlxcdUE5NTQtXFx1QTk1RVxcdUE5N0QtXFx1QTk3RlxcdUE5Q0VcXHVBOURBLVxcdUE5RERcXHVBOUUwLVxcdUE5RkZcXHVBQTM3LVxcdUFBM0ZcXHVBQTRFXFx1QUE0RlxcdUFBNUFcXHVBQTVCXFx1QUE3Qy1cXHVBQTdGXFx1QUFDMy1cXHVBQURBXFx1QUFGNy1cXHVBQjAwXFx1QUIwN1xcdUFCMDhcXHVBQjBGXFx1QUIxMFxcdUFCMTctXFx1QUIxRlxcdUFCMjdcXHVBQjJGLVxcdUFCQkZcXHVBQkVFXFx1QUJFRlxcdUFCRkEtXFx1QUJGRlxcdUQ3QTQtXFx1RDdBRlxcdUQ3QzctXFx1RDdDQVxcdUQ3RkMtXFx1RjhGRlxcdUZBNkVcXHVGQTZGXFx1RkFEQS1cXHVGQUZGXFx1RkIwNy1cXHVGQjEyXFx1RkIxOC1cXHVGQjFDXFx1RkIzN1xcdUZCM0RcXHVGQjNGXFx1RkI0MlxcdUZCNDVcXHVGQkMyLVxcdUZCRDJcXHVGRDQwLVxcdUZENEZcXHVGRDkwXFx1RkQ5MVxcdUZEQzgtXFx1RkRFRlxcdUZERkVcXHVGREZGXFx1RkUxQS1cXHVGRTFGXFx1RkUyNy1cXHVGRTJGXFx1RkU1M1xcdUZFNjdcXHVGRTZDLVxcdUZFNkZcXHVGRTc1XFx1RkVGRC1cXHVGRjAwXFx1RkZCRi1cXHVGRkMxXFx1RkZDOFxcdUZGQzlcXHVGRkQwXFx1RkZEMVxcdUZGRDhcXHVGRkQ5XFx1RkZERC1cXHVGRkRGXFx1RkZFN1xcdUZGRUYtXFx1RkZGQlxcdUZGRkVcXHVGRkZGXS87IC8vIE90aGVyIChjb250cm9sLCBmb3JtYXQsIHByaXZhdGUgdXNlLCBzdXJyb2dhdGUsIGFuZCB1bmFzc2lnbmVkIGNvZGVzKVxuXG4gICAgdmFyIHVuaWNvZGVQYWNrYWdlTmFtZXNNYXBwaW5nID0ge1xuICAgICAgICBMOiB1bmljb2RlUmVnRXhwLmxldHRlcixcbiAgICAgICAgTTogdW5pY29kZVJlZ0V4cC5tYXJrLFxuICAgICAgICBOOiB1bmljb2RlUmVnRXhwLm51bWJlcixcbiAgICAgICAgUDogdW5pY29kZVJlZ0V4cC5wdW5jdHVhdGlvbixcbiAgICAgICAgUzogdW5pY29kZVJlZ0V4cC5zeW1ib2wsXG4gICAgICAgIFo6IHVuaWNvZGVSZWdFeHAuc2VwYXJhdG9yLFxuICAgICAgICBDOiB1bmljb2RlUmVnRXhwLm90aGVyLFxuICAgICAgICBsZXR0ZXI6IHVuaWNvZGVSZWdFeHAubGV0dGVyLFxuICAgICAgICBtYXJrOiB1bmljb2RlUmVnRXhwLm1hcmssXG4gICAgICAgIG51bWJlcjogdW5pY29kZVJlZ0V4cC5udW1iZXIsXG4gICAgICAgIGRpZ2l0OiB1bmljb2RlUmVnRXhwLm51bWJlcixcbiAgICAgICAgcHVuY3R1YXRpb246IHVuaWNvZGVSZWdFeHAucHVuY3R1YXRpb24sXG4gICAgICAgIHN5bWJvbDogdW5pY29kZVJlZ0V4cC5zeW1ib2wsXG4gICAgICAgIHNlcGFyYXRvcjogdW5pY29kZVJlZ0V4cC5zZXBhcmF0b3IsXG4gICAgICAgIG90aGVyOiB1bmljb2RlUmVnRXhwLm90aGVyXG4gICAgfTtcblxuICAgIHVuaWNvZGVSZWdFeHAudW5pY29kZVBhY2thZ2VOYW1lUmVnRXhwID0gbmV3IFJlZ0V4cCgnXlxcXFxbXFxcXDooXFxcXF4pPygnICsgT2JqZWN0LmtleXModW5pY29kZVBhY2thZ2VOYW1lc01hcHBpbmcpLmpvaW4oJ3wnKSArICcpXFxcXDpcXFxcXSQnKTtcblxuICAgIHVuaWNvZGVSZWdFeHAuZXhwYW5kQ2xkclVuaWNvZGVTZXRJZFRvQ2hhcmFjdGVyQ2xhc3MgPSBmdW5jdGlvbiAodW5pY29kZVNldElkKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuaWNvZGVTZXRJZC5yZXBsYWNlKHVuaWNvZGVSZWdFeHAudW5pY29kZVBhY2thZ2VOYW1lUmVnRXhwLCBmdW5jdGlvbiAoJDAsIG5lZ2F0ZWQsIHBhY2thZ2VOYW1lKSB7XG4gICAgICAgICAgICB2YXIgY2hhcmFjdGVycyA9IHVuaWNvZGVQYWNrYWdlTmFtZXNNYXBwaW5nW3BhY2thZ2VOYW1lXS5zb3VyY2UucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgICAgIHJldHVybiAnWycgKyAobmVnYXRlZCA/ICdeJyArIGNoYXJhY3RlcnMgOiBjaGFyYWN0ZXJzKSArICddJztcbiAgICAgICAgfSkpO1xuICAgIH07XG5cbiAgICB1bmljb2RlUmVnRXhwLnNwbGljZUNoYXJhY3RlckNsYXNzUmVnRXhwcyA9IGZ1bmN0aW9uICgpIHsgLy8gLi4uXG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnWycgKyBhcmdzLm1hcChmdW5jdGlvbiAocmVnRXhwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnRXhwLnNvdXJjZS5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICB9KS5qb2luKFwiXCIpICsgJ10nKTtcbiAgICB9O1xuXG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBjb21iaW5lZCwgZXhjZXB0ICdzZXBhcmF0b3InLCBhbmQgJ290aGVyJzpcbiAgICB1bmljb2RlUmVnRXhwLnZpc2libGUgPSB1bmljb2RlUmVnRXhwLnNwbGljZUNoYXJhY3RlckNsYXNzUmVnRXhwcyhcbiAgICAgICAgdW5pY29kZVJlZ0V4cC5sZXR0ZXIsXG4gICAgICAgIHVuaWNvZGVSZWdFeHAubWFyayxcbiAgICAgICAgdW5pY29kZVJlZ0V4cC5udW1iZXIsXG4gICAgICAgIHVuaWNvZGVSZWdFeHAucHVuY3R1YXRpb24sXG4gICAgICAgIHVuaWNvZGVSZWdFeHAuc3ltYm9sXG4gICAgKTtcblxuICAgIC8vIFRoZSBzZXQgb2YgcHJpbnRhYmxlIGNoYXJhY3RlcnMgYWxzbyBpbmNsdWRlcyBzcGFjZTpcbiAgICB1bmljb2RlUmVnRXhwLnByaW50YWJsZSA9IHVuaWNvZGVSZWdFeHAuc3BsaWNlQ2hhcmFjdGVyQ2xhc3NSZWdFeHBzKFxuICAgICAgICB1bmljb2RlUmVnRXhwLnZpc2libGUsXG4gICAgICAgIHVuaWNvZGVSZWdFeHAuc2VwYXJhdG9yXG4gICAgKTtcblxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiBmb3IgcmVtb3ZpbmcgYSBjaGFyIGZyb20gYSBjaGFyYWN0ZXIgY2xhc3MgcmVndWxhciBleHByZXNzaW9uOlxuXG4gICAgZnVuY3Rpb24gcGFyc2VDaGFyQ29kZSh1NCwgeDIsIGxpdGVyYWwpIHtcbiAgICAgICAgaWYgKHU0IHx8IHgyKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodTQgfHwgeDIsIDE2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGFyQ29kZVRvUmVnRXhwVG9rZW4oY2hhckNvZGUpIHtcbiAgICAgICAgaWYgKGNoYXJDb2RlID49IDB4MjAgJiYgY2hhckNvZGUgPCAweDdmKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaGV4U3RyID0gY2hhckNvZGUudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHVcIiArIFwiMDAwMFwiLnNsaWNlKGhleFN0ci5sZW5ndGgpICsgaGV4U3RyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYXJhY3RlckNsYXNzVG9rZW4gPSAvKD86XFxcXHUoWzAtOWEtZl17NH0pfFxcXFx4KFswLTlhLWZdezJ9KXwoW15cXC1dKSkoPzotKD86XFxcXHUoWzAtOWEtZl17NH0pfFxcXFx4KFswLTlhLWZdezJ9KXwoW15cXC1dKSkpPy9naTtcblxuICAgIHVuaWNvZGVSZWdFeHAucmVtb3ZlQ2hhcmFjdGVyRnJvbUNoYXJhY3RlckNsYXNzUmVnRXhwID0gZnVuY3Rpb24gKHJlZ0V4cCwgY2gpIHtcbiAgICAgICAgdmFyIGNoYXJDb2RlID0gY2guY2hhckNvZGVBdCgwKTtcblxuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnWycgKyByZWdFeHAuc291cmNlLnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJykucmVwbGFjZShjaGFyYWN0ZXJDbGFzc1Rva2VuLCBmdW5jdGlvbiAoJDAsIGZyb21VNCwgZnJvbVgyLCBmcm9tTGl0ZXJhbCwgdG9VNCwgdG9YMiwgdG9MaXRlcmFsKSB7XG4gICAgICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gcGFyc2VDaGFyQ29kZShmcm9tVTQsIGZyb21YMiwgZnJvbUxpdGVyYWwpO1xuICAgICAgICAgICAgaWYgKHRvVTQgfHwgdG9YMiB8fCB0b0xpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9DaGFyQ29kZSA9IHBhcnNlQ2hhckNvZGUodG9VNCwgdG9YMiwgdG9MaXRlcmFsKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT09IGZyb21DaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgKyAxIDwgdG9DaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJDb2RlVG9SZWdFeHBUb2tlbihjaGFyQ29kZSArIDEpICsgJy0nICsgY2hhckNvZGVUb1JlZ0V4cFRva2VuKHRvQ2hhckNvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJDb2RlVG9SZWdFeHBUb2tlbih0b0NoYXJDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT09IHRvQ2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb21DaGFyQ29kZSA8IGNoYXJDb2RlIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJDb2RlVG9SZWdFeHBUb2tlbihmcm9tQ2hhckNvZGUpICsgJy0nICsgY2hhckNvZGVUb1JlZ0V4cFRva2VuKGNoYXJDb2RlIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tQ2hhckNvZGUgPT09IHRvQ2hhckNvZGUgLSAxLCByZXdyaXRlIHRvIHNpbmdsZSBjaGFyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhckNvZGVUb1JlZ0V4cFRva2VuKGZyb21DaGFyQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID4gZnJvbUNoYXJDb2RlICYmIGNoYXJDb2RlIDwgdG9DaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhckNvZGVUb1JlZ0V4cFRva2VuKGZyb21DaGFyQ29kZSkgKyAoY2hhckNvZGUgPiBmcm9tQ2hhckNvZGUgKyAxID8gJy0nICsgY2hhckNvZGVUb1JlZ0V4cFRva2VuKGNoYXJDb2RlIC0gMSkgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGNoYXJDb2RlICsgMSA8IHRvQ2hhckNvZGUgPyBjaGFyQ29kZVRvUmVnRXhwVG9rZW4oY2hhckNvZGUgKyAxKSArICctJyA6ICcnKSArIGNoYXJDb2RlVG9SZWdFeHBUb2tlbih0b0NoYXJDb2RlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT09IGZyb21DaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhckNvZGVUb1JlZ0V4cFRva2VuKGZyb21DaGFyQ29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSArICddJyk7XG4gICAgfTtcblxuICAgIHJldHVybiB1bmljb2RlUmVnRXhwO1xufSkpO1xuIiwiZnVuY3Rpb24gRE9NUGFyc2VyKG9wdGlvbnMpe1xyXG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHx7bG9jYXRvcjp7fX07XHJcblx0XHJcbn1cclxuRE9NUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZyb21TdHJpbmcgPSBmdW5jdGlvbihzb3VyY2UsbWltZVR5cGUpe1x0XHJcblx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblx0dmFyIHNheCA9ICBuZXcgWE1MUmVhZGVyKCk7XHJcblx0dmFyIGRvbUJ1aWxkZXIgPSBvcHRpb25zLmRvbUJ1aWxkZXIgfHwgbmV3IERPTUhhbmRsZXIoKTsvL2NvbnRlbnRIYW5kbGVyIGFuZCBMZXhpY2FsSGFuZGxlclxyXG5cdHZhciBlcnJvckhhbmRsZXIgPSBvcHRpb25zLmVycm9ySGFuZGxlcjtcclxuXHR2YXIgbG9jYXRvciA9IG9wdGlvbnMubG9jYXRvcjtcclxuXHR2YXIgZGVmYXVsdE5TTWFwID0gb3B0aW9ucy54bWxuc3x8e307XHJcblx0dmFyIGVudGl0eU1hcCA9IHsnbHQnOic8JywnZ3QnOic+JywnYW1wJzonJicsJ3F1b3QnOidcIicsJ2Fwb3MnOlwiJ1wifVxyXG5cdGlmKGxvY2F0b3Ipe1xyXG5cdFx0ZG9tQnVpbGRlci5zZXREb2N1bWVudExvY2F0b3IobG9jYXRvcilcclxuXHR9XHJcblx0XHJcblx0c2F4LmVycm9ySGFuZGxlciA9IGJ1aWxkRXJyb3JIYW5kbGVyKGVycm9ySGFuZGxlcixkb21CdWlsZGVyLGxvY2F0b3IpO1xyXG5cdHNheC5kb21CdWlsZGVyID0gb3B0aW9ucy5kb21CdWlsZGVyIHx8IGRvbUJ1aWxkZXI7XHJcblx0aWYoL1xcL3g/aHRtbD8kLy50ZXN0KG1pbWVUeXBlKSl7XHJcblx0XHRlbnRpdHlNYXAubmJzcCA9ICdcXHhhMCc7XHJcblx0XHRlbnRpdHlNYXAuY29weSA9ICdcXHhhOSc7XHJcblx0XHRkZWZhdWx0TlNNYXBbJyddPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XHJcblx0fVxyXG5cdGlmKHNvdXJjZSl7XHJcblx0XHRzYXgucGFyc2Uoc291cmNlLGRlZmF1bHROU01hcCxlbnRpdHlNYXApO1xyXG5cdH1lbHNle1xyXG5cdFx0c2F4LmVycm9ySGFuZGxlci5lcnJvcihcImludmFsaWQgZG9jdW1lbnQgc291cmNlXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gZG9tQnVpbGRlci5kb2N1bWVudDtcclxufVxyXG5mdW5jdGlvbiBidWlsZEVycm9ySGFuZGxlcihlcnJvckltcGwsZG9tQnVpbGRlcixsb2NhdG9yKXtcclxuXHRpZighZXJyb3JJbXBsKXtcclxuXHRcdGlmKGRvbUJ1aWxkZXIgaW5zdGFuY2VvZiBET01IYW5kbGVyKXtcclxuXHRcdFx0cmV0dXJuIGRvbUJ1aWxkZXI7XHJcblx0XHR9XHJcblx0XHRlcnJvckltcGwgPSBkb21CdWlsZGVyIDtcclxuXHR9XHJcblx0dmFyIGVycm9ySGFuZGxlciA9IHt9XHJcblx0dmFyIGlzQ2FsbGJhY2sgPSBlcnJvckltcGwgaW5zdGFuY2VvZiBGdW5jdGlvbjtcclxuXHRsb2NhdG9yID0gbG9jYXRvcnx8e31cclxuXHRmdW5jdGlvbiBidWlsZChrZXkpe1xyXG5cdFx0dmFyIGZuID0gZXJyb3JJbXBsW2tleV07XHJcblx0XHRpZighZm4pe1xyXG5cdFx0XHRpZihpc0NhbGxiYWNrKXtcclxuXHRcdFx0XHRmbiA9IGVycm9ySW1wbC5sZW5ndGggPT0gMj9mdW5jdGlvbihtc2cpe2Vycm9ySW1wbChrZXksbXNnKX06ZXJyb3JJbXBsO1xyXG5cdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHR2YXIgaT1hcmd1bWVudHMubGVuZ3RoO1xyXG5cdFx0XHRcdHdoaWxlKC0taSl7XHJcblx0XHRcdFx0XHRpZihmbiA9IGVycm9ySW1wbFthcmd1bWVudHNbaV1dKXtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRlcnJvckhhbmRsZXJba2V5XSA9IGZuICYmIGZ1bmN0aW9uKG1zZyl7XHJcblx0XHRcdGZuKG1zZytfbG9jYXRvcihsb2NhdG9yKSk7XHJcblx0XHR9fHxmdW5jdGlvbigpe307XHJcblx0fVxyXG5cdGJ1aWxkKCd3YXJuaW5nJywnd2FybicpO1xyXG5cdGJ1aWxkKCdlcnJvcicsJ3dhcm4nLCd3YXJuaW5nJyk7XHJcblx0YnVpbGQoJ2ZhdGFsRXJyb3InLCd3YXJuJywnd2FybmluZycsJ2Vycm9yJyk7XHJcblx0cmV0dXJuIGVycm9ySGFuZGxlcjtcclxufVxyXG4vKipcclxuICogK0NvbnRlbnRIYW5kbGVyK0Vycm9ySGFuZGxlclxyXG4gKiArTGV4aWNhbEhhbmRsZXIrRW50aXR5UmVzb2x2ZXIyXHJcbiAqIC1EZWNsSGFuZGxlci1EVERIYW5kbGVyIFxyXG4gKiBcclxuICogRGVmYXVsdEhhbmRsZXI6RW50aXR5UmVzb2x2ZXIsIERUREhhbmRsZXIsIENvbnRlbnRIYW5kbGVyLCBFcnJvckhhbmRsZXJcclxuICogRGVmYXVsdEhhbmRsZXIyOkRlZmF1bHRIYW5kbGVyLExleGljYWxIYW5kbGVyLCBEZWNsSGFuZGxlciwgRW50aXR5UmVzb2x2ZXIyXHJcbiAqIEBsaW5rIGh0dHA6Ly93d3cuc2F4cHJvamVjdC5vcmcvYXBpZG9jL29yZy94bWwvc2F4L2hlbHBlcnMvRGVmYXVsdEhhbmRsZXIuaHRtbFxyXG4gKi9cclxuZnVuY3Rpb24gRE9NSGFuZGxlcigpIHtcclxuICAgIHRoaXMuY2RhdGEgPSBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBwb3NpdGlvbihsb2NhdG9yLG5vZGUpe1xyXG5cdG5vZGUubGluZU51bWJlciA9IGxvY2F0b3IubGluZU51bWJlcjtcclxuXHRub2RlLmNvbHVtbk51bWJlciA9IGxvY2F0b3IuY29sdW1uTnVtYmVyO1xyXG59XHJcbi8qKlxyXG4gKiBAc2VlIG9yZy54bWwuc2F4LkNvbnRlbnRIYW5kbGVyI3N0YXJ0RG9jdW1lbnRcclxuICogQGxpbmsgaHR0cDovL3d3dy5zYXhwcm9qZWN0Lm9yZy9hcGlkb2Mvb3JnL3htbC9zYXgvQ29udGVudEhhbmRsZXIuaHRtbFxyXG4gKi8gXHJcbkRPTUhhbmRsZXIucHJvdG90eXBlID0ge1xyXG5cdHN0YXJ0RG9jdW1lbnQgOiBmdW5jdGlvbigpIHtcclxuICAgIFx0dGhpcy5kb2N1bWVudCA9IG5ldyBET01JbXBsZW1lbnRhdGlvbigpLmNyZWF0ZURvY3VtZW50KG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgXHRpZiAodGhpcy5sb2NhdG9yKSB7XHJcbiAgICAgICAgXHR0aGlzLmRvY3VtZW50LmRvY3VtZW50VVJJID0gdGhpcy5sb2NhdG9yLnN5c3RlbUlkO1xyXG4gICAgXHR9XHJcblx0fSxcclxuXHRzdGFydEVsZW1lbnQ6ZnVuY3Rpb24obmFtZXNwYWNlVVJJLCBsb2NhbE5hbWUsIHFOYW1lLCBhdHRycykge1xyXG5cdFx0dmFyIGRvYyA9IHRoaXMuZG9jdW1lbnQ7XHJcblx0ICAgIHZhciBlbCA9IGRvYy5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCBxTmFtZXx8bG9jYWxOYW1lKTtcclxuXHQgICAgdmFyIGxlbiA9IGF0dHJzLmxlbmd0aDtcclxuXHQgICAgYXBwZW5kRWxlbWVudCh0aGlzLCBlbCk7XHJcblx0ICAgIHRoaXMuY3VycmVudEVsZW1lbnQgPSBlbDtcclxuXHQgICAgXHJcblx0XHR0aGlzLmxvY2F0b3IgJiYgcG9zaXRpb24odGhpcy5sb2NhdG9yLGVsKVxyXG5cdCAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBsZW47IGkrKykge1xyXG5cdCAgICAgICAgdmFyIG5hbWVzcGFjZVVSSSA9IGF0dHJzLmdldFVSSShpKTtcclxuXHQgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzLmdldFZhbHVlKGkpO1xyXG5cdCAgICAgICAgdmFyIHFOYW1lID0gYXR0cnMuZ2V0UU5hbWUoaSk7XHJcblx0XHRcdHZhciBhdHRyID0gZG9jLmNyZWF0ZUF0dHJpYnV0ZU5TKG5hbWVzcGFjZVVSSSwgcU5hbWUpO1xyXG5cdFx0XHRpZiggYXR0ci5nZXRPZmZzZXQpe1xyXG5cdFx0XHRcdHBvc2l0aW9uKGF0dHIuZ2V0T2Zmc2V0KDEpLGF0dHIpXHJcblx0XHRcdH1cclxuXHRcdFx0YXR0ci52YWx1ZSA9IGF0dHIubm9kZVZhbHVlID0gdmFsdWU7XHJcblx0XHRcdGVsLnNldEF0dHJpYnV0ZU5vZGUoYXR0cilcclxuXHQgICAgfVxyXG5cdH0sXHJcblx0ZW5kRWxlbWVudDpmdW5jdGlvbihuYW1lc3BhY2VVUkksIGxvY2FsTmFtZSwgcU5hbWUpIHtcclxuXHRcdHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50RWxlbWVudFxyXG5cdCAgICB2YXIgdGFnTmFtZSA9IGN1cnJlbnQudGFnTmFtZTtcclxuXHQgICAgdGhpcy5jdXJyZW50RWxlbWVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcclxuXHR9LFxyXG5cdHN0YXJ0UHJlZml4TWFwcGluZzpmdW5jdGlvbihwcmVmaXgsIHVyaSkge1xyXG5cdH0sXHJcblx0ZW5kUHJlZml4TWFwcGluZzpmdW5jdGlvbihwcmVmaXgpIHtcclxuXHR9LFxyXG5cdHByb2Nlc3NpbmdJbnN0cnVjdGlvbjpmdW5jdGlvbih0YXJnZXQsIGRhdGEpIHtcclxuXHQgICAgdmFyIGlucyA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlUHJvY2Vzc2luZ0luc3RydWN0aW9uKHRhcmdldCwgZGF0YSk7XHJcblx0ICAgIHRoaXMubG9jYXRvciAmJiBwb3NpdGlvbih0aGlzLmxvY2F0b3IsaW5zKVxyXG5cdCAgICBhcHBlbmRFbGVtZW50KHRoaXMsIGlucyk7XHJcblx0fSxcclxuXHRpZ25vcmFibGVXaGl0ZXNwYWNlOmZ1bmN0aW9uKGNoLCBzdGFydCwgbGVuZ3RoKSB7XHJcblx0fSxcclxuXHRjaGFyYWN0ZXJzOmZ1bmN0aW9uKGNoYXJzLCBzdGFydCwgbGVuZ3RoKSB7XHJcblx0XHRjaGFycyA9IF90b1N0cmluZy5hcHBseSh0aGlzLGFyZ3VtZW50cylcclxuXHRcdC8vY29uc29sZS5sb2coY2hhcnMpXHJcblx0XHRpZih0aGlzLmN1cnJlbnRFbGVtZW50ICYmIGNoYXJzKXtcclxuXHRcdFx0aWYgKHRoaXMuY2RhdGEpIHtcclxuXHRcdFx0XHR2YXIgY2hhck5vZGUgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUNEQVRBU2VjdGlvbihjaGFycyk7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50RWxlbWVudC5hcHBlbmRDaGlsZChjaGFyTm9kZSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGNoYXJOb2RlID0gdGhpcy5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGFycyk7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50RWxlbWVudC5hcHBlbmRDaGlsZChjaGFyTm9kZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5sb2NhdG9yICYmIHBvc2l0aW9uKHRoaXMubG9jYXRvcixjaGFyTm9kZSlcclxuXHRcdH1cclxuXHR9LFxyXG5cdHNraXBwZWRFbnRpdHk6ZnVuY3Rpb24obmFtZSkge1xyXG5cdH0sXHJcblx0ZW5kRG9jdW1lbnQ6ZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLmRvY3VtZW50Lm5vcm1hbGl6ZSgpO1xyXG5cdH0sXHJcblx0c2V0RG9jdW1lbnRMb2NhdG9yOmZ1bmN0aW9uIChsb2NhdG9yKSB7XHJcblx0ICAgIGlmKHRoaXMubG9jYXRvciA9IGxvY2F0b3Ipey8vICYmICEoJ2xpbmVOdW1iZXInIGluIGxvY2F0b3IpKXtcclxuXHQgICAgXHRsb2NhdG9yLmxpbmVOdW1iZXIgPSAwO1xyXG5cdCAgICB9XHJcblx0fSxcclxuXHQvL0xleGljYWxIYW5kbGVyXHJcblx0Y29tbWVudDpmdW5jdGlvbihjaGFycywgc3RhcnQsIGxlbmd0aCkge1xyXG5cdFx0Y2hhcnMgPSBfdG9TdHJpbmcuYXBwbHkodGhpcyxhcmd1bWVudHMpXHJcblx0ICAgIHZhciBjb21tID0gdGhpcy5kb2N1bWVudC5jcmVhdGVDb21tZW50KGNoYXJzKTtcclxuXHQgICAgdGhpcy5sb2NhdG9yICYmIHBvc2l0aW9uKHRoaXMubG9jYXRvcixjb21tKVxyXG5cdCAgICBhcHBlbmRFbGVtZW50KHRoaXMsIGNvbW0pO1xyXG5cdH0sXHJcblx0XHJcblx0c3RhcnRDREFUQTpmdW5jdGlvbigpIHtcclxuXHQgICAgLy91c2VkIGluIGNoYXJhY3RlcnMoKSBtZXRob2RzXHJcblx0ICAgIHRoaXMuY2RhdGEgPSB0cnVlO1xyXG5cdH0sXHJcblx0ZW5kQ0RBVEE6ZnVuY3Rpb24oKSB7XHJcblx0ICAgIHRoaXMuY2RhdGEgPSBmYWxzZTtcclxuXHR9LFxyXG5cdFxyXG5cdHN0YXJ0RFREOmZ1bmN0aW9uKG5hbWUsIHB1YmxpY0lkLCBzeXN0ZW1JZCkge1xyXG5cdFx0dmFyIGltcGwgPSB0aGlzLmRvY3VtZW50LmltcGxlbWVudGF0aW9uO1xyXG5cdCAgICBpZiAoaW1wbCAmJiBpbXBsLmNyZWF0ZURvY3VtZW50VHlwZSkge1xyXG5cdCAgICAgICAgdmFyIGR0ID0gaW1wbC5jcmVhdGVEb2N1bWVudFR5cGUobmFtZSwgcHVibGljSWQsIHN5c3RlbUlkKTtcclxuXHQgICAgICAgIHRoaXMubG9jYXRvciAmJiBwb3NpdGlvbih0aGlzLmxvY2F0b3IsZHQpXHJcblx0ICAgICAgICBhcHBlbmRFbGVtZW50KHRoaXMsIGR0KTtcclxuXHQgICAgfVxyXG5cdH0sXHJcblx0LyoqXHJcblx0ICogQHNlZSBvcmcueG1sLnNheC5FcnJvckhhbmRsZXJcclxuXHQgKiBAbGluayBodHRwOi8vd3d3LnNheHByb2plY3Qub3JnL2FwaWRvYy9vcmcveG1sL3NheC9FcnJvckhhbmRsZXIuaHRtbFxyXG5cdCAqL1xyXG5cdHdhcm5pbmc6ZnVuY3Rpb24oZXJyb3IpIHtcclxuXHRcdGNvbnNvbGUud2FybihlcnJvcixfbG9jYXRvcih0aGlzLmxvY2F0b3IpKTtcclxuXHR9LFxyXG5cdGVycm9yOmZ1bmN0aW9uKGVycm9yKSB7XHJcblx0XHRjb25zb2xlLmVycm9yKGVycm9yLF9sb2NhdG9yKHRoaXMubG9jYXRvcikpO1xyXG5cdH0sXHJcblx0ZmF0YWxFcnJvcjpmdW5jdGlvbihlcnJvcikge1xyXG5cdFx0Y29uc29sZS5lcnJvcihlcnJvcixfbG9jYXRvcih0aGlzLmxvY2F0b3IpKTtcclxuXHQgICAgdGhyb3cgZXJyb3I7XHJcblx0fVxyXG59XHJcbmZ1bmN0aW9uIF9sb2NhdG9yKGwpe1xyXG5cdGlmKGwpe1xyXG5cdFx0cmV0dXJuICdcXG5AJysobC5zeXN0ZW1JZCB8fCcnKSsnI1tsaW5lOicrbC5saW5lTnVtYmVyKycsY29sOicrbC5jb2x1bW5OdW1iZXIrJ10nXHJcblx0fVxyXG59XHJcbmZ1bmN0aW9uIF90b1N0cmluZyhjaGFycyxzdGFydCxsZW5ndGgpe1xyXG5cdGlmKHR5cGVvZiBjaGFycyA9PSAnc3RyaW5nJyl7XHJcblx0XHRyZXR1cm4gY2hhcnMuc3Vic3RyKHN0YXJ0LGxlbmd0aClcclxuXHR9ZWxzZXsvL2phdmEgc2F4IGNvbm5lY3Qgd2lkdGggeG1sZG9tIG9uIHJoaW5vKHdoYXQgYWJvdXQ6IFwiPyAmJiAhKGNoYXJzIGluc3RhbmNlb2YgU3RyaW5nKVwiKVxyXG5cdFx0aWYoY2hhcnMubGVuZ3RoID49IHN0YXJ0K2xlbmd0aCB8fCBzdGFydCl7XHJcblx0XHRcdHJldHVybiBuZXcgamF2YS5sYW5nLlN0cmluZyhjaGFycyxzdGFydCxsZW5ndGgpKycnO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNoYXJzO1xyXG5cdH1cclxufVxyXG5cclxuLypcclxuICogQGxpbmsgaHR0cDovL3d3dy5zYXhwcm9qZWN0Lm9yZy9hcGlkb2Mvb3JnL3htbC9zYXgvZXh0L0xleGljYWxIYW5kbGVyLmh0bWxcclxuICogdXNlZCBtZXRob2Qgb2Ygb3JnLnhtbC5zYXguZXh0LkxleGljYWxIYW5kbGVyOlxyXG4gKiAgI2NvbW1lbnQoY2hhcnMsIHN0YXJ0LCBsZW5ndGgpXHJcbiAqICAjc3RhcnRDREFUQSgpXHJcbiAqICAjZW5kQ0RBVEEoKVxyXG4gKiAgI3N0YXJ0RFREKG5hbWUsIHB1YmxpY0lkLCBzeXN0ZW1JZClcclxuICpcclxuICpcclxuICogSUdOT1JFRCBtZXRob2Qgb2Ygb3JnLnhtbC5zYXguZXh0LkxleGljYWxIYW5kbGVyOlxyXG4gKiAgI2VuZERURCgpXHJcbiAqICAjc3RhcnRFbnRpdHkobmFtZSlcclxuICogICNlbmRFbnRpdHkobmFtZSlcclxuICpcclxuICpcclxuICogQGxpbmsgaHR0cDovL3d3dy5zYXhwcm9qZWN0Lm9yZy9hcGlkb2Mvb3JnL3htbC9zYXgvZXh0L0RlY2xIYW5kbGVyLmh0bWxcclxuICogSUdOT1JFRCBtZXRob2Qgb2Ygb3JnLnhtbC5zYXguZXh0LkRlY2xIYW5kbGVyXHJcbiAqIFx0I2F0dHJpYnV0ZURlY2woZU5hbWUsIGFOYW1lLCB0eXBlLCBtb2RlLCB2YWx1ZSlcclxuICogICNlbGVtZW50RGVjbChuYW1lLCBtb2RlbClcclxuICogICNleHRlcm5hbEVudGl0eURlY2wobmFtZSwgcHVibGljSWQsIHN5c3RlbUlkKVxyXG4gKiAgI2ludGVybmFsRW50aXR5RGVjbChuYW1lLCB2YWx1ZSlcclxuICogQGxpbmsgaHR0cDovL3d3dy5zYXhwcm9qZWN0Lm9yZy9hcGlkb2Mvb3JnL3htbC9zYXgvZXh0L0VudGl0eVJlc29sdmVyMi5odG1sXHJcbiAqIElHTk9SRUQgbWV0aG9kIG9mIG9yZy54bWwuc2F4LkVudGl0eVJlc29sdmVyMlxyXG4gKiAgI3Jlc29sdmVFbnRpdHkoU3RyaW5nIG5hbWUsU3RyaW5nIHB1YmxpY0lkLFN0cmluZyBiYXNlVVJJLFN0cmluZyBzeXN0ZW1JZClcclxuICogICNyZXNvbHZlRW50aXR5KHB1YmxpY0lkLCBzeXN0ZW1JZClcclxuICogICNnZXRFeHRlcm5hbFN1YnNldChuYW1lLCBiYXNlVVJJKVxyXG4gKiBAbGluayBodHRwOi8vd3d3LnNheHByb2plY3Qub3JnL2FwaWRvYy9vcmcveG1sL3NheC9EVERIYW5kbGVyLmh0bWxcclxuICogSUdOT1JFRCBtZXRob2Qgb2Ygb3JnLnhtbC5zYXguRFRESGFuZGxlclxyXG4gKiAgI25vdGF0aW9uRGVjbChuYW1lLCBwdWJsaWNJZCwgc3lzdGVtSWQpIHt9O1xyXG4gKiAgI3VucGFyc2VkRW50aXR5RGVjbChuYW1lLCBwdWJsaWNJZCwgc3lzdGVtSWQsIG5vdGF0aW9uTmFtZSkge307XHJcbiAqL1xyXG5cImVuZERURCxzdGFydEVudGl0eSxlbmRFbnRpdHksYXR0cmlidXRlRGVjbCxlbGVtZW50RGVjbCxleHRlcm5hbEVudGl0eURlY2wsaW50ZXJuYWxFbnRpdHlEZWNsLHJlc29sdmVFbnRpdHksZ2V0RXh0ZXJuYWxTdWJzZXQsbm90YXRpb25EZWNsLHVucGFyc2VkRW50aXR5RGVjbFwiLnJlcGxhY2UoL1xcdysvZyxmdW5jdGlvbihrZXkpe1xyXG5cdERPTUhhbmRsZXIucHJvdG90eXBlW2tleV0gPSBmdW5jdGlvbigpe3JldHVybiBudWxsfVxyXG59KVxyXG5cclxuLyogUHJpdmF0ZSBzdGF0aWMgaGVscGVycyB0cmVhdGVkIGJlbG93IGFzIHByaXZhdGUgaW5zdGFuY2UgbWV0aG9kcywgc28gZG9uJ3QgbmVlZCB0byBhZGQgdGhlc2UgdG8gdGhlIHB1YmxpYyBBUEk7IHdlIG1pZ2h0IHVzZSBhIFJlbGF0b3IgdG8gYWxzbyBnZXQgcmlkIG9mIG5vbi1zdGFuZGFyZCBwdWJsaWMgcHJvcGVydGllcyAqL1xyXG5mdW5jdGlvbiBhcHBlbmRFbGVtZW50IChoYW5kZXIsbm9kZSkge1xyXG4gICAgaWYgKCFoYW5kZXIuY3VycmVudEVsZW1lbnQpIHtcclxuICAgICAgICBoYW5kZXIuZG9jdW1lbnQuYXBwZW5kQ2hpbGQobm9kZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGhhbmRlci5jdXJyZW50RWxlbWVudC5hcHBlbmRDaGlsZChub2RlKTtcclxuICAgIH1cclxufS8vYXBwZW5kQ2hpbGQgYW5kIHNldEF0dHJpYnV0ZU5TIGFyZSBwcmVmb3JtYW5jZSBrZXlcclxuXHJcbmlmKHR5cGVvZiByZXF1aXJlID09ICdmdW5jdGlvbicpe1xyXG5cdHZhciBYTUxSZWFkZXIgPSByZXF1aXJlKCcuL3NheCcpLlhNTFJlYWRlcjtcclxuXHR2YXIgRE9NSW1wbGVtZW50YXRpb24gPSBleHBvcnRzLkRPTUltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9kb20nKS5ET01JbXBsZW1lbnRhdGlvbjtcclxuXHRleHBvcnRzLlhNTFNlcmlhbGl6ZXIgPSByZXF1aXJlKCcuL2RvbScpLlhNTFNlcmlhbGl6ZXIgO1xyXG5cdGV4cG9ydHMuRE9NUGFyc2VyID0gRE9NUGFyc2VyO1xyXG59XHJcbiIsIi8qXG4gKiBET00gTGV2ZWwgMlxuICogT2JqZWN0IERPTUV4Y2VwdGlvblxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMtRE9NLUxldmVsLTEvZWNtYS1zY3JpcHQtbGFuZ3VhZ2UtYmluZGluZy5odG1sXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDAvUkVDLURPTS1MZXZlbC0yLUNvcmUtMjAwMDExMTMvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG4gKi9cblxuZnVuY3Rpb24gY29weShzcmMsZGVzdCl7XG5cdGZvcih2YXIgcCBpbiBzcmMpe1xuXHRcdGRlc3RbcF0gPSBzcmNbcF07XG5cdH1cbn1cbi8qKlxuXlxcdytcXC5wcm90b3R5cGVcXC4oW19cXHddKylcXHMqPVxccyooKD86LipcXHtcXHMqP1tcXHJcXG5dW1xcc1xcU10qP159KXxcXFMuKj8oPz1bO1xcclxcbl0pKTs/XG5eXFx3K1xcLnByb3RvdHlwZVxcLihbX1xcd10rKVxccyo9XFxzKihcXFMuKj8oPz1bO1xcclxcbl0pKTs/XG4gKi9cbmZ1bmN0aW9uIF9leHRlbmRzKENsYXNzLFN1cGVyKXtcblx0dmFyIHB0ID0gQ2xhc3MucHJvdG90eXBlO1xuXHRpZihPYmplY3QuY3JlYXRlKXtcblx0XHR2YXIgcHB0ID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpXG5cdFx0cHQuX19wcm90b19fID0gcHB0O1xuXHR9XG5cdGlmKCEocHQgaW5zdGFuY2VvZiBTdXBlcikpe1xuXHRcdGZ1bmN0aW9uIHQoKXt9O1xuXHRcdHQucHJvdG90eXBlID0gU3VwZXIucHJvdG90eXBlO1xuXHRcdHQgPSBuZXcgdCgpO1xuXHRcdGNvcHkocHQsdCk7XG5cdFx0Q2xhc3MucHJvdG90eXBlID0gcHQgPSB0O1xuXHR9XG5cdGlmKHB0LmNvbnN0cnVjdG9yICE9IENsYXNzKXtcblx0XHRpZih0eXBlb2YgQ2xhc3MgIT0gJ2Z1bmN0aW9uJyl7XG5cdFx0XHRjb25zb2xlLmVycm9yKFwidW5rbm93IENsYXNzOlwiK0NsYXNzKVxuXHRcdH1cblx0XHRwdC5jb25zdHJ1Y3RvciA9IENsYXNzXG5cdH1cbn1cbnZhciBodG1sbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcgO1xuLy8gTm9kZSBUeXBlc1xudmFyIE5vZGVUeXBlID0ge31cbnZhciBFTEVNRU5UX05PREUgICAgICAgICAgICAgICAgPSBOb2RlVHlwZS5FTEVNRU5UX05PREUgICAgICAgICAgICAgICAgPSAxO1xudmFyIEFUVFJJQlVURV9OT0RFICAgICAgICAgICAgICA9IE5vZGVUeXBlLkFUVFJJQlVURV9OT0RFICAgICAgICAgICAgICA9IDI7XG52YXIgVEVYVF9OT0RFICAgICAgICAgICAgICAgICAgID0gTm9kZVR5cGUuVEVYVF9OT0RFICAgICAgICAgICAgICAgICAgID0gMztcbnZhciBDREFUQV9TRUNUSU9OX05PREUgICAgICAgICAgPSBOb2RlVHlwZS5DREFUQV9TRUNUSU9OX05PREUgICAgICAgICAgPSA0O1xudmFyIEVOVElUWV9SRUZFUkVOQ0VfTk9ERSAgICAgICA9IE5vZGVUeXBlLkVOVElUWV9SRUZFUkVOQ0VfTk9ERSAgICAgICA9IDU7XG52YXIgRU5USVRZX05PREUgICAgICAgICAgICAgICAgID0gTm9kZVR5cGUuRU5USVRZX05PREUgICAgICAgICAgICAgICAgID0gNjtcbnZhciBQUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREUgPSBOb2RlVHlwZS5QUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREUgPSA3O1xudmFyIENPTU1FTlRfTk9ERSAgICAgICAgICAgICAgICA9IE5vZGVUeXBlLkNPTU1FTlRfTk9ERSAgICAgICAgICAgICAgICA9IDg7XG52YXIgRE9DVU1FTlRfTk9ERSAgICAgICAgICAgICAgID0gTm9kZVR5cGUuRE9DVU1FTlRfTk9ERSAgICAgICAgICAgICAgID0gOTtcbnZhciBET0NVTUVOVF9UWVBFX05PREUgICAgICAgICAgPSBOb2RlVHlwZS5ET0NVTUVOVF9UWVBFX05PREUgICAgICAgICAgPSAxMDtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFICAgICAgPSBOb2RlVHlwZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICAgICAgPSAxMTtcbnZhciBOT1RBVElPTl9OT0RFICAgICAgICAgICAgICAgPSBOb2RlVHlwZS5OT1RBVElPTl9OT0RFICAgICAgICAgICAgICAgPSAxMjtcblxuLy8gRXhjZXB0aW9uQ29kZVxudmFyIEV4Y2VwdGlvbkNvZGUgPSB7fVxudmFyIEV4Y2VwdGlvbk1lc3NhZ2UgPSB7fTtcbnZhciBJTkRFWF9TSVpFX0VSUiAgICAgICAgICAgICAgPSBFeGNlcHRpb25Db2RlLklOREVYX1NJWkVfRVJSICAgICAgICAgICAgICA9ICgoRXhjZXB0aW9uTWVzc2FnZVsxXT1cIkluZGV4IHNpemUgZXJyb3JcIiksMSk7XG52YXIgRE9NU1RSSU5HX1NJWkVfRVJSICAgICAgICAgID0gRXhjZXB0aW9uQ29kZS5ET01TVFJJTkdfU0laRV9FUlIgICAgICAgICAgPSAoKEV4Y2VwdGlvbk1lc3NhZ2VbMl09XCJET01TdHJpbmcgc2l6ZSBlcnJvclwiKSwyKTtcbnZhciBISUVSQVJDSFlfUkVRVUVTVF9FUlIgICAgICAgPSBFeGNlcHRpb25Db2RlLkhJRVJBUkNIWV9SRVFVRVNUX0VSUiAgICAgICA9ICgoRXhjZXB0aW9uTWVzc2FnZVszXT1cIkhpZXJhcmNoeSByZXF1ZXN0IGVycm9yXCIpLDMpO1xudmFyIFdST05HX0RPQ1VNRU5UX0VSUiAgICAgICAgICA9IEV4Y2VwdGlvbkNvZGUuV1JPTkdfRE9DVU1FTlRfRVJSICAgICAgICAgID0gKChFeGNlcHRpb25NZXNzYWdlWzRdPVwiV3JvbmcgZG9jdW1lbnRcIiksNCk7XG52YXIgSU5WQUxJRF9DSEFSQUNURVJfRVJSICAgICAgID0gRXhjZXB0aW9uQ29kZS5JTlZBTElEX0NIQVJBQ1RFUl9FUlIgICAgICAgPSAoKEV4Y2VwdGlvbk1lc3NhZ2VbNV09XCJJbnZhbGlkIGNoYXJhY3RlclwiKSw1KTtcbnZhciBOT19EQVRBX0FMTE9XRURfRVJSICAgICAgICAgPSBFeGNlcHRpb25Db2RlLk5PX0RBVEFfQUxMT1dFRF9FUlIgICAgICAgICA9ICgoRXhjZXB0aW9uTWVzc2FnZVs2XT1cIk5vIGRhdGEgYWxsb3dlZFwiKSw2KTtcbnZhciBOT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlIgPSBFeGNlcHRpb25Db2RlLk5PX01PRElGSUNBVElPTl9BTExPV0VEX0VSUiA9ICgoRXhjZXB0aW9uTWVzc2FnZVs3XT1cIk5vIG1vZGlmaWNhdGlvbiBhbGxvd2VkXCIpLDcpO1xudmFyIE5PVF9GT1VORF9FUlIgICAgICAgICAgICAgICA9IEV4Y2VwdGlvbkNvZGUuTk9UX0ZPVU5EX0VSUiAgICAgICAgICAgICAgID0gKChFeGNlcHRpb25NZXNzYWdlWzhdPVwiTm90IGZvdW5kXCIpLDgpO1xudmFyIE5PVF9TVVBQT1JURURfRVJSICAgICAgICAgICA9IEV4Y2VwdGlvbkNvZGUuTk9UX1NVUFBPUlRFRF9FUlIgICAgICAgICAgID0gKChFeGNlcHRpb25NZXNzYWdlWzldPVwiTm90IHN1cHBvcnRlZFwiKSw5KTtcbnZhciBJTlVTRV9BVFRSSUJVVEVfRVJSICAgICAgICAgPSBFeGNlcHRpb25Db2RlLklOVVNFX0FUVFJJQlVURV9FUlIgICAgICAgICA9ICgoRXhjZXB0aW9uTWVzc2FnZVsxMF09XCJBdHRyaWJ1dGUgaW4gdXNlXCIpLDEwKTtcbi8vbGV2ZWwyXG52YXIgSU5WQUxJRF9TVEFURV9FUlIgICAgICAgIFx0PSBFeGNlcHRpb25Db2RlLklOVkFMSURfU1RBVEVfRVJSICAgICAgICBcdD0gKChFeGNlcHRpb25NZXNzYWdlWzExXT1cIkludmFsaWQgc3RhdGVcIiksMTEpO1xudmFyIFNZTlRBWF9FUlIgICAgICAgICAgICAgICBcdD0gRXhjZXB0aW9uQ29kZS5TWU5UQVhfRVJSICAgICAgICAgICAgICAgXHQ9ICgoRXhjZXB0aW9uTWVzc2FnZVsxMl09XCJTeW50YXggZXJyb3JcIiksMTIpO1xudmFyIElOVkFMSURfTU9ESUZJQ0FUSU9OX0VSUiBcdD0gRXhjZXB0aW9uQ29kZS5JTlZBTElEX01PRElGSUNBVElPTl9FUlIgXHQ9ICgoRXhjZXB0aW9uTWVzc2FnZVsxM109XCJJbnZhbGlkIG1vZGlmaWNhdGlvblwiKSwxMyk7XG52YXIgTkFNRVNQQUNFX0VSUiAgICAgICAgICAgIFx0PSBFeGNlcHRpb25Db2RlLk5BTUVTUEFDRV9FUlIgICAgICAgICAgIFx0PSAoKEV4Y2VwdGlvbk1lc3NhZ2VbMTRdPVwiSW52YWxpZCBuYW1lc3BhY2VcIiksMTQpO1xudmFyIElOVkFMSURfQUNDRVNTX0VSUiAgICAgICBcdD0gRXhjZXB0aW9uQ29kZS5JTlZBTElEX0FDQ0VTU19FUlIgICAgICBcdD0gKChFeGNlcHRpb25NZXNzYWdlWzE1XT1cIkludmFsaWQgYWNjZXNzXCIpLDE1KTtcblxuXG5mdW5jdGlvbiBET01FeGNlcHRpb24oY29kZSwgbWVzc2FnZSkge1xuXHRpZihtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3Ipe1xuXHRcdHZhciBlcnJvciA9IG1lc3NhZ2U7XG5cdH1lbHNle1xuXHRcdGVycm9yID0gdGhpcztcblx0XHRFcnJvci5jYWxsKHRoaXMsIEV4Y2VwdGlvbk1lc3NhZ2VbY29kZV0pO1xuXHRcdHRoaXMubWVzc2FnZSA9IEV4Y2VwdGlvbk1lc3NhZ2VbY29kZV07XG5cdFx0aWYoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIERPTUV4Y2VwdGlvbik7XG5cdH1cblx0ZXJyb3IuY29kZSA9IGNvZGU7XG5cdGlmKG1lc3NhZ2UpIHRoaXMubWVzc2FnZSA9IHRoaXMubWVzc2FnZSArIFwiOiBcIiArIG1lc3NhZ2U7XG5cdHJldHVybiBlcnJvcjtcbn07XG5ET01FeGNlcHRpb24ucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuY29weShFeGNlcHRpb25Db2RlLERPTUV4Y2VwdGlvbilcbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAwL1JFQy1ET00tTGV2ZWwtMi1Db3JlLTIwMDAxMTEzL2NvcmUuaHRtbCNJRC01MzYyOTcxNzdcbiAqIFRoZSBOb2RlTGlzdCBpbnRlcmZhY2UgcHJvdmlkZXMgdGhlIGFic3RyYWN0aW9uIG9mIGFuIG9yZGVyZWQgY29sbGVjdGlvbiBvZiBub2Rlcywgd2l0aG91dCBkZWZpbmluZyBvciBjb25zdHJhaW5pbmcgaG93IHRoaXMgY29sbGVjdGlvbiBpcyBpbXBsZW1lbnRlZC4gTm9kZUxpc3Qgb2JqZWN0cyBpbiB0aGUgRE9NIGFyZSBsaXZlLlxuICogVGhlIGl0ZW1zIGluIHRoZSBOb2RlTGlzdCBhcmUgYWNjZXNzaWJsZSB2aWEgYW4gaW50ZWdyYWwgaW5kZXgsIHN0YXJ0aW5nIGZyb20gMC5cbiAqL1xuZnVuY3Rpb24gTm9kZUxpc3QoKSB7XG59O1xuTm9kZUxpc3QucHJvdG90eXBlID0ge1xuXHQvKipcblx0ICogVGhlIG51bWJlciBvZiBub2RlcyBpbiB0aGUgbGlzdC4gVGhlIHJhbmdlIG9mIHZhbGlkIGNoaWxkIG5vZGUgaW5kaWNlcyBpcyAwIHRvIGxlbmd0aC0xIGluY2x1c2l2ZS5cblx0ICogQHN0YW5kYXJkIGxldmVsMVxuXHQgKi9cblx0bGVuZ3RoOjAsIFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgaW5kZXh0aCBpdGVtIGluIHRoZSBjb2xsZWN0aW9uLiBJZiBpbmRleCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBub2RlcyBpbiB0aGUgbGlzdCwgdGhpcyByZXR1cm5zIG51bGwuXG5cdCAqIEBzdGFuZGFyZCBsZXZlbDFcblx0ICogQHBhcmFtIGluZGV4ICB1bnNpZ25lZCBsb25nIFxuXHQgKiAgIEluZGV4IGludG8gdGhlIGNvbGxlY3Rpb24uXG5cdCAqIEByZXR1cm4gTm9kZVxuXHQgKiBcdFRoZSBub2RlIGF0IHRoZSBpbmRleHRoIHBvc2l0aW9uIGluIHRoZSBOb2RlTGlzdCwgb3IgbnVsbCBpZiB0aGF0IGlzIG5vdCBhIHZhbGlkIGluZGV4LiBcblx0ICovXG5cdGl0ZW06IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXNbaW5kZXhdIHx8IG51bGw7XG5cdH1cbn07XG5mdW5jdGlvbiBMaXZlTm9kZUxpc3Qobm9kZSxyZWZyZXNoKXtcblx0dGhpcy5fbm9kZSA9IG5vZGU7XG5cdHRoaXMuX3JlZnJlc2ggPSByZWZyZXNoXG5cdF91cGRhdGVMaXZlTGlzdCh0aGlzKTtcbn1cbmZ1bmN0aW9uIF91cGRhdGVMaXZlTGlzdChsaXN0KXtcblx0dmFyIGluYyA9IGxpc3QuX25vZGUuX2luYyB8fCBsaXN0Ll9ub2RlLm93bmVyRG9jdW1lbnQuX2luYztcblx0aWYobGlzdC5faW5jICE9IGluYyl7XG5cdFx0dmFyIGxzID0gbGlzdC5fcmVmcmVzaChsaXN0Ll9ub2RlKTtcblx0XHQvL2NvbnNvbGUubG9nKGxzLmxlbmd0aClcblx0XHRfX3NldF9fKGxpc3QsJ2xlbmd0aCcsbHMubGVuZ3RoKTtcblx0XHRjb3B5KGxzLGxpc3QpO1xuXHRcdGxpc3QuX2luYyA9IGluYztcblx0fVxufVxuTGl2ZU5vZGVMaXN0LnByb3RvdHlwZS5pdGVtID0gZnVuY3Rpb24oaSl7XG5cdF91cGRhdGVMaXZlTGlzdCh0aGlzKTtcblx0cmV0dXJuIHRoaXNbaV07XG59XG5cbl9leHRlbmRzKExpdmVOb2RlTGlzdCxOb2RlTGlzdCk7XG4vKipcbiAqIFxuICogT2JqZWN0cyBpbXBsZW1lbnRpbmcgdGhlIE5hbWVkTm9kZU1hcCBpbnRlcmZhY2UgYXJlIHVzZWQgdG8gcmVwcmVzZW50IGNvbGxlY3Rpb25zIG9mIG5vZGVzIHRoYXQgY2FuIGJlIGFjY2Vzc2VkIGJ5IG5hbWUuIE5vdGUgdGhhdCBOYW1lZE5vZGVNYXAgZG9lcyBub3QgaW5oZXJpdCBmcm9tIE5vZGVMaXN0OyBOYW1lZE5vZGVNYXBzIGFyZSBub3QgbWFpbnRhaW5lZCBpbiBhbnkgcGFydGljdWxhciBvcmRlci4gT2JqZWN0cyBjb250YWluZWQgaW4gYW4gb2JqZWN0IGltcGxlbWVudGluZyBOYW1lZE5vZGVNYXAgbWF5IGFsc28gYmUgYWNjZXNzZWQgYnkgYW4gb3JkaW5hbCBpbmRleCwgYnV0IHRoaXMgaXMgc2ltcGx5IHRvIGFsbG93IGNvbnZlbmllbnQgZW51bWVyYXRpb24gb2YgdGhlIGNvbnRlbnRzIG9mIGEgTmFtZWROb2RlTWFwLCBhbmQgZG9lcyBub3QgaW1wbHkgdGhhdCB0aGUgRE9NIHNwZWNpZmllcyBhbiBvcmRlciB0byB0aGVzZSBOb2Rlcy5cbiAqIE5hbWVkTm9kZU1hcCBvYmplY3RzIGluIHRoZSBET00gYXJlIGxpdmUuXG4gKiB1c2VkIGZvciBhdHRyaWJ1dGVzIG9yIERvY3VtZW50VHlwZSBlbnRpdGllcyBcbiAqL1xuZnVuY3Rpb24gTmFtZWROb2RlTWFwKCkge1xufTtcblxuZnVuY3Rpb24gX2ZpbmROb2RlSW5kZXgobGlzdCxub2RlKXtcblx0dmFyIGkgPSBsaXN0Lmxlbmd0aDtcblx0d2hpbGUoaS0tKXtcblx0XHRpZihsaXN0W2ldID09PSBub2RlKXtyZXR1cm4gaX1cblx0fVxufVxuXG5mdW5jdGlvbiBfYWRkTmFtZWROb2RlKGVsLGxpc3QsbmV3QXR0cixvbGRBdHRyKXtcblx0aWYob2xkQXR0cil7XG5cdFx0bGlzdFtfZmluZE5vZGVJbmRleChsaXN0LG9sZEF0dHIpXSA9IG5ld0F0dHI7XG5cdH1lbHNle1xuXHRcdGxpc3RbbGlzdC5sZW5ndGgrK10gPSBuZXdBdHRyO1xuXHR9XG5cdGlmKGVsKXtcblx0XHRuZXdBdHRyLm93bmVyRWxlbWVudCA9IGVsO1xuXHRcdHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50O1xuXHRcdGlmKGRvYyl7XG5cdFx0XHRvbGRBdHRyICYmIF9vblJlbW92ZUF0dHJpYnV0ZShkb2MsZWwsb2xkQXR0cik7XG5cdFx0XHRfb25BZGRBdHRyaWJ1dGUoZG9jLGVsLG5ld0F0dHIpO1xuXHRcdH1cblx0fVxufVxuZnVuY3Rpb24gX3JlbW92ZU5hbWVkTm9kZShlbCxsaXN0LGF0dHIpe1xuXHR2YXIgaSA9IF9maW5kTm9kZUluZGV4KGxpc3QsYXR0cik7XG5cdGlmKGk+PTApe1xuXHRcdHZhciBsYXN0SW5kZXggPSBsaXN0Lmxlbmd0aC0xXG5cdFx0d2hpbGUoaTxsYXN0SW5kZXgpe1xuXHRcdFx0bGlzdFtpXSA9IGxpc3RbKytpXVxuXHRcdH1cblx0XHRsaXN0Lmxlbmd0aCA9IGxhc3RJbmRleDtcblx0XHRpZihlbCl7XG5cdFx0XHR2YXIgZG9jID0gZWwub3duZXJEb2N1bWVudDtcblx0XHRcdGlmKGRvYyl7XG5cdFx0XHRcdF9vblJlbW92ZUF0dHJpYnV0ZShkb2MsZWwsYXR0cik7XG5cdFx0XHRcdGF0dHIub3duZXJFbGVtZW50ID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH1lbHNle1xuXHRcdHRocm93IERPTUV4Y2VwdGlvbihOT1RfRk9VTkRfRVJSLG5ldyBFcnJvcigpKVxuXHR9XG59XG5OYW1lZE5vZGVNYXAucHJvdG90eXBlID0ge1xuXHRsZW5ndGg6MCxcblx0aXRlbTpOb2RlTGlzdC5wcm90b3R5cGUuaXRlbSxcblx0Z2V0TmFtZWRJdGVtOiBmdW5jdGlvbihrZXkpIHtcbi8vXHRcdGlmKGtleS5pbmRleE9mKCc6Jyk+MCB8fCBrZXkgPT0gJ3htbG5zJyl7XG4vL1x0XHRcdHJldHVybiBudWxsO1xuLy9cdFx0fVxuXHRcdHZhciBpID0gdGhpcy5sZW5ndGg7XG5cdFx0d2hpbGUoaS0tKXtcblx0XHRcdHZhciBhdHRyID0gdGhpc1tpXTtcblx0XHRcdGlmKGF0dHIubm9kZU5hbWUgPT0ga2V5KXtcblx0XHRcdFx0cmV0dXJuIGF0dHI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRzZXROYW1lZEl0ZW06IGZ1bmN0aW9uKGF0dHIpIHtcblx0XHR2YXIgZWwgPSBhdHRyLm93bmVyRWxlbWVudDtcblx0XHRpZihlbCAmJiBlbCE9dGhpcy5fb3duZXJFbGVtZW50KXtcblx0XHRcdHRocm93IG5ldyBET01FeGNlcHRpb24oSU5VU0VfQVRUUklCVVRFX0VSUik7XG5cdFx0fVxuXHRcdHZhciBvbGRBdHRyID0gdGhpcy5nZXROYW1lZEl0ZW0oYXR0ci5ub2RlTmFtZSk7XG5cdFx0X2FkZE5hbWVkTm9kZSh0aGlzLl9vd25lckVsZW1lbnQsdGhpcyxhdHRyLG9sZEF0dHIpO1xuXHRcdHJldHVybiBvbGRBdHRyO1xuXHR9LFxuXHQvKiByZXR1cm5zIE5vZGUgKi9cblx0c2V0TmFtZWRJdGVtTlM6IGZ1bmN0aW9uKGF0dHIpIHsvLyByYWlzZXM6IFdST05HX0RPQ1VNRU5UX0VSUixOT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlIsSU5VU0VfQVRUUklCVVRFX0VSUlxuXHRcdHZhciBlbCA9IGF0dHIub3duZXJFbGVtZW50LCBvbGRBdHRyO1xuXHRcdGlmKGVsICYmIGVsIT10aGlzLl9vd25lckVsZW1lbnQpe1xuXHRcdFx0dGhyb3cgbmV3IERPTUV4Y2VwdGlvbihJTlVTRV9BVFRSSUJVVEVfRVJSKTtcblx0XHR9XG5cdFx0b2xkQXR0ciA9IHRoaXMuZ2V0TmFtZWRJdGVtTlMoYXR0ci5uYW1lc3BhY2VVUkksYXR0ci5sb2NhbE5hbWUpO1xuXHRcdF9hZGROYW1lZE5vZGUodGhpcy5fb3duZXJFbGVtZW50LHRoaXMsYXR0cixvbGRBdHRyKTtcblx0XHRyZXR1cm4gb2xkQXR0cjtcblx0fSxcblxuXHQvKiByZXR1cm5zIE5vZGUgKi9cblx0cmVtb3ZlTmFtZWRJdGVtOiBmdW5jdGlvbihrZXkpIHtcblx0XHR2YXIgYXR0ciA9IHRoaXMuZ2V0TmFtZWRJdGVtKGtleSk7XG5cdFx0X3JlbW92ZU5hbWVkTm9kZSh0aGlzLl9vd25lckVsZW1lbnQsdGhpcyxhdHRyKTtcblx0XHRyZXR1cm4gYXR0cjtcblx0XHRcblx0XHRcblx0fSwvLyByYWlzZXM6IE5PVF9GT1VORF9FUlIsTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSXG5cdFxuXHQvL2ZvciBsZXZlbDJcblx0cmVtb3ZlTmFtZWRJdGVtTlM6ZnVuY3Rpb24obmFtZXNwYWNlVVJJLGxvY2FsTmFtZSl7XG5cdFx0dmFyIGF0dHIgPSB0aGlzLmdldE5hbWVkSXRlbU5TKG5hbWVzcGFjZVVSSSxsb2NhbE5hbWUpO1xuXHRcdF9yZW1vdmVOYW1lZE5vZGUodGhpcy5fb3duZXJFbGVtZW50LHRoaXMsYXR0cik7XG5cdFx0cmV0dXJuIGF0dHI7XG5cdH0sXG5cdGdldE5hbWVkSXRlbU5TOiBmdW5jdGlvbihuYW1lc3BhY2VVUkksIGxvY2FsTmFtZSkge1xuXHRcdHZhciBpID0gdGhpcy5sZW5ndGg7XG5cdFx0d2hpbGUoaS0tKXtcblx0XHRcdHZhciBub2RlID0gdGhpc1tpXTtcblx0XHRcdGlmKG5vZGUubG9jYWxOYW1lID09IGxvY2FsTmFtZSAmJiBub2RlLm5hbWVzcGFjZVVSSSA9PSBuYW1lc3BhY2VVUkkpe1xuXHRcdFx0XHRyZXR1cm4gbm9kZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn07XG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLURPTS1MZXZlbC0xL2xldmVsLW9uZS1jb3JlLmh0bWwjSUQtMTAyMTYxNDkwXG4gKi9cbmZ1bmN0aW9uIERPTUltcGxlbWVudGF0aW9uKC8qIE9iamVjdCAqLyBmZWF0dXJlcykge1xuXHR0aGlzLl9mZWF0dXJlcyA9IHt9O1xuXHRpZiAoZmVhdHVyZXMpIHtcblx0XHRmb3IgKHZhciBmZWF0dXJlIGluIGZlYXR1cmVzKSB7XG5cdFx0XHQgdGhpcy5fZmVhdHVyZXMgPSBmZWF0dXJlc1tmZWF0dXJlXTtcblx0XHR9XG5cdH1cbn07XG5cbkRPTUltcGxlbWVudGF0aW9uLnByb3RvdHlwZSA9IHtcblx0aGFzRmVhdHVyZTogZnVuY3Rpb24oLyogc3RyaW5nICovIGZlYXR1cmUsIC8qIHN0cmluZyAqLyB2ZXJzaW9uKSB7XG5cdFx0dmFyIHZlcnNpb25zID0gdGhpcy5fZmVhdHVyZXNbZmVhdHVyZS50b0xvd2VyQ2FzZSgpXTtcblx0XHRpZiAodmVyc2lvbnMgJiYgKCF2ZXJzaW9uIHx8IHZlcnNpb24gaW4gdmVyc2lvbnMpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fSxcblx0Ly8gSW50cm9kdWNlZCBpbiBET00gTGV2ZWwgMjpcblx0Y3JlYXRlRG9jdW1lbnQ6ZnVuY3Rpb24obmFtZXNwYWNlVVJJLCAgcXVhbGlmaWVkTmFtZSwgZG9jdHlwZSl7Ly8gcmFpc2VzOklOVkFMSURfQ0hBUkFDVEVSX0VSUixOQU1FU1BBQ0VfRVJSLFdST05HX0RPQ1VNRU5UX0VSUlxuXHRcdHZhciBkb2MgPSBuZXcgRG9jdW1lbnQoKTtcblx0XHRkb2MuZG9jdHlwZSA9IGRvY3R5cGU7XG5cdFx0aWYoZG9jdHlwZSl7XG5cdFx0XHRkb2MuYXBwZW5kQ2hpbGQoZG9jdHlwZSk7XG5cdFx0fVxuXHRcdGRvYy5pbXBsZW1lbnRhdGlvbiA9IHRoaXM7XG5cdFx0ZG9jLmNoaWxkTm9kZXMgPSBuZXcgTm9kZUxpc3QoKTtcblx0XHRpZihxdWFsaWZpZWROYW1lKXtcblx0XHRcdHZhciByb290ID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkkscXVhbGlmaWVkTmFtZSk7XG5cdFx0XHRkb2MuYXBwZW5kQ2hpbGQocm9vdCk7XG5cdFx0fVxuXHRcdHJldHVybiBkb2M7XG5cdH0sXG5cdC8vIEludHJvZHVjZWQgaW4gRE9NIExldmVsIDI6XG5cdGNyZWF0ZURvY3VtZW50VHlwZTpmdW5jdGlvbihxdWFsaWZpZWROYW1lLCBwdWJsaWNJZCwgc3lzdGVtSWQpey8vIHJhaXNlczpJTlZBTElEX0NIQVJBQ1RFUl9FUlIsTkFNRVNQQUNFX0VSUlxuXHRcdHZhciBub2RlID0gbmV3IERvY3VtZW50VHlwZSgpO1xuXHRcdG5vZGUubmFtZSA9IHF1YWxpZmllZE5hbWU7XG5cdFx0bm9kZS5ub2RlTmFtZSA9IHF1YWxpZmllZE5hbWU7XG5cdFx0bm9kZS5wdWJsaWNJZCA9IHB1YmxpY0lkO1xuXHRcdG5vZGUuc3lzdGVtSWQgPSBzeXN0ZW1JZDtcblx0XHQvLyBJbnRyb2R1Y2VkIGluIERPTSBMZXZlbCAyOlxuXHRcdC8vcmVhZG9ubHkgYXR0cmlidXRlIERPTVN0cmluZyAgICAgICAgaW50ZXJuYWxTdWJzZXQ7XG5cdFx0XG5cdFx0Ly9UT0RPOi4uXG5cdFx0Ly8gIHJlYWRvbmx5IGF0dHJpYnV0ZSBOYW1lZE5vZGVNYXAgICAgIGVudGl0aWVzO1xuXHRcdC8vICByZWFkb25seSBhdHRyaWJ1dGUgTmFtZWROb2RlTWFwICAgICBub3RhdGlvbnM7XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH1cbn07XG5cblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDAvUkVDLURPTS1MZXZlbC0yLUNvcmUtMjAwMDExMTMvY29yZS5odG1sI0lELTE5NTA2NDEyNDdcbiAqL1xuXG5mdW5jdGlvbiBOb2RlKCkge1xufTtcblxuTm9kZS5wcm90b3R5cGUgPSB7XG5cdGZpcnN0Q2hpbGQgOiBudWxsLFxuXHRsYXN0Q2hpbGQgOiBudWxsLFxuXHRwcmV2aW91c1NpYmxpbmcgOiBudWxsLFxuXHRuZXh0U2libGluZyA6IG51bGwsXG5cdGF0dHJpYnV0ZXMgOiBudWxsLFxuXHRwYXJlbnROb2RlIDogbnVsbCxcblx0Y2hpbGROb2RlcyA6IG51bGwsXG5cdG93bmVyRG9jdW1lbnQgOiBudWxsLFxuXHRub2RlVmFsdWUgOiBudWxsLFxuXHRuYW1lc3BhY2VVUkkgOiBudWxsLFxuXHRwcmVmaXggOiBudWxsLFxuXHRsb2NhbE5hbWUgOiBudWxsLFxuXHQvLyBNb2RpZmllZCBpbiBET00gTGV2ZWwgMjpcblx0aW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKG5ld0NoaWxkLCByZWZDaGlsZCl7Ly9yYWlzZXMgXG5cdFx0cmV0dXJuIF9pbnNlcnRCZWZvcmUodGhpcyxuZXdDaGlsZCxyZWZDaGlsZCk7XG5cdH0sXG5cdHJlcGxhY2VDaGlsZDpmdW5jdGlvbihuZXdDaGlsZCwgb2xkQ2hpbGQpey8vcmFpc2VzIFxuXHRcdHRoaXMuaW5zZXJ0QmVmb3JlKG5ld0NoaWxkLG9sZENoaWxkKTtcblx0XHRpZihvbGRDaGlsZCl7XG5cdFx0XHR0aGlzLnJlbW92ZUNoaWxkKG9sZENoaWxkKTtcblx0XHR9XG5cdH0sXG5cdHJlbW92ZUNoaWxkOmZ1bmN0aW9uKG9sZENoaWxkKXtcblx0XHRyZXR1cm4gX3JlbW92ZUNoaWxkKHRoaXMsb2xkQ2hpbGQpO1xuXHR9LFxuXHRhcHBlbmRDaGlsZDpmdW5jdGlvbihuZXdDaGlsZCl7XG5cdFx0cmV0dXJuIHRoaXMuaW5zZXJ0QmVmb3JlKG5ld0NoaWxkLG51bGwpO1xuXHR9LFxuXHRoYXNDaGlsZE5vZGVzOmZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIHRoaXMuZmlyc3RDaGlsZCAhPSBudWxsO1xuXHR9LFxuXHRjbG9uZU5vZGU6ZnVuY3Rpb24oZGVlcCl7XG5cdFx0cmV0dXJuIGNsb25lTm9kZSh0aGlzLm93bmVyRG9jdW1lbnR8fHRoaXMsdGhpcyxkZWVwKTtcblx0fSxcblx0Ly8gTW9kaWZpZWQgaW4gRE9NIExldmVsIDI6XG5cdG5vcm1hbGl6ZTpmdW5jdGlvbigpe1xuXHRcdHZhciBjaGlsZCA9IHRoaXMuZmlyc3RDaGlsZDtcblx0XHR3aGlsZShjaGlsZCl7XG5cdFx0XHR2YXIgbmV4dCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuXHRcdFx0aWYobmV4dCAmJiBuZXh0Lm5vZGVUeXBlID09IFRFWFRfTk9ERSAmJiBjaGlsZC5ub2RlVHlwZSA9PSBURVhUX05PREUpe1xuXHRcdFx0XHR0aGlzLnJlbW92ZUNoaWxkKG5leHQpO1xuXHRcdFx0XHRjaGlsZC5hcHBlbmREYXRhKG5leHQuZGF0YSk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0Y2hpbGQubm9ybWFsaXplKCk7XG5cdFx0XHRcdGNoaWxkID0gbmV4dDtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG4gIFx0Ly8gSW50cm9kdWNlZCBpbiBET00gTGV2ZWwgMjpcblx0aXNTdXBwb3J0ZWQ6ZnVuY3Rpb24oZmVhdHVyZSwgdmVyc2lvbil7XG5cdFx0cmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKGZlYXR1cmUsdmVyc2lvbik7XG5cdH0sXG4gICAgLy8gSW50cm9kdWNlZCBpbiBET00gTGV2ZWwgMjpcbiAgICBoYXNBdHRyaWJ1dGVzOmZ1bmN0aW9uKCl7XG4gICAgXHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmxlbmd0aD4wO1xuICAgIH0sXG4gICAgbG9va3VwUHJlZml4OmZ1bmN0aW9uKG5hbWVzcGFjZVVSSSl7XG4gICAgXHR2YXIgZWwgPSB0aGlzO1xuICAgIFx0d2hpbGUoZWwpe1xuICAgIFx0XHR2YXIgbWFwID0gZWwuX25zTWFwO1xuICAgIFx0XHQvL2NvbnNvbGUuZGlyKG1hcClcbiAgICBcdFx0aWYobWFwKXtcbiAgICBcdFx0XHRmb3IodmFyIG4gaW4gbWFwKXtcbiAgICBcdFx0XHRcdGlmKG1hcFtuXSA9PSBuYW1lc3BhY2VVUkkpe1xuICAgIFx0XHRcdFx0XHRyZXR1cm4gbjtcbiAgICBcdFx0XHRcdH1cbiAgICBcdFx0XHR9XG4gICAgXHRcdH1cbiAgICBcdFx0ZWwgPSBlbC5ub2RlVHlwZSA9PSAyP2VsLm93bmVyRG9jdW1lbnQgOiBlbC5wYXJlbnROb2RlO1xuICAgIFx0fVxuICAgIFx0cmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICAvLyBJbnRyb2R1Y2VkIGluIERPTSBMZXZlbCAzOlxuICAgIGxvb2t1cE5hbWVzcGFjZVVSSTpmdW5jdGlvbihwcmVmaXgpe1xuICAgIFx0dmFyIGVsID0gdGhpcztcbiAgICBcdHdoaWxlKGVsKXtcbiAgICBcdFx0dmFyIG1hcCA9IGVsLl9uc01hcDtcbiAgICBcdFx0Ly9jb25zb2xlLmRpcihtYXApXG4gICAgXHRcdGlmKG1hcCl7XG4gICAgXHRcdFx0aWYocHJlZml4IGluIG1hcCl7XG4gICAgXHRcdFx0XHRyZXR1cm4gbWFwW3ByZWZpeF0gO1xuICAgIFx0XHRcdH1cbiAgICBcdFx0fVxuICAgIFx0XHRlbCA9IGVsLm5vZGVUeXBlID09IDI/ZWwub3duZXJEb2N1bWVudCA6IGVsLnBhcmVudE5vZGU7XG4gICAgXHR9XG4gICAgXHRyZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIC8vIEludHJvZHVjZWQgaW4gRE9NIExldmVsIDM6XG4gICAgaXNEZWZhdWx0TmFtZXNwYWNlOmZ1bmN0aW9uKG5hbWVzcGFjZVVSSSl7XG4gICAgXHR2YXIgcHJlZml4ID0gdGhpcy5sb29rdXBQcmVmaXgobmFtZXNwYWNlVVJJKTtcbiAgICBcdHJldHVybiBwcmVmaXggPT0gbnVsbDtcbiAgICB9XG59O1xuXG5cbmZ1bmN0aW9uIF94bWxFbmNvZGVyKGMpe1xuXHRyZXR1cm4gYyA9PSAnPCcgJiYgJyZsdDsnIHx8XG4gICAgICAgICBjID09ICc+JyAmJiAnJmd0OycgfHxcbiAgICAgICAgIGMgPT0gJyYnICYmICcmYW1wOycgfHxcbiAgICAgICAgIGMgPT0gJ1wiJyAmJiAnJnF1b3Q7JyB8fFxuICAgICAgICAgJyYjJytjLmNoYXJDb2RlQXQoKSsnOydcbn1cblxuXG5jb3B5KE5vZGVUeXBlLE5vZGUpO1xuY29weShOb2RlVHlwZSxOb2RlLnByb3RvdHlwZSk7XG5cbi8qKlxuICogQHBhcmFtIGNhbGxiYWNrIHJldHVybiB0cnVlIGZvciBjb250aW51ZSxmYWxzZSBmb3IgYnJlYWtcbiAqIEByZXR1cm4gYm9vbGVhbiB0cnVlOiBicmVhayB2aXNpdDtcbiAqL1xuZnVuY3Rpb24gX3Zpc2l0Tm9kZShub2RlLGNhbGxiYWNrKXtcblx0aWYoY2FsbGJhY2sobm9kZSkpe1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmKG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQpe1xuXHRcdGRve1xuXHRcdFx0aWYoX3Zpc2l0Tm9kZShub2RlLGNhbGxiYWNrKSl7cmV0dXJuIHRydWV9XG4gICAgICAgIH13aGlsZShub2RlPW5vZGUubmV4dFNpYmxpbmcpXG4gICAgfVxufVxuXG5cblxuZnVuY3Rpb24gRG9jdW1lbnQoKXtcbn1cbmZ1bmN0aW9uIF9vbkFkZEF0dHJpYnV0ZShkb2MsZWwsbmV3QXR0cil7XG5cdGRvYyAmJiBkb2MuX2luYysrO1xuXHR2YXIgbnMgPSBuZXdBdHRyLm5hbWVzcGFjZVVSSSA7XG5cdGlmKG5zID09ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLycpe1xuXHRcdC8vdXBkYXRlIG5hbWVzcGFjZVxuXHRcdGVsLl9uc01hcFtuZXdBdHRyLnByZWZpeD9uZXdBdHRyLmxvY2FsTmFtZTonJ10gPSBuZXdBdHRyLnZhbHVlXG5cdH1cbn1cbmZ1bmN0aW9uIF9vblJlbW92ZUF0dHJpYnV0ZShkb2MsZWwsbmV3QXR0cixyZW1vdmUpe1xuXHRkb2MgJiYgZG9jLl9pbmMrKztcblx0dmFyIG5zID0gbmV3QXR0ci5uYW1lc3BhY2VVUkkgO1xuXHRpZihucyA9PSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nKXtcblx0XHQvL3VwZGF0ZSBuYW1lc3BhY2Vcblx0XHRkZWxldGUgZWwuX25zTWFwW25ld0F0dHIucHJlZml4P25ld0F0dHIubG9jYWxOYW1lOicnXVxuXHR9XG59XG5mdW5jdGlvbiBfb25VcGRhdGVDaGlsZChkb2MsZWwsbmV3Q2hpbGQpe1xuXHRpZihkb2MgJiYgZG9jLl9pbmMpe1xuXHRcdGRvYy5faW5jKys7XG5cdFx0Ly91cGRhdGUgY2hpbGROb2Rlc1xuXHRcdHZhciBjcyA9IGVsLmNoaWxkTm9kZXM7XG5cdFx0aWYobmV3Q2hpbGQpe1xuXHRcdFx0Y3NbY3MubGVuZ3RoKytdID0gbmV3Q2hpbGQ7XG5cdFx0fWVsc2V7XG5cdFx0XHQvL2NvbnNvbGUubG9nKDEpXG5cdFx0XHR2YXIgY2hpbGQgPSBlbC5maXJzdENoaWxkO1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0d2hpbGUoY2hpbGQpe1xuXHRcdFx0XHRjc1tpKytdID0gY2hpbGQ7XG5cdFx0XHRcdGNoaWxkID1jaGlsZC5uZXh0U2libGluZztcblx0XHRcdH1cblx0XHRcdGNzLmxlbmd0aCA9IGk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogYXR0cmlidXRlcztcbiAqIGNoaWxkcmVuO1xuICogXG4gKiB3cml0ZWFibGUgcHJvcGVydGllczpcbiAqIG5vZGVWYWx1ZSxBdHRyOnZhbHVlLENoYXJhY3RlckRhdGE6ZGF0YVxuICogcHJlZml4XG4gKi9cbmZ1bmN0aW9uIF9yZW1vdmVDaGlsZChwYXJlbnROb2RlLGNoaWxkKXtcblx0dmFyIHByZXZpb3VzID0gY2hpbGQucHJldmlvdXNTaWJsaW5nO1xuXHR2YXIgbmV4dCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuXHRpZihwcmV2aW91cyl7XG5cdFx0cHJldmlvdXMubmV4dFNpYmxpbmcgPSBuZXh0O1xuXHR9ZWxzZXtcblx0XHRwYXJlbnROb2RlLmZpcnN0Q2hpbGQgPSBuZXh0XG5cdH1cblx0aWYobmV4dCl7XG5cdFx0bmV4dC5wcmV2aW91c1NpYmxpbmcgPSBwcmV2aW91cztcblx0fWVsc2V7XG5cdFx0cGFyZW50Tm9kZS5sYXN0Q2hpbGQgPSBwcmV2aW91cztcblx0fVxuXHRfb25VcGRhdGVDaGlsZChwYXJlbnROb2RlLm93bmVyRG9jdW1lbnQscGFyZW50Tm9kZSk7XG5cdHJldHVybiBjaGlsZDtcbn1cbi8qKlxuICogcHJlZm9ybWFuY2Uga2V5KHJlZkNoaWxkID09IG51bGwpXG4gKi9cbmZ1bmN0aW9uIF9pbnNlcnRCZWZvcmUocGFyZW50Tm9kZSxuZXdDaGlsZCxuZXh0Q2hpbGQpe1xuXHR2YXIgY3AgPSBuZXdDaGlsZC5wYXJlbnROb2RlO1xuXHRpZihjcCl7XG5cdFx0Y3AucmVtb3ZlQ2hpbGQobmV3Q2hpbGQpOy8vcmVtb3ZlIGFuZCB1cGRhdGVcblx0fVxuXHRpZihuZXdDaGlsZC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSl7XG5cdFx0dmFyIG5ld0ZpcnN0ID0gbmV3Q2hpbGQuZmlyc3RDaGlsZDtcblx0XHRpZiAobmV3Rmlyc3QgPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIG5ld0NoaWxkO1xuXHRcdH1cblx0XHR2YXIgbmV3TGFzdCA9IG5ld0NoaWxkLmxhc3RDaGlsZDtcblx0fWVsc2V7XG5cdFx0bmV3Rmlyc3QgPSBuZXdMYXN0ID0gbmV3Q2hpbGQ7XG5cdH1cblx0dmFyIHByZSA9IG5leHRDaGlsZCA/IG5leHRDaGlsZC5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnROb2RlLmxhc3RDaGlsZDtcblxuXHRuZXdGaXJzdC5wcmV2aW91c1NpYmxpbmcgPSBwcmU7XG5cdG5ld0xhc3QubmV4dFNpYmxpbmcgPSBuZXh0Q2hpbGQ7XG5cdFxuXHRcblx0aWYocHJlKXtcblx0XHRwcmUubmV4dFNpYmxpbmcgPSBuZXdGaXJzdDtcblx0fWVsc2V7XG5cdFx0cGFyZW50Tm9kZS5maXJzdENoaWxkID0gbmV3Rmlyc3Q7XG5cdH1cblx0aWYobmV4dENoaWxkID09IG51bGwpe1xuXHRcdHBhcmVudE5vZGUubGFzdENoaWxkID0gbmV3TGFzdDtcblx0fWVsc2V7XG5cdFx0bmV4dENoaWxkLnByZXZpb3VzU2libGluZyA9IG5ld0xhc3Q7XG5cdH1cblx0ZG97XG5cdFx0bmV3Rmlyc3QucGFyZW50Tm9kZSA9IHBhcmVudE5vZGU7XG5cdH13aGlsZShuZXdGaXJzdCAhPT0gbmV3TGFzdCAmJiAobmV3Rmlyc3Q9IG5ld0ZpcnN0Lm5leHRTaWJsaW5nKSlcblx0X29uVXBkYXRlQ2hpbGQocGFyZW50Tm9kZS5vd25lckRvY3VtZW50fHxwYXJlbnROb2RlLHBhcmVudE5vZGUpO1xuXHQvL2NvbnNvbGUubG9nKHBhcmVudE5vZGUubGFzdENoaWxkLm5leHRTaWJsaW5nID09IG51bGwpXG5cdGlmIChuZXdDaGlsZC5ub2RlVHlwZSA9PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG5cdFx0bmV3Q2hpbGQuZmlyc3RDaGlsZCA9IG5ld0NoaWxkLmxhc3RDaGlsZCA9IG51bGw7XG5cdH1cblx0cmV0dXJuIG5ld0NoaWxkO1xufVxuZnVuY3Rpb24gX2FwcGVuZFNpbmdsZUNoaWxkKHBhcmVudE5vZGUsbmV3Q2hpbGQpe1xuXHR2YXIgY3AgPSBuZXdDaGlsZC5wYXJlbnROb2RlO1xuXHRpZihjcCl7XG5cdFx0dmFyIHByZSA9IHBhcmVudE5vZGUubGFzdENoaWxkO1xuXHRcdGNwLnJlbW92ZUNoaWxkKG5ld0NoaWxkKTsvL3JlbW92ZSBhbmQgdXBkYXRlXG5cdFx0dmFyIHByZSA9IHBhcmVudE5vZGUubGFzdENoaWxkO1xuXHR9XG5cdHZhciBwcmUgPSBwYXJlbnROb2RlLmxhc3RDaGlsZDtcblx0bmV3Q2hpbGQucGFyZW50Tm9kZSA9IHBhcmVudE5vZGU7XG5cdG5ld0NoaWxkLnByZXZpb3VzU2libGluZyA9IHByZTtcblx0bmV3Q2hpbGQubmV4dFNpYmxpbmcgPSBudWxsO1xuXHRpZihwcmUpe1xuXHRcdHByZS5uZXh0U2libGluZyA9IG5ld0NoaWxkO1xuXHR9ZWxzZXtcblx0XHRwYXJlbnROb2RlLmZpcnN0Q2hpbGQgPSBuZXdDaGlsZDtcblx0fVxuXHRwYXJlbnROb2RlLmxhc3RDaGlsZCA9IG5ld0NoaWxkO1xuXHRfb25VcGRhdGVDaGlsZChwYXJlbnROb2RlLm93bmVyRG9jdW1lbnQscGFyZW50Tm9kZSxuZXdDaGlsZCk7XG5cdHJldHVybiBuZXdDaGlsZDtcblx0Ly9jb25zb2xlLmxvZyhcIl9fYWFcIixwYXJlbnROb2RlLmxhc3RDaGlsZC5uZXh0U2libGluZyA9PSBudWxsKVxufVxuRG9jdW1lbnQucHJvdG90eXBlID0ge1xuXHQvL2ltcGxlbWVudGF0aW9uIDogbnVsbCxcblx0bm9kZU5hbWUgOiAgJyNkb2N1bWVudCcsXG5cdG5vZGVUeXBlIDogIERPQ1VNRU5UX05PREUsXG5cdGRvY3R5cGUgOiAgbnVsbCxcblx0ZG9jdW1lbnRFbGVtZW50IDogIG51bGwsXG5cdF9pbmMgOiAxLFxuXHRcblx0aW5zZXJ0QmVmb3JlIDogIGZ1bmN0aW9uKG5ld0NoaWxkLCByZWZDaGlsZCl7Ly9yYWlzZXMgXG5cdFx0aWYobmV3Q2hpbGQubm9kZVR5cGUgPT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSl7XG5cdFx0XHR2YXIgY2hpbGQgPSBuZXdDaGlsZC5maXJzdENoaWxkO1xuXHRcdFx0d2hpbGUoY2hpbGQpe1xuXHRcdFx0XHR2YXIgbmV4dCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuXHRcdFx0XHR0aGlzLmluc2VydEJlZm9yZShjaGlsZCxyZWZDaGlsZCk7XG5cdFx0XHRcdGNoaWxkID0gbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuZXdDaGlsZDtcblx0XHR9XG5cdFx0aWYodGhpcy5kb2N1bWVudEVsZW1lbnQgPT0gbnVsbCAmJiBuZXdDaGlsZC5ub2RlVHlwZSA9PSAxKXtcblx0XHRcdHRoaXMuZG9jdW1lbnRFbGVtZW50ID0gbmV3Q2hpbGQ7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBfaW5zZXJ0QmVmb3JlKHRoaXMsbmV3Q2hpbGQscmVmQ2hpbGQpLChuZXdDaGlsZC5vd25lckRvY3VtZW50ID0gdGhpcyksbmV3Q2hpbGQ7XG5cdH0sXG5cdHJlbW92ZUNoaWxkIDogIGZ1bmN0aW9uKG9sZENoaWxkKXtcblx0XHRpZih0aGlzLmRvY3VtZW50RWxlbWVudCA9PSBvbGRDaGlsZCl7XG5cdFx0XHR0aGlzLmRvY3VtZW50RWxlbWVudCA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBfcmVtb3ZlQ2hpbGQodGhpcyxvbGRDaGlsZCk7XG5cdH0sXG5cdC8vIEludHJvZHVjZWQgaW4gRE9NIExldmVsIDI6XG5cdGltcG9ydE5vZGUgOiBmdW5jdGlvbihpbXBvcnRlZE5vZGUsZGVlcCl7XG5cdFx0cmV0dXJuIGltcG9ydE5vZGUodGhpcyxpbXBvcnRlZE5vZGUsZGVlcCk7XG5cdH0sXG5cdC8vIEludHJvZHVjZWQgaW4gRE9NIExldmVsIDI6XG5cdGdldEVsZW1lbnRCeUlkIDpcdGZ1bmN0aW9uKGlkKXtcblx0XHR2YXIgcnR2ID0gbnVsbDtcblx0XHRfdmlzaXROb2RlKHRoaXMuZG9jdW1lbnRFbGVtZW50LGZ1bmN0aW9uKG5vZGUpe1xuXHRcdFx0aWYobm9kZS5ub2RlVHlwZSA9PSAxKXtcblx0XHRcdFx0aWYobm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJykgPT0gaWQpe1xuXHRcdFx0XHRcdHJ0diA9IG5vZGU7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KVxuXHRcdHJldHVybiBydHY7XG5cdH0sXG5cdFxuXHQvL2RvY3VtZW50IGZhY3RvcnkgbWV0aG9kOlxuXHRjcmVhdGVFbGVtZW50IDpcdGZ1bmN0aW9uKHRhZ05hbWUpe1xuXHRcdHZhciBub2RlID0gbmV3IEVsZW1lbnQoKTtcblx0XHRub2RlLm93bmVyRG9jdW1lbnQgPSB0aGlzO1xuXHRcdG5vZGUubm9kZU5hbWUgPSB0YWdOYW1lO1xuXHRcdG5vZGUudGFnTmFtZSA9IHRhZ05hbWU7XG5cdFx0bm9kZS5jaGlsZE5vZGVzID0gbmV3IE5vZGVMaXN0KCk7XG5cdFx0dmFyIGF0dHJzXHQ9IG5vZGUuYXR0cmlidXRlcyA9IG5ldyBOYW1lZE5vZGVNYXAoKTtcblx0XHRhdHRycy5fb3duZXJFbGVtZW50ID0gbm9kZTtcblx0XHRyZXR1cm4gbm9kZTtcblx0fSxcblx0Y3JlYXRlRG9jdW1lbnRGcmFnbWVudCA6XHRmdW5jdGlvbigpe1xuXHRcdHZhciBub2RlID0gbmV3IERvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRub2RlLm93bmVyRG9jdW1lbnQgPSB0aGlzO1xuXHRcdG5vZGUuY2hpbGROb2RlcyA9IG5ldyBOb2RlTGlzdCgpO1xuXHRcdHJldHVybiBub2RlO1xuXHR9LFxuXHRjcmVhdGVUZXh0Tm9kZSA6XHRmdW5jdGlvbihkYXRhKXtcblx0XHR2YXIgbm9kZSA9IG5ldyBUZXh0KCk7XG5cdFx0bm9kZS5vd25lckRvY3VtZW50ID0gdGhpcztcblx0XHRub2RlLmFwcGVuZERhdGEoZGF0YSlcblx0XHRyZXR1cm4gbm9kZTtcblx0fSxcblx0Y3JlYXRlQ29tbWVudCA6XHRmdW5jdGlvbihkYXRhKXtcblx0XHR2YXIgbm9kZSA9IG5ldyBDb21tZW50KCk7XG5cdFx0bm9kZS5vd25lckRvY3VtZW50ID0gdGhpcztcblx0XHRub2RlLmFwcGVuZERhdGEoZGF0YSlcblx0XHRyZXR1cm4gbm9kZTtcblx0fSxcblx0Y3JlYXRlQ0RBVEFTZWN0aW9uIDpcdGZ1bmN0aW9uKGRhdGEpe1xuXHRcdHZhciBub2RlID0gbmV3IENEQVRBU2VjdGlvbigpO1xuXHRcdG5vZGUub3duZXJEb2N1bWVudCA9IHRoaXM7XG5cdFx0bm9kZS5hcHBlbmREYXRhKGRhdGEpXG5cdFx0cmV0dXJuIG5vZGU7XG5cdH0sXG5cdGNyZWF0ZVByb2Nlc3NpbmdJbnN0cnVjdGlvbiA6XHRmdW5jdGlvbih0YXJnZXQsZGF0YSl7XG5cdFx0dmFyIG5vZGUgPSBuZXcgUHJvY2Vzc2luZ0luc3RydWN0aW9uKCk7XG5cdFx0bm9kZS5vd25lckRvY3VtZW50ID0gdGhpcztcblx0XHRub2RlLnRhZ05hbWUgPSBub2RlLnRhcmdldCA9IHRhcmdldDtcblx0XHRub2RlLm5vZGVWYWx1ZT0gbm9kZS5kYXRhID0gZGF0YTtcblx0XHRyZXR1cm4gbm9kZTtcblx0fSxcblx0Y3JlYXRlQXR0cmlidXRlIDpcdGZ1bmN0aW9uKG5hbWUpe1xuXHRcdHZhciBub2RlID0gbmV3IEF0dHIoKTtcblx0XHRub2RlLm93bmVyRG9jdW1lbnRcdD0gdGhpcztcblx0XHRub2RlLm5hbWUgPSBuYW1lO1xuXHRcdG5vZGUubm9kZU5hbWVcdD0gbmFtZTtcblx0XHRub2RlLmxvY2FsTmFtZSA9IG5hbWU7XG5cdFx0bm9kZS5zcGVjaWZpZWQgPSB0cnVlO1xuXHRcdHJldHVybiBub2RlO1xuXHR9LFxuXHRjcmVhdGVFbnRpdHlSZWZlcmVuY2UgOlx0ZnVuY3Rpb24obmFtZSl7XG5cdFx0dmFyIG5vZGUgPSBuZXcgRW50aXR5UmVmZXJlbmNlKCk7XG5cdFx0bm9kZS5vd25lckRvY3VtZW50XHQ9IHRoaXM7XG5cdFx0bm9kZS5ub2RlTmFtZVx0PSBuYW1lO1xuXHRcdHJldHVybiBub2RlO1xuXHR9LFxuXHQvLyBJbnRyb2R1Y2VkIGluIERPTSBMZXZlbCAyOlxuXHRjcmVhdGVFbGVtZW50TlMgOlx0ZnVuY3Rpb24obmFtZXNwYWNlVVJJLHF1YWxpZmllZE5hbWUpe1xuXHRcdHZhciBub2RlID0gbmV3IEVsZW1lbnQoKTtcblx0XHR2YXIgcGwgPSBxdWFsaWZpZWROYW1lLnNwbGl0KCc6Jyk7XG5cdFx0dmFyIGF0dHJzXHQ9IG5vZGUuYXR0cmlidXRlcyA9IG5ldyBOYW1lZE5vZGVNYXAoKTtcblx0XHRub2RlLmNoaWxkTm9kZXMgPSBuZXcgTm9kZUxpc3QoKTtcblx0XHRub2RlLm93bmVyRG9jdW1lbnQgPSB0aGlzO1xuXHRcdG5vZGUubm9kZU5hbWUgPSBxdWFsaWZpZWROYW1lO1xuXHRcdG5vZGUudGFnTmFtZSA9IHF1YWxpZmllZE5hbWU7XG5cdFx0bm9kZS5uYW1lc3BhY2VVUkkgPSBuYW1lc3BhY2VVUkk7XG5cdFx0aWYocGwubGVuZ3RoID09IDIpe1xuXHRcdFx0bm9kZS5wcmVmaXggPSBwbFswXTtcblx0XHRcdG5vZGUubG9jYWxOYW1lID0gcGxbMV07XG5cdFx0fWVsc2V7XG5cdFx0XHQvL2VsLnByZWZpeCA9IG51bGw7XG5cdFx0XHRub2RlLmxvY2FsTmFtZSA9IHF1YWxpZmllZE5hbWU7XG5cdFx0fVxuXHRcdGF0dHJzLl9vd25lckVsZW1lbnQgPSBub2RlO1xuXHRcdHJldHVybiBub2RlO1xuXHR9LFxuXHQvLyBJbnRyb2R1Y2VkIGluIERPTSBMZXZlbCAyOlxuXHRjcmVhdGVBdHRyaWJ1dGVOUyA6XHRmdW5jdGlvbihuYW1lc3BhY2VVUkkscXVhbGlmaWVkTmFtZSl7XG5cdFx0dmFyIG5vZGUgPSBuZXcgQXR0cigpO1xuXHRcdHZhciBwbCA9IHF1YWxpZmllZE5hbWUuc3BsaXQoJzonKTtcblx0XHRub2RlLm93bmVyRG9jdW1lbnQgPSB0aGlzO1xuXHRcdG5vZGUubm9kZU5hbWUgPSBxdWFsaWZpZWROYW1lO1xuXHRcdG5vZGUubmFtZSA9IHF1YWxpZmllZE5hbWU7XG5cdFx0bm9kZS5uYW1lc3BhY2VVUkkgPSBuYW1lc3BhY2VVUkk7XG5cdFx0bm9kZS5zcGVjaWZpZWQgPSB0cnVlO1xuXHRcdGlmKHBsLmxlbmd0aCA9PSAyKXtcblx0XHRcdG5vZGUucHJlZml4ID0gcGxbMF07XG5cdFx0XHRub2RlLmxvY2FsTmFtZSA9IHBsWzFdO1xuXHRcdH1lbHNle1xuXHRcdFx0Ly9lbC5wcmVmaXggPSBudWxsO1xuXHRcdFx0bm9kZS5sb2NhbE5hbWUgPSBxdWFsaWZpZWROYW1lO1xuXHRcdH1cblx0XHRyZXR1cm4gbm9kZTtcblx0fVxufTtcbl9leHRlbmRzKERvY3VtZW50LE5vZGUpO1xuXG5cbmZ1bmN0aW9uIEVsZW1lbnQoKSB7XG5cdHRoaXMuX25zTWFwID0ge307XG59O1xuRWxlbWVudC5wcm90b3R5cGUgPSB7XG5cdG5vZGVUeXBlIDogRUxFTUVOVF9OT0RFLFxuXHRoYXNBdHRyaWJ1dGUgOiBmdW5jdGlvbihuYW1lKXtcblx0XHRyZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpIT1udWxsO1xuXHR9LFxuXHRnZXRBdHRyaWJ1dGUgOiBmdW5jdGlvbihuYW1lKXtcblx0XHR2YXIgYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlTm9kZShuYW1lKTtcblx0XHRyZXR1cm4gYXR0ciAmJiBhdHRyLnZhbHVlIHx8ICcnO1xuXHR9LFxuXHRnZXRBdHRyaWJ1dGVOb2RlIDogZnVuY3Rpb24obmFtZSl7XG5cdFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0obmFtZSk7XG5cdH0sXG5cdHNldEF0dHJpYnV0ZSA6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKXtcblx0XHR2YXIgYXR0ciA9IHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVBdHRyaWJ1dGUobmFtZSk7XG5cdFx0YXR0ci52YWx1ZSA9IGF0dHIubm9kZVZhbHVlID0gXCJcIiArIHZhbHVlO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlTm9kZShhdHRyKVxuXHR9LFxuXHRyZW1vdmVBdHRyaWJ1dGUgOiBmdW5jdGlvbihuYW1lKXtcblx0XHR2YXIgYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlTm9kZShuYW1lKVxuXHRcdGF0dHIgJiYgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOb2RlKGF0dHIpO1xuXHR9LFxuXHRcblx0Ly9mb3VyIHJlYWwgb3BlYXJ0aW9uIG1ldGhvZFxuXHRhcHBlbmRDaGlsZDpmdW5jdGlvbihuZXdDaGlsZCl7XG5cdFx0aWYobmV3Q2hpbGQubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUpe1xuXHRcdFx0cmV0dXJuIHRoaXMuaW5zZXJ0QmVmb3JlKG5ld0NoaWxkLG51bGwpO1xuXHRcdH1lbHNle1xuXHRcdFx0cmV0dXJuIF9hcHBlbmRTaW5nbGVDaGlsZCh0aGlzLG5ld0NoaWxkKTtcblx0XHR9XG5cdH0sXG5cdHNldEF0dHJpYnV0ZU5vZGUgOiBmdW5jdGlvbihuZXdBdHRyKXtcblx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnNldE5hbWVkSXRlbShuZXdBdHRyKTtcblx0fSxcblx0c2V0QXR0cmlidXRlTm9kZU5TIDogZnVuY3Rpb24obmV3QXR0cil7XG5cdFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5zZXROYW1lZEl0ZW1OUyhuZXdBdHRyKTtcblx0fSxcblx0cmVtb3ZlQXR0cmlidXRlTm9kZSA6IGZ1bmN0aW9uKG9sZEF0dHIpe1xuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXMucmVtb3ZlTmFtZWRJdGVtKG9sZEF0dHIubm9kZU5hbWUpO1xuXHR9LFxuXHQvL2dldCByZWFsIGF0dHJpYnV0ZSBuYW1lLGFuZCByZW1vdmUgaXQgYnkgcmVtb3ZlQXR0cmlidXRlTm9kZVxuXHRyZW1vdmVBdHRyaWJ1dGVOUyA6IGZ1bmN0aW9uKG5hbWVzcGFjZVVSSSwgbG9jYWxOYW1lKXtcblx0XHR2YXIgb2xkID0gdGhpcy5nZXRBdHRyaWJ1dGVOb2RlTlMobmFtZXNwYWNlVVJJLCBsb2NhbE5hbWUpO1xuXHRcdG9sZCAmJiB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5vZGUob2xkKTtcblx0fSxcblx0XG5cdGhhc0F0dHJpYnV0ZU5TIDogZnVuY3Rpb24obmFtZXNwYWNlVVJJLCBsb2NhbE5hbWUpe1xuXHRcdHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZU5vZGVOUyhuYW1lc3BhY2VVUkksIGxvY2FsTmFtZSkhPW51bGw7XG5cdH0sXG5cdGdldEF0dHJpYnV0ZU5TIDogZnVuY3Rpb24obmFtZXNwYWNlVVJJLCBsb2NhbE5hbWUpe1xuXHRcdHZhciBhdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGVOb2RlTlMobmFtZXNwYWNlVVJJLCBsb2NhbE5hbWUpO1xuXHRcdHJldHVybiBhdHRyICYmIGF0dHIudmFsdWUgfHwgJyc7XG5cdH0sXG5cdHNldEF0dHJpYnV0ZU5TIDogZnVuY3Rpb24obmFtZXNwYWNlVVJJLCBxdWFsaWZpZWROYW1lLCB2YWx1ZSl7XG5cdFx0dmFyIGF0dHIgPSB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlQXR0cmlidXRlTlMobmFtZXNwYWNlVVJJLCBxdWFsaWZpZWROYW1lKTtcblx0XHRhdHRyLnZhbHVlID0gYXR0ci5ub2RlVmFsdWUgPSB2YWx1ZTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZU5vZGUoYXR0cilcblx0fSxcblx0Z2V0QXR0cmlidXRlTm9kZU5TIDogZnVuY3Rpb24obmFtZXNwYWNlVVJJLCBsb2NhbE5hbWUpe1xuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtTlMobmFtZXNwYWNlVVJJLCBsb2NhbE5hbWUpO1xuXHR9LFxuXHRcblx0Z2V0RWxlbWVudHNCeVRhZ05hbWUgOiBmdW5jdGlvbih0YWdOYW1lKXtcblx0XHRyZXR1cm4gbmV3IExpdmVOb2RlTGlzdCh0aGlzLGZ1bmN0aW9uKGJhc2Upe1xuXHRcdFx0dmFyIGxzID0gW107XG5cdFx0XHRfdmlzaXROb2RlKGJhc2UsZnVuY3Rpb24obm9kZSl7XG5cdFx0XHRcdGlmKG5vZGUgIT09IGJhc2UgJiYgbm9kZS5ub2RlVHlwZSA9PSBFTEVNRU5UX05PREUgJiYgKHRhZ05hbWUgPT09ICcqJyB8fCBub2RlLnRhZ05hbWUgPT0gdGFnTmFtZSkpe1xuXHRcdFx0XHRcdGxzLnB1c2gobm9kZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGxzO1xuXHRcdH0pO1xuXHR9LFxuXHRnZXRFbGVtZW50c0J5VGFnTmFtZU5TIDogZnVuY3Rpb24obmFtZXNwYWNlVVJJLCBsb2NhbE5hbWUpe1xuXHRcdHJldHVybiBuZXcgTGl2ZU5vZGVMaXN0KHRoaXMsZnVuY3Rpb24oYmFzZSl7XG5cdFx0XHR2YXIgbHMgPSBbXTtcblx0XHRcdF92aXNpdE5vZGUoYmFzZSxmdW5jdGlvbihub2RlKXtcblx0XHRcdFx0aWYobm9kZSAhPT0gYmFzZSAmJiBub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgbm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZVVSSSAmJiAobG9jYWxOYW1lID09PSAnKicgfHwgbm9kZS5sb2NhbE5hbWUgPT0gbG9jYWxOYW1lKSl7XG5cdFx0XHRcdFx0bHMucHVzaChub2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gbHM7XG5cdFx0fSk7XG5cdH1cbn07XG5Eb2N1bWVudC5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBFbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZTtcbkRvY3VtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZU5TID0gRWxlbWVudC5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeVRhZ05hbWVOUztcblxuXG5fZXh0ZW5kcyhFbGVtZW50LE5vZGUpO1xuZnVuY3Rpb24gQXR0cigpIHtcbn07XG5BdHRyLnByb3RvdHlwZS5ub2RlVHlwZSA9IEFUVFJJQlVURV9OT0RFO1xuX2V4dGVuZHMoQXR0cixOb2RlKTtcblxuXG5mdW5jdGlvbiBDaGFyYWN0ZXJEYXRhKCkge1xufTtcbkNoYXJhY3RlckRhdGEucHJvdG90eXBlID0ge1xuXHRkYXRhIDogJycsXG5cdHN1YnN0cmluZ0RhdGEgOiBmdW5jdGlvbihvZmZzZXQsIGNvdW50KSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQrY291bnQpO1xuXHR9LFxuXHRhcHBlbmREYXRhOiBmdW5jdGlvbih0ZXh0KSB7XG5cdFx0dGV4dCA9IHRoaXMuZGF0YSt0ZXh0O1xuXHRcdHRoaXMubm9kZVZhbHVlID0gdGhpcy5kYXRhID0gdGV4dDtcblx0XHR0aGlzLmxlbmd0aCA9IHRleHQubGVuZ3RoO1xuXHR9LFxuXHRpbnNlcnREYXRhOiBmdW5jdGlvbihvZmZzZXQsdGV4dCkge1xuXHRcdHRoaXMucmVwbGFjZURhdGEob2Zmc2V0LDAsdGV4dCk7XG5cdFxuXHR9LFxuXHRhcHBlbmRDaGlsZDpmdW5jdGlvbihuZXdDaGlsZCl7XG5cdFx0Ly9pZighKG5ld0NoaWxkIGluc3RhbmNlb2YgQ2hhcmFjdGVyRGF0YSkpe1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKEV4Y2VwdGlvbk1lc3NhZ2VbM10pXG5cdFx0Ly99XG5cdFx0cmV0dXJuIE5vZGUucHJvdG90eXBlLmFwcGVuZENoaWxkLmFwcGx5KHRoaXMsYXJndW1lbnRzKVxuXHR9LFxuXHRkZWxldGVEYXRhOiBmdW5jdGlvbihvZmZzZXQsIGNvdW50KSB7XG5cdFx0dGhpcy5yZXBsYWNlRGF0YShvZmZzZXQsY291bnQsXCJcIik7XG5cdH0sXG5cdHJlcGxhY2VEYXRhOiBmdW5jdGlvbihvZmZzZXQsIGNvdW50LCB0ZXh0KSB7XG5cdFx0dmFyIHN0YXJ0ID0gdGhpcy5kYXRhLnN1YnN0cmluZygwLG9mZnNldCk7XG5cdFx0dmFyIGVuZCA9IHRoaXMuZGF0YS5zdWJzdHJpbmcob2Zmc2V0K2NvdW50KTtcblx0XHR0ZXh0ID0gc3RhcnQgKyB0ZXh0ICsgZW5kO1xuXHRcdHRoaXMubm9kZVZhbHVlID0gdGhpcy5kYXRhID0gdGV4dDtcblx0XHR0aGlzLmxlbmd0aCA9IHRleHQubGVuZ3RoO1xuXHR9XG59XG5fZXh0ZW5kcyhDaGFyYWN0ZXJEYXRhLE5vZGUpO1xuZnVuY3Rpb24gVGV4dCgpIHtcbn07XG5UZXh0LnByb3RvdHlwZSA9IHtcblx0bm9kZU5hbWUgOiBcIiN0ZXh0XCIsXG5cdG5vZGVUeXBlIDogVEVYVF9OT0RFLFxuXHRzcGxpdFRleHQgOiBmdW5jdGlvbihvZmZzZXQpIHtcblx0XHR2YXIgdGV4dCA9IHRoaXMuZGF0YTtcblx0XHR2YXIgbmV3VGV4dCA9IHRleHQuc3Vic3RyaW5nKG9mZnNldCk7XG5cdFx0dGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIG9mZnNldCk7XG5cdFx0dGhpcy5kYXRhID0gdGhpcy5ub2RlVmFsdWUgPSB0ZXh0O1xuXHRcdHRoaXMubGVuZ3RoID0gdGV4dC5sZW5ndGg7XG5cdFx0dmFyIG5ld05vZGUgPSB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobmV3VGV4dCk7XG5cdFx0aWYodGhpcy5wYXJlbnROb2RlKXtcblx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgdGhpcy5uZXh0U2libGluZyk7XG5cdFx0fVxuXHRcdHJldHVybiBuZXdOb2RlO1xuXHR9XG59XG5fZXh0ZW5kcyhUZXh0LENoYXJhY3RlckRhdGEpO1xuZnVuY3Rpb24gQ29tbWVudCgpIHtcbn07XG5Db21tZW50LnByb3RvdHlwZSA9IHtcblx0bm9kZU5hbWUgOiBcIiNjb21tZW50XCIsXG5cdG5vZGVUeXBlIDogQ09NTUVOVF9OT0RFXG59XG5fZXh0ZW5kcyhDb21tZW50LENoYXJhY3RlckRhdGEpO1xuXG5mdW5jdGlvbiBDREFUQVNlY3Rpb24oKSB7XG59O1xuQ0RBVEFTZWN0aW9uLnByb3RvdHlwZSA9IHtcblx0bm9kZU5hbWUgOiBcIiNjZGF0YS1zZWN0aW9uXCIsXG5cdG5vZGVUeXBlIDogQ0RBVEFfU0VDVElPTl9OT0RFXG59XG5fZXh0ZW5kcyhDREFUQVNlY3Rpb24sQ2hhcmFjdGVyRGF0YSk7XG5cblxuZnVuY3Rpb24gRG9jdW1lbnRUeXBlKCkge1xufTtcbkRvY3VtZW50VHlwZS5wcm90b3R5cGUubm9kZVR5cGUgPSBET0NVTUVOVF9UWVBFX05PREU7XG5fZXh0ZW5kcyhEb2N1bWVudFR5cGUsTm9kZSk7XG5cbmZ1bmN0aW9uIE5vdGF0aW9uKCkge1xufTtcbk5vdGF0aW9uLnByb3RvdHlwZS5ub2RlVHlwZSA9IE5PVEFUSU9OX05PREU7XG5fZXh0ZW5kcyhOb3RhdGlvbixOb2RlKTtcblxuZnVuY3Rpb24gRW50aXR5KCkge1xufTtcbkVudGl0eS5wcm90b3R5cGUubm9kZVR5cGUgPSBFTlRJVFlfTk9ERTtcbl9leHRlbmRzKEVudGl0eSxOb2RlKTtcblxuZnVuY3Rpb24gRW50aXR5UmVmZXJlbmNlKCkge1xufTtcbkVudGl0eVJlZmVyZW5jZS5wcm90b3R5cGUubm9kZVR5cGUgPSBFTlRJVFlfUkVGRVJFTkNFX05PREU7XG5fZXh0ZW5kcyhFbnRpdHlSZWZlcmVuY2UsTm9kZSk7XG5cbmZ1bmN0aW9uIERvY3VtZW50RnJhZ21lbnQoKSB7XG59O1xuRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUubm9kZU5hbWUgPVx0XCIjZG9jdW1lbnQtZnJhZ21lbnRcIjtcbkRvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLm5vZGVUeXBlID1cdERPQ1VNRU5UX0ZSQUdNRU5UX05PREU7XG5fZXh0ZW5kcyhEb2N1bWVudEZyYWdtZW50LE5vZGUpO1xuXG5cbmZ1bmN0aW9uIFByb2Nlc3NpbmdJbnN0cnVjdGlvbigpIHtcbn1cblByb2Nlc3NpbmdJbnN0cnVjdGlvbi5wcm90b3R5cGUubm9kZVR5cGUgPSBQUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREU7XG5fZXh0ZW5kcyhQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sTm9kZSk7XG5mdW5jdGlvbiBYTUxTZXJpYWxpemVyKCl7fVxuWE1MU2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplVG9TdHJpbmcgPSBmdW5jdGlvbihub2RlKXtcblx0dmFyIGJ1ZiA9IFtdO1xuXHRzZXJpYWxpemVUb1N0cmluZyhub2RlLGJ1Zik7XG5cdHJldHVybiBidWYuam9pbignJyk7XG59XG5Ob2RlLnByb3RvdHlwZS50b1N0cmluZyA9ZnVuY3Rpb24oKXtcblx0cmV0dXJuIFhNTFNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZVRvU3RyaW5nKHRoaXMpO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplVG9TdHJpbmcobm9kZSxidWYpe1xuXHRzd2l0Y2gobm9kZS5ub2RlVHlwZSl7XG5cdGNhc2UgRUxFTUVOVF9OT0RFOlxuXHRcdHZhciBhdHRycyA9IG5vZGUuYXR0cmlidXRlcztcblx0XHR2YXIgbGVuID0gYXR0cnMubGVuZ3RoO1xuXHRcdHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcblx0XHR2YXIgbm9kZU5hbWUgPSBub2RlLnRhZ05hbWU7XG5cdFx0dmFyIGlzSFRNTCA9IGh0bWxucyA9PT0gbm9kZS5uYW1lc3BhY2VVUklcblx0XHRidWYucHVzaCgnPCcsbm9kZU5hbWUpO1xuXHRcdGZvcih2YXIgaT0wO2k8bGVuO2krKyl7XG5cdFx0XHRzZXJpYWxpemVUb1N0cmluZyhhdHRycy5pdGVtKGkpLGJ1Zixpc0hUTUwpO1xuXHRcdH1cblx0XHRpZihjaGlsZCB8fCBpc0hUTUwgJiYgIS9eKD86bWV0YXxsaW5rfGltZ3xicnxocnxpbnB1dCkkL2kudGVzdChub2RlTmFtZSkpe1xuXHRcdFx0YnVmLnB1c2goJz4nKTtcblx0XHRcdC8vaWYgaXMgY2RhdGEgY2hpbGQgbm9kZVxuXHRcdFx0aWYoaXNIVE1MICYmIC9ec2NyaXB0JC9pLnRlc3Qobm9kZU5hbWUpKXtcblx0XHRcdFx0aWYoY2hpbGQpe1xuXHRcdFx0XHRcdGJ1Zi5wdXNoKGNoaWxkLmRhdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0d2hpbGUoY2hpbGQpe1xuXHRcdFx0XHRcdHNlcmlhbGl6ZVRvU3RyaW5nKGNoaWxkLGJ1Zik7XG5cdFx0XHRcdFx0Y2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0YnVmLnB1c2goJzwvJyxub2RlTmFtZSwnPicpO1xuXHRcdH1lbHNle1xuXHRcdFx0YnVmLnB1c2goJy8+Jyk7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0Y2FzZSBET0NVTUVOVF9OT0RFOlxuXHRjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG5cdFx0dmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXHRcdHdoaWxlKGNoaWxkKXtcblx0XHRcdHNlcmlhbGl6ZVRvU3RyaW5nKGNoaWxkLGJ1Zik7XG5cdFx0XHRjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdGNhc2UgQVRUUklCVVRFX05PREU6XG5cdFx0cmV0dXJuIGJ1Zi5wdXNoKCcgJyxub2RlLm5hbWUsJz1cIicsbm9kZS52YWx1ZS5yZXBsYWNlKC9bPCZcIl0vZyxfeG1sRW5jb2RlciksJ1wiJyk7XG5cdGNhc2UgVEVYVF9OT0RFOlxuXHRcdHJldHVybiBidWYucHVzaChub2RlLmRhdGEucmVwbGFjZSgvWzwmXS9nLF94bWxFbmNvZGVyKSk7XG5cdGNhc2UgQ0RBVEFfU0VDVElPTl9OT0RFOlxuXHRcdHJldHVybiBidWYucHVzaCggJzwhW0NEQVRBWycsbm9kZS5kYXRhLCddXT4nKTtcblx0Y2FzZSBDT01NRU5UX05PREU6XG5cdFx0cmV0dXJuIGJ1Zi5wdXNoKCBcIjwhLS1cIixub2RlLmRhdGEsXCItLT5cIik7XG5cdGNhc2UgRE9DVU1FTlRfVFlQRV9OT0RFOlxuXHRcdHZhciBwdWJpZCA9IG5vZGUucHVibGljSWQ7XG5cdFx0dmFyIHN5c2lkID0gbm9kZS5zeXN0ZW1JZDtcblx0XHRidWYucHVzaCgnPCFET0NUWVBFICcsbm9kZS5uYW1lKTtcblx0XHRpZihwdWJpZCl7XG5cdFx0XHRidWYucHVzaCgnIFBVQkxJQyBcIicscHViaWQpO1xuXHRcdFx0aWYgKHN5c2lkICYmIHN5c2lkIT0nLicpIHtcblx0XHRcdFx0YnVmLnB1c2goICdcIiBcIicsc3lzaWQpO1xuXHRcdFx0fVxuXHRcdFx0YnVmLnB1c2goJ1wiPicpO1xuXHRcdH1lbHNlIGlmKHN5c2lkICYmIHN5c2lkIT0nLicpe1xuXHRcdFx0YnVmLnB1c2goJyBTWVNURU0gXCInLHN5c2lkLCdcIj4nKTtcblx0XHR9ZWxzZXtcblx0XHRcdHZhciBzdWIgPSBub2RlLmludGVybmFsU3Vic2V0O1xuXHRcdFx0aWYoc3ViKXtcblx0XHRcdFx0YnVmLnB1c2goXCIgW1wiLHN1YixcIl1cIik7XG5cdFx0XHR9XG5cdFx0XHRidWYucHVzaChcIj5cIik7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0Y2FzZSBQUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREU6XG5cdFx0cmV0dXJuIGJ1Zi5wdXNoKCBcIjw/XCIsbm9kZS50YXJnZXQsXCIgXCIsbm9kZS5kYXRhLFwiPz5cIik7XG5cdGNhc2UgRU5USVRZX1JFRkVSRU5DRV9OT0RFOlxuXHRcdHJldHVybiBidWYucHVzaCggJyYnLG5vZGUubm9kZU5hbWUsJzsnKTtcblx0Ly9jYXNlIEVOVElUWV9OT0RFOlxuXHQvL2Nhc2UgTk9UQVRJT05fTk9ERTpcblx0ZGVmYXVsdDpcblx0XHRidWYucHVzaCgnPz8nLG5vZGUubm9kZU5hbWUpO1xuXHR9XG59XG5mdW5jdGlvbiBpbXBvcnROb2RlKGRvYyxub2RlLGRlZXApe1xuXHR2YXIgbm9kZTI7XG5cdHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuXHRjYXNlIEVMRU1FTlRfTk9ERTpcblx0XHRub2RlMiA9IG5vZGUuY2xvbmVOb2RlKGZhbHNlKTtcblx0XHRub2RlMi5vd25lckRvY3VtZW50ID0gZG9jO1xuXHRcdC8vdmFyIGF0dHJzID0gbm9kZTIuYXR0cmlidXRlcztcblx0XHQvL3ZhciBsZW4gPSBhdHRycy5sZW5ndGg7XG5cdFx0Ly9mb3IodmFyIGk9MDtpPGxlbjtpKyspe1xuXHRcdFx0Ly9ub2RlMi5zZXRBdHRyaWJ1dGVOb2RlTlMoaW1wb3J0Tm9kZShkb2MsYXR0cnMuaXRlbShpKSxkZWVwKSk7XG5cdFx0Ly99XG5cdGNhc2UgRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcblx0XHRicmVhaztcblx0Y2FzZSBBVFRSSUJVVEVfTk9ERTpcblx0XHRkZWVwID0gdHJ1ZTtcblx0XHRicmVhaztcblx0Ly9jYXNlIEVOVElUWV9SRUZFUkVOQ0VfTk9ERTpcblx0Ly9jYXNlIFBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERTpcblx0Ly8vL2Nhc2UgVEVYVF9OT0RFOlxuXHQvL2Nhc2UgQ0RBVEFfU0VDVElPTl9OT0RFOlxuXHQvL2Nhc2UgQ09NTUVOVF9OT0RFOlxuXHQvL1x0ZGVlcCA9IGZhbHNlO1xuXHQvL1x0YnJlYWs7XG5cdC8vY2FzZSBET0NVTUVOVF9OT0RFOlxuXHQvL2Nhc2UgRE9DVU1FTlRfVFlQRV9OT0RFOlxuXHQvL2Nhbm5vdCBiZSBpbXBvcnRlZC5cblx0Ly9jYXNlIEVOVElUWV9OT0RFOlxuXHQvL2Nhc2UgTk9UQVRJT05fTk9ERe+8mlxuXHQvL2NhbiBub3QgaGl0IGluIGxldmVsM1xuXHQvL2RlZmF1bHQ6dGhyb3cgZTtcblx0fVxuXHRpZighbm9kZTIpe1xuXHRcdG5vZGUyID0gbm9kZS5jbG9uZU5vZGUoZmFsc2UpOy8vZmFsc2Vcblx0fVxuXHRub2RlMi5vd25lckRvY3VtZW50ID0gZG9jO1xuXHRub2RlMi5wYXJlbnROb2RlID0gbnVsbDtcblx0aWYoZGVlcCl7XG5cdFx0dmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXHRcdHdoaWxlKGNoaWxkKXtcblx0XHRcdG5vZGUyLmFwcGVuZENoaWxkKGltcG9ydE5vZGUoZG9jLGNoaWxkLGRlZXApKTtcblx0XHRcdGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBub2RlMjtcbn1cbi8vXG4vL3ZhciBfcmVsYXRpb25NYXAgPSB7Zmlyc3RDaGlsZDoxLGxhc3RDaGlsZDoxLHByZXZpb3VzU2libGluZzoxLG5leHRTaWJsaW5nOjEsXG4vL1x0XHRcdFx0XHRhdHRyaWJ1dGVzOjEsY2hpbGROb2RlczoxLHBhcmVudE5vZGU6MSxkb2N1bWVudEVsZW1lbnQ6MSxkb2N0eXBlLH07XG5mdW5jdGlvbiBjbG9uZU5vZGUoZG9jLG5vZGUsZGVlcCl7XG5cdHZhciBub2RlMiA9IG5ldyBub2RlLmNvbnN0cnVjdG9yKCk7XG5cdGZvcih2YXIgbiBpbiBub2RlKXtcblx0XHR2YXIgdiA9IG5vZGVbbl07XG5cdFx0aWYodHlwZW9mIHYgIT0gJ29iamVjdCcgKXtcblx0XHRcdGlmKHYgIT0gbm9kZTJbbl0pe1xuXHRcdFx0XHRub2RlMltuXSA9IHY7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGlmKG5vZGUuY2hpbGROb2Rlcyl7XG5cdFx0bm9kZTIuY2hpbGROb2RlcyA9IG5ldyBOb2RlTGlzdCgpO1xuXHR9XG5cdG5vZGUyLm93bmVyRG9jdW1lbnQgPSBkb2M7XG5cdHN3aXRjaCAobm9kZTIubm9kZVR5cGUpIHtcblx0Y2FzZSBFTEVNRU5UX05PREU6XG5cdFx0dmFyIGF0dHJzXHQ9IG5vZGUuYXR0cmlidXRlcztcblx0XHR2YXIgYXR0cnMyXHQ9IG5vZGUyLmF0dHJpYnV0ZXMgPSBuZXcgTmFtZWROb2RlTWFwKCk7XG5cdFx0dmFyIGxlbiA9IGF0dHJzLmxlbmd0aFxuXHRcdGF0dHJzMi5fb3duZXJFbGVtZW50ID0gbm9kZTI7XG5cdFx0Zm9yKHZhciBpPTA7aTxsZW47aSsrKXtcblx0XHRcdG5vZGUyLnNldEF0dHJpYnV0ZU5vZGUoY2xvbmVOb2RlKGRvYyxhdHRycy5pdGVtKGkpLHRydWUpKTtcblx0XHR9XG5cdFx0YnJlYWs7O1xuXHRjYXNlIEFUVFJJQlVURV9OT0RFOlxuXHRcdGRlZXAgPSB0cnVlO1xuXHR9XG5cdGlmKGRlZXApe1xuXHRcdHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcblx0XHR3aGlsZShjaGlsZCl7XG5cdFx0XHRub2RlMi5hcHBlbmRDaGlsZChjbG9uZU5vZGUoZG9jLGNoaWxkLGRlZXApKTtcblx0XHRcdGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBub2RlMjtcbn1cblxuZnVuY3Rpb24gX19zZXRfXyhvYmplY3Qsa2V5LHZhbHVlKXtcblx0b2JqZWN0W2tleV0gPSB2YWx1ZVxufVxuLy9kbyBkeW5hbWljXG50cnl7XG5cdGlmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSl7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KExpdmVOb2RlTGlzdC5wcm90b3R5cGUsJ2xlbmd0aCcse1xuXHRcdFx0Z2V0OmZ1bmN0aW9uKCl7XG5cdFx0XHRcdF91cGRhdGVMaXZlTGlzdCh0aGlzKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuJCRsZW5ndGg7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGUucHJvdG90eXBlLCd0ZXh0Q29udGVudCcse1xuXHRcdFx0Z2V0OmZ1bmN0aW9uKCl7XG5cdFx0XHRcdHJldHVybiBnZXRUZXh0Q29udGVudCh0aGlzKTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6ZnVuY3Rpb24oZGF0YSl7XG5cdFx0XHRcdHN3aXRjaCh0aGlzLm5vZGVUeXBlKXtcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRjYXNlIDExOlxuXHRcdFx0XHRcdHdoaWxlKHRoaXMuZmlyc3RDaGlsZCl7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbW92ZUNoaWxkKHRoaXMuZmlyc3RDaGlsZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGRhdGEgfHwgU3RyaW5nKGRhdGEpKXtcblx0XHRcdFx0XHRcdHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGEpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0Ly9UT0RPOlxuXHRcdFx0XHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdHRoaXMubm9kZVZhbHVlID0gZGF0YTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pXG5cdFx0XG5cdFx0ZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnQobm9kZSl7XG5cdFx0XHRzd2l0Y2gobm9kZS5ub2RlVHlwZSl7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRjYXNlIDExOlxuXHRcdFx0XHR2YXIgYnVmID0gW107XG5cdFx0XHRcdG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG5cdFx0XHRcdHdoaWxlKG5vZGUpe1xuXHRcdFx0XHRcdGlmKG5vZGUubm9kZVR5cGUhPT03ICYmIG5vZGUubm9kZVR5cGUgIT09OCl7XG5cdFx0XHRcdFx0XHRidWYucHVzaChnZXRUZXh0Q29udGVudChub2RlKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBidWYuam9pbignJyk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gbm9kZS5ub2RlVmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdF9fc2V0X18gPSBmdW5jdGlvbihvYmplY3Qsa2V5LHZhbHVlKXtcblx0XHRcdC8vY29uc29sZS5sb2codmFsdWUpXG5cdFx0XHRvYmplY3RbJyQkJytrZXldID0gdmFsdWVcblx0XHR9XG5cdH1cbn1jYXRjaChlKXsvL2llOFxufVxuXG5pZih0eXBlb2YgcmVxdWlyZSA9PSAnZnVuY3Rpb24nKXtcblx0ZXhwb3J0cy5ET01JbXBsZW1lbnRhdGlvbiA9IERPTUltcGxlbWVudGF0aW9uO1xuXHRleHBvcnRzLlhNTFNlcmlhbGl6ZXIgPSBYTUxTZXJpYWxpemVyO1xufVxuIiwiLy9bNF0gICBcdE5hbWVTdGFydENoYXJcdCAgIDo6PSAgIFx0XCI6XCIgfCBbQS1aXSB8IFwiX1wiIHwgW2Etel0gfCBbI3hDMC0jeEQ2XSB8IFsjeEQ4LSN4RjZdIHwgWyN4RjgtI3gyRkZdIHwgWyN4MzcwLSN4MzdEXSB8IFsjeDM3Ri0jeDFGRkZdIHwgWyN4MjAwQy0jeDIwMERdIHwgWyN4MjA3MC0jeDIxOEZdIHwgWyN4MkMwMC0jeDJGRUZdIHwgWyN4MzAwMS0jeEQ3RkZdIHwgWyN4RjkwMC0jeEZEQ0ZdIHwgWyN4RkRGMC0jeEZGRkRdIHwgWyN4MTAwMDAtI3hFRkZGRl1cclxuLy9bNGFdICAgXHROYW1lQ2hhclx0ICAgOjo9ICAgXHROYW1lU3RhcnRDaGFyIHwgXCItXCIgfCBcIi5cIiB8IFswLTldIHwgI3hCNyB8IFsjeDAzMDAtI3gwMzZGXSB8IFsjeDIwM0YtI3gyMDQwXVxyXG4vL1s1XSAgIFx0TmFtZVx0ICAgOjo9ICAgXHROYW1lU3RhcnRDaGFyIChOYW1lQ2hhcikqXHJcbnZhciBuYW1lU3RhcnRDaGFyID0gL1tBLVpfYS16XFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF0vLy9cXHUxMDAwMC1cXHVFRkZGRlxyXG52YXIgbmFtZUNoYXIgPSBuZXcgUmVnRXhwKFwiW1xcXFwtXFxcXC4wLTlcIituYW1lU3RhcnRDaGFyLnNvdXJjZS5zbGljZSgxLC0xKStcIlxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXFxcdXgyMDNGLVxcdTIwNDBdXCIpO1xyXG52YXIgdGFnTmFtZVBhdHRlcm4gPSBuZXcgUmVnRXhwKCdeJytuYW1lU3RhcnRDaGFyLnNvdXJjZStuYW1lQ2hhci5zb3VyY2UrJyooPzpcXDonK25hbWVTdGFydENoYXIuc291cmNlK25hbWVDaGFyLnNvdXJjZSsnKik/JCcpO1xyXG4vL3ZhciB0YWdOYW1lUGF0dGVybiA9IC9eW2EtekEtWl9dW1xcd1xcLVxcLl0qKD86XFw6W2EtekEtWl9dW1xcd1xcLVxcLl0qKT8kL1xyXG4vL3ZhciBoYW5kbGVycyA9ICdyZXNvbHZlRW50aXR5LGdldEV4dGVybmFsU3Vic2V0LGNoYXJhY3RlcnMsZW5kRG9jdW1lbnQsZW5kRWxlbWVudCxlbmRQcmVmaXhNYXBwaW5nLGlnbm9yYWJsZVdoaXRlc3BhY2UscHJvY2Vzc2luZ0luc3RydWN0aW9uLHNldERvY3VtZW50TG9jYXRvcixza2lwcGVkRW50aXR5LHN0YXJ0RG9jdW1lbnQsc3RhcnRFbGVtZW50LHN0YXJ0UHJlZml4TWFwcGluZyxub3RhdGlvbkRlY2wsdW5wYXJzZWRFbnRpdHlEZWNsLGVycm9yLGZhdGFsRXJyb3Isd2FybmluZyxhdHRyaWJ1dGVEZWNsLGVsZW1lbnREZWNsLGV4dGVybmFsRW50aXR5RGVjbCxpbnRlcm5hbEVudGl0eURlY2wsY29tbWVudCxlbmRDREFUQSxlbmREVEQsZW5kRW50aXR5LHN0YXJ0Q0RBVEEsc3RhcnREVEQsc3RhcnRFbnRpdHknLnNwbGl0KCcsJylcclxuXHJcbi8vU19UQUcsXHRTX0FUVFIsXHRTX0VRLFx0U19WXHJcbi8vU19BVFRSX1MsXHRTX0UsXHRTX1MsXHRTX0NcclxudmFyIFNfVEFHID0gMDsvL3RhZyBuYW1lIG9mZmVycmluZ1xyXG52YXIgU19BVFRSID0gMTsvL2F0dHIgbmFtZSBvZmZlcnJpbmcgXHJcbnZhciBTX0FUVFJfUz0yOy8vYXR0ciBuYW1lIGVuZCBhbmQgc3BhY2Ugb2ZmZXJcclxudmFyIFNfRVEgPSAzOy8vPXNwYWNlP1xyXG52YXIgU19WID0gNDsvL2F0dHIgdmFsdWUobm8gcXVvdCB2YWx1ZSBvbmx5KVxyXG52YXIgU19FID0gNTsvL2F0dHIgdmFsdWUgZW5kIGFuZCBubyBzcGFjZShxdW90IGVuZClcclxudmFyIFNfUyA9IDY7Ly8oYXR0ciB2YWx1ZSBlbmQgfHwgdGFnIGVuZCApICYmIChzcGFjZSBvZmZlcilcclxudmFyIFNfQyA9IDc7Ly9jbG9zZWQgZWw8ZWwgLz5cclxuXHJcbmZ1bmN0aW9uIFhNTFJlYWRlcigpe1xyXG5cdFxyXG59XHJcblxyXG5YTUxSZWFkZXIucHJvdG90eXBlID0ge1xyXG5cdHBhcnNlOmZ1bmN0aW9uKHNvdXJjZSxkZWZhdWx0TlNNYXAsZW50aXR5TWFwKXtcclxuXHRcdHZhciBkb21CdWlsZGVyID0gdGhpcy5kb21CdWlsZGVyO1xyXG5cdFx0ZG9tQnVpbGRlci5zdGFydERvY3VtZW50KCk7XHJcblx0XHRfY29weShkZWZhdWx0TlNNYXAgLGRlZmF1bHROU01hcCA9IHt9KVxyXG5cdFx0cGFyc2Uoc291cmNlLGRlZmF1bHROU01hcCxlbnRpdHlNYXAsXHJcblx0XHRcdFx0ZG9tQnVpbGRlcix0aGlzLmVycm9ySGFuZGxlcik7XHJcblx0XHRkb21CdWlsZGVyLmVuZERvY3VtZW50KCk7XHJcblx0fVxyXG59XHJcbmZ1bmN0aW9uIHBhcnNlKHNvdXJjZSxkZWZhdWx0TlNNYXBDb3B5LGVudGl0eU1hcCxkb21CdWlsZGVyLGVycm9ySGFuZGxlcil7XHJcbiAgZnVuY3Rpb24gZml4ZWRGcm9tQ2hhckNvZGUoY29kZSkge1xyXG5cdFx0Ly8gU3RyaW5nLnByb3RvdHlwZS5mcm9tQ2hhckNvZGUgZG9lcyBub3Qgc3VwcG9ydHNcclxuXHRcdC8vID4gMiBieXRlcyB1bmljb2RlIGNoYXJzIGRpcmVjdGx5XHJcblx0XHRpZiAoY29kZSA+IDB4ZmZmZikge1xyXG5cdFx0XHRjb2RlIC09IDB4MTAwMDA7XHJcblx0XHRcdHZhciBzdXJyb2dhdGUxID0gMHhkODAwICsgKGNvZGUgPj4gMTApXHJcblx0XHRcdFx0LCBzdXJyb2dhdGUyID0gMHhkYzAwICsgKGNvZGUgJiAweDNmZik7XHJcblxyXG5cdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShzdXJyb2dhdGUxLCBzdXJyb2dhdGUyKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRmdW5jdGlvbiBlbnRpdHlSZXBsYWNlcihhKXtcclxuXHRcdHZhciBrID0gYS5zbGljZSgxLC0xKTtcclxuXHRcdGlmKGsgaW4gZW50aXR5TWFwKXtcclxuXHRcdFx0cmV0dXJuIGVudGl0eU1hcFtrXTsgXHJcblx0XHR9ZWxzZSBpZihrLmNoYXJBdCgwKSA9PT0gJyMnKXtcclxuXHRcdFx0cmV0dXJuIGZpeGVkRnJvbUNoYXJDb2RlKHBhcnNlSW50KGsuc3Vic3RyKDEpLnJlcGxhY2UoJ3gnLCcweCcpKSlcclxuXHRcdH1lbHNle1xyXG5cdFx0XHRlcnJvckhhbmRsZXIuZXJyb3IoJ2VudGl0eSBub3QgZm91bmQ6JythKTtcclxuXHRcdFx0cmV0dXJuIGE7XHJcblx0XHR9XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGFwcGVuZFRleHQoZW5kKXsvL2hhcyBzb21lIGJ1Z3NcclxuXHRcdHZhciB4dCA9IHNvdXJjZS5zdWJzdHJpbmcoc3RhcnQsZW5kKS5yZXBsYWNlKC8mIz9cXHcrOy9nLGVudGl0eVJlcGxhY2VyKTtcclxuXHRcdGxvY2F0b3ImJnBvc2l0aW9uKHN0YXJ0KTtcclxuXHRcdGRvbUJ1aWxkZXIuY2hhcmFjdGVycyh4dCwwLGVuZC1zdGFydCk7XHJcblx0XHRzdGFydCA9IGVuZFxyXG5cdH1cclxuXHRmdW5jdGlvbiBwb3NpdGlvbihzdGFydCxtKXtcclxuXHRcdHdoaWxlKHN0YXJ0Pj1lbmRQb3MgJiYgKG0gPSBsaW5lUGF0dGVybi5leGVjKHNvdXJjZSkpKXtcclxuXHRcdFx0c3RhcnRQb3MgPSBtLmluZGV4O1xyXG5cdFx0XHRlbmRQb3MgPSBzdGFydFBvcyArIG1bMF0ubGVuZ3RoO1xyXG5cdFx0XHRsb2NhdG9yLmxpbmVOdW1iZXIrKztcclxuXHRcdFx0Ly9jb25zb2xlLmxvZygnbGluZSsrOicsbG9jYXRvcixzdGFydFBvcyxlbmRQb3MpXHJcblx0XHR9XHJcblx0XHRsb2NhdG9yLmNvbHVtbk51bWJlciA9IHN0YXJ0LXN0YXJ0UG9zKzE7XHJcblx0fVxyXG5cdHZhciBzdGFydFBvcyA9IDA7XHJcblx0dmFyIGVuZFBvcyA9IDA7XHJcblx0dmFyIGxpbmVQYXR0ZXJuID0gLy4rKD86XFxyXFxuP3xcXG4pfC4qJC9nXHJcblx0dmFyIGxvY2F0b3IgPSBkb21CdWlsZGVyLmxvY2F0b3I7XHJcblx0XHJcblx0dmFyIHBhcnNlU3RhY2sgPSBbe2N1cnJlbnROU01hcDpkZWZhdWx0TlNNYXBDb3B5fV1cclxuXHR2YXIgY2xvc2VNYXAgPSB7fTtcclxuXHR2YXIgc3RhcnQgPSAwO1xyXG5cdHdoaWxlKHRydWUpe1xyXG5cdFx0dmFyIGkgPSBzb3VyY2UuaW5kZXhPZignPCcsc3RhcnQpO1xyXG5cdFx0aWYoaTwwKXtcclxuXHRcdFx0aWYoIXNvdXJjZS5zdWJzdHIoc3RhcnQpLm1hdGNoKC9eXFxzKiQvKSl7XHJcblx0XHRcdFx0dmFyIGRvYyA9IGRvbUJ1aWxkZXIuZG9jdW1lbnQ7XHJcbiAgICBcdFx0XHR2YXIgdGV4dCA9IGRvYy5jcmVhdGVUZXh0Tm9kZShzb3VyY2Uuc3Vic3RyKHN0YXJ0KSk7XHJcbiAgICBcdFx0XHRkb2MuYXBwZW5kQ2hpbGQodGV4dCk7XHJcbiAgICBcdFx0XHRkb21CdWlsZGVyLmN1cnJlbnRFbGVtZW50ID0gdGV4dDtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRpZihpPnN0YXJ0KXtcclxuXHRcdFx0YXBwZW5kVGV4dChpKTtcclxuXHRcdH1cclxuXHRcdHN3aXRjaChzb3VyY2UuY2hhckF0KGkrMSkpe1xyXG5cdFx0Y2FzZSAnLyc6XHJcblx0XHRcdHZhciBlbmQgPSBzb3VyY2UuaW5kZXhPZignPicsaSszKTtcclxuXHRcdFx0dmFyIHRhZ05hbWUgPSBzb3VyY2Uuc3Vic3RyaW5nKGkrMixlbmQpO1xyXG5cdFx0XHR2YXIgY29uZmlnID0gcGFyc2VTdGFjay5wb3AoKTtcclxuXHRcdFx0dmFyIGxvY2FsTlNNYXAgPSBjb25maWcubG9jYWxOU01hcDtcclxuXHRcdFx0XHJcblx0ICAgICAgICBpZihjb25maWcudGFnTmFtZSAhPSB0YWdOYW1lKXtcclxuXHQgICAgICAgICAgICBlcnJvckhhbmRsZXIuZmF0YWxFcnJvcihcImVuZCB0YWcgbmFtZTogXCIrdGFnTmFtZSsnIGlzIG5vdCBtYXRjaCB0aGUgY3VycmVudCBzdGFydCB0YWdOYW1lOicrY29uZmlnLnRhZ05hbWUgKTtcclxuXHQgICAgICAgIH1cclxuXHRcdFx0ZG9tQnVpbGRlci5lbmRFbGVtZW50KGNvbmZpZy51cmksY29uZmlnLmxvY2FsTmFtZSx0YWdOYW1lKTtcclxuXHRcdFx0aWYobG9jYWxOU01hcCl7XHJcblx0XHRcdFx0Zm9yKHZhciBwcmVmaXggaW4gbG9jYWxOU01hcCl7XHJcblx0XHRcdFx0XHRkb21CdWlsZGVyLmVuZFByZWZpeE1hcHBpbmcocHJlZml4KSA7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVuZCsrO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdFx0Ly8gZW5kIGVsbWVudFxyXG5cdFx0Y2FzZSAnPyc6Ly8gPD8uLi4/PlxyXG5cdFx0XHRsb2NhdG9yJiZwb3NpdGlvbihpKTtcclxuXHRcdFx0ZW5kID0gcGFyc2VJbnN0cnVjdGlvbihzb3VyY2UsaSxkb21CdWlsZGVyKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlICchJzovLyA8IWRvY3R5cGUsPCFbQ0RBVEEsPCEtLVxyXG5cdFx0XHRsb2NhdG9yJiZwb3NpdGlvbihpKTtcclxuXHRcdFx0ZW5kID0gcGFyc2VEQ0Moc291cmNlLGksZG9tQnVpbGRlcixlcnJvckhhbmRsZXIpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdHRyeXtcclxuXHRcdFx0XHRsb2NhdG9yJiZwb3NpdGlvbihpKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHR2YXIgZWwgPSBuZXcgRWxlbWVudEF0dHJpYnV0ZXMoKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvL2VsU3RhcnRFbmRcclxuXHRcdFx0XHR2YXIgZW5kID0gcGFyc2VFbGVtZW50U3RhcnRQYXJ0KHNvdXJjZSxpLGVsLGVudGl0eVJlcGxhY2VyLGVycm9ySGFuZGxlcik7XHJcblx0XHRcdFx0dmFyIGxlbiA9IGVsLmxlbmd0aDtcclxuXHRcdFx0XHQvL3Bvc2l0aW9uIGZpeGVkXHJcblx0XHRcdFx0aWYobGVuICYmIGxvY2F0b3Ipe1xyXG5cdFx0XHRcdFx0dmFyIGJhY2t1cCA9IGNvcHlMb2NhdG9yKGxvY2F0b3Ise30pO1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBpID0gMDtpPGxlbjtpKyspe1xyXG5cdFx0XHRcdFx0XHR2YXIgYSA9IGVsW2ldO1xyXG5cdFx0XHRcdFx0XHRwb3NpdGlvbihhLm9mZnNldCk7XHJcblx0XHRcdFx0XHRcdGEub2Zmc2V0ID0gY29weUxvY2F0b3IobG9jYXRvcix7fSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRjb3B5TG9jYXRvcihiYWNrdXAsbG9jYXRvcik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCFlbC5jbG9zZWQgJiYgZml4U2VsZkNsb3NlZChzb3VyY2UsZW5kLGVsLnRhZ05hbWUsY2xvc2VNYXApKXtcclxuXHRcdFx0XHRcdGVsLmNsb3NlZCA9IHRydWU7XHJcblx0XHRcdFx0XHRpZighZW50aXR5TWFwLm5ic3Ape1xyXG5cdFx0XHRcdFx0XHRlcnJvckhhbmRsZXIud2FybmluZygndW5jbG9zZWQgeG1sIGF0dHJpYnV0ZScpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRhcHBlbmRFbGVtZW50KGVsLGRvbUJ1aWxkZXIscGFyc2VTdGFjayk7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0aWYoZWwudXJpID09PSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcgJiYgIWVsLmNsb3NlZCl7XHJcblx0XHRcdFx0XHRlbmQgPSBwYXJzZUh0bWxTcGVjaWFsQ29udGVudChzb3VyY2UsZW5kLGVsLnRhZ05hbWUsZW50aXR5UmVwbGFjZXIsZG9tQnVpbGRlcilcclxuXHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdGVuZCsrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fWNhdGNoKGUpe1xyXG5cdFx0XHRcdGVycm9ySGFuZGxlci5lcnJvcignZWxlbWVudCBwYXJzZSBlcnJvcjogJytlKTtcclxuXHRcdFx0XHRlbmQgPSAtMTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHRcdGlmKGVuZDwwKXtcclxuXHRcdFx0Ly9UT0RPOiDov5nph4zmnInlj6/og71zYXjlm57pgIDvvIzmnInkvY3nva7plJnor6/po47pmalcclxuXHRcdFx0YXBwZW5kVGV4dChpKzEpO1xyXG5cdFx0fWVsc2V7XHJcblx0XHRcdHN0YXJ0ID0gZW5kO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5mdW5jdGlvbiBjb3B5TG9jYXRvcihmLHQpe1xyXG5cdHQubGluZU51bWJlciA9IGYubGluZU51bWJlcjtcclxuXHR0LmNvbHVtbk51bWJlciA9IGYuY29sdW1uTnVtYmVyO1xyXG5cdHJldHVybiB0O1xyXG5cdFxyXG59XHJcblxyXG4vKipcclxuICogQHNlZSAjYXBwZW5kRWxlbWVudChzb3VyY2UsZWxTdGFydEVuZCxlbCxzZWxmQ2xvc2VkLGVudGl0eVJlcGxhY2VyLGRvbUJ1aWxkZXIscGFyc2VTdGFjayk7XHJcbiAqIEByZXR1cm4gZW5kIG9mIHRoZSBlbGVtZW50U3RhcnRQYXJ0KGVuZCBvZiBlbGVtZW50RW5kUGFydCBmb3Igc2VsZkNsb3NlZCBlbClcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlRWxlbWVudFN0YXJ0UGFydChzb3VyY2Usc3RhcnQsZWwsZW50aXR5UmVwbGFjZXIsZXJyb3JIYW5kbGVyKXtcclxuXHR2YXIgYXR0ck5hbWU7XHJcblx0dmFyIHZhbHVlO1xyXG5cdHZhciBwID0gKytzdGFydDtcclxuXHR2YXIgcyA9IFNfVEFHOy8vc3RhdHVzXHJcblx0d2hpbGUodHJ1ZSl7XHJcblx0XHR2YXIgYyA9IHNvdXJjZS5jaGFyQXQocCk7XHJcblx0XHRzd2l0Y2goYyl7XHJcblx0XHRjYXNlICc9JzpcclxuXHRcdFx0aWYocyA9PT0gU19BVFRSKXsvL2F0dHJOYW1lXHJcblx0XHRcdFx0YXR0ck5hbWUgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQscCk7XHJcblx0XHRcdFx0cyA9IFNfRVE7XHJcblx0XHRcdH1lbHNlIGlmKHMgPT09IFNfQVRUUl9TKXtcclxuXHRcdFx0XHRzID0gU19FUTtcclxuXHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0Ly9mYXRhbEVycm9yOiBlcXVhbCBtdXN0IGFmdGVyIGF0dHJOYW1lIG9yIHNwYWNlIGFmdGVyIGF0dHJOYW1lXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdhdHRyaWJ1dGUgZXF1YWwgbXVzdCBhZnRlciBhdHRyTmFtZScpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSAnXFwnJzpcclxuXHRcdGNhc2UgJ1wiJzpcclxuXHRcdFx0aWYocyA9PT0gU19FUSl7Ly9lcXVhbFxyXG5cdFx0XHRcdHN0YXJ0ID0gcCsxO1xyXG5cdFx0XHRcdHAgPSBzb3VyY2UuaW5kZXhPZihjLHN0YXJ0KVxyXG5cdFx0XHRcdGlmKHA+MCl7XHJcblx0XHRcdFx0XHR2YWx1ZSA9IHNvdXJjZS5zbGljZShzdGFydCxwKS5yZXBsYWNlKC8mIz9cXHcrOy9nLGVudGl0eVJlcGxhY2VyKTtcclxuXHRcdFx0XHRcdGVsLmFkZChhdHRyTmFtZSx2YWx1ZSxzdGFydC0xKTtcclxuXHRcdFx0XHRcdHMgPSBTX0U7XHJcblx0XHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0XHQvL2ZhdGFsRXJyb3I6IG5vIGVuZCBxdW90IG1hdGNoXHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2F0dHJpYnV0ZSB2YWx1ZSBubyBlbmQgXFwnJytjKydcXCcgbWF0Y2gnKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1lbHNlIGlmKHMgPT0gU19WKXtcclxuXHRcdFx0XHR2YWx1ZSA9IHNvdXJjZS5zbGljZShzdGFydCxwKS5yZXBsYWNlKC8mIz9cXHcrOy9nLGVudGl0eVJlcGxhY2VyKTtcclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKGF0dHJOYW1lLHZhbHVlLHN0YXJ0LHApXHJcblx0XHRcdFx0ZWwuYWRkKGF0dHJOYW1lLHZhbHVlLHN0YXJ0KTtcclxuXHRcdFx0XHQvL2NvbnNvbGUuZGlyKGVsKVxyXG5cdFx0XHRcdGVycm9ySGFuZGxlci53YXJuaW5nKCdhdHRyaWJ1dGUgXCInK2F0dHJOYW1lKydcIiBtaXNzZWQgc3RhcnQgcXVvdCgnK2MrJykhIScpO1xyXG5cdFx0XHRcdHN0YXJ0ID0gcCsxO1xyXG5cdFx0XHRcdHMgPSBTX0VcclxuXHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0Ly9mYXRhbEVycm9yOiBubyBlcXVhbCBiZWZvcmVcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2F0dHJpYnV0ZSB2YWx1ZSBtdXN0IGFmdGVyIFwiPVwiJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlICcvJzpcclxuXHRcdFx0c3dpdGNoKHMpe1xyXG5cdFx0XHRjYXNlIFNfVEFHOlxyXG5cdFx0XHRcdGVsLnNldFRhZ05hbWUoc291cmNlLnNsaWNlKHN0YXJ0LHApKTtcclxuXHRcdFx0Y2FzZSBTX0U6XHJcblx0XHRcdGNhc2UgU19TOlxyXG5cdFx0XHRjYXNlIFNfQzpcclxuXHRcdFx0XHRzID0gU19DO1xyXG5cdFx0XHRcdGVsLmNsb3NlZCA9IHRydWU7XHJcblx0XHRcdGNhc2UgU19WOlxyXG5cdFx0XHRjYXNlIFNfQVRUUjpcclxuXHRcdFx0Y2FzZSBTX0FUVFJfUzpcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Ly9jYXNlIFNfRVE6XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiYXR0cmlidXRlIGludmFsaWQgY2xvc2UgY2hhcignLycpXCIpXHJcblx0XHRcdH1cclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlICcnOi8vZW5kIGRvY3VtZW50XHJcblx0XHRcdC8vdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpXHJcblx0XHRcdGVycm9ySGFuZGxlci5lcnJvcigndW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnKTtcclxuXHRcdGNhc2UgJz4nOlxyXG5cdFx0XHRzd2l0Y2gocyl7XHJcblx0XHRcdGNhc2UgU19UQUc6XHJcblx0XHRcdFx0ZWwuc2V0VGFnTmFtZShzb3VyY2Uuc2xpY2Uoc3RhcnQscCkpO1xyXG5cdFx0XHRjYXNlIFNfRTpcclxuXHRcdFx0Y2FzZSBTX1M6XHJcblx0XHRcdGNhc2UgU19DOlxyXG5cdFx0XHRcdGJyZWFrOy8vbm9ybWFsXHJcblx0XHRcdGNhc2UgU19WOi8vQ29tcGF0aWJsZSBzdGF0ZVxyXG5cdFx0XHRjYXNlIFNfQVRUUjpcclxuXHRcdFx0XHR2YWx1ZSA9IHNvdXJjZS5zbGljZShzdGFydCxwKTtcclxuXHRcdFx0XHRpZih2YWx1ZS5zbGljZSgtMSkgPT09ICcvJyl7XHJcblx0XHRcdFx0XHRlbC5jbG9zZWQgID0gdHJ1ZTtcclxuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWUuc2xpY2UoMCwtMSlcclxuXHRcdFx0XHR9XHJcblx0XHRcdGNhc2UgU19BVFRSX1M6XHJcblx0XHRcdFx0aWYocyA9PT0gU19BVFRSX1Mpe1xyXG5cdFx0XHRcdFx0dmFsdWUgPSBhdHRyTmFtZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYocyA9PSBTX1Ype1xyXG5cdFx0XHRcdFx0ZXJyb3JIYW5kbGVyLndhcm5pbmcoJ2F0dHJpYnV0ZSBcIicrdmFsdWUrJ1wiIG1pc3NlZCBxdW90KFwiKSEhJyk7XHJcblx0XHRcdFx0XHRlbC5hZGQoYXR0ck5hbWUsdmFsdWUucmVwbGFjZSgvJiM/XFx3KzsvZyxlbnRpdHlSZXBsYWNlciksc3RhcnQpXHJcblx0XHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0XHRlcnJvckhhbmRsZXIud2FybmluZygnYXR0cmlidXRlIFwiJyt2YWx1ZSsnXCIgbWlzc2VkIHZhbHVlISEgXCInK3ZhbHVlKydcIiBpbnN0ZWFkISEnKVxyXG5cdFx0XHRcdFx0ZWwuYWRkKHZhbHVlLHZhbHVlLHN0YXJ0KVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBTX0VROlxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignYXR0cmlidXRlIHZhbHVlIG1pc3NlZCEhJyk7XHJcblx0XHRcdH1cclxuLy9cdFx0XHRjb25zb2xlLmxvZyh0YWdOYW1lLHRhZ05hbWVQYXR0ZXJuLHRhZ05hbWVQYXR0ZXJuLnRlc3QodGFnTmFtZSkpXHJcblx0XHRcdHJldHVybiBwO1xyXG5cdFx0Lyp4bWwgc3BhY2UgJ1xceDIwJyB8ICN4OSB8ICN4RCB8ICN4QTsgKi9cclxuXHRcdGNhc2UgJ1xcdTAwODAnOlxyXG5cdFx0XHRjID0gJyAnO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0aWYoYzw9ICcgJyl7Ly9zcGFjZVxyXG5cdFx0XHRcdHN3aXRjaChzKXtcclxuXHRcdFx0XHRjYXNlIFNfVEFHOlxyXG5cdFx0XHRcdFx0ZWwuc2V0VGFnTmFtZShzb3VyY2Uuc2xpY2Uoc3RhcnQscCkpOy8vdGFnTmFtZVxyXG5cdFx0XHRcdFx0cyA9IFNfUztcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgU19BVFRSOlxyXG5cdFx0XHRcdFx0YXR0ck5hbWUgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQscClcclxuXHRcdFx0XHRcdHMgPSBTX0FUVFJfUztcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgU19WOlxyXG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gc291cmNlLnNsaWNlKHN0YXJ0LHApLnJlcGxhY2UoLyYjP1xcdys7L2csZW50aXR5UmVwbGFjZXIpO1xyXG5cdFx0XHRcdFx0ZXJyb3JIYW5kbGVyLndhcm5pbmcoJ2F0dHJpYnV0ZSBcIicrdmFsdWUrJ1wiIG1pc3NlZCBxdW90KFwiKSEhJyk7XHJcblx0XHRcdFx0XHRlbC5hZGQoYXR0ck5hbWUsdmFsdWUsc3RhcnQpXHJcblx0XHRcdFx0Y2FzZSBTX0U6XHJcblx0XHRcdFx0XHRzID0gU19TO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Ly9jYXNlIFNfUzpcclxuXHRcdFx0XHQvL2Nhc2UgU19FUTpcclxuXHRcdFx0XHQvL2Nhc2UgU19BVFRSX1M6XHJcblx0XHRcdFx0Ly9cdHZvaWQoKTticmVhaztcclxuXHRcdFx0XHQvL2Nhc2UgU19DOlxyXG5cdFx0XHRcdFx0Ly9pZ25vcmUgd2FybmluZ1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fWVsc2V7Ly9ub3Qgc3BhY2VcclxuLy9TX1RBRyxcdFNfQVRUUixcdFNfRVEsXHRTX1ZcclxuLy9TX0FUVFJfUyxcdFNfRSxcdFNfUyxcdFNfQ1xyXG5cdFx0XHRcdHN3aXRjaChzKXtcclxuXHRcdFx0XHQvL2Nhc2UgU19UQUc6dm9pZCgpO2JyZWFrO1xyXG5cdFx0XHRcdC8vY2FzZSBTX0FUVFI6dm9pZCgpO2JyZWFrO1xyXG5cdFx0XHRcdC8vY2FzZSBTX1Y6dm9pZCgpO2JyZWFrO1xyXG5cdFx0XHRcdGNhc2UgU19BVFRSX1M6XHJcblx0XHRcdFx0XHRlcnJvckhhbmRsZXIud2FybmluZygnYXR0cmlidXRlIFwiJythdHRyTmFtZSsnXCIgbWlzc2VkIHZhbHVlISEgXCInK2F0dHJOYW1lKydcIiBpbnN0ZWFkISEnKVxyXG5cdFx0XHRcdFx0ZWwuYWRkKGF0dHJOYW1lLGF0dHJOYW1lLHN0YXJ0KTtcclxuXHRcdFx0XHRcdHN0YXJ0ID0gcDtcclxuXHRcdFx0XHRcdHMgPSBTX0FUVFI7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFNfRTpcclxuXHRcdFx0XHRcdGVycm9ySGFuZGxlci53YXJuaW5nKCdhdHRyaWJ1dGUgc3BhY2UgaXMgcmVxdWlyZWRcIicrYXR0ck5hbWUrJ1wiISEnKVxyXG5cdFx0XHRcdGNhc2UgU19TOlxyXG5cdFx0XHRcdFx0cyA9IFNfQVRUUjtcclxuXHRcdFx0XHRcdHN0YXJ0ID0gcDtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgU19FUTpcclxuXHRcdFx0XHRcdHMgPSBTX1Y7XHJcblx0XHRcdFx0XHRzdGFydCA9IHA7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFNfQzpcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImVsZW1lbnRzIGNsb3NlZCBjaGFyYWN0ZXIgJy8nIGFuZCAnPicgbXVzdCBiZSBjb25uZWN0ZWQgdG9cIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRwKys7XHJcblx0fVxyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJuIGVuZCBvZiB0aGUgZWxlbWVudFN0YXJ0UGFydChlbmQgb2YgZWxlbWVudEVuZFBhcnQgZm9yIHNlbGZDbG9zZWQgZWwpXHJcbiAqL1xyXG5mdW5jdGlvbiBhcHBlbmRFbGVtZW50KGVsLGRvbUJ1aWxkZXIscGFyc2VTdGFjayl7XHJcblx0dmFyIHRhZ05hbWUgPSBlbC50YWdOYW1lO1xyXG5cdHZhciBsb2NhbE5TTWFwID0gbnVsbDtcclxuXHR2YXIgY3VycmVudE5TTWFwID0gcGFyc2VTdGFja1twYXJzZVN0YWNrLmxlbmd0aC0xXS5jdXJyZW50TlNNYXA7XHJcblx0dmFyIGkgPSBlbC5sZW5ndGg7XHJcblx0d2hpbGUoaS0tKXtcclxuXHRcdHZhciBhID0gZWxbaV07XHJcblx0XHR2YXIgcU5hbWUgPSBhLnFOYW1lO1xyXG5cdFx0dmFyIHZhbHVlID0gYS52YWx1ZTtcclxuXHRcdHZhciBuc3AgPSBxTmFtZS5pbmRleE9mKCc6Jyk7XHJcblx0XHRpZihuc3A+MCl7XHJcblx0XHRcdHZhciBwcmVmaXggPSBhLnByZWZpeCA9IHFOYW1lLnNsaWNlKDAsbnNwKTtcclxuXHRcdFx0dmFyIGxvY2FsTmFtZSA9IHFOYW1lLnNsaWNlKG5zcCsxKTtcclxuXHRcdFx0dmFyIG5zUHJlZml4ID0gcHJlZml4ID09PSAneG1sbnMnICYmIGxvY2FsTmFtZVxyXG5cdFx0fWVsc2V7XHJcblx0XHRcdGxvY2FsTmFtZSA9IHFOYW1lO1xyXG5cdFx0XHRwcmVmaXggPSBudWxsXHJcblx0XHRcdG5zUHJlZml4ID0gcU5hbWUgPT09ICd4bWxucycgJiYgJydcclxuXHRcdH1cclxuXHRcdC8vY2FuIG5vdCBzZXQgcHJlZml4LGJlY2F1c2UgcHJlZml4ICE9PSAnJ1xyXG5cdFx0YS5sb2NhbE5hbWUgPSBsb2NhbE5hbWUgO1xyXG5cdFx0Ly9wcmVmaXggPT0gbnVsbCBmb3Igbm8gbnMgcHJlZml4IGF0dHJpYnV0ZSBcclxuXHRcdGlmKG5zUHJlZml4ICE9PSBmYWxzZSl7Ly9oYWNrISFcclxuXHRcdFx0aWYobG9jYWxOU01hcCA9PSBudWxsKXtcclxuXHRcdFx0XHRsb2NhbE5TTWFwID0ge31cclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKGN1cnJlbnROU01hcCwwKVxyXG5cdFx0XHRcdF9jb3B5KGN1cnJlbnROU01hcCxjdXJyZW50TlNNYXA9e30pXHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhjdXJyZW50TlNNYXAsMSlcclxuXHRcdFx0fVxyXG5cdFx0XHRjdXJyZW50TlNNYXBbbnNQcmVmaXhdID0gbG9jYWxOU01hcFtuc1ByZWZpeF0gPSB2YWx1ZTtcclxuXHRcdFx0YS51cmkgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nXHJcblx0XHRcdGRvbUJ1aWxkZXIuc3RhcnRQcmVmaXhNYXBwaW5nKG5zUHJlZml4LCB2YWx1ZSkgXHJcblx0XHR9XHJcblx0fVxyXG5cdHZhciBpID0gZWwubGVuZ3RoO1xyXG5cdHdoaWxlKGktLSl7XHJcblx0XHRhID0gZWxbaV07XHJcblx0XHR2YXIgcHJlZml4ID0gYS5wcmVmaXg7XHJcblx0XHRpZihwcmVmaXgpey8vbm8gcHJlZml4IGF0dHJpYnV0ZSBoYXMgbm8gbmFtZXNwYWNlXHJcblx0XHRcdGlmKHByZWZpeCA9PT0gJ3htbCcpe1xyXG5cdFx0XHRcdGEudXJpID0gJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSc7XHJcblx0XHRcdH1pZihwcmVmaXggIT09ICd4bWxucycpe1xyXG5cdFx0XHRcdGEudXJpID0gY3VycmVudE5TTWFwW3ByZWZpeF1cclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvL3tjb25zb2xlLmxvZygnIyMjJythLnFOYW1lLGRvbUJ1aWxkZXIubG9jYXRvci5zeXN0ZW1JZCsnJyxjdXJyZW50TlNNYXAsYS51cmkpfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdHZhciBuc3AgPSB0YWdOYW1lLmluZGV4T2YoJzonKTtcclxuXHRpZihuc3A+MCl7XHJcblx0XHRwcmVmaXggPSBlbC5wcmVmaXggPSB0YWdOYW1lLnNsaWNlKDAsbnNwKTtcclxuXHRcdGxvY2FsTmFtZSA9IGVsLmxvY2FsTmFtZSA9IHRhZ05hbWUuc2xpY2UobnNwKzEpO1xyXG5cdH1lbHNle1xyXG5cdFx0cHJlZml4ID0gbnVsbDsvL2ltcG9ydGFudCEhXHJcblx0XHRsb2NhbE5hbWUgPSBlbC5sb2NhbE5hbWUgPSB0YWdOYW1lO1xyXG5cdH1cclxuXHQvL25vIHByZWZpeCBlbGVtZW50IGhhcyBkZWZhdWx0IG5hbWVzcGFjZVxyXG5cdHZhciBucyA9IGVsLnVyaSA9IGN1cnJlbnROU01hcFtwcmVmaXggfHwgJyddO1xyXG5cdGRvbUJ1aWxkZXIuc3RhcnRFbGVtZW50KG5zLGxvY2FsTmFtZSx0YWdOYW1lLGVsKTtcclxuXHQvL2VuZFByZWZpeE1hcHBpbmcgYW5kIHN0YXJ0UHJlZml4TWFwcGluZyBoYXZlIG5vdCBhbnkgaGVscCBmb3IgZG9tIGJ1aWxkZXJcclxuXHQvL2xvY2FsTlNNYXAgPSBudWxsXHJcblx0aWYoZWwuY2xvc2VkKXtcclxuXHRcdGRvbUJ1aWxkZXIuZW5kRWxlbWVudChucyxsb2NhbE5hbWUsdGFnTmFtZSk7XHJcblx0XHRpZihsb2NhbE5TTWFwKXtcclxuXHRcdFx0Zm9yKHByZWZpeCBpbiBsb2NhbE5TTWFwKXtcclxuXHRcdFx0XHRkb21CdWlsZGVyLmVuZFByZWZpeE1hcHBpbmcocHJlZml4KSBcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1lbHNle1xyXG5cdFx0ZWwuY3VycmVudE5TTWFwID0gY3VycmVudE5TTWFwO1xyXG5cdFx0ZWwubG9jYWxOU01hcCA9IGxvY2FsTlNNYXA7XHJcblx0XHRwYXJzZVN0YWNrLnB1c2goZWwpO1xyXG5cdH1cclxufVxyXG5mdW5jdGlvbiBwYXJzZUh0bWxTcGVjaWFsQ29udGVudChzb3VyY2UsZWxTdGFydEVuZCx0YWdOYW1lLGVudGl0eVJlcGxhY2VyLGRvbUJ1aWxkZXIpe1xyXG5cdGlmKC9eKD86c2NyaXB0fHRleHRhcmVhKSQvaS50ZXN0KHRhZ05hbWUpKXtcclxuXHRcdHZhciBlbEVuZFN0YXJ0ID0gIHNvdXJjZS5pbmRleE9mKCc8LycrdGFnTmFtZSsnPicsZWxTdGFydEVuZCk7XHJcblx0XHR2YXIgdGV4dCA9IHNvdXJjZS5zdWJzdHJpbmcoZWxTdGFydEVuZCsxLGVsRW5kU3RhcnQpO1xyXG5cdFx0aWYoL1smPF0vLnRlc3QodGV4dCkpe1xyXG5cdFx0XHRpZigvXnNjcmlwdCQvaS50ZXN0KHRhZ05hbWUpKXtcclxuXHRcdFx0XHQvL2lmKCEvXFxdXFxdPi8udGVzdCh0ZXh0KSl7XHJcblx0XHRcdFx0XHQvL2xleEhhbmRsZXIuc3RhcnRDREFUQSgpO1xyXG5cdFx0XHRcdFx0ZG9tQnVpbGRlci5jaGFyYWN0ZXJzKHRleHQsMCx0ZXh0Lmxlbmd0aCk7XHJcblx0XHRcdFx0XHQvL2xleEhhbmRsZXIuZW5kQ0RBVEEoKTtcclxuXHRcdFx0XHRcdHJldHVybiBlbEVuZFN0YXJ0O1xyXG5cdFx0XHRcdC8vfVxyXG5cdFx0XHR9Ly99ZWxzZXsvL3RleHQgYXJlYVxyXG5cdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoLyYjP1xcdys7L2csZW50aXR5UmVwbGFjZXIpO1xyXG5cdFx0XHRcdGRvbUJ1aWxkZXIuY2hhcmFjdGVycyh0ZXh0LDAsdGV4dC5sZW5ndGgpO1xyXG5cdFx0XHRcdHJldHVybiBlbEVuZFN0YXJ0O1xyXG5cdFx0XHQvL31cclxuXHRcdFx0XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBlbFN0YXJ0RW5kKzE7XHJcbn1cclxuZnVuY3Rpb24gZml4U2VsZkNsb3NlZChzb3VyY2UsZWxTdGFydEVuZCx0YWdOYW1lLGNsb3NlTWFwKXtcclxuXHQvL2lmKHRhZ05hbWUgaW4gY2xvc2VNYXApe1xyXG5cdHZhciBwb3MgPSBjbG9zZU1hcFt0YWdOYW1lXTtcclxuXHRpZihwb3MgPT0gbnVsbCl7XHJcblx0XHQvL2NvbnNvbGUubG9nKHRhZ05hbWUpXHJcblx0XHRwb3MgPSBjbG9zZU1hcFt0YWdOYW1lXSA9IHNvdXJjZS5sYXN0SW5kZXhPZignPC8nK3RhZ05hbWUrJz4nKVxyXG5cdH1cclxuXHRyZXR1cm4gcG9zPGVsU3RhcnRFbmQ7XHJcblx0Ly99IFxyXG59XHJcbmZ1bmN0aW9uIF9jb3B5KHNvdXJjZSx0YXJnZXQpe1xyXG5cdGZvcih2YXIgbiBpbiBzb3VyY2Upe3RhcmdldFtuXSA9IHNvdXJjZVtuXX1cclxufVxyXG5mdW5jdGlvbiBwYXJzZURDQyhzb3VyY2Usc3RhcnQsZG9tQnVpbGRlcixlcnJvckhhbmRsZXIpey8vc3VyZSBzdGFydCB3aXRoICc8ISdcclxuXHR2YXIgbmV4dD0gc291cmNlLmNoYXJBdChzdGFydCsyKVxyXG5cdHN3aXRjaChuZXh0KXtcclxuXHRjYXNlICctJzpcclxuXHRcdGlmKHNvdXJjZS5jaGFyQXQoc3RhcnQgKyAzKSA9PT0gJy0nKXtcclxuXHRcdFx0dmFyIGVuZCA9IHNvdXJjZS5pbmRleE9mKCctLT4nLHN0YXJ0KzQpO1xyXG5cdFx0XHQvL2FwcGVuZCBjb21tZW50IHNvdXJjZS5zdWJzdHJpbmcoNCxlbmQpLy88IS0tXHJcblx0XHRcdGlmKGVuZD5zdGFydCl7XHJcblx0XHRcdFx0ZG9tQnVpbGRlci5jb21tZW50KHNvdXJjZSxzdGFydCs0LGVuZC1zdGFydC00KTtcclxuXHRcdFx0XHRyZXR1cm4gZW5kKzM7XHJcblx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdGVycm9ySGFuZGxlci5lcnJvcihcIlVuY2xvc2VkIGNvbW1lbnRcIik7XHJcblx0XHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0XHR9XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0Ly9lcnJvclxyXG5cdFx0XHRyZXR1cm4gLTE7XHJcblx0XHR9XHJcblx0ZGVmYXVsdDpcclxuXHRcdGlmKHNvdXJjZS5zdWJzdHIoc3RhcnQrMyw2KSA9PSAnQ0RBVEFbJyl7XHJcblx0XHRcdHZhciBlbmQgPSBzb3VyY2UuaW5kZXhPZignXV0+JyxzdGFydCs5KTtcclxuXHRcdFx0ZG9tQnVpbGRlci5zdGFydENEQVRBKCk7XHJcblx0XHRcdGRvbUJ1aWxkZXIuY2hhcmFjdGVycyhzb3VyY2Usc3RhcnQrOSxlbmQtc3RhcnQtOSk7XHJcblx0XHRcdGRvbUJ1aWxkZXIuZW5kQ0RBVEEoKSBcclxuXHRcdFx0cmV0dXJuIGVuZCszO1xyXG5cdFx0fVxyXG5cdFx0Ly88IURPQ1RZUEVcclxuXHRcdC8vc3RhcnREVEQoamF2YS5sYW5nLlN0cmluZyBuYW1lLCBqYXZhLmxhbmcuU3RyaW5nIHB1YmxpY0lkLCBqYXZhLmxhbmcuU3RyaW5nIHN5c3RlbUlkKSBcclxuXHRcdHZhciBtYXRjaHMgPSBzcGxpdChzb3VyY2Usc3RhcnQpO1xyXG5cdFx0dmFyIGxlbiA9IG1hdGNocy5sZW5ndGg7XHJcblx0XHRpZihsZW4+MSAmJiAvIWRvY3R5cGUvaS50ZXN0KG1hdGNoc1swXVswXSkpe1xyXG5cdFx0XHR2YXIgbmFtZSA9IG1hdGNoc1sxXVswXTtcclxuXHRcdFx0dmFyIHB1YmlkID0gbGVuPjMgJiYgL15wdWJsaWMkL2kudGVzdChtYXRjaHNbMl1bMF0pICYmIG1hdGNoc1szXVswXVxyXG5cdFx0XHR2YXIgc3lzaWQgPSBsZW4+NCAmJiBtYXRjaHNbNF1bMF07XHJcblx0XHRcdHZhciBsYXN0TWF0Y2ggPSBtYXRjaHNbbGVuLTFdXHJcblx0XHRcdGRvbUJ1aWxkZXIuc3RhcnREVEQobmFtZSxwdWJpZCAmJiBwdWJpZC5yZXBsYWNlKC9eKFsnXCJdKSguKj8pXFwxJC8sJyQyJyksXHJcblx0XHRcdFx0XHRzeXNpZCAmJiBzeXNpZC5yZXBsYWNlKC9eKFsnXCJdKSguKj8pXFwxJC8sJyQyJykpO1xyXG5cdFx0XHRkb21CdWlsZGVyLmVuZERURCgpO1xyXG5cdFx0XHRcclxuXHRcdFx0cmV0dXJuIGxhc3RNYXRjaC5pbmRleCtsYXN0TWF0Y2hbMF0ubGVuZ3RoXHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiAtMTtcclxufVxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBwYXJzZUluc3RydWN0aW9uKHNvdXJjZSxzdGFydCxkb21CdWlsZGVyKXtcclxuXHR2YXIgZW5kID0gc291cmNlLmluZGV4T2YoJz8+JyxzdGFydCk7XHJcblx0aWYoZW5kKXtcclxuXHRcdHZhciBtYXRjaCA9IHNvdXJjZS5zdWJzdHJpbmcoc3RhcnQsZW5kKS5tYXRjaCgvXjxcXD8oXFxTKilcXHMqKFtcXHNcXFNdKj8pXFxzKiQvKTtcclxuXHRcdGlmKG1hdGNoKXtcclxuXHRcdFx0dmFyIGxlbiA9IG1hdGNoWzBdLmxlbmd0aDtcclxuXHRcdFx0ZG9tQnVpbGRlci5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb24obWF0Y2hbMV0sIG1hdGNoWzJdKSA7XHJcblx0XHRcdHJldHVybiBlbmQrMjtcclxuXHRcdH1lbHNley8vZXJyb3JcclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gLTE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gc291cmNlXHJcbiAqL1xyXG5mdW5jdGlvbiBFbGVtZW50QXR0cmlidXRlcyhzb3VyY2Upe1xyXG5cdFxyXG59XHJcbkVsZW1lbnRBdHRyaWJ1dGVzLnByb3RvdHlwZSA9IHtcclxuXHRzZXRUYWdOYW1lOmZ1bmN0aW9uKHRhZ05hbWUpe1xyXG5cdFx0aWYoIXRhZ05hbWVQYXR0ZXJuLnRlc3QodGFnTmFtZSkpe1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdGFnTmFtZTonK3RhZ05hbWUpXHJcblx0XHR9XHJcblx0XHR0aGlzLnRhZ05hbWUgPSB0YWdOYW1lXHJcblx0fSxcclxuXHRhZGQ6ZnVuY3Rpb24ocU5hbWUsdmFsdWUsb2Zmc2V0KXtcclxuXHRcdGlmKCF0YWdOYW1lUGF0dGVybi50ZXN0KHFOYW1lKSl7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhdHRyaWJ1dGU6JytxTmFtZSlcclxuXHRcdH1cclxuXHRcdHRoaXNbdGhpcy5sZW5ndGgrK10gPSB7cU5hbWU6cU5hbWUsdmFsdWU6dmFsdWUsb2Zmc2V0Om9mZnNldH1cclxuXHR9LFxyXG5cdGxlbmd0aDowLFxyXG5cdGdldExvY2FsTmFtZTpmdW5jdGlvbihpKXtyZXR1cm4gdGhpc1tpXS5sb2NhbE5hbWV9LFxyXG5cdGdldE9mZnNldDpmdW5jdGlvbihpKXtyZXR1cm4gdGhpc1tpXS5vZmZzZXR9LFxyXG5cdGdldFFOYW1lOmZ1bmN0aW9uKGkpe3JldHVybiB0aGlzW2ldLnFOYW1lfSxcclxuXHRnZXRVUkk6ZnVuY3Rpb24oaSl7cmV0dXJuIHRoaXNbaV0udXJpfSxcclxuXHRnZXRWYWx1ZTpmdW5jdGlvbihpKXtyZXR1cm4gdGhpc1tpXS52YWx1ZX1cclxuLy9cdCxnZXRJbmRleDpmdW5jdGlvbih1cmksIGxvY2FsTmFtZSkpe1xyXG4vL1x0XHRpZihsb2NhbE5hbWUpe1xyXG4vL1x0XHRcdFxyXG4vL1x0XHR9ZWxzZXtcclxuLy9cdFx0XHR2YXIgcU5hbWUgPSB1cmlcclxuLy9cdFx0fVxyXG4vL1x0fSxcclxuLy9cdGdldFZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0VmFsdWUodGhpcy5nZXRJbmRleC5hcHBseSh0aGlzLGFyZ3VtZW50cykpfSxcclxuLy9cdGdldFR5cGU6ZnVuY3Rpb24odXJpLGxvY2FsTmFtZSl7fVxyXG4vL1x0Z2V0VHlwZTpmdW5jdGlvbihpKXt9LFxyXG59XHJcblxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBfc2V0X3Byb3RvXyh0aGl6LHBhcmVudCl7XHJcblx0dGhpei5fX3Byb3RvX18gPSBwYXJlbnQ7XHJcblx0cmV0dXJuIHRoaXo7XHJcbn1cclxuaWYoIShfc2V0X3Byb3RvXyh7fSxfc2V0X3Byb3RvXy5wcm90b3R5cGUpIGluc3RhbmNlb2YgX3NldF9wcm90b18pKXtcclxuXHRfc2V0X3Byb3RvXyA9IGZ1bmN0aW9uKHRoaXoscGFyZW50KXtcclxuXHRcdGZ1bmN0aW9uIHAoKXt9O1xyXG5cdFx0cC5wcm90b3R5cGUgPSBwYXJlbnQ7XHJcblx0XHRwID0gbmV3IHAoKTtcclxuXHRcdGZvcihwYXJlbnQgaW4gdGhpeil7XHJcblx0XHRcdHBbcGFyZW50XSA9IHRoaXpbcGFyZW50XTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBwO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gc3BsaXQoc291cmNlLHN0YXJ0KXtcclxuXHR2YXIgbWF0Y2g7XHJcblx0dmFyIGJ1ZiA9IFtdO1xyXG5cdHZhciByZWcgPSAvJ1teJ10rJ3xcIlteXCJdK1wifFteXFxzPD5cXC89XSs9P3woXFwvP1xccyo+fDwpL2c7XHJcblx0cmVnLmxhc3RJbmRleCA9IHN0YXJ0O1xyXG5cdHJlZy5leGVjKHNvdXJjZSk7Ly9za2lwIDxcclxuXHR3aGlsZShtYXRjaCA9IHJlZy5leGVjKHNvdXJjZSkpe1xyXG5cdFx0YnVmLnB1c2gobWF0Y2gpO1xyXG5cdFx0aWYobWF0Y2hbMV0pcmV0dXJuIGJ1ZjtcclxuXHR9XHJcbn1cclxuXHJcbmlmKHR5cGVvZiByZXF1aXJlID09ICdmdW5jdGlvbicpe1xyXG5cdGV4cG9ydHMuWE1MUmVhZGVyID0gWE1MUmVhZGVyO1xyXG59XHJcblxyXG4iLCIvKlxyXG4gKiB4cGF0aC5qc1xyXG4gKlxyXG4gKiBBbiBYUGF0aCAxLjAgbGlicmFyeSBmb3IgSmF2YVNjcmlwdC5cclxuICpcclxuICogQ2FtZXJvbiBNY0Nvcm1hY2sgPGNhbSAoYXQpIG1jYy5pZC5hdT5cclxuICpcclxuICogVGhpcyB3b3JrIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBDcmVhdGl2ZSBDb21tb25zIEF0dHJpYnV0aW9uLVNoYXJlQWxpa2VcclxuICogTGljZW5zZS4gVG8gdmlldyBhIGNvcHkgb2YgdGhpcyBsaWNlbnNlLCB2aXNpdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LXNhLzIuMC9cclxuICpcclxuICogb3Igc2VuZCBhIGxldHRlciB0byBDcmVhdGl2ZSBDb21tb25zLCA1NTkgTmF0aGFuIEFiYm90dCBXYXksIFN0YW5mb3JkLFxyXG4gKiBDYWxpZm9ybmlhIDk0MzA1LCBVU0EuXHJcbiAqXHJcbiAqIFJldmlzaW9uIDIwOiBBcHJpbCAyNiwgMjAxMVxyXG4gKiAgIEZpeGVkIGEgdHlwbyByZXN1bHRpbmcgaW4gRklSU1RfT1JERVJFRF9OT0RFX1RZUEUgcmVzdWx0cyBiZWluZyB3cm9uZyxcclxuICogICB0aGFua3MgdG8gPHNoaV9hMDA5IChhdCkgaG90bWFpbC5jb20+LlxyXG4gKlxyXG4gKiBSZXZpc2lvbiAxOTogTm92ZW1iZXIgMjksIDIwMDVcclxuICogICBOb2Rlc2V0cyBub3cgc3RvcmUgdGhlaXIgbm9kZXMgaW4gYSBoZWlnaHQgYmFsYW5jZWQgdHJlZSwgaW5jcmVhc2luZ1xyXG4gKiAgIHBlcmZvcm1hbmNlIGZvciB0aGUgY29tbW9uIGNhc2Ugb2Ygc2VsZWN0aW5nIG5vZGVzIGluIGRvY3VtZW50IG9yZGVyLFxyXG4gKiAgIHRoYW5rcyB0byBT6ZaOYXN0aWVuIENyYW1hdHRlIDxjb250YWN0IChhdCkgemVuaW50ZXJhY3RpZi5jb20+LlxyXG4gKiAgIEFWTCB0cmVlIGNvZGUgYWRhcHRlZCBmcm9tIFJhaW11bmQgTmV1bWFubiA8cm5vdmEgKGF0KSBnbXgubmV0Pi5cclxuICpcclxuICogUmV2aXNpb24gMTg6IE9jdG9iZXIgMjcsIDIwMDVcclxuICogICBET00gMyBYUGF0aCBzdXBwb3J0LiAgQ2F2ZWF0czpcclxuICogICAgIC0gbmFtZXNwYWNlIHByZWZpeGVzIGFyZW4ndCByZXNvbHZlZCBpbiBYUGF0aEV2YWx1YXRvci5jcmVhdGVFeHByZXNzaW9uLFxyXG4gKiAgICAgICBidXQgaW4gWFBhdGhFeHByZXNzaW9uLmV2YWx1YXRlLlxyXG4gKiAgICAgLSBYUGF0aFJlc3VsdC5pbnZhbGlkSXRlcmF0b3JTdGF0ZSBpcyBub3QgaW1wbGVtZW50ZWQuXHJcbiAqXHJcbiAqIFJldmlzaW9uIDE3OiBPY3RvYmVyIDI1LCAyMDA1XHJcbiAqICAgU29tZSBjb3JlIFhQYXRoIGZ1bmN0aW9uIGZpeGVzIGFuZCBhIHBhdGNoIHRvIGF2b2lkIGNyYXNoaW5nIGNlcnRhaW5cclxuICogICB2ZXJzaW9ucyBvZiBNU1hNTCBpbiBQYXRoRXhwci5wcm90b3R5cGUuZ2V0T3duZXJFbGVtZW50LCB0aGFua3MgdG9cclxuICogICBT6ZaOYXN0aWVuIENyYW1hdHRlIDxjb250YWN0IChhdCkgemVuaW50ZXJhY3RpZi5jb20+LlxyXG4gKlxyXG4gKiBSZXZpc2lvbiAxNjogU2VwdGVtYmVyIDIyLCAyMDA1XHJcbiAqICAgV29ya2Fyb3VuZHMgZm9yIHNvbWUgSUUgNS41IGRlZmljaWVuY2llcy5cclxuICogICBGaXhlZCBwcm9ibGVtIHdpdGggcHJlZml4IG5vZGUgdGVzdHMgb24gYXR0cmlidXRlIG5vZGVzLlxyXG4gKlxyXG4gKiBSZXZpc2lvbiAxNTogTWF5IDIxLCAyMDA1XHJcbiAqICAgRml4ZWQgcHJvYmxlbSB3aXRoIFFOYW1lIG5vZGUgdGVzdHMgb24gZWxlbWVudHMgd2l0aCBhbiB4bWxucz1cIi4uLlwiLlxyXG4gKlxyXG4gKiBSZXZpc2lvbiAxNDogTWF5IDE5LCAyMDA1XHJcbiAqICAgRml4ZWQgUU5hbWUgbm9kZSB0ZXN0cyBvbiBhdHRyaWJ1dGUgbm9kZSByZWdyZXNzaW9uLlxyXG4gKlxyXG4gKiBSZXZpc2lvbiAxMzogTWF5IDMsIDIwMDVcclxuICogICBOb2RlIHRlc3RzIGFyZSBjYXNlIGluc2Vuc2l0aXZlIG5vdyBpZiB3b3JraW5nIGluIGFuIEhUTUwgRE9NLlxyXG4gKlxyXG4gKiBSZXZpc2lvbiAxMjogQXByaWwgMjYsIDIwMDVcclxuICogICBVcGRhdGVkIGxpY2VuY2UuICBTbGlnaHQgY29kZSBjaGFuZ2VzIHRvIGVuYWJsZSB1c2Ugb2YgRGVhblxyXG4gKiAgIEVkd2FyZHMnIHNjcmlwdCBjb21wcmVzc2lvbiwgaHR0cDovL2RlYW4uZWR3YXJkcy5uYW1lL3BhY2tlci8gLlxyXG4gKlxyXG4gKiBSZXZpc2lvbiAxMTogQXByaWwgMjMsIDIwMDVcclxuICogICBGaXhlZCBidWcgd2l0aCAnYW5kJyBhbmQgJ29yJyBvcGVyYXRvcnMsIGZpeCB0aGFua3MgdG9cclxuICogICBTYW5keSBNY0FydGh1ciA8c2FuZHkgKGF0KSBtY2FydGh1ci5vcmc+LlxyXG4gKlxyXG4gKiBSZXZpc2lvbiAxMDogQXByaWwgMTUsIDIwMDVcclxuICogICBBZGRlZCBzdXBwb3J0IGZvciBhIHZpcnR1YWwgcm9vdCBub2RlLCBzdXBwb3NlZGx5IGhlbHBmdWwgZm9yXHJcbiAqICAgaW1wbGVtZW50aW5nIFhGb3Jtcy4gIEZpeGVkIHByb2JsZW0gd2l0aCBRTmFtZSBub2RlIHRlc3RzIGFuZFxyXG4gKiAgIHRoZSBwYXJlbnQgYXhpcy5cclxuICpcclxuICogUmV2aXNpb24gOTogTWFyY2ggMTcsIDIwMDVcclxuICogICBOYW1lc3BhY2UgcmVzb2x2ZXIgdHdlYWtlZCBzbyB1c2luZyB0aGUgZG9jdW1lbnQgbm9kZSBhcyB0aGUgY29udGV4dFxyXG4gKiAgIGZvciBuYW1lc3BhY2UgbG9va3VwcyBpcyBlcXVpdmFsZW50IHRvIHVzaW5nIHRoZSBkb2N1bWVudCBlbGVtZW50LlxyXG4gKlxyXG4gKiBSZXZpc2lvbiA4OiBGZWJydWFyeSAxMywgMjAwNVxyXG4gKiAgIEhhbmRsZSBpbXBsaWNpdCBkZWNsYXJhdGlvbiBvZiAneG1sbnMnIG5hbWVzcGFjZSBwcmVmaXguXHJcbiAqICAgRml4ZWQgYnVnIHdoZW4gY29tcGFyaW5nIG5vZGVzZXRzLlxyXG4gKiAgIEluc3RhbmNlIGRhdGEgY2FuIG5vdyBiZSBhc3NvY2lhdGVkIHdpdGggYSBGdW5jdGlvblJlc29sdmVyLCBhbmRcclxuICogICAgIHdvcmthcm91bmQgZm9yIE1TWE1MIG5vdCBzdXBwb3J0aW5nICdsb2NhbE5hbWUnIGFuZCAnZ2V0RWxlbWVudEJ5SWQnLFxyXG4gKiAgICAgdGhhbmtzIHRvIEdyYW50IEdvbmdhd2FyZS5cclxuICogICBGaXggYSBmZXcgcHJvYmxlbXMgd2hlbiB0aGUgY29udGV4dCBub2RlIGlzIHRoZSByb290IG5vZGUuXHJcbiAqXHJcbiAqIFJldmlzaW9uIDc6IEZlYnJ1YXJ5IDExLCAyMDA1XHJcbiAqICAgRGVmYXVsdCBuYW1lc3BhY2UgcmVzb2x2ZXIgZml4IGZyb20gR3JhbnQgR29uZ2F3YXJlXHJcbiAqICAgPGdyYW50IChhdCkgZ29uZ2F3YXJlLmNvbT4uXHJcbiAqXHJcbiAqIFJldmlzaW9uIDY6IEZlYnJ1YXJ5IDEwLCAyMDA1XHJcbiAqICAgRml4ZWQgYnVnIGluICdudW1iZXInIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBSZXZpc2lvbiA1OiBGZWJydWFyeSA5LCAyMDA1XHJcbiAqICAgRml4ZWQgYnVnIHdoZXJlIHRleHQgbm9kZXMgbm90IGdldHRpbmcgY29udmVydGVkIHRvIHN0cmluZyB2YWx1ZXMuXHJcbiAqXHJcbiAqIFJldmlzaW9uIDQ6IEphbnVhcnkgMjEsIDIwMDVcclxuICogICBCdWcgaW4gJ25hbWUnIGZ1bmN0aW9uLCBmaXggdGhhbmtzIHRvIEJpbGwgRWRuZXkuXHJcbiAqICAgRml4ZWQgaW5jb3JyZWN0IHByb2Nlc3Npbmcgb2YgbmFtZXNwYWNlIG5vZGVzLlxyXG4gKiAgIEZpeGVkIE5hbWVzcGFjZVJlc29sdmVyIHRvIHJlc29sdmUgJ3htbCcgbmFtZXNwYWNlLlxyXG4gKiAgIEltcGxlbWVudGVkIHVuaW9uICd8JyBvcGVyYXRvci5cclxuICpcclxuICogUmV2aXNpb24gMzogSmFudWFyeSAxNCwgMjAwNVxyXG4gKiAgIEZpeGVkIGJ1ZyB3aXRoIG5vZGVzZXQgY29tcGFyaXNvbnMsIGJ1ZyBsZXhpbmcgPCBhbmQgPi5cclxuICpcclxuICogUmV2aXNpb24gMjogT2N0b2JlciAyNiwgMjAwNFxyXG4gKiAgIFFOYW1lIG5vZGUgdGVzdCBuYW1lc3BhY2UgaGFuZGxpbmcgZml4ZWQuICBGZXcgb3RoZXIgYnVnIGZpeGVzLlxyXG4gKlxyXG4gKiBSZXZpc2lvbiAxOiBBdWd1c3QgMTMsIDIwMDRcclxuICogICBCdWcgZml4ZXMgZnJvbSBXaWxsaWFtIEouIEVkbmV5IDxiZWRuZXkgKGF0KSB0ZWNobmljYWxwdXJzdWl0LmNvbT4uXHJcbiAqICAgQWRkZWQgbWluaW1hbCBsaWNlbmNlLlxyXG4gKlxyXG4gKiBJbml0aWFsIHZlcnNpb246IEp1bmUgMTQsIDIwMDRcclxuICovXHJcblxyXG4vLyBub24tbm9kZSB3cmFwcGVyXHJcbmlmKHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyApIHtcclxuXHR4cGF0aCA9IHt9O1xyXG59XHJcbihmdW5jdGlvbihleHBvcnRzKSB7XHJcblx0XHJcbi8vIFhQYXRoUGFyc2VyIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuWFBhdGhQYXJzZXIucHJvdG90eXBlID0gbmV3IE9iamVjdCgpO1xyXG5YUGF0aFBhcnNlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBYUGF0aFBhcnNlcjtcclxuWFBhdGhQYXJzZXIuc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBYUGF0aFBhcnNlcigpIHtcclxuXHR0aGlzLmluaXQoKTtcclxufVxyXG5cclxuWFBhdGhQYXJzZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnMgPSBbXTtcclxuXHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzNdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IE9yT3BlcmF0aW9uKHJoc1swXSwgcmhzWzJdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s1XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBBbmRPcGVyYXRpb24ocmhzWzBdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzddID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IEVxdWFsc09wZXJhdGlvbihyaHNbMF0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbOF0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgTm90RXF1YWxPcGVyYXRpb24ocmhzWzBdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzEwXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBMZXNzVGhhbk9wZXJhdGlvbihyaHNbMF0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMTFdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IEdyZWF0ZXJUaGFuT3BlcmF0aW9uKHJoc1swXSwgcmhzWzJdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1sxMl0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgTGVzc1RoYW5PckVxdWFsT3BlcmF0aW9uKHJoc1swXSwgcmhzWzJdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1sxM10gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgR3JlYXRlclRoYW5PckVxdWFsT3BlcmF0aW9uKHJoc1swXSwgcmhzWzJdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1sxNV0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgUGx1c09wZXJhdGlvbihyaHNbMF0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMTZdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IE1pbnVzT3BlcmF0aW9uKHJoc1swXSwgcmhzWzJdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1sxOF0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgTXVsdGlwbHlPcGVyYXRpb24ocmhzWzBdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzE5XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBEaXZPcGVyYXRpb24ocmhzWzBdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzIwXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBNb2RPcGVyYXRpb24ocmhzWzBdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzIyXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBVbmFyeU1pbnVzT3BlcmF0aW9uKHJoc1sxXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMjRdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IEJhck9wZXJhdGlvbihyaHNbMF0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMjVdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBhdGhFeHByKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCByaHNbMF0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzI3XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmhzWzBdLmxvY2F0aW9uUGF0aCA9IHJoc1syXTtcclxuXHRcdHJldHVybiByaHNbMF07XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMjhdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyaHNbMF0ubG9jYXRpb25QYXRoID0gcmhzWzJdO1xyXG5cdFx0cmhzWzBdLmxvY2F0aW9uUGF0aC5zdGVwcy51bnNoaWZ0KG5ldyBTdGVwKFN0ZXAuREVTQ0VOREFOVE9SU0VMRiwgbmV3IE5vZGVUZXN0KE5vZGVUZXN0Lk5PREUsIHVuZGVmaW5lZCksIFtdKSk7XHJcblx0XHRyZXR1cm4gcmhzWzBdO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzI5XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBQYXRoRXhwcihyaHNbMF0sIFtdLCB1bmRlZmluZWQpO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzMwXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyaHNbMF0sIFBhdGhFeHByKSkge1xyXG5cdFx0XHRpZiAocmhzWzBdLmZpbHRlclByZWRpY2F0ZXMgPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0cmhzWzBdLmZpbHRlclByZWRpY2F0ZXMgPSBbXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyaHNbMF0uZmlsdGVyUHJlZGljYXRlcy5wdXNoKHJoc1sxXSk7XHJcblx0XHRcdHJldHVybiByaHNbMF07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFBhdGhFeHByKHJoc1swXSwgW3Joc1sxXV0sIHVuZGVmaW5lZCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMzJdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gcmhzWzFdO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzMzXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBYU3RyaW5nKHJoc1swXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMzRdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IFhOdW1iZXIocmhzWzBdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1szNl0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgRnVuY3Rpb25DYWxsKHJoc1swXSwgW10pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzM3XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBGdW5jdGlvbkNhbGwocmhzWzBdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzM4XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIFsgcmhzWzBdIF07XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMzldID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyaHNbMl0udW5zaGlmdChyaHNbMF0pO1xyXG5cdFx0cmV0dXJuIHJoc1syXTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s0M10gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgTG9jYXRpb25QYXRoKHRydWUsIFtdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s0NF0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJoc1sxXS5hYnNvbHV0ZSA9IHRydWU7XHJcblx0XHRyZXR1cm4gcmhzWzFdO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzQ2XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBMb2NhdGlvblBhdGgoZmFsc2UsIFsgcmhzWzBdIF0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzQ3XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmhzWzBdLnN0ZXBzLnB1c2gocmhzWzJdKTtcclxuXHRcdHJldHVybiByaHNbMF07XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNDldID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IFN0ZXAocmhzWzBdLCByaHNbMV0sIFtdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s1MF0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgU3RlcChTdGVwLkNISUxELCByaHNbMF0sIFtdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s1MV0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgU3RlcChyaHNbMF0sIHJoc1sxXSwgcmhzWzJdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s1Ml0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgU3RlcChTdGVwLkNISUxELCByaHNbMF0sIHJoc1sxXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNTRdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gWyByaHNbMF0gXTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s1NV0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJoc1sxXS51bnNoaWZ0KHJoc1swXSk7XHJcblx0XHRyZXR1cm4gcmhzWzFdO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzU2XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0aWYgKHJoc1swXSA9PSBcImFuY2VzdG9yXCIpIHtcclxuXHRcdFx0cmV0dXJuIFN0ZXAuQU5DRVNUT1I7XHJcblx0XHR9IGVsc2UgaWYgKHJoc1swXSA9PSBcImFuY2VzdG9yLW9yLXNlbGZcIikge1xyXG5cdFx0XHRyZXR1cm4gU3RlcC5BTkNFU1RPUk9SU0VMRjtcclxuXHRcdH0gZWxzZSBpZiAocmhzWzBdID09IFwiYXR0cmlidXRlXCIpIHtcclxuXHRcdFx0cmV0dXJuIFN0ZXAuQVRUUklCVVRFO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJjaGlsZFwiKSB7XHJcblx0XHRcdHJldHVybiBTdGVwLkNISUxEO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJkZXNjZW5kYW50XCIpIHtcclxuXHRcdFx0cmV0dXJuIFN0ZXAuREVTQ0VOREFOVDtcclxuXHRcdH0gZWxzZSBpZiAocmhzWzBdID09IFwiZGVzY2VuZGFudC1vci1zZWxmXCIpIHtcclxuXHRcdFx0cmV0dXJuIFN0ZXAuREVTQ0VOREFOVE9SU0VMRjtcclxuXHRcdH0gZWxzZSBpZiAocmhzWzBdID09IFwiZm9sbG93aW5nXCIpIHtcclxuXHRcdFx0cmV0dXJuIFN0ZXAuRk9MTE9XSU5HO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJmb2xsb3dpbmctc2libGluZ1wiKSB7XHJcblx0XHRcdHJldHVybiBTdGVwLkZPTExPV0lOR1NJQkxJTkc7XHJcblx0XHR9IGVsc2UgaWYgKHJoc1swXSA9PSBcIm5hbWVzcGFjZVwiKSB7XHJcblx0XHRcdHJldHVybiBTdGVwLk5BTUVTUEFDRTtcclxuXHRcdH0gZWxzZSBpZiAocmhzWzBdID09IFwicGFyZW50XCIpIHtcclxuXHRcdFx0cmV0dXJuIFN0ZXAuUEFSRU5UO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJwcmVjZWRpbmdcIikge1xyXG5cdFx0XHRyZXR1cm4gU3RlcC5QUkVDRURJTkc7XHJcblx0XHR9IGVsc2UgaWYgKHJoc1swXSA9PSBcInByZWNlZGluZy1zaWJsaW5nXCIpIHtcclxuXHRcdFx0cmV0dXJuIFN0ZXAuUFJFQ0VESU5HU0lCTElORztcclxuXHRcdH0gZWxzZSBpZiAocmhzWzBdID09IFwic2VsZlwiKSB7XHJcblx0XHRcdHJldHVybiBTdGVwLlNFTEY7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNTddID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gU3RlcC5BVFRSSUJVVEU7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNTldID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRpZiAocmhzWzBdID09IFwiY29tbWVudFwiKSB7XHJcblx0XHRcdHJldHVybiBuZXcgTm9kZVRlc3QoTm9kZVRlc3QuQ09NTUVOVCwgdW5kZWZpbmVkKTtcclxuXHRcdH0gZWxzZSBpZiAocmhzWzBdID09IFwidGV4dFwiKSB7XHJcblx0XHRcdHJldHVybiBuZXcgTm9kZVRlc3QoTm9kZVRlc3QuVEVYVCwgdW5kZWZpbmVkKTtcclxuXHRcdH0gZWxzZSBpZiAocmhzWzBdID09IFwicHJvY2Vzc2luZy1pbnN0cnVjdGlvblwiKSB7XHJcblx0XHRcdHJldHVybiBuZXcgTm9kZVRlc3QoTm9kZVRlc3QuUEksIHVuZGVmaW5lZCk7XHJcblx0XHR9IGVsc2UgaWYgKHJoc1swXSA9PSBcIm5vZGVcIikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IE5vZGVUZXN0KE5vZGVUZXN0Lk5PREUsIHVuZGVmaW5lZCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IE5vZGVUZXN0KC0xLCB1bmRlZmluZWQpO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzYwXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBOb2RlVGVzdChOb2RlVGVzdC5QSSwgcmhzWzJdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s2MV0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiByaHNbMV07XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNjNdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyaHNbMV0uYWJzb2x1dGUgPSB0cnVlO1xyXG5cdFx0cmhzWzFdLnN0ZXBzLnVuc2hpZnQobmV3IFN0ZXAoU3RlcC5ERVNDRU5EQU5UT1JTRUxGLCBuZXcgTm9kZVRlc3QoTm9kZVRlc3QuTk9ERSwgdW5kZWZpbmVkKSwgW10pKTtcclxuXHRcdHJldHVybiByaHNbMV07XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNjRdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyaHNbMF0uc3RlcHMucHVzaChuZXcgU3RlcChTdGVwLkRFU0NFTkRBTlRPUlNFTEYsIG5ldyBOb2RlVGVzdChOb2RlVGVzdC5OT0RFLCB1bmRlZmluZWQpLCBbXSkpO1xyXG5cdFx0cmhzWzBdLnN0ZXBzLnB1c2gocmhzWzJdKTtcclxuXHRcdHJldHVybiByaHNbMF07XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNjVdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IFN0ZXAoU3RlcC5TRUxGLCBuZXcgTm9kZVRlc3QoTm9kZVRlc3QuTk9ERSwgdW5kZWZpbmVkKSwgW10pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzY2XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBTdGVwKFN0ZXAuUEFSRU5ULCBuZXcgTm9kZVRlc3QoTm9kZVRlc3QuTk9ERSwgdW5kZWZpbmVkKSwgW10pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzY3XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBWYXJpYWJsZVJlZmVyZW5jZShyaHNbMV0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzY4XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBOb2RlVGVzdChOb2RlVGVzdC5OQU1FVEVTVEFOWSwgdW5kZWZpbmVkKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s2OV0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHZhciBwcmVmaXggPSByaHNbMF0uc3Vic3RyaW5nKDAsIHJoc1swXS5pbmRleE9mKFwiOlwiKSk7XHJcblx0XHRyZXR1cm4gbmV3IE5vZGVUZXN0KE5vZGVUZXN0Lk5BTUVURVNUUFJFRklYQU5ZLCBwcmVmaXgpO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzcwXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBOb2RlVGVzdChOb2RlVGVzdC5OQU1FVEVTVFFOQU1FLCByaHNbMF0pO1xyXG5cdH07XHJcbn07XHJcblxyXG5YUGF0aFBhcnNlci5hY3Rpb25UYWJsZSA9IFtcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiICAgICAgICAgICAgICAgICBzICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyICByICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICBycnJyciAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCJycyAgcnJycnJycnIgcyAgc3Nzc3NycnJycnIgIHJycyBycyBcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyAgICAgICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciByciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciByciAgXCIsXHJcblx0XCIgIHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICAgICAgIFwiLFxyXG5cdFwiIHMgICAgICAgICAgIHMgIHNzc3NzICAgICAgICAgIHMgIHMgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyICByICBcIixcclxuXHRcImEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiciAgICAgICBzICAgICAgICAgICAgICAgICAgICByciAgciAgXCIsXHJcblx0XCJyICAgICAgc3IgICAgICAgICAgICAgICAgICAgIHJyICByICBcIixcclxuXHRcInIgICBzICByciAgICAgICAgICAgIHMgICAgICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJzc3JyICAgICAgICAgICAgcnNzICAgICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnIgICAgICAgICAgICBycnJzcyAgIHJyICByICBcIixcclxuXHRcInIgICBycnJycnNzcyAgICAgICAgIHJycnJyICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJycnJyICAgICAgICAgcnJycnIgICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnJycnIgICAgICAgICBycnJycnMgIHJyICByICBcIixcclxuXHRcInIgICBycnJycnJyciAgICAgICAgIHJycnJyciAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJycnJyICAgICAgICAgcnJycnJyICByciAgciAgXCIsXHJcblx0XCJyICBzcnJycnJycnIgICAgICAgICBycnJycnJzIHJyIHNyICBcIixcclxuXHRcInIgIHNycnJycnJyciAgICAgICAgIHJycnJycnMgcnIgIHIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciByciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiciAgIHJycnJycnJyICAgICAgICAgcnJycnJyICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnJycnIgICAgICAgICBycnJycnIgIHJyICByICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgIHIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciAgciAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgc3Nzc3MgICAgICAgICAgICAgICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgc3IgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciAgciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICAgICAgXCIsXHJcblx0XCJyICBzcnJycnJycnIgICAgICAgICBycnJycnJzIHJyICByICBcIixcclxuXHRcInIgICBycnJycnJyciAgICAgICAgIHJycnJyICAgcnIgIHIgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICBzICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICBycnJyciAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3NzIHMgIHNzXCIsXHJcblx0XCJyICBzcnJycnJycnIgICAgICAgICBycnJycnJzIHJyICByICBcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgICAgc3MgIHMgIHNzXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcIiBzICAgICAgICAgICBzICBzc3NzcyAgICAgICAgICBzICBzIFwiLFxyXG5cdFwiIHMgICAgICAgICAgIHMgIHNzc3NzICAgICAgICAgIHMgIHMgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcIiBzICAgICAgICAgICBzICBzc3NzcyAgICAgICAgICBzICBzIFwiLFxyXG5cdFwiIHMgICAgICAgICAgIHMgIHNzc3NzICAgICAgICAgIHMgIHMgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHNyICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgc3IgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciAgciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyAgICAgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciByciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnIgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJzICAgICBcIixcclxuXHRcInIgICAgICBzciAgICAgICAgICAgICAgICAgICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHMgIHJyICAgICAgICAgICAgcyAgICAgICByciAgciAgXCIsXHJcblx0XCJyICAgcnNzcnIgICAgICAgICAgICByc3MgICAgIHJyICByICBcIixcclxuXHRcInIgICByc3NyciAgICAgICAgICAgIHJzcyAgICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJyICAgICAgICAgICAgcnJyc3MgICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnIgICAgICAgICAgICBycnJzcyAgIHJyICByICBcIixcclxuXHRcInIgICBycnJyciAgICAgICAgICAgIHJycnNzICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJyICAgICAgICAgICAgcnJyc3MgICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnJzc3MgICAgICAgICBycnJyciAgIHJyICByICBcIixcclxuXHRcInIgICBycnJycnNzcyAgICAgICAgIHJycnJyICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJycnJyICAgICAgICAgcnJycnIgICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnJycnIgICAgICAgICBycnJyciAgIHJyICByICBcIixcclxuXHRcInIgICBycnJycnJyciAgICAgICAgIHJycnJyICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJycnJyICAgICAgICAgcnJycnJyICByciAgciAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgIFwiLFxyXG5cdFwiciAgc3JycnJycnJyICAgICAgICAgcnJycnJycyByciAgciAgXCIsXHJcblx0XCJyICBzcnJycnJycnIgICAgICAgICBycnJycnJzIHJyICByICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgIHIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciAgciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyICByICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgIHIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciByciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciByciAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgICAgICBcIlxyXG5dO1xyXG5cclxuWFBhdGhQYXJzZXIuYWN0aW9uVGFibGVOdW1iZXIgPSBbXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgSiAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiYSAgYWFhYWFhYWFhICAgICAgICAgYWFhYWFhYSBhYSAgYSAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgWVlZWVkgICAgICAgICAgICAgICBcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiSzEgIEtLS0tLS0tLIC4gICsqKSgnS0tLS0tLICBLSyMgS1xcXCIgXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8gICAgICAgXCIsXHJcblx0XCJlICBlZWVlZWVlZWUgICAgICAgICBlZWVlZWVlIGVlIGVlICBcIixcclxuXHRcImYgIGZmZmZmZmZmZiAgICAgICAgIGZmZmZmZmYgZmYgZmYgIFwiLFxyXG5cdFwiZCAgZGRkZGRkZGRkICAgICAgICAgZGRkZGRkZCBkZCBkZCAgXCIsXHJcblx0XCJCICBCQkJCQkJCQkIgICAgICAgICBCQkJCQkJCIEJCIEJCICBcIixcclxuXHRcIkEgIEFBQUFBQUFBQSAgICAgICAgIEFBQUFBQUEgQUEgQUEgIFwiLFxyXG5cdFwiICBQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgUSAgICAgICBcIixcclxuXHRcIiAxICAgICAgICAgICAuICArKikoJyAgICAgICAgICAjICBcXFwiIFwiLFxyXG5cdFwiYiAgYmJiYmJiYmJiICAgICAgICAgYmJiYmJiYiBiYiAgYiAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiEgICAgICAgUyAgICAgICAgICAgICAgICAgICAgISEgICEgIFwiLFxyXG5cdFwiXFxcIiAgICAgIFRcXFwiICAgICAgICAgICAgICAgICAgICBcXFwiXFxcIiAgXFxcIiAgXCIsXHJcblx0XCIkICAgViAgJCQgICAgICAgICAgICBVICAgICAgICQkICAkICBcIixcclxuXHRcIiYgICAmWlkmJiAgICAgICAgICAgICZYVyAgICAgJiYgICYgIFwiLFxyXG5cdFwiKSAgICkpKSkpICAgICAgICAgICAgKSkpXFxcXFsgICApKSAgKSAgXCIsXHJcblx0XCIuICAgLi4uLi5fXl0gICAgICAgICAuLi4uLiAgIC4uICAuICBcIixcclxuXHRcIjEgICAxMTExMTExMSAgICAgICAgIDExMTExICAgMTEgIDEgIFwiLFxyXG5cdFwiNSAgIDU1NTU1NTU1ICAgICAgICAgNTU1NTVgICA1NSAgNSAgXCIsXHJcblx0XCI3ICAgNzc3Nzc3NzcgICAgICAgICA3Nzc3NzcgIDc3ICA3ICBcIixcclxuXHRcIjkgICA5OTk5OTk5OSAgICAgICAgIDk5OTk5OSAgOTkgIDkgIFwiLFxyXG5cdFwiOiAgYzo6Ojo6Ojo6ICAgICAgICAgOjo6Ojo6YiA6OiBhOiAgXCIsXHJcblx0XCJJICBmSUlJSUlJSUkgICAgICAgICBJSUlJSUllIElJICBJICBcIixcclxuXHRcIj0gID09PT09PT09PSAgICAgICAgID09PT09PT0gPT0gPT0gIFwiLFxyXG5cdFwiPyAgPz8/Pz8/Pz8/ICAgICAgICAgPz8/Pz8/PyA/PyA/PyAgXCIsXHJcblx0XCJDICBDQ0NDQ0NDQ0MgICAgICAgICBDQ0NDQ0NDIENDIENDICBcIixcclxuXHRcIkogICBKSkpKSkpKSiAgICAgICAgIEpKSkpKSiAgSkogIEogIFwiLFxyXG5cdFwiTSAgIE1NTU1NTU1NICAgICAgICAgTU1NTU1NICBNTSAgTSAgXCIsXHJcblx0XCJOICBOTk5OTk5OTk4gICAgICAgICBOTk5OTk5OIE5OICBOICBcIixcclxuXHRcIlAgIFBQUFBQUFBQUCAgICAgICAgIFBQUFBQUFAgUFAgIFAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICsqKSgnICAgICAgICAgICAgICAgXCIsXHJcblx0XCJSICBSUlJSUlJSUlIgICAgICAgICBSUlJSUlJSIFJSIGFSICBcIixcclxuXHRcIlUgIFVVVVVVVVVVVSAgICAgICAgIFVVVVVVVVUgVVUgIFUgIFwiLFxyXG5cdFwiWiAgWlpaWlpaWlpaICAgICAgICAgWlpaWlpaWiBaWiBaWiAgXCIsXHJcblx0XCJjICBjY2NjY2NjY2MgICAgICAgICBjY2NjY2NjIGNjIGNjICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaiAgICAgIFwiLFxyXG5cdFwiTCAgZkxMTExMTExMICAgICAgICAgTExMTExMZSBMTCAgTCAgXCIsXHJcblx0XCI2ICAgNjY2NjY2NjYgICAgICAgICA2NjY2NiAgIDY2ICA2ICBcIixcclxuXHRcIiAgICAgICAgICAgICAgayAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgWFhYWFggICAgICAgICAgICAgICBcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkbSAjICBcXFwiIVwiLFxyXG5cdFwiXyAgZl9fX19fX19fICAgICAgICAgX19fX19fZSBfXyAgXyAgXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAgICUkICAjICBcXFwiIVwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgMSAgICAgICAgICAgLiAgKyopKCcgICAgICAgICAgIyAgXFxcIiBcIixcclxuXHRcIiAxICAgICAgICAgICAuICArKikoJyAgICAgICAgICAjICBcXFwiIFwiLFxyXG5cdFwiPiAgPj4+Pj4+Pj4+ICAgICAgICAgPj4+Pj4+PiA+PiA+PiAgXCIsXHJcblx0XCIgMSAgICAgICAgICAgLiAgKyopKCcgICAgICAgICAgIyAgXFxcIiBcIixcclxuXHRcIiAxICAgICAgICAgICAuICArKikoJyAgICAgICAgICAjICBcXFwiIFwiLFxyXG5cdFwiUSAgUVFRUVFRUVFRICAgICAgICAgUVFRUVFRUSBRUSBhUSAgXCIsXHJcblx0XCJWICBWVlZWVlZWVlYgICAgICAgICBWVlZWVlZWIFZWIGFWICBcIixcclxuXHRcIlQgIFRUVFRUVFRUVCAgICAgICAgIFRUVFRUVFQgVFQgIFQgIFwiLFxyXG5cdFwiQCAgQEBAQEBAQEBAICAgICAgICAgQEBAQEBAQCBAQCBAQCAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxceDg3ICAgICAgXCIsXHJcblx0XCJbICBbW1tbW1tbW1sgICAgICAgICBbW1tbW1tbIFtbIFtbICBcIixcclxuXHRcIkQgIERERERERERERCAgICAgICAgIEREREREREQgREQgREQgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBISCAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxceDg4ICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZcXHg4OSAgICAgXCIsXHJcblx0XCIjICAgICAgVCMgICAgICAgICAgICAgICAgICAgICMjICAjICBcIixcclxuXHRcIiUgICBWICAlJSAgICAgICAgICAgIFUgICAgICAgJSUgICUgIFwiLFxyXG5cdFwiJyAgICdaWScnICAgICAgICAgICAgJ1hXICAgICAnJyAgJyAgXCIsXHJcblx0XCIoICAgKFpZKCggICAgICAgICAgICAoWFcgICAgICgoICAoICBcIixcclxuXHRcIisgICArKysrKyAgICAgICAgICAgICsrK1xcXFxbICAgKysgICsgIFwiLFxyXG5cdFwiKiAgICoqKioqICAgICAgICAgICAgKioqXFxcXFsgICAqKiAgKiAgXCIsXHJcblx0XCItICAgLS0tLS0gICAgICAgICAgICAtLS1cXFxcWyAgIC0tICAtICBcIixcclxuXHRcIiwgICAsLCwsLCAgICAgICAgICAgICwsLFxcXFxbICAgLCwgICwgIFwiLFxyXG5cdFwiMCAgIDAwMDAwX15dICAgICAgICAgMDAwMDAgICAwMCAgMCAgXCIsXHJcblx0XCIvICAgLy8vLy9fXl0gICAgICAgICAvLy8vLyAgIC8vICAvICBcIixcclxuXHRcIjIgICAyMjIyMjIyMiAgICAgICAgIDIyMjIyICAgMjIgIDIgIFwiLFxyXG5cdFwiMyAgIDMzMzMzMzMzICAgICAgICAgMzMzMzMgICAzMyAgMyAgXCIsXHJcblx0XCI0ICAgNDQ0NDQ0NDQgICAgICAgICA0NDQ0NCAgIDQ0ICA0ICBcIixcclxuXHRcIjggICA4ODg4ODg4OCAgICAgICAgIDg4ODg4OCAgODggIDggIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXiAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXHg4YSAgXCIsXHJcblx0XCI7ICBmOzs7Ozs7OzsgICAgICAgICA7Ozs7OztlIDs7ICA7ICBcIixcclxuXHRcIjwgIGY8PDw8PDw8PCAgICAgICAgIDw8PDw8PGUgPDwgIDwgIFwiLFxyXG5cdFwiTyAgT09PT09PT09PICAgICAgICAgT09PT09PTyBPTyAgTyAgXCIsXHJcblx0XCJgICBgYGBgYGBgYGAgICAgICAgICBgYGBgYGBgIGBgICBgICBcIixcclxuXHRcIlMgIFNTU1NTU1NTUyAgICAgICAgIFNTU1NTU1MgU1MgIFMgIFwiLFxyXG5cdFwiVyAgV1dXV1dXV1dXICAgICAgICAgV1dXV1dXVyBXVyAgVyAgXCIsXHJcblx0XCJcXFxcICBcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwgICAgICAgICBcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcIFxcXFxcXFxcIFxcXFxcXFxcICBcIixcclxuXHRcIkUgIEVFRUVFRUVFRSAgICAgICAgIEVFRUVFRUUgRUUgRUUgIFwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCJdICBdXV1dXV1dXV0gICAgICAgICBdXV1dXV1dIF1dIF1dICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRyAgICAgIFwiXHJcbl07XHJcblxyXG5YUGF0aFBhcnNlci5nb3RvVGFibGUgPSBbXHJcblx0XCIzNDU2Nzg5Ojs8PT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiTDQ1Njc4OTo7PD0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIiAgICAgICAgICAgIE0gICAgICAgIEVGR0ggSUogXCIsXHJcblx0XCIgICAgICAgTjs8PT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgUyAgICAgICAgRUZHSCBJSiBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgZSAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgIGggIEogXCIsXHJcblx0XCIgICAgICAgICAgICAgIGkgICAgICAgICAgaiAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwibzQ1Njc4OTo7PD0+P0AgQUJwcUNERUZHSCBJSiBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgIHI2Nzg5Ojs8PT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgczc4OTo7PD0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIiAgICB0ODk6Ozw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICAgdTg5Ojs8PT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgICB2OTo7PD0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIiAgICAgdzk6Ozw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICAgIHg5Ojs8PT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgICB5OTo7PD0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIiAgICAgIHo6Ozw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICAgICB7Ojs8PT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgIHw7PD0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIiAgICAgICB9Ozw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICAgICAgfjs8PT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgICAgXFx4N2Y9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCJcXHg4MDQ1Njc4OTo7PD0+P0AgQUIgIENERUZHSCBJSlxceDgxXCIsXHJcblx0XCIgICAgICAgICAgICBcXHg4MiAgICAgICAgRUZHSCBJSiBcIixcclxuXHRcIiAgICAgICAgICAgIFxceDgzICAgICAgICBFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgIFxceDg0IEdIIElKIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgXFx4ODUgR0ggSUogXCIsXHJcblx0XCIgICAgICAgICAgICAgIGkgICAgICAgICAgXFx4ODYgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgaSAgICAgICAgICBcXHg4NyAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCJvNDU2Nzg5Ojs8PT4/QCBBQlxceDhjcUNERUZHSCBJSiBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXHJcbl07XHJcblxyXG5YUGF0aFBhcnNlci5wcm9kdWN0aW9ucyA9IFtcclxuXHRbMSwgMSwgMl0sXHJcblx0WzIsIDEsIDNdLFxyXG5cdFszLCAxLCA0XSxcclxuXHRbMywgMywgMywgLTksIDRdLFxyXG5cdFs0LCAxLCA1XSxcclxuXHRbNCwgMywgNCwgLTgsIDVdLFxyXG5cdFs1LCAxLCA2XSxcclxuXHRbNSwgMywgNSwgLTIyLCA2XSxcclxuXHRbNSwgMywgNSwgLTUsIDZdLFxyXG5cdFs2LCAxLCA3XSxcclxuXHRbNiwgMywgNiwgLTIzLCA3XSxcclxuXHRbNiwgMywgNiwgLTI0LCA3XSxcclxuXHRbNiwgMywgNiwgLTYsIDddLFxyXG5cdFs2LCAzLCA2LCAtNywgN10sXHJcblx0WzcsIDEsIDhdLFxyXG5cdFs3LCAzLCA3LCAtMjUsIDhdLFxyXG5cdFs3LCAzLCA3LCAtMjYsIDhdLFxyXG5cdFs4LCAxLCA5XSxcclxuXHRbOCwgMywgOCwgLTEyLCA5XSxcclxuXHRbOCwgMywgOCwgLTExLCA5XSxcclxuXHRbOCwgMywgOCwgLTEwLCA5XSxcclxuXHRbOSwgMSwgMTBdLFxyXG5cdFs5LCAyLCAtMjYsIDldLFxyXG5cdFsxMCwgMSwgMTFdLFxyXG5cdFsxMCwgMywgMTAsIC0yNywgMTFdLFxyXG5cdFsxMSwgMSwgMTJdLFxyXG5cdFsxMSwgMSwgMTNdLFxyXG5cdFsxMSwgMywgMTMsIC0yOCwgMTRdLFxyXG5cdFsxMSwgMywgMTMsIC00LCAxNF0sXHJcblx0WzEzLCAxLCAxNV0sXHJcblx0WzEzLCAyLCAxMywgMTZdLFxyXG5cdFsxNSwgMSwgMTddLFxyXG5cdFsxNSwgMywgLTI5LCAyLCAtMzBdLFxyXG5cdFsxNSwgMSwgLTE1XSxcclxuXHRbMTUsIDEsIC0xNl0sXHJcblx0WzE1LCAxLCAxOF0sXHJcblx0WzE4LCAzLCAtMTMsIC0yOSwgLTMwXSxcclxuXHRbMTgsIDQsIC0xMywgLTI5LCAxOSwgLTMwXSxcclxuXHRbMTksIDEsIDIwXSxcclxuXHRbMTksIDMsIDIwLCAtMzEsIDE5XSxcclxuXHRbMjAsIDEsIDJdLFxyXG5cdFsxMiwgMSwgMTRdLFxyXG5cdFsxMiwgMSwgMjFdLFxyXG5cdFsyMSwgMSwgLTI4XSxcclxuXHRbMjEsIDIsIC0yOCwgMTRdLFxyXG5cdFsyMSwgMSwgMjJdLFxyXG5cdFsxNCwgMSwgMjNdLFxyXG5cdFsxNCwgMywgMTQsIC0yOCwgMjNdLFxyXG5cdFsxNCwgMSwgMjRdLFxyXG5cdFsyMywgMiwgMjUsIDI2XSxcclxuXHRbMjMsIDEsIDI2XSxcclxuXHRbMjMsIDMsIDI1LCAyNiwgMjddLFxyXG5cdFsyMywgMiwgMjYsIDI3XSxcclxuXHRbMjMsIDEsIDI4XSxcclxuXHRbMjcsIDEsIDE2XSxcclxuXHRbMjcsIDIsIDE2LCAyN10sXHJcblx0WzI1LCAyLCAtMTQsIC0zXSxcclxuXHRbMjUsIDEsIC0zMl0sXHJcblx0WzI2LCAxLCAyOV0sXHJcblx0WzI2LCAzLCAtMjAsIC0yOSwgLTMwXSxcclxuXHRbMjYsIDQsIC0yMSwgLTI5LCAtMTUsIC0zMF0sXHJcblx0WzE2LCAzLCAtMzMsIDMwLCAtMzRdLFxyXG5cdFszMCwgMSwgMl0sXHJcblx0WzIyLCAyLCAtNCwgMTRdLFxyXG5cdFsyNCwgMywgMTQsIC00LCAyM10sXHJcblx0WzI4LCAxLCAtMzVdLFxyXG5cdFsyOCwgMSwgLTJdLFxyXG5cdFsxNywgMiwgLTM2LCAtMThdLFxyXG5cdFsyOSwgMSwgLTE3XSxcclxuXHRbMjksIDEsIC0xOV0sXHJcblx0WzI5LCAxLCAtMThdXHJcbl07XHJcblxyXG5YUGF0aFBhcnNlci5ET1VCTEVET1QgPSAyO1xyXG5YUGF0aFBhcnNlci5ET1VCTEVDT0xPTiA9IDM7XHJcblhQYXRoUGFyc2VyLkRPVUJMRVNMQVNIID0gNDtcclxuWFBhdGhQYXJzZXIuTk9URVFVQUwgPSA1O1xyXG5YUGF0aFBhcnNlci5MRVNTVEhBTk9SRVFVQUwgPSA2O1xyXG5YUGF0aFBhcnNlci5HUkVBVEVSVEhBTk9SRVFVQUwgPSA3O1xyXG5YUGF0aFBhcnNlci5BTkQgPSA4O1xyXG5YUGF0aFBhcnNlci5PUiA9IDk7XHJcblhQYXRoUGFyc2VyLk1PRCA9IDEwO1xyXG5YUGF0aFBhcnNlci5ESVYgPSAxMTtcclxuWFBhdGhQYXJzZXIuTVVMVElQTFlPUEVSQVRPUiA9IDEyO1xyXG5YUGF0aFBhcnNlci5GVU5DVElPTk5BTUUgPSAxMztcclxuWFBhdGhQYXJzZXIuQVhJU05BTUUgPSAxNDtcclxuWFBhdGhQYXJzZXIuTElURVJBTCA9IDE1O1xyXG5YUGF0aFBhcnNlci5OVU1CRVIgPSAxNjtcclxuWFBhdGhQYXJzZXIuQVNURVJJU0tOQU1FVEVTVCA9IDE3O1xyXG5YUGF0aFBhcnNlci5RTkFNRSA9IDE4O1xyXG5YUGF0aFBhcnNlci5OQ05BTUVDT0xPTkFTVEVSSVNLID0gMTk7XHJcblhQYXRoUGFyc2VyLk5PREVUWVBFID0gMjA7XHJcblhQYXRoUGFyc2VyLlBST0NFU1NJTkdJTlNUUlVDVElPTldJVEhMSVRFUkFMID0gMjE7XHJcblhQYXRoUGFyc2VyLkVRVUFMUyA9IDIyO1xyXG5YUGF0aFBhcnNlci5MRVNTVEhBTiA9IDIzO1xyXG5YUGF0aFBhcnNlci5HUkVBVEVSVEhBTiA9IDI0O1xyXG5YUGF0aFBhcnNlci5QTFVTID0gMjU7XHJcblhQYXRoUGFyc2VyLk1JTlVTID0gMjY7XHJcblhQYXRoUGFyc2VyLkJBUiA9IDI3O1xyXG5YUGF0aFBhcnNlci5TTEFTSCA9IDI4O1xyXG5YUGF0aFBhcnNlci5MRUZUUEFSRU5USEVTSVMgPSAyOTtcclxuWFBhdGhQYXJzZXIuUklHSFRQQVJFTlRIRVNJUyA9IDMwO1xyXG5YUGF0aFBhcnNlci5DT01NQSA9IDMxO1xyXG5YUGF0aFBhcnNlci5BVCA9IDMyO1xyXG5YUGF0aFBhcnNlci5MRUZUQlJBQ0tFVCA9IDMzO1xyXG5YUGF0aFBhcnNlci5SSUdIVEJSQUNLRVQgPSAzNDtcclxuWFBhdGhQYXJzZXIuRE9UID0gMzU7XHJcblhQYXRoUGFyc2VyLkRPTExBUiA9IDM2O1xyXG5cclxuWFBhdGhQYXJzZXIucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24oczEpIHtcclxuXHR2YXIgdHlwZXMgPSBbXTtcclxuXHR2YXIgdmFsdWVzID0gW107XHJcblx0dmFyIHMgPSBzMSArICdcXDAnO1xyXG5cclxuXHR2YXIgcG9zID0gMDtcclxuXHR2YXIgYyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHR3aGlsZSAoMSkge1xyXG5cdFx0d2hpbGUgKGMgPT0gJyAnIHx8IGMgPT0gJ1xcdCcgfHwgYyA9PSAnXFxyJyB8fCBjID09ICdcXG4nKSB7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHR9XHJcblx0XHRpZiAoYyA9PSAnXFwwJyB8fCBwb3MgPj0gcy5sZW5ndGgpIHtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGMgPT0gJygnKSB7XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuTEVGVFBBUkVOVEhFU0lTKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goYyk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGMgPT0gJyknKSB7XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuUklHSFRQQVJFTlRIRVNJUyk7XHJcblx0XHRcdHZhbHVlcy5wdXNoKGMpO1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHRcdGlmIChjID09ICdbJykge1xyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkxFRlRCUkFDS0VUKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goYyk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGMgPT0gJ10nKSB7XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuUklHSFRCUkFDS0VUKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goYyk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGMgPT0gJ0AnKSB7XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuQVQpO1xyXG5cdFx0XHR2YWx1ZXMucHVzaChjKTtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblx0XHRpZiAoYyA9PSAnLCcpIHtcclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5DT01NQSk7XHJcblx0XHRcdHZhbHVlcy5wdXNoKGMpO1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHRcdGlmIChjID09ICd8Jykge1xyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkJBUik7XHJcblx0XHRcdHZhbHVlcy5wdXNoKGMpO1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHRcdGlmIChjID09ICcrJykge1xyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLlBMVVMpO1xyXG5cdFx0XHR2YWx1ZXMucHVzaChjKTtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblx0XHRpZiAoYyA9PSAnLScpIHtcclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5NSU5VUyk7XHJcblx0XHRcdHZhbHVlcy5wdXNoKGMpO1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHRcdGlmIChjID09ICc9Jykge1xyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkVRVUFMUyk7XHJcblx0XHRcdHZhbHVlcy5wdXNoKGMpO1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHRcdGlmIChjID09ICckJykge1xyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkRPTExBUik7XHJcblx0XHRcdHZhbHVlcy5wdXNoKGMpO1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYyA9PSAnLicpIHtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0aWYgKGMgPT0gJy4nKSB7XHJcblx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5ET1VCTEVET1QpO1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKFwiLi5cIik7XHJcblx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoYyA+PSAnMCcgJiYgYyA8PSAnOScpIHtcclxuXHRcdFx0XHR2YXIgbnVtYmVyID0gXCIuXCIgKyBjO1xyXG5cdFx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdFx0d2hpbGUgKGMgPj0gJzAnICYmIGMgPD0gJzknKSB7XHJcblx0XHRcdFx0XHRudW1iZXIgKz0gYztcclxuXHRcdFx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuTlVNQkVSKTtcclxuXHRcdFx0XHR2YWx1ZXMucHVzaChudW1iZXIpO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuRE9UKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goJy4nKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGMgPT0gJ1xcJycgfHwgYyA9PSAnXCInKSB7XHJcblx0XHRcdHZhciBkZWxpbWl0ZXIgPSBjO1xyXG5cdFx0XHR2YXIgbGl0ZXJhbCA9IFwiXCI7XHJcblx0XHRcdHdoaWxlICgoYyA9IHMuY2hhckF0KHBvcysrKSkgIT0gZGVsaW1pdGVyKSB7XHJcblx0XHRcdFx0bGl0ZXJhbCArPSBjO1xyXG5cdFx0XHR9XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuTElURVJBTCk7XHJcblx0XHRcdHZhbHVlcy5wdXNoKGxpdGVyYWwpO1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYyA+PSAnMCcgJiYgYyA8PSAnOScpIHtcclxuXHRcdFx0dmFyIG51bWJlciA9IGM7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdHdoaWxlIChjID49ICcwJyAmJiBjIDw9ICc5Jykge1xyXG5cdFx0XHRcdG51bWJlciArPSBjO1xyXG5cdFx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGMgPT0gJy4nKSB7XHJcblx0XHRcdFx0aWYgKHMuY2hhckF0KHBvcykgPj0gJzAnICYmIHMuY2hhckF0KHBvcykgPD0gJzknKSB7XHJcblx0XHRcdFx0XHRudW1iZXIgKz0gYztcclxuXHRcdFx0XHRcdG51bWJlciArPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRcdFx0d2hpbGUgKGMgPj0gJzAnICYmIGMgPD0gJzknKSB7XHJcblx0XHRcdFx0XHRcdG51bWJlciArPSBjO1xyXG5cdFx0XHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLk5VTUJFUik7XHJcblx0XHRcdHZhbHVlcy5wdXNoKG51bWJlcik7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjID09ICcqJykge1xyXG5cdFx0XHRpZiAodHlwZXMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdHZhciBsYXN0ID0gdHlwZXNbdHlwZXMubGVuZ3RoIC0gMV07XHJcblx0XHRcdFx0aWYgKGxhc3QgIT0gWFBhdGhQYXJzZXIuQVRcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5ET1VCTEVDT0xPTlxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkxFRlRQQVJFTlRIRVNJU1xyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkxFRlRCUkFDS0VUXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuQU5EXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuT1JcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5NT0RcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5ESVZcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5NVUxUSVBMWU9QRVJBVE9SXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuU0xBU0hcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5ET1VCTEVTTEFTSFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkJBUlxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLlBMVVNcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5NSU5VU1xyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkVRVUFMU1xyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLk5PVEVRVUFMXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTEVTU1RIQU5cclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5MRVNTVEhBTk9SRVFVQUxcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5HUkVBVEVSVEhBTlxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkdSRUFURVJUSEFOT1JFUVVBTCkge1xyXG5cdFx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5NVUxUSVBMWU9QRVJBVE9SKTtcclxuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKGMpO1xyXG5cdFx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkFTVEVSSVNLTkFNRVRFU1QpO1xyXG5cdFx0XHR2YWx1ZXMucHVzaChjKTtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGMgPT0gJzonKSB7XHJcblx0XHRcdGlmIChzLmNoYXJBdChwb3MpID09ICc6Jykge1xyXG5cdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuRE9VQkxFQ09MT04pO1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKFwiOjpcIik7XHJcblx0XHRcdFx0cG9zKys7XHJcblx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjID09ICcvJykge1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRpZiAoYyA9PSAnLycpIHtcclxuXHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkRPVUJMRVNMQVNIKTtcclxuXHRcdFx0XHR2YWx1ZXMucHVzaChcIi8vXCIpO1xyXG5cdFx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5TTEFTSCk7XHJcblx0XHRcdHZhbHVlcy5wdXNoKCcvJyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjID09ICchJykge1xyXG5cdFx0XHRpZiAocy5jaGFyQXQocG9zKSA9PSAnPScpIHtcclxuXHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLk5PVEVRVUFMKTtcclxuXHRcdFx0XHR2YWx1ZXMucHVzaChcIiE9XCIpO1xyXG5cdFx0XHRcdHBvcysrO1xyXG5cdFx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYyA9PSAnPCcpIHtcclxuXHRcdFx0aWYgKHMuY2hhckF0KHBvcykgPT0gJz0nKSB7XHJcblx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5MRVNTVEhBTk9SRVFVQUwpO1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKFwiPD1cIik7XHJcblx0XHRcdFx0cG9zKys7XHJcblx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkxFU1NUSEFOKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goJzwnKTtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGMgPT0gJz4nKSB7XHJcblx0XHRcdGlmIChzLmNoYXJBdChwb3MpID09ICc9Jykge1xyXG5cdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuR1JFQVRFUlRIQU5PUkVRVUFMKTtcclxuXHRcdFx0XHR2YWx1ZXMucHVzaChcIj49XCIpO1xyXG5cdFx0XHRcdHBvcysrO1xyXG5cdFx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5HUkVBVEVSVEhBTik7XHJcblx0XHRcdHZhbHVlcy5wdXNoKCc+Jyk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjID09ICdfJyB8fCBVdGlsaXRpZXMuaXNMZXR0ZXIoYy5jaGFyQ29kZUF0KDApKSkge1xyXG5cdFx0XHR2YXIgbmFtZSA9IGM7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdHdoaWxlIChVdGlsaXRpZXMuaXNOQ05hbWVDaGFyKGMuY2hhckNvZGVBdCgwKSkpIHtcclxuXHRcdFx0XHRuYW1lICs9IGM7XHJcblx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodHlwZXMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdHZhciBsYXN0ID0gdHlwZXNbdHlwZXMubGVuZ3RoIC0gMV07XHJcblx0XHRcdFx0aWYgKGxhc3QgIT0gWFBhdGhQYXJzZXIuQVRcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5ET1VCTEVDT0xPTlxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkxFRlRQQVJFTlRIRVNJU1xyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkxFRlRCUkFDS0VUXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuQU5EXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuT1JcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5NT0RcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5ESVZcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5NVUxUSVBMWU9QRVJBVE9SXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuU0xBU0hcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5ET1VCTEVTTEFTSFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkJBUlxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLlBMVVNcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5NSU5VU1xyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkVRVUFMU1xyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLk5PVEVRVUFMXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTEVTU1RIQU5cclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5MRVNTVEhBTk9SRVFVQUxcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5HUkVBVEVSVEhBTlxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkdSRUFURVJUSEFOT1JFUVVBTCkge1xyXG5cdFx0XHRcdFx0aWYgKG5hbWUgPT0gXCJhbmRcIikge1xyXG5cdFx0XHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkFORCk7XHJcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKG5hbWUpO1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChuYW1lID09IFwib3JcIikge1xyXG5cdFx0XHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLk9SKTtcclxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2gobmFtZSk7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKG5hbWUgPT0gXCJtb2RcIikge1xyXG5cdFx0XHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLk1PRCk7XHJcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKG5hbWUpO1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChuYW1lID09IFwiZGl2XCIpIHtcclxuXHRcdFx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5ESVYpO1xyXG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaChuYW1lKTtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChjID09ICc6Jykge1xyXG5cdFx0XHRcdGlmIChzLmNoYXJBdChwb3MpID09ICcqJykge1xyXG5cdFx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5OQ05BTUVDT0xPTkFTVEVSSVNLKTtcclxuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKG5hbWUgKyBcIjoqXCIpO1xyXG5cdFx0XHRcdFx0cG9zKys7XHJcblx0XHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChzLmNoYXJBdChwb3MpID09ICdfJyB8fCBVdGlsaXRpZXMuaXNMZXR0ZXIocy5jaGFyQ29kZUF0KHBvcykpKSB7XHJcblx0XHRcdFx0XHRuYW1lICs9ICc6JztcclxuXHRcdFx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdFx0XHR3aGlsZSAoVXRpbGl0aWVzLmlzTkNOYW1lQ2hhcihjLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0XHRcdFx0XHRcdG5hbWUgKz0gYztcclxuXHRcdFx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChjID09ICcoJykge1xyXG5cdFx0XHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkZVTkNUSU9OTkFNRSk7XHJcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKG5hbWUpO1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuUU5BTUUpO1xyXG5cdFx0XHRcdFx0dmFsdWVzLnB1c2gobmFtZSk7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHMuY2hhckF0KHBvcykgPT0gJzonKSB7XHJcblx0XHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkFYSVNOQU1FKTtcclxuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKG5hbWUpO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChjID09ICcoJykge1xyXG5cdFx0XHRcdGlmIChuYW1lID09IFwiY29tbWVudFwiIHx8IG5hbWUgPT0gXCJ0ZXh0XCIgfHwgbmFtZSA9PSBcIm5vZGVcIikge1xyXG5cdFx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5OT0RFVFlQRSk7XHJcblx0XHRcdFx0XHR2YWx1ZXMucHVzaChuYW1lKTtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAobmFtZSA9PSBcInByb2Nlc3NpbmctaW5zdHJ1Y3Rpb25cIikge1xyXG5cdFx0XHRcdFx0aWYgKHMuY2hhckF0KHBvcykgPT0gJyknKSB7XHJcblx0XHRcdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuTk9ERVRZUEUpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5QUk9DRVNTSU5HSU5TVFJVQ1RJT05XSVRITElURVJBTCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR2YWx1ZXMucHVzaChuYW1lKTtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkZVTkNUSU9OTkFNRSk7XHJcblx0XHRcdFx0dmFsdWVzLnB1c2gobmFtZSk7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5RTkFNRSk7XHJcblx0XHRcdHZhbHVlcy5wdXNoKG5hbWUpO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNoYXJhY3RlciBcIiArIGMpO1xyXG5cdH1cclxuXHR0eXBlcy5wdXNoKDEpO1xyXG5cdHZhbHVlcy5wdXNoKFwiW0VPRl1cIik7XHJcblx0cmV0dXJuIFt0eXBlcywgdmFsdWVzXTtcclxufTtcclxuXHJcblhQYXRoUGFyc2VyLlNISUZUID0gJ3MnO1xyXG5YUGF0aFBhcnNlci5SRURVQ0UgPSAncic7XHJcblhQYXRoUGFyc2VyLkFDQ0VQVCA9ICdhJztcclxuXHJcblhQYXRoUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHMpIHtcclxuXHR2YXIgdHlwZXM7XHJcblx0dmFyIHZhbHVlcztcclxuXHR2YXIgcmVzID0gdGhpcy50b2tlbml6ZShzKTtcclxuXHRpZiAocmVzID09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9XHJcblx0dHlwZXMgPSByZXNbMF07XHJcblx0dmFsdWVzID0gcmVzWzFdO1xyXG5cdHZhciB0b2tlblBvcyA9IDA7XHJcblx0dmFyIHN0YXRlID0gW107XHJcblx0dmFyIHRva2VuVHlwZSA9IFtdO1xyXG5cdHZhciB0b2tlblZhbHVlID0gW107XHJcblx0dmFyIHM7XHJcblx0dmFyIGE7XHJcblx0dmFyIHQ7XHJcblxyXG5cdHN0YXRlLnB1c2goMCk7XHJcblx0dG9rZW5UeXBlLnB1c2goMSk7XHJcblx0dG9rZW5WYWx1ZS5wdXNoKFwiX1NcIik7XHJcblxyXG5cdGEgPSB0eXBlc1t0b2tlblBvc107XHJcblx0dCA9IHZhbHVlc1t0b2tlblBvcysrXTtcclxuXHR3aGlsZSAoMSkge1xyXG5cdFx0cyA9IHN0YXRlW3N0YXRlLmxlbmd0aCAtIDFdO1xyXG5cdFx0c3dpdGNoIChYUGF0aFBhcnNlci5hY3Rpb25UYWJsZVtzXS5jaGFyQXQoYSAtIDEpKSB7XHJcblx0XHRcdGNhc2UgWFBhdGhQYXJzZXIuU0hJRlQ6XHJcblx0XHRcdFx0dG9rZW5UeXBlLnB1c2goLWEpO1xyXG5cdFx0XHRcdHRva2VuVmFsdWUucHVzaCh0KTtcclxuXHRcdFx0XHRzdGF0ZS5wdXNoKFhQYXRoUGFyc2VyLmFjdGlvblRhYmxlTnVtYmVyW3NdLmNoYXJDb2RlQXQoYSAtIDEpIC0gMzIpO1xyXG5cdFx0XHRcdGEgPSB0eXBlc1t0b2tlblBvc107XHJcblx0XHRcdFx0dCA9IHZhbHVlc1t0b2tlblBvcysrXTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBYUGF0aFBhcnNlci5SRURVQ0U6XHJcblx0XHRcdFx0dmFyIG51bSA9IFhQYXRoUGFyc2VyLnByb2R1Y3Rpb25zW1hQYXRoUGFyc2VyLmFjdGlvblRhYmxlTnVtYmVyW3NdLmNoYXJDb2RlQXQoYSAtIDEpIC0gMzJdWzFdO1xyXG5cdFx0XHRcdHZhciByaHMgPSBbXTtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XHJcblx0XHRcdFx0XHR0b2tlblR5cGUucG9wKCk7XHJcblx0XHRcdFx0XHRyaHMudW5zaGlmdCh0b2tlblZhbHVlLnBvcCgpKTtcclxuXHRcdFx0XHRcdHN0YXRlLnBvcCgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgc18gPSBzdGF0ZVtzdGF0ZS5sZW5ndGggLSAxXTtcclxuXHRcdFx0XHR0b2tlblR5cGUucHVzaChYUGF0aFBhcnNlci5wcm9kdWN0aW9uc1tYUGF0aFBhcnNlci5hY3Rpb25UYWJsZU51bWJlcltzXS5jaGFyQ29kZUF0KGEgLSAxKSAtIDMyXVswXSk7XHJcblx0XHRcdFx0aWYgKHRoaXMucmVkdWNlQWN0aW9uc1tYUGF0aFBhcnNlci5hY3Rpb25UYWJsZU51bWJlcltzXS5jaGFyQ29kZUF0KGEgLSAxKSAtIDMyXSA9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdHRva2VuVmFsdWUucHVzaChyaHNbMF0pO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0b2tlblZhbHVlLnB1c2godGhpcy5yZWR1Y2VBY3Rpb25zW1hQYXRoUGFyc2VyLmFjdGlvblRhYmxlTnVtYmVyW3NdLmNoYXJDb2RlQXQoYSAtIDEpIC0gMzJdKHJocykpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRzdGF0ZS5wdXNoKFhQYXRoUGFyc2VyLmdvdG9UYWJsZVtzX10uY2hhckNvZGVBdChYUGF0aFBhcnNlci5wcm9kdWN0aW9uc1tYUGF0aFBhcnNlci5hY3Rpb25UYWJsZU51bWJlcltzXS5jaGFyQ29kZUF0KGEgLSAxKSAtIDMyXVswXSAtIDIpIC0gMzMpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFhQYXRoUGFyc2VyLkFDQ0VQVDpcclxuXHRcdFx0XHRyZXR1cm4gbmV3IFhQYXRoKHRva2VuVmFsdWUucG9wKCkpO1xyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlhQYXRoIHBhcnNlIGVycm9yXCIpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbi8vIFhQYXRoIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuWFBhdGgucHJvdG90eXBlID0gbmV3IE9iamVjdCgpO1xyXG5YUGF0aC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBYUGF0aDtcclxuWFBhdGguc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBYUGF0aChlKSB7XHJcblx0dGhpcy5leHByZXNzaW9uID0gZTtcclxufVxyXG5cclxuWFBhdGgucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuZXhwcmVzc2lvbi50b1N0cmluZygpO1xyXG59O1xyXG5cclxuWFBhdGgucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdGMuY29udGV4dE5vZGUgPSBjLmV4cHJlc3Npb25Db250ZXh0Tm9kZTtcclxuXHRjLmNvbnRleHRTaXplID0gMTtcclxuXHRjLmNvbnRleHRQb3NpdGlvbiA9IDE7XHJcblx0Yy5jYXNlSW5zZW5zaXRpdmUgPSBmYWxzZTtcclxuXHRpZiAoYy5jb250ZXh0Tm9kZSAhPSBudWxsKSB7XHJcblx0XHR2YXIgZG9jID0gYy5jb250ZXh0Tm9kZTtcclxuXHRcdGlmIChkb2Mubm9kZVR5cGUgIT0gOSAvKk5vZGUuRE9DVU1FTlRfTk9ERSovKSB7XHJcblx0XHRcdGRvYyA9IGRvYy5vd25lckRvY3VtZW50O1xyXG5cdFx0fVxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Yy5jYXNlSW5zZW5zaXRpdmUgPSBkb2MuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcIkhUTUxcIiwgXCIyLjBcIik7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdGMuY2FzZUluc2Vuc2l0aXZlID0gdHJ1ZTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZShjKTtcclxufTtcclxuXHJcblhQYXRoLlhNTF9OQU1FU1BBQ0VfVVJJID0gXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIjtcclxuWFBhdGguWE1MTlNfTkFNRVNQQUNFX1VSSSA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIjtcclxuXHJcbi8vIEV4cHJlc3Npb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuRXhwcmVzc2lvbi5wcm90b3R5cGUgPSBuZXcgT2JqZWN0KCk7XHJcbkV4cHJlc3Npb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXhwcmVzc2lvbjtcclxuRXhwcmVzc2lvbi5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIEV4cHJlc3Npb24oKSB7XHJcbn1cclxuXHJcbkV4cHJlc3Npb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcclxufTtcclxuXHJcbkV4cHJlc3Npb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiPEV4cHJlc3Npb24+XCI7XHJcbn07XHJcblxyXG5FeHByZXNzaW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZXZhbHVhdGUgZXhwcmVzc2lvbi5cIik7XHJcbn07XHJcblxyXG4vLyBVbmFyeU9wZXJhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblVuYXJ5T3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBFeHByZXNzaW9uKCk7XHJcblVuYXJ5T3BlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVuYXJ5T3BlcmF0aW9uO1xyXG5VbmFyeU9wZXJhdGlvbi5zdXBlcmNsYXNzID0gRXhwcmVzc2lvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBVbmFyeU9wZXJhdGlvbihyaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChyaHMpO1xyXG5cdH1cclxufVxyXG5cclxuVW5hcnlPcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihyaHMpIHtcclxuXHR0aGlzLnJocyA9IHJocztcclxufTtcclxuXHJcbi8vIFVuYXJ5TWludXNPcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuVW5hcnlNaW51c09wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgVW5hcnlPcGVyYXRpb24oKTtcclxuVW5hcnlNaW51c09wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVbmFyeU1pbnVzT3BlcmF0aW9uO1xyXG5VbmFyeU1pbnVzT3BlcmF0aW9uLnN1cGVyY2xhc3MgPSBVbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBVbmFyeU1pbnVzT3BlcmF0aW9uKHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5VbmFyeU1pbnVzT3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0VW5hcnlNaW51c09wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCByaHMpO1xyXG59O1xyXG5cclxuVW5hcnlNaW51c09wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXMucmhzLmV2YWx1YXRlKGMpLm51bWJlcigpLm5lZ2F0ZSgpO1xyXG59O1xyXG5cclxuVW5hcnlNaW51c09wZXJhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCItXCIgKyB0aGlzLnJocy50b1N0cmluZygpO1xyXG59O1xyXG5cclxuLy8gQmluYXJ5T3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5CaW5hcnlPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEV4cHJlc3Npb24oKTtcclxuQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJpbmFyeU9wZXJhdGlvbjtcclxuQmluYXJ5T3BlcmF0aW9uLnN1cGVyY2xhc3MgPSBFeHByZXNzaW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIEJpbmFyeU9wZXJhdGlvbihsaHMsIHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGxocywgcmhzKTtcclxuXHR9XHJcbn1cclxuXHJcbkJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XHJcblx0dGhpcy5saHMgPSBsaHM7XHJcblx0dGhpcy5yaHMgPSByaHM7XHJcbn07XHJcblxyXG4vLyBPck9wZXJhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbk9yT3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBCaW5hcnlPcGVyYXRpb24oKTtcclxuT3JPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT3JPcGVyYXRpb247XHJcbk9yT3BlcmF0aW9uLnN1cGVyY2xhc3MgPSBCaW5hcnlPcGVyYXRpb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gT3JPcGVyYXRpb24obGhzLCByaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChsaHMsIHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5Pck9wZXJhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XHJcblx0T3JPcGVyYXRpb24uc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbGhzLCByaHMpO1xyXG59O1xyXG5cclxuT3JPcGVyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiKFwiICsgdGhpcy5saHMudG9TdHJpbmcoKSArIFwiIG9yIFwiICsgdGhpcy5yaHMudG9TdHJpbmcoKSArIFwiKVwiO1xyXG59O1xyXG5cclxuT3JPcGVyYXRpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHZhciBiID0gdGhpcy5saHMuZXZhbHVhdGUoYykuYm9vbCgpO1xyXG5cdGlmIChiLmJvb2xlYW5WYWx1ZSgpKSB7XHJcblx0XHRyZXR1cm4gYjtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMucmhzLmV2YWx1YXRlKGMpLmJvb2woKTtcclxufTtcclxuXHJcbi8vIEFuZE9wZXJhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuQW5kT3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBCaW5hcnlPcGVyYXRpb24oKTtcclxuQW5kT3BlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFuZE9wZXJhdGlvbjtcclxuQW5kT3BlcmF0aW9uLnN1cGVyY2xhc3MgPSBCaW5hcnlPcGVyYXRpb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gQW5kT3BlcmF0aW9uKGxocywgcmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQobGhzLCByaHMpO1xyXG5cdH1cclxufVxyXG5cclxuQW5kT3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHRBbmRPcGVyYXRpb24uc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbGhzLCByaHMpO1xyXG59O1xyXG5cclxuQW5kT3BlcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIihcIiArIHRoaXMubGhzLnRvU3RyaW5nKCkgKyBcIiBhbmQgXCIgKyB0aGlzLnJocy50b1N0cmluZygpICsgXCIpXCI7XHJcbn07XHJcblxyXG5BbmRPcGVyYXRpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHZhciBiID0gdGhpcy5saHMuZXZhbHVhdGUoYykuYm9vbCgpO1xyXG5cdGlmICghYi5ib29sZWFuVmFsdWUoKSkge1xyXG5cdFx0cmV0dXJuIGI7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLnJocy5ldmFsdWF0ZShjKS5ib29sKCk7XHJcbn07XHJcblxyXG4vLyBFcXVhbHNPcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbkVxdWFsc09wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgQmluYXJ5T3BlcmF0aW9uKCk7XHJcbkVxdWFsc09wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFcXVhbHNPcGVyYXRpb247XHJcbkVxdWFsc09wZXJhdGlvbi5zdXBlcmNsYXNzID0gQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIEVxdWFsc09wZXJhdGlvbihsaHMsIHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGxocywgcmhzKTtcclxuXHR9XHJcbn1cclxuXHJcbkVxdWFsc09wZXJhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XHJcblx0RXF1YWxzT3BlcmF0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIGxocywgcmhzKTtcclxufTtcclxuXHJcbkVxdWFsc09wZXJhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCIoXCIgKyB0aGlzLmxocy50b1N0cmluZygpICsgXCIgPSBcIiArIHRoaXMucmhzLnRvU3RyaW5nKCkgKyBcIilcIjtcclxufTtcclxuXHJcbkVxdWFsc09wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXMubGhzLmV2YWx1YXRlKGMpLmVxdWFscyh0aGlzLnJocy5ldmFsdWF0ZShjKSk7XHJcbn07XHJcblxyXG4vLyBOb3RFcXVhbE9wZXJhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbk5vdEVxdWFsT3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBCaW5hcnlPcGVyYXRpb24oKTtcclxuTm90RXF1YWxPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTm90RXF1YWxPcGVyYXRpb247XHJcbk5vdEVxdWFsT3BlcmF0aW9uLnN1cGVyY2xhc3MgPSBCaW5hcnlPcGVyYXRpb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gTm90RXF1YWxPcGVyYXRpb24obGhzLCByaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChsaHMsIHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5Ob3RFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XHJcblx0Tm90RXF1YWxPcGVyYXRpb24uc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbGhzLCByaHMpO1xyXG59O1xyXG5cclxuTm90RXF1YWxPcGVyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiKFwiICsgdGhpcy5saHMudG9TdHJpbmcoKSArIFwiICE9IFwiICsgdGhpcy5yaHMudG9TdHJpbmcoKSArIFwiKVwiO1xyXG59O1xyXG5cclxuTm90RXF1YWxPcGVyYXRpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiB0aGlzLmxocy5ldmFsdWF0ZShjKS5ub3RlcXVhbCh0aGlzLnJocy5ldmFsdWF0ZShjKSk7XHJcbn07XHJcblxyXG4vLyBMZXNzVGhhbk9wZXJhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbkxlc3NUaGFuT3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBCaW5hcnlPcGVyYXRpb24oKTtcclxuTGVzc1RoYW5PcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGVzc1RoYW5PcGVyYXRpb247XHJcbkxlc3NUaGFuT3BlcmF0aW9uLnN1cGVyY2xhc3MgPSBCaW5hcnlPcGVyYXRpb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gTGVzc1RoYW5PcGVyYXRpb24obGhzLCByaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChsaHMsIHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5MZXNzVGhhbk9wZXJhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XHJcblx0TGVzc1RoYW5PcGVyYXRpb24uc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbGhzLCByaHMpO1xyXG59O1xyXG5cclxuTGVzc1RoYW5PcGVyYXRpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiB0aGlzLmxocy5ldmFsdWF0ZShjKS5sZXNzdGhhbih0aGlzLnJocy5ldmFsdWF0ZShjKSk7XHJcbn07XHJcblxyXG5MZXNzVGhhbk9wZXJhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCIoXCIgKyB0aGlzLmxocy50b1N0cmluZygpICsgXCIgPCBcIiArIHRoaXMucmhzLnRvU3RyaW5nKCkgKyBcIilcIjtcclxufTtcclxuXHJcbi8vIEdyZWF0ZXJUaGFuT3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuR3JlYXRlclRoYW5PcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEJpbmFyeU9wZXJhdGlvbigpO1xyXG5HcmVhdGVyVGhhbk9wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHcmVhdGVyVGhhbk9wZXJhdGlvbjtcclxuR3JlYXRlclRoYW5PcGVyYXRpb24uc3VwZXJjbGFzcyA9IEJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBHcmVhdGVyVGhhbk9wZXJhdGlvbihsaHMsIHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGxocywgcmhzKTtcclxuXHR9XHJcbn1cclxuXHJcbkdyZWF0ZXJUaGFuT3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHRHcmVhdGVyVGhhbk9wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBsaHMsIHJocyk7XHJcbn07XHJcblxyXG5HcmVhdGVyVGhhbk9wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXMubGhzLmV2YWx1YXRlKGMpLmdyZWF0ZXJ0aGFuKHRoaXMucmhzLmV2YWx1YXRlKGMpKTtcclxufTtcclxuXHJcbkdyZWF0ZXJUaGFuT3BlcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIihcIiArIHRoaXMubGhzLnRvU3RyaW5nKCkgKyBcIiA+IFwiICsgdGhpcy5yaHMudG9TdHJpbmcoKSArIFwiKVwiO1xyXG59O1xyXG5cclxuLy8gTGVzc1RoYW5PckVxdWFsT3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5MZXNzVGhhbk9yRXF1YWxPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEJpbmFyeU9wZXJhdGlvbigpO1xyXG5MZXNzVGhhbk9yRXF1YWxPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGVzc1RoYW5PckVxdWFsT3BlcmF0aW9uO1xyXG5MZXNzVGhhbk9yRXF1YWxPcGVyYXRpb24uc3VwZXJjbGFzcyA9IEJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBMZXNzVGhhbk9yRXF1YWxPcGVyYXRpb24obGhzLCByaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChsaHMsIHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5MZXNzVGhhbk9yRXF1YWxPcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihsaHMsIHJocykge1xyXG5cdExlc3NUaGFuT3JFcXVhbE9wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBsaHMsIHJocyk7XHJcbn07XHJcblxyXG5MZXNzVGhhbk9yRXF1YWxPcGVyYXRpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiB0aGlzLmxocy5ldmFsdWF0ZShjKS5sZXNzdGhhbm9yZXF1YWwodGhpcy5yaHMuZXZhbHVhdGUoYykpO1xyXG59O1xyXG5cclxuTGVzc1RoYW5PckVxdWFsT3BlcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIihcIiArIHRoaXMubGhzLnRvU3RyaW5nKCkgKyBcIiA8PSBcIiArIHRoaXMucmhzLnRvU3RyaW5nKCkgKyBcIilcIjtcclxufTtcclxuXHJcbi8vIEdyZWF0ZXJUaGFuT3JFcXVhbE9wZXJhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuR3JlYXRlclRoYW5PckVxdWFsT3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBCaW5hcnlPcGVyYXRpb24oKTtcclxuR3JlYXRlclRoYW5PckVxdWFsT3BlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdyZWF0ZXJUaGFuT3JFcXVhbE9wZXJhdGlvbjtcclxuR3JlYXRlclRoYW5PckVxdWFsT3BlcmF0aW9uLnN1cGVyY2xhc3MgPSBCaW5hcnlPcGVyYXRpb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gR3JlYXRlclRoYW5PckVxdWFsT3BlcmF0aW9uKGxocywgcmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQobGhzLCByaHMpO1xyXG5cdH1cclxufVxyXG5cclxuR3JlYXRlclRoYW5PckVxdWFsT3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHRHcmVhdGVyVGhhbk9yRXF1YWxPcGVyYXRpb24uc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbGhzLCByaHMpO1xyXG59O1xyXG5cclxuR3JlYXRlclRoYW5PckVxdWFsT3BlcmF0aW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcy5saHMuZXZhbHVhdGUoYykuZ3JlYXRlcnRoYW5vcmVxdWFsKHRoaXMucmhzLmV2YWx1YXRlKGMpKTtcclxufTtcclxuXHJcbkdyZWF0ZXJUaGFuT3JFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCIoXCIgKyB0aGlzLmxocy50b1N0cmluZygpICsgXCIgPj0gXCIgKyB0aGlzLnJocy50b1N0cmluZygpICsgXCIpXCI7XHJcbn07XHJcblxyXG4vLyBQbHVzT3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblBsdXNPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEJpbmFyeU9wZXJhdGlvbigpO1xyXG5QbHVzT3BlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsdXNPcGVyYXRpb247XHJcblBsdXNPcGVyYXRpb24uc3VwZXJjbGFzcyA9IEJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBQbHVzT3BlcmF0aW9uKGxocywgcmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQobGhzLCByaHMpO1xyXG5cdH1cclxufVxyXG5cclxuUGx1c09wZXJhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XHJcblx0UGx1c09wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBsaHMsIHJocyk7XHJcbn07XHJcblxyXG5QbHVzT3BlcmF0aW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcy5saHMuZXZhbHVhdGUoYykubnVtYmVyKCkucGx1cyh0aGlzLnJocy5ldmFsdWF0ZShjKS5udW1iZXIoKSk7XHJcbn07XHJcblxyXG5QbHVzT3BlcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIihcIiArIHRoaXMubGhzLnRvU3RyaW5nKCkgKyBcIiArIFwiICsgdGhpcy5yaHMudG9TdHJpbmcoKSArIFwiKVwiO1xyXG59O1xyXG5cclxuLy8gTWludXNPcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5NaW51c09wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgQmluYXJ5T3BlcmF0aW9uKCk7XHJcbk1pbnVzT3BlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1pbnVzT3BlcmF0aW9uO1xyXG5NaW51c09wZXJhdGlvbi5zdXBlcmNsYXNzID0gQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIE1pbnVzT3BlcmF0aW9uKGxocywgcmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQobGhzLCByaHMpO1xyXG5cdH1cclxufVxyXG5cclxuTWludXNPcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihsaHMsIHJocykge1xyXG5cdE1pbnVzT3BlcmF0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIGxocywgcmhzKTtcclxufTtcclxuXHJcbk1pbnVzT3BlcmF0aW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcy5saHMuZXZhbHVhdGUoYykubnVtYmVyKCkubWludXModGhpcy5yaHMuZXZhbHVhdGUoYykubnVtYmVyKCkpO1xyXG59O1xyXG5cclxuTWludXNPcGVyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiKFwiICsgdGhpcy5saHMudG9TdHJpbmcoKSArIFwiIC0gXCIgKyB0aGlzLnJocy50b1N0cmluZygpICsgXCIpXCI7XHJcbn07XHJcblxyXG4vLyBNdWx0aXBseU9wZXJhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbk11bHRpcGx5T3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBCaW5hcnlPcGVyYXRpb24oKTtcclxuTXVsdGlwbHlPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTXVsdGlwbHlPcGVyYXRpb247XHJcbk11bHRpcGx5T3BlcmF0aW9uLnN1cGVyY2xhc3MgPSBCaW5hcnlPcGVyYXRpb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gTXVsdGlwbHlPcGVyYXRpb24obGhzLCByaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChsaHMsIHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5NdWx0aXBseU9wZXJhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XHJcblx0TXVsdGlwbHlPcGVyYXRpb24uc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbGhzLCByaHMpO1xyXG59O1xyXG5cclxuTXVsdGlwbHlPcGVyYXRpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiB0aGlzLmxocy5ldmFsdWF0ZShjKS5udW1iZXIoKS5tdWx0aXBseSh0aGlzLnJocy5ldmFsdWF0ZShjKS5udW1iZXIoKSk7XHJcbn07XHJcblxyXG5NdWx0aXBseU9wZXJhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCIoXCIgKyB0aGlzLmxocy50b1N0cmluZygpICsgXCIgKiBcIiArIHRoaXMucmhzLnRvU3RyaW5nKCkgKyBcIilcIjtcclxufTtcclxuXHJcbi8vIERpdk9wZXJhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuRGl2T3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBCaW5hcnlPcGVyYXRpb24oKTtcclxuRGl2T3BlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERpdk9wZXJhdGlvbjtcclxuRGl2T3BlcmF0aW9uLnN1cGVyY2xhc3MgPSBCaW5hcnlPcGVyYXRpb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gRGl2T3BlcmF0aW9uKGxocywgcmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQobGhzLCByaHMpO1xyXG5cdH1cclxufVxyXG5cclxuRGl2T3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHREaXZPcGVyYXRpb24uc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbGhzLCByaHMpO1xyXG59O1xyXG5cclxuRGl2T3BlcmF0aW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcy5saHMuZXZhbHVhdGUoYykubnVtYmVyKCkuZGl2KHRoaXMucmhzLmV2YWx1YXRlKGMpLm51bWJlcigpKTtcclxufTtcclxuXHJcbkRpdk9wZXJhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCIoXCIgKyB0aGlzLmxocy50b1N0cmluZygpICsgXCIgZGl2IFwiICsgdGhpcy5yaHMudG9TdHJpbmcoKSArIFwiKVwiO1xyXG59O1xyXG5cclxuLy8gTW9kT3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5Nb2RPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEJpbmFyeU9wZXJhdGlvbigpO1xyXG5Nb2RPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW9kT3BlcmF0aW9uO1xyXG5Nb2RPcGVyYXRpb24uc3VwZXJjbGFzcyA9IEJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBNb2RPcGVyYXRpb24obGhzLCByaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChsaHMsIHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5Nb2RPcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihsaHMsIHJocykge1xyXG5cdE1vZE9wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBsaHMsIHJocyk7XHJcbn07XHJcblxyXG5Nb2RPcGVyYXRpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiB0aGlzLmxocy5ldmFsdWF0ZShjKS5udW1iZXIoKS5tb2QodGhpcy5yaHMuZXZhbHVhdGUoYykubnVtYmVyKCkpO1xyXG59O1xyXG5cclxuTW9kT3BlcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIihcIiArIHRoaXMubGhzLnRvU3RyaW5nKCkgKyBcIiBtb2QgXCIgKyB0aGlzLnJocy50b1N0cmluZygpICsgXCIpXCI7XHJcbn07XHJcblxyXG4vLyBCYXJPcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbkJhck9wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgQmluYXJ5T3BlcmF0aW9uKCk7XHJcbkJhck9wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCYXJPcGVyYXRpb247XHJcbkJhck9wZXJhdGlvbi5zdXBlcmNsYXNzID0gQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIEJhck9wZXJhdGlvbihsaHMsIHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGxocywgcmhzKTtcclxuXHR9XHJcbn1cclxuXHJcbkJhck9wZXJhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XHJcblx0QmFyT3BlcmF0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIGxocywgcmhzKTtcclxufTtcclxuXHJcbkJhck9wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXMubGhzLmV2YWx1YXRlKGMpLm5vZGVzZXQoKS51bmlvbih0aGlzLnJocy5ldmFsdWF0ZShjKS5ub2Rlc2V0KCkpO1xyXG59O1xyXG5cclxuQmFyT3BlcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmxocy50b1N0cmluZygpICsgXCIgfCBcIiArIHRoaXMucmhzLnRvU3RyaW5nKCk7XHJcbn07XHJcblxyXG4vLyBQYXRoRXhwciAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblBhdGhFeHByLnByb3RvdHlwZSA9IG5ldyBFeHByZXNzaW9uKCk7XHJcblBhdGhFeHByLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhdGhFeHByO1xyXG5QYXRoRXhwci5zdXBlcmNsYXNzID0gRXhwcmVzc2lvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBQYXRoRXhwcihmaWx0ZXIsIGZpbHRlclByZWRzLCBsb2NwYXRoKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQoZmlsdGVyLCBmaWx0ZXJQcmVkcywgbG9jcGF0aCk7XHJcblx0fVxyXG59XHJcblxyXG5QYXRoRXhwci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGZpbHRlciwgZmlsdGVyUHJlZHMsIGxvY3BhdGgpIHtcclxuXHRQYXRoRXhwci5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzKTtcclxuXHR0aGlzLmZpbHRlciA9IGZpbHRlcjtcclxuXHR0aGlzLmZpbHRlclByZWRpY2F0ZXMgPSBmaWx0ZXJQcmVkcztcclxuXHR0aGlzLmxvY2F0aW9uUGF0aCA9IGxvY3BhdGg7XHJcbn07XHJcblxyXG5QYXRoRXhwci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0dmFyIG5vZGVzO1xyXG5cdHZhciB4cGMgPSBuZXcgWFBhdGhDb250ZXh0KCk7XHJcblx0eHBjLnZhcmlhYmxlUmVzb2x2ZXIgPSBjLnZhcmlhYmxlUmVzb2x2ZXI7XHJcblx0eHBjLmZ1bmN0aW9uUmVzb2x2ZXIgPSBjLmZ1bmN0aW9uUmVzb2x2ZXI7XHJcblx0eHBjLm5hbWVzcGFjZVJlc29sdmVyID0gYy5uYW1lc3BhY2VSZXNvbHZlcjtcclxuXHR4cGMuZXhwcmVzc2lvbkNvbnRleHROb2RlID0gYy5leHByZXNzaW9uQ29udGV4dE5vZGU7XHJcblx0eHBjLnZpcnR1YWxSb290ID0gYy52aXJ0dWFsUm9vdDtcclxuXHR4cGMuY2FzZUluc2Vuc2l0aXZlID0gYy5jYXNlSW5zZW5zaXRpdmU7XHJcblx0aWYgKHRoaXMuZmlsdGVyID09IG51bGwpIHtcclxuXHRcdG5vZGVzID0gWyBjLmNvbnRleHROb2RlIF07XHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBucyA9IHRoaXMuZmlsdGVyLmV2YWx1YXRlKGMpO1xyXG5cdFx0aWYgKCFVdGlsaXRpZXMuaW5zdGFuY2Vfb2YobnMsIFhOb2RlU2V0KSkge1xyXG5cdFx0XHRpZiAodGhpcy5maWx0ZXJQcmVkaWNhdGVzICE9IG51bGwgJiYgdGhpcy5maWx0ZXJQcmVkaWNhdGVzLmxlbmd0aCA+IDAgfHwgdGhpcy5sb2NhdGlvblBhdGggIT0gbnVsbCkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhdGggZXhwcmVzc2lvbiBmaWx0ZXIgbXVzdCBldmFsdWF0ZSB0byBhIG5vZHNldCBpZiBwcmVkaWNhdGVzIG9yIGxvY2F0aW9uIHBhdGggYXJlIHVzZWRcIik7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG5zO1xyXG5cdFx0fVxyXG5cdFx0bm9kZXMgPSBucy50b0FycmF5KCk7XHJcblx0XHRpZiAodGhpcy5maWx0ZXJQcmVkaWNhdGVzICE9IG51bGwpIHtcclxuXHRcdFx0Ly8gYXBwbHkgZWFjaCBvZiB0aGUgcHJlZGljYXRlcyBpbiB0dXJuXHJcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5maWx0ZXJQcmVkaWNhdGVzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0dmFyIHByZWQgPSB0aGlzLmZpbHRlclByZWRpY2F0ZXNbal07XHJcblx0XHRcdFx0dmFyIG5ld05vZGVzID0gW107XHJcblx0XHRcdFx0eHBjLmNvbnRleHRTaXplID0gbm9kZXMubGVuZ3RoO1xyXG5cdFx0XHRcdGZvciAoeHBjLmNvbnRleHRQb3NpdGlvbiA9IDE7IHhwYy5jb250ZXh0UG9zaXRpb24gPD0geHBjLmNvbnRleHRTaXplOyB4cGMuY29udGV4dFBvc2l0aW9uKyspIHtcclxuXHRcdFx0XHRcdHhwYy5jb250ZXh0Tm9kZSA9IG5vZGVzW3hwYy5jb250ZXh0UG9zaXRpb24gLSAxXTtcclxuXHRcdFx0XHRcdGlmICh0aGlzLnByZWRpY2F0ZU1hdGNoZXMocHJlZCwgeHBjKSkge1xyXG5cdFx0XHRcdFx0XHRuZXdOb2Rlcy5wdXNoKHhwYy5jb250ZXh0Tm9kZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG5vZGVzID0gbmV3Tm9kZXM7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKHRoaXMubG9jYXRpb25QYXRoICE9IG51bGwpIHtcclxuXHRcdGlmICh0aGlzLmxvY2F0aW9uUGF0aC5hYnNvbHV0ZSkge1xyXG5cdFx0XHRpZiAobm9kZXNbMF0ubm9kZVR5cGUgIT0gOSAvKk5vZGUuRE9DVU1FTlRfTk9ERSovKSB7XHJcblx0XHRcdFx0aWYgKHhwYy52aXJ0dWFsUm9vdCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRub2RlcyA9IFsgeHBjLnZpcnR1YWxSb290IF07XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmIChub2Rlc1swXS5vd25lckRvY3VtZW50ID09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0Ly8gSUUgNS41IGRvZXNuJ3QgaGF2ZSBvd25lckRvY3VtZW50P1xyXG5cdFx0XHRcdFx0XHR2YXIgbiA9IG5vZGVzWzBdO1xyXG5cdFx0XHRcdFx0XHR3aGlsZSAobi5wYXJlbnROb2RlICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRuID0gbi5wYXJlbnROb2RlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdG5vZGVzID0gWyBuIF07XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRub2RlcyA9IFsgbm9kZXNbMF0ub3duZXJEb2N1bWVudCBdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRub2RlcyA9IFsgbm9kZXNbMF0gXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxvY2F0aW9uUGF0aC5zdGVwcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgc3RlcCA9IHRoaXMubG9jYXRpb25QYXRoLnN0ZXBzW2ldO1xyXG5cdFx0XHR2YXIgbmV3Tm9kZXMgPSBbXTtcclxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHhwYy5jb250ZXh0Tm9kZSA9IG5vZGVzW2pdO1xyXG5cdFx0XHRcdHN3aXRjaCAoc3RlcC5heGlzKSB7XHJcblx0XHRcdFx0XHRjYXNlIFN0ZXAuQU5DRVNUT1I6XHJcblx0XHRcdFx0XHRcdC8vIGxvb2sgYXQgYWxsIHRoZSBhbmNlc3RvciBub2Rlc1xyXG5cdFx0XHRcdFx0XHRpZiAoeHBjLmNvbnRleHROb2RlID09PSB4cGMudmlydHVhbFJvb3QpIHtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR2YXIgbTtcclxuXHRcdFx0XHRcdFx0aWYgKHhwYy5jb250ZXh0Tm9kZS5ub2RlVHlwZSA9PSAyIC8qTm9kZS5BVFRSSUJVVEVfTk9ERSovKSB7XHJcblx0XHRcdFx0XHRcdFx0bSA9IHRoaXMuZ2V0T3duZXJFbGVtZW50KHhwYy5jb250ZXh0Tm9kZSk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0bSA9IHhwYy5jb250ZXh0Tm9kZS5wYXJlbnROb2RlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHdoaWxlIChtICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoc3RlcC5ub2RlVGVzdC5tYXRjaGVzKG0sIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2gobSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGlmIChtID09PSB4cGMudmlydHVhbFJvb3QpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRtID0gbS5wYXJlbnROb2RlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgU3RlcC5BTkNFU1RPUk9SU0VMRjpcclxuXHRcdFx0XHRcdFx0Ly8gbG9vayBhdCBhbGwgdGhlIGFuY2VzdG9yIG5vZGVzIGFuZCB0aGUgY3VycmVudCBub2RlXHJcblx0XHRcdFx0XHRcdGZvciAodmFyIG0gPSB4cGMuY29udGV4dE5vZGU7IG0gIT0gbnVsbDsgbSA9IG0ubm9kZVR5cGUgPT0gMiAvKk5vZGUuQVRUUklCVVRFX05PREUqLyA/IHRoaXMuZ2V0T3duZXJFbGVtZW50KG0pIDogbS5wYXJlbnROb2RlKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKHN0ZXAubm9kZVRlc3QubWF0Y2hlcyhtLCB4cGMpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRuZXdOb2Rlcy5wdXNoKG0pO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRpZiAobSA9PT0geHBjLnZpcnR1YWxSb290KSB7XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBTdGVwLkFUVFJJQlVURTpcclxuXHRcdFx0XHRcdFx0Ly8gbG9vayBhdCB0aGUgYXR0cmlidXRlc1xyXG5cdFx0XHRcdFx0XHR2YXIgbm5tID0geHBjLmNvbnRleHROb2RlLmF0dHJpYnV0ZXM7XHJcblx0XHRcdFx0XHRcdGlmIChubm0gIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgbm5tLmxlbmd0aDsgaysrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgbSA9IG5ubS5pdGVtKGspO1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHN0ZXAubm9kZVRlc3QubWF0Y2hlcyhtLCB4cGMpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2gobSk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgU3RlcC5DSElMRDpcclxuXHRcdFx0XHRcdFx0Ly8gbG9vayBhdCBhbGwgY2hpbGQgZWxlbWVudHNcclxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgbSA9IHhwYy5jb250ZXh0Tm9kZS5maXJzdENoaWxkOyBtICE9IG51bGw7IG0gPSBtLm5leHRTaWJsaW5nKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKHN0ZXAubm9kZVRlc3QubWF0Y2hlcyhtLCB4cGMpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRuZXdOb2Rlcy5wdXNoKG0pO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFN0ZXAuREVTQ0VOREFOVDpcclxuXHRcdFx0XHRcdFx0Ly8gbG9vayBhdCBhbGwgZGVzY2VuZGFudCBub2Rlc1xyXG5cdFx0XHRcdFx0XHR2YXIgc3QgPSBbIHhwYy5jb250ZXh0Tm9kZS5maXJzdENoaWxkIF07XHJcblx0XHRcdFx0XHRcdHdoaWxlIChzdC5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgbSA9IHN0LnBvcCgpOyBtICE9IG51bGw7ICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHN0ZXAubm9kZVRlc3QubWF0Y2hlcyhtLCB4cGMpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2gobSk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAobS5maXJzdENoaWxkICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0c3QucHVzaChtLm5leHRTaWJsaW5nKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bSA9IG0uZmlyc3RDaGlsZDtcclxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG0gPSBtLm5leHRTaWJsaW5nO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFN0ZXAuREVTQ0VOREFOVE9SU0VMRjpcclxuXHRcdFx0XHRcdFx0Ly8gbG9vayBhdCBzZWxmXHJcblx0XHRcdFx0XHRcdGlmIChzdGVwLm5vZGVUZXN0Lm1hdGNoZXMoeHBjLmNvbnRleHROb2RlLCB4cGMpKSB7XHJcblx0XHRcdFx0XHRcdFx0bmV3Tm9kZXMucHVzaCh4cGMuY29udGV4dE5vZGUpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdC8vIGxvb2sgYXQgYWxsIGRlc2NlbmRhbnQgbm9kZXNcclxuXHRcdFx0XHRcdFx0dmFyIHN0ID0gWyB4cGMuY29udGV4dE5vZGUuZmlyc3RDaGlsZCBdO1xyXG5cdFx0XHRcdFx0XHR3aGlsZSAoc3QubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIG0gPSBzdC5wb3AoKTsgbSAhPSBudWxsOyApIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmIChzdGVwLm5vZGVUZXN0Lm1hdGNoZXMobSwgeHBjKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdOb2Rlcy5wdXNoKG0pO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKG0uZmlyc3RDaGlsZCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHN0LnB1c2gobS5uZXh0U2libGluZyk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG0gPSBtLmZpcnN0Q2hpbGQ7XHJcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRtID0gbS5uZXh0U2libGluZztcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBTdGVwLkZPTExPV0lORzpcclxuXHRcdFx0XHRcdFx0aWYgKHhwYy5jb250ZXh0Tm9kZSA9PT0geHBjLnZpcnR1YWxSb290KSB7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0dmFyIHN0ID0gW107XHJcblx0XHRcdFx0XHRcdGlmICh4cGMuY29udGV4dE5vZGUuZmlyc3RDaGlsZCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0c3QudW5zaGlmdCh4cGMuY29udGV4dE5vZGUuZmlyc3RDaGlsZCk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0c3QudW5zaGlmdCh4cGMuY29udGV4dE5vZGUubmV4dFNpYmxpbmcpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGZvciAodmFyIG0gPSB4cGMuY29udGV4dE5vZGUucGFyZW50Tm9kZTsgbSAhPSBudWxsICYmIG0ubm9kZVR5cGUgIT0gOSAvKk5vZGUuRE9DVU1FTlRfTk9ERSovICYmIG0gIT09IHhwYy52aXJ0dWFsUm9vdDsgbSA9IG0ucGFyZW50Tm9kZSkge1xyXG5cdFx0XHRcdFx0XHRcdHN0LnVuc2hpZnQobS5uZXh0U2libGluZyk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0ZG8ge1xyXG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIG0gPSBzdC5wb3AoKTsgbSAhPSBudWxsOyApIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmIChzdGVwLm5vZGVUZXN0Lm1hdGNoZXMobSwgeHBjKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdOb2Rlcy5wdXNoKG0pO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKG0uZmlyc3RDaGlsZCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHN0LnB1c2gobS5uZXh0U2libGluZyk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG0gPSBtLmZpcnN0Q2hpbGQ7XHJcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRtID0gbS5uZXh0U2libGluZztcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0gd2hpbGUgKHN0Lmxlbmd0aCA+IDApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFN0ZXAuRk9MTE9XSU5HU0lCTElORzpcclxuXHRcdFx0XHRcdFx0aWYgKHhwYy5jb250ZXh0Tm9kZSA9PT0geHBjLnZpcnR1YWxSb290KSB7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgbSA9IHhwYy5jb250ZXh0Tm9kZS5uZXh0U2libGluZzsgbSAhPSBudWxsOyBtID0gbS5uZXh0U2libGluZykge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChzdGVwLm5vZGVUZXN0Lm1hdGNoZXMobSwgeHBjKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0bmV3Tm9kZXMucHVzaChtKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBTdGVwLk5BTUVTUEFDRTpcclxuXHRcdFx0XHRcdFx0dmFyIG4gPSB7fTtcclxuXHRcdFx0XHRcdFx0aWYgKHhwYy5jb250ZXh0Tm9kZS5ub2RlVHlwZSA9PSAxIC8qTm9kZS5FTEVNRU5UX05PREUqLykge1xyXG5cdFx0XHRcdFx0XHRcdG5bXCJ4bWxcIl0gPSBYUGF0aC5YTUxfTkFNRVNQQUNFX1VSSTtcclxuXHRcdFx0XHRcdFx0XHRuW1wieG1sbnNcIl0gPSBYUGF0aC5YTUxOU19OQU1FU1BBQ0VfVVJJO1xyXG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIG0gPSB4cGMuY29udGV4dE5vZGU7IG0gIT0gbnVsbCAmJiBtLm5vZGVUeXBlID09IDEgLypOb2RlLkVMRU1FTlRfTk9ERSovOyBtID0gbS5wYXJlbnROb2RlKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IG0uYXR0cmlidXRlcy5sZW5ndGg7IGsrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgYXR0ciA9IG0uYXR0cmlidXRlcy5pdGVtKGspO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgbm0gPSBTdHJpbmcoYXR0ci5uYW1lKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKG5tID09IFwieG1sbnNcIikge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChuW1wiXCJdID09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bltcIlwiXSA9IGF0dHIudmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKG5tLmxlbmd0aCA+IDYgJiYgbm0uc3Vic3RyaW5nKDAsIDYpID09IFwieG1sbnM6XCIpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgcHJlID0gbm0uc3Vic3RyaW5nKDYsIG5tLmxlbmd0aCk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKG5bcHJlXSA9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5bcHJlXSA9IGF0dHIudmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIHByZSBpbiBuKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgbnNuID0gbmV3IE5hbWVzcGFjZU5vZGUocHJlLCBuW3ByZV0sIHhwYy5jb250ZXh0Tm9kZSk7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoc3RlcC5ub2RlVGVzdC5tYXRjaGVzKG5zbiwgeHBjKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdOb2Rlcy5wdXNoKG5zbik7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgU3RlcC5QQVJFTlQ6XHJcblx0XHRcdFx0XHRcdG0gPSBudWxsO1xyXG5cdFx0XHRcdFx0XHRpZiAoeHBjLmNvbnRleHROb2RlICE9PSB4cGMudmlydHVhbFJvb3QpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoeHBjLmNvbnRleHROb2RlLm5vZGVUeXBlID09IDIgLypOb2RlLkFUVFJJQlVURV9OT0RFKi8pIHtcclxuXHRcdFx0XHRcdFx0XHRcdG0gPSB0aGlzLmdldE93bmVyRWxlbWVudCh4cGMuY29udGV4dE5vZGUpO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRtID0geHBjLmNvbnRleHROb2RlLnBhcmVudE5vZGU7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmIChtICE9IG51bGwgJiYgc3RlcC5ub2RlVGVzdC5tYXRjaGVzKG0sIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRuZXdOb2Rlcy5wdXNoKG0pO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgU3RlcC5QUkVDRURJTkc6XHJcblx0XHRcdFx0XHRcdHZhciBzdDtcclxuXHRcdFx0XHRcdFx0aWYgKHhwYy52aXJ0dWFsUm9vdCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0c3QgPSBbIHhwYy52aXJ0dWFsUm9vdCBdO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdHN0ID0geHBjLmNvbnRleHROb2RlLm5vZGVUeXBlID09IDkgLypOb2RlLkRPQ1VNRU5UX05PREUqL1xyXG5cdFx0XHRcdFx0XHRcdFx0PyBbIHhwYy5jb250ZXh0Tm9kZSBdXHJcblx0XHRcdFx0XHRcdFx0XHQ6IFsgeHBjLmNvbnRleHROb2RlLm93bmVyRG9jdW1lbnQgXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRvdXRlcjogd2hpbGUgKHN0Lmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBtID0gc3QucG9wKCk7IG0gIT0gbnVsbDsgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAobSA9PSB4cGMuY29udGV4dE5vZGUpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoc3RlcC5ub2RlVGVzdC5tYXRjaGVzKG0sIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3Tm9kZXMudW5zaGlmdChtKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdGlmIChtLmZpcnN0Q2hpbGQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRzdC5wdXNoKG0ubmV4dFNpYmxpbmcpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRtID0gbS5maXJzdENoaWxkO1xyXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bSA9IG0ubmV4dFNpYmxpbmc7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgU3RlcC5QUkVDRURJTkdTSUJMSU5HOlxyXG5cdFx0XHRcdFx0XHRpZiAoeHBjLmNvbnRleHROb2RlID09PSB4cGMudmlydHVhbFJvb3QpIHtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBtID0geHBjLmNvbnRleHROb2RlLnByZXZpb3VzU2libGluZzsgbSAhPSBudWxsOyBtID0gbS5wcmV2aW91c1NpYmxpbmcpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoc3RlcC5ub2RlVGVzdC5tYXRjaGVzKG0sIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2gobSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgU3RlcC5TRUxGOlxyXG5cdFx0XHRcdFx0XHRpZiAoc3RlcC5ub2RlVGVzdC5tYXRjaGVzKHhwYy5jb250ZXh0Tm9kZSwgeHBjKSkge1xyXG5cdFx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2goeHBjLmNvbnRleHROb2RlKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRub2RlcyA9IG5ld05vZGVzO1xyXG5cdFx0XHQvLyBhcHBseSBlYWNoIG9mIHRoZSBwcmVkaWNhdGVzIGluIHR1cm5cclxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzdGVwLnByZWRpY2F0ZXMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHR2YXIgcHJlZCA9IHN0ZXAucHJlZGljYXRlc1tqXTtcclxuXHRcdFx0XHR2YXIgbmV3Tm9kZXMgPSBbXTtcclxuXHRcdFx0XHR4cGMuY29udGV4dFNpemUgPSBub2Rlcy5sZW5ndGg7XHJcblx0XHRcdFx0Zm9yICh4cGMuY29udGV4dFBvc2l0aW9uID0gMTsgeHBjLmNvbnRleHRQb3NpdGlvbiA8PSB4cGMuY29udGV4dFNpemU7IHhwYy5jb250ZXh0UG9zaXRpb24rKykge1xyXG5cdFx0XHRcdFx0eHBjLmNvbnRleHROb2RlID0gbm9kZXNbeHBjLmNvbnRleHRQb3NpdGlvbiAtIDFdO1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMucHJlZGljYXRlTWF0Y2hlcyhwcmVkLCB4cGMpKSB7XHJcblx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2goeHBjLmNvbnRleHROb2RlKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG5vZGVzID0gbmV3Tm9kZXM7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0dmFyIG5zID0gbmV3IFhOb2RlU2V0KCk7XHJcblx0bnMuYWRkQXJyYXkobm9kZXMpO1xyXG5cdHJldHVybiBucztcclxufTtcclxuXHJcblBhdGhFeHByLnByb3RvdHlwZS5wcmVkaWNhdGVNYXRjaGVzID0gZnVuY3Rpb24ocHJlZCwgYykge1xyXG5cdHZhciByZXMgPSBwcmVkLmV2YWx1YXRlKGMpO1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YocmVzLCBYTnVtYmVyKSkge1xyXG5cdFx0cmV0dXJuIGMuY29udGV4dFBvc2l0aW9uID09IHJlcy5udW1iZXJWYWx1ZSgpO1xyXG5cdH1cclxuXHRyZXR1cm4gcmVzLmJvb2xlYW5WYWx1ZSgpO1xyXG59O1xyXG5cclxuUGF0aEV4cHIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0aWYgKHRoaXMuZmlsdGVyICE9IHVuZGVmaW5lZCkge1xyXG5cdFx0dmFyIHMgPSB0aGlzLmZpbHRlci50b1N0cmluZygpO1xyXG5cdFx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZih0aGlzLmZpbHRlciwgWFN0cmluZykpIHtcclxuXHRcdFx0cyA9IFwiJ1wiICsgcyArIFwiJ1wiO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuZmlsdGVyUHJlZGljYXRlcyAhPSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbHRlclByZWRpY2F0ZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRzID0gcyArIFwiW1wiICsgdGhpcy5maWx0ZXJQcmVkaWNhdGVzW2ldLnRvU3RyaW5nKCkgKyBcIl1cIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMubG9jYXRpb25QYXRoICE9IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRpZiAoIXRoaXMubG9jYXRpb25QYXRoLmFic29sdXRlKSB7XHJcblx0XHRcdFx0cyArPSBcIi9cIjtcclxuXHRcdFx0fVxyXG5cdFx0XHRzICs9IHRoaXMubG9jYXRpb25QYXRoLnRvU3RyaW5nKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcztcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMubG9jYXRpb25QYXRoLnRvU3RyaW5nKCk7XHJcbn07XHJcblxyXG5QYXRoRXhwci5wcm90b3R5cGUuZ2V0T3duZXJFbGVtZW50ID0gZnVuY3Rpb24obikge1xyXG5cdC8vIERPTSAyIGhhcyBvd25lckVsZW1lbnRcclxuXHRpZiAobi5vd25lckVsZW1lbnQpIHtcclxuXHRcdHJldHVybiBuLm93bmVyRWxlbWVudDtcclxuXHR9XHJcblx0Ly8gRE9NIDEgSW50ZXJuZXQgRXhwbG9yZXIgY2FuIHVzZSBzZWxlY3RTaW5nbGVOb2RlIChpcm9uaWNhbGx5KVxyXG5cdHRyeSB7XHJcblx0XHRpZiAobi5zZWxlY3RTaW5nbGVOb2RlKSB7XHJcblx0XHRcdHJldHVybiBuLnNlbGVjdFNpbmdsZU5vZGUoXCIuLlwiKTtcclxuXHRcdH1cclxuXHR9IGNhdGNoIChlKSB7XHJcblx0fVxyXG5cdC8vIE90aGVyIERPTSAxIGltcGxlbWVudGF0aW9ucyBtdXN0IHVzZSB0aGlzIGVncmVnaW91cyBzZWFyY2hcclxuXHR2YXIgZG9jID0gbi5ub2RlVHlwZSA9PSA5IC8qTm9kZS5ET0NVTUVOVF9OT0RFKi9cclxuXHRcdFx0PyBuXHJcblx0XHRcdDogbi5vd25lckRvY3VtZW50O1xyXG5cdHZhciBlbHRzID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGVsdHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBlbHQgPSBlbHRzLml0ZW0oaSk7XHJcblx0XHR2YXIgbm5tID0gZWx0LmF0dHJpYnV0ZXM7XHJcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IG5ubS5sZW5ndGg7IGorKykge1xyXG5cdFx0XHR2YXIgYW4gPSBubm0uaXRlbShqKTtcclxuXHRcdFx0aWYgKGFuID09PSBuKSB7XHJcblx0XHRcdFx0cmV0dXJuIGVsdDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8vIExvY2F0aW9uUGF0aCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuTG9jYXRpb25QYXRoLnByb3RvdHlwZSA9IG5ldyBPYmplY3QoKTtcclxuTG9jYXRpb25QYXRoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvY2F0aW9uUGF0aDtcclxuTG9jYXRpb25QYXRoLnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gTG9jYXRpb25QYXRoKGFicywgc3RlcHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChhYnMsIHN0ZXBzKTtcclxuXHR9XHJcbn1cclxuXHJcbkxvY2F0aW9uUGF0aC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGFicywgc3RlcHMpIHtcclxuXHR0aGlzLmFic29sdXRlID0gYWJzO1xyXG5cdHRoaXMuc3RlcHMgPSBzdGVwcztcclxufTtcclxuXHJcbkxvY2F0aW9uUGF0aC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgcztcclxuXHRpZiAodGhpcy5hYnNvbHV0ZSkge1xyXG5cdFx0cyA9IFwiL1wiO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRzID0gXCJcIjtcclxuXHR9XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0ZXBzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAoaSAhPSAwKSB7XHJcblx0XHRcdHMgKz0gXCIvXCI7XHJcblx0XHR9XHJcblx0XHRzICs9IHRoaXMuc3RlcHNbaV0udG9TdHJpbmcoKTtcclxuXHR9XHJcblx0cmV0dXJuIHM7XHJcbn07XHJcblxyXG4vLyBTdGVwIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblN0ZXAucHJvdG90eXBlID0gbmV3IE9iamVjdCgpO1xyXG5TdGVwLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0ZXA7XHJcblN0ZXAuc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBTdGVwKGF4aXMsIG5vZGV0ZXN0LCBwcmVkcykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGF4aXMsIG5vZGV0ZXN0LCBwcmVkcyk7XHJcblx0fVxyXG59XHJcblxyXG5TdGVwLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oYXhpcywgbm9kZXRlc3QsIHByZWRzKSB7XHJcblx0dGhpcy5heGlzID0gYXhpcztcclxuXHR0aGlzLm5vZGVUZXN0ID0gbm9kZXRlc3Q7XHJcblx0dGhpcy5wcmVkaWNhdGVzID0gcHJlZHM7XHJcbn07XHJcblxyXG5TdGVwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBzO1xyXG5cdHN3aXRjaCAodGhpcy5heGlzKSB7XHJcblx0XHRjYXNlIFN0ZXAuQU5DRVNUT1I6XHJcblx0XHRcdHMgPSBcImFuY2VzdG9yXCI7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBTdGVwLkFOQ0VTVE9ST1JTRUxGOlxyXG5cdFx0XHRzID0gXCJhbmNlc3Rvci1vci1zZWxmXCI7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBTdGVwLkFUVFJJQlVURTpcclxuXHRcdFx0cyA9IFwiYXR0cmlidXRlXCI7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBTdGVwLkNISUxEOlxyXG5cdFx0XHRzID0gXCJjaGlsZFwiO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgU3RlcC5ERVNDRU5EQU5UOlxyXG5cdFx0XHRzID0gXCJkZXNjZW5kYW50XCI7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBTdGVwLkRFU0NFTkRBTlRPUlNFTEY6XHJcblx0XHRcdHMgPSBcImRlc2NlbmRhbnQtb3Itc2VsZlwiO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgU3RlcC5GT0xMT1dJTkc6XHJcblx0XHRcdHMgPSBcImZvbGxvd2luZ1wiO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgU3RlcC5GT0xMT1dJTkdTSUJMSU5HOlxyXG5cdFx0XHRzID0gXCJmb2xsb3dpbmctc2libGluZ1wiO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgU3RlcC5OQU1FU1BBQ0U6XHJcblx0XHRcdHMgPSBcIm5hbWVzcGFjZVwiO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgU3RlcC5QQVJFTlQ6XHJcblx0XHRcdHMgPSBcInBhcmVudFwiO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgU3RlcC5QUkVDRURJTkc6XHJcblx0XHRcdHMgPSBcInByZWNlZGluZ1wiO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgU3RlcC5QUkVDRURJTkdTSUJMSU5HOlxyXG5cdFx0XHRzID0gXCJwcmVjZWRpbmctc2libGluZ1wiO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgU3RlcC5TRUxGOlxyXG5cdFx0XHRzID0gXCJzZWxmXCI7XHJcblx0XHRcdGJyZWFrO1xyXG5cdH1cclxuXHRzICs9IFwiOjpcIjtcclxuXHRzICs9IHRoaXMubm9kZVRlc3QudG9TdHJpbmcoKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHJlZGljYXRlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0cyArPSBcIltcIiArIHRoaXMucHJlZGljYXRlc1tpXS50b1N0cmluZygpICsgXCJdXCI7XHJcblx0fVxyXG5cdHJldHVybiBzO1xyXG59O1xyXG5cclxuU3RlcC5BTkNFU1RPUiA9IDA7XHJcblN0ZXAuQU5DRVNUT1JPUlNFTEYgPSAxO1xyXG5TdGVwLkFUVFJJQlVURSA9IDI7XHJcblN0ZXAuQ0hJTEQgPSAzO1xyXG5TdGVwLkRFU0NFTkRBTlQgPSA0O1xyXG5TdGVwLkRFU0NFTkRBTlRPUlNFTEYgPSA1O1xyXG5TdGVwLkZPTExPV0lORyA9IDY7XHJcblN0ZXAuRk9MTE9XSU5HU0lCTElORyA9IDc7XHJcblN0ZXAuTkFNRVNQQUNFID0gODtcclxuU3RlcC5QQVJFTlQgPSA5O1xyXG5TdGVwLlBSRUNFRElORyA9IDEwO1xyXG5TdGVwLlBSRUNFRElOR1NJQkxJTkcgPSAxMTtcclxuU3RlcC5TRUxGID0gMTI7XHJcblxyXG4vLyBOb2RlVGVzdCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbk5vZGVUZXN0LnByb3RvdHlwZSA9IG5ldyBPYmplY3QoKTtcclxuTm9kZVRlc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTm9kZVRlc3Q7XHJcbk5vZGVUZXN0LnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gTm9kZVRlc3QodHlwZSwgdmFsdWUpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdCh0eXBlLCB2YWx1ZSk7XHJcblx0fVxyXG59XHJcblxyXG5Ob2RlVGVzdC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHR5cGUsIHZhbHVlKSB7XHJcblx0dGhpcy50eXBlID0gdHlwZTtcclxuXHR0aGlzLnZhbHVlID0gdmFsdWU7XHJcbn07XHJcblxyXG5Ob2RlVGVzdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG5cdFx0Y2FzZSBOb2RlVGVzdC5OQU1FVEVTVEFOWTpcclxuXHRcdFx0cmV0dXJuIFwiKlwiO1xyXG5cdFx0Y2FzZSBOb2RlVGVzdC5OQU1FVEVTVFBSRUZJWEFOWTpcclxuXHRcdFx0cmV0dXJuIHRoaXMudmFsdWUgKyBcIjoqXCI7XHJcblx0XHRjYXNlIE5vZGVUZXN0Lk5BTUVURVNUUkVTT0xWRURBTlk6XHJcblx0XHRcdHJldHVybiBcIntcIiArIHRoaXMudmFsdWUgKyBcIn0qXCI7XHJcblx0XHRjYXNlIE5vZGVUZXN0Lk5BTUVURVNUUU5BTUU6XHJcblx0XHRcdHJldHVybiB0aGlzLnZhbHVlO1xyXG5cdFx0Y2FzZSBOb2RlVGVzdC5OQU1FVEVTVFJFU09MVkVETkFNRTpcclxuXHRcdFx0cmV0dXJuIFwie1wiICsgdGhpcy5uYW1lc3BhY2VVUkkgKyBcIn1cIiArIHRoaXMudmFsdWU7XHJcblx0XHRjYXNlIE5vZGVUZXN0LkNPTU1FTlQ6XHJcblx0XHRcdHJldHVybiBcImNvbW1lbnQoKVwiO1xyXG5cdFx0Y2FzZSBOb2RlVGVzdC5URVhUOlxyXG5cdFx0XHRyZXR1cm4gXCJ0ZXh0KClcIjtcclxuXHRcdGNhc2UgTm9kZVRlc3QuUEk6XHJcblx0XHRcdGlmICh0aGlzLnZhbHVlICE9IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdHJldHVybiBcInByb2Nlc3NpbmctaW5zdHJ1Y3Rpb24oXFxcIlwiICsgdGhpcy52YWx1ZSArIFwiXFxcIilcIjtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gXCJwcm9jZXNzaW5nLWluc3RydWN0aW9uKClcIjtcclxuXHRcdGNhc2UgTm9kZVRlc3QuTk9ERTpcclxuXHRcdFx0cmV0dXJuIFwibm9kZSgpXCI7XHJcblx0fVxyXG5cdHJldHVybiBcIjx1bmtub3duIG5vZGV0ZXN0IHR5cGU+XCI7XHJcbn07XHJcblxyXG5Ob2RlVGVzdC5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uKG4sIHhwYykge1xyXG5cdHN3aXRjaCAodGhpcy50eXBlKSB7XHJcblx0XHRjYXNlIE5vZGVUZXN0Lk5BTUVURVNUQU5ZOlxyXG5cdFx0XHRpZiAobi5ub2RlVHlwZSA9PSAyIC8qTm9kZS5BVFRSSUJVVEVfTk9ERSovXHJcblx0XHRcdFx0XHR8fCBuLm5vZGVUeXBlID09IDEgLypOb2RlLkVMRU1FTlRfTk9ERSovXHJcblx0XHRcdFx0XHR8fCBuLm5vZGVUeXBlID09IFhQYXRoTmFtZXNwYWNlLlhQQVRIX05BTUVTUEFDRV9OT0RFKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0Y2FzZSBOb2RlVGVzdC5OQU1FVEVTVFBSRUZJWEFOWTpcclxuXHRcdFx0aWYgKChuLm5vZGVUeXBlID09IDIgLypOb2RlLkFUVFJJQlVURV9OT0RFKi8gfHwgbi5ub2RlVHlwZSA9PSAxIC8qTm9kZS5FTEVNRU5UX05PREUqLykpIHtcclxuXHRcdFx0XHR2YXIgbnMgPSB4cGMubmFtZXNwYWNlUmVzb2x2ZXIuZ2V0TmFtZXNwYWNlKHRoaXMudmFsdWUsIHhwYy5leHByZXNzaW9uQ29udGV4dE5vZGUpO1xyXG5cdFx0XHRcdGlmIChucyA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBRTmFtZSBcIiArIHRoaXMudmFsdWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gbnMgPT0gKG4ubmFtZXNwYWNlVVJJIHx8ICcnKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRjYXNlIE5vZGVUZXN0Lk5BTUVURVNUUU5BTUU6XHJcblx0XHRcdGlmIChuLm5vZGVUeXBlID09IDIgLypOb2RlLkFUVFJJQlVURV9OT0RFKi9cclxuXHRcdFx0XHRcdHx8IG4ubm9kZVR5cGUgPT0gMSAvKk5vZGUuRUxFTUVOVF9OT0RFKi9cclxuXHRcdFx0XHRcdHx8IG4ubm9kZVR5cGUgPT0gWFBhdGhOYW1lc3BhY2UuWFBBVEhfTkFNRVNQQUNFX05PREUpIHtcclxuXHRcdFx0XHR2YXIgdGVzdCA9IFV0aWxpdGllcy5yZXNvbHZlUU5hbWUodGhpcy52YWx1ZSwgeHBjLm5hbWVzcGFjZVJlc29sdmVyLCB4cGMuZXhwcmVzc2lvbkNvbnRleHROb2RlLCBmYWxzZSk7XHJcblx0XHRcdFx0aWYgKHRlc3RbMF0gPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgUU5hbWUgXCIgKyB0aGlzLnZhbHVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGVzdFswXSA9IFN0cmluZyh0ZXN0WzBdKTtcclxuXHRcdFx0XHR0ZXN0WzFdID0gU3RyaW5nKHRlc3RbMV0pO1xyXG5cdFx0XHRcdGlmICh0ZXN0WzBdID09IFwiXCIpIHtcclxuXHRcdFx0XHRcdHRlc3RbMF0gPSBudWxsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgbm9kZSA9IFtuLm5hbWVzcGFjZVVSSSB8fCAnJywgbi5sb2NhbE5hbWVdO1xyXG5cdFx0XHRcdG5vZGVbMF0gPSBTdHJpbmcobm9kZVswXSk7XHJcblx0XHRcdFx0bm9kZVsxXSA9IFN0cmluZyhub2RlWzFdKTtcclxuXHRcdFx0XHRpZiAobm9kZVswXSA9PSBcIlwiKSB7XHJcblx0XHRcdFx0XHRub2RlWzBdID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHhwYy5jYXNlSW5zZW5zaXRpdmUpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0ZXN0WzBdID09IG5vZGVbMF0gJiYgU3RyaW5nKHRlc3RbMV0pLnRvTG93ZXJDYXNlKCkgPT0gU3RyaW5nKG5vZGVbMV0pLnRvTG93ZXJDYXNlKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB0ZXN0WzBdID09IG5vZGVbMF0gJiYgdGVzdFsxXSA9PSBub2RlWzFdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdGNhc2UgTm9kZVRlc3QuQ09NTUVOVDpcclxuXHRcdFx0cmV0dXJuIG4ubm9kZVR5cGUgPT0gOCAvKk5vZGUuQ09NTUVOVF9OT0RFKi87XHJcblx0XHRjYXNlIE5vZGVUZXN0LlRFWFQ6XHJcblx0XHRcdHJldHVybiBuLm5vZGVUeXBlID09IDMgLypOb2RlLlRFWFRfTk9ERSovIHx8IG4ubm9kZVR5cGUgPT0gNCAvKk5vZGUuQ0RBVEFfU0VDVElPTl9OT0RFKi87XHJcblx0XHRjYXNlIE5vZGVUZXN0LlBJOlxyXG5cdFx0XHRyZXR1cm4gbi5ub2RlVHlwZSA9PSA3IC8qTm9kZS5QUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREUqL1xyXG5cdFx0XHRcdCYmICh0aGlzLnZhbHVlID09IG51bGwgfHwgbi5ub2RlTmFtZSA9PSB0aGlzLnZhbHVlKTtcclxuXHRcdGNhc2UgTm9kZVRlc3QuTk9ERTpcclxuXHRcdFx0cmV0dXJuIG4ubm9kZVR5cGUgPT0gOSAvKk5vZGUuRE9DVU1FTlRfTk9ERSovXHJcblx0XHRcdFx0fHwgbi5ub2RlVHlwZSA9PSAxIC8qTm9kZS5FTEVNRU5UX05PREUqL1xyXG5cdFx0XHRcdHx8IG4ubm9kZVR5cGUgPT0gMiAvKk5vZGUuQVRUUklCVVRFX05PREUqL1xyXG5cdFx0XHRcdHx8IG4ubm9kZVR5cGUgPT0gMyAvKk5vZGUuVEVYVF9OT0RFKi9cclxuXHRcdFx0XHR8fCBuLm5vZGVUeXBlID09IDQgLypOb2RlLkNEQVRBX1NFQ1RJT05fTk9ERSovXHJcblx0XHRcdFx0fHwgbi5ub2RlVHlwZSA9PSA4IC8qTm9kZS5DT01NRU5UX05PREUqL1xyXG5cdFx0XHRcdHx8IG4ubm9kZVR5cGUgPT0gNyAvKk5vZGUuUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFKi87XHJcblx0fVxyXG5cdHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbk5vZGVUZXN0Lk5BTUVURVNUQU5ZID0gMDtcclxuTm9kZVRlc3QuTkFNRVRFU1RQUkVGSVhBTlkgPSAxO1xyXG5Ob2RlVGVzdC5OQU1FVEVTVFFOQU1FID0gMjtcclxuTm9kZVRlc3QuQ09NTUVOVCA9IDM7XHJcbk5vZGVUZXN0LlRFWFQgPSA0O1xyXG5Ob2RlVGVzdC5QSSA9IDU7XHJcbk5vZGVUZXN0Lk5PREUgPSA2O1xyXG5cclxuLy8gVmFyaWFibGVSZWZlcmVuY2UgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5WYXJpYWJsZVJlZmVyZW5jZS5wcm90b3R5cGUgPSBuZXcgRXhwcmVzc2lvbigpO1xyXG5WYXJpYWJsZVJlZmVyZW5jZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWYXJpYWJsZVJlZmVyZW5jZTtcclxuVmFyaWFibGVSZWZlcmVuY2Uuc3VwZXJjbGFzcyA9IEV4cHJlc3Npb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gVmFyaWFibGVSZWZlcmVuY2Uodikge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KHYpO1xyXG5cdH1cclxufVxyXG5cclxuVmFyaWFibGVSZWZlcmVuY2UucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbih2KSB7XHJcblx0dGhpcy52YXJpYWJsZSA9IHY7XHJcbn07XHJcblxyXG5WYXJpYWJsZVJlZmVyZW5jZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCIkXCIgKyB0aGlzLnZhcmlhYmxlO1xyXG59O1xyXG5cclxuVmFyaWFibGVSZWZlcmVuY2UucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiBjLnZhcmlhYmxlUmVzb2x2ZXIuZ2V0VmFyaWFibGUodGhpcy52YXJpYWJsZSwgYyk7XHJcbn07XHJcblxyXG4vLyBGdW5jdGlvbkNhbGwgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUgPSBuZXcgRXhwcmVzc2lvbigpO1xyXG5GdW5jdGlvbkNhbGwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRnVuY3Rpb25DYWxsO1xyXG5GdW5jdGlvbkNhbGwuc3VwZXJjbGFzcyA9IEV4cHJlc3Npb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gRnVuY3Rpb25DYWxsKGZuLCBhcmdzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQoZm4sIGFyZ3MpO1xyXG5cdH1cclxufVxyXG5cclxuRnVuY3Rpb25DYWxsLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oZm4sIGFyZ3MpIHtcclxuXHR0aGlzLmZ1bmN0aW9uTmFtZSA9IGZuO1xyXG5cdHRoaXMuYXJndW1lbnRzID0gYXJncztcclxufTtcclxuXHJcbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgcyA9IHRoaXMuZnVuY3Rpb25OYW1lICsgXCIoXCI7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKGkgPiAwKSB7XHJcblx0XHRcdHMgKz0gXCIsIFwiO1xyXG5cdFx0fVxyXG5cdFx0cyArPSB0aGlzLmFyZ3VtZW50c1tpXS50b1N0cmluZygpO1xyXG5cdH1cclxuXHRyZXR1cm4gcyArIFwiKVwiO1xyXG59O1xyXG5cclxuRnVuY3Rpb25DYWxsLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHR2YXIgZiA9IGMuZnVuY3Rpb25SZXNvbHZlci5nZXRGdW5jdGlvbih0aGlzLmZ1bmN0aW9uTmFtZSwgYyk7XHJcblx0aWYgKGYgPT0gdW5kZWZpbmVkKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGZ1bmN0aW9uIFwiICsgdGhpcy5mdW5jdGlvbk5hbWUpO1xyXG5cdH1cclxuXHR2YXIgYSA9IFtjXS5jb25jYXQodGhpcy5hcmd1bWVudHMpO1xyXG5cdHJldHVybiBmLmFwcGx5KGMuZnVuY3Rpb25SZXNvbHZlci50aGlzQXJnLCBhKTtcclxufTtcclxuXHJcbi8vIFhTdHJpbmcgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuWFN0cmluZy5wcm90b3R5cGUgPSBuZXcgRXhwcmVzc2lvbigpO1xyXG5YU3RyaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhTdHJpbmc7XHJcblhTdHJpbmcuc3VwZXJjbGFzcyA9IEV4cHJlc3Npb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gWFN0cmluZyhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQocyk7XHJcblx0fVxyXG59XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24ocykge1xyXG5cdHRoaXMuc3RyID0gcztcclxufTtcclxuXHJcblhTdHJpbmcucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuc3RyO1xyXG59O1xyXG5cclxuWFN0cmluZy5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblhTdHJpbmcucHJvdG90eXBlLm51bWJlciA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgWE51bWJlcih0aGlzLnN0cik7XHJcbn07XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbih0aGlzLnN0cik7XHJcbn07XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5ub2Rlc2V0ID0gZnVuY3Rpb24oKSB7XHJcblx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnZlcnQgc3RyaW5nIHRvIG5vZGVzZXRcIik7XHJcbn07XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5zdHJpbmdWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLnN0cjtcclxufTtcclxuXHJcblhTdHJpbmcucHJvdG90eXBlLm51bWJlclZhbHVlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMubnVtYmVyKCkubnVtYmVyVmFsdWUoKTtcclxufTtcclxuXHJcblhTdHJpbmcucHJvdG90eXBlLmJvb2xlYW5WYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmJvb2woKS5ib29sZWFuVmFsdWUoKTtcclxufTtcclxuXHJcblhTdHJpbmcucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhCb29sZWFuKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuYm9vbCgpLmVxdWFscyhyKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTnVtYmVyKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMubnVtYmVyKCkuZXF1YWxzKHIpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhTdHJpbmcodGhpcywgT3BlcmF0b3JzLmVxdWFscyk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4odGhpcy5zdHIgPT0gci5zdHIpO1xyXG59O1xyXG5cclxuWFN0cmluZy5wcm90b3R5cGUubm90ZXF1YWwgPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYQm9vbGVhbikpIHtcclxuXHRcdHJldHVybiB0aGlzLmJvb2woKS5ub3RlcXVhbChyKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTnVtYmVyKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMubnVtYmVyKCkubm90ZXF1YWwocik7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aFN0cmluZyh0aGlzLCBPcGVyYXRvcnMubm90ZXF1YWwpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHRoaXMuc3RyICE9IHIuc3RyKTtcclxufTtcclxuXHJcblhTdHJpbmcucHJvdG90eXBlLmxlc3N0aGFuID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aE51bWJlcih0aGlzLm51bWJlcigpLCBPcGVyYXRvcnMuZ3JlYXRlcnRoYW5vcmVxdWFsKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMubnVtYmVyKCkubGVzc3RoYW4oci5udW1iZXIoKSk7XHJcbn07XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5ncmVhdGVydGhhbiA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhOdW1iZXIodGhpcy5udW1iZXIoKSwgT3BlcmF0b3JzLmxlc3N0aGFub3JlcXVhbCk7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLm51bWJlcigpLmdyZWF0ZXJ0aGFuKHIubnVtYmVyKCkpO1xyXG59O1xyXG5cclxuWFN0cmluZy5wcm90b3R5cGUubGVzc3RoYW5vcmVxdWFsID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aE51bWJlcih0aGlzLm51bWJlcigpLCBPcGVyYXRvcnMuZ3JlYXRlcnRoYW4pO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5udW1iZXIoKS5sZXNzdGhhbm9yZXF1YWwoci5udW1iZXIoKSk7XHJcbn07XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5ncmVhdGVydGhhbm9yZXF1YWwgPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTm9kZVNldCkpIHtcclxuXHRcdHJldHVybiByLmNvbXBhcmVXaXRoTnVtYmVyKHRoaXMubnVtYmVyKCksIE9wZXJhdG9ycy5sZXNzdGhhbik7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLm51bWJlcigpLmdyZWF0ZXJ0aGFub3JlcXVhbChyLm51bWJlcigpKTtcclxufTtcclxuXHJcbi8vIFhOdW1iZXIgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUgPSBuZXcgRXhwcmVzc2lvbigpO1xyXG5YTnVtYmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhOdW1iZXI7XHJcblhOdW1iZXIuc3VwZXJjbGFzcyA9IEV4cHJlc3Npb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gWE51bWJlcihuKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQobik7XHJcblx0fVxyXG59XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obikge1xyXG5cdHRoaXMubnVtID0gTnVtYmVyKG4pO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5udW07XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgWFN0cmluZyh0aGlzLm51bSk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5udW1iZXIgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHRoaXMubnVtKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLm5vZGVzZXQgPSBmdW5jdGlvbigpIHtcclxuXHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBudW1iZXIgdG8gbm9kZXNldFwiKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLnN0cmluZ1ZhbHVlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuc3RyaW5nKCkuc3RyaW5nVmFsdWUoKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLm51bWJlclZhbHVlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMubnVtO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUuYm9vbGVhblZhbHVlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuYm9vbCgpLmJvb2xlYW5WYWx1ZSgpO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBYTnVtYmVyKC10aGlzLm51bSk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYQm9vbGVhbikpIHtcclxuXHRcdHJldHVybiB0aGlzLmJvb2woKS5lcXVhbHMocik7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWFN0cmluZykpIHtcclxuXHRcdHJldHVybiB0aGlzLmVxdWFscyhyLm51bWJlcigpKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTm9kZVNldCkpIHtcclxuXHRcdHJldHVybiByLmNvbXBhcmVXaXRoTnVtYmVyKHRoaXMsIE9wZXJhdG9ycy5lcXVhbHMpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHRoaXMubnVtID09IHIubnVtKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLm5vdGVxdWFsID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWEJvb2xlYW4pKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5ib29sKCkubm90ZXF1YWwocik7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWFN0cmluZykpIHtcclxuXHRcdHJldHVybiB0aGlzLm5vdGVxdWFsKHIubnVtYmVyKCkpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhOdW1iZXIodGhpcywgT3BlcmF0b3JzLm5vdGVxdWFsKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbih0aGlzLm51bSAhPSByLm51bSk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5sZXNzdGhhbiA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhOdW1iZXIodGhpcywgT3BlcmF0b3JzLmdyZWF0ZXJ0aGFub3JlcXVhbCk7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWEJvb2xlYW4pIHx8IFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYU3RyaW5nKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMubGVzc3RoYW4oci5udW1iZXIoKSk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4odGhpcy5udW0gPCByLm51bSk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5ncmVhdGVydGhhbiA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhOdW1iZXIodGhpcywgT3BlcmF0b3JzLmxlc3N0aGFub3JlcXVhbCk7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWEJvb2xlYW4pIHx8IFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYU3RyaW5nKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ3JlYXRlcnRoYW4oci5udW1iZXIoKSk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4odGhpcy5udW0gPiByLm51bSk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5sZXNzdGhhbm9yZXF1YWwgPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTm9kZVNldCkpIHtcclxuXHRcdHJldHVybiByLmNvbXBhcmVXaXRoTnVtYmVyKHRoaXMsIE9wZXJhdG9ycy5ncmVhdGVydGhhbik7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWEJvb2xlYW4pIHx8IFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYU3RyaW5nKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMubGVzc3RoYW5vcmVxdWFsKHIubnVtYmVyKCkpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHRoaXMubnVtIDw9IHIubnVtKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLmdyZWF0ZXJ0aGFub3JlcXVhbCA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhOdW1iZXIodGhpcywgT3BlcmF0b3JzLmxlc3N0aGFuKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYQm9vbGVhbikgfHwgVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhTdHJpbmcpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5ncmVhdGVydGhhbm9yZXF1YWwoci5udW1iZXIoKSk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4odGhpcy5udW0gPj0gci5udW0pO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUucGx1cyA9IGZ1bmN0aW9uKHIpIHtcclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIodGhpcy5udW0gKyByLm51bSk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5taW51cyA9IGZ1bmN0aW9uKHIpIHtcclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIodGhpcy5udW0gLSByLm51bSk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uKHIpIHtcclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIodGhpcy5udW0gKiByLm51bSk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbihyKSB7XHJcblx0cmV0dXJuIG5ldyBYTnVtYmVyKHRoaXMubnVtIC8gci5udW0pO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24ocikge1xyXG5cdHJldHVybiBuZXcgWE51bWJlcih0aGlzLm51bSAlIHIubnVtKTtcclxufTtcclxuXHJcbi8vIFhCb29sZWFuIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlID0gbmV3IEV4cHJlc3Npb24oKTtcclxuWEJvb2xlYW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWEJvb2xlYW47XHJcblhCb29sZWFuLnN1cGVyY2xhc3MgPSBFeHByZXNzaW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFhCb29sZWFuKGIpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChiKTtcclxuXHR9XHJcbn1cclxuXHJcblhCb29sZWFuLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oYikge1xyXG5cdHRoaXMuYiA9IEJvb2xlYW4oYik7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5iLnRvU3RyaW5nKCk7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBYU3RyaW5nKHRoaXMuYik7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUubnVtYmVyID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBYTnVtYmVyKHRoaXMuYik7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLm5vZGVzZXQgPSBmdW5jdGlvbigpIHtcclxuXHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBib29sZWFuIHRvIG5vZGVzZXRcIik7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUuc3RyaW5nVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5zdHJpbmcoKS5zdHJpbmdWYWx1ZSgpO1xyXG59O1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLm51bWJlclZhbHVlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMubnVtKCkubnVtYmVyVmFsdWUoKTtcclxufTtcclxuXHJcblhCb29sZWFuLnByb3RvdHlwZS5ib29sZWFuVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5iO1xyXG59O1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4oIXRoaXMuYik7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWFN0cmluZykgfHwgVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOdW1iZXIpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lcXVhbHMoci5ib29sKCkpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhCb29sZWFuKHRoaXMsIE9wZXJhdG9ycy5lcXVhbHMpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHRoaXMuYiA9PSByLmIpO1xyXG59O1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLm5vdGVxdWFsID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWFN0cmluZykgfHwgVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOdW1iZXIpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5ub3RlcXVhbChyLmJvb2woKSk7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aEJvb2xlYW4odGhpcywgT3BlcmF0b3JzLm5vdGVxdWFsKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbih0aGlzLmIgIT0gci5iKTtcclxufTtcclxuXHJcblhCb29sZWFuLnByb3RvdHlwZS5sZXNzdGhhbiA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhOdW1iZXIodGhpcy5udW1iZXIoKSwgT3BlcmF0b3JzLmdyZWF0ZXJ0aGFub3JlcXVhbCk7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLm51bWJlcigpLmxlc3N0aGFuKHIubnVtYmVyKCkpO1xyXG59O1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLmdyZWF0ZXJ0aGFuID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aE51bWJlcih0aGlzLm51bWJlcigpLCBPcGVyYXRvcnMubGVzc3RoYW5vcmVxdWFsKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMubnVtYmVyKCkuZ3JlYXRlcnRoYW4oci5udW1iZXIoKSk7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUubGVzc3RoYW5vcmVxdWFsID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aE51bWJlcih0aGlzLm51bWJlcigpLCBPcGVyYXRvcnMuZ3JlYXRlcnRoYW4pO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5udW1iZXIoKS5sZXNzdGhhbm9yZXF1YWwoci5udW1iZXIoKSk7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUuZ3JlYXRlcnRoYW5vcmVxdWFsID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aE51bWJlcih0aGlzLm51bWJlcigpLCBPcGVyYXRvcnMubGVzc3RoYW4pO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5udW1iZXIoKS5ncmVhdGVydGhhbm9yZXF1YWwoci5udW1iZXIoKSk7XHJcbn07XHJcblxyXG4vLyBBVkxUcmVlIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbkFWTFRyZWUucHJvdG90eXBlID0gbmV3IE9iamVjdCgpO1xyXG5BVkxUcmVlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFWTFRyZWU7XHJcbkFWTFRyZWUuc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBBVkxUcmVlKG4pIHtcclxuXHR0aGlzLmluaXQobik7XHJcbn1cclxuXHJcbkFWTFRyZWUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihuKSB7XHJcblx0dGhpcy5sZWZ0ID0gbnVsbDtcclxuICAgIHRoaXMucmlnaHQgPSBudWxsO1xyXG5cdHRoaXMubm9kZSA9IG47XHJcblx0dGhpcy5kZXB0aCA9IDE7XHJcbn07XHJcblxyXG5BVkxUcmVlLnByb3RvdHlwZS5iYWxhbmNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgbGRlcHRoID0gdGhpcy5sZWZ0ICA9PSBudWxsID8gMCA6IHRoaXMubGVmdC5kZXB0aDtcclxuICAgIHZhciByZGVwdGggPSB0aGlzLnJpZ2h0ID09IG51bGwgPyAwIDogdGhpcy5yaWdodC5kZXB0aDtcclxuXHJcblx0aWYgKGxkZXB0aCA+IHJkZXB0aCArIDEpIHtcclxuICAgICAgICAvLyBMUiBvciBMTCByb3RhdGlvblxyXG4gICAgICAgIHZhciBsbGRlcHRoID0gdGhpcy5sZWZ0LmxlZnQgID09IG51bGwgPyAwIDogdGhpcy5sZWZ0LmxlZnQuZGVwdGg7XHJcbiAgICAgICAgdmFyIGxyZGVwdGggPSB0aGlzLmxlZnQucmlnaHQgPT0gbnVsbCA/IDAgOiB0aGlzLmxlZnQucmlnaHQuZGVwdGg7XHJcblxyXG4gICAgICAgIGlmIChsbGRlcHRoIDwgbHJkZXB0aCkge1xyXG4gICAgICAgICAgICAvLyBMUiByb3RhdGlvbiBjb25zaXN0cyBvZiBhIFJSIHJvdGF0aW9uIG9mIHRoZSBsZWZ0IGNoaWxkXHJcbiAgICAgICAgICAgIHRoaXMubGVmdC5yb3RhdGVSUigpO1xyXG4gICAgICAgICAgICAvLyBwbHVzIGEgTEwgcm90YXRpb24gb2YgdGhpcyBub2RlLCB3aGljaCBoYXBwZW5zIGFueXdheVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJvdGF0ZUxMKCk7XHJcbiAgICB9IGVsc2UgaWYgKGxkZXB0aCArIDEgPCByZGVwdGgpIHtcclxuICAgICAgICAvLyBSUiBvciBSTCByb3JhcmlvblxyXG5cdFx0dmFyIHJyZGVwdGggPSB0aGlzLnJpZ2h0LnJpZ2h0ID09IG51bGwgPyAwIDogdGhpcy5yaWdodC5yaWdodC5kZXB0aDtcclxuXHRcdHZhciBybGRlcHRoID0gdGhpcy5yaWdodC5sZWZ0ICA9PSBudWxsID8gMCA6IHRoaXMucmlnaHQubGVmdC5kZXB0aDtcclxuXHJcbiAgICAgICAgaWYgKHJsZGVwdGggPiBycmRlcHRoKSB7XHJcbiAgICAgICAgICAgIC8vIFJSIHJvdGF0aW9uIGNvbnNpc3RzIG9mIGEgTEwgcm90YXRpb24gb2YgdGhlIHJpZ2h0IGNoaWxkXHJcbiAgICAgICAgICAgIHRoaXMucmlnaHQucm90YXRlTEwoKTtcclxuICAgICAgICAgICAgLy8gcGx1cyBhIFJSIHJvdGF0aW9uIG9mIHRoaXMgbm9kZSwgd2hpY2ggaGFwcGVucyBhbnl3YXlcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yb3RhdGVSUigpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQVZMVHJlZS5wcm90b3R5cGUucm90YXRlTEwgPSBmdW5jdGlvbigpIHtcclxuICAgIC8vIHRoZSBsZWZ0IHNpZGUgaXMgdG9vIGxvbmcgPT4gcm90YXRlIGZyb20gdGhlIGxlZnQgKF9ub3RfIGxlZnR3YXJkcylcclxuICAgIHZhciBub2RlQmVmb3JlID0gdGhpcy5ub2RlO1xyXG4gICAgdmFyIHJpZ2h0QmVmb3JlID0gdGhpcy5yaWdodDtcclxuICAgIHRoaXMubm9kZSA9IHRoaXMubGVmdC5ub2RlO1xyXG4gICAgdGhpcy5yaWdodCA9IHRoaXMubGVmdDtcclxuICAgIHRoaXMubGVmdCA9IHRoaXMubGVmdC5sZWZ0O1xyXG4gICAgdGhpcy5yaWdodC5sZWZ0ID0gdGhpcy5yaWdodC5yaWdodDtcclxuICAgIHRoaXMucmlnaHQucmlnaHQgPSByaWdodEJlZm9yZTtcclxuICAgIHRoaXMucmlnaHQubm9kZSA9IG5vZGVCZWZvcmU7XHJcbiAgICB0aGlzLnJpZ2h0LnVwZGF0ZUluTmV3TG9jYXRpb24oKTtcclxuICAgIHRoaXMudXBkYXRlSW5OZXdMb2NhdGlvbigpO1xyXG59O1xyXG5cclxuQVZMVHJlZS5wcm90b3R5cGUucm90YXRlUlIgPSBmdW5jdGlvbigpIHtcclxuICAgIC8vIHRoZSByaWdodCBzaWRlIGlzIHRvbyBsb25nID0+IHJvdGF0ZSBmcm9tIHRoZSByaWdodCAoX25vdF8gcmlnaHR3YXJkcylcclxuICAgIHZhciBub2RlQmVmb3JlID0gdGhpcy5ub2RlO1xyXG4gICAgdmFyIGxlZnRCZWZvcmUgPSB0aGlzLmxlZnQ7XHJcbiAgICB0aGlzLm5vZGUgPSB0aGlzLnJpZ2h0Lm5vZGU7XHJcbiAgICB0aGlzLmxlZnQgPSB0aGlzLnJpZ2h0O1xyXG4gICAgdGhpcy5yaWdodCA9IHRoaXMucmlnaHQucmlnaHQ7XHJcbiAgICB0aGlzLmxlZnQucmlnaHQgPSB0aGlzLmxlZnQubGVmdDtcclxuICAgIHRoaXMubGVmdC5sZWZ0ID0gbGVmdEJlZm9yZTtcclxuICAgIHRoaXMubGVmdC5ub2RlID0gbm9kZUJlZm9yZTtcclxuICAgIHRoaXMubGVmdC51cGRhdGVJbk5ld0xvY2F0aW9uKCk7XHJcbiAgICB0aGlzLnVwZGF0ZUluTmV3TG9jYXRpb24oKTtcclxufTtcclxuXHJcbkFWTFRyZWUucHJvdG90eXBlLnVwZGF0ZUluTmV3TG9jYXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuZ2V0RGVwdGhGcm9tQ2hpbGRyZW4oKTtcclxufTtcclxuXHJcbkFWTFRyZWUucHJvdG90eXBlLmdldERlcHRoRnJvbUNoaWxkcmVuID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmRlcHRoID0gdGhpcy5ub2RlID09IG51bGwgPyAwIDogMTtcclxuICAgIGlmICh0aGlzLmxlZnQgIT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuZGVwdGggPSB0aGlzLmxlZnQuZGVwdGggKyAxO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMucmlnaHQgIT0gbnVsbCAmJiB0aGlzLmRlcHRoIDw9IHRoaXMucmlnaHQuZGVwdGgpIHtcclxuICAgICAgICB0aGlzLmRlcHRoID0gdGhpcy5yaWdodC5kZXB0aCArIDE7XHJcbiAgICB9XHJcbn07XHJcblxyXG5BVkxUcmVlLnByb3RvdHlwZS5vcmRlciA9IGZ1bmN0aW9uKG4xLCBuMikge1xyXG5cdGlmIChuMSA9PT0gbjIpIHtcclxuXHRcdHJldHVybiAwO1xyXG5cdH1cclxuXHR2YXIgZDEgPSAwO1xyXG5cdHZhciBkMiA9IDA7XHJcblx0Zm9yICh2YXIgbTEgPSBuMTsgbTEgIT0gbnVsbDsgbTEgPSBtMS5wYXJlbnROb2RlKSB7XHJcblx0XHRkMSsrO1xyXG5cdH1cclxuXHRmb3IgKHZhciBtMiA9IG4yOyBtMiAhPSBudWxsOyBtMiA9IG0yLnBhcmVudE5vZGUpIHtcclxuXHRcdGQyKys7XHJcblx0fVxyXG5cdGlmIChkMSA+IGQyKSB7XHJcblx0XHR3aGlsZSAoZDEgPiBkMikge1xyXG5cdFx0XHRuMSA9IG4xLnBhcmVudE5vZGU7XHJcblx0XHRcdGQxLS07XHJcblx0XHR9XHJcblx0XHRpZiAobjEgPT0gbjIpIHtcclxuXHRcdFx0cmV0dXJuIDE7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmIChkMiA+IGQxKSB7XHJcblx0XHR3aGlsZSAoZDIgPiBkMSkge1xyXG5cdFx0XHRuMiA9IG4yLnBhcmVudE5vZGU7XHJcblx0XHRcdGQyLS07XHJcblx0XHR9XHJcblx0XHRpZiAobjEgPT0gbjIpIHtcclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0fVxyXG5cdH1cclxuXHR3aGlsZSAobjEucGFyZW50Tm9kZSAhPSBuMi5wYXJlbnROb2RlKSB7XHJcblx0XHRuMSA9IG4xLnBhcmVudE5vZGU7XHJcblx0XHRuMiA9IG4yLnBhcmVudE5vZGU7XHJcblx0fVxyXG5cdHdoaWxlIChuMS5wcmV2aW91c1NpYmxpbmcgIT0gbnVsbCAmJiBuMi5wcmV2aW91c1NpYmxpbmcgIT0gbnVsbCkge1xyXG5cdFx0bjEgPSBuMS5wcmV2aW91c1NpYmxpbmc7XHJcblx0XHRuMiA9IG4yLnByZXZpb3VzU2libGluZztcclxuXHR9XHJcblx0aWYgKG4xLnByZXZpb3VzU2libGluZyA9PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fVxyXG5cdHJldHVybiAxO1xyXG59O1xyXG5cclxuQVZMVHJlZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obikgIHtcclxuXHRpZiAobiA9PT0gdGhpcy5ub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuXHR2YXIgbyA9IHRoaXMub3JkZXIobiwgdGhpcy5ub2RlKTtcclxuXHJcbiAgICB2YXIgcmV0ID0gZmFsc2U7XHJcbiAgICBpZiAobyA9PSAtMSkge1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBuZXcgQVZMVHJlZShuKTtcclxuICAgICAgICAgICAgcmV0ID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXQgPSB0aGlzLmxlZnQuYWRkKG4pO1xyXG4gICAgICAgICAgICBpZiAocmV0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhbGFuY2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobyA9PSAxKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gbmV3IEFWTFRyZWUobik7XHJcbiAgICAgICAgICAgIHJldCA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0ID0gdGhpcy5yaWdodC5hZGQobik7XHJcbiAgICAgICAgICAgIGlmIChyZXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmFsYW5jZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChyZXQpIHtcclxuICAgICAgICB0aGlzLmdldERlcHRoRnJvbUNoaWxkcmVuKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59O1xyXG5cclxuLy8gWE5vZGVTZXQgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUgPSBuZXcgRXhwcmVzc2lvbigpO1xyXG5YTm9kZVNldC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBYTm9kZVNldDtcclxuWE5vZGVTZXQuc3VwZXJjbGFzcyA9IEV4cHJlc3Npb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gWE5vZGVTZXQoKSB7XHJcblx0dGhpcy5pbml0KCk7XHJcbn1cclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy50cmVlID0gbnVsbDtcclxuXHR0aGlzLnNpemUgPSAwO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIHAgPSB0aGlzLmZpcnN0KCk7XHJcblx0aWYgKHAgPT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIFwiXCI7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLnN0cmluZ0Zvck5vZGUocCk7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBYU3RyaW5nKHRoaXMudG9TdHJpbmcoKSk7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuc3RyaW5nVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLm51bWJlciA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgWE51bWJlcih0aGlzLnN0cmluZygpKTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5udW1iZXJWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBOdW1iZXIodGhpcy5zdHJpbmcoKSk7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4odGhpcy50cmVlICE9IG51bGwpO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLmJvb2xlYW5WYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLnRyZWUgIT0gbnVsbDtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5ub2Rlc2V0ID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuc3RyaW5nRm9yTm9kZSA9IGZ1bmN0aW9uKG4pIHtcclxuXHRpZiAobi5ub2RlVHlwZSA9PSA5IC8qTm9kZS5ET0NVTUVOVF9OT0RFKi8pIHtcclxuXHRcdG4gPSBuLmRvY3VtZW50RWxlbWVudDtcclxuXHR9XHJcblx0aWYgKG4ubm9kZVR5cGUgPT0gMSAvKk5vZGUuRUxFTUVOVF9OT0RFKi8pIHtcclxuXHRcdHJldHVybiB0aGlzLnN0cmluZ0Zvck5vZGVSZWMobik7XHJcblx0fVxyXG5cdGlmIChuLmlzTmFtZXNwYWNlTm9kZSkge1xyXG5cdFx0cmV0dXJuIG4ubmFtZXNwYWNlO1xyXG5cdH1cclxuXHRyZXR1cm4gbi5ub2RlVmFsdWU7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuc3RyaW5nRm9yTm9kZVJlYyA9IGZ1bmN0aW9uKG4pIHtcclxuXHR2YXIgcyA9IFwiXCI7XHJcblx0Zm9yICh2YXIgbjIgPSBuLmZpcnN0Q2hpbGQ7IG4yICE9IG51bGw7IG4yID0gbjIubmV4dFNpYmxpbmcpIHtcclxuXHRcdGlmIChuMi5ub2RlVHlwZSA9PSAzIC8qTm9kZS5URVhUX05PREUqLykge1xyXG5cdFx0XHRzICs9IG4yLm5vZGVWYWx1ZTtcclxuXHRcdH0gZWxzZSBpZiAobjIubm9kZVR5cGUgPT0gMSAvKk5vZGUuRUxFTUVOVF9OT0RFKi8pIHtcclxuXHRcdFx0cyArPSB0aGlzLnN0cmluZ0Zvck5vZGVSZWMobjIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcztcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5maXJzdCA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBwID0gdGhpcy50cmVlO1xyXG5cdGlmIChwID09IG51bGwpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHR3aGlsZSAocC5sZWZ0ICE9IG51bGwpIHtcclxuXHRcdHAgPSBwLmxlZnQ7XHJcblx0fVxyXG5cdHJldHVybiBwLm5vZGU7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obikge1xyXG4gICAgdmFyIGFkZGVkO1xyXG4gICAgaWYgKHRoaXMudHJlZSA9PSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy50cmVlID0gbmV3IEFWTFRyZWUobik7XHJcbiAgICAgICAgYWRkZWQgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBhZGRlZCA9IHRoaXMudHJlZS5hZGQobik7XHJcbiAgICB9XHJcbiAgICBpZiAoYWRkZWQpIHtcclxuICAgICAgICB0aGlzLnNpemUrKztcclxuICAgIH1cclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5hZGRBcnJheSA9IGZ1bmN0aW9uKG5zKSB7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBucy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dGhpcy5hZGQobnNbaV0pO1xyXG5cdH1cclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGEgPSBbXTtcclxuXHR0aGlzLnRvQXJyYXlSZWModGhpcy50cmVlLCBhKTtcclxuXHRyZXR1cm4gYTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS50b0FycmF5UmVjID0gZnVuY3Rpb24odCwgYSkge1xyXG5cdGlmICh0ICE9IG51bGwpIHtcclxuXHRcdHRoaXMudG9BcnJheVJlYyh0LmxlZnQsIGEpO1xyXG5cdFx0YS5wdXNoKHQubm9kZSk7XHJcblx0XHR0aGlzLnRvQXJyYXlSZWModC5yaWdodCwgYSk7XHJcblx0fVxyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLmNvbXBhcmVXaXRoU3RyaW5nID0gZnVuY3Rpb24ociwgbykge1xyXG5cdHZhciBhID0gdGhpcy50b0FycmF5KCk7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgbiA9IGFbaV07XHJcblx0XHR2YXIgbCA9IG5ldyBYU3RyaW5nKHRoaXMuc3RyaW5nRm9yTm9kZShuKSk7XHJcblx0XHR2YXIgcmVzID0gbyhsLCByKTtcclxuXHRcdGlmIChyZXMuYm9vbGVhblZhbHVlKCkpIHtcclxuXHRcdFx0cmV0dXJuIHJlcztcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbihmYWxzZSk7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuY29tcGFyZVdpdGhOdW1iZXIgPSBmdW5jdGlvbihyLCBvKSB7XHJcblx0dmFyIGEgPSB0aGlzLnRvQXJyYXkoKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBuID0gYVtpXTtcclxuXHRcdHZhciBsID0gbmV3IFhOdW1iZXIodGhpcy5zdHJpbmdGb3JOb2RlKG4pKTtcclxuXHRcdHZhciByZXMgPSBvKGwsIHIpO1xyXG5cdFx0aWYgKHJlcy5ib29sZWFuVmFsdWUoKSkge1xyXG5cdFx0XHRyZXR1cm4gcmVzO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKGZhbHNlKTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5jb21wYXJlV2l0aEJvb2xlYW4gPSBmdW5jdGlvbihyLCBvKSB7XHJcblx0cmV0dXJuIG8odGhpcy5ib29sKCksIHIpO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLmNvbXBhcmVXaXRoTm9kZVNldCA9IGZ1bmN0aW9uKHIsIG8pIHtcclxuXHR2YXIgYSA9IHRoaXMudG9BcnJheSgpO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIG4gPSBhW2ldO1xyXG5cdFx0dmFyIGwgPSBuZXcgWFN0cmluZyh0aGlzLnN0cmluZ0Zvck5vZGUobikpO1xyXG5cdFx0dmFyIGIgPSByLnRvQXJyYXkoKTtcclxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgYi5sZW5ndGg7IGorKykge1xyXG5cdFx0XHR2YXIgbjIgPSBiW2pdO1xyXG5cdFx0XHR2YXIgciA9IG5ldyBYU3RyaW5nKHRoaXMuc3RyaW5nRm9yTm9kZShuMikpO1xyXG5cdFx0XHR2YXIgcmVzID0gbyhsLCByKTtcclxuXHRcdFx0aWYgKHJlcy5ib29sZWFuVmFsdWUoKSkge1xyXG5cdFx0XHRcdHJldHVybiByZXM7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbihmYWxzZSk7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWFN0cmluZykpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoU3RyaW5nKHIsIE9wZXJhdG9ycy5lcXVhbHMpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOdW1iZXIpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE51bWJlcihyLCBPcGVyYXRvcnMuZXF1YWxzKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYQm9vbGVhbikpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoQm9vbGVhbihyLCBPcGVyYXRvcnMuZXF1YWxzKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOb2RlU2V0KHIsIE9wZXJhdG9ycy5lcXVhbHMpO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLm5vdGVxdWFsID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWFN0cmluZykpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoU3RyaW5nKHIsIE9wZXJhdG9ycy5ub3RlcXVhbCk7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE51bWJlcikpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoTnVtYmVyKHIsIE9wZXJhdG9ycy5ub3RlcXVhbCk7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWEJvb2xlYW4pKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aEJvb2xlYW4ociwgT3BlcmF0b3JzLm5vdGVxdWFsKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOb2RlU2V0KHIsIE9wZXJhdG9ycy5ub3RlcXVhbCk7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUubGVzc3RoYW4gPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYU3RyaW5nKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOdW1iZXIoci5udW1iZXIoKSwgT3BlcmF0b3JzLmxlc3N0aGFuKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTnVtYmVyKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOdW1iZXIociwgT3BlcmF0b3JzLmxlc3N0aGFuKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYQm9vbGVhbikpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoQm9vbGVhbihyLCBPcGVyYXRvcnMubGVzc3RoYW4pO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE5vZGVTZXQociwgT3BlcmF0b3JzLmxlc3N0aGFuKTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5ncmVhdGVydGhhbiA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhTdHJpbmcpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE51bWJlcihyLm51bWJlcigpLCBPcGVyYXRvcnMuZ3JlYXRlcnRoYW4pO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOdW1iZXIpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE51bWJlcihyLCBPcGVyYXRvcnMuZ3JlYXRlcnRoYW4pO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhCb29sZWFuKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhCb29sZWFuKHIsIE9wZXJhdG9ycy5ncmVhdGVydGhhbik7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoTm9kZVNldChyLCBPcGVyYXRvcnMuZ3JlYXRlcnRoYW4pO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLmxlc3N0aGFub3JlcXVhbCA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhTdHJpbmcpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE51bWJlcihyLm51bWJlcigpLCBPcGVyYXRvcnMubGVzc3RoYW5vcmVxdWFsKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTnVtYmVyKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOdW1iZXIociwgT3BlcmF0b3JzLmxlc3N0aGFub3JlcXVhbCk7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWEJvb2xlYW4pKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aEJvb2xlYW4ociwgT3BlcmF0b3JzLmxlc3N0aGFub3JlcXVhbCk7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoTm9kZVNldChyLCBPcGVyYXRvcnMubGVzc3RoYW5vcmVxdWFsKTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5ncmVhdGVydGhhbm9yZXF1YWwgPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYU3RyaW5nKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOdW1iZXIoci5udW1iZXIoKSwgT3BlcmF0b3JzLmdyZWF0ZXJ0aGFub3JlcXVhbCk7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE51bWJlcikpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoTnVtYmVyKHIsIE9wZXJhdG9ycy5ncmVhdGVydGhhbm9yZXF1YWwpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhCb29sZWFuKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhCb29sZWFuKHIsIE9wZXJhdG9ycy5ncmVhdGVydGhhbm9yZXF1YWwpO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE5vZGVTZXQociwgT3BlcmF0b3JzLmdyZWF0ZXJ0aGFub3JlcXVhbCk7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbihyKSB7XHJcblx0dmFyIG5zID0gbmV3IFhOb2RlU2V0KCk7XHJcblx0bnMudHJlZSA9IHRoaXMudHJlZTtcclxuXHRucy5zaXplID0gdGhpcy5zaXplO1xyXG5cdG5zLmFkZEFycmF5KHIudG9BcnJheSgpKTtcclxuXHRyZXR1cm4gbnM7XHJcbn07XHJcblxyXG4vLyBYUGF0aE5hbWVzcGFjZSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblhQYXRoTmFtZXNwYWNlLnByb3RvdHlwZSA9IG5ldyBPYmplY3QoKTtcclxuWFBhdGhOYW1lc3BhY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWFBhdGhOYW1lc3BhY2U7XHJcblhQYXRoTmFtZXNwYWNlLnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gWFBhdGhOYW1lc3BhY2UocHJlLCBucywgcCkge1xyXG5cdHRoaXMuaXNYUGF0aE5hbWVzcGFjZSA9IHRydWU7XHJcblx0dGhpcy5vd25lckRvY3VtZW50ID0gcC5vd25lckRvY3VtZW50O1xyXG5cdHRoaXMubm9kZU5hbWUgPSBcIiNuYW1lc3BhY2VcIjtcclxuXHR0aGlzLnByZWZpeCA9IHByZTtcclxuXHR0aGlzLmxvY2FsTmFtZSA9IHByZTtcclxuXHR0aGlzLm5hbWVzcGFjZVVSSSA9IG5zO1xyXG5cdHRoaXMubm9kZVZhbHVlID0gbnM7XHJcblx0dGhpcy5vd25lckVsZW1lbnQgPSBwO1xyXG5cdHRoaXMubm9kZVR5cGUgPSBYUGF0aE5hbWVzcGFjZS5YUEFUSF9OQU1FU1BBQ0VfTk9ERTtcclxufVxyXG5cclxuWFBhdGhOYW1lc3BhY2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwieyBcXFwiXCIgKyB0aGlzLnByZWZpeCArIFwiXFxcIiwgXFxcIlwiICsgdGhpcy5uYW1lc3BhY2VVUkkgKyBcIlxcXCIgfVwiO1xyXG59O1xyXG5cclxuLy8gT3BlcmF0b3JzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG52YXIgT3BlcmF0b3JzID0gbmV3IE9iamVjdCgpO1xyXG5cclxuT3BlcmF0b3JzLmVxdWFscyA9IGZ1bmN0aW9uKGwsIHIpIHtcclxuXHRyZXR1cm4gbC5lcXVhbHMocik7XHJcbn07XHJcblxyXG5PcGVyYXRvcnMubm90ZXF1YWwgPSBmdW5jdGlvbihsLCByKSB7XHJcblx0cmV0dXJuIGwubm90ZXF1YWwocik7XHJcbn07XHJcblxyXG5PcGVyYXRvcnMubGVzc3RoYW4gPSBmdW5jdGlvbihsLCByKSB7XHJcblx0cmV0dXJuIGwubGVzc3RoYW4ocik7XHJcbn07XHJcblxyXG5PcGVyYXRvcnMuZ3JlYXRlcnRoYW4gPSBmdW5jdGlvbihsLCByKSB7XHJcblx0cmV0dXJuIGwuZ3JlYXRlcnRoYW4ocik7XHJcbn07XHJcblxyXG5PcGVyYXRvcnMubGVzc3RoYW5vcmVxdWFsID0gZnVuY3Rpb24obCwgcikge1xyXG5cdHJldHVybiBsLmxlc3N0aGFub3JlcXVhbChyKTtcclxufTtcclxuXHJcbk9wZXJhdG9ycy5ncmVhdGVydGhhbm9yZXF1YWwgPSBmdW5jdGlvbihsLCByKSB7XHJcblx0cmV0dXJuIGwuZ3JlYXRlcnRoYW5vcmVxdWFsKHIpO1xyXG59O1xyXG5cclxuLy8gWFBhdGhDb250ZXh0IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5YUGF0aENvbnRleHQucHJvdG90eXBlID0gbmV3IE9iamVjdCgpO1xyXG5YUGF0aENvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWFBhdGhDb250ZXh0O1xyXG5YUGF0aENvbnRleHQuc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBYUGF0aENvbnRleHQodnIsIG5yLCBmcikge1xyXG5cdHRoaXMudmFyaWFibGVSZXNvbHZlciA9IHZyICE9IG51bGwgPyB2ciA6IG5ldyBWYXJpYWJsZVJlc29sdmVyKCk7XHJcblx0dGhpcy5uYW1lc3BhY2VSZXNvbHZlciA9IG5yICE9IG51bGwgPyBuciA6IG5ldyBOYW1lc3BhY2VSZXNvbHZlcigpO1xyXG5cdHRoaXMuZnVuY3Rpb25SZXNvbHZlciA9IGZyICE9IG51bGwgPyBmciA6IG5ldyBGdW5jdGlvblJlc29sdmVyKCk7XHJcbn1cclxuXHJcbi8vIFZhcmlhYmxlUmVzb2x2ZXIgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuVmFyaWFibGVSZXNvbHZlci5wcm90b3R5cGUgPSBuZXcgT2JqZWN0KCk7XHJcblZhcmlhYmxlUmVzb2x2ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVmFyaWFibGVSZXNvbHZlcjtcclxuVmFyaWFibGVSZXNvbHZlci5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFZhcmlhYmxlUmVzb2x2ZXIoKSB7XHJcbn1cclxuXHJcblZhcmlhYmxlUmVzb2x2ZXIucHJvdG90eXBlLmdldFZhcmlhYmxlID0gZnVuY3Rpb24odm4sIGMpIHtcclxuXHR2YXIgcGFydHMgPSBVdGlsaXRpZXMuc3BsaXRRTmFtZSh2bik7XHJcblx0aWYgKHBhcnRzWzBdICE9IG51bGwpIHtcclxuXHRcdHBhcnRzWzBdID0gYy5uYW1lc3BhY2VSZXNvbHZlci5nZXROYW1lc3BhY2UocGFydHNbMF0sIGMuZXhwcmVzc2lvbkNvbnRleHROb2RlKTtcclxuICAgICAgICBpZiAocGFydHNbMF0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBRTmFtZSBcIiArIGZuKTtcclxuICAgICAgICB9XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLmdldFZhcmlhYmxlV2l0aE5hbWUocGFydHNbMF0sIHBhcnRzWzFdLCBjLmV4cHJlc3Npb25Db250ZXh0Tm9kZSk7XHJcbn07XHJcblxyXG5WYXJpYWJsZVJlc29sdmVyLnByb3RvdHlwZS5nZXRWYXJpYWJsZVdpdGhOYW1lID0gZnVuY3Rpb24obnMsIGxuLCBjKSB7XHJcblx0cmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG4vLyBGdW5jdGlvblJlc29sdmVyIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbkZ1bmN0aW9uUmVzb2x2ZXIucHJvdG90eXBlID0gbmV3IE9iamVjdCgpO1xyXG5GdW5jdGlvblJlc29sdmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZ1bmN0aW9uUmVzb2x2ZXI7XHJcbkZ1bmN0aW9uUmVzb2x2ZXIuc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBGdW5jdGlvblJlc29sdmVyKHRoaXNBcmcpIHtcclxuXHR0aGlzLnRoaXNBcmcgPSB0aGlzQXJnICE9IG51bGwgPyB0aGlzQXJnIDogRnVuY3Rpb25zO1xyXG5cdHRoaXMuZnVuY3Rpb25zID0gbmV3IE9iamVjdCgpO1xyXG5cdHRoaXMuYWRkU3RhbmRhcmRGdW5jdGlvbnMoKTtcclxufVxyXG5cclxuRnVuY3Rpb25SZXNvbHZlci5wcm90b3R5cGUuYWRkU3RhbmRhcmRGdW5jdGlvbnMgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9bGFzdFwiXSA9IEZ1bmN0aW9ucy5sYXN0O1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31wb3NpdGlvblwiXSA9IEZ1bmN0aW9ucy5wb3NpdGlvbjtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9Y291bnRcIl0gPSBGdW5jdGlvbnMuY291bnQ7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fWlkXCJdID0gRnVuY3Rpb25zLmlkO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31sb2NhbC1uYW1lXCJdID0gRnVuY3Rpb25zLmxvY2FsTmFtZTtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9bmFtZXNwYWNlLXVyaVwiXSA9IEZ1bmN0aW9ucy5uYW1lc3BhY2VVUkk7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fW5hbWVcIl0gPSBGdW5jdGlvbnMubmFtZTtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9c3RyaW5nXCJdID0gRnVuY3Rpb25zLnN0cmluZztcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9Y29uY2F0XCJdID0gRnVuY3Rpb25zLmNvbmNhdDtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9c3RhcnRzLXdpdGhcIl0gPSBGdW5jdGlvbnMuc3RhcnRzV2l0aDtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9Y29udGFpbnNcIl0gPSBGdW5jdGlvbnMuY29udGFpbnM7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fXN1YnN0cmluZy1iZWZvcmVcIl0gPSBGdW5jdGlvbnMuc3Vic3RyaW5nQmVmb3JlO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31zdWJzdHJpbmctYWZ0ZXJcIl0gPSBGdW5jdGlvbnMuc3Vic3RyaW5nQWZ0ZXI7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fXN1YnN0cmluZ1wiXSA9IEZ1bmN0aW9ucy5zdWJzdHJpbmc7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fXN0cmluZy1sZW5ndGhcIl0gPSBGdW5jdGlvbnMuc3RyaW5nTGVuZ3RoO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31ub3JtYWxpemUtc3BhY2VcIl0gPSBGdW5jdGlvbnMubm9ybWFsaXplU3BhY2U7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fXRyYW5zbGF0ZVwiXSA9IEZ1bmN0aW9ucy50cmFuc2xhdGU7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fWJvb2xlYW5cIl0gPSBGdW5jdGlvbnMuYm9vbGVhbl87XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fW5vdFwiXSA9IEZ1bmN0aW9ucy5ub3Q7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fXRydWVcIl0gPSBGdW5jdGlvbnMudHJ1ZV87XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fWZhbHNlXCJdID0gRnVuY3Rpb25zLmZhbHNlXztcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9bGFuZ1wiXSA9IEZ1bmN0aW9ucy5sYW5nO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31udW1iZXJcIl0gPSBGdW5jdGlvbnMubnVtYmVyO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31zdW1cIl0gPSBGdW5jdGlvbnMuc3VtO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31mbG9vclwiXSA9IEZ1bmN0aW9ucy5mbG9vcjtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9Y2VpbGluZ1wiXSA9IEZ1bmN0aW9ucy5jZWlsaW5nO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31yb3VuZFwiXSA9IEZ1bmN0aW9ucy5yb3VuZDtcclxufTtcclxuXHJcbkZ1bmN0aW9uUmVzb2x2ZXIucHJvdG90eXBlLmFkZEZ1bmN0aW9uID0gZnVuY3Rpb24obnMsIGxuLCBmKSB7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7XCIgKyBucyArIFwifVwiICsgbG5dID0gZjtcclxufTtcclxuXHJcbkZ1bmN0aW9uUmVzb2x2ZXIucHJvdG90eXBlLmdldEZ1bmN0aW9uID0gZnVuY3Rpb24oZm4sIGMpIHtcclxuXHR2YXIgcGFydHMgPSBVdGlsaXRpZXMucmVzb2x2ZVFOYW1lKGZuLCBjLm5hbWVzcGFjZVJlc29sdmVyLCBjLmNvbnRleHROb2RlLCBmYWxzZSk7XHJcbiAgICBpZiAocGFydHNbMF0gPT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIFFOYW1lIFwiICsgZm4pO1xyXG4gICAgfVxyXG5cdHJldHVybiB0aGlzLmdldEZ1bmN0aW9uV2l0aE5hbWUocGFydHNbMF0sIHBhcnRzWzFdLCBjLmNvbnRleHROb2RlKTtcclxufTtcclxuXHJcbkZ1bmN0aW9uUmVzb2x2ZXIucHJvdG90eXBlLmdldEZ1bmN0aW9uV2l0aE5hbWUgPSBmdW5jdGlvbihucywgbG4sIGMpIHtcclxuXHRyZXR1cm4gdGhpcy5mdW5jdGlvbnNbXCJ7XCIgKyBucyArIFwifVwiICsgbG5dO1xyXG59O1xyXG5cclxuLy8gTmFtZXNwYWNlUmVzb2x2ZXIgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5OYW1lc3BhY2VSZXNvbHZlci5wcm90b3R5cGUgPSBuZXcgT2JqZWN0KCk7XHJcbk5hbWVzcGFjZVJlc29sdmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5hbWVzcGFjZVJlc29sdmVyO1xyXG5OYW1lc3BhY2VSZXNvbHZlci5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIE5hbWVzcGFjZVJlc29sdmVyKCkge1xyXG59XHJcblxyXG5OYW1lc3BhY2VSZXNvbHZlci5wcm90b3R5cGUuZ2V0TmFtZXNwYWNlID0gZnVuY3Rpb24ocHJlZml4LCBuKSB7XHJcblx0aWYgKHByZWZpeCA9PSBcInhtbFwiKSB7XHJcblx0XHRyZXR1cm4gWFBhdGguWE1MX05BTUVTUEFDRV9VUkk7XHJcblx0fSBlbHNlIGlmIChwcmVmaXggPT0gXCJ4bWxuc1wiKSB7XHJcblx0XHRyZXR1cm4gWFBhdGguWE1MTlNfTkFNRVNQQUNFX1VSSTtcclxuXHR9XHJcblx0aWYgKG4ubm9kZVR5cGUgPT0gOSAvKk5vZGUuRE9DVU1FTlRfTk9ERSovKSB7XHJcblx0XHRuID0gbi5kb2N1bWVudEVsZW1lbnQ7XHJcblx0fSBlbHNlIGlmIChuLm5vZGVUeXBlID09IDIgLypOb2RlLkFUVFJJQlVURV9OT0RFKi8pIHtcclxuXHRcdG4gPSBQYXRoRXhwci5wcm90b3R5cGUuZ2V0T3duZXJFbGVtZW50KG4pO1xyXG5cdH0gZWxzZSBpZiAobi5ub2RlVHlwZSAhPSAxIC8qTm9kZS5FTEVNRU5UX05PREUqLykge1xyXG5cdFx0biA9IG4ucGFyZW50Tm9kZTtcclxuXHR9XHJcblx0d2hpbGUgKG4gIT0gbnVsbCAmJiBuLm5vZGVUeXBlID09IDEgLypOb2RlLkVMRU1FTlRfTk9ERSovKSB7XHJcblx0XHR2YXIgbm5tID0gbi5hdHRyaWJ1dGVzO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBubm0ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGEgPSBubm0uaXRlbShpKTtcclxuXHRcdFx0dmFyIGFuYW1lID0gYS5ub2RlTmFtZTtcclxuXHRcdFx0aWYgKGFuYW1lID09IFwieG1sbnNcIiAmJiBwcmVmaXggPT0gXCJcIlxyXG5cdFx0XHRcdFx0fHwgYW5hbWUgPT0gXCJ4bWxuczpcIiArIHByZWZpeCkge1xyXG5cdFx0XHRcdHJldHVybiBTdHJpbmcoYS5ub2RlVmFsdWUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRuID0gbi5wYXJlbnROb2RlO1xyXG5cdH1cclxuXHRyZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8vIEZ1bmN0aW9ucyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuRnVuY3Rpb25zID0gbmV3IE9iamVjdCgpO1xyXG5cclxuRnVuY3Rpb25zLmxhc3QgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAxKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBsYXN0IGV4cGVjdHMgKClcIik7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWE51bWJlcihjLmNvbnRleHRTaXplKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5wb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIHBvc2l0aW9uIGV4cGVjdHMgKClcIik7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWE51bWJlcihjLmNvbnRleHRQb3NpdGlvbik7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMuY291bnQgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHR2YXIgbnM7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMiB8fCAhVXRpbGl0aWVzLmluc3RhbmNlX29mKG5zID0gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLCBYTm9kZVNldCkpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGNvdW50IGV4cGVjdHMgKG5vZGUtc2V0KVwiKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYTnVtYmVyKG5zLnNpemUpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLmlkID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0dmFyIGlkO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGlkIGV4cGVjdHMgKG9iamVjdClcIik7XHJcblx0fVxyXG5cdGlkID0gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpO1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YoaWQsIFhOb2RlU2V0KSkge1xyXG5cdFx0aWQgPSBpZC50b0FycmF5KCkuam9pbihcIiBcIik7XHJcblx0fSBlbHNlIHtcclxuXHRcdGlkID0gaWQuc3RyaW5nVmFsdWUoKTtcclxuXHR9XHJcblx0dmFyIGlkcyA9IGlkLnNwbGl0KC9bXFx4MGRcXHgwYVxceDA5XFx4MjBdKy8pO1xyXG5cdHZhciBjb3VudCA9IDA7XHJcblx0dmFyIG5zID0gbmV3IFhOb2RlU2V0KCk7XHJcblx0dmFyIGRvYyA9IGMuY29udGV4dE5vZGUubm9kZVR5cGUgPT0gOSAvKk5vZGUuRE9DVU1FTlRfTk9ERSovXHJcblx0XHRcdD8gYy5jb250ZXh0Tm9kZVxyXG5cdFx0XHQ6IGMuY29udGV4dE5vZGUub3duZXJEb2N1bWVudDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIG47XHJcblx0XHRpZiAoZG9jLmdldEVsZW1lbnRCeUlkKSB7XHJcblx0XHRcdG4gPSBkb2MuZ2V0RWxlbWVudEJ5SWQoaWRzW2ldKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG4gPSBVdGlsaXRpZXMuZ2V0RWxlbWVudEJ5SWQoZG9jLCBpZHNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0aWYgKG4gIT0gbnVsbCkge1xyXG5cdFx0XHRucy5hZGQobik7XHJcblx0XHRcdGNvdW50Kys7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBucztcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5sb2NhbE5hbWUgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHR2YXIgbjtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XHJcblx0XHRuID0gYy5jb250ZXh0Tm9kZTtcclxuXHR9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xyXG5cdFx0biA9IGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5maXJzdCgpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBsb2NhbC1uYW1lIGV4cGVjdHMgKG5vZGUtc2V0PylcIik7XHJcblx0fVxyXG5cdGlmIChuID09IG51bGwpIHtcclxuXHRcdHJldHVybiBuZXcgWFN0cmluZyhcIlwiKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYU3RyaW5nKG4ubG9jYWxOYW1lID8gbi5sb2NhbE5hbWUgOiBuLmJhc2VOYW1lKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5uYW1lc3BhY2VVUkkgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHR2YXIgbjtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XHJcblx0XHRuID0gYy5jb250ZXh0Tm9kZTtcclxuXHR9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xyXG5cdFx0biA9IGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5maXJzdCgpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBuYW1lc3BhY2UtdXJpIGV4cGVjdHMgKG5vZGUtc2V0PylcIik7XHJcblx0fVxyXG5cdGlmIChuID09IG51bGwpIHtcclxuXHRcdHJldHVybiBuZXcgWFN0cmluZyhcIlwiKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYU3RyaW5nKG4ubmFtZXNwYWNlVVJJKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5uYW1lID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0dmFyIG47XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xyXG5cdFx0biA9IGMuY29udGV4dE5vZGU7XHJcblx0fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcclxuXHRcdG4gPSBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykuZmlyc3QoKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gbmFtZSBleHBlY3RzIChub2RlLXNldD8pXCIpO1xyXG5cdH1cclxuXHRpZiAobiA9PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gbmV3IFhTdHJpbmcoXCJcIik7XHJcblx0fVxyXG5cdGlmIChuLm5vZGVUeXBlID09IDEgLypOb2RlLkVMRU1FTlRfTk9ERSovIHx8IG4ubm9kZVR5cGUgPT0gMiAvKk5vZGUuQVRUUklCVVRFX05PREUqLykge1xyXG5cdFx0cmV0dXJuIG5ldyBYU3RyaW5nKG4ubm9kZU5hbWUpO1xyXG5cdH0gZWxzZSBpZiAobi5sb2NhbE5hbWUgPT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIG5ldyBYU3RyaW5nKFwiXCIpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gbmV3IFhTdHJpbmcobi5sb2NhbE5hbWUpO1xyXG5cdH1cclxufTtcclxuXHJcbkZ1bmN0aW9ucy5zdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XHJcblx0XHRyZXR1cm4gWE5vZGVTZXQucHJvdG90eXBlLnN0cmluZ0Zvck5vZGUoYy5jb250ZXh0Tm9kZSk7XHJcblx0fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcclxuXHRcdHJldHVybiBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykuc3RyaW5nKCk7XHJcblx0fVxyXG5cdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIHN0cmluZyBleHBlY3RzIChvYmplY3Q/KVwiKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5jb25jYXQgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGNvbmNhdCBleHBlY3RzIChzdHJpbmcsIHN0cmluZywgc3RyaW5nKilcIik7XHJcblx0fVxyXG5cdHZhciBzID0gXCJcIjtcclxuXHRmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0cyArPSBhcmd1bWVudHNbaV0uZXZhbHVhdGUoYykuc3RyaW5nVmFsdWUoKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYU3RyaW5nKHMpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLnN0YXJ0c1dpdGggPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAzKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBzdGFydHNXaXRoIGV4cGVjdHMgKHN0cmluZywgc3RyaW5nKVwiKTtcclxuXHR9XHJcblx0dmFyIHMxID0gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLnN0cmluZ1ZhbHVlKCk7XHJcblx0dmFyIHMyID0gYXJndW1lbnRzWzJdLmV2YWx1YXRlKGMpLnN0cmluZ1ZhbHVlKCk7XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbihzMS5zdWJzdHJpbmcoMCwgczIubGVuZ3RoKSA9PSBzMik7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMuY29udGFpbnMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAzKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBjb250YWlucyBleHBlY3RzIChzdHJpbmcsIHN0cmluZylcIik7XHJcblx0fVxyXG5cdHZhciBzMSA9IGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdHZhciBzMiA9IGFyZ3VtZW50c1syXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4oczEuaW5kZXhPZihzMikgIT0gLTEpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLnN1YnN0cmluZ0JlZm9yZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDMpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIHN1YnN0cmluZy1iZWZvcmUgZXhwZWN0cyAoc3RyaW5nLCBzdHJpbmcpXCIpO1xyXG5cdH1cclxuXHR2YXIgczEgPSBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykuc3RyaW5nVmFsdWUoKTtcclxuXHR2YXIgczIgPSBhcmd1bWVudHNbMl0uZXZhbHVhdGUoYykuc3RyaW5nVmFsdWUoKTtcclxuXHRyZXR1cm4gbmV3IFhTdHJpbmcoczEuc3Vic3RyaW5nKDAsIHMxLmluZGV4T2YoczIpKSk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMuc3Vic3RyaW5nQWZ0ZXIgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAzKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBzdWJzdHJpbmctYWZ0ZXIgZXhwZWN0cyAoc3RyaW5nLCBzdHJpbmcpXCIpO1xyXG5cdH1cclxuXHR2YXIgczEgPSBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykuc3RyaW5nVmFsdWUoKTtcclxuXHR2YXIgczIgPSBhcmd1bWVudHNbMl0uZXZhbHVhdGUoYykuc3RyaW5nVmFsdWUoKTtcclxuXHRpZiAoczIubGVuZ3RoID09IDApIHtcclxuXHRcdHJldHVybiBuZXcgWFN0cmluZyhzMSk7XHJcblx0fVxyXG5cdHZhciBpID0gczEuaW5kZXhPZihzMik7XHJcblx0aWYgKGkgPT0gLTEpIHtcclxuXHRcdHJldHVybiBuZXcgWFN0cmluZyhcIlwiKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYU3RyaW5nKHMxLnN1YnN0cmluZyhzMS5pbmRleE9mKHMyKSArIDEpKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5zdWJzdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoIShhcmd1bWVudHMubGVuZ3RoID09IDMgfHwgYXJndW1lbnRzLmxlbmd0aCA9PSA0KSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gc3Vic3RyaW5nIGV4cGVjdHMgKHN0cmluZywgbnVtYmVyLCBudW1iZXI/KVwiKTtcclxuXHR9XHJcblx0dmFyIHMgPSBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykuc3RyaW5nVmFsdWUoKTtcclxuXHR2YXIgbjEgPSBNYXRoLnJvdW5kKGFyZ3VtZW50c1syXS5ldmFsdWF0ZShjKS5udW1iZXJWYWx1ZSgpKSAtIDE7XHJcblx0dmFyIG4yID0gYXJndW1lbnRzLmxlbmd0aCA9PSA0ID8gbjEgKyBNYXRoLnJvdW5kKGFyZ3VtZW50c1szXS5ldmFsdWF0ZShjKS5udW1iZXJWYWx1ZSgpKSA6IHVuZGVmaW5lZDtcclxuXHRyZXR1cm4gbmV3IFhTdHJpbmcocy5zdWJzdHJpbmcobjEsIG4yKSk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMuc3RyaW5nTGVuZ3RoID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0dmFyIHM7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xyXG5cdFx0cyA9IFhOb2RlU2V0LnByb3RvdHlwZS5zdHJpbmdGb3JOb2RlKGMuY29udGV4dE5vZGUpO1xyXG5cdH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XHJcblx0XHRzID0gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLnN0cmluZ1ZhbHVlKCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIHN0cmluZy1sZW5ndGggZXhwZWN0cyAoc3RyaW5nPylcIik7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWE51bWJlcihzLmxlbmd0aCk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMubm9ybWFsaXplU3BhY2UgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHR2YXIgcztcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XHJcblx0XHRzID0gWE5vZGVTZXQucHJvdG90eXBlLnN0cmluZ0Zvck5vZGUoYy5jb250ZXh0Tm9kZSk7XHJcblx0fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcclxuXHRcdHMgPSBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykuc3RyaW5nVmFsdWUoKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gbm9ybWFsaXplLXNwYWNlIGV4cGVjdHMgKHN0cmluZz8pXCIpO1xyXG5cdH1cclxuXHR2YXIgaSA9IDA7XHJcblx0dmFyIGogPSBzLmxlbmd0aCAtIDE7XHJcblx0d2hpbGUgKFV0aWxpdGllcy5pc1NwYWNlKHMuY2hhckNvZGVBdChqKSkpIHtcclxuXHRcdGotLTtcclxuXHR9XHJcblx0dmFyIHQgPSBcIlwiO1xyXG5cdHdoaWxlIChpIDw9IGogJiYgVXRpbGl0aWVzLmlzU3BhY2Uocy5jaGFyQ29kZUF0KGkpKSkge1xyXG5cdFx0aSsrO1xyXG5cdH1cclxuXHR3aGlsZSAoaSA8PSBqKSB7XHJcblx0XHRpZiAoVXRpbGl0aWVzLmlzU3BhY2Uocy5jaGFyQ29kZUF0KGkpKSkge1xyXG5cdFx0XHR0ICs9IFwiIFwiO1xyXG5cdFx0XHR3aGlsZSAoaSA8PSBqICYmIFV0aWxpdGllcy5pc1NwYWNlKHMuY2hhckNvZGVBdChpKSkpIHtcclxuXHRcdFx0XHRpKys7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHQgKz0gcy5jaGFyQXQoaSk7XHJcblx0XHRcdGkrKztcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYU3RyaW5nKHQpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDQpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIHRyYW5zbGF0ZSBleHBlY3RzIChzdHJpbmcsIHN0cmluZywgc3RyaW5nKVwiKTtcclxuXHR9XHJcblx0dmFyIHMxID0gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLnN0cmluZ1ZhbHVlKCk7XHJcblx0dmFyIHMyID0gYXJndW1lbnRzWzJdLmV2YWx1YXRlKGMpLnN0cmluZ1ZhbHVlKCk7XHJcblx0dmFyIHMzID0gYXJndW1lbnRzWzNdLmV2YWx1YXRlKGMpLnN0cmluZ1ZhbHVlKCk7XHJcblx0dmFyIG1hcCA9IFtdO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgczIubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBqID0gczIuY2hhckNvZGVBdChpKTtcclxuXHRcdGlmIChtYXBbal0gPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHZhciBrID0gaSA+IHMzLmxlbmd0aCA/IFwiXCIgOiBzMy5jaGFyQXQoaSk7XHJcblx0XHRcdG1hcFtqXSA9IGs7XHJcblx0XHR9XHJcblx0fVxyXG5cdHZhciB0ID0gXCJcIjtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHMxLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgYyA9IHMxLmNoYXJDb2RlQXQoaSk7XHJcblx0XHR2YXIgciA9IG1hcFtjXTtcclxuXHRcdGlmIChyID09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0ICs9IHMxLmNoYXJBdChpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHQgKz0gcjtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYU3RyaW5nKHQpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLmJvb2xlYW5fID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMikge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gYm9vbGVhbiBleHBlY3RzIChvYmplY3QpXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLmJvb2woKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5ub3QgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBub3QgZXhwZWN0cyAob2JqZWN0KVwiKTtcclxuXHR9XHJcblx0cmV0dXJuIGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5ib29sKCkubm90KCk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMudHJ1ZV8gPSBmdW5jdGlvbigpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAxKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiB0cnVlIGV4cGVjdHMgKClcIik7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4odHJ1ZSk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMuZmFsc2VfID0gZnVuY3Rpb24oKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gZmFsc2UgZXhwZWN0cyAoKVwiKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbihmYWxzZSk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMubGFuZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGxhbmcgZXhwZWN0cyAoc3RyaW5nKVwiKTtcclxuXHR9XHJcblx0dmFyIGxhbmc7XHJcblx0Zm9yICh2YXIgbiA9IGMuY29udGV4dE5vZGU7IG4gIT0gbnVsbCAmJiBuLm5vZGVUeXBlICE9IDkgLypOb2RlLkRPQ1VNRU5UX05PREUqLzsgbiA9IG4ucGFyZW50Tm9kZSkge1xyXG5cdFx0dmFyIGEgPSBuLmdldEF0dHJpYnV0ZU5TKFhQYXRoLlhNTF9OQU1FU1BBQ0VfVVJJLCBcImxhbmdcIik7XHJcblx0XHRpZiAoYSAhPSBudWxsKSB7XHJcblx0XHRcdGxhbmcgPSBTdHJpbmcoYSk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAobGFuZyA9PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gbmV3IFhCb29sZWFuKGZhbHNlKTtcclxuXHR9XHJcblx0dmFyIHMgPSBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykuc3RyaW5nVmFsdWUoKTtcclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKGxhbmcuc3Vic3RyaW5nKDAsIHMubGVuZ3RoKSA9PSBzXHJcblx0XHRcdFx0JiYgKGxhbmcubGVuZ3RoID09IHMubGVuZ3RoIHx8IGxhbmcuY2hhckF0KHMubGVuZ3RoKSA9PSAnLScpKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5udW1iZXIgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoIShhcmd1bWVudHMubGVuZ3RoID09IDEgfHwgYXJndW1lbnRzLmxlbmd0aCA9PSAyKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gbnVtYmVyIGV4cGVjdHMgKG9iamVjdD8pXCIpO1xyXG5cdH1cclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XHJcblx0XHRyZXR1cm4gbmV3IFhOdW1iZXIoWE5vZGVTZXQucHJvdG90eXBlLnN0cmluZ0Zvck5vZGUoYy5jb250ZXh0Tm9kZSkpO1xyXG5cdH1cclxuXHRyZXR1cm4gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLm51bWJlcigpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLnN1bSA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdHZhciBucztcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyIHx8ICFVdGlsaXRpZXMuaW5zdGFuY2Vfb2YoKG5zID0gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpKSwgWE5vZGVTZXQpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBzdW0gZXhwZWN0cyAobm9kZS1zZXQpXCIpO1xyXG5cdH1cclxuXHRucyA9IG5zLnRvQXJyYXkoKTtcclxuXHR2YXIgbiA9IDA7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBucy5sZW5ndGg7IGkrKykge1xyXG5cdFx0biArPSBuZXcgWE51bWJlcihYTm9kZVNldC5wcm90b3R5cGUuc3RyaW5nRm9yTm9kZShuc1tpXSkpLm51bWJlclZhbHVlKCk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWE51bWJlcihuKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5mbG9vciA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGZsb29yIGV4cGVjdHMgKG51bWJlcilcIik7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWE51bWJlcihNYXRoLmZsb29yKGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5udW1iZXJWYWx1ZSgpKSk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMuY2VpbGluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGNlaWxpbmcgZXhwZWN0cyAobnVtYmVyKVwiKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYTnVtYmVyKE1hdGguY2VpbChhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykubnVtYmVyVmFsdWUoKSkpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLnJvdW5kID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMikge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gcm91bmQgZXhwZWN0cyAobnVtYmVyKVwiKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYTnVtYmVyKE1hdGgucm91bmQoYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLm51bWJlclZhbHVlKCkpKTtcclxufTtcclxuXHJcbi8vIFV0aWxpdGllcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuVXRpbGl0aWVzID0gbmV3IE9iamVjdCgpO1xyXG5cclxuVXRpbGl0aWVzLnNwbGl0UU5hbWUgPSBmdW5jdGlvbihxbikge1xyXG5cdHZhciBpID0gcW4uaW5kZXhPZihcIjpcIik7XHJcblx0aWYgKGkgPT0gLTEpIHtcclxuXHRcdHJldHVybiBbIG51bGwsIHFuIF07XHJcblx0fVxyXG5cdHJldHVybiBbIHFuLnN1YnN0cmluZygwLCBpKSwgcW4uc3Vic3RyaW5nKGkgKyAxKSBdO1xyXG59O1xyXG5cclxuVXRpbGl0aWVzLnJlc29sdmVRTmFtZSA9IGZ1bmN0aW9uKHFuLCBuciwgbiwgdXNlRGVmYXVsdCkge1xyXG5cdHZhciBwYXJ0cyA9IFV0aWxpdGllcy5zcGxpdFFOYW1lKHFuKTtcclxuXHRpZiAocGFydHNbMF0gIT0gbnVsbCkge1xyXG5cdFx0cGFydHNbMF0gPSBuci5nZXROYW1lc3BhY2UocGFydHNbMF0sIG4pO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRpZiAodXNlRGVmYXVsdCkge1xyXG5cdFx0XHRwYXJ0c1swXSA9IG5yLmdldE5hbWVzcGFjZShcIlwiLCBuKTtcclxuXHRcdFx0aWYgKHBhcnRzWzBdID09IG51bGwpIHtcclxuXHRcdFx0XHRwYXJ0c1swXSA9IFwiXCI7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHBhcnRzWzBdID0gXCJcIjtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHBhcnRzO1xyXG59O1xyXG5cclxuVXRpbGl0aWVzLmlzU3BhY2UgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIGMgPT0gMHg5IHx8IGMgPT0gMHhkIHx8IGMgPT0gMHhhIHx8IGMgPT0gMHgyMDtcclxufTtcclxuXHJcblV0aWxpdGllcy5pc0xldHRlciA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gYyA+PSAweDAwNDEgJiYgYyA8PSAweDAwNUEgfHxcclxuXHRcdGMgPj0gMHgwMDYxICYmIGMgPD0gMHgwMDdBIHx8XHJcblx0XHRjID49IDB4MDBDMCAmJiBjIDw9IDB4MDBENiB8fFxyXG5cdFx0YyA+PSAweDAwRDggJiYgYyA8PSAweDAwRjYgfHxcclxuXHRcdGMgPj0gMHgwMEY4ICYmIGMgPD0gMHgwMEZGIHx8XHJcblx0XHRjID49IDB4MDEwMCAmJiBjIDw9IDB4MDEzMSB8fFxyXG5cdFx0YyA+PSAweDAxMzQgJiYgYyA8PSAweDAxM0UgfHxcclxuXHRcdGMgPj0gMHgwMTQxICYmIGMgPD0gMHgwMTQ4IHx8XHJcblx0XHRjID49IDB4MDE0QSAmJiBjIDw9IDB4MDE3RSB8fFxyXG5cdFx0YyA+PSAweDAxODAgJiYgYyA8PSAweDAxQzMgfHxcclxuXHRcdGMgPj0gMHgwMUNEICYmIGMgPD0gMHgwMUYwIHx8XHJcblx0XHRjID49IDB4MDFGNCAmJiBjIDw9IDB4MDFGNSB8fFxyXG5cdFx0YyA+PSAweDAxRkEgJiYgYyA8PSAweDAyMTcgfHxcclxuXHRcdGMgPj0gMHgwMjUwICYmIGMgPD0gMHgwMkE4IHx8XHJcblx0XHRjID49IDB4MDJCQiAmJiBjIDw9IDB4MDJDMSB8fFxyXG5cdFx0YyA9PSAweDAzODYgfHxcclxuXHRcdGMgPj0gMHgwMzg4ICYmIGMgPD0gMHgwMzhBIHx8XHJcblx0XHRjID09IDB4MDM4QyB8fFxyXG5cdFx0YyA+PSAweDAzOEUgJiYgYyA8PSAweDAzQTEgfHxcclxuXHRcdGMgPj0gMHgwM0EzICYmIGMgPD0gMHgwM0NFIHx8XHJcblx0XHRjID49IDB4MDNEMCAmJiBjIDw9IDB4MDNENiB8fFxyXG5cdFx0YyA9PSAweDAzREEgfHxcclxuXHRcdGMgPT0gMHgwM0RDIHx8XHJcblx0XHRjID09IDB4MDNERSB8fFxyXG5cdFx0YyA9PSAweDAzRTAgfHxcclxuXHRcdGMgPj0gMHgwM0UyICYmIGMgPD0gMHgwM0YzIHx8XHJcblx0XHRjID49IDB4MDQwMSAmJiBjIDw9IDB4MDQwQyB8fFxyXG5cdFx0YyA+PSAweDA0MEUgJiYgYyA8PSAweDA0NEYgfHxcclxuXHRcdGMgPj0gMHgwNDUxICYmIGMgPD0gMHgwNDVDIHx8XHJcblx0XHRjID49IDB4MDQ1RSAmJiBjIDw9IDB4MDQ4MSB8fFxyXG5cdFx0YyA+PSAweDA0OTAgJiYgYyA8PSAweDA0QzQgfHxcclxuXHRcdGMgPj0gMHgwNEM3ICYmIGMgPD0gMHgwNEM4IHx8XHJcblx0XHRjID49IDB4MDRDQiAmJiBjIDw9IDB4MDRDQyB8fFxyXG5cdFx0YyA+PSAweDA0RDAgJiYgYyA8PSAweDA0RUIgfHxcclxuXHRcdGMgPj0gMHgwNEVFICYmIGMgPD0gMHgwNEY1IHx8XHJcblx0XHRjID49IDB4MDRGOCAmJiBjIDw9IDB4MDRGOSB8fFxyXG5cdFx0YyA+PSAweDA1MzEgJiYgYyA8PSAweDA1NTYgfHxcclxuXHRcdGMgPT0gMHgwNTU5IHx8XHJcblx0XHRjID49IDB4MDU2MSAmJiBjIDw9IDB4MDU4NiB8fFxyXG5cdFx0YyA+PSAweDA1RDAgJiYgYyA8PSAweDA1RUEgfHxcclxuXHRcdGMgPj0gMHgwNUYwICYmIGMgPD0gMHgwNUYyIHx8XHJcblx0XHRjID49IDB4MDYyMSAmJiBjIDw9IDB4MDYzQSB8fFxyXG5cdFx0YyA+PSAweDA2NDEgJiYgYyA8PSAweDA2NEEgfHxcclxuXHRcdGMgPj0gMHgwNjcxICYmIGMgPD0gMHgwNkI3IHx8XHJcblx0XHRjID49IDB4MDZCQSAmJiBjIDw9IDB4MDZCRSB8fFxyXG5cdFx0YyA+PSAweDA2QzAgJiYgYyA8PSAweDA2Q0UgfHxcclxuXHRcdGMgPj0gMHgwNkQwICYmIGMgPD0gMHgwNkQzIHx8XHJcblx0XHRjID09IDB4MDZENSB8fFxyXG5cdFx0YyA+PSAweDA2RTUgJiYgYyA8PSAweDA2RTYgfHxcclxuXHRcdGMgPj0gMHgwOTA1ICYmIGMgPD0gMHgwOTM5IHx8XHJcblx0XHRjID09IDB4MDkzRCB8fFxyXG5cdFx0YyA+PSAweDA5NTggJiYgYyA8PSAweDA5NjEgfHxcclxuXHRcdGMgPj0gMHgwOTg1ICYmIGMgPD0gMHgwOThDIHx8XHJcblx0XHRjID49IDB4MDk4RiAmJiBjIDw9IDB4MDk5MCB8fFxyXG5cdFx0YyA+PSAweDA5OTMgJiYgYyA8PSAweDA5QTggfHxcclxuXHRcdGMgPj0gMHgwOUFBICYmIGMgPD0gMHgwOUIwIHx8XHJcblx0XHRjID09IDB4MDlCMiB8fFxyXG5cdFx0YyA+PSAweDA5QjYgJiYgYyA8PSAweDA5QjkgfHxcclxuXHRcdGMgPj0gMHgwOURDICYmIGMgPD0gMHgwOUREIHx8XHJcblx0XHRjID49IDB4MDlERiAmJiBjIDw9IDB4MDlFMSB8fFxyXG5cdFx0YyA+PSAweDA5RjAgJiYgYyA8PSAweDA5RjEgfHxcclxuXHRcdGMgPj0gMHgwQTA1ICYmIGMgPD0gMHgwQTBBIHx8XHJcblx0XHRjID49IDB4MEEwRiAmJiBjIDw9IDB4MEExMCB8fFxyXG5cdFx0YyA+PSAweDBBMTMgJiYgYyA8PSAweDBBMjggfHxcclxuXHRcdGMgPj0gMHgwQTJBICYmIGMgPD0gMHgwQTMwIHx8XHJcblx0XHRjID49IDB4MEEzMiAmJiBjIDw9IDB4MEEzMyB8fFxyXG5cdFx0YyA+PSAweDBBMzUgJiYgYyA8PSAweDBBMzYgfHxcclxuXHRcdGMgPj0gMHgwQTM4ICYmIGMgPD0gMHgwQTM5IHx8XHJcblx0XHRjID49IDB4MEE1OSAmJiBjIDw9IDB4MEE1QyB8fFxyXG5cdFx0YyA9PSAweDBBNUUgfHxcclxuXHRcdGMgPj0gMHgwQTcyICYmIGMgPD0gMHgwQTc0IHx8XHJcblx0XHRjID49IDB4MEE4NSAmJiBjIDw9IDB4MEE4QiB8fFxyXG5cdFx0YyA9PSAweDBBOEQgfHxcclxuXHRcdGMgPj0gMHgwQThGICYmIGMgPD0gMHgwQTkxIHx8XHJcblx0XHRjID49IDB4MEE5MyAmJiBjIDw9IDB4MEFBOCB8fFxyXG5cdFx0YyA+PSAweDBBQUEgJiYgYyA8PSAweDBBQjAgfHxcclxuXHRcdGMgPj0gMHgwQUIyICYmIGMgPD0gMHgwQUIzIHx8XHJcblx0XHRjID49IDB4MEFCNSAmJiBjIDw9IDB4MEFCOSB8fFxyXG5cdFx0YyA9PSAweDBBQkQgfHxcclxuXHRcdGMgPT0gMHgwQUUwIHx8XHJcblx0XHRjID49IDB4MEIwNSAmJiBjIDw9IDB4MEIwQyB8fFxyXG5cdFx0YyA+PSAweDBCMEYgJiYgYyA8PSAweDBCMTAgfHxcclxuXHRcdGMgPj0gMHgwQjEzICYmIGMgPD0gMHgwQjI4IHx8XHJcblx0XHRjID49IDB4MEIyQSAmJiBjIDw9IDB4MEIzMCB8fFxyXG5cdFx0YyA+PSAweDBCMzIgJiYgYyA8PSAweDBCMzMgfHxcclxuXHRcdGMgPj0gMHgwQjM2ICYmIGMgPD0gMHgwQjM5IHx8XHJcblx0XHRjID09IDB4MEIzRCB8fFxyXG5cdFx0YyA+PSAweDBCNUMgJiYgYyA8PSAweDBCNUQgfHxcclxuXHRcdGMgPj0gMHgwQjVGICYmIGMgPD0gMHgwQjYxIHx8XHJcblx0XHRjID49IDB4MEI4NSAmJiBjIDw9IDB4MEI4QSB8fFxyXG5cdFx0YyA+PSAweDBCOEUgJiYgYyA8PSAweDBCOTAgfHxcclxuXHRcdGMgPj0gMHgwQjkyICYmIGMgPD0gMHgwQjk1IHx8XHJcblx0XHRjID49IDB4MEI5OSAmJiBjIDw9IDB4MEI5QSB8fFxyXG5cdFx0YyA9PSAweDBCOUMgfHxcclxuXHRcdGMgPj0gMHgwQjlFICYmIGMgPD0gMHgwQjlGIHx8XHJcblx0XHRjID49IDB4MEJBMyAmJiBjIDw9IDB4MEJBNCB8fFxyXG5cdFx0YyA+PSAweDBCQTggJiYgYyA8PSAweDBCQUEgfHxcclxuXHRcdGMgPj0gMHgwQkFFICYmIGMgPD0gMHgwQkI1IHx8XHJcblx0XHRjID49IDB4MEJCNyAmJiBjIDw9IDB4MEJCOSB8fFxyXG5cdFx0YyA+PSAweDBDMDUgJiYgYyA8PSAweDBDMEMgfHxcclxuXHRcdGMgPj0gMHgwQzBFICYmIGMgPD0gMHgwQzEwIHx8XHJcblx0XHRjID49IDB4MEMxMiAmJiBjIDw9IDB4MEMyOCB8fFxyXG5cdFx0YyA+PSAweDBDMkEgJiYgYyA8PSAweDBDMzMgfHxcclxuXHRcdGMgPj0gMHgwQzM1ICYmIGMgPD0gMHgwQzM5IHx8XHJcblx0XHRjID49IDB4MEM2MCAmJiBjIDw9IDB4MEM2MSB8fFxyXG5cdFx0YyA+PSAweDBDODUgJiYgYyA8PSAweDBDOEMgfHxcclxuXHRcdGMgPj0gMHgwQzhFICYmIGMgPD0gMHgwQzkwIHx8XHJcblx0XHRjID49IDB4MEM5MiAmJiBjIDw9IDB4MENBOCB8fFxyXG5cdFx0YyA+PSAweDBDQUEgJiYgYyA8PSAweDBDQjMgfHxcclxuXHRcdGMgPj0gMHgwQ0I1ICYmIGMgPD0gMHgwQ0I5IHx8XHJcblx0XHRjID09IDB4MENERSB8fFxyXG5cdFx0YyA+PSAweDBDRTAgJiYgYyA8PSAweDBDRTEgfHxcclxuXHRcdGMgPj0gMHgwRDA1ICYmIGMgPD0gMHgwRDBDIHx8XHJcblx0XHRjID49IDB4MEQwRSAmJiBjIDw9IDB4MEQxMCB8fFxyXG5cdFx0YyA+PSAweDBEMTIgJiYgYyA8PSAweDBEMjggfHxcclxuXHRcdGMgPj0gMHgwRDJBICYmIGMgPD0gMHgwRDM5IHx8XHJcblx0XHRjID49IDB4MEQ2MCAmJiBjIDw9IDB4MEQ2MSB8fFxyXG5cdFx0YyA+PSAweDBFMDEgJiYgYyA8PSAweDBFMkUgfHxcclxuXHRcdGMgPT0gMHgwRTMwIHx8XHJcblx0XHRjID49IDB4MEUzMiAmJiBjIDw9IDB4MEUzMyB8fFxyXG5cdFx0YyA+PSAweDBFNDAgJiYgYyA8PSAweDBFNDUgfHxcclxuXHRcdGMgPj0gMHgwRTgxICYmIGMgPD0gMHgwRTgyIHx8XHJcblx0XHRjID09IDB4MEU4NCB8fFxyXG5cdFx0YyA+PSAweDBFODcgJiYgYyA8PSAweDBFODggfHxcclxuXHRcdGMgPT0gMHgwRThBIHx8XHJcblx0XHRjID09IDB4MEU4RCB8fFxyXG5cdFx0YyA+PSAweDBFOTQgJiYgYyA8PSAweDBFOTcgfHxcclxuXHRcdGMgPj0gMHgwRTk5ICYmIGMgPD0gMHgwRTlGIHx8XHJcblx0XHRjID49IDB4MEVBMSAmJiBjIDw9IDB4MEVBMyB8fFxyXG5cdFx0YyA9PSAweDBFQTUgfHxcclxuXHRcdGMgPT0gMHgwRUE3IHx8XHJcblx0XHRjID49IDB4MEVBQSAmJiBjIDw9IDB4MEVBQiB8fFxyXG5cdFx0YyA+PSAweDBFQUQgJiYgYyA8PSAweDBFQUUgfHxcclxuXHRcdGMgPT0gMHgwRUIwIHx8XHJcblx0XHRjID49IDB4MEVCMiAmJiBjIDw9IDB4MEVCMyB8fFxyXG5cdFx0YyA9PSAweDBFQkQgfHxcclxuXHRcdGMgPj0gMHgwRUMwICYmIGMgPD0gMHgwRUM0IHx8XHJcblx0XHRjID49IDB4MEY0MCAmJiBjIDw9IDB4MEY0NyB8fFxyXG5cdFx0YyA+PSAweDBGNDkgJiYgYyA8PSAweDBGNjkgfHxcclxuXHRcdGMgPj0gMHgxMEEwICYmIGMgPD0gMHgxMEM1IHx8XHJcblx0XHRjID49IDB4MTBEMCAmJiBjIDw9IDB4MTBGNiB8fFxyXG5cdFx0YyA9PSAweDExMDAgfHxcclxuXHRcdGMgPj0gMHgxMTAyICYmIGMgPD0gMHgxMTAzIHx8XHJcblx0XHRjID49IDB4MTEwNSAmJiBjIDw9IDB4MTEwNyB8fFxyXG5cdFx0YyA9PSAweDExMDkgfHxcclxuXHRcdGMgPj0gMHgxMTBCICYmIGMgPD0gMHgxMTBDIHx8XHJcblx0XHRjID49IDB4MTEwRSAmJiBjIDw9IDB4MTExMiB8fFxyXG5cdFx0YyA9PSAweDExM0MgfHxcclxuXHRcdGMgPT0gMHgxMTNFIHx8XHJcblx0XHRjID09IDB4MTE0MCB8fFxyXG5cdFx0YyA9PSAweDExNEMgfHxcclxuXHRcdGMgPT0gMHgxMTRFIHx8XHJcblx0XHRjID09IDB4MTE1MCB8fFxyXG5cdFx0YyA+PSAweDExNTQgJiYgYyA8PSAweDExNTUgfHxcclxuXHRcdGMgPT0gMHgxMTU5IHx8XHJcblx0XHRjID49IDB4MTE1RiAmJiBjIDw9IDB4MTE2MSB8fFxyXG5cdFx0YyA9PSAweDExNjMgfHxcclxuXHRcdGMgPT0gMHgxMTY1IHx8XHJcblx0XHRjID09IDB4MTE2NyB8fFxyXG5cdFx0YyA9PSAweDExNjkgfHxcclxuXHRcdGMgPj0gMHgxMTZEICYmIGMgPD0gMHgxMTZFIHx8XHJcblx0XHRjID49IDB4MTE3MiAmJiBjIDw9IDB4MTE3MyB8fFxyXG5cdFx0YyA9PSAweDExNzUgfHxcclxuXHRcdGMgPT0gMHgxMTlFIHx8XHJcblx0XHRjID09IDB4MTFBOCB8fFxyXG5cdFx0YyA9PSAweDExQUIgfHxcclxuXHRcdGMgPj0gMHgxMUFFICYmIGMgPD0gMHgxMUFGIHx8XHJcblx0XHRjID49IDB4MTFCNyAmJiBjIDw9IDB4MTFCOCB8fFxyXG5cdFx0YyA9PSAweDExQkEgfHxcclxuXHRcdGMgPj0gMHgxMUJDICYmIGMgPD0gMHgxMUMyIHx8XHJcblx0XHRjID09IDB4MTFFQiB8fFxyXG5cdFx0YyA9PSAweDExRjAgfHxcclxuXHRcdGMgPT0gMHgxMUY5IHx8XHJcblx0XHRjID49IDB4MUUwMCAmJiBjIDw9IDB4MUU5QiB8fFxyXG5cdFx0YyA+PSAweDFFQTAgJiYgYyA8PSAweDFFRjkgfHxcclxuXHRcdGMgPj0gMHgxRjAwICYmIGMgPD0gMHgxRjE1IHx8XHJcblx0XHRjID49IDB4MUYxOCAmJiBjIDw9IDB4MUYxRCB8fFxyXG5cdFx0YyA+PSAweDFGMjAgJiYgYyA8PSAweDFGNDUgfHxcclxuXHRcdGMgPj0gMHgxRjQ4ICYmIGMgPD0gMHgxRjREIHx8XHJcblx0XHRjID49IDB4MUY1MCAmJiBjIDw9IDB4MUY1NyB8fFxyXG5cdFx0YyA9PSAweDFGNTkgfHxcclxuXHRcdGMgPT0gMHgxRjVCIHx8XHJcblx0XHRjID09IDB4MUY1RCB8fFxyXG5cdFx0YyA+PSAweDFGNUYgJiYgYyA8PSAweDFGN0QgfHxcclxuXHRcdGMgPj0gMHgxRjgwICYmIGMgPD0gMHgxRkI0IHx8XHJcblx0XHRjID49IDB4MUZCNiAmJiBjIDw9IDB4MUZCQyB8fFxyXG5cdFx0YyA9PSAweDFGQkUgfHxcclxuXHRcdGMgPj0gMHgxRkMyICYmIGMgPD0gMHgxRkM0IHx8XHJcblx0XHRjID49IDB4MUZDNiAmJiBjIDw9IDB4MUZDQyB8fFxyXG5cdFx0YyA+PSAweDFGRDAgJiYgYyA8PSAweDFGRDMgfHxcclxuXHRcdGMgPj0gMHgxRkQ2ICYmIGMgPD0gMHgxRkRCIHx8XHJcblx0XHRjID49IDB4MUZFMCAmJiBjIDw9IDB4MUZFQyB8fFxyXG5cdFx0YyA+PSAweDFGRjIgJiYgYyA8PSAweDFGRjQgfHxcclxuXHRcdGMgPj0gMHgxRkY2ICYmIGMgPD0gMHgxRkZDIHx8XHJcblx0XHRjID09IDB4MjEyNiB8fFxyXG5cdFx0YyA+PSAweDIxMkEgJiYgYyA8PSAweDIxMkIgfHxcclxuXHRcdGMgPT0gMHgyMTJFIHx8XHJcblx0XHRjID49IDB4MjE4MCAmJiBjIDw9IDB4MjE4MiB8fFxyXG5cdFx0YyA+PSAweDMwNDEgJiYgYyA8PSAweDMwOTQgfHxcclxuXHRcdGMgPj0gMHgzMEExICYmIGMgPD0gMHgzMEZBIHx8XHJcblx0XHRjID49IDB4MzEwNSAmJiBjIDw9IDB4MzEyQyB8fFxyXG5cdFx0YyA+PSAweEFDMDAgJiYgYyA8PSAweEQ3QTMgfHxcclxuXHRcdGMgPj0gMHg0RTAwICYmIGMgPD0gMHg5RkE1IHx8XHJcblx0XHRjID09IDB4MzAwNyB8fFxyXG5cdFx0YyA+PSAweDMwMjEgJiYgYyA8PSAweDMwMjk7XHJcbn07XHJcblxyXG5VdGlsaXRpZXMuaXNOQ05hbWVDaGFyID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiBjID49IDB4MDAzMCAmJiBjIDw9IDB4MDAzOVxyXG5cdFx0fHwgYyA+PSAweDA2NjAgJiYgYyA8PSAweDA2NjlcclxuXHRcdHx8IGMgPj0gMHgwNkYwICYmIGMgPD0gMHgwNkY5XHJcblx0XHR8fCBjID49IDB4MDk2NiAmJiBjIDw9IDB4MDk2RlxyXG5cdFx0fHwgYyA+PSAweDA5RTYgJiYgYyA8PSAweDA5RUZcclxuXHRcdHx8IGMgPj0gMHgwQTY2ICYmIGMgPD0gMHgwQTZGXHJcblx0XHR8fCBjID49IDB4MEFFNiAmJiBjIDw9IDB4MEFFRlxyXG5cdFx0fHwgYyA+PSAweDBCNjYgJiYgYyA8PSAweDBCNkZcclxuXHRcdHx8IGMgPj0gMHgwQkU3ICYmIGMgPD0gMHgwQkVGXHJcblx0XHR8fCBjID49IDB4MEM2NiAmJiBjIDw9IDB4MEM2RlxyXG5cdFx0fHwgYyA+PSAweDBDRTYgJiYgYyA8PSAweDBDRUZcclxuXHRcdHx8IGMgPj0gMHgwRDY2ICYmIGMgPD0gMHgwRDZGXHJcblx0XHR8fCBjID49IDB4MEU1MCAmJiBjIDw9IDB4MEU1OVxyXG5cdFx0fHwgYyA+PSAweDBFRDAgJiYgYyA8PSAweDBFRDlcclxuXHRcdHx8IGMgPj0gMHgwRjIwICYmIGMgPD0gMHgwRjI5XHJcblx0XHR8fCBjID09IDB4MDAyRVxyXG5cdFx0fHwgYyA9PSAweDAwMkRcclxuXHRcdHx8IGMgPT0gMHgwMDVGXHJcblx0XHR8fCBVdGlsaXRpZXMuaXNMZXR0ZXIoYylcclxuXHRcdHx8IGMgPj0gMHgwMzAwICYmIGMgPD0gMHgwMzQ1XHJcblx0XHR8fCBjID49IDB4MDM2MCAmJiBjIDw9IDB4MDM2MVxyXG5cdFx0fHwgYyA+PSAweDA0ODMgJiYgYyA8PSAweDA0ODZcclxuXHRcdHx8IGMgPj0gMHgwNTkxICYmIGMgPD0gMHgwNUExXHJcblx0XHR8fCBjID49IDB4MDVBMyAmJiBjIDw9IDB4MDVCOVxyXG5cdFx0fHwgYyA+PSAweDA1QkIgJiYgYyA8PSAweDA1QkRcclxuXHRcdHx8IGMgPT0gMHgwNUJGXHJcblx0XHR8fCBjID49IDB4MDVDMSAmJiBjIDw9IDB4MDVDMlxyXG5cdFx0fHwgYyA9PSAweDA1QzRcclxuXHRcdHx8IGMgPj0gMHgwNjRCICYmIGMgPD0gMHgwNjUyXHJcblx0XHR8fCBjID09IDB4MDY3MFxyXG5cdFx0fHwgYyA+PSAweDA2RDYgJiYgYyA8PSAweDA2RENcclxuXHRcdHx8IGMgPj0gMHgwNkREICYmIGMgPD0gMHgwNkRGXHJcblx0XHR8fCBjID49IDB4MDZFMCAmJiBjIDw9IDB4MDZFNFxyXG5cdFx0fHwgYyA+PSAweDA2RTcgJiYgYyA8PSAweDA2RThcclxuXHRcdHx8IGMgPj0gMHgwNkVBICYmIGMgPD0gMHgwNkVEXHJcblx0XHR8fCBjID49IDB4MDkwMSAmJiBjIDw9IDB4MDkwM1xyXG5cdFx0fHwgYyA9PSAweDA5M0NcclxuXHRcdHx8IGMgPj0gMHgwOTNFICYmIGMgPD0gMHgwOTRDXHJcblx0XHR8fCBjID09IDB4MDk0RFxyXG5cdFx0fHwgYyA+PSAweDA5NTEgJiYgYyA8PSAweDA5NTRcclxuXHRcdHx8IGMgPj0gMHgwOTYyICYmIGMgPD0gMHgwOTYzXHJcblx0XHR8fCBjID49IDB4MDk4MSAmJiBjIDw9IDB4MDk4M1xyXG5cdFx0fHwgYyA9PSAweDA5QkNcclxuXHRcdHx8IGMgPT0gMHgwOUJFXHJcblx0XHR8fCBjID09IDB4MDlCRlxyXG5cdFx0fHwgYyA+PSAweDA5QzAgJiYgYyA8PSAweDA5QzRcclxuXHRcdHx8IGMgPj0gMHgwOUM3ICYmIGMgPD0gMHgwOUM4XHJcblx0XHR8fCBjID49IDB4MDlDQiAmJiBjIDw9IDB4MDlDRFxyXG5cdFx0fHwgYyA9PSAweDA5RDdcclxuXHRcdHx8IGMgPj0gMHgwOUUyICYmIGMgPD0gMHgwOUUzXHJcblx0XHR8fCBjID09IDB4MEEwMlxyXG5cdFx0fHwgYyA9PSAweDBBM0NcclxuXHRcdHx8IGMgPT0gMHgwQTNFXHJcblx0XHR8fCBjID09IDB4MEEzRlxyXG5cdFx0fHwgYyA+PSAweDBBNDAgJiYgYyA8PSAweDBBNDJcclxuXHRcdHx8IGMgPj0gMHgwQTQ3ICYmIGMgPD0gMHgwQTQ4XHJcblx0XHR8fCBjID49IDB4MEE0QiAmJiBjIDw9IDB4MEE0RFxyXG5cdFx0fHwgYyA+PSAweDBBNzAgJiYgYyA8PSAweDBBNzFcclxuXHRcdHx8IGMgPj0gMHgwQTgxICYmIGMgPD0gMHgwQTgzXHJcblx0XHR8fCBjID09IDB4MEFCQ1xyXG5cdFx0fHwgYyA+PSAweDBBQkUgJiYgYyA8PSAweDBBQzVcclxuXHRcdHx8IGMgPj0gMHgwQUM3ICYmIGMgPD0gMHgwQUM5XHJcblx0XHR8fCBjID49IDB4MEFDQiAmJiBjIDw9IDB4MEFDRFxyXG5cdFx0fHwgYyA+PSAweDBCMDEgJiYgYyA8PSAweDBCMDNcclxuXHRcdHx8IGMgPT0gMHgwQjNDXHJcblx0XHR8fCBjID49IDB4MEIzRSAmJiBjIDw9IDB4MEI0M1xyXG5cdFx0fHwgYyA+PSAweDBCNDcgJiYgYyA8PSAweDBCNDhcclxuXHRcdHx8IGMgPj0gMHgwQjRCICYmIGMgPD0gMHgwQjREXHJcblx0XHR8fCBjID49IDB4MEI1NiAmJiBjIDw9IDB4MEI1N1xyXG5cdFx0fHwgYyA+PSAweDBCODIgJiYgYyA8PSAweDBCODNcclxuXHRcdHx8IGMgPj0gMHgwQkJFICYmIGMgPD0gMHgwQkMyXHJcblx0XHR8fCBjID49IDB4MEJDNiAmJiBjIDw9IDB4MEJDOFxyXG5cdFx0fHwgYyA+PSAweDBCQ0EgJiYgYyA8PSAweDBCQ0RcclxuXHRcdHx8IGMgPT0gMHgwQkQ3XHJcblx0XHR8fCBjID49IDB4MEMwMSAmJiBjIDw9IDB4MEMwM1xyXG5cdFx0fHwgYyA+PSAweDBDM0UgJiYgYyA8PSAweDBDNDRcclxuXHRcdHx8IGMgPj0gMHgwQzQ2ICYmIGMgPD0gMHgwQzQ4XHJcblx0XHR8fCBjID49IDB4MEM0QSAmJiBjIDw9IDB4MEM0RFxyXG5cdFx0fHwgYyA+PSAweDBDNTUgJiYgYyA8PSAweDBDNTZcclxuXHRcdHx8IGMgPj0gMHgwQzgyICYmIGMgPD0gMHgwQzgzXHJcblx0XHR8fCBjID49IDB4MENCRSAmJiBjIDw9IDB4MENDNFxyXG5cdFx0fHwgYyA+PSAweDBDQzYgJiYgYyA8PSAweDBDQzhcclxuXHRcdHx8IGMgPj0gMHgwQ0NBICYmIGMgPD0gMHgwQ0NEXHJcblx0XHR8fCBjID49IDB4MENENSAmJiBjIDw9IDB4MENENlxyXG5cdFx0fHwgYyA+PSAweDBEMDIgJiYgYyA8PSAweDBEMDNcclxuXHRcdHx8IGMgPj0gMHgwRDNFICYmIGMgPD0gMHgwRDQzXHJcblx0XHR8fCBjID49IDB4MEQ0NiAmJiBjIDw9IDB4MEQ0OFxyXG5cdFx0fHwgYyA+PSAweDBENEEgJiYgYyA8PSAweDBENERcclxuXHRcdHx8IGMgPT0gMHgwRDU3XHJcblx0XHR8fCBjID09IDB4MEUzMVxyXG5cdFx0fHwgYyA+PSAweDBFMzQgJiYgYyA8PSAweDBFM0FcclxuXHRcdHx8IGMgPj0gMHgwRTQ3ICYmIGMgPD0gMHgwRTRFXHJcblx0XHR8fCBjID09IDB4MEVCMVxyXG5cdFx0fHwgYyA+PSAweDBFQjQgJiYgYyA8PSAweDBFQjlcclxuXHRcdHx8IGMgPj0gMHgwRUJCICYmIGMgPD0gMHgwRUJDXHJcblx0XHR8fCBjID49IDB4MEVDOCAmJiBjIDw9IDB4MEVDRFxyXG5cdFx0fHwgYyA+PSAweDBGMTggJiYgYyA8PSAweDBGMTlcclxuXHRcdHx8IGMgPT0gMHgwRjM1XHJcblx0XHR8fCBjID09IDB4MEYzN1xyXG5cdFx0fHwgYyA9PSAweDBGMzlcclxuXHRcdHx8IGMgPT0gMHgwRjNFXHJcblx0XHR8fCBjID09IDB4MEYzRlxyXG5cdFx0fHwgYyA+PSAweDBGNzEgJiYgYyA8PSAweDBGODRcclxuXHRcdHx8IGMgPj0gMHgwRjg2ICYmIGMgPD0gMHgwRjhCXHJcblx0XHR8fCBjID49IDB4MEY5MCAmJiBjIDw9IDB4MEY5NVxyXG5cdFx0fHwgYyA9PSAweDBGOTdcclxuXHRcdHx8IGMgPj0gMHgwRjk5ICYmIGMgPD0gMHgwRkFEXHJcblx0XHR8fCBjID49IDB4MEZCMSAmJiBjIDw9IDB4MEZCN1xyXG5cdFx0fHwgYyA9PSAweDBGQjlcclxuXHRcdHx8IGMgPj0gMHgyMEQwICYmIGMgPD0gMHgyMERDXHJcblx0XHR8fCBjID09IDB4MjBFMVxyXG5cdFx0fHwgYyA+PSAweDMwMkEgJiYgYyA8PSAweDMwMkZcclxuXHRcdHx8IGMgPT0gMHgzMDk5XHJcblx0XHR8fCBjID09IDB4MzA5QVxyXG5cdFx0fHwgYyA9PSAweDAwQjdcclxuXHRcdHx8IGMgPT0gMHgwMkQwXHJcblx0XHR8fCBjID09IDB4MDJEMVxyXG5cdFx0fHwgYyA9PSAweDAzODdcclxuXHRcdHx8IGMgPT0gMHgwNjQwXHJcblx0XHR8fCBjID09IDB4MEU0NlxyXG5cdFx0fHwgYyA9PSAweDBFQzZcclxuXHRcdHx8IGMgPT0gMHgzMDA1XHJcblx0XHR8fCBjID49IDB4MzAzMSAmJiBjIDw9IDB4MzAzNVxyXG5cdFx0fHwgYyA+PSAweDMwOUQgJiYgYyA8PSAweDMwOUVcclxuXHRcdHx8IGMgPj0gMHgzMEZDICYmIGMgPD0gMHgzMEZFO1xyXG59O1xyXG5cclxuVXRpbGl0aWVzLmNvYWxlc2NlVGV4dCA9IGZ1bmN0aW9uKG4pIHtcclxuXHRmb3IgKHZhciBtID0gbi5maXJzdENoaWxkOyBtICE9IG51bGw7IG0gPSBtLm5leHRTaWJsaW5nKSB7XHJcblx0XHRpZiAobS5ub2RlVHlwZSA9PSAzIC8qTm9kZS5URVhUX05PREUqLyB8fCBtLm5vZGVUeXBlID09IDQgLypOb2RlLkNEQVRBX1NFQ1RJT05fTk9ERSovKSB7XHJcblx0XHRcdHZhciBzID0gbS5ub2RlVmFsdWU7XHJcblx0XHRcdHZhciBmaXJzdCA9IG07XHJcblx0XHRcdG0gPSBtLm5leHRTaWJsaW5nO1xyXG5cdFx0XHR3aGlsZSAobSAhPSBudWxsICYmIChtLm5vZGVUeXBlID09IDMgLypOb2RlLlRFWFRfTk9ERSovIHx8IG0ubm9kZVR5cGUgPT0gNCAvKk5vZGUuQ0RBVEFfU0VDVElPTl9OT0RFKi8pKSB7XHJcblx0XHRcdFx0cyArPSBtLm5vZGVWYWx1ZTtcclxuXHRcdFx0XHR2YXIgZGVsID0gbTtcclxuXHRcdFx0XHRtID0gbS5uZXh0U2libGluZztcclxuXHRcdFx0XHRkZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkZWwpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChmaXJzdC5ub2RlVHlwZSA9PSA0IC8qTm9kZS5DREFUQV9TRUNUSU9OX05PREUqLykge1xyXG5cdFx0XHRcdHZhciBwID0gZmlyc3QucGFyZW50Tm9kZTtcclxuXHRcdFx0XHRpZiAoZmlyc3QubmV4dFNpYmxpbmcgPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0cC5yZW1vdmVDaGlsZChmaXJzdCk7XHJcblx0XHRcdFx0XHRwLmFwcGVuZENoaWxkKHAub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzKSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBuZXh0ID0gZmlyc3QubmV4dFNpYmxpbmc7XHJcblx0XHRcdFx0XHRwLnJlbW92ZUNoaWxkKGZpcnN0KTtcclxuXHRcdFx0XHRcdHAuaW5zZXJ0QmVmb3JlKHAub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzKSwgbmV4dCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGZpcnN0Lm5vZGVWYWx1ZSA9IHM7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG0gPT0gbnVsbCkge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKG0ubm9kZVR5cGUgPT0gMSAvKk5vZGUuRUxFTUVOVF9OT0RFKi8pIHtcclxuXHRcdFx0VXRpbGl0aWVzLmNvYWxlc2NlVGV4dChtKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG5VdGlsaXRpZXMuaW5zdGFuY2Vfb2YgPSBmdW5jdGlvbihvLCBjKSB7XHJcblx0d2hpbGUgKG8gIT0gbnVsbCkge1xyXG5cdFx0aWYgKG8uY29uc3RydWN0b3IgPT09IGMpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0XHRpZiAobyA9PT0gT2JqZWN0KSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdG8gPSBvLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3M7XHJcblx0fVxyXG5cdHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcblV0aWxpdGllcy5nZXRFbGVtZW50QnlJZCA9IGZ1bmN0aW9uKG4sIGlkKSB7XHJcblx0Ly8gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgY2hlY2sgdGhlIERURCB0byBjaGVjayBmb3IgYWN0dWFsXHJcblx0Ly8gYXR0cmlidXRlcyBvZiB0eXBlIElELCBzbyB0aGlzIG1heSBiZSBhIGJpdCB3cm9uZy5cclxuXHRpZiAobi5ub2RlVHlwZSA9PSAxIC8qTm9kZS5FTEVNRU5UX05PREUqLykge1xyXG5cdFx0aWYgKG4uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT0gaWRcclxuXHRcdFx0XHR8fCBuLmdldEF0dHJpYnV0ZU5TKG51bGwsIFwiaWRcIikgPT0gaWQpIHtcclxuXHRcdFx0cmV0dXJuIG47XHJcblx0XHR9XHJcblx0fVxyXG5cdGZvciAodmFyIG0gPSBuLmZpcnN0Q2hpbGQ7IG0gIT0gbnVsbDsgbSA9IG0ubmV4dFNpYmxpbmcpIHtcclxuXHRcdHZhciByZXMgPSBVdGlsaXRpZXMuZ2V0RWxlbWVudEJ5SWQobSwgaWQpO1xyXG5cdFx0aWYgKHJlcyAhPSBudWxsKSB7XHJcblx0XHRcdHJldHVybiByZXM7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuLy8gWFBhdGhFeGNlcHRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5YUGF0aEV4Y2VwdGlvbi5wcm90b3R5cGUgPSB7fTtcclxuWFBhdGhFeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWFBhdGhFeGNlcHRpb247XHJcblhQYXRoRXhjZXB0aW9uLnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gWFBhdGhFeGNlcHRpb24oYywgZSkge1xyXG5cdHRoaXMuY29kZSA9IGM7XHJcblx0dGhpcy5leGNlcHRpb24gPSBlO1xyXG59XHJcblxyXG5YUGF0aEV4Y2VwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgbXNnID0gdGhpcy5leGNlcHRpb24gPyBcIjogXCIgKyB0aGlzLmV4Y2VwdGlvbi50b1N0cmluZygpIDogXCJcIjtcclxuXHRzd2l0Y2ggKHRoaXMuY29kZSkge1xyXG5cdFx0Y2FzZSBYUGF0aEV4Y2VwdGlvbi5JTlZBTElEX0VYUFJFU1NJT05fRVJSOlxyXG5cdFx0XHRyZXR1cm4gXCJJbnZhbGlkIGV4cHJlc3Npb25cIiArIG1zZztcclxuXHRcdGNhc2UgWFBhdGhFeGNlcHRpb24uVFlQRV9FUlI6XHJcblx0XHRcdHJldHVybiBcIlR5cGUgZXJyb3JcIiArIG1zZztcclxuXHR9XHJcbn07XHJcblxyXG5YUGF0aEV4Y2VwdGlvbi5JTlZBTElEX0VYUFJFU1NJT05fRVJSID0gNTE7XHJcblhQYXRoRXhjZXB0aW9uLlRZUEVfRVJSID0gNTI7XHJcblxyXG4vLyBYUGF0aEV4cHJlc3Npb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblhQYXRoRXhwcmVzc2lvbi5wcm90b3R5cGUgPSB7fTtcclxuWFBhdGhFeHByZXNzaW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhQYXRoRXhwcmVzc2lvbjtcclxuWFBhdGhFeHByZXNzaW9uLnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gWFBhdGhFeHByZXNzaW9uKGUsIHIsIHApIHtcclxuXHR0aGlzLnhwYXRoID0gcC5wYXJzZShlKTtcclxuXHR0aGlzLmNvbnRleHQgPSBuZXcgWFBhdGhDb250ZXh0KCk7XHJcblx0dGhpcy5jb250ZXh0Lm5hbWVzcGFjZVJlc29sdmVyID0gbmV3IFhQYXRoTlNSZXNvbHZlcldyYXBwZXIocik7XHJcbn1cclxuXHJcblhQYXRoRXhwcmVzc2lvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihuLCB0LCByZXMpIHtcclxuXHR0aGlzLmNvbnRleHQuZXhwcmVzc2lvbkNvbnRleHROb2RlID0gbjtcclxuXHR2YXIgcmVzdWx0ID0gdGhpcy54cGF0aC5ldmFsdWF0ZSh0aGlzLmNvbnRleHQpO1xyXG5cdHJldHVybiBuZXcgWFBhdGhSZXN1bHQocmVzdWx0LCB0KTtcclxufVxyXG5cclxuLy8gWFBhdGhOU1Jlc29sdmVyV3JhcHBlciAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5YUGF0aE5TUmVzb2x2ZXJXcmFwcGVyLnByb3RvdHlwZSA9IHt9O1xyXG5YUGF0aE5TUmVzb2x2ZXJXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhQYXRoTlNSZXNvbHZlcldyYXBwZXI7XHJcblhQYXRoTlNSZXNvbHZlcldyYXBwZXIuc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBYUGF0aE5TUmVzb2x2ZXJXcmFwcGVyKHIpIHtcclxuXHR0aGlzLnhwYXRoTlNSZXNvbHZlciA9IHI7XHJcbn1cclxuXHJcblhQYXRoTlNSZXNvbHZlcldyYXBwZXIucHJvdG90eXBlLmdldE5hbWVzcGFjZSA9IGZ1bmN0aW9uKHByZWZpeCwgbikge1xyXG4gICAgaWYgKHRoaXMueHBhdGhOU1Jlc29sdmVyID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHRyZXR1cm4gdGhpcy54cGF0aE5TUmVzb2x2ZXIubG9va3VwTmFtZXNwYWNlVVJJKHByZWZpeCk7XHJcbn07XHJcblxyXG4vLyBOb2RlWFBhdGhOU1Jlc29sdmVyIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbk5vZGVYUGF0aE5TUmVzb2x2ZXIucHJvdG90eXBlID0ge307XHJcbk5vZGVYUGF0aE5TUmVzb2x2ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTm9kZVhQYXRoTlNSZXNvbHZlcjtcclxuTm9kZVhQYXRoTlNSZXNvbHZlci5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIE5vZGVYUGF0aE5TUmVzb2x2ZXIobikge1xyXG5cdHRoaXMubm9kZSA9IG47XHJcblx0dGhpcy5uYW1lc3BhY2VSZXNvbHZlciA9IG5ldyBOYW1lc3BhY2VSZXNvbHZlcigpO1xyXG59XHJcblxyXG5Ob2RlWFBhdGhOU1Jlc29sdmVyLnByb3RvdHlwZS5sb29rdXBOYW1lc3BhY2VVUkkgPSBmdW5jdGlvbihwcmVmaXgpIHtcclxuXHRyZXR1cm4gdGhpcy5uYW1lc3BhY2VSZXNvbHZlci5nZXROYW1lc3BhY2UocHJlZml4LCB0aGlzLm5vZGUpO1xyXG59O1xyXG5cclxuLy8gWFBhdGhSZXN1bHQgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5YUGF0aFJlc3VsdC5wcm90b3R5cGUgPSB7fTtcclxuWFBhdGhSZXN1bHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWFBhdGhSZXN1bHQ7XHJcblhQYXRoUmVzdWx0LnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gWFBhdGhSZXN1bHQodiwgdCkge1xyXG5cdGlmICh0ID09IFhQYXRoUmVzdWx0LkFOWV9UWVBFKSB7XHJcblx0XHRpZiAodi5jb25zdHJ1Y3RvciA9PT0gWFN0cmluZykge1xyXG5cdFx0XHR0ID0gWFBhdGhSZXN1bHQuU1RSSU5HX1RZUEU7XHJcblx0XHR9IGVsc2UgaWYgKHYuY29uc3RydWN0b3IgPT09IFhOdW1iZXIpIHtcclxuXHRcdFx0dCA9IFhQYXRoUmVzdWx0Lk5VTUJFUl9UWVBFO1xyXG5cdFx0fSBlbHNlIGlmICh2LmNvbnN0cnVjdG9yID09PSBYQm9vbGVhbikge1xyXG5cdFx0XHR0ID0gWFBhdGhSZXN1bHQuQk9PTEVBTl9UWVBFO1xyXG5cdFx0fSBlbHNlIGlmICh2LmNvbnN0cnVjdG9yID09PSBYTm9kZVNldCkge1xyXG5cdFx0XHR0ID0gWFBhdGhSZXN1bHQuVU5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRTtcclxuXHRcdH1cclxuXHR9XHJcblx0dGhpcy5yZXN1bHRUeXBlID0gdDtcclxuXHRzd2l0Y2ggKHQpIHtcclxuXHRcdGNhc2UgWFBhdGhSZXN1bHQuTlVNQkVSX1RZUEU6XHJcblx0XHRcdHRoaXMubnVtYmVyVmFsdWUgPSB2Lm51bWJlclZhbHVlKCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdGNhc2UgWFBhdGhSZXN1bHQuU1RSSU5HX1RZUEU6XHJcblx0XHRcdHRoaXMuc3RyaW5nVmFsdWUgPSB2LnN0cmluZ1ZhbHVlKCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdGNhc2UgWFBhdGhSZXN1bHQuQk9PTEVBTl9UWVBFOlxyXG5cdFx0XHR0aGlzLmJvb2xlYW5WYWx1ZSA9IHYuYm9vbGVhblZhbHVlKCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdGNhc2UgWFBhdGhSZXN1bHQuQU5ZX1VOT1JERVJFRF9OT0RFX1RZUEU6XHJcblx0XHRjYXNlIFhQYXRoUmVzdWx0LkZJUlNUX09SREVSRURfTk9ERV9UWVBFOlxyXG5cdFx0XHRpZiAodi5jb25zdHJ1Y3RvciA9PT0gWE5vZGVTZXQpIHtcclxuXHRcdFx0XHR0aGlzLnNpbmdsZU5vZGVWYWx1ZSA9IHYuZmlyc3QoKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIFhQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX0lURVJBVE9SX1RZUEU6XHJcblx0XHRjYXNlIFhQYXRoUmVzdWx0Lk9SREVSRURfTk9ERV9JVEVSQVRPUl9UWVBFOlxyXG5cdFx0XHRpZiAodi5jb25zdHJ1Y3RvciA9PT0gWE5vZGVTZXQpIHtcclxuXHRcdFx0XHR0aGlzLmludmFsaWRJdGVyYXRvclN0YXRlID0gZmFsc2U7XHJcblx0XHRcdFx0dGhpcy5ub2RlcyA9IHYudG9BcnJheSgpO1xyXG5cdFx0XHRcdHRoaXMuaXRlcmF0b3JJbmRleCA9IDA7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBYUGF0aFJlc3VsdC5VTk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFOlxyXG5cdFx0Y2FzZSBYUGF0aFJlc3VsdC5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRTpcclxuXHRcdFx0aWYgKHYuY29uc3RydWN0b3IgPT09IFhOb2RlU2V0KSB7XHJcblx0XHRcdFx0dGhpcy5ub2RlcyA9IHYudG9BcnJheSgpO1xyXG5cdFx0XHRcdHRoaXMuc25hcHNob3RMZW5ndGggPSB0aGlzLm5vZGVzLmxlbmd0aDtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0YnJlYWs7XHJcblx0fVxyXG5cdHRocm93IG5ldyBYUGF0aEV4Y2VwdGlvbihYUGF0aEV4Y2VwdGlvbi5UWVBFX0VSUik7XHJcbn07XHJcblxyXG5YUGF0aFJlc3VsdC5wcm90b3R5cGUuaXRlcmF0ZU5leHQgPSBmdW5jdGlvbigpIHtcclxuXHRpZiAodGhpcy5yZXN1bHRUeXBlICE9IFhQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX0lURVJBVE9SX1RZUEVcclxuXHRcdFx0JiYgdGhpcy5yZXN1bHRUeXBlICE9IFhQYXRoUmVzdWx0Lk9SREVSRURfTk9ERV9JVEVSQVRPUl9UWVBFKSB7XHJcblx0XHR0aHJvdyBuZXcgWFBhdGhFeGNlcHRpb24oWFBhdGhFeGNlcHRpb24uVFlQRV9FUlIpO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5ub2Rlc1t0aGlzLml0ZXJhdG9ySW5kZXgrK107XHJcbn07XHJcblxyXG5YUGF0aFJlc3VsdC5wcm90b3R5cGUuc25hcHNob3RJdGVtID0gZnVuY3Rpb24oaSkge1xyXG5cdGlmICh0aGlzLnJlc3VsdFR5cGUgIT0gWFBhdGhSZXN1bHQuVU5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRVxyXG5cdFx0XHQmJiB0aGlzLnJlc3VsdFR5cGUgIT0gWFBhdGhSZXN1bHQuT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEUpIHtcclxuXHRcdHRocm93IG5ldyBYUGF0aEV4Y2VwdGlvbihYUGF0aEV4Y2VwdGlvbi5UWVBFX0VSUik7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLm5vZGVzW2ldO1xyXG59O1xyXG5cclxuWFBhdGhSZXN1bHQuQU5ZX1RZUEUgPSAwO1xyXG5YUGF0aFJlc3VsdC5OVU1CRVJfVFlQRSA9IDE7XHJcblhQYXRoUmVzdWx0LlNUUklOR19UWVBFID0gMjtcclxuWFBhdGhSZXN1bHQuQk9PTEVBTl9UWVBFID0gMztcclxuWFBhdGhSZXN1bHQuVU5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRSA9IDQ7XHJcblhQYXRoUmVzdWx0Lk9SREVSRURfTk9ERV9JVEVSQVRPUl9UWVBFID0gNTtcclxuWFBhdGhSZXN1bHQuVU5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRSA9IDY7XHJcblhQYXRoUmVzdWx0Lk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFID0gNztcclxuWFBhdGhSZXN1bHQuQU5ZX1VOT1JERVJFRF9OT0RFX1RZUEUgPSA4O1xyXG5YUGF0aFJlc3VsdC5GSVJTVF9PUkRFUkVEX05PREVfVFlQRSA9IDk7XHJcblxyXG4vLyBET00gMyBYUGF0aCBzdXBwb3J0IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbmZ1bmN0aW9uIGluc3RhbGxET00zWFBhdGhTdXBwb3J0KGRvYywgcCkge1xyXG5cdGRvYy5jcmVhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24oZSwgcikge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0cmV0dXJuIG5ldyBYUGF0aEV4cHJlc3Npb24oZSwgciwgcCk7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdHRocm93IG5ldyBYUGF0aEV4Y2VwdGlvbihYUGF0aEV4Y2VwdGlvbi5JTlZBTElEX0VYUFJFU1NJT05fRVJSLCBlKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cdGRvYy5jcmVhdGVOU1Jlc29sdmVyID0gZnVuY3Rpb24obikge1xyXG5cdFx0cmV0dXJuIG5ldyBOb2RlWFBhdGhOU1Jlc29sdmVyKG4pO1xyXG5cdH07XHJcblx0ZG9jLmV2YWx1YXRlID0gZnVuY3Rpb24oZSwgY24sIHIsIHQsIHJlcykge1xyXG5cdFx0aWYgKHQgPCAwIHx8IHQgPiA5KSB7XHJcblx0XHRcdHRocm93IHsgY29kZTogMCwgdG9TdHJpbmc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJSZXF1ZXN0IHR5cGUgbm90IHN1cHBvcnRlZFwiOyB9IH07XHJcblx0XHR9XHJcbiAgICAgICAgcmV0dXJuIGRvYy5jcmVhdGVFeHByZXNzaW9uKGUsIHIsIHApLmV2YWx1YXRlKGNuLCB0LCByZXMpO1xyXG5cdH07XHJcbn07XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8vIEluc3RhbGwgRE9NIDMgWFBhdGggc3VwcG9ydCBmb3IgdGhlIGN1cnJlbnQgZG9jdW1lbnQuXHJcbnRyeSB7XHJcblx0dmFyIHNob3VsZEluc3RhbGwgPSB0cnVlO1xyXG5cdHRyeSB7XHJcblx0XHRpZiAoZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cclxuXHRcdFx0XHQmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlXHJcblx0XHRcdFx0JiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcIlhQYXRoXCIsIG51bGwpKSB7XHJcblx0XHRcdHNob3VsZEluc3RhbGwgPSBmYWxzZTtcclxuXHRcdH1cclxuXHR9IGNhdGNoIChlKSB7XHJcblx0fVxyXG5cdGlmIChzaG91bGRJbnN0YWxsKSB7XHJcblx0XHRpbnN0YWxsRE9NM1hQYXRoU3VwcG9ydChkb2N1bWVudCwgbmV3IFhQYXRoUGFyc2VyKCkpO1xyXG5cdH1cclxufSBjYXRjaCAoZSkge1xyXG59XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gZXhwb3J0cyBmb3Igbm9kZS5qc1xyXG5cclxuaW5zdGFsbERPTTNYUGF0aFN1cHBvcnQoZXhwb3J0cywgbmV3IFhQYXRoUGFyc2VyKCkpO1xyXG5cclxuZXhwb3J0cy5YUGF0aFJlc3VsdCA9IFhQYXRoUmVzdWx0O1xyXG5cclxuLy8gaGVscGVyXHJcbmV4cG9ydHMuc2VsZWN0ID0gZnVuY3Rpb24oZSwgZG9jLCBzaW5nbGUpIHtcclxuXHRyZXR1cm4gZXhwb3J0cy5zZWxlY3RXaXRoUmVzb2x2ZXIoZSwgZG9jLCBudWxsLCBzaW5nbGUpO1xyXG59O1xyXG5cclxuZXhwb3J0cy51c2VOYW1lc3BhY2VzID0gZnVuY3Rpb24obWFwcGluZ3MpIHtcclxuXHR2YXIgcmVzb2x2ZXIgPSB7XHJcblx0XHRtYXBwaW5nczogbWFwcGluZ3MgfHwge30sXHJcblx0XHRsb29rdXBOYW1lc3BhY2VVUkk6IGZ1bmN0aW9uKHByZWZpeCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5tYXBwaW5nc1twcmVmaXhdO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbihlLCBkb2MsIHNpbmdsZSkge1xyXG5cdFx0cmV0dXJuIGV4cG9ydHMuc2VsZWN0V2l0aFJlc29sdmVyKGUsIGRvYywgcmVzb2x2ZXIsIHNpbmdsZSk7XHJcblx0fTtcclxufTtcclxuXHJcbmV4cG9ydHMuc2VsZWN0V2l0aFJlc29sdmVyID0gZnVuY3Rpb24oZSwgZG9jLCByZXNvbHZlciwgc2luZ2xlKSB7XHJcblx0dmFyIGV4cHJlc3Npb24gPSBuZXcgWFBhdGhFeHByZXNzaW9uKGUsIHJlc29sdmVyLCBuZXcgWFBhdGhQYXJzZXIoKSk7XHJcblx0dmFyIHR5cGUgPSBYUGF0aFJlc3VsdC5BTllfVFlQRTtcclxuXHJcblx0dmFyIHJlc3VsdCA9IGV4cHJlc3Npb24uZXZhbHVhdGUoZG9jLCB0eXBlLCBudWxsKTtcclxuXHJcblx0aWYgKHJlc3VsdC5yZXN1bHRUeXBlID09IFhQYXRoUmVzdWx0LlNUUklOR19UWVBFKSB7XHJcblx0XHRyZXN1bHQgPSByZXN1bHQuc3RyaW5nVmFsdWU7XHJcblx0fVxyXG5cdGVsc2UgaWYgKHJlc3VsdC5yZXN1bHRUeXBlID09IFhQYXRoUmVzdWx0Lk5VTUJFUl9UWVBFKSB7XHJcblx0XHRyZXN1bHQgPSByZXN1bHQubnVtYmVyVmFsdWU7XHJcblx0fVxyXG5cdGVsc2UgaWYgKHJlc3VsdC5yZXN1bHRUeXBlID09IFhQYXRoUmVzdWx0LkJPT0xFQU5fVFlQRSkge1xyXG5cdFx0cmVzdWx0ID0gcmVzdWx0LmJvb2xlYW5WYWx1ZTtcclxuXHR9XHJcblx0ZWxzZSB7XHJcblx0XHRyZXN1bHQgPSByZXN1bHQubm9kZXM7XHJcblx0XHRpZiAoc2luZ2xlKSB7XHJcblx0XHRcdHJlc3VsdCA9IHJlc3VsdFswXTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5leHBvcnRzLnNlbGVjdDEgPSBmdW5jdGlvbihlLCBkb2MpIHtcclxuXHRyZXR1cm4gZXhwb3J0cy5zZWxlY3QoZSwgZG9jLCB0cnVlKTtcclxufTtcclxuXHJcbi8vIGVuZCBub24tbm9kZSB3cmFwcGVyXHJcbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB4cGF0aCk7XHJcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IDA7XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW1pdHRlci5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSAxO1xuICBlbHNlXG4gICAgcmV0ID0gZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cy5EaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9saWIvRGlzcGF0Y2hlcicpO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEaXNwYXRjaGVyXG4gKiBcbiAqIEBwcmV2ZW50TXVuZ2VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBfcHJlZml4ID0gJ0lEXyc7XG5cbi8qKlxuICogRGlzcGF0Y2hlciBpcyB1c2VkIHRvIGJyb2FkY2FzdCBwYXlsb2FkcyB0byByZWdpc3RlcmVkIGNhbGxiYWNrcy4gVGhpcyBpc1xuICogZGlmZmVyZW50IGZyb20gZ2VuZXJpYyBwdWItc3ViIHN5c3RlbXMgaW4gdHdvIHdheXM6XG4gKlxuICogICAxKSBDYWxsYmFja3MgYXJlIG5vdCBzdWJzY3JpYmVkIHRvIHBhcnRpY3VsYXIgZXZlbnRzLiBFdmVyeSBwYXlsb2FkIGlzXG4gKiAgICAgIGRpc3BhdGNoZWQgdG8gZXZlcnkgcmVnaXN0ZXJlZCBjYWxsYmFjay5cbiAqICAgMikgQ2FsbGJhY2tzIGNhbiBiZSBkZWZlcnJlZCBpbiB3aG9sZSBvciBwYXJ0IHVudGlsIG90aGVyIGNhbGxiYWNrcyBoYXZlXG4gKiAgICAgIGJlZW4gZXhlY3V0ZWQuXG4gKlxuICogRm9yIGV4YW1wbGUsIGNvbnNpZGVyIHRoaXMgaHlwb3RoZXRpY2FsIGZsaWdodCBkZXN0aW5hdGlvbiBmb3JtLCB3aGljaFxuICogc2VsZWN0cyBhIGRlZmF1bHQgY2l0eSB3aGVuIGEgY291bnRyeSBpcyBzZWxlY3RlZDpcbiAqXG4gKiAgIHZhciBmbGlnaHREaXNwYXRjaGVyID0gbmV3IERpc3BhdGNoZXIoKTtcbiAqXG4gKiAgIC8vIEtlZXBzIHRyYWNrIG9mIHdoaWNoIGNvdW50cnkgaXMgc2VsZWN0ZWRcbiAqICAgdmFyIENvdW50cnlTdG9yZSA9IHtjb3VudHJ5OiBudWxsfTtcbiAqXG4gKiAgIC8vIEtlZXBzIHRyYWNrIG9mIHdoaWNoIGNpdHkgaXMgc2VsZWN0ZWRcbiAqICAgdmFyIENpdHlTdG9yZSA9IHtjaXR5OiBudWxsfTtcbiAqXG4gKiAgIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBiYXNlIGZsaWdodCBwcmljZSBvZiB0aGUgc2VsZWN0ZWQgY2l0eVxuICogICB2YXIgRmxpZ2h0UHJpY2VTdG9yZSA9IHtwcmljZTogbnVsbH1cbiAqXG4gKiBXaGVuIGEgdXNlciBjaGFuZ2VzIHRoZSBzZWxlY3RlZCBjaXR5LCB3ZSBkaXNwYXRjaCB0aGUgcGF5bG9hZDpcbiAqXG4gKiAgIGZsaWdodERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuICogICAgIGFjdGlvblR5cGU6ICdjaXR5LXVwZGF0ZScsXG4gKiAgICAgc2VsZWN0ZWRDaXR5OiAncGFyaXMnXG4gKiAgIH0pO1xuICpcbiAqIFRoaXMgcGF5bG9hZCBpcyBkaWdlc3RlZCBieSBgQ2l0eVN0b3JlYDpcbiAqXG4gKiAgIGZsaWdodERpc3BhdGNoZXIucmVnaXN0ZXIoZnVuY3Rpb24ocGF5bG9hZCkge1xuICogICAgIGlmIChwYXlsb2FkLmFjdGlvblR5cGUgPT09ICdjaXR5LXVwZGF0ZScpIHtcbiAqICAgICAgIENpdHlTdG9yZS5jaXR5ID0gcGF5bG9hZC5zZWxlY3RlZENpdHk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBXaGVuIHRoZSB1c2VyIHNlbGVjdHMgYSBjb3VudHJ5LCB3ZSBkaXNwYXRjaCB0aGUgcGF5bG9hZDpcbiAqXG4gKiAgIGZsaWdodERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuICogICAgIGFjdGlvblR5cGU6ICdjb3VudHJ5LXVwZGF0ZScsXG4gKiAgICAgc2VsZWN0ZWRDb3VudHJ5OiAnYXVzdHJhbGlhJ1xuICogICB9KTtcbiAqXG4gKiBUaGlzIHBheWxvYWQgaXMgZGlnZXN0ZWQgYnkgYm90aCBzdG9yZXM6XG4gKlxuICogICBDb3VudHJ5U3RvcmUuZGlzcGF0Y2hUb2tlbiA9IGZsaWdodERpc3BhdGNoZXIucmVnaXN0ZXIoZnVuY3Rpb24ocGF5bG9hZCkge1xuICogICAgIGlmIChwYXlsb2FkLmFjdGlvblR5cGUgPT09ICdjb3VudHJ5LXVwZGF0ZScpIHtcbiAqICAgICAgIENvdW50cnlTdG9yZS5jb3VudHJ5ID0gcGF5bG9hZC5zZWxlY3RlZENvdW50cnk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBXaGVuIHRoZSBjYWxsYmFjayB0byB1cGRhdGUgYENvdW50cnlTdG9yZWAgaXMgcmVnaXN0ZXJlZCwgd2Ugc2F2ZSBhIHJlZmVyZW5jZVxuICogdG8gdGhlIHJldHVybmVkIHRva2VuLiBVc2luZyB0aGlzIHRva2VuIHdpdGggYHdhaXRGb3IoKWAsIHdlIGNhbiBndWFyYW50ZWVcbiAqIHRoYXQgYENvdW50cnlTdG9yZWAgaXMgdXBkYXRlZCBiZWZvcmUgdGhlIGNhbGxiYWNrIHRoYXQgdXBkYXRlcyBgQ2l0eVN0b3JlYFxuICogbmVlZHMgdG8gcXVlcnkgaXRzIGRhdGEuXG4gKlxuICogICBDaXR5U3RvcmUuZGlzcGF0Y2hUb2tlbiA9IGZsaWdodERpc3BhdGNoZXIucmVnaXN0ZXIoZnVuY3Rpb24ocGF5bG9hZCkge1xuICogICAgIGlmIChwYXlsb2FkLmFjdGlvblR5cGUgPT09ICdjb3VudHJ5LXVwZGF0ZScpIHtcbiAqICAgICAgIC8vIGBDb3VudHJ5U3RvcmUuY291bnRyeWAgbWF5IG5vdCBiZSB1cGRhdGVkLlxuICogICAgICAgZmxpZ2h0RGlzcGF0Y2hlci53YWl0Rm9yKFtDb3VudHJ5U3RvcmUuZGlzcGF0Y2hUb2tlbl0pO1xuICogICAgICAgLy8gYENvdW50cnlTdG9yZS5jb3VudHJ5YCBpcyBub3cgZ3VhcmFudGVlZCB0byBiZSB1cGRhdGVkLlxuICpcbiAqICAgICAgIC8vIFNlbGVjdCB0aGUgZGVmYXVsdCBjaXR5IGZvciB0aGUgbmV3IGNvdW50cnlcbiAqICAgICAgIENpdHlTdG9yZS5jaXR5ID0gZ2V0RGVmYXVsdENpdHlGb3JDb3VudHJ5KENvdW50cnlTdG9yZS5jb3VudHJ5KTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFRoZSB1c2FnZSBvZiBgd2FpdEZvcigpYCBjYW4gYmUgY2hhaW5lZCwgZm9yIGV4YW1wbGU6XG4gKlxuICogICBGbGlnaHRQcmljZVN0b3JlLmRpc3BhdGNoVG9rZW4gPVxuICogICAgIGZsaWdodERpc3BhdGNoZXIucmVnaXN0ZXIoZnVuY3Rpb24ocGF5bG9hZCkge1xuICogICAgICAgc3dpdGNoIChwYXlsb2FkLmFjdGlvblR5cGUpIHtcbiAqICAgICAgICAgY2FzZSAnY291bnRyeS11cGRhdGUnOlxuICogICAgICAgICBjYXNlICdjaXR5LXVwZGF0ZSc6XG4gKiAgICAgICAgICAgZmxpZ2h0RGlzcGF0Y2hlci53YWl0Rm9yKFtDaXR5U3RvcmUuZGlzcGF0Y2hUb2tlbl0pO1xuICogICAgICAgICAgIEZsaWdodFByaWNlU3RvcmUucHJpY2UgPVxuICogICAgICAgICAgICAgZ2V0RmxpZ2h0UHJpY2VTdG9yZShDb3VudHJ5U3RvcmUuY291bnRyeSwgQ2l0eVN0b3JlLmNpdHkpO1xuICogICAgICAgICAgIGJyZWFrO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogVGhlIGBjb3VudHJ5LXVwZGF0ZWAgcGF5bG9hZCB3aWxsIGJlIGd1YXJhbnRlZWQgdG8gaW52b2tlIHRoZSBzdG9yZXMnXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcyBpbiBvcmRlcjogYENvdW50cnlTdG9yZWAsIGBDaXR5U3RvcmVgLCB0aGVuXG4gKiBgRmxpZ2h0UHJpY2VTdG9yZWAuXG4gKi9cblxudmFyIERpc3BhdGNoZXIgPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEaXNwYXRjaGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaXNwYXRjaGVyKTtcblxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHRoaXMuX2lzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9pc0hhbmRsZWQgPSB7fTtcbiAgICB0aGlzLl9pc1BlbmRpbmcgPSB7fTtcbiAgICB0aGlzLl9sYXN0SUQgPSAxO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2l0aCBldmVyeSBkaXNwYXRjaGVkIHBheWxvYWQuIFJldHVybnNcbiAgICogYSB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIHdpdGggYHdhaXRGb3IoKWAuXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIoY2FsbGJhY2spIHtcbiAgICB2YXIgaWQgPSBfcHJlZml4ICsgdGhpcy5fbGFzdElEKys7XG4gICAgdGhpcy5fY2FsbGJhY2tzW2lkXSA9IGNhbGxiYWNrO1xuICAgIHJldHVybiBpZDtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNhbGxiYWNrIGJhc2VkIG9uIGl0cyB0b2tlbi5cbiAgICovXG5cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uIHVucmVnaXN0ZXIoaWQpIHtcbiAgICAhdGhpcy5fY2FsbGJhY2tzW2lkXSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdEaXNwYXRjaGVyLnVucmVnaXN0ZXIoLi4uKTogYCVzYCBkb2VzIG5vdCBtYXAgdG8gYSByZWdpc3RlcmVkIGNhbGxiYWNrLicsIGlkKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tpZF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFdhaXRzIGZvciB0aGUgY2FsbGJhY2tzIHNwZWNpZmllZCB0byBiZSBpbnZva2VkIGJlZm9yZSBjb250aW51aW5nIGV4ZWN1dGlvblxuICAgKiBvZiB0aGUgY3VycmVudCBjYWxsYmFjay4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgdXNlZCBieSBhIGNhbGxiYWNrIGluXG4gICAqIHJlc3BvbnNlIHRvIGEgZGlzcGF0Y2hlZCBwYXlsb2FkLlxuICAgKi9cblxuICBEaXNwYXRjaGVyLnByb3RvdHlwZS53YWl0Rm9yID0gZnVuY3Rpb24gd2FpdEZvcihpZHMpIHtcbiAgICAhdGhpcy5faXNEaXNwYXRjaGluZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdEaXNwYXRjaGVyLndhaXRGb3IoLi4uKTogTXVzdCBiZSBpbnZva2VkIHdoaWxlIGRpc3BhdGNoaW5nLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgaWRzLmxlbmd0aDsgaWkrKykge1xuICAgICAgdmFyIGlkID0gaWRzW2lpXTtcbiAgICAgIGlmICh0aGlzLl9pc1BlbmRpbmdbaWRdKSB7XG4gICAgICAgICF0aGlzLl9pc0hhbmRsZWRbaWRdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Rpc3BhdGNoZXIud2FpdEZvciguLi4pOiBDaXJjdWxhciBkZXBlbmRlbmN5IGRldGVjdGVkIHdoaWxlICcgKyAnd2FpdGluZyBmb3IgYCVzYC4nLCBpZCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgICF0aGlzLl9jYWxsYmFja3NbaWRdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Rpc3BhdGNoZXIud2FpdEZvciguLi4pOiBgJXNgIGRvZXMgbm90IG1hcCB0byBhIHJlZ2lzdGVyZWQgY2FsbGJhY2suJywgaWQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2ludm9rZUNhbGxiYWNrKGlkKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYSBwYXlsb2FkIHRvIGFsbCByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAgICovXG5cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaChwYXlsb2FkKSB7XG4gICAgISF0aGlzLl9pc0Rpc3BhdGNoaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Rpc3BhdGNoLmRpc3BhdGNoKC4uLik6IENhbm5vdCBkaXNwYXRjaCBpbiB0aGUgbWlkZGxlIG9mIGEgZGlzcGF0Y2guJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N0YXJ0RGlzcGF0Y2hpbmcocGF5bG9hZCk7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICBpZiAodGhpcy5faXNQZW5kaW5nW2lkXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludm9rZUNhbGxiYWNrKGlkKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fc3RvcERpc3BhdGNoaW5nKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJcyB0aGlzIERpc3BhdGNoZXIgY3VycmVudGx5IGRpc3BhdGNoaW5nLlxuICAgKi9cblxuICBEaXNwYXRjaGVyLnByb3RvdHlwZS5pc0Rpc3BhdGNoaW5nID0gZnVuY3Rpb24gaXNEaXNwYXRjaGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faXNEaXNwYXRjaGluZztcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbCB0aGUgY2FsbGJhY2sgc3RvcmVkIHdpdGggdGhlIGdpdmVuIGlkLiBBbHNvIGRvIHNvbWUgaW50ZXJuYWxcbiAgICogYm9va2tlZXBpbmcuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICBEaXNwYXRjaGVyLnByb3RvdHlwZS5faW52b2tlQ2FsbGJhY2sgPSBmdW5jdGlvbiBfaW52b2tlQ2FsbGJhY2soaWQpIHtcbiAgICB0aGlzLl9pc1BlbmRpbmdbaWRdID0gdHJ1ZTtcbiAgICB0aGlzLl9jYWxsYmFja3NbaWRdKHRoaXMuX3BlbmRpbmdQYXlsb2FkKTtcbiAgICB0aGlzLl9pc0hhbmRsZWRbaWRdID0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHVwIGJvb2trZWVwaW5nIG5lZWRlZCB3aGVuIGRpc3BhdGNoaW5nLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUuX3N0YXJ0RGlzcGF0Y2hpbmcgPSBmdW5jdGlvbiBfc3RhcnREaXNwYXRjaGluZyhwYXlsb2FkKSB7XG4gICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICB0aGlzLl9pc1BlbmRpbmdbaWRdID0gZmFsc2U7XG4gICAgICB0aGlzLl9pc0hhbmRsZWRbaWRdID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX3BlbmRpbmdQYXlsb2FkID0gcGF5bG9hZDtcbiAgICB0aGlzLl9pc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXIgYm9va2tlZXBpbmcgdXNlZCBmb3IgZGlzcGF0Y2hpbmcuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICBEaXNwYXRjaGVyLnByb3RvdHlwZS5fc3RvcERpc3BhdGNoaW5nID0gZnVuY3Rpb24gX3N0b3BEaXNwYXRjaGluZygpIHtcbiAgICBkZWxldGUgdGhpcy5fcGVuZGluZ1BheWxvYWQ7XG4gICAgdGhpcy5faXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICB9O1xuXG4gIHJldHVybiBEaXNwYXRjaGVyO1xufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEaXNwYXRjaGVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpbnZhcmlhbnRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0ludmFyaWFudCBWaW9sYXRpb246ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50OyIsIi8qIVxuICogbm9kZS1jYWxlbmRhclxuICogQ29weXJpZ2h0KGMpIDIwMTMgQXJtaW4gVGFtemFyaWFuIDx0YW16YXJpYW4xOTg5QGdtYWlsLmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbihmdW5jdGlvbigpIHtcblxuICAgIHZhciBfREFZU19JTl9NT05USCA9IFswLCAzMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTtcbiAgICB2YXIgX0RBWVNfQkVGT1JFX01PTlRIID0gWy0xLCAwLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG5cbiAgICB0cnkge1xuICAgICAgdmFyIGNsZHIgPSByZXF1aXJlKFwiY2xkclwiKTtcbiAgICB9XG4gICAgY2F0Y2goZXJyKSB7XG4gICAgICBjbGRyID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0IHRoZSBwcm92aWRlZCB3ZWVrZGF5IGluZGV4IGZyb20gdGhlIEphdmFzY3JpcHQgaW5kZXggc2NoZW1lXG4gICAgICogKFNVTj0wLCBNT049MSwgLi4uKSB0byB0aGUgUHl0aG9uIHNjaGVtZSAoTU9OPTAsIFRVRT0xLCAuLi4pXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfYWRqdXN0V2Vla2RheSh3ZWVrZGF5KSB7XG4gICAgICByZXR1cm4gd2Vla2RheSA+IDAgPyB3ZWVrZGF5IC0gMSA6IDZcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHdpZGUgb3IgYWJicmV2aWF0ZWQgZGF5IG5hbWVzIGZvciBhIHNwZWNpZmllZCBsb2NhbGUuXG4gICAgICogSWYgY2xkciBpcyBub3QgaW5zdGFsbGVkIHZhbHVlcyBkZWZhdWx0IHRvIHRoYXQgZm9yIGxvY2FsZSBlbl9VUy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWJiclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsb2NhbGVcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZXh0cmFjdExvY2FsZURheXMoYWJiciwgbG9jYWxlKSB7XG4gICAgICBzaG9ydCA9IHR5cGVvZihhYmJyKSA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogYWJicjtcblxuICAgICAgaWYoYWJicikge1xuICAgICAgICByZXR1cm4gY2xkciA/IGNsZHIuZXh0cmFjdERheU5hbWVzKGxvY2FsZSkuZm9ybWF0LmFiYnJldmlhdGVkIDogWydNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCcsICdTdW4nXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY2xkciA/IGNsZHIuZXh0cmFjdERheU5hbWVzKGxvY2FsZSkuZm9ybWF0LndpZGUgOiBbJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknLCAnU3VuZGF5J107XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB3aWRlIG9yIGFiYnJldmlhdGVkIG1vbnRoIG5hbWVzIGZvciBhIHNwZWNpZmllZCBsb2NhbGUuXG4gICAgICogSWYgY2xkciBpcyBub3QgaW5zdGFsbGVkIHZhbHVlcyBkZWZhdWx0IHRvIHRoYXQgZm9yIGxvY2FsZSBlbl9VUy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWJiclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsb2NhbGVcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZXh0cmFjdExvY2FsZU1vbnRocyhhYmJyLCBsb2NhbGUpIHtcbiAgICAgIHNob3J0ID0gdHlwZW9mKGFiYnIpID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBhYmJyO1xuXG4gICAgICB2YXIgbW9udGhzID0gW11cbiAgICAgIGlmKGFiYnIpIHtcbiAgICAgICAgbW9udGhzID0gY2xkciA/IGNsZHIuZXh0cmFjdE1vbnRoTmFtZXMobG9jYWxlKS5mb3JtYXQuYWJicmV2aWF0ZWQgOiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ107XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbW9udGhzID0gY2xkciA/IGNsZHIuZXh0cmFjdE1vbnRoTmFtZXMobG9jYWxlKS5mb3JtYXQud2lkZSA6IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddO1xuICAgICAgfVxuXG4gICAgICBtb250aHMudW5zaGlmdCgnJyk7XG4gICAgICByZXR1cm4gbW9udGhzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBvcmRpbmFsIHRpbWUgZnJvbSBnaXZlbiB5ZWFyLCBtb250aCwgZGF5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1vbnRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRheVxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF90b29yZGluYWwoeWVhciwgbW9udGgsIGRheSkge1xuICAgICAgdmFyIGRheXNfYmVmb3JlX3llYXIgPSAoKHllYXIgLSAxKSAqIDM2NSkgKyBNYXRoLmZsb29yKCh5ZWFyIC0gMSkgLyA0KSAtIE1hdGguZmxvb3IoKHllYXIgLSAxKSAvIDEwMCkgKyBNYXRoLmZsb29yKCh5ZWFyIC0gMSkgLyA0MDApO1xuICAgICAgdmFyIGRheXNfYmVmb3JlX21vbnRoID0gX0RBWVNfQkVGT1JFX01PTlRIW21vbnRoXSArIChtb250aCA+IDIgJiYgaXNsZWFwKHllYXIpID8gMSA6IDApO1xuICAgICAgcmV0dXJuIChkYXlzX2JlZm9yZV95ZWFyICsgZGF5c19iZWZvcmVfbW9udGggKyBkYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGZvciBsZWFwIHllYXJzLCBmYWxzZSBmb3Igbm9uLWxlYXAgeWVhcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geWVhclxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNsZWFwKHllYXIpIHtcbiAgICAgIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIG51bWJlciBvZiBsZWFwIHllYXJzIGluIHJhbmdlIFt5MSwgeTIpLlxuICAgICAqIEFzc3VtZXMgeTEgPD0geTIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geTFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geTJcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxlYXBkYXlzKHkxLCB5Mikge1xuICAgICAgeTEtLTtcbiAgICAgIHkyLS07XG4gICAgICByZXR1cm4gKE1hdGguZmxvb3IoeTIvNCkgLSBNYXRoLmZsb29yKHkxLzQpKSAtIChNYXRoLmZsb29yKHkyLzEwMCkgLSBNYXRoLmZsb29yKHkxLzEwMCkpICsgKE1hdGguZmxvb3IoeTIvNDAwKSAtIE1hdGguZmxvb3IoeTEvNDAwKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBzdGFydGluZyB3ZWVrZGF5ICgwLTYgfiBNb24tU3VuKSBhbmQgbnVtYmVyIG9mIGRheXMgKDI4LTMxKSBmb3JcbiAgICAgKiB5ZWFyLCBtb250aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1vbnRoXG4gICAgICogQHRocm93cyB7SWxsZWdhbE1vbnRoRXJyb3J9IElmIHRoZSBwcm92aWRlZCBtb250aCBpcyBpbnZhbGlkLlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgZnVuY3Rpb24gbW9udGhyYW5nZSh5ZWFyLCBtb250aCkge1xuICAgICAgaWYobW9udGggPCAxIHx8IG1vbnRoID4gMTIpIHtcbiAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxNb250aEVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXkxID0gd2Vla2RheSh5ZWFyLCBtb250aCwgMSk7XG4gICAgICB2YXIgbmRheXMgPSBfREFZU19JTl9NT05USFttb250aF0gKyAobW9udGggPT09IDIgJiYgaXNsZWFwKHllYXIpKTtcblxuICAgICAgcmV0dXJuIFtkYXkxLCBuZGF5c107XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxvY2FsZSBmb3IgdXNlIGluIGV4dHJhY3RpbmcgbW9udGggYW5kIHdlZWtkYXkgbmFtZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbG9jYWxlXG4gICAgICogQHRocm93cyB7SWxsZWdhbExvY2FsZUVycm9yfSBJZiB0aGUgcHJvdmlkZWQgbG9jYWxlIGlzIGludmFsaWQuXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRsb2NhbGUobG9jYWxlKSB7XG4gICAgICBsb2NhbGUgPSB0eXBlb2YobG9jYWxlKSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwiZW5fVVNcIiA6IGxvY2FsZTtcblxuICAgICAgaWYoKGNsZHIgJiYgKGNsZHIubG9jYWxlSWRzLmluZGV4T2YobG9jYWxlLnJlcGxhY2UoLy0vZywgJ18nKS50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpKSB8fCAoIWNsZHIgJiYgKChsb2NhbGUucmVwbGFjZSgvLS9nLCAnXycpLnRvTG93ZXJDYXNlKCkgIT09IFwiZW5fdXNcIikpKSkge1xuICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxMb2NhbGVFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRheV9uYW1lICAgPSBfZXh0cmFjdExvY2FsZURheXMoZmFsc2UsIGxvY2FsZSk7XG4gICAgICB0aGlzLmRheV9hYmJyICAgPSBfZXh0cmFjdExvY2FsZURheXModHJ1ZSwgbG9jYWxlKTtcbiAgICAgIHRoaXMubW9udGhfbmFtZSA9IF9leHRyYWN0TG9jYWxlTW9udGhzKGZhbHNlLCBsb2NhbGUpO1xuICAgICAgdGhpcy5tb250aF9hYmJyID0gX2V4dHJhY3RMb2NhbGVNb250aHModHJ1ZSwgbG9jYWxlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICAqIFVucmVsYXRlZCBidXQgaGFuZHkgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIFVuaXggdGltZXN0YW1wIGZyb20gR01ULlxuICAgICAgKlxuICAgICAgKiBAcGFyYW0ge0FycmF5fSB0dXBsZVxuICAgICAgKiBAdGhyb3dzIHtJbGxlZ2FsTW9udGhFcnJvcn0gSWYgdGhlIHByb3ZpZGVkIG1vbnRoIGVsZW1lbnQgaXMgaW52YWxpZC5cbiAgICAgICogQHRocm93cyB7SWxsZWdhbERheUVycm9yfSBJZiB0aGUgcHJvdmlkZWQgZGF5IGVsZW1lbnQgaXMgaW52YWxpZC5cbiAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICovXG4gICAgZnVuY3Rpb24gdGltZWdtKHRpbWVnbXQpIHtcbiAgICAgIHZhciB5ZWFyICAgPSB0aW1lZ210WzBdO1xuICAgICAgdmFyIG1vbnRoICA9IHRpbWVnbXRbMV07XG4gICAgICB2YXIgZGF5ICAgID0gdGltZWdtdFsyXTtcbiAgICAgIHZhciBob3VyICAgPSB0aW1lZ210WzNdO1xuICAgICAgdmFyIG1pbnV0ZSA9IHRpbWVnbXRbNF07XG4gICAgICB2YXIgc2Vjb25kID0gdGltZWdtdFs1XTtcblxuICAgICAgaWYobW9udGggPCAxIHx8IG1vbnRoID4gMTIpIHtcbiAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxNb250aEVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIGlmKGRheSA8IDEgfHwgZGF5ID4gKF9EQVlTX0lOX01PTlRIW21vbnRoXSArIChtb250aCA9PT0gMiAmJiBpc2xlYXAoeWVhcikpKSkge1xuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbERheUVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIGlmKGhvdXIgPCAwIHx8IGhvdXIgPiAyMyB8fCBtaW51dGUgPCAwIHx8IG1pbnV0ZSA+IDU5IHx8IHNlY29uZCA8IDAgfHwgc2Vjb25kID4gNTkpIHtcbiAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxUaW1lRXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRheXMgPSBfdG9vcmRpbmFsKHllYXIsIG1vbnRoLCAxKSAtIDcxOTE2MyArIGRheSAtIDE7XG4gICAgICB2YXIgaG91cnMgPSAoZGF5cyAqIDI0KSArIGhvdXI7XG4gICAgICB2YXIgbWludXRlcyA9IChob3VycyAqIDYwKSArIG1pbnV0ZTtcbiAgICAgIHZhciBzZWNvbmRzID0gKG1pbnV0ZXMgKiA2MCkgKyBzZWNvbmQ7XG5cbiAgICAgIHJldHVybiBzZWNvbmRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB3ZWVrZGF5ICgwLTYgfiBNb24tU3VuKSBmb3IgeWVhciAoMTk3MC0uLi4pLCBtb250aCAoMS0xMiksXG4gICAgICogZGF5ICgxLTMxKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1vbnRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRheVxuICAgICAqIEB0aHJvd3Mge0lsbGVnYWxNb250aEVycm9yfSBJZiB0aGUgcHJvdmlkZWQgbW9udGggZWxlbWVudCBpcyBpbnZhbGlkLlxuICAgICAqIEB0aHJvd3Mge0lsbGVnYWxEYXlFcnJvcn0gSWYgdGhlIHByb3ZpZGVkIGRheSBlbGVtZW50IGlzIGludmFsaWQuXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3ZWVrZGF5KHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgICAgIGlmKG1vbnRoIDwgMSB8fCBtb250aCA+IDEyKSB7XG4gICAgICAgIHRocm93IG5ldyBJbGxlZ2FsTW9udGhFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICBpZihkYXkgPCAxIHx8IGRheSA+IChfREFZU19JTl9NT05USFttb250aF0gKyAobW9udGggPT09IDIgJiYgaXNsZWFwKHllYXIpKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxEYXlFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5KTtcbiAgICAgIHJldHVybiBfYWRqdXN0V2Vla2RheShkYXRlLmdldERheSgpKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBCYXNlIGNhbGVuZGFyIGNsYXNzLiBUaGlzIGNsYXNzIGRvZXNuJ3QgZG8gYW55IGZvcm1hdHRpbmcuIEl0IHNpbXBseVxuICAgICAqIHByb3ZpZGVzIGRhdGEgdG8gc3ViY2xhc3Nlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmaXJzdHdlZWtkYXlcbiAgICAgKiBAdGhyb3dzIHtJbGxlZ2FsV2Vla2RheUVycm9yfSBJZiB0aGUgcHJvdmlkZWQgZmlyc3R3ZWVrZGF5IGlzIGludmFsaWQuXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDYWxlbmRhcihmaXJzdHdlZWtkYXkpIHtcbiAgICAgIHRoaXMuX2ZpcnN0d2Vla2RheSA9IHR5cGVvZihmaXJzdHdlZWtkYXkpID09PSBcInVuZGVmaW5lZFwiID8gMCA6IGZpcnN0d2Vla2RheTtcblxuICAgICAgaWYoZmlyc3R3ZWVrZGF5IDwgMCB8fCBmaXJzdHdlZWtkYXkgPiA2KSB7XG4gICAgICAgIHRocm93IG5ldyBJbGxlZ2FsV2Vla2RheUVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX29uZWRheSA9IDEwMDAgKiA2MCAqIDYwICogMjQ7XG4gICAgICB0aGlzLl9vbmVob3VyID0gMTAwMCAqIDYwICogNjA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdFVC1lciBmb3IgZmlyc3R3ZWVrZGF5XG4gICAgICpcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXRmaXJzdHdlZWtkYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdHdlZWtkYXk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNFVC1lciBmb3IgZmlyc3R3ZWVrZGF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZmlyc3R3ZWVrZGF5XG4gICAgICogQHRocm93cyB7SWxsZWdhbFdlZWtkYXlFcnJvcn0gSWYgdGhlIHByb3ZpZGVkIGZpcnN0d2Vla2RheSBpcyBpbnZhbGlkLlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnNldGZpcnN0d2Vla2RheSA9IGZ1bmN0aW9uKGZpcnN0d2Vla2RheSkge1xuICAgICAgaWYoZmlyc3R3ZWVrZGF5IDwgMCB8fCBmaXJzdHdlZWtkYXkgPiA2KSB7XG4gICAgICAgIHRocm93IG5ldyBJbGxlZ2FsV2Vla2RheUVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2ZpcnN0d2Vla2RheSA9IGZpcnN0d2Vla2RheTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFycmF5IGZvciBvbmUgd2VlayBvZiB3ZWVrZGF5IG51bWJlcnMgc3RhcnRpbmcgd2l0aCB0aGVcbiAgICAgKiBjb25maWd1cmVkIGZpcnN0IG9uZS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLml0ZXJ3ZWVrZGF5cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHdlZWtkYXlzID0gW107XG4gICAgICBmb3IodmFyIGkgPSB0aGlzLl9maXJzdHdlZWtkYXk7IGkgPCB0aGlzLl9maXJzdHdlZWtkYXkgKyA3OyBpKyspIHtcbiAgICAgICAgd2Vla2RheXMucHVzaChpICUgNyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3ZWVrZGF5cztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFycmF5IGZvciBvbmUgbW9udGguIFRoZSBhcnJheSB3aWxsIGNvbnRhaW4gRGF0ZVxuICAgICAqIHZhbHVlcyBhbmQgd2lsbCBhbHdheXMgaXRlcmF0ZSB0aHJvdWdoIGNvbXBsZXRlIHdlZWtzLCBzbyBpdCB3aWxsIHlpZWxkXG4gICAgICogZGF0ZXMgb3V0c2lkZSB0aGUgc3BlY2lmaWVkIG1vbnRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbW9udGhcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLml0ZXJtb250aGRhdGVzID0gZnVuY3Rpb24oeWVhciwgbW9udGgpIHtcbiAgICAgIGlmKG1vbnRoIDwgMSB8fCBtb250aCA+IDEyKSB7XG4gICAgICAgIHRocm93IG5ldyBJbGxlZ2FsTW9udGhFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgMSk7XG4gICAgICB2YXIgZGF5ID0gX2FkanVzdFdlZWtkYXkoZGF0ZS5nZXREYXkoKSk7XG4gICAgICB2YXIgZGF5cyA9IChkYXkgLSB0aGlzLl9maXJzdHdlZWtkYXkpICA+PSAwID8gKGRheSAtIHRoaXMuX2ZpcnN0d2Vla2RheSkgJSA3IDogNyArIChkYXkgLSB0aGlzLl9maXJzdHdlZWtkYXkpO1xuXG4gICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgLSAoZGF5cyAqIHRoaXMuX29uZWRheSkpO1xuXG4gICAgICB2YXIgZGF0ZXMgPSBbXTtcbiAgICAgIHdoaWxlKHRydWUpIHtcbiAgICAgICAgZGF0ZXMucHVzaChuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSkpO1xuXG4gICAgICAgIHZhciBjdXJyZW50RGF0ZSA9IGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyB0aGlzLl9vbmVkYXkpO1xuXG4gICAgICAgIC8vIEhhY2sgdG8gYWNjb3VudCBmb3IgRFNUXG4gICAgICAgIHdoaWxlKGRhdGUuZ2V0RGF0ZSgpID09PSBjdXJyZW50RGF0ZSkge1xuICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIHRoaXMuX29uZWhvdXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZGF0ZS5nZXRNb250aCgpICE9PSBtb250aCAtIDEgJiYgX2FkanVzdFdlZWtkYXkoZGF0ZS5nZXREYXkoKSkgPT09IHRoaXMuX2ZpcnN0d2Vla2RheSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExpa2UgaXRlcm1vbnRoZGF0ZXMoKSwgYnV0IHdpbGwgeWllbGQgZGF5IG51bWJlcnMuIEZvciBkYXlzIG91dHNpZGVcbiAgICAgKiB0aGUgc3BlY2lmaWVkIG1vbnRoIHRoZSBkYXkgbnVtYmVyIGlzIDAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geWVhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtb250aFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLml0ZXJtb250aGRheXMgPSBmdW5jdGlvbih5ZWFyLCBtb250aCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXRlcm1vbnRoZGF0ZXMoeWVhciwgbW9udGgpLm1hcChmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgIHJldHVybiB2YWx1ZS5nZXRNb250aCgpID09PSBtb250aCAtIDEgPyB2YWx1ZS5nZXREYXRlKCkgOiAwO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExpa2UgaXRlcm1vbnRoZGF0ZXMoKSwgYnV0IHdpbGwgeWllbGQgW2RheSBudW1iZXIsIHdlZWtkYXkgbnVtYmVyXVxuICAgICAqIGFycmF5cy4gRm9yIGRheXMgb3V0c2lkZSB0aGUgc3BlY2lmaWVkIG1vbnRoIHRoZSBkYXkgbnVtYmVyIGlzIDAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geWVhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtb250aFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLml0ZXJtb250aGRheXMyID0gZnVuY3Rpb24oeWVhciwgbW9udGgpIHtcbiAgICAgIHJldHVybiB0aGlzLml0ZXJtb250aGRhdGVzKHllYXIsIG1vbnRoKS5tYXAoZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICByZXR1cm4gdmFsdWUuZ2V0TW9udGgoKSA9PT0gbW9udGggLSAxID8gW3ZhbHVlLmdldERhdGUoKSwgX2FkanVzdFdlZWtkYXkodmFsdWUuZ2V0RGF5KCkpXSA6IFswLCBfYWRqdXN0V2Vla2RheSh2YWx1ZS5nZXREYXkoKSldO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG1hdHJpeCAoYXJyYXkgb2YgYXJyYXkpIHJlcHJlc2VudGluZyBhIG1vbnRoJ3MgY2FsZW5kYXIuXG4gICAgICogRWFjaCByb3cgcmVwcmVzZW50cyBhIHdlZWs7IHdlZWsgZW50cmllcyBhcmUgRGF0ZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geWVhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtb250aFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm1vbnRoZGF0ZXNjYWxlbmRhciA9IGZ1bmN0aW9uKHllYXIsIG1vbnRoKSB7XG4gICAgICB2YXIgZGF5cyA9IFtdO1xuICAgICAgZGF0ZXMgPSB0aGlzLml0ZXJtb250aGRhdGVzKHllYXIsIG1vbnRoKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkYXRlcy5sZW5ndGg7IGkgKz0gNykge1xuICAgICAgICBkYXlzLnB1c2goZGF0ZXMuc2xpY2UoaSwgaSArIDcpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRheXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG1hdHJpeCByZXByZXNlbnRpbmcgYSBtb250aCdzIGNhbGVuZGFyLlxuICAgICAqIEVhY2ggcm93IHJlcHJlc2VudHMgYSB3ZWVrOyBkYXlzIG91dHNpZGUgdGhpcyBtb250aCBhcmUgemVyby5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1vbnRoXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBDYWxlbmRhci5wcm90b3R5cGUubW9udGhkYXlzY2FsZW5kYXIgPSBmdW5jdGlvbih5ZWFyLCBtb250aCkge1xuICAgICAgdmFyIGRheXMgPSBbXTtcbiAgICAgIGRhdGVzID0gdGhpcy5pdGVybW9udGhkYXlzKHllYXIsIG1vbnRoKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkYXRlcy5sZW5ndGg7IGkgKz0gNykge1xuICAgICAgICBkYXlzLnB1c2goZGF0ZXMuc2xpY2UoaSwgaSArIDcpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRheXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG1hdHJpeCByZXByZXNlbnRpbmcgYSBtb250aCdzIGNhbGVuZGFyLlxuICAgICAqIEVhY2ggcm93IHJlcHJlc2VudHMgYSB3ZWVrOyB3ZWVrIGVudHJpZXMgYXJlXG4gICAgICogW2RheSBudW1iZXIsIHdlZWtkYXkgbnVtYmVyXSBhcnJheXMuIERheSBudW1iZXJzIG91dHNpZGUgdGhpcyBtb250aFxuICAgICAqIGFyZSB6ZXJvLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbW9udGhcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5tb250aGRheXMyY2FsZW5kYXIgPSBmdW5jdGlvbih5ZWFyLCBtb250aCkge1xuICAgICAgdmFyIGRheXMgPSBbXTtcbiAgICAgIGRhdGVzID0gdGhpcy5pdGVybW9udGhkYXlzMih5ZWFyLCBtb250aCk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGF0ZXMubGVuZ3RoOyBpICs9IDcpIHtcbiAgICAgICAgZGF5cy5wdXNoKGRhdGVzLnNsaWNlKGksIGkgKyA3KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRhdGEgZm9yIHRoZSBzcGVjaWZpZWQgeWVhciByZWFkeSBmb3IgZm9ybWF0dGluZy4gVGhlIHJldHVyblxuICAgICAqIHZhbHVlIGlzIGFuIGFycmF5IG9mIG1vbnRoIHJvd3MuIEVhY2ggbW9udGggcm93IGNvbnRhaW5zIHVwIHRvIHdpZHRoIG1vbnRocy5cbiAgICAgKiBFYWNoIG1vbnRoIGNvbnRhaW5zIGJldHdlZW4gNCBhbmQgNiB3ZWVrcyBhbmQgZWFjaCB3ZWVrIGNvbnRhaW5zIDEtN1xuICAgICAqIGRheXMuIERheXMgYXJlIERhdGUgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBDYWxlbmRhci5wcm90b3R5cGUueWVhcmRhdGVzY2FsZW5kYXIgPSBmdW5jdGlvbih5ZWFyLCB3aWR0aCkge1xuICAgICAgd2lkdGggPSB0eXBlb2Yod2lkdGgpID09PSBcInVuZGVmaW5lZFwiID8gMyA6IHdpZHRoO1xuXG4gICAgICB2YXIgbW9udGhzID0gW107XG4gICAgICBmb3IodmFyIG1vbnRoID0gMTsgbW9udGggPD0gMTI7IG1vbnRoKyspIHtcbiAgICAgICAgbW9udGhzLnB1c2godGhpcy5tb250aGRhdGVzY2FsZW5kYXIoeWVhciwgbW9udGgpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJvd3MgPSBbXTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtb250aHMubGVuZ3RoOyBpICs9IHdpZHRoKSB7XG4gICAgICAgIHJvd3MucHVzaChtb250aHMuc2xpY2UoaSwgaSArIHdpZHRoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm93cztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkYXRhIGZvciB0aGUgc3BlY2lmaWVkIHllYXIgcmVhZHkgZm9yIGZvcm1hdHRpbmcgKHNpbWlsYXIgdG9cbiAgICAgKiB5ZWFyZGF0ZXNjYWxlbmRhcigpKS4gRW50cmllcyBpbiB0aGUgd2VlayBhcnJheXMgYXJlIGRheSBudW1iZXJzLlxuICAgICAqIERheSBudW1iZXJzIG91dHNpZGUgdGhpcyBtb250aCBhcmUgemVyby5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBDYWxlbmRhci5wcm90b3R5cGUueWVhcmRheXNjYWxlbmRhciA9IGZ1bmN0aW9uKHllYXIsIHdpZHRoKSB7XG4gICAgICB3aWR0aCA9IHR5cGVvZih3aWR0aCkgPT09IFwidW5kZWZpbmVkXCIgPyAzIDogd2lkdGg7XG5cbiAgICAgIHZhciBtb250aHMgPSBbXTtcbiAgICAgIGZvcih2YXIgbW9udGggPSAxOyBtb250aCA8PSAxMjsgbW9udGgrKykge1xuICAgICAgICBtb250aHMucHVzaCh0aGlzLm1vbnRoZGF5c2NhbGVuZGFyKHllYXIsIG1vbnRoKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByb3dzID0gW107XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbW9udGhzLmxlbmd0aDsgaSArPSB3aWR0aCkge1xuICAgICAgICByb3dzLnB1c2gobW9udGhzLnNsaWNlKGksIGkgKyB3aWR0aCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCB5ZWFyIHJlYWR5IGZvciBmb3JtYXR0aW5nIChzaW1pbGFyIHRvXG4gICAgICogeWVhcmRhdGVzY2FsZW5kYXIoKSkuIEVudHJpZXMgaW4gdGhlIHdlZWsgYXJyYXlzIGFyZVxuICAgICAqIFtkYXkgbnVtYmVyLCB3ZWVrZGF5IG51bWJlcl0gYXJyYXlzLiBEYXkgbnVtYmVycyBvdXRzaWRlIHRoaXMgbW9udGggYXJlXG4gICAgICogemVyby5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBDYWxlbmRhci5wcm90b3R5cGUueWVhcmRheXMyY2FsZW5kYXIgPSBmdW5jdGlvbih5ZWFyLCB3aWR0aCkge1xuICAgICAgd2lkdGggPSB0eXBlb2Yod2lkdGgpID09PSBcInVuZGVmaW5lZFwiID8gMyA6IHdpZHRoO1xuXG4gICAgICB2YXIgbW9udGhzID0gW107XG4gICAgICBmb3IodmFyIG1vbnRoID0gMTsgbW9udGggPD0gMTI7IG1vbnRoKyspIHtcbiAgICAgICAgbW9udGhzLnB1c2godGhpcy5tb250aGRheXMyY2FsZW5kYXIoeWVhciwgbW9udGgpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJvd3MgPSBbXTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtb250aHMubGVuZ3RoOyBpICs9IHdpZHRoKSB7XG4gICAgICAgIHJvd3MucHVzaChtb250aHMuc2xpY2UoaSwgaSArIHdpZHRoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm93cztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXJyb3IgaW5kaWNhdGluZyBhIG5vbmV4aXN0ZW50IG9yIHVuc3VwcG9ydGVkIGxvY2FsZSBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgZnVuY3Rpb24gSWxsZWdhbExvY2FsZUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgIHRoaXMubmFtZSA9IFwiSWxsZWdhbExvY2FsZUVycm9yXCI7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSB0eXBlb2YobWVzc2FnZSkgPT09IFwidW5kZWZpbmVkXCIgPyBcIkludmFsaWQgbG9jYWxlIHNwZWNpZmllZC5cIiA6IG1lc3NhZ2U7XG4gICAgfTtcbiAgICBJbGxlZ2FsTG9jYWxlRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gICAgSWxsZWdhbExvY2FsZUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IElsbGVnYWxMb2NhbGVFcnJvcjtcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGluZGljYXRpbmcgYSBkYXkgaW5kZXggc3BlY2lmaWVkIG91dHNpZGUgb2YgdGhlIHZhbGlkIHJhbmdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIElsbGVnYWxEYXlFcnJvcihtZXNzYWdlKSB7XG4gICAgICB0aGlzLm5hbWUgPSBcIklsbGVnYWxEYXlFcnJvclwiO1xuICAgICAgdGhpcy5tZXNzYWdlID0gdHlwZW9mKG1lc3NhZ2UpID09PSBcInVuZGVmaW5lZFwiID8gXCJJbnZhbGlkIGRheSBzcGVjaWZpZWQuXCIgOiBtZXNzYWdlO1xuICAgIH07XG4gICAgSWxsZWdhbERheUVycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICAgIElsbGVnYWxEYXlFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbGxlZ2FsRGF5RXJyb3I7XG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBpbmRpY2F0aW5nIGEgbW9udGggaW5kZXggc3BlY2lmaWVkIG91dHNpZGUgb2YgdGhlIGV4cGVjdGVkIHJhbmdlICgxLTEyIH4gSmFuLURlYykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgZnVuY3Rpb24gSWxsZWdhbE1vbnRoRXJyb3IobWVzc2FnZSkge1xuICAgICAgdGhpcy5uYW1lID0gXCJJbGxlZ2FsTW9udGhFcnJvclwiO1xuICAgICAgdGhpcy5tZXNzYWdlID0gdHlwZW9mKG1lc3NhZ2UpID09PSBcInVuZGVmaW5lZFwiID8gXCJJbnZhbGlkIG1vbnRoIHNwZWNpZmllZC5cIiA6IG1lc3NhZ2U7XG4gICAgfTtcbiAgICBJbGxlZ2FsTW9udGhFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgICBJbGxlZ2FsTW9udGhFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbGxlZ2FsTW9udGhFcnJvcjtcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGluZGljYXRpbmcgYSB0aW1lIGVsZW1lbnQgaXMgb3V0c2lkZSBvZiB0aGUgdmFsaWQgcmFuZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgZnVuY3Rpb24gSWxsZWdhbFRpbWVFcnJvcihtZXNzYWdlKSB7XG4gICAgICB0aGlzLm5hbWUgPSBcIklsbGVnYWxUaW1lRXJyb3JcIjtcbiAgICAgIHRoaXMubWVzc2FnZSA9IHR5cGVvZihtZXNzYWdlKSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwiSW52YWxpZCB0aW1lIGVsZW1lbnQgc3BlY2lmaWVkLlwiIDogbWVzc2FnZTtcbiAgICB9O1xuICAgIElsbGVnYWxUaW1lRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gICAgSWxsZWdhbFRpbWVFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbGxlZ2FsVGltZUVycm9yO1xuXG4gICAgLyoqXG4gICAgICogRXJyb3IgaW5kaWNhdGluZyBhIHdlZWtkYXkgaW5kZXggc3BlY2lmaWVkIG91dHNpZGUgb2YgdGhlIGV4cGVjdGVkIHJhbmdlICgwLTYgfiBNb24tU3VuKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbGxlZ2FsV2Vla2RheUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgIHRoaXMubmFtZSA9IFwiSWxsZWdhbFdlZWtkYXlFcnJvclwiO1xuICAgICAgdGhpcy5tZXNzYWdlID0gdHlwZW9mKG1lc3NhZ2UpID09PSBcInVuZGVmaW5lZFwiID8gXCJJbnZhbGlkIHdlZWtkYXkgc3BlY2lmaWVkLlwiIDogbWVzc2FnZTtcbiAgICB9O1xuICAgIElsbGVnYWxXZWVrZGF5RXJyb3IgLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICAgIElsbGVnYWxXZWVrZGF5RXJyb3IgLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IElsbGVnYWxXZWVrZGF5RXJyb3IgO1xuXG4gICAgLy8gZXhwb3J0IG9mIHBhY2thZ2UtbGlrZSBvYmplY3Qgd2l0aCBleHBsaWNpdCBwdWJsaWMgQVBJXG4gICAgdmFyIGNhbGVuZGFyID0gZnVuY3Rpb24oKSB7fTtcblxuICAgIGNhbGVuZGFyLmlzbGVhcCAgICAgPSBpc2xlYXA7XG4gICAgY2FsZW5kYXIubGVhcGRheXMgICA9IGxlYXBkYXlzO1xuICAgIGNhbGVuZGFyLm1vbnRocmFuZ2UgPSBtb250aHJhbmdlO1xuICAgIGNhbGVuZGFyLndlZWtkYXkgICAgPSB3ZWVrZGF5O1xuICAgIGNhbGVuZGFyLnNldGxvY2FsZSAgPSBzZXRsb2NhbGU7XG4gICAgY2FsZW5kYXIudGltZWdtICAgICA9IHRpbWVnbTtcbiAgICBjYWxlbmRhci5DYWxlbmRhciAgID0gQ2FsZW5kYXI7XG5cbiAgICBjYWxlbmRhci5JbGxlZ2FsTG9jYWxlRXJyb3IgID0gSWxsZWdhbExvY2FsZUVycm9yO1xuICAgIGNhbGVuZGFyLklsbGVnYWxEYXlFcnJvciAgICAgPSBJbGxlZ2FsRGF5RXJyb3I7XG4gICAgY2FsZW5kYXIuSWxsZWdhbE1vbnRoRXJyb3IgICA9IElsbGVnYWxNb250aEVycm9yO1xuICAgIGNhbGVuZGFyLklsbGVnYWxUaW1lRXJyb3IgICAgPSBJbGxlZ2FsVGltZUVycm9yO1xuICAgIGNhbGVuZGFyLklsbGVnYWxXZWVrZGF5RXJyb3IgPSBJbGxlZ2FsV2Vla2RheUVycm9yO1xuXG4gICAgY2FsZW5kYXIuTU9OREFZICAgICA9IDA7XG4gICAgY2FsZW5kYXIuVFVFU0RBWSAgICA9IDE7XG4gICAgY2FsZW5kYXIuV0VETkVTREFZICA9IDI7XG4gICAgY2FsZW5kYXIuVEhVUlNEQVkgICA9IDM7XG4gICAgY2FsZW5kYXIuRlJJREFZICAgICA9IDQ7XG4gICAgY2FsZW5kYXIuU0FUVVJEQVkgICA9IDU7XG4gICAgY2FsZW5kYXIuU1VOREFZICAgICA9IDY7XG5cbiAgICBjYWxlbmRhci5KQU5VQVJZICAgID0gIDE7XG4gICAgY2FsZW5kYXIuRkVCUlVBUlkgICA9ICAyO1xuICAgIGNhbGVuZGFyLk1BUkNIICAgICAgPSAgMztcbiAgICBjYWxlbmRhci5BUFJJTCAgICAgID0gIDQ7XG4gICAgY2FsZW5kYXIuTUFZICAgICAgICA9ICA1O1xuICAgIGNhbGVuZGFyLkpVTkUgICAgICAgPSAgNjtcbiAgICBjYWxlbmRhci5KVUxZICAgICAgID0gIDc7XG4gICAgY2FsZW5kYXIuQVVHVVNUICAgICA9ICA4O1xuICAgIGNhbGVuZGFyLlNFUFRFTUJFUiAgPSAgOTtcbiAgICBjYWxlbmRhci5PQ1RPQkVSICAgID0gMTA7XG4gICAgY2FsZW5kYXIuTk9WRU1CRVIgICA9IDExO1xuICAgIGNhbGVuZGFyLkRFQ0VNQkVSICAgPSAxMjtcblxuICAgIGNhbGVuZGFyLnNldGxvY2FsZSgpO1xuXG4gICAgLy8gSW5pdGlhbGl6YXRpb24gbWV0aG9kb2xvZ3kgYW5kIG5vQ29uZmxpY3QgY291cnRlc3kgbm9kZS11dWlkOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkXG5cbiAgICB2YXIgX2dsb2JhbCA9IHRoaXM7XG5cbiAgICAvLyBQdWJsaXNoIGFzIG5vZGUuanMgbW9kdWxlXG4gICAgaWYgKHR5cGVvZihtb2R1bGUpICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGNhbGVuZGFyO1xuICAgIH1cblxuICAgIC8vIFB1Ymxpc2ggYXMgZ2xvYmFsIChpbiBicm93c2VycylcbiAgICBlbHNlIHtcbiAgICAgIHZhciBfcHJldmlvdXNSb290ID0gX2dsb2JhbC5jYWxlbmRhcjtcblxuICAgICAgLyoqXG4gICAgICAgICogUmVzZXQgZ2xvYmFsICdjYWxlbmRhcicgdmFyaWFibGVcbiAgICAgICAgKlxuICAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgICovXG4gICAgICBjYWxlbmRhci5ub2NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIF9nbG9iYWwuY2FsZW5kYXIgPSBfcHJldmlvdXNSb290O1xuICAgICAgICByZXR1cm4gY2FsZW5kYXI7XG4gICAgICB9O1xuXG4gICAgICBfZ2xvYmFsLmNhbGVuZGFyID0gY2FsZW5kYXI7XG4gICAgfVxuXG59KS5jYWxsKHRoaXMpO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIE9iamVjdC5hc3NpZ25cbiAqL1xuXG4vLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LmFzc2lnblxuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZXMpIHtcbiAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiB0YXJnZXQgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gIH1cblxuICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBuZXh0SW5kZXggPSAxOyBuZXh0SW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBuZXh0SW5kZXgrKykge1xuICAgIHZhciBuZXh0U291cmNlID0gYXJndW1lbnRzW25leHRJbmRleF07XG4gICAgaWYgKG5leHRTb3VyY2UgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGZyb20gPSBPYmplY3QobmV4dFNvdXJjZSk7XG5cbiAgICAvLyBXZSBkb24ndCBjdXJyZW50bHkgc3VwcG9ydCBhY2Nlc3NvcnMgbm9yIHByb3hpZXMuIFRoZXJlZm9yZSB0aGlzXG4gICAgLy8gY29weSBjYW5ub3QgdGhyb3cuIElmIHdlIGV2ZXIgc3VwcG9ydGVkIHRoaXMgdGhlbiB3ZSBtdXN0IGhhbmRsZVxuICAgIC8vIGV4Y2VwdGlvbnMgYW5kIHNpZGUtZWZmZWN0cy4gV2UgZG9uJ3Qgc3VwcG9ydCBzeW1ib2xzIHNvIHRoZXkgd29uJ3RcbiAgICAvLyBiZSB0cmFuc2ZlcnJlZC5cblxuICAgIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG4gICAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbjtcbiIsInZhciBBcHBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9EaXNwYXRjaGVyLmpzJyk7XG52YXIgYXBwQ29uc3RhbnRzID0gcmVxdWlyZSgnLi9Db25zdGFudHMuanMnKTtcblxudmFyIHBsYW5uZXJBY3Rpb25zID0ge1xuICBuZXdNb250aDogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICBBcHBEaXNwYXRjaGVyLmhhbmRsZVZpZXdBY3Rpb24oe1xuICAgICAgYWN0aW9uVHlwZTogYXBwQ29uc3RhbnRzLk5FV19NT05USCxcbiAgICAgIGRhdGE6IGRhdGVcbiAgICB9KTtcbiAgfSxcbiAgZmluZE1vbnRoOiBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgQXBwRGlzcGF0Y2hlci5oYW5kbGVWaWV3QWN0aW9uKHtcbiAgICAgIGFjdGlvblR5cGU6IGFwcENvbnN0YW50cy5GSU5EX01PTlRILFxuICAgICAgZGF0YTogZGlyZWN0aW9uXG4gICAgfSk7XG4gIH0sXG4gIHNlbGVjdGVkRGF5OiBmdW5jdGlvbiAoZGF5TnVtKSB7XG4gICAgQXBwRGlzcGF0Y2hlci5oYW5kbGVWaWV3QWN0aW9uKHtcbiAgICAgIGFjdGlvblR5cGU6IGFwcENvbnN0YW50cy5TRUxFQ1RFRF9EQVksXG4gICAgICBkYXRhOiBkYXlOdW1cbiAgICB9KTtcbiAgfSxcbiAgYWRkRXZlbnRzOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgQXBwRGlzcGF0Y2hlci5oYW5kbGVWaWV3QWN0aW9uKHtcbiAgICAgIGFjdGlvblR5cGU6IGFwcENvbnN0YW50cy5BRERfRVZFTlRTLFxuICAgICAgZGF0YTogZXZ0XG4gICAgfSk7XG4gIH0sXG4gIGRlbGV0ZUV2ZW50czogZnVuY3Rpb24gKGV2dCkge1xuICAgIEFwcERpc3BhdGNoZXIuaGFuZGxlVmlld0FjdGlvbih7XG4gICAgICBhY3Rpb25UeXBlOiBhcHBDb25zdGFudHMuREVMRVRFX0VWRU5UUyxcbiAgICAgIGRhdGE6IGV2dFxuICAgIH0pXG4gIH0sXG4gIGFkZFRvRG86IGZ1bmN0aW9uICh0b0RvKSB7XG4gICAgQXBwRGlzcGF0Y2hlci5oYW5kbGVWaWV3QWN0aW9uKHtcbiAgICAgIGFjdGlvblR5cGU6IGFwcENvbnN0YW50cy5BRERfVE9ETyxcbiAgICAgIGRhdGE6IHRvRG9cbiAgICB9KVxuICB9LFxuICBkZWxldGVUb0RvOiBmdW5jdGlvbiAodG9Ebykge1xuICAgIEFwcERpc3BhdGNoZXIuaGFuZGxlVmlld0FjdGlvbih7XG4gICAgICBhY3Rpb25UeXBlOiBhcHBDb25zdGFudHMuREVMRVRFX1RPRE8sXG4gICAgICBkYXRhOiB0b0RvXG4gICAgfSlcbiAgfSxcbiAgdG9Eb1N0YXR1czogZnVuY3Rpb24gKHRvRG8pIHtcbiAgICBBcHBEaXNwYXRjaGVyLmhhbmRsZVZpZXdBY3Rpb24oe1xuICAgICAgYWN0aW9uVHlwZTogYXBwQ29uc3RhbnRzLlRPRE9fU1RBVFVTLFxuICAgICAgZGF0YTogdG9Eb1xuICAgIH0pXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcGxhbm5lckFjdGlvbnM7XG4iLCJ2YXIgYXBwQ29uc3RhbnRzID0ge1xuICBORVdfTU9OVEg6ICdORVdfTU9OVEgnLFxuICBGSU5EX01PTlRIOiAnRklORF9NT05USCcsXG4gIFNFTEVDVEVEX0RBWTogJ1NFTEVDVEVEX0RBWScsXG4gIEFERF9FVkVOVFM6ICdBRERfRVZFTlRTJyxcbiAgREVMRVRFX0VWRU5UUzogJ0RFTEVURV9FVkVOVFMnLFxuICBBRERfVE9ETzogJ0FERF9UT0RPJyxcbiAgREVMRVRFX1RPRE86ICdERUxFVEVfVE9ETycsXG4gIFRPRE9fU1RBVFVTOiAnVE9ET19TVEFUVVMnXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcENvbnN0YW50cztcbiIsInZhciBEaXNwYXRjaGVyID0gcmVxdWlyZSgnZmx1eCcpLkRpc3BhdGNoZXI7XG52YXIgQXBwRGlzcGF0Y2hlciA9IG5ldyBEaXNwYXRjaGVyKCk7XG5cbkFwcERpc3BhdGNoZXIuaGFuZGxlVmlld0FjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbikge1xuICB0aGlzLmRpc3BhdGNoKHtcbiAgICBzb3VyY2U6ICdWSUVXX0FDVElPTicsXG4gICAgYWN0aW9uOiBhY3Rpb25cbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXBwRGlzcGF0Y2hlcjtcbiIsInZhciBtb250aENvbnZlcnNpb24gPSB7XG4gIEphbiA6IFsxLCAnSmFudWFyeSddLFxuICBGZWIgOiBbMiwgJ0ZlYnJ1YXJ5J10sXG4gIE1hciA6IFszLCAnTWFyY2gnXSxcbiAgQXByIDogWzQsICdBcHJpbCddLFxuICBNYXkgOiBbNSwgJ01heSddLFxuICBKdW4gOiBbNiwgJ0p1bmUnXSxcbiAgSnVsIDogWzcsICdKdWx5J10sXG4gIEF1ZyA6IFs4LCAnQXVndXN0J10sXG4gIFNlcCA6IFs5LCAnU2VwdGVtYmVyJ10sXG4gIE9jdCA6IFsxMCwgJ09jdG9iZXInXSxcbiAgTm92IDogWzExLCAnTm92ZW1iZXInXSxcbiAgRGVjIDogWzEyLCAnRGVjZW1iZXInXSxcbiAgMSA6ICdKYW4nLFxuICAyIDogJ0ZlYicsXG4gIDMgOiAnTWFyJyxcbiAgNCA6ICdBcHInLFxuICA1IDogJ01heScsXG4gIDYgOiAnSnVuJyxcbiAgNyA6ICdKdWwnLFxuICA4IDogJ0F1ZycsXG4gIDkgOiAnU2VwJyxcbiAgMTAgOiAnT2N0JyxcbiAgMTEgOiAnTm92JyxcbiAgMTIgOiAnRGVjJyxcbn1cblxudmFyIG1vbnRoQW5pbWF0aW9uID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICBpZihkaXJlY3Rpb24pIHtcbiAgICB2YXIgbW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbW9udGhHcmlkJylbMF0uY2xhc3NMaXN0O1xuICAgIG1vbi5hZGQoJ2FuaW1hdGVkJywgJ2JvdW5jZUluTGVmdCcpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgbW9uLnJlbW92ZSgnYW5pbWF0ZWQnLCAnYm91bmNlSW5MZWZ0JykgfSwgMTAwMCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1vbiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ21vbnRoR3JpZCcpWzBdLmNsYXNzTGlzdDtcbiAgICBtb24uYWRkKCdhbmltYXRlZCcsICdib3VuY2VJblJpZ2h0Jyk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpeyBtb24ucmVtb3ZlKCdhbmltYXRlZCcsICdib3VuY2VJblJpZ2h0JykgfSwgMTAwMCk7XG4gIH1cbn1cblxudmFyIHNvcnRlZEV2ZW50cyA9IGZ1bmN0aW9uIChldnQxLCBldnQyKSB7XG4gIHJldHVybiBwYXJzZUludChldnQxLnRpbWUuc3RhcnQucmVwbGFjZSgnOicsICcnKSkgLSBwYXJzZUludChldnQyLnRpbWUuc3RhcnQucmVwbGFjZSgnOicsICcnKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtb250aENvbnZlcnNpb246IG1vbnRoQ29udmVyc2lvbixcbiAgbW9udGhBbmltYXRpb246IG1vbnRoQW5pbWF0aW9uLFxuICBzb3J0ZWRFdmVudHM6IHNvcnRlZEV2ZW50c1xufVxuIiwidmFyIGhhbmRsZXJzID0ge1xuICBkYXRlVG9nZ2xlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBkYXRlVG9nZ2xlOiB0aGlzLnN0YXRlLmRhdGVUb2dnbGUgPyB0aGlzLnN0YXRlLmRhdGVUb2dnbGUgPSBmYWxzZSA6IHRoaXMuc3RhdGUuZGF0ZVRvZ2dsZSA9IHRydWVcbiAgICB9KVxuICB9LFxuICBldmVudHNUb2dnbGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGV2ZW50c1RvZ2dsZTogdGhpcy5zdGF0ZS5ldmVudHNUb2dnbGUgPyB0aGlzLnN0YXRlLmV2ZW50c1RvZ2dsZSA9IGZhbHNlIDogdGhpcy5zdGF0ZS5ldmVudHNUb2dnbGUgPSB0cnVlXG4gICAgfSlcbiAgfSxcbiAgdG9Eb1RvZ2dsZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdG9Eb1RvZ2dsZTogdGhpcy5zdGF0ZS50b0RvVG9nZ2xlID8gdGhpcy5zdGF0ZS50b0RvVG9nZ2xlID0gZmFsc2UgOiB0aGlzLnN0YXRlLnRvRG9Ub2dnbGUgPSB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG52YXIgdG9nZ2xlU3RhdGUgPSB7XG4gIGRhdGVUb2dnbGU6IHRydWUsXG4gIGV2ZW50c1RvZ2dsZTogZmFsc2UsXG4gIHRvRG9Ub2dnbGU6IGZhbHNlXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBoYW5kbGVyczogaGFuZGxlcnMsXG4gIHRvZ2dsZVN0YXRlOiB0b2dnbGVTdGF0ZVxufVxuIiwidmFyIERheSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW9udGhEYXlcIj5cbiAgICAgICAge1xuICAgICAgICAgdGhpcy5wcm9wcy5jdXJyZW50TW9udGguaXRlbXMuZXZlbnRzW3BhcnNlSW50KHRoaXMucHJvcHMuZGF5KV1cbiAgICAgICAgID8gdGhpcy5wcm9wcy5jdXJyZW50TW9udGguaXRlbXMuZXZlbnRzW3BhcnNlSW50KHRoaXMucHJvcHMuZGF5KV0ubWFwKGZ1bmN0aW9uIChldnQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiA8cCBjbGFzc05hbWU9XCJjYWxlbmRhckV2ZW50XCIga2V5PXtpfT57ZXZ0LnRpdGxlfTwvcD5cbiAgICAgICAgICAgfSlcbiAgICAgICAgIDogbnVsbFxuICAgICAgICB9XG4gICAgICAgIHtcbiAgICAgICAgIHRoaXMucHJvcHMuY3VycmVudE1vbnRoLml0ZW1zLnRvZG9zW3BhcnNlSW50KHRoaXMucHJvcHMuZGF5KV1cbiAgICAgICAgID8gdGhpcy5wcm9wcy5jdXJyZW50TW9udGguaXRlbXMudG9kb3NbcGFyc2VJbnQodGhpcy5wcm9wcy5kYXkpXS5tYXAoZnVuY3Rpb24gKHRvRG8sIGkpIHtcbiAgICAgICAgICAgIHJldHVybiA8cCBjbGFzc05hbWU9e3RvRG8uY29tcGxldGVkID8gXCJjYWxlbmRhclRvRG9DXCIgOiBcImNhbGVuZGFyVG9Eb05DXCJ9IGtleT17aX0+e3RvRG8udGl0bGV9PC9wPiBcbiAgICAgICAgICAgfSlcbiAgICAgICAgIDogbnVsbFxuICAgICAgICB9XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gRGF5O1xuIiwidmFyIEV2ZW50cyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgZ2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRheUV2ZW50cyA9IHRoaXMucHJvcHMuY3VycmVudE1vbnRoLml0ZW1zLmV2ZW50c1t0aGlzLnByb3BzLmN1cnJlbnRNb250aC5zZWxlY3RlZERheV07XG4gICAgcmV0dXJuIGRheUV2ZW50cyB8fCBudWxsO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJkYXlFdmVudHMgYW5pbWF0ZWQgem9vbUluXCI+XG4gICAgICAgIHsgdGhpcy5nZXRFdmVudHMoKSAhPSBudWxsXG4gICAgICAgICAgPyB0aGlzLmdldEV2ZW50cygpLm1hcChmdW5jdGlvbiAoZGF5LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRheUV2ZW50Q29udGFpbmVyXCIga2V5PXtkYXkudGltZS5zdGFydCArIGRheS50aXRsZX0+XG4gICAgICAgICAgICAgICAgPGZvcm0+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJldmVudE1hcmtlciBmYSBmYS1jYWxlbmRhci1jaGVjay1vXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgcGxhY2Vob2xkZXI9XCJUaXRsZVwiIG5hbWU9XCJ0aXRsZVwiIGRlZmF1bHRWYWx1ZT17ZGF5LnRpdGxlfT48L2lucHV0PlxuICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0aW1lXCIgcGxhY2Vob2xkZXI9XCJTdGFydFwiIG5hbWU9XCJzdGFydFwiIGRlZmF1bHRWYWx1ZT17ZGF5LnRpbWUuc3RhcnR9PjwvaW5wdXQ+XG4gICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRpbWVcIiBwbGFjZWhvbGRlcj1cIkVuZFwiIG5hbWU9XCJlbmRcIiBkZWZhdWx0VmFsdWU9e2RheS50aW1lLmVuZH0+PC9pbnB1dD5cbiAgICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSBkZWZhdWx0VmFsdWU9XCJEZXNjcmlwdGlvblwiIG5hbWU9XCJkZXNjcmlwdGlvblwiIGRlZmF1bHRWYWx1ZT17ZGF5LmRlc2NyaXB0aW9ufT48L3RleHRhcmVhPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZGVsZXRlRXZlbnQgZ2x5cGhpY29uIGdseXBoaWNvbi1taW51cy1zaWduXCIgb25DbGljaz17dGhpcy5wcm9wcy5kZWxldGVFdmVudHMuYmluZCh0aGlzLCB7ZGF5OiBkYXkuZGF5LCBldnRJbmRleDogaX0pfT48L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9mb3JtPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9LCB0aGlzKVxuICAgICAgICAgIDpcbiAgICAgICAgICA8cD5ObyBFdmVudHMgVG9kYXk8L3A+XG4gICAgICAgIH1cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudHM7XG4iLCJ2YXIgRGF5ID0gcmVxdWlyZSgnLi9EYXkuanN4Jyk7XG5cbnZhciBNb250aCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiAoXG4gICAgICA8c2VjdGlvbj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYWxlbmRhckhlYWRlclwiPlxuICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiYnRuIGJ0bi1wcmltYXJ5XCIgb25DbGljaz17dGhpcy5wcm9wcy5oYW5kbGVycy5kaXNwbGF5TW9udGh9PkJhY2s8L2J1dHRvbj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vbnRoTmFtZVwiPlxuICAgICAgICAgICAgPGgxPnt0aGlzLnByb3BzLmN1cnJlbnRNb250aC5uYW1lfTwvaDE+XG4gICAgICAgICAgICA8aDQ+e3RoaXMucHJvcHMuY3VycmVudE1vbnRoLnllYXJ9PC9oND5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cImJ0biBidG4tcHJpbWFyeVwiIG9uQ2xpY2s9e3RoaXMucHJvcHMuaGFuZGxlcnMuZGlzcGxheU1vbnRofT5Gb3J3YXJkPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8dGFibGUgY2xhc3NOYW1lPVwibW9udGhHcmlkIHRhYmxlLWJvcmRlcmVkXCI+XG4gICAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICA8dGg+U3VuZGF5PC90aD4gPHRoPk1vbmRheTwvdGg+IDx0aD5UdWVzZGF5PC90aD4gPHRoPldlZG5lc2RheTwvdGg+IDx0aD5UaHVyc2RheTwvdGg+IDx0aD5GcmlkYXk8L3RoPiA8dGg+U2F0dXJkYXk8L3RoPlxuICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICA8L3RoZWFkPlxuICAgICAgICAgIDx0Ym9keT5cbiAgICAgICAgICAgIHt0aGlzLnByb3BzLmN1cnJlbnRNb250aC5tb250aE1hdHJpeC5tYXAoZnVuY3Rpb24od2Vlaykge1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDx0ciBrZXk9e3dlZWt9PlxuICAgICAgICAgICAgICAgICAge3dlZWsubWFwKGZ1bmN0aW9uKGRheSwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5ID09IHBhcnNlSW50KHRoaXMucHJvcHMuY3VycmVudE1vbnRoLnNlbGVjdGVkRGF5KVxuICAgICAgICAgICAgICAgICAgICAgID8gPHRkIGNsYXNzTmFtZT1cInNlbGVjdGVkRGF5XCIga2V5PXtpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzY3JvbGxcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Yj48cD57ZGF5fTwvcD48L2I+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPERheSBkYXk9e2RheX0gY3VycmVudE1vbnRoPXt0aGlzLnByb3BzLmN1cnJlbnRNb250aH0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgIDogPHRkIG9uQ2xpY2s9e3RoaXMucHJvcHMuaGFuZGxlcnMuc2VsZWN0ZWREYXkuYmluZCh0aGlzLCBkYXkpfSBrZXk9e2l9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNjcm9sbFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxiPjxwPntkYXl9PC9wPjwvYj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RGF5IGRheT17ZGF5fSBjdXJyZW50TW9udGg9e3RoaXMucHJvcHMuY3VycmVudE1vbnRofSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICB9LHRoaXMpfVxuICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LHRoaXMpfVxuICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgIDwvdGFibGU+XG4gICAgICA8L3NlY3Rpb24+XG4gICAgKTtcbiAgfVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBNb250aDtcbiIsInZhciBNb250aCA9IHJlcXVpcmUoJy4vbW9udGguanN4Jyk7XG52YXIgU2VsZWN0ZWREYXkgPSByZXF1aXJlKCcuL3NlbGVjdGVkRGF5LmpzeCcpO1xudmFyIFRhc2tNYW5hZ2VyID0gcmVxdWlyZSgnLi90YXNrTWFuYWdlci5qc3gnKTtcbnZhciBwbGFubmVyU3RvcmUgPSByZXF1aXJlKCcuLi9zdG9yZXMvcGxhbm5lclN0b3JlLmpzJyk7XG52YXIgcGxhbm5lckFjdGlvbnMgPSByZXF1aXJlKCcuLi9BY3Rpb24uanMnKTtcbnZhciBtb250aEFuaW1hdGlvbiA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9jYWxlbmRhckNvbnZlcnNpb25zJykubW9udGhBbmltYXRpb247XG5cbnZhciBQbGFubmVyID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLnRvU3RyaW5nKCkuc3BsaXQoJyAnKTtcbiAgICBwbGFubmVyQWN0aW9ucy5uZXdNb250aChbbm93WzFdLCBub3dbM10sIG5vd1syXV0pO1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50TW9udGg6IHBsYW5uZXJTdG9yZS5nZXRDdXJyZW50TW9udGgoKSxcbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgcGxhbm5lclN0b3JlLmFkZENoYW5nZUxpc3RlbmVyKHRoaXMuX29uQ2hhbmdlKTtcbiAgfSxcbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBwbGFubmVyU3RvcmUucmVtb3ZlQ2hhbmdlTGlzdGVuZXIodGhpcy5fb25DaGFuZ2UpO1xuICB9LFxuICBtb250aEhhbmRsZXJzOiB7XG4gICAgc2VsZWN0ZWREYXk6ICBmdW5jdGlvbiAoZGF5KSB7XG4gICAgICBwbGFubmVyQWN0aW9ucy5zZWxlY3RlZERheShkYXkpO1xuICAgIH0sXG4gICAgZGlzcGxheU1vbnRoOiBmdW5jdGlvbiAoZSkge1xuICAgICAgbW9udGhBbmltYXRpb24oZS50YXJnZXQuaW5uZXJIVE1MID09ICdGb3J3YXJkJyA/IHRydWUgOiBmYWxzZSk7XG4gICAgICBlLnRhcmdldC5pbm5lckhUTUwgPT0gJ0ZvcndhcmQnID8gcGxhbm5lckFjdGlvbnMuZmluZE1vbnRoKHRydWUpIDogcGxhbm5lckFjdGlvbnMuZmluZE1vbnRoKGZhbHNlKTtcbiAgICB9XG4gIH0sXG4gIHRhc2tIYW5kbGVyczoge1xuICAgIGFkZEV2ZW50czogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHBsYW5uZXJBY3Rpb25zLmFkZEV2ZW50cyhlKTtcbiAgICB9LFxuICAgIGRlbGV0ZUV2ZW50czogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHBsYW5uZXJBY3Rpb25zLmRlbGV0ZUV2ZW50cyhlKTtcbiAgICB9LFxuICAgIGFkZFRvRG86IGZ1bmN0aW9uIChlKSB7XG4gICAgICBwbGFubmVyQWN0aW9ucy5hZGRUb0RvKGUpO1xuICAgIH0sXG4gICAgZGVsZXRlVG9EbzogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHBsYW5uZXJBY3Rpb25zLmRlbGV0ZVRvRG8oZSlcbiAgICB9LFxuICAgIHRvRG9TdGF0dXM6IGZ1bmN0aW9uIChlKSB7XG4gICAgICBwbGFubmVyQWN0aW9ucy50b0RvU3RhdHVzKGUpO1xuICAgIH1cbiAgfSxcbiAgX29uQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjdXJyZW50TW9udGg6IHBsYW5uZXJTdG9yZS5nZXRDdXJyZW50TW9udGgoKVxuICAgIH0pXG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYW5pbWF0ZWQgem9vbUluIGNvbnRhaW5lci1mbHVpZFwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvdyB0ZXh0LWNlbnRlclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLW1kLThcIj5cbiAgICAgICAgICAgIDxNb250aCBjdXJyZW50TW9udGg9e3RoaXMuc3RhdGUuY3VycmVudE1vbnRofSBoYW5kbGVycz17dGhpcy5tb250aEhhbmRsZXJzfSAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLW1kLTRcIj5cbiAgICAgICAgICAgIDxUYXNrTWFuYWdlciBjdXJyZW50TW9udGg9e3RoaXMuc3RhdGUuY3VycmVudE1vbnRofSBoYW5kbGVycz17dGhpcy50YXNrSGFuZGxlcnN9IC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG59KTtcblxuXG5SZWFjdC5yZW5kZXIoPFBsYW5uZXIgLz4sIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhcHAnKSk7XG4iLCJ2YXIgU2VsZWN0ZWREYXkgPSBSZWFjdC5jcmVhdGVDbGFzcyAoe1xuICBoYW5kbGVFdmVudFN1Ym1pdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmb3JtID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoJ25ld0V2ZW50Jyk7XG4gICAgdGhpcy5wcm9wcy5hZGRFdmVudHMoe1xuICAgICAgZGF5OiB0aGlzLnByb3BzLmN1cnJlbnRNb250aC5zZWxlY3RlZERheSwgdGltZToge3N0YXJ0OiBmb3JtWzFdLnZhbHVlLCBlbmQ6IGZvcm1bMl0udmFsdWV9LCB0aXRsZTogZm9ybVswXS52YWx1ZSwgZGVzY3JpcHRpb246IGZvcm1bM10udmFsdWVcbiAgICB9KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcm0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvcm1baV0udmFsdWUgPSBudWxsO1xuICAgIH1cbiAgICBmb3JtW2Zvcm0ubGVuZ3RoIC0xXS52YWx1ZSA9ICdEZXNjcmlwdGlvbic7XG4gIH0sXG4gIGhhbmRsZVRvRG9TdWJtaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm9ybSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCduZXdUb0RvJyk7XG4gICAgdGhpcy5wcm9wcy5hZGRUb0RvKHtcbiAgICAgIGRheTogdGhpcy5wcm9wcy5jdXJyZW50TW9udGguc2VsZWN0ZWREYXksIHRpdGxlOiBmb3JtWzBdLnZhbHVlLCBwcmlvcml0eTogZm9ybVsxXS52YWx1ZSwgZGVzY3JpcHRpb246IGZvcm1bMl0udmFsdWUsIGNvbXBsZXRlZDogZmFsc2VcbiAgICB9KTtcbiAgICBjb25zb2xlLmxvZyhmb3JtWzBdLnZhbHVlLCBmb3JtWzFdLnZhbHVlLCBmb3JtWzJdLnZhbHVlKTtcbiAgICBmb3JtWzBdLnZhbHVlID0gbnVsbDtcbiAgICBmb3JtWzFdLnZhbHVlID0gMztcbiAgICBmb3JtWzJdLnZhbHVlID0gJ0Rlc2NyaXB0aW9uJztcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYW5pbWF0ZWQgem9vbUluIHNlbGVjdGVkRGF5Q29udGFpbmVyXCI+XG4gICAgICAgIHsvKiBOZXcgRXZlbnQgKi99XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2F0ZWdvcnlPbmVcIj5cbiAgICAgICAgICA8aDQ+QWRkIEV2ZW50PC9oND5cbiAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBwbGFjZWhvbGRlcj1cIlRpdGxlXCIgbmFtZT1cIm5ld0V2ZW50XCI+PC9pbnB1dD5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRpbWVcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLWhvdXJnbGFzcy1zdGFydFwiPiA8L3NwYW4+XG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRpbWVcIiBwbGFjZWhvbGRlcj1cIlN0YXJ0XCIgbmFtZT1cIm5ld0V2ZW50XCI+PC9pbnB1dD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRpbWVcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLWhvdXJnbGFzcy1lbmRcIj4gPC9zcGFuPlxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0aW1lXCIgcGxhY2Vob2xkZXI9XCJFbmRcIiBuYW1lPVwibmV3RXZlbnRcIj48L2lucHV0PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDx0ZXh0YXJlYSBkZWZhdWx0VmFsdWU9XCJEZXNjcmlwdGlvblwiIG5hbWU9XCJuZXdFdmVudFwiPjwvdGV4dGFyZWE+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYnRuU3BhbiBnbHlwaGljb24gZ2x5cGhpY29uLXBsdXMtc2lnblwiIG9uQ2xpY2s9e3RoaXMuaGFuZGxlRXZlbnRTdWJtaXR9Pjwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIHsvKiBOZXcgVG9EbyAqL31cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8aDQgY2xhc3NOYW1lPVwidG9Eb0hlYWRlclwiPkFkZCBUb0RvPC9oND5cbiAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBwbGFjZWhvbGRlcj1cIlRpdGxlXCIgbmFtZT1cIm5ld1RvRG9cIj48L2lucHV0PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidG9Eb1ByaW9yaXR5XCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJwcmlvcml0eVNwYW5cIj5Qcmlvcml0eTwvc3Bhbj5cbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFuZ2VcIiBtaW49XCIxXCIgbWF4PVwiNVwiIGxpc3Q9XCJpbnRlcmVzdFwiIGRlZmF1bHRWYWx1ZT17M30gbmFtZT1cIm5ld1RvRG9cIj48L2lucHV0PlxuICAgICAgICAgICAgICA8ZGF0YWxpc3QgaWQ9XCJpbnRlcmVzdFwiPlxuICAgICAgICAgICAgICAgIDxvcHRpb24+MTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24+Mjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24+Mzwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24+NDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24+NTwvb3B0aW9uPlxuICAgICAgICAgICAgICA8L2RhdGFsaXN0PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDx0ZXh0YXJlYSBkZWZhdWx0VmFsdWU9XCJEZXNjcmlwdGlvblwiIG5hbWU9XCJuZXdUb0RvXCI+PC90ZXh0YXJlYT5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJidG5TcGFuIGdseXBoaWNvbiBnbHlwaGljb24tcGx1cy1zaWduXCIgb25DbGljaz17dGhpcy5oYW5kbGVUb0RvU3VibWl0fT48L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdGVkRGF5XG4iLCJ2YXIgU2VsZWN0ZWREYXkgPSByZXF1aXJlKCcuL3NlbGVjdGVkRGF5LmpzeCcpO1xudmFyIEV2ZW50cyA9IHJlcXVpcmUoJy4vZXZlbnRzLmpzeCcpO1xudmFyIFRvRG8gPSByZXF1aXJlKCcuL3RvRG8uanN4Jyk7XG52YXIgdGFza0hlbHBlcnMgPSByZXF1aXJlKCcuLi9hc3NldHMvdGFza0hlbHBlcnMuanMnKTtcblxudmFyIFRhc2tNYW5hZ2VyID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0YXNrSGVscGVycy50b2dnbGVTdGF0ZVxuICB9LFxuICB0b2dnbGVIYW5kbGVyczogdGFza0hlbHBlcnMuaGFuZGxlcnMsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cInRhc2tNYW5hZ2VyXCI+XG4gICAgICAgIDxoMSBjbGFzc05hbWU9XCJ0YXNrSGVhZGVyXCI+VGFzayBNYW5hZ2VyPC9oMT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0YXNrQ29udGFpbmVyXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0YXNrU2VjdGlvblwiPlxuICAgICAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLnRvZ2dsZUhhbmRsZXJzLmRhdGVUb2dnbGUuYmluZCh0aGlzKX0+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17XCJ0YXNrSWNvbiBnbHlwaGljb24gZ2x5cGhpY29uLXRyaWFuZ2xlLVwiICsgKHRoaXMuc3RhdGUuZGF0ZVRvZ2dsZSA/IFwiYm90dG9tXCIgOiBcInJpZ2h0XCIpfT48L3NwYW4+XG4gICAgICAgICAgICAgIDxoMz57dGhpcy5wcm9wcy5jdXJyZW50TW9udGgubmFtZSArXCIgXCIrIHRoaXMucHJvcHMuY3VycmVudE1vbnRoLnNlbGVjdGVkRGF5ICtcIiwgXCIrIHRoaXMucHJvcHMuY3VycmVudE1vbnRoLnllYXJ9PC9oMz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAge3RoaXMuc3RhdGUuZGF0ZVRvZ2dsZSA/IDxTZWxlY3RlZERheSBjdXJyZW50TW9udGg9e3RoaXMucHJvcHMuY3VycmVudE1vbnRofSBhZGRFdmVudHM9e3RoaXMucHJvcHMuaGFuZGxlcnMuYWRkRXZlbnRzfSBhZGRUb0RvPXt0aGlzLnByb3BzLmhhbmRsZXJzLmFkZFRvRG99IC8+IDogbnVsbH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRhc2tTZWN0aW9uXCI+XG4gICAgICAgICAgICA8ZGl2IG9uQ2xpY2s9e3RoaXMudG9nZ2xlSGFuZGxlcnMuZXZlbnRzVG9nZ2xlLmJpbmQodGhpcyl9PlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e1widGFza0ljb24gZ2x5cGhpY29uIGdseXBoaWNvbi10cmlhbmdsZS1cIiArICh0aGlzLnN0YXRlLmV2ZW50c1RvZ2dsZSA/IFwiYm90dG9tXCIgOiBcInJpZ2h0XCIpfT48L3NwYW4+XG4gICAgICAgICAgICAgIDxoMz5FdmVudHM8L2gzPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7dGhpcy5zdGF0ZS5ldmVudHNUb2dnbGUgPyA8RXZlbnRzIGN1cnJlbnRNb250aD17dGhpcy5wcm9wcy5jdXJyZW50TW9udGh9IGRlbGV0ZUV2ZW50cz17dGhpcy5wcm9wcy5oYW5kbGVycy5kZWxldGVFdmVudHN9IC8+IDogbnVsbH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRhc2tTZWN0aW9uXCI+XG4gICAgICAgICAgICA8ZGl2IG9uQ2xpY2s9e3RoaXMudG9nZ2xlSGFuZGxlcnMudG9Eb1RvZ2dsZS5iaW5kKHRoaXMpfT5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtcInRhc2tJY29uIGdseXBoaWNvbiBnbHlwaGljb24tdHJpYW5nbGUtXCIgKyAodGhpcy5zdGF0ZS50b0RvVG9nZ2xlID8gXCJib3R0b21cIiA6IFwicmlnaHRcIil9Pjwvc3Bhbj5cbiAgICAgICAgICAgICAgPGgzPlRvRG8nczwvaDM+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIHt0aGlzLnN0YXRlLnRvRG9Ub2dnbGUgPyA8VG9EbyBjdXJyZW50TW9udGg9e3RoaXMucHJvcHMuY3VycmVudE1vbnRofSB0b0RvU3RhdHVzPXt0aGlzLnByb3BzLmhhbmRsZXJzLnRvRG9TdGF0dXN9IGRlbGV0ZVRvRG89e3RoaXMucHJvcHMuaGFuZGxlcnMuZGVsZXRlVG9Eb30gLz4gOiBudWxsfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvc2VjdGlvbj5cbiAgICApXG4gIH1cbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gVGFza01hbmFnZXI7XG4iLCJ2YXIgVG9EbyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgZ2V0VG9Eb3M6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF5VG9Eb3MgPSB0aGlzLnByb3BzLmN1cnJlbnRNb250aC5pdGVtcy50b2Rvc1t0aGlzLnByb3BzLmN1cnJlbnRNb250aC5zZWxlY3RlZERheV07XG4gICAgcmV0dXJuIGRheVRvRG9zIHx8IG51bGw7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImRheVRvRG9zIGFuaW1hdGVkIHpvb21JblwiPlxuICAgICAgICB7IHRoaXMuZ2V0VG9Eb3MoKSAhPSBudWxsXG4gICAgICAgICAgPyB0aGlzLmdldFRvRG9zKCkubWFwKGZ1bmN0aW9uICh0b0RvLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRheVRvRG9Db250YWluZXJcIiBrZXk9e3RvRG8udGl0bGUgKyB0b0RvLnByaW9yaXR5fT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0b0RvTWFya2VyIGZhIGZhLXRodW1iLXRhY2tcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgcGxhY2Vob2xkZXI9XCJUaXRsZVwiIG5hbWU9XCJuZXdUb0RvXCIgZGVmYXVsdFZhbHVlPXt0b0RvLnRpdGxlfT48L2lucHV0PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidG9Eb1ByaW9yaXR5XCI+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJwcmlvcml0eVNwYW5cIj5Qcmlvcml0eTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFuZ2VcIiBtaW49XCIxXCIgbWF4PVwiNVwiIGxpc3Q9XCJpbnRlcmVzdFwiIGRlZmF1bHRWYWx1ZT17dG9Eby5wcmlvcml0eX0gbmFtZT1cIm5ld1RvRG9cIj48L2lucHV0PlxuICAgICAgICAgICAgICAgICAgICA8ZGF0YWxpc3QgaWQ9XCJpbnRlcmVzdFwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24+MTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24+Mjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24+Mzwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24+NDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24+NTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8L2RhdGFsaXN0PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSBkZWZhdWx0VmFsdWU9XCJEZXNjcmlwdGlvblwiIG5hbWU9XCJuZXdUb0RvXCIgZGVmYXVsdFZhbHVlPXt0b0RvLmRlc2NyaXB0aW9ufT48L3RleHRhcmVhPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17dG9Eby5jb21wbGV0ZWQgPyBcImNvbXBsZXRlZFRvRG8gZmEgZmEtY2hlY2stc3F1YXJlLW9cIiA6IFwibm90Q29tcGxldGVkVG9EbyBmYSBmYS1zcXVhcmUtb1wifSBvbkNsaWNrPXt0aGlzLnByb3BzLnRvRG9TdGF0dXMuYmluZCh0aGlzLCB7ZGF5OiB0b0RvLmRheSwgaW5kZXg6IGl9KX0+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImRlbGV0ZVRvRG8gZ2x5cGhpY29uIGdseXBoaWNvbi1taW51cy1zaWduXCIgb25DbGljaz17dGhpcy5wcm9wcy5kZWxldGVUb0RvLmJpbmQodGhpcywge3RvRG86IHRvRG8sIGluZGV4OiBpfSl9Pjwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApXG4gICAgICAgICAgfSwgdGhpcylcbiAgICAgICAgICA6XG4gICAgICAgICAgPHA+Tm8gVG9EbydzIFRvZGF5PC9wPlxuICAgICAgICB9XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gVG9EbztcbiIsInZhciBBcHBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vRGlzcGF0Y2hlci5qcycpO1xudmFyIGFwcENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL0NvbnN0YW50cy5qcycpO1xudmFyIG9iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9PYmplY3QuYXNzaWduJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGNhbGVuZGFyID0gcmVxdWlyZSgnbm9kZS1jYWxlbmRhcicpO1xudmFyIGFzc2V0cyA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9jYWxlbmRhckNvbnZlcnNpb25zJyk7XG5cbnZhciBDSEFOR0VfRVZFTlQgPSAnY2hhbmdlJztcblxudmFyIHllYXJzID0ge307XG52YXIgY3VycmVudCA9IHt9O1xuXG5mdW5jdGlvbiBNb250aChkYXRlKSB7XG4gIHRoaXMubmFtZSA9IGFzc2V0cy5tb250aENvbnZlcnNpb25bZGF0ZVswXV1bMV07XG4gIHRoaXMubW9udGhLZXkgPSBhc3NldHMubW9udGhDb252ZXJzaW9uW2RhdGVbMF1dWzBdO1xuICB0aGlzLnllYXIgPSBwYXJzZUludChkYXRlWzFdKTtcbiAgdGhpcy5tb250aE1hdHJpeCA9IGRhdGU7XG4gIHRoaXMuc2VsZWN0ZWREYXkgPSBkYXRlWzJdIHx8IDE7XG4gIHRoaXMuaXRlbXMgPSB7XG4gICAgZXZlbnRzOiB7fSxcbiAgICB0b2Rvczoge31cbiAgfTtcbn1cblxuTW9udGgucHJvdG90eXBlLm5ld01vbnRoID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm1vbnRoTWF0cml4ID0gbmV3IGNhbGVuZGFyLkNhbGVuZGFyKGNhbGVuZGFyLlNVTkRBWSkubW9udGhkYXlzY2FsZW5kYXIodGhpcy5tb250aE1hdHJpeFsxXSwgYXNzZXRzLm1vbnRoQ29udmVyc2lvblt0aGlzLm1vbnRoTWF0cml4WzBdXVswXSk7XG59O1xuXG52YXIgbmV3TW9udGggPSBmdW5jdGlvbiAoZGF0ZSkge1xuICBjdXJyZW50ID0gbmV3IE1vbnRoKGRhdGUpO1xuICBjdXJyZW50Lm5ld01vbnRoKCk7XG4gIHllYXJzW2N1cnJlbnQueWVhcl0gPyB5ZWFyc1tjdXJyZW50LnllYXJdLnB1c2goY3VycmVudCkgOiB5ZWFyc1tjdXJyZW50LnllYXJdID0gW2N1cnJlbnRdO1xufVxuXG52YXIgZmluZE1vbnRoID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICBpZihkaXJlY3Rpb24pXG4gICAgY3VycmVudC5tb250aEtleSArMSA8IDEzID8gbmV3Q3VycmVudCA9IFtjdXJyZW50Lm1vbnRoS2V5ICsxLCBjdXJyZW50LnllYXJdIDogbmV3Q3VycmVudCA9IFsxLCBjdXJyZW50LnllYXIgKzFdO1xuICBlbHNlXG4gICAgY3VycmVudC5tb250aEtleSAtMSA+IDAgPyBuZXdDdXJyZW50ID0gW2N1cnJlbnQubW9udGhLZXkgLTEsIGN1cnJlbnQueWVhcl0gOiBuZXdDdXJyZW50ID0gWzEyLCBjdXJyZW50LnllYXIgLTFdO1xuICBpZih5ZWFyc1tuZXdDdXJyZW50WzFdXSl7XG4gICAgdmFyIGNoZWNrZXIgPSB5ZWFyc1tuZXdDdXJyZW50WzFdXS5maWx0ZXIoZnVuY3Rpb24gKG1vbikge1xuICAgICAgaWYobW9uLm1vbnRoS2V5ID09PSBuZXdDdXJyZW50WzBdKVxuICAgICAgICByZXR1cm4gbW9uO1xuICAgIH0pXG4gICAgY2hlY2tlci5sZW5ndGggPiAwID8gY3VycmVudCA9IGNoZWNrZXJbMF0gOiBuZXdNb250aChbYXNzZXRzLm1vbnRoQ29udmVyc2lvbltuZXdDdXJyZW50WzBdXSwgbmV3Q3VycmVudFsxXV0pO1xuICB9IGVsc2Uge1xuICAgIG5ld01vbnRoKFthc3NldHMubW9udGhDb252ZXJzaW9uW25ld0N1cnJlbnRbMF1dLCBuZXdDdXJyZW50WzFdXSk7XG4gIH1cbn1cblxudmFyIHNlbGVjdGVkRGF5ID0gZnVuY3Rpb24gKGRheU51bSkge1xuICBjdXJyZW50LnNlbGVjdGVkRGF5ID0gZGF5TnVtO1xufVxuXG52YXIgYWRkRXZlbnRzID0gZnVuY3Rpb24gKGV2dCkge1xuICBjdXJyZW50Lml0ZW1zLmV2ZW50c1tldnQuZGF5XSA/IGN1cnJlbnQuaXRlbXMuZXZlbnRzW2V2dC5kYXldLnB1c2goZXZ0KSA6IGN1cnJlbnQuaXRlbXMuZXZlbnRzW2V2dC5kYXldID0gW2V2dF07XG4gIGN1cnJlbnQuaXRlbXMuZXZlbnRzW2V2dC5kYXldLnNvcnQoYXNzZXRzLnNvcnRlZEV2ZW50cyk7XG59XG5cbnZhciBkZWxldGVFdmVudHMgPSBmdW5jdGlvbiAoZGF5LCBldnRJbmRleCkge1xuICBjdXJyZW50Lml0ZW1zLmV2ZW50c1tkYXldLnNwbGljZShldnRJbmRleCwgMSk7XG59XG5cbnZhciBhZGRUb0RvID0gZnVuY3Rpb24gKHRvRG8pIHtcbiAgY3VycmVudC5pdGVtcy50b2Rvc1t0b0RvLmRheV0gPyBjdXJyZW50Lml0ZW1zLnRvZG9zW3RvRG8uZGF5XS5wdXNoKHRvRG8pIDogY3VycmVudC5pdGVtcy50b2Rvc1t0b0RvLmRheV0gPSBbdG9Eb107XG59XG5cbnZhciBkZWxldGVUb0RvID0gZnVuY3Rpb24gKHRvRG8sIGluZGV4KSB7XG4gIGN1cnJlbnQuaXRlbXMudG9kb3NbdG9Eby5kYXldLnNwbGljZShpbmRleCwgMSk7XG59XG5cbnZhciB0b0RvU3RhdHVzID0gZnVuY3Rpb24gKHRvRG8pIHtcbiAgY3VycmVudC5pdGVtcy50b2Rvc1t0b0RvLmRheV1bdG9Eby5pbmRleF0uY29tcGxldGVkID8gY3VycmVudC5pdGVtcy50b2Rvc1t0b0RvLmRheV1bdG9Eby5pbmRleF0uY29tcGxldGVkID0gZmFsc2UgOiBjdXJyZW50Lml0ZW1zLnRvZG9zW3RvRG8uZGF5XVt0b0RvLmluZGV4XS5jb21wbGV0ZWQgPSB0cnVlO1xufVxuXG52YXIgcGxhbm5lclN0b3JlID0gb2JqZWN0QXNzaWduKHt9LCBFdmVudEVtaXR0ZXIucHJvdG90eXBlLCB7XG4gIGFkZENoYW5nZUxpc3RlbmVyOiBmdW5jdGlvbiAoY2IpIHtcbiAgICB0aGlzLm9uKENIQU5HRV9FVkVOVCwgY2IpO1xuICB9LFxuICByZW1vdmVDaGFuZ2VMaXN0ZW5lcjogZnVuY3Rpb24gKGNiKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihDSEFOR0VfRVZFTlQsIGNiKTtcbiAgfSxcbiAgZ2V0Q3VycmVudE1vbnRoOiBmdW5jdGlvbiAoKSB7XG4gICAgY29uc29sZS5sb2coeWVhcnMsIGN1cnJlbnQpO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG59KTtcblxuQXBwRGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbiAocGF5bG9hZCkge1xuICB2YXIgYWN0aW9uID0gcGF5bG9hZC5hY3Rpb247XG4gIHN3aXRjaChhY3Rpb24uYWN0aW9uVHlwZSl7XG4gICAgY2FzZSBhcHBDb25zdGFudHMuTkVXX01PTlRIOlxuICAgICAgbmV3TW9udGgoYWN0aW9uLmRhdGEpO1xuICAgICAgcGxhbm5lclN0b3JlLmVtaXQoQ0hBTkdFX0VWRU5UKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXBwQ29uc3RhbnRzLkZJTkRfTU9OVEg6XG4gICAgICBmaW5kTW9udGgoYWN0aW9uLmRhdGEpO1xuICAgICAgcGxhbm5lclN0b3JlLmVtaXQoQ0hBTkdFX0VWRU5UKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXBwQ29uc3RhbnRzLlNFTEVDVEVEX0RBWTpcbiAgICAgIHNlbGVjdGVkRGF5KGFjdGlvbi5kYXRhKTtcbiAgICAgIHBsYW5uZXJTdG9yZS5lbWl0KENIQU5HRV9FVkVOVCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFwcENvbnN0YW50cy5BRERfRVZFTlRTOlxuICAgICAgYWRkRXZlbnRzKGFjdGlvbi5kYXRhKTtcbiAgICAgIHBsYW5uZXJTdG9yZS5lbWl0KENIQU5HRV9FVkVOVCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFwcENvbnN0YW50cy5ERUxFVEVfRVZFTlRTOlxuICAgICAgZGVsZXRlRXZlbnRzKGFjdGlvbi5kYXRhLmRheSwgYWN0aW9uLmRhdGEuZXZ0SW5kZXgpO1xuICAgICAgcGxhbm5lclN0b3JlLmVtaXQoQ0hBTkdFX0VWRU5UKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXBwQ29uc3RhbnRzLkFERF9UT0RPOlxuICAgICAgYWRkVG9EbyhhY3Rpb24uZGF0YSk7XG4gICAgICBwbGFubmVyU3RvcmUuZW1pdChDSEFOR0VfRVZFTlQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhcHBDb25zdGFudHMuVE9ET19TVEFUVVM6XG4gICAgICB0b0RvU3RhdHVzKGFjdGlvbi5kYXRhKTtcbiAgICAgIHBsYW5uZXJTdG9yZS5lbWl0KENIQU5HRV9FVkVOVCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFwcENvbnN0YW50cy5ERUxFVEVfVE9ETzpcbiAgICAgIGRlbGV0ZVRvRG8oYWN0aW9uLmRhdGEudG9EbywgYWN0aW9uLmRhdGEuaW5kZXgpO1xuICAgICAgcGxhbm5lclN0b3JlLmVtaXQoQ0hBTkdFX0VWRU5UKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGxhbm5lclN0b3JlO1xuIl19

(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/lib/_empty.js":[function(require,module,exports){

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/path-browserify/index.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/CldrPluralRule.js":[function(require,module,exports){
(function (__dirname){
var fs = require('fs'),
    Path = require('path'),
    PEG = require('pegjs'),
    parser = PEG.buildParser(fs.readFileSync(Path.resolve(__dirname, 'cldrPluralRule.pegjs'), 'utf-8'));

function rangeListToJavaScriptAst(rangeListNode, lhsJavaScriptAst, withinSemantics) {
    var javaScriptAst,
        seenRange = false;
    for (var i = rangeListNode.ranges.length - 1 ; i >= 0 ; i -= 1) {
        var range = rangeListNode.ranges[i],
            itemJavaScriptAst;
        if (range.type === 'number') {
            itemJavaScriptAst = ['binary', '===', lhsJavaScriptAst, ['num', range.value]];
        } else {
            // range.type === 'range'
            seenRange = true;
            itemJavaScriptAst = ['binary', '&&', ['binary', '>=', lhsJavaScriptAst, ['num', range.min.value]],
                                                 ['binary', '<=', lhsJavaScriptAst, ['num', range.max.value]]];
        }
        if (javaScriptAst) {
            javaScriptAst = ['binary', '||', itemJavaScriptAst, javaScriptAst];
        } else {
            javaScriptAst = itemJavaScriptAst;
        }
    }
    if (seenRange && !withinSemantics) {
        javaScriptAst = ['binary', '&&', ['binary', '===', lhsJavaScriptAst,
                                                           ['call', ['dot', ['name', 'Math'], 'floor'], [lhsJavaScriptAst]]],
                                         javaScriptAst];
    }
    return javaScriptAst;
}

function nodeToJavaScriptAst(node) {
    switch (node.type) {
    case 'number':
        return ['num', node.value];
    case 'n':
    case 'i':
    case 'v':
    case 'w':
    case 'f':
    case 't':
        return ['name', node.type];
    case 'is':
        return ['binary', '==='].concat(node.operands.map(nodeToJavaScriptAst));
    case 'isnot':
        return ['binary', '!=='].concat(node.operands.map(nodeToJavaScriptAst));
    case 'mod':
        return ['binary', '%'].concat(node.operands.map(nodeToJavaScriptAst));
    case 'and':
        return ['binary', '&&'].concat(node.operands.map(nodeToJavaScriptAst));
    case 'or':
        return ['binary', '||'].concat(node.operands.map(nodeToJavaScriptAst));
    case 'not':
        return ['unary-prefix', '!', nodeToJavaScriptAst(node.operands)];
    case 'isnot':
        return ['binary', '!=='].concat(node.operands.map(nodeToJavaScriptAst));
    case 'within':
        return rangeListToJavaScriptAst(node.operands[1], nodeToJavaScriptAst(node.operands[0]), true);
    case 'notwithin':
        return ['unary-prefix', '!', rangeListToJavaScriptAst(node.operands[1], nodeToJavaScriptAst(node.operands[0]), true)];
    case 'in':
        return rangeListToJavaScriptAst(node.operands[1], nodeToJavaScriptAst(node.operands[0]), false);
    case 'notin':
        return ['unary-prefix', '!', rangeListToJavaScriptAst(node.operands[1], nodeToJavaScriptAst(node.operands[0]), false)];
    default:
        throw new Error('nodeToJavaScriptAst: Unknown node type: ' + node.type);
    }
}

function traverse(node, lambda) {
    lambda(node);
    if (node.operands) {
        node.operands.forEach(function (operand) {
            traverse(operand, lambda);
        });
    }
}

function CldrPluralRule(src) {
    this.topLevelNode = parser.parse(src.replace(/^\s+|\s+$/g, '').replace(/\s{2,}/g, ' '));
}

CldrPluralRule.prototype = {
    toJavaScriptAst: function () {
        return nodeToJavaScriptAst(this.topLevelNode);
    },

    eachNode: function (lambda) {
        traverse(this.topLevelNode, lambda);
    },

    updateIsUsedByTerm: function (isUsedByTerm) {
        this.eachNode(function (node) {
            if (['i', 'v', 'w', 'f', 't', 'n'].indexOf(node.type) !== -1) {
                isUsedByTerm[node.type] = true;
            }
        });
        return isUsedByTerm;
    }
};

module.exports = CldrPluralRule;

}).call(this,"/node_modules/cldr/lib")

},{"fs":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/lib/_empty.js","path":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/path-browserify/index.js","pegjs":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/pegjs/lib/peg.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/CldrPluralRuleSet.js":[function(require,module,exports){
var CldrPluralRule = require('./CldrPluralRule'),
    cldrPluralRuleTermFunctionByName = require('./cldrPluralRuleTermFunctionByName'),
    uglifyJs = require('uglify-js');

function CldrPluralRuleSet() {
    this.cldrPluralRuleByCount = {};
}

CldrPluralRuleSet.prototype = {
    addRule: function (cldrPluralRule, count) {
        if (typeof cldrPluralRule === 'string') {
            cldrPluralRule = cldrPluralRule.replace(/\s*@(?:decimal|integer).*$/, '');
            // Some count="other" nodes in CLDR 24+ consist purely of sample text.
            // Don't add those.
            if (cldrPluralRule.length === 0) {
                return;
            }
            cldrPluralRule = new CldrPluralRule(cldrPluralRule);
        }
        this.cldrPluralRuleByCount[count] = cldrPluralRule;
    },

    toJavaScriptFunctionBodyAst: function () {
        var statementAsts = [],
            isUsedByTerm = {};
        Object.keys(this.cldrPluralRuleByCount).forEach(function (count) {
            var cldrPluralRule = this.cldrPluralRuleByCount[count];
            cldrPluralRule.updateIsUsedByTerm(isUsedByTerm);
            statementAsts.push(
                [
                    'if',
                    cldrPluralRule.toJavaScriptAst(),
                    ['return', ['string', count]]
                ]
            );
        }, this);
        statementAsts.push(['return', ['string', 'other']]);
        var varAsts = [];

        ['i', 'v', 'w', 'f', 't'].forEach(function (term) {
            if (isUsedByTerm[term]) {
                varAsts.push([term, uglifyJs.parser.parse(cldrPluralRuleTermFunctionByName[term].toString())[1][0][3][0][1]]);
            }
        });

        if (Object.keys(isUsedByTerm).length !== 0) {
            statementAsts.unshift(
                // if (typeof n === 'string') n = parseInt(n, 10);
                [ 'if',
                      [ 'binary',
                        '===',
                        [ 'unary-prefix', 'typeof', [ 'name', 'n' ] ],
                        [ 'string', 'string' ] ],
                      [ 'stat',
                        [ 'assign',
                          true,
                          [ 'name', 'n' ],
                          [ 'call',
                            [ 'name', 'parseInt' ],
                            [ [ 'name', 'n' ], [ 'num', 10 ] ] ] ] ],
                      undefined ]
            );
        }

        if (varAsts.length > 0) {
            statementAsts.unshift(['var', varAsts]);
        }
        return statementAsts;
    }
};

module.exports = CldrPluralRuleSet;

},{"./CldrPluralRule":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/CldrPluralRule.js","./cldrPluralRuleTermFunctionByName":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/cldrPluralRuleTermFunctionByName.js","uglify-js":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/uglify-js.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/CldrRbnfRuleSet.js":[function(require,module,exports){
var _ = require('underscore');

function CldrRbnfRuleSet(config) {
    _.extend(this, config);
    this.ruleByValue = {};
}

CldrRbnfRuleSet.getSafeRendererName = function (rendererName) {
    return (
        ("render-" + rendererName)
        .replace(/[^\w-]/g, '-')
        .replace(/[-_]+([0-9a-z])/gi, function ($0, ch) {
            return ch.toUpperCase();
        })
        .replace('GREEKNUMERALMAJUSCULES', 'GreekNumeralMajuscules')
    );
};

CldrRbnfRuleSet.prototype = {
    toFunctionAst: function () {
        var that = this,
            isSeenByRuleSetType = {};

        function ruleToExpressionAst(rule) {
            var expressionAsts = [],
                rbnf = rule.rbnf;

            // "If a rule body begins with an apostrophe, the apostrophe is ignored, but all text after it becomes
            // significant (this is how you can have a rule's rule text begin with whitespace)."
            // -- http://www.icu-project.org/apiref/icu4c/classRuleBasedNumberFormat.html
            rbnf = rbnf.replace(/^'/, '');

            var radix = rule.radix || 10;

            function getDivisor() {
                var divisor = 1;
                while (10 * divisor <= parseInt(rule.value, 10)) { // Inefficient, but won't suffer from Math.log rounding errors
                    divisor *= 10;
                }
                return divisor;
            }

            // Replace is used for tokenization, the return value isn't used:
            rbnf.replace(/(?:([\<\>\=])(?:(%%?[\w\-]+)|([#,0.]+))?\1)|(?:\[([^\]]+)\])|([\x7f-\uffff:'\.\s\w\d\-]+)/gi, function ($0, specialChar, otherFormat, decimalFormat, optional, literal) {
                // The meanings of the substitution token characters are as follows:
                if (specialChar) {
                    var expr;
                    if (specialChar === '<') { // <<
                        if (/^\d+$/.test(rule.value)) {
                            // In normal rule: Divide the number by the rule's divisor and format the quotient
                            expr = ['call', ['dot', ['name', 'Math'], 'floor'], [['binary', '/', ['name', 'n'], ['num', getDivisor()]]]];
                        } else if (rule.value === '-x') {
                            throw new Error('<< not allowed in negative number rule');
                        } else {
                            // In fraction or master rule: Isolate the number's integral part and format it.
                            expr = ['call', ['dot', ['name', 'Math'], 'floor'], [['name', 'n']]];
                        }
                    } else if (specialChar === '>') { // >>
                        if (/\./.test(rule.value)) {
                            // Fraction or master rule => parseInt(String(n).replace(/\d*\./, ''), 10)
                            expr = ['call', ['name', 'parseInt'], [['call', ['dot', ['call', ['name', 'String'], [['name', 'n']]], 'replace'], [['regexp', '\\d*\\.', ''], ['string', '']]], ['num', 10]]];
                        } else if (rule.value === '-x') {
                            expr = ['unary-prefix', '-', ['name', 'n']];
                        } else {
                            expr = ['binary', '%', ['name', 'n'], ['num', getDivisor()]];
                        }
                    } else if (specialChar === '=') { // ==
                        expr = ['name', 'n'];
                    }
                    // FIXME: >>> not supported

                    // The substitution descriptor (i.e., the text between the token characters) may take one of three forms:
                    if (otherFormat) {
                        // A rule set name:
                        // Perform the mathematical operation on the number, and format the result using the named rule set.
                        var otherFormatName = CldrRbnfRuleSet.getSafeRendererName(otherFormat);
                        isSeenByRuleSetType[otherFormatName] = true;
                        // Turn into this.<otherFormatName>(<expr>)
                        expressionAsts.push(['call', ['dot', ['name', 'this'], otherFormatName], [expr]]);
                    } else if (decimalFormat) {
                        // A DecimalFormat pattern:
                        // Perform the mathematical operation on the number, and format the result using a DecimalFormat
                        // with the specified pattern. The pattern must begin with 0 or #.
                        expressionAsts.push(['call', ['dot', ['name', 'this'], 'renderNumber'], [expr, ['string', decimalFormat]]]);
                    } else {
                        // Nothing:
                        if (specialChar === '>') {
                            // If you omit the substitution descriptor in a >> substitution in a fraction rule, format the result one digit at a time using the rule set containing the current rule.
                            expressionAsts.push(['call', ['dot', ['name', 'this'], that.type], [expr]]);
                        } else if (specialChar === '<') {
                            // If you omit the substitution descriptor in a << substitution in a rule in a fraction rule set, format the result using the default rule set for this renderer.
                            // FIXME: Should be the default rule set for this renderer!
                            expressionAsts.push(['call', ['dot', ['name', 'this'], that.type], [expr]]);
                        } else {
                            throw new Error('== not supported!');
                        }
                   }
                } else if (optional) { // [ ... ]
                    var optionalRuleExpressionAst = ruleToExpressionAst({radix: rule.radix, rbnf: optional, value: rule.value});
                    expressionAsts.push(['conditional', ['binary', '===', ['name', 'n'], ['num', parseInt(rule.value, 10)]], ['string', ''], optionalRuleExpressionAst]);
                } else if (literal) {
                    expressionAsts.push(['string', literal]);
                } else {
                    throw new Error("Unknown token in " + rule.rbnf);
                }
            });
            if (expressionAsts.length === 0) {
                expressionAsts = [['string', '']];
            }
            var expressionAst = expressionAsts.shift();
            while (expressionAsts.length > 0) {
                expressionAst = ['binary', '+', expressionAst, expressionAsts.shift()];
            }
            return expressionAst;
        }

        function conditionToStatementAst(conditionAst, rule) {
            return ['if', conditionAst, ['return', ruleToExpressionAst(rule)], null];
        }

        var statementAsts = [];
        if (this.ruleByValue['x.0'] || this.ruleByValue['x.x']) {
            // var isFractional = n !== Math.floor(n);
            statementAsts.push(['var', [['isFractional', ['binary', '!==', ['name', 'n'], ['call', ['dot', ['name', 'Math'], 'floor'], [['name', 'n']]]]]]]);
        }
        if (this.ruleByValue['x.0']) {
            statementAsts.push(conditionToStatementAst(['name', 'isFractional'], this.ruleByValue['x.0']));
        }
        if (this.ruleByValue['-x']) {
            statementAsts.push(conditionToStatementAst(['binary', '<', ['name', 'n'], ['num', 0]], this.ruleByValue['-x']));
        }
        if (this.ruleByValue['x.x']) {
            statementAsts.push(conditionToStatementAst(['binary', '&&', ['name', 'isFractional'], ['binary', '>', ['name', 'n'], ['num', 1]]], this.ruleByValue['x.x']));
        }
        if (this.ruleByValue['0.x']) {
            statementAsts.push(conditionToStatementAst(['binary', '&&', ['binary', '>', ['name', 'n'], ['num', 0]], ['binary', '<', ['name', 'n'], ['num', 1]]], this.ruleByValue['0.x']));
        }

        Object.keys(this.ruleByValue).filter(function (value) {
            return /^\d+$/.test(value);
        }).map(function (value) {
            return parseInt(value, 10);
        }).sort(function (a, b) {
            return b - a;
        }).forEach(function (numericalValue) {
            statementAsts.push(conditionToStatementAst(['binary', '>=', ['name', 'n'], ['num', numericalValue]], this.ruleByValue[numericalValue]));
        }, this);

        return {functionAst: ['function', null, ['n'], statementAsts], dependencies: Object.keys(isSeenByRuleSetType)};
    }
};

module.exports = CldrRbnfRuleSet;

},{"underscore":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/underscore/underscore.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/cldr.js":[function(require,module,exports){
(function (process,__dirname){
var Path = require('path'),
    fs = require('fs'),
    _ = require('underscore'),
    passError = require('passerror'),
    memoizeAsync = require('./memoizeAsync'),
    dom = require('xmldom').DOMParser,
    xpath = require('xpath'),
    seq = require('seq'),
    normalizeLocaleId = require('./normalizeLocaleId'),
    normalizeProperty = require('./normalizeProperty'),
    convertObjectsWithIntegerKeysToArrays = require('./convertObjectsWithIntegerKeysToArrays'),
    CldrPluralRuleSet = require('./CldrPluralRuleSet'),
    CldrRbnfRuleSet = require('./CldrRbnfRuleSet'),
    uglifyJs = require('uglify-js'),
    unicoderegexp = require('unicoderegexp');

function normalizeXPathQuery(xpathQuery) {
    var xpathQueryFragments = xpathQuery.split('/');
    for (var i = 0 ; i < xpathQueryFragments.length ; i += 1) {
        if (i > 0 && xpathQueryFragments[i] === '..' && xpathQueryFragments[i - 1] !== '..') {
            xpathQueryFragments.splice(i - 1, 2);
            i -= 2;
        }
    }
    return xpathQueryFragments.join('/');
}

function expandLocaleIdToPrioritizedList(localeId) {
    localeId = normalizeLocaleId(localeId);
    if (!localeId) {
        return [];
    }
    var localeIds = [localeId];
    while (/_[^_]+$/.test(localeId)) {
        localeId = localeId.replace(/_[^_]+$/, '');
        localeIds.push(localeId);
    }
    return localeIds;
}

function Cldr(cldrPath) {
    // Support instantiation without the 'new' operator:
    if (!(this instanceof Cldr)) {
        return new Cldr(cldrPath);
    }
    this.cldrPath = cldrPath;
    this.documentByFileName = {};
    this.memoizerByFileName = {};
}

Cldr.prototype = {
    get fileNamesByTypeAndNormalizedLocaleId() {
        if (!this._fileNamesByTypeAndNormalizedLocaleId) {
            this._fileNamesByTypeAndNormalizedLocaleId = {};
            ['main', 'rbnf'].forEach(function (type) {
                this._fileNamesByTypeAndNormalizedLocaleId[type] = {};
                var fileNames;
                try {
                    fileNames = fs.readdirSync(Path.resolve(this.cldrPath, "common", type));
                } catch (e) {
                    if (e.code === 'ENOENT') {
                        // Directory doesn't exist, just pretend it's empty.
                        return;
                    }
                }
                fileNames.forEach(function (fileName) {
                    var matchFileName = fileName.match(/^(.*)\.xml$/);
                    if (matchFileName) {
                        this._fileNamesByTypeAndNormalizedLocaleId[type][normalizeLocaleId(matchFileName[1])] =
                            Path.resolve(this.cldrPath, "common", type, fileName);
                    }
                }, this);
            }, this);
        }
        return this._fileNamesByTypeAndNormalizedLocaleId;
    },

    get localeIds() {
        if (!this._localeIds) {
            this._localeIds = Object.keys(this.fileNamesByTypeAndNormalizedLocaleId.main);
        }
        return this._localeIds;
    },

    get calendarIds() {
        if (!this._calendarIds) {
            this._calendarIds = [];
            xpath.select('/ldmlBCP47/keyword/key[@name="ca"]/type', this.getDocument(Path.resolve(this.cldrPath, 'common', 'bcp47', 'calendar.xml'))).forEach(function (keyNode) {
                var calendarId = keyNode.getAttribute('name');
                if (calendarId === 'gregory') {
                    calendarId = 'gregorian';
                }
                this._calendarIds.push(calendarId);
            }, this);
        }
        return this._calendarIds;
    },

    get numberSystemIds() {
        if (!this._numberSystemIds) {
            this._numberSystemIds = [];
            xpath.select('/ldmlBCP47/keyword/key[@name="nu"]/type', this.getDocument(Path.resolve(this.cldrPath, 'common', 'bcp47', 'number.xml'))).forEach(function (keyNode) {
                this._numberSystemIds.push(keyNode.getAttribute('name'));
            }, this);
        }
        return this._numberSystemIds;
    },

    // Works both async and sync (omit cb):
    getDocument: function (fileName, cb) {
        var that = this;
        if (that.documentByFileName[fileName]) {
            if (cb) {
                process.nextTick(function () {
                    cb(null, that.documentByFileName[fileName]);
                });
            } else {
                return that.documentByFileName[fileName];
            }
        } else {
            if (cb) {
                // Make sure not to load file more than once if it's being loaded when getDocument is called for the second time:
                that.memoizerByFileName[fileName] = that.memoizerByFileName[fileName] || memoizeAsync(function (cb) {
                    fs.readFile(fileName, 'utf-8', passError(cb, function (xmlString) {
                        var document = new dom().parseFromString(xmlString);
                        that.documentByFileName[fileName] = document;
                        cb(null, document);
                    }));
                });
                that.memoizerByFileName[fileName](cb);
            } else {
                return that.documentByFileName[fileName] = new dom().parseFromString(fs.readFileSync(fileName, 'utf-8'));
            }
        }
    },

    getPrioritizedDocumentsForLocale: function (localeId, type) {
        var that = this;
        return expandLocaleIdToPrioritizedList(localeId).concat('root').map(function (subLocaleId) {
            return that.fileNamesByTypeAndNormalizedLocaleId[type][normalizeLocaleId(subLocaleId)];
        }).filter(function (fileName) {
            return !!fileName;
        }).map(function (fileName) {
            return that.getDocument(fileName);
        });
    },

    preload: function (localeIds, cb) {
        var that = this;
        if (typeof localeIds === 'function') {
            cb = localeIds;
            localeIds = that.localeIds;
        }
        localeIds = (Array.isArray(localeIds) ? localeIds : [localeIds]).map(normalizeLocaleId);
        var neededLocaleById = {root: true};
        localeIds.forEach(function (localeId) {
            expandLocaleIdToPrioritizedList(localeId).forEach(function (subLocaleId) {
                neededLocaleById[subLocaleId] = true;
            });
        });
        var fileNames = [
            Path.resolve(that.cldrPath, 'common', 'supplemental', 'plurals.xml'),
            Path.resolve(that.cldrPath, 'common', 'supplemental', 'numberingSystems.xml')
        ];
        Object.keys(neededLocaleById).forEach(function (localeId) {
            ['main', 'rbnf'].forEach(function (type) {
                var fileName = that.fileNamesByTypeAndNormalizedLocaleId[type][localeId];
                if (fileName) {
                    fileNames.push(fileName);
                }
            });
        });
        seq(fileNames)
            .parEach(20, function (fileName) {
                that.getDocument(fileName, this);
            })
            .seq(function () {
                cb();
            })
            .catch(cb);
    },

    createFinder: function (prioritizedDocuments) {
        return function finder(xpathQuery) {
            var prioritizedResults = [];
            prioritizedDocuments.forEach(function (document, i) {
                var resultsForLocaleDocument = xpath.select(xpathQuery, document);
                if (resultsForLocaleDocument.length === 0 && i === (prioritizedDocuments.length - 1)) {
                    // We're in root and there were no results, look for alias elements in path:
                    var queryFragments = xpathQuery.split('/'),
                        poppedQueryFragments = [];
                    while (queryFragments.length > 1) {
                        var aliasNodes = xpath.select(queryFragments.join('/') + '/alias', document);
                        if (aliasNodes.length > 0) {
                            var aliasSpecifiedQuery = normalizeXPathQuery(queryFragments.join('/') + '/' + aliasNodes[0].getAttribute('path') + '/' + poppedQueryFragments.join('/'));
                            Array.prototype.push.apply(prioritizedResults, finder(aliasSpecifiedQuery));
                            break;
                        }
                        poppedQueryFragments.unshift(queryFragments.pop());
                    }
                } else {
                    Array.prototype.push.apply(prioritizedResults, resultsForLocaleDocument);
                }
            });
            return prioritizedResults;
        };
    },

    extractLocaleDisplayPattern: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            localeDisplayPattern = {};
        finder("/ldml/localeDisplayNames/localeDisplayPattern/*").forEach(function (node) {
            localeDisplayPattern[node.nodeName] = node.textContent;
        });
        return localeDisplayPattern;
    },

    extractLanguageDisplayNames: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            languageDisplayNames = {};
        finder('/ldml/localeDisplayNames/languages/language').forEach(function (node) {
            var id = normalizeLocaleId(node.getAttribute('type'));
            languageDisplayNames[id] = languageDisplayNames[id] || node.textContent;
        });
        return languageDisplayNames;
    },

    extractTimeZoneDisplayNames: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            timeZoneDisplayNames = {};
        finder("/ldml/dates/timeZoneNames/zone").forEach(function (zoneNode) {
            var timeZoneId = zoneNode.getAttribute('type'),
                exemplarCityNodes = xpath.select("exemplarCity", zoneNode),
                tzNameLocale;
            if (exemplarCityNodes.length > 0) {
                tzNameLocale = exemplarCityNodes[0].textContent;
            } else {
                var genericDisplayNameNodes = xpath.select("long/generic", zoneNode);
                if (genericDisplayNameNodes.length > 0) {
                    tzNameLocale = genericDisplayNameNodes[0].textContent;
                } else {
                    var longDisplayNameNodes = xpath.select("long/standard", zoneNode);
                    if (longDisplayNameNodes.length > 0) {
                        tzNameLocale = longDisplayNameNodes[0].textContent;
                    }
                }
            }
            if (tzNameLocale) {
                timeZoneDisplayNames[timeZoneId] = timeZoneDisplayNames[timeZoneId] || tzNameLocale;
            }
        });
        return timeZoneDisplayNames;
    },

    extractTimeZoneFormats: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            timeZoneFormats = {};
        ['hourFormat', 'gmtFormat', 'gmtZeroFormat', 'regionFormat', 'fallbackFormat', 'fallbackRegionFormat'].forEach(function (tagName) {
            finder("/ldml/dates/timeZoneNames/" + tagName).forEach(function (node) {
                var formatName = node.nodeName.replace(/Format$/, ''),
                    value = node.textContent;
                if (formatName === 'hour') {
                    value = value.split(';');
                }
                timeZoneFormats[formatName] = timeZoneFormats[formatName] || value;
            });
        });
        finder("/ldml/dates/timeZoneNames/regionFormat[@type]").forEach(function (node) {
            var type = node.getAttribute('type');
            timeZoneFormats.regions = timeZoneFormats.regions || {};
            timeZoneFormats.regions[type] = timeZoneFormats.regions[type] || node.textContent;
        });
        return timeZoneFormats;
    },

    extractTerritoryDisplayNames: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            territoryDisplayNames = {};
        finder("/ldml/localeDisplayNames/territories/territory").forEach(function (territoryNode) {
            var territoryId = territoryNode.getAttribute('type');
            territoryDisplayNames[territoryId] = territoryDisplayNames[territoryId] || territoryNode.textContent;
        });
        return territoryDisplayNames;
    },

    extractCurrencyInfoById: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            currencyDisplayNameByCurrencyId = {},
            currencyDisplayNameByCurrencyIdAndCount = {},
            currencySymbolByCurrencyId = {};

        finder("/ldml/numbers/currencies/currency/displayName").forEach(function (displayNameNode) {
            var currencyId = displayNameNode.parentNode.getAttribute('type'),
                countAttribute = displayNameNode.getAttribute('count');
            if (countAttribute) {
                currencyDisplayNameByCurrencyIdAndCount[currencyId] = currencyDisplayNameByCurrencyIdAndCount[currencyId] || {};
                currencyDisplayNameByCurrencyIdAndCount[currencyId][countAttribute] = displayNameNode.textContent;
            } else {
                currencyDisplayNameByCurrencyId[currencyId] = currencyDisplayNameByCurrencyId[currencyId] || displayNameNode.textContent;
            }
        });

        finder("/ldml/numbers/currencies/currency/symbol").forEach(function (symbolNode) {
            var currencyId = symbolNode.parentNode.getAttribute('type');
            currencySymbolByCurrencyId[currencyId] = currencySymbolByCurrencyId[currencyId] || symbolNode.textContent;
        });

        var currencyInfoById = {};
        Object.keys(currencyDisplayNameByCurrencyId).forEach(function (currencyId) {
            currencyInfoById[currencyId] = _.extend({
                displayName: currencyDisplayNameByCurrencyId[currencyId],
                symbol: currencySymbolByCurrencyId[currencyId]
            }, currencyDisplayNameByCurrencyIdAndCount[currencyId]);
        });
        return currencyInfoById;
    },

    extractScriptDisplayNames: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            scriptDisplayNames = {};
        finder("/ldml/localeDisplayNames/scripts/script").forEach(function (scriptNode) {
            var id = scriptNode.getAttribute('type');
            scriptDisplayNames[id] = scriptDisplayNames[id] || scriptNode.textContent;
        });
        return scriptDisplayNames;
    },

    extractKeyTypes: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            keyTypes = {};
        finder('/ldml/localeDisplayNames/keys/key').forEach(function (keyNode) {
            var type = keyNode.getAttribute('type');
            keyTypes[type] = { displayName: keyNode.textContent };
        });
        finder('/ldml/localeDisplayNames/types/type').forEach(function (typeNode) {
            var key = typeNode.getAttribute('key'),
                type = normalizeProperty(typeNode.getAttribute('type'));
            keyTypes[key] = keyTypes[key] || {};
            keyTypes[key].types = keyTypes[key].types || {};
            keyTypes[key].types[type] = typeNode.textContent;
        });
        return keyTypes;
    },

    extractTransformNames: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            transformNames = {};
        finder("/ldml/localeDisplayNames/transformNames/transformName").forEach(function (transformNameNode) {
            var id = transformNameNode.getAttribute('type');
            transformNames[id] = transformNames[id] || transformNameNode.textContent;
        });
        return transformNames;
    },

    extractMeasurementSystemNames: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            measurementSystemNames = {};
        finder("/ldml/localeDisplayNames/measurementSystemNames/measurementSystemName").forEach(function (measurementSystemNameNode) {
            var id = measurementSystemNameNode.getAttribute('type');
            measurementSystemNames[id] = measurementSystemNames[id] || measurementSystemNameNode.textContent;
        });
        return measurementSystemNames;
    },

    extractCodePatterns: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            codePatterns = {};
        finder("/ldml/localeDisplayNames/codePatterns/codePattern").forEach(function (codePatternNode) {
            var id = codePatternNode.getAttribute('type');
            codePatterns[id] = codePatterns[id] || codePatternNode.textContent;
        });
        return codePatterns;
    },

    // Calendar extraction methods:

    extractEraNames: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            eraNames;
        ['eraNames', 'eraAbbr'].forEach(function (eraType) {
            var typeInOutput = {eraNames: 'wide', eraAbbr: 'abbreviated'}[eraType];
            finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/eras/" + eraType + "/era").forEach(function (eraNode) {
                var type = parseInt(eraNode.getAttribute('type'), 10);
                eraNames = eraNames || {};
                eraNames[typeInOutput] = eraNames[typeInOutput] || {};
                eraNames[typeInOutput][type] = eraNames[typeInOutput][type] || eraNode.textContent;
            });
        });
        return convertObjectsWithIntegerKeysToArrays(eraNames);
    },

    extractQuarterNames: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            quarterNames;
        ['format', 'stand-alone'].forEach(function (quarterContext) {
            var quarterContextCamelCase = normalizeProperty(quarterContext); // stand-alone => standAlone
            ['abbreviated', 'narrow', 'wide'].forEach(function (quarterWidth) {
                finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/quarters/quarterContext[@type='" + quarterContext + "']/quarterWidth[@type='" + quarterWidth + "']/quarter").forEach(function (quarterNode) {
                    var quarterNo = parseInt(quarterNode.getAttribute('type'), 10) - 1;

                    quarterNames = quarterNames || {};
                    quarterNames[quarterContextCamelCase] = quarterNames[quarterContextCamelCase] || {};
                    quarterNames[quarterContextCamelCase][quarterWidth] = quarterNames[quarterContextCamelCase][quarterWidth] || {};
                    quarterNames[quarterContextCamelCase][quarterWidth][quarterNo] = quarterNames[quarterContextCamelCase][quarterWidth][quarterNo] || quarterNode.textContent;
                });
            });
        });
        return convertObjectsWithIntegerKeysToArrays(quarterNames);
    },

    extractDayPeriods: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            dayPeriods;
        ['format', 'stand-alone'].forEach(function (dayPeriodContext) {
            var dayPeriodContextCamelCase = normalizeProperty(dayPeriodContext); // stand-alone => standAlone
            ['abbreviated', 'narrow', 'wide', 'short'].forEach(function (dayPeriodWidth) {
                finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/dayPeriods/dayPeriodContext[@type='" + dayPeriodContext + "']/dayPeriodWidth[@type='" + dayPeriodWidth + "']/dayPeriod").forEach(function (dayPeriodNode) {
                    var type = dayPeriodNode.getAttribute('type');

                    dayPeriods = dayPeriods || {};
                    dayPeriods[dayPeriodContextCamelCase] = dayPeriods[dayPeriodContextCamelCase] || {};
                    dayPeriods[dayPeriodContextCamelCase][dayPeriodWidth] =
                        dayPeriods[dayPeriodContextCamelCase][dayPeriodWidth] || {};
                    dayPeriods[dayPeriodContextCamelCase][dayPeriodWidth][type] =
                        dayPeriods[dayPeriodContextCamelCase][dayPeriodWidth][type] || dayPeriodNode.textContent;
                });
            });
        });
        return dayPeriods;
    },

    extractCyclicNames: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            cyclicNames;
        ['dayParts', 'days', 'months', 'years', 'zodiacs'].forEach(function (cyclicNameSet) {
            ['format'].forEach(function (cyclicNameContext) {
                ['abbreviated', 'narrow', 'wide'].forEach(function (cyclicNameWidth) {
                    finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/cyclicNameSets/cyclicNameSet[@type='" + cyclicNameSet + "']/cyclicNameContext[@type='" + cyclicNameContext + "']/cyclicNameWidth[@type='" + cyclicNameWidth + "']/cyclicName").forEach(function (cyclicNameNode) {
                        var type = cyclicNameNode.getAttribute('type');
                        cyclicNames = cyclicNames || {};
                        cyclicNames[cyclicNameSet] = cyclicNames[cyclicNameSet] || {};
                        cyclicNames[cyclicNameSet][cyclicNameContext] = cyclicNames[cyclicNameSet][cyclicNameContext] || {};
                        cyclicNames[cyclicNameSet][cyclicNameContext][cyclicNameWidth] = cyclicNames[cyclicNameSet][cyclicNameContext][cyclicNameWidth] || {};
                        cyclicNames[cyclicNameSet][cyclicNameContext][cyclicNameWidth][type] = cyclicNames[cyclicNameSet][cyclicNameContext][cyclicNameWidth][type] || cyclicNameNode.textContent;
                    });
                });
            });
        });
        return convertObjectsWithIntegerKeysToArrays(cyclicNames);
    },

    extractMonthNames: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            monthNames;
        ['format', 'stand-alone'].forEach(function (monthContext) {
            var monthContextCamelCase = normalizeProperty(monthContext); // stand-alone => standAlone
            ['abbreviated', 'narrow', 'wide'].forEach(function (monthWidth) {
                finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/months/monthContext[@type='" + monthContext + "']/monthWidth[@type='" + monthWidth + "']/month").forEach(function (monthNode) {
                    var monthNo = parseInt(monthNode.getAttribute('type'), 10) - 1;
                    monthNames = monthNames || {};
                    monthNames[monthContextCamelCase] = monthNames[monthContextCamelCase] || {};
                    monthNames[monthContextCamelCase][monthWidth] = monthNames[monthContextCamelCase][monthWidth] || {};
                    monthNames[monthContextCamelCase][monthWidth][monthNo] =
                        monthNames[monthContextCamelCase][monthWidth][monthNo] || monthNode.textContent;
                });
            });
        });
        return convertObjectsWithIntegerKeysToArrays(monthNames);
    },

    extractMonthPatterns: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            monthPatterns;
        ['format', 'numeric', 'stand-alone'].forEach(function (monthPatternContext) {
            var monthPatternContextCamelCase = normalizeProperty(monthPatternContext); // stand-alone => standAlone
            ['abbreviated', 'narrow', 'wide', 'all'].forEach(function (monthPatternWidth) {
                finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/monthPatterns/monthPatternContext[@type='" + monthPatternContext + "']/monthPatternWidth[@type='" + monthPatternWidth + "']/monthPattern").forEach(function (monthPatternNode) {
                    var type = monthPatternNode.getAttribute('type');
                    monthPatterns = monthPatterns || {};
                    monthPatterns[monthPatternContextCamelCase] = monthPatterns[monthPatternContextCamelCase] || {};
                    monthPatterns[monthPatternContextCamelCase][monthPatternWidth] =
                        monthPatterns[monthPatternContextCamelCase][monthPatternWidth] || {};
                    monthPatterns[monthPatternContextCamelCase][monthPatternWidth][type] =
                        monthPatterns[monthPatternContextCamelCase][monthPatternWidth][type] || monthPatternNode.textContent;
                });
            });
        });
        return monthPatterns;
    },

    extractDayNames: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            dayNoByCldrId = {sun: 0, mon: 1, tue: 2, wed: 3, thu: 4, fri: 5, sat: 6},
            dayNames;
        ['format', 'numeric', 'stand-alone'].forEach(function (dayContext) {
            var dayContextCamelCase = normalizeProperty(dayContext); // stand-alone => standAlone
            ['abbreviated', 'narrow', 'wide', 'short'].forEach(function (dayWidth) {
                finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/days/dayContext[@type='" + dayContext + "']/dayWidth[@type='" + dayWidth + "']/day").forEach(function (dayNode) {
                    var dayNo = dayNoByCldrId[dayNode.getAttribute('type')];
                    dayNames = dayNames || {};
                    dayNames[dayContextCamelCase] = dayNames[dayContextCamelCase] || {};
                    dayNames[dayContextCamelCase][dayWidth] = dayNames[dayContextCamelCase][dayWidth] || {};
                    dayNames[dayContextCamelCase][dayWidth][dayNo] = dayNames[dayContextCamelCase][dayWidth][dayNo] || dayNode.textContent;
                });
            });
        });
        return convertObjectsWithIntegerKeysToArrays(dayNames);
    },

    extractFields: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            fields;
        finder("/ldml/dates/fields/field/displayName").forEach(function (fieldDisplayNameNode) {
            var fieldName = fieldDisplayNameNode.parentNode.getAttribute('type');
            fields = fields || {};
            fields[fieldName] = fields[fieldName] || {};
            fields[fieldName].displayName = fields[fieldName].displayName || fieldDisplayNameNode.textContent;
        });

        finder("/ldml/dates/fields/field/relative").forEach(function (fieldRelativeNode) {
            var fieldName = fieldRelativeNode.parentNode.getAttribute('type'),
                type = fieldRelativeNode.getAttribute('type');
            fields = fields || {};
            fields[fieldName] = fields[fieldName] || {};
            fields[fieldName].relative = fields[fieldName].relative || {};
            fields[fieldName].relative[type] = fields[fieldName].relative[type] || fieldRelativeNode.textContent;
        });

        finder("/ldml/dates/fields/field/relativeTime/relativeTimePattern").forEach(function (relativeTimePatternNode) {
            var relativeTimeNode = relativeTimePatternNode.parentNode,
                fieldName = relativeTimeNode.parentNode.getAttribute('type'),
                type = relativeTimeNode.getAttribute('type'),
                count = relativeTimePatternNode.getAttribute('count');
            fields = fields || {};
            fields[fieldName] = fields[fieldName] || {};
            fields[fieldName].relativeTime = fields[fieldName].relativeTime || {};
            fields[fieldName].relativeTime[type] = fields[fieldName].relativeTime[type] || {};
            fields[fieldName].relativeTime[type][count] = fields[fieldName].relativeTime[type][count] || relativeTimePatternNode.textContent
        });
        return fields;
    },

    extractDateTimePatterns: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            dateTimePatterns;
        finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/dateTimeFormats/dateTimeFormatLength/dateTimeFormat").forEach(function (dateTimeFormatNode) {
            var dateTimeFormatLengthType = dateTimeFormatNode.parentNode.getAttribute('type'),
                patternNodes = xpath.select("pattern", dateTimeFormatNode);
            if (patternNodes.length !== 1) {
                throw new Error('Expected exactly one pattern in dateTimeFormatNode');
            }
            dateTimePatterns = dateTimePatterns || {};
            dateTimePatterns[dateTimeFormatLengthType] = dateTimePatterns[dateTimeFormatLengthType] || patternNodes[0].textContent;
        });
        return dateTimePatterns;
    },

    extractDateOrTimeFormats: function (localeId, calendarId, dateOrTime) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            formats;
        finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/" + dateOrTime + "Formats/" + dateOrTime + "FormatLength/" + dateOrTime + "Format/*").forEach(function (patternNode) {
            var type = patternNode.parentNode.parentNode.getAttribute('type');
            formats = formats || {};
            formats[type] = formats[type] || patternNode.textContent;
        });
        return formats;
    },

    extractDateFormats: function (localeId, calendarId) {
        return this.extractDateOrTimeFormats(localeId, calendarId, 'date');
    },

    extractTimeFormats: function (localeId, calendarId) {
        return this.extractDateOrTimeFormats(localeId, calendarId, 'time');
    },

    extractDateFormatItems: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            dateFormatItems;
        finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/dateTimeFormats/availableFormats/dateFormatItem").forEach(function (dateFormatItemNode) {
            var id = dateFormatItemNode.getAttribute('id');
            dateFormatItems = dateFormatItems || {};
            dateFormatItems[id] = dateFormatItems[id] || dateFormatItemNode.textContent;
        });
        return dateFormatItems;
    },

    extractDateIntervalFormats: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            dateIntervalFormats;
        finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/dateTimeFormats/intervalFormats/intervalFormatItem").forEach(function (intervalFormatItemNode) {
            var dateIntervalFormat = {};
            for (var i = 0 ; i < intervalFormatItemNode.childNodes.length ; i += 1) {
                var greatestDifferenceNode = intervalFormatItemNode.childNodes[i];
                if (greatestDifferenceNode.nodeType !== 1) {
                    // Skip whitespace node
                    continue;
                }
                var greatestDifferenceIdAttribute = greatestDifferenceNode.getAttribute('id');
                var greatestDifferenceId = greatestDifferenceIdAttribute;
                dateIntervalFormat[greatestDifferenceId] = dateIntervalFormat[greatestDifferenceId] || greatestDifferenceNode.textContent;
            }
            var id = intervalFormatItemNode.getAttribute('id');
            dateIntervalFormats = dateIntervalFormats || {};
            dateIntervalFormats[id] = dateIntervalFormats[id] || dateIntervalFormat;
        });
        return dateIntervalFormats;
    },

    extractDateIntervalFallbackFormat: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            dateIntervalFallbackFormat;
        finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/dateTimeFormats/intervalFormats/intervalFormatFallback").forEach(function (intervalFormatFallbackNode) {
            dateIntervalFallbackFormat = dateIntervalFallbackFormat || intervalFormatFallbackNode.textContent;
        });
        return dateIntervalFallbackFormat;
    },

    // Number extraction code:

    extractNumberSymbols: function (localeId, numberSystemId) {
        numberSystemId = numberSystemId || 'latn';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            numberSymbols;
        finder("/ldml/numbers/symbols[@numberSystem = '" + numberSystemId + "']/*[name() != 'alias']").concat(finder("/ldml/numbers/symbols/*[name() != 'alias']")).forEach(function (numberSymbolNode) {
            var symbolId = numberSymbolNode.nodeName;
            numberSymbols = numberSymbols || {};
            numberSymbols[symbolId] = numberSymbols[symbolId] || numberSymbolNode.textContent;
        });
        return numberSymbols;
    },

    extractNumberFormats: function (localeId, numberSystemId) {
        numberSystemId = numberSystemId || 'latn';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            numberFormats;
        ['scientific', 'decimal', 'currency', 'percent'].forEach(function (formatType) {
            ['full', 'long', 'medium', 'short'].forEach(function (length) {
                finder("/ldml/numbers/" + formatType + "Formats[@numberSystem = '" + numberSystemId + "']/" + formatType + "FormatLength[@type='" + length + "']/" + formatType + "Format/pattern").forEach(function (patternNode) {
                    var type = patternNode.getAttribute('type'),
                        count = patternNode.getAttribute('count');
                    numberFormats = numberFormats || {};
                    numberFormats[formatType] = numberFormats[formatType] || {};
                    numberFormats[formatType][length] = numberFormats[formatType][length] || {};
                    numberFormats[formatType][length][type] = numberFormats[formatType][length][type] || {};
                    numberFormats[formatType][length][type][count] = numberFormats[formatType][length][type][count] || patternNode.textContent;
                });
            });
            finder("/ldml/numbers/" + formatType + "Formats[@numberSystem = '" + numberSystemId + "']/" + formatType + "FormatLength[not(@type)]/" + formatType + "Format/pattern").forEach(function (patternNode) {
                numberFormats = numberFormats || {};
                numberFormats[formatType] = numberFormats[formatType] || {};
                numberFormats[formatType].default = numberFormats[formatType].default || patternNode.textContent;
            });
            finder("/ldml/numbers/" + formatType + "Formats[@numberSystem = '" + numberSystemId + "']/unitPattern").forEach(function (unitPatternNode) {
                var count = unitPatternNode.getAttribute('count');
                numberFormats = numberFormats || {};
                numberFormats[formatType] = numberFormats[formatType] || {};
                numberFormats[formatType][count] = numberFormats[formatType][count] || unitPatternNode.textContent;
            });
        });

        finder("/ldml/numbers/currencyFormats[@numberSystem = '" + numberSystemId + "']/currencySpacing").forEach(function (currencySpacingNode) {
            numberFormats = numberFormats || {};
            numberFormats.currency = numberFormats.currency || {};
            numberFormats.currency.currencySpacing = numberFormats.currency.currencySpacing || {};

            ['before', 'after'].forEach(function (place) {
                var placeData = numberFormats.currency.currencySpacing[place + 'Currency'] = numberFormats.currency.currencySpacing[place + 'Currency'] || {};

                ['currencyMatch', 'surroundingMatch', 'insertBetween'].forEach(function (spacingPropertyName) {
                    var match = xpath.select(place + "Currency/" + spacingPropertyName, currencySpacingNode);
                    if (match.length > 0) {
                        numberFormats.currency.currencySpacing[place + 'Currency'][spacingPropertyName] = match[0].textContent;
                    }
                });

                ['currencyMatch', 'surroundingMatch'].forEach(function (spacingPropertyName) {
                    if (placeData[spacingPropertyName]) {
                        placeData[spacingPropertyName] = unicoderegexp.expandCldrUnicodeSetIdToCharacterClass(placeData[spacingPropertyName]);
                    }
                });
            });
        });

        return numberFormats;
    },

    extractDefaultNumberSystemId: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            defaultNumberSystemId;
        finder('/ldml/numbers/defaultNumberingSystem').forEach(function (defaultNumberingSystemNode) {
            defaultNumberSystemId = defaultNumberSystemId || defaultNumberingSystemNode.textContent;
        });
        return defaultNumberSystemId;
    },

    extractUnitPatterns: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            unitPatterns = {};
        finder("/ldml/units/unitLength/unit/unitPattern").forEach(function (unitPatternNode) {
            var unitNode = unitPatternNode.parentNode,
                unitLength = unitNode.parentNode.getAttribute('type'),
                unitId = normalizeProperty(unitNode.getAttribute('type'));
            unitPatterns[unitLength] = unitPatterns[unitLength] || {};
            unitPatterns[unitLength].unit = unitPatterns[unitLength].unit || {};
            unitPatterns[unitLength].unit[unitId] = unitPatterns[unitLength].unit[unitId] || {};
            var count = unitPatternNode.getAttribute('count');
            unitPatterns[unitLength].unit[unitId][count] = unitPatterns[unitLength].unit[unitId][count] || unitPatternNode.textContent;
        });
        finder("/ldml/units/unitLength/compoundUnit/compoundUnitPattern").forEach(function (compoundUnitPatternNode) {
            var compoundUnitNode = compoundUnitPatternNode.parentNode,
                unitLength = compoundUnitNode.parentNode.getAttribute('type'),
                compoundUnitId = compoundUnitNode.getAttribute('type');

            unitPatterns[unitLength].compoundUnit = unitPatterns[unitLength].compoundUnit || {};
            unitPatterns[unitLength].compoundUnit[compoundUnitId] = compoundUnitPatternNode.textContent;
        });
        return unitPatterns;
    },

    extractDelimiters: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            delimiters = {};
        finder("/ldml/delimiters/*").forEach(function (delimiterNode) {
            var type = delimiterNode.nodeName;
            delimiters[type] = delimiters[type] || delimiterNode.textContent;
        });
        return delimiters;
    },

    extractListPatterns: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            listPatterns = {};
        finder("/ldml/listPatterns/listPattern/listPatternPart").forEach(function (listPatternPartNode) {
            var listPatternTypeAttribute = listPatternPartNode.parentNode.getAttribute('type'),
                type = listPatternTypeAttribute ? normalizeProperty(listPatternTypeAttribute) : 'default',
                part = listPatternPartNode.getAttribute('type');
            listPatterns[type] = listPatterns[type] || {};
            listPatterns[type][part] = listPatterns[type][part] || listPatternPartNode.textContent;
        });
        return listPatterns;
    },

    extractCharacters: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            characters = {
                exemplar: {},
                ellipsis: {}
            };
        finder("/ldml/characters/exemplarCharacters").forEach(function (exemplarCharactersNode) {
            var typeAttr = exemplarCharactersNode.getAttribute('type'),
                type = typeAttr || 'default';
            characters.exemplar[type] = characters.exemplar[type] || exemplarCharactersNode.textContent.replace(/^\[|\]$/g, '').split(" ");
        });
        finder("/ldml/characters/ellipsis").forEach(function (ellipsisNode) {
            var type = ellipsisNode.getAttribute('type');
            characters.ellipsis[type] = characters.ellipsis[type] || ellipsisNode.textContent;
        });
        finder("/ldml/characters/moreInformation").forEach(function (moreInformationNode) {
            characters.moreInformation = characters.moreInformation || moreInformationNode.textContent;
        });
        return characters;
    },

    extractPluralRuleFunction: function (localeId) {
        var that = this,
            document = that.getDocument(Path.resolve(that.cldrPath, 'common', 'supplemental', 'plurals.xml')),
            subLocaleIds = expandLocaleIdToPrioritizedList(localeId),
            statementAsts = [];
        for (var i = 0 ; i < subLocaleIds.length ; i += 1) {
            var subLocaleId = subLocaleIds[i],
                matchLocalesXPathExpr =
                    "@locales = '" + subLocaleId + "' or " +
                    "starts-with(@locales, '" + subLocaleId + "') or " +
                    "contains(@locales, ' " + subLocaleId + " ') or " +
                    "substring(@locales, string-length(@locales) - string-length(' " + subLocaleId + "') + 1) = ' " + subLocaleId + "'",
                pluralRulesNodes = xpath.select("/supplementalData/plurals/pluralRules[" + matchLocalesXPathExpr + "]", document),
                cldrPluralRuleSet = new CldrPluralRuleSet();
            if (pluralRulesNodes.length > 0) {
                xpath.select("pluralRule", pluralRulesNodes[0]).forEach(function (pluralRuleNode) {
                    cldrPluralRuleSet.addRule(pluralRuleNode.textContent, pluralRuleNode.getAttribute('count'));
                });
                statementAsts = cldrPluralRuleSet.toJavaScriptFunctionBodyAst();
                break;
            }
        }
        return new Function("n", uglifyJs.uglify.gen_code(['toplevel', statementAsts]));
    },

    // 'types' is optional, defaults to all available
    extractRbnfFunctionByType: function (localeId, types) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'rbnf')),
            cldrRbnfRuleSetByType = {};
        finder('/ldml/rbnf/rulesetGrouping/ruleset/rbnfrule').forEach(function (rbnfRuleNode) {
            var type = CldrRbnfRuleSet.getSafeRendererName(rbnfRuleNode.parentNode.getAttribute('type')),
                value = rbnfRuleNode.getAttribute('value');
            cldrRbnfRuleSetByType[type] = cldrRbnfRuleSetByType[type] || new CldrRbnfRuleSet({type: type});
            if (!cldrRbnfRuleSetByType[type].ruleByValue[value]) {
                var radixAttribute = rbnfRuleNode.getAttribute('radix');
                cldrRbnfRuleSetByType[type].ruleByValue[value] = {
                    value: value,
                    rbnf: rbnfRuleNode.textContent.replace(/;$/, '').replace(//g, '<').replace(//g, '>'),
                    radix: radixAttribute
                };
            }
        });
        var isAddedByType = {},
            typesToAdd = types ? [].concat(types) : Object.keys(cldrRbnfRuleSetByType),
            rbnfFunctionByType = {
                renderNumber: String // Provide a (bad) default number rendering implementation to avoid #13
            };
        while (typesToAdd.length > 0) {
            var type = typesToAdd.shift();
            if (!(type in isAddedByType)) {
                isAddedByType[type] = true;
                var cldrRbnfRuleSet = cldrRbnfRuleSetByType[type];
                // Some rules aren't available in some locales (such as spellout-cardinal-financial).
                // The easiest thing is just to skip the missing ones here, even though it can produce
                // some broken function sets:
                if (cldrRbnfRuleSet) {
                    var result = cldrRbnfRuleSet.toFunctionAst();

                    rbnfFunctionByType[type] = new Function("n", uglifyJs.uglify.gen_code(['toplevel', result.functionAst[3]]));
                    Array.prototype.push.apply(typesToAdd, result.dependencies);
                }
            }
        }
        return rbnfFunctionByType;
    },

    extractDigitsByNumberSystemId: function () {
        var document = this.getDocument(Path.resolve(this.cldrPath, 'common', 'supplemental', 'numberingSystems.xml')),
            digitsByNumberSystemId = {};

        xpath.select('/supplementalData/numberingSystems/numberingSystem', document).forEach(function (numberingSystemNode) {
            var numberSystemId = numberingSystemNode.getAttribute('id');
            if (numberingSystemNode.getAttribute('type') === 'numeric') {
                digitsByNumberSystemId[numberSystemId] = numberingSystemNode.getAttribute('digits').split(/(?:)/);
            } else {
                // type='algorithmic'
                var rulesAttributeFragments = numberingSystemNode.getAttribute('rules').split('/'),
                    sourceLocaleId = rulesAttributeFragments.length === 3 ? normalizeLocaleId(rulesAttributeFragments[0]) : 'root',
                    ruleType = CldrRbnfRuleSet.getSafeRendererName(rulesAttributeFragments[rulesAttributeFragments.length - 1]);
                digitsByNumberSystemId[numberSystemId] = ruleType; // A string value means "use this rbnf renderer for the digits"
            }
        }, this);
        return digitsByNumberSystemId;
    },

    extractLayout: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            layout = {};
        finder("/ldml/layout/*/*").forEach(function (leafNode) {
            var type = leafNode.nodeName,
                parentType = leafNode.parentNode.nodeName;
            layout[parentType] = layout[parentType] || {};
            layout[parentType][type] = layout[parentType][type] || leafNode.textContent;
        });
        return layout;
    }
};

module.exports = new Cldr(Path.resolve(__dirname, '../3rdparty/cldr/'));
module.exports.load = function (cldrPath) {
    return new Cldr(cldrPath);
};

}).call(this,require('_process'),"/node_modules/cldr/lib")

},{"./CldrPluralRuleSet":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/CldrPluralRuleSet.js","./CldrRbnfRuleSet":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/CldrRbnfRuleSet.js","./convertObjectsWithIntegerKeysToArrays":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/convertObjectsWithIntegerKeysToArrays.js","./memoizeAsync":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/memoizeAsync.js","./normalizeLocaleId":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/normalizeLocaleId.js","./normalizeProperty":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/normalizeProperty.js","_process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js","fs":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/lib/_empty.js","passerror":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/passerror/lib/index.js","path":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/path-browserify/index.js","seq":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/index.js","uglify-js":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/uglify-js.js","underscore":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/underscore/underscore.js","unicoderegexp":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/unicoderegexp/lib/unicodeRegExp.js","xmldom":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xmldom/dom-parser.js","xpath":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xpath/xpath.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/cldrPluralRuleTermFunctionByName.js":[function(require,module,exports){
exports.i = function i(n) {
    return Math.floor(Math.abs(n));
};

exports.v = function v(n) {
    return n.toString().replace(/^[^.]*\.?/, '').length;
};

exports.w = function w(n) {
    return n.toString().replace(/^[^.]*\.?|0+$/g, '').length;
};

exports.f = function f(n) {
    return parseInt(n.toString().replace(/^[^.]*\.?/, ''), 10) || 0;
};

exports.t = function t(n) {
    return parseInt(n.toString().replace(/^[^.]*\.?|0+$/g, ''), 10) || 0;
};

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/convertObjectsWithIntegerKeysToArrays.js":[function(require,module,exports){
// Convert objects with all integer keys starting from 0 to arrays and remove undefined values:
module.exports = function convertObjectsWithIntegerKeysToArrays(obj) {
    if (Array.isArray(obj)) {
        return obj.map(convertObjectsWithIntegerKeysToArrays);
    } else if (typeof obj === 'object' && obj !== null) {
        var keys = Object.keys(obj);
        if (0 in obj || 1 in obj) {
            var firstNumericKeyNumber = 0 in obj ? 0 : 1,
                nextNumericKeyNumber = firstNumericKeyNumber + 1;
            while (nextNumericKeyNumber in obj) {
                nextNumericKeyNumber += 1;
            }
            if (keys.length > 0 && nextNumericKeyNumber === keys.length + firstNumericKeyNumber) {
                var array = [],
                    i;
                for (i = 0 ; i < firstNumericKeyNumber ; i += 1) {
                    array.push(undefined);
                }
                for (i = firstNumericKeyNumber ; i < keys.length ; i += 1) {
                    array.push(convertObjectsWithIntegerKeysToArrays(obj[i]));
                }
                return array;
            }
        }
        var resultObj = {};
        keys.forEach(function (key) {
            if (typeof obj[key] !== 'undefined') {
                resultObj[key] = convertObjectsWithIntegerKeysToArrays(obj[key]);
            }
        });
        return resultObj;
    } else {
        return obj;
    }
};

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/memoizeAsync.js":[function(require,module,exports){
(function (process){
// Create a memoizer for an async function
module.exports = function memoizeAsync(fn) {
    var resultArguments,
        waitingCallbacks;
    return function (cb) {
        var that = this;
        if (resultArguments) {
            process.nextTick(function () {
                cb.apply(this, resultArguments);
            });
        } else {
            if (waitingCallbacks) {
                waitingCallbacks.push(cb);
            } else {
                waitingCallbacks = [cb];
                fn(function () { // ...
                    var resultArguments = arguments;
                    waitingCallbacks.forEach(function (waitingCallback) {
                        waitingCallback.apply(this, resultArguments);
                    });
                    waitingCallbacks = null;
                });
            }
        }
    };
};

}).call(this,require('_process'))

},{"_process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/normalizeLocaleId.js":[function(require,module,exports){
/*
 * Replace - with _ and convert to lower case: en-GB => en_gb
 */
module.exports = function normalizeLocaleId(localeId) {
    return localeId && localeId.replace(/-/g, '_').toLowerCase();
};

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/normalizeProperty.js":[function(require,module,exports){
/*
 * Convert foo-bar attribute values to fooBar JavaScript keys
 */
module.exports = function normalizeProperty(str) {
	return str.replace(/-([a-z])/g, function ($0, ch) {
        return ch.toUpperCase();
    });
};

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/passerror/lib/index.js":[function(require,module,exports){
module.exports = function passError(errorCallback, successCallback) {
    return function (err) { // ...
        if (err) {
            errorCallback(err);
        } else if (successCallback) {
            successCallback.apply(this, [].slice.call(arguments, 1));
        }
    };
};

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/pegjs/lib/peg.js":[function(require,module,exports){
/*
 * PEG.js 0.7.0
 *
 * http://pegjs.majda.cz/
 *
 * Copyright (c) 2010-2012 David Majda
 * Licensend under the MIT license.
 */
var PEG = (function(undefined) {

var PEG = {
  /* PEG.js version (uses semantic versioning). */
  VERSION: "0.7.0",

  /*
   * Generates a parser from a specified grammar and returns it.
   *
   * The grammar must be a string in the format described by the metagramar in
   * the parser.pegjs file.
   *
   * Throws |PEG.parser.SyntaxError| if the grammar contains a syntax error or
   * |PEG.GrammarError| if it contains a semantic error. Note that not all
   * errors are detected during the generation and some may protrude to the
   * generated parser and cause its malfunction.
   */
  buildParser: function(grammar, options) {
    return PEG.compiler.compile(PEG.parser.parse(grammar), options);
  }
};

/* Thrown when the grammar contains an error. */

PEG.GrammarError = function(message) {
  this.name = "PEG.GrammarError";
  this.message = message;
};

PEG.GrammarError.prototype = Error.prototype;

/* Like Python's |range|, but without |step|. */
function range(start, stop) {
  if (stop === undefined) {
    stop = start;
    start = 0;
  }

  var result = new Array(Math.max(0, stop - start));
  for (var i = 0, j = start; j < stop; i++, j++) {
    result[i] = j;
  }
  return result;
}

function find(array, callback) {
  var length = array.length;
  for (var i = 0; i < length; i++) {
    if (callback(array[i])) {
      return array[i];
    }
  }
}

function contains(array, value) {
  /*
   * Stupid IE does not have Array.prototype.indexOf, otherwise this function
   * would be a one-liner.
   */
  var length = array.length;
  for (var i = 0; i < length; i++) {
    if (array[i] === value) {
      return true;
    }
  }
  return false;
}

function each(array, callback) {
  var length = array.length;
  for (var i = 0; i < length; i++) {
    callback(array[i], i);
  }
}

function map(array, callback) {
  var result = [];
  var length = array.length;
  for (var i = 0; i < length; i++) {
    result[i] = callback(array[i], i);
  }
  return result;
}

function pluck(array, key) {
  return map(array, function (e) { return e[key]; });
}

function keys(object) {
  var result = [];
  for (var key in object) {
    result.push(key);
  }
  return result;
}

function values(object) {
  var result = [];
  for (var key in object) {
    result.push(object[key]);
  }
  return result;
}

/*
 * Returns a string padded on the left to a desired length with a character.
 *
 * The code needs to be in sync with the code template in the compilation
 * function for "action" nodes.
 */
function padLeft(input, padding, length) {
  var result = input;

  var padLength = length - input.length;
  for (var i = 0; i < padLength; i++) {
    result = padding + result;
  }

  return result;
}

/*
 * Returns an escape sequence for given character. Uses \x for characters <=
 * 0xFF to save space, \u for the rest.
 *
 * The code needs to be in sync with the code template in the compilation
 * function for "action" nodes.
 */
function escape(ch) {
  var charCode = ch.charCodeAt(0);
  var escapeChar;
  var length;

  if (charCode <= 0xFF) {
    escapeChar = 'x';
    length = 2;
  } else {
    escapeChar = 'u';
    length = 4;
  }

  return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
}

/*
 * Surrounds the string with quotes and escapes characters inside so that the
 * result is a valid JavaScript string.
 *
 * The code needs to be in sync with the code template in the compilation
 * function for "action" nodes.
 */
function quote(s) {
  /*
   * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a string
   * literal except for the closing quote character, backslash, carriage return,
   * line separator, paragraph separator, and line feed. Any character may
   * appear in the form of an escape sequence.
   *
   * For portability, we also escape escape all control and non-ASCII
   * characters. Note that "\0" and "\v" escape sequences are not used because
   * JSHint does not like the first and IE the second.
   */
  return '"' + s
    .replace(/\\/g, '\\\\')  // backslash
    .replace(/"/g, '\\"')    // closing quote character
    .replace(/\x08/g, '\\b') // backspace
    .replace(/\t/g, '\\t')   // horizontal tab
    .replace(/\n/g, '\\n')   // line feed
    .replace(/\f/g, '\\f')   // form feed
    .replace(/\r/g, '\\r')   // carriage return
    .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
    + '"';
}

/*
 * Escapes characters inside the string so that it can be used as a list of
 * characters in a character class of a regular expression.
 */
function quoteForRegexpClass(s) {
  /*
   * Based on ECMA-262, 5th ed., 7.8.5 & 15.10.1.
   *
   * For portability, we also escape escape all control and non-ASCII
   * characters.
   */
  return s
    .replace(/\\/g, '\\\\')  // backslash
    .replace(/\//g, '\\/')   // closing slash
    .replace(/\]/g, '\\]')   // closing bracket
    .replace(/-/g, '\\-')    // dash
    .replace(/\0/g, '\\0')   // null
    .replace(/\t/g, '\\t')   // horizontal tab
    .replace(/\n/g, '\\n')   // line feed
    .replace(/\v/g, '\\x0B') // vertical tab
    .replace(/\f/g, '\\f')   // form feed
    .replace(/\r/g, '\\r')   // carriage return
    .replace(/[\x01-\x08\x0E-\x1F\x80-\uFFFF]/g, escape);
}

/*
 * Builds a node visitor -- a function which takes a node and any number of
 * other parameters, calls an appropriate function according to the node type,
 * passes it all its parameters and returns its value. The functions for various
 * node types are passed in a parameter to |buildNodeVisitor| as a hash.
 */
function buildNodeVisitor(functions) {
  return function(node) {
    return functions[node.type].apply(null, arguments);
  };
}

function findRuleByName(ast, name) {
  return find(ast.rules, function(r) { return r.name === name; });
}
PEG.parser = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "grammar": parse_grammar,
        "initializer": parse_initializer,
        "rule": parse_rule,
        "choice": parse_choice,
        "sequence": parse_sequence,
        "labeled": parse_labeled,
        "prefixed": parse_prefixed,
        "suffixed": parse_suffixed,
        "primary": parse_primary,
        "action": parse_action,
        "braced": parse_braced,
        "nonBraceCharacters": parse_nonBraceCharacters,
        "nonBraceCharacter": parse_nonBraceCharacter,
        "equals": parse_equals,
        "colon": parse_colon,
        "semicolon": parse_semicolon,
        "slash": parse_slash,
        "and": parse_and,
        "not": parse_not,
        "question": parse_question,
        "star": parse_star,
        "plus": parse_plus,
        "lparen": parse_lparen,
        "rparen": parse_rparen,
        "dot": parse_dot,
        "identifier": parse_identifier,
        "literal": parse_literal,
        "string": parse_string,
        "doubleQuotedString": parse_doubleQuotedString,
        "doubleQuotedCharacter": parse_doubleQuotedCharacter,
        "simpleDoubleQuotedCharacter": parse_simpleDoubleQuotedCharacter,
        "singleQuotedString": parse_singleQuotedString,
        "singleQuotedCharacter": parse_singleQuotedCharacter,
        "simpleSingleQuotedCharacter": parse_simpleSingleQuotedCharacter,
        "class": parse_class,
        "classCharacterRange": parse_classCharacterRange,
        "classCharacter": parse_classCharacter,
        "bracketDelimitedCharacter": parse_bracketDelimitedCharacter,
        "simpleBracketDelimitedCharacter": parse_simpleBracketDelimitedCharacter,
        "simpleEscapeSequence": parse_simpleEscapeSequence,
        "zeroEscapeSequence": parse_zeroEscapeSequence,
        "hexEscapeSequence": parse_hexEscapeSequence,
        "unicodeEscapeSequence": parse_unicodeEscapeSequence,
        "eolEscapeSequence": parse_eolEscapeSequence,
        "digit": parse_digit,
        "hexDigit": parse_hexDigit,
        "letter": parse_letter,
        "lowerCaseLetter": parse_lowerCaseLetter,
        "upperCaseLetter": parse_upperCaseLetter,
        "__": parse___,
        "comment": parse_comment,
        "singleLineComment": parse_singleLineComment,
        "multiLineComment": parse_multiLineComment,
        "eol": parse_eol,
        "eolChar": parse_eolChar,
        "whitespace": parse_whitespace
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "grammar";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_grammar() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse___();
        if (result0 !== null) {
          result1 = parse_initializer();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result3 = parse_rule();
            if (result3 !== null) {
              result2 = [];
              while (result3 !== null) {
                result2.push(result3);
                result3 = parse_rule();
              }
            } else {
              result2 = null;
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, initializer, rules) {
              return {
                type:        "grammar",
                initializer: initializer !== "" ? initializer : null,
                rules:       rules,
                startRule:   rules[0].name
              };
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_initializer() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_action();
        if (result0 !== null) {
          result1 = parse_semicolon();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, code) {
              return {
                type: "initializer",
                code: code
              };
            })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_rule() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_identifier();
        if (result0 !== null) {
          result1 = parse_string();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_equals();
            if (result2 !== null) {
              result3 = parse_choice();
              if (result3 !== null) {
                result4 = parse_semicolon();
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, name, displayName, expression) {
              return {
                type:        "rule",
                name:        name,
                displayName: displayName !== "" ? displayName : null,
                expression:  expression
              };
            })(pos0, result0[0], result0[1], result0[3]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_choice() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_sequence();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_slash();
          if (result2 !== null) {
            result3 = parse_sequence();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_slash();
            if (result2 !== null) {
              result3 = parse_sequence();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) {
              if (tail.length > 0) {
                var alternatives = [head].concat(map(
                    tail,
                    function(element) { return element[1]; }
                ));
                return {
                  type:         "choice",
                  alternatives: alternatives
                };
              } else {
                return head;
              }
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_sequence() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        result1 = parse_labeled();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_labeled();
        }
        if (result0 !== null) {
          result1 = parse_action();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, elements, code) {
              var expression = elements.length !== 1
                ? {
                    type:     "sequence",
                    elements: elements
                  }
                : elements[0];
              return {
                type:       "action",
                expression: expression,
                code:       code
              };
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = [];
          result1 = parse_labeled();
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_labeled();
          }
          if (result0 !== null) {
            result0 = (function(offset, elements) {
                return elements.length !== 1
                  ? {
                      type:     "sequence",
                      elements: elements
                    }
                  : elements[0];
              })(pos0, result0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_labeled() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_identifier();
        if (result0 !== null) {
          result1 = parse_colon();
          if (result1 !== null) {
            result2 = parse_prefixed();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, label, expression) {
              return {
                type:       "labeled",
                label:      label,
                expression: expression
              };
            })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_prefixed();
        }
        return result0;
      }
      
      function parse_prefixed() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_and();
        if (result0 !== null) {
          result1 = parse_action();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, code) {
              return {
                type: "semantic_and",
                code: code
              };
            })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_and();
          if (result0 !== null) {
            result1 = parse_suffixed();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, expression) {
                return {
                  type:       "simple_and",
                  expression: expression
                };
              })(pos0, result0[1]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            result0 = parse_not();
            if (result0 !== null) {
              result1 = parse_action();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, code) {
                  return {
                    type: "semantic_not",
                    code: code
                  };
                })(pos0, result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              pos1 = pos;
              result0 = parse_not();
              if (result0 !== null) {
                result1 = parse_suffixed();
                if (result1 !== null) {
                  result0 = [result0, result1];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 !== null) {
                result0 = (function(offset, expression) {
                    return {
                      type:       "simple_not",
                      expression: expression
                    };
                  })(pos0, result0[1]);
              }
              if (result0 === null) {
                pos = pos0;
              }
              if (result0 === null) {
                result0 = parse_suffixed();
              }
            }
          }
        }
        return result0;
      }
      
      function parse_suffixed() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_primary();
        if (result0 !== null) {
          result1 = parse_question();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, expression) {
              return {
                type:       "optional",
                expression: expression
              };
            })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_primary();
          if (result0 !== null) {
            result1 = parse_star();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, expression) {
                return {
                  type:       "zero_or_more",
                  expression: expression
                };
              })(pos0, result0[0]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            result0 = parse_primary();
            if (result0 !== null) {
              result1 = parse_plus();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, expression) {
                  return {
                    type:       "one_or_more",
                    expression: expression
                  };
                })(pos0, result0[0]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              result0 = parse_primary();
            }
          }
        }
        return result0;
      }
      
      function parse_primary() {
        var result0, result1, result2;
        var pos0, pos1, pos2, pos3;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_identifier();
        if (result0 !== null) {
          pos2 = pos;
          reportFailures++;
          pos3 = pos;
          result1 = parse_string();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_equals();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos3;
            }
          } else {
            result1 = null;
            pos = pos3;
          }
          reportFailures--;
          if (result1 === null) {
            result1 = "";
          } else {
            result1 = null;
            pos = pos2;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, name) {
              return {
                type: "rule_ref",
                name: name
              };
            })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_literal();
          if (result0 === null) {
            pos0 = pos;
            result0 = parse_dot();
            if (result0 !== null) {
              result0 = (function(offset) { return { type: "any" }; })(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              result0 = parse_class();
              if (result0 === null) {
                pos0 = pos;
                pos1 = pos;
                result0 = parse_lparen();
                if (result0 !== null) {
                  result1 = parse_choice();
                  if (result1 !== null) {
                    result2 = parse_rparen();
                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
                if (result0 !== null) {
                  result0 = (function(offset, expression) { return expression; })(pos0, result0[1]);
                }
                if (result0 === null) {
                  pos = pos0;
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_action() {
        var result0, result1;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_braced();
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, braced) { return braced.substr(1, braced.length - 2); })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("action");
        }
        return result0;
      }
      
      function parse_braced() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 123) {
          result0 = "{";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"{\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_braced();
          if (result2 === null) {
            result2 = parse_nonBraceCharacter();
          }
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_braced();
            if (result2 === null) {
              result2 = parse_nonBraceCharacter();
            }
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 125) {
              result2 = "}";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"}\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, parts) {
              return "{" + parts.join("") + "}";
            })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_nonBraceCharacters() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_nonBraceCharacter();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_nonBraceCharacter();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, chars) { return chars.join(""); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_nonBraceCharacter() {
        var result0;
        
        if (/^[^{}]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[^{}]");
          }
        }
        return result0;
      }
      
      function parse_equals() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 61) {
          result0 = "=";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"=\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "="; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_colon() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 58) {
          result0 = ":";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\":\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return ":"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_semicolon() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 59) {
          result0 = ";";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\";\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return ";"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_slash() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 47) {
          result0 = "/";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "/"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_and() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 38) {
          result0 = "&";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"&\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "&"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_not() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 33) {
          result0 = "!";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"!\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "!"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_question() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 63) {
          result0 = "?";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"?\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "?"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_star() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 42) {
          result0 = "*";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"*\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "*"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_plus() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 43) {
          result0 = "+";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"+\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "+"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_lparen() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 40) {
          result0 = "(";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "("; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_rparen() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 41) {
          result0 = ")";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\")\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return ")"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_dot() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 46) {
          result0 = ".";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\".\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "."; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_identifier() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_letter();
        if (result0 === null) {
          if (input.charCodeAt(pos) === 95) {
            result0 = "_";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"_\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 36) {
              result0 = "$";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"$\"");
              }
            }
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_letter();
          if (result2 === null) {
            result2 = parse_digit();
            if (result2 === null) {
              if (input.charCodeAt(pos) === 95) {
                result2 = "_";
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"_\"");
                }
              }
              if (result2 === null) {
                if (input.charCodeAt(pos) === 36) {
                  result2 = "$";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"$\"");
                  }
                }
              }
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_letter();
            if (result2 === null) {
              result2 = parse_digit();
              if (result2 === null) {
                if (input.charCodeAt(pos) === 95) {
                  result2 = "_";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"_\"");
                  }
                }
                if (result2 === null) {
                  if (input.charCodeAt(pos) === 36) {
                    result2 = "$";
                    pos++;
                  } else {
                    result2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"$\"");
                    }
                  }
                }
              }
            }
          }
          if (result1 !== null) {
            result2 = parse___();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) {
              return head + tail.join("");
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("identifier");
        }
        return result0;
      }
      
      function parse_literal() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_doubleQuotedString();
        if (result0 === null) {
          result0 = parse_singleQuotedString();
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 105) {
            result1 = "i";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"i\"");
            }
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse___();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, value, flags) {
              return {
                type:       "literal",
                value:      value,
                ignoreCase: flags === "i"
              };
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("literal");
        }
        return result0;
      }
      
      function parse_string() {
        var result0, result1;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_doubleQuotedString();
        if (result0 === null) {
          result0 = parse_singleQuotedString();
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, string) { return string; })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("string");
        }
        return result0;
      }
      
      function parse_doubleQuotedString() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 34) {
          result0 = "\"";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\"\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_doubleQuotedCharacter();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_doubleQuotedCharacter();
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 34) {
              result2 = "\"";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\\"\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, chars) { return chars.join(""); })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_doubleQuotedCharacter() {
        var result0;
        
        result0 = parse_simpleDoubleQuotedCharacter();
        if (result0 === null) {
          result0 = parse_simpleEscapeSequence();
          if (result0 === null) {
            result0 = parse_zeroEscapeSequence();
            if (result0 === null) {
              result0 = parse_hexEscapeSequence();
              if (result0 === null) {
                result0 = parse_unicodeEscapeSequence();
                if (result0 === null) {
                  result0 = parse_eolEscapeSequence();
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_simpleDoubleQuotedCharacter() {
        var result0, result1;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        pos2 = pos;
        reportFailures++;
        if (input.charCodeAt(pos) === 34) {
          result0 = "\"";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\"\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 92) {
            result0 = "\\";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\\\"");
            }
          }
          if (result0 === null) {
            result0 = parse_eolChar();
          }
        }
        reportFailures--;
        if (result0 === null) {
          result0 = "";
        } else {
          result0 = null;
          pos = pos2;
        }
        if (result0 !== null) {
          if (input.length > pos) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("any character");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, char_) { return char_; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_singleQuotedString() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 39) {
          result0 = "'";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"'\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_singleQuotedCharacter();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_singleQuotedCharacter();
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 39) {
              result2 = "'";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"'\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, chars) { return chars.join(""); })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_singleQuotedCharacter() {
        var result0;
        
        result0 = parse_simpleSingleQuotedCharacter();
        if (result0 === null) {
          result0 = parse_simpleEscapeSequence();
          if (result0 === null) {
            result0 = parse_zeroEscapeSequence();
            if (result0 === null) {
              result0 = parse_hexEscapeSequence();
              if (result0 === null) {
                result0 = parse_unicodeEscapeSequence();
                if (result0 === null) {
                  result0 = parse_eolEscapeSequence();
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_simpleSingleQuotedCharacter() {
        var result0, result1;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        pos2 = pos;
        reportFailures++;
        if (input.charCodeAt(pos) === 39) {
          result0 = "'";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"'\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 92) {
            result0 = "\\";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\\\"");
            }
          }
          if (result0 === null) {
            result0 = parse_eolChar();
          }
        }
        reportFailures--;
        if (result0 === null) {
          result0 = "";
        } else {
          result0 = null;
          pos = pos2;
        }
        if (result0 !== null) {
          if (input.length > pos) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("any character");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, char_) { return char_; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_class() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 94) {
            result1 = "^";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"^\"");
            }
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = [];
            result3 = parse_classCharacterRange();
            if (result3 === null) {
              result3 = parse_classCharacter();
            }
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_classCharacterRange();
              if (result3 === null) {
                result3 = parse_classCharacter();
              }
            }
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 93) {
                result3 = "]";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"]\"");
                }
              }
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 105) {
                  result4 = "i";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"i\"");
                  }
                }
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result5 = parse___();
                  if (result5 !== null) {
                    result0 = [result0, result1, result2, result3, result4, result5];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, inverted, parts, flags) {
              var partsConverted = map(parts, function(part) { return part.data; });
              var rawText = "["
                + inverted
                + map(parts, function(part) { return part.rawText; }).join("")
                + "]"
                + flags;
        
              return {
                type:       "class",
                inverted:   inverted === "^",
                ignoreCase: flags === "i",
                parts:      partsConverted,
                // FIXME: Get the raw text from the input directly.
                rawText:    rawText
              };
            })(pos0, result0[1], result0[2], result0[4]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("character class");
        }
        return result0;
      }
      
      function parse_classCharacterRange() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_classCharacter();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 45) {
            result1 = "-";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_classCharacter();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, begin, end) {
              if (begin.data.charCodeAt(0) > end.data.charCodeAt(0)) {
                throw new this.SyntaxError(
                  "Invalid character range: " + begin.rawText + "-" + end.rawText + "."
                );
              }
        
              return {
                data:    [begin.data, end.data],
                // FIXME: Get the raw text from the input directly.
                rawText: begin.rawText + "-" + end.rawText
              };
            })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_classCharacter() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_bracketDelimitedCharacter();
        if (result0 !== null) {
          result0 = (function(offset, char_) {
              return {
                data:    char_,
                // FIXME: Get the raw text from the input directly.
                rawText: quoteForRegexpClass(char_)
              };
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_bracketDelimitedCharacter() {
        var result0;
        
        result0 = parse_simpleBracketDelimitedCharacter();
        if (result0 === null) {
          result0 = parse_simpleEscapeSequence();
          if (result0 === null) {
            result0 = parse_zeroEscapeSequence();
            if (result0 === null) {
              result0 = parse_hexEscapeSequence();
              if (result0 === null) {
                result0 = parse_unicodeEscapeSequence();
                if (result0 === null) {
                  result0 = parse_eolEscapeSequence();
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_simpleBracketDelimitedCharacter() {
        var result0, result1;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        pos2 = pos;
        reportFailures++;
        if (input.charCodeAt(pos) === 93) {
          result0 = "]";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"]\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 92) {
            result0 = "\\";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\\\"");
            }
          }
          if (result0 === null) {
            result0 = parse_eolChar();
          }
        }
        reportFailures--;
        if (result0 === null) {
          result0 = "";
        } else {
          result0 = null;
          pos = pos2;
        }
        if (result0 !== null) {
          if (input.length > pos) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("any character");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, char_) { return char_; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_simpleEscapeSequence() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 92) {
          result0 = "\\";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\\"");
          }
        }
        if (result0 !== null) {
          pos2 = pos;
          reportFailures++;
          result1 = parse_digit();
          if (result1 === null) {
            if (input.charCodeAt(pos) === 120) {
              result1 = "x";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"x\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 117) {
                result1 = "u";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"u\"");
                }
              }
              if (result1 === null) {
                result1 = parse_eolChar();
              }
            }
          }
          reportFailures--;
          if (result1 === null) {
            result1 = "";
          } else {
            result1 = null;
            pos = pos2;
          }
          if (result1 !== null) {
            if (input.length > pos) {
              result2 = input.charAt(pos);
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("any character");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, char_) {
              return char_
                .replace("b", "\b")
                .replace("f", "\f")
                .replace("n", "\n")
                .replace("r", "\r")
                .replace("t", "\t")
                .replace("v", "\x0B"); // IE does not recognize "\v".
            })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_zeroEscapeSequence() {
        var result0, result1;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2) === "\\0") {
          result0 = "\\0";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\0\"");
          }
        }
        if (result0 !== null) {
          pos2 = pos;
          reportFailures++;
          result1 = parse_digit();
          reportFailures--;
          if (result1 === null) {
            result1 = "";
          } else {
            result1 = null;
            pos = pos2;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "\x00"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hexEscapeSequence() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2) === "\\x") {
          result0 = "\\x";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\x\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_hexDigit();
          if (result1 !== null) {
            result2 = parse_hexDigit();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, h1, h2) {
              return String.fromCharCode(parseInt(h1 + h2, 16));
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_unicodeEscapeSequence() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2) === "\\u") {
          result0 = "\\u";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\u\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_hexDigit();
          if (result1 !== null) {
            result2 = parse_hexDigit();
            if (result2 !== null) {
              result3 = parse_hexDigit();
              if (result3 !== null) {
                result4 = parse_hexDigit();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, h1, h2, h3, h4) {
              return String.fromCharCode(parseInt(h1 + h2 + h3 + h4, 16));
            })(pos0, result0[1], result0[2], result0[3], result0[4]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_eolEscapeSequence() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 92) {
          result0 = "\\";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_eol();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, eol) { return eol; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_digit() {
        var result0;
        
        if (/^[0-9]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9]");
          }
        }
        return result0;
      }
      
      function parse_hexDigit() {
        var result0;
        
        if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9a-fA-F]");
          }
        }
        return result0;
      }
      
      function parse_letter() {
        var result0;
        
        result0 = parse_lowerCaseLetter();
        if (result0 === null) {
          result0 = parse_upperCaseLetter();
        }
        return result0;
      }
      
      function parse_lowerCaseLetter() {
        var result0;
        
        if (/^[a-z]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-z]");
          }
        }
        return result0;
      }
      
      function parse_upperCaseLetter() {
        var result0;
        
        if (/^[A-Z]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[A-Z]");
          }
        }
        return result0;
      }
      
      function parse___() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_whitespace();
        if (result1 === null) {
          result1 = parse_eol();
          if (result1 === null) {
            result1 = parse_comment();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_whitespace();
          if (result1 === null) {
            result1 = parse_eol();
            if (result1 === null) {
              result1 = parse_comment();
            }
          }
        }
        return result0;
      }
      
      function parse_comment() {
        var result0;
        
        reportFailures++;
        result0 = parse_singleLineComment();
        if (result0 === null) {
          result0 = parse_multiLineComment();
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("comment");
        }
        return result0;
      }
      
      function parse_singleLineComment() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "//") {
          result0 = "//";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"//\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          pos2 = pos;
          reportFailures++;
          result2 = parse_eolChar();
          reportFailures--;
          if (result2 === null) {
            result2 = "";
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            if (input.length > pos) {
              result3 = input.charAt(pos);
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("any character");
              }
            }
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            result2 = parse_eolChar();
            reportFailures--;
            if (result2 === null) {
              result2 = "";
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              if (input.length > pos) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("any character");
                }
              }
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_multiLineComment() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "/*") {
          result0 = "/*";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/*\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          pos2 = pos;
          reportFailures++;
          if (input.substr(pos, 2) === "*/") {
            result2 = "*/";
            pos += 2;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\"*/\"");
            }
          }
          reportFailures--;
          if (result2 === null) {
            result2 = "";
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            if (input.length > pos) {
              result3 = input.charAt(pos);
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("any character");
              }
            }
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            reportFailures--;
            if (result2 === null) {
              result2 = "";
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              if (input.length > pos) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("any character");
                }
              }
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_eol() {
        var result0;
        
        reportFailures++;
        if (input.charCodeAt(pos) === 10) {
          result0 = "\n";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\n\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 2) === "\r\n") {
            result0 = "\r\n";
            pos += 2;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\r\\n\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 13) {
              result0 = "\r";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\r\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 8232) {
                result0 = "\u2028";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\u2028\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 8233) {
                  result0 = "\u2029";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\u2029\"");
                  }
                }
              }
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("end of line");
        }
        return result0;
      }
      
      function parse_eolChar() {
        var result0;
        
        if (/^[\n\r\u2028\u2029]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\n\\r\\u2028\\u2029]");
          }
        }
        return result0;
      }
      
      function parse_whitespace() {
        var result0;
        
        reportFailures++;
        if (/^[ \t\x0B\f\xA0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[ \\t\\x0B\\f\\xA0\\uFEFF\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000]");
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("whitespace");
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();
PEG.compiler = {
  /*
   * Names of passes that will get run during the compilation (in the specified
   * order).
   */
  appliedPassNames: [
    "reportMissingRules",
    "reportLeftRecursion",
    "removeProxyRules",
    "computeVarNames",
    "computeParams"
  ],

  /*
   * Generates a parser from a specified grammar AST. Throws |PEG.GrammarError|
   * if the AST contains a semantic error. Note that not all errors are detected
   * during the generation and some may protrude to the generated parser and
   * cause its malfunction.
   */
  compile: function(ast, options) {
    var that = this;

    each(this.appliedPassNames, function(passName) {
      that.passes[passName](ast);
    });

    var source = this.emitter(ast, options);
    var result = eval(source);
    result._source = source;

    return result;
  }
};

/*
 * Compiler passes.
 *
 * Each pass is a function that is passed the AST. It can perform checks on it
 * or modify it as needed. If the pass encounters a semantic error, it throws
 * |PEG.GrammarError|.
 */
PEG.compiler.passes = {
  /* Checks that all referenced rules exist. */
  reportMissingRules: function(ast) {
    function nop() {}

    function checkExpression(node) { check(node.expression); }

    function checkSubnodes(propertyName) {
      return function(node) { each(node[propertyName], check); };
    }

    var check = buildNodeVisitor({
      grammar:      checkSubnodes("rules"),
      rule:         checkExpression,
      choice:       checkSubnodes("alternatives"),
      sequence:     checkSubnodes("elements"),
      labeled:      checkExpression,
      simple_and:   checkExpression,
      simple_not:   checkExpression,
      semantic_and: nop,
      semantic_not: nop,
      optional:     checkExpression,
      zero_or_more: checkExpression,
      one_or_more:  checkExpression,
      action:       checkExpression,

      rule_ref:
        function(node) {
          if (!findRuleByName(ast, node.name)) {
            throw new PEG.GrammarError(
              "Referenced rule \"" + node.name + "\" does not exist."
            );
          }
        },

      literal:      nop,
      any:          nop,
      "class":      nop
    });

    check(ast);
  },

  /* Checks that no left recursion is present. */
  reportLeftRecursion: function(ast) {
    function nop() {}

    function checkExpression(node, appliedRules) {
      check(node.expression, appliedRules);
    }

    function checkSubnodes(propertyName) {
      return function(node, appliedRules) {
        each(node[propertyName], function(subnode) {
          check(subnode, appliedRules);
        });
      };
    }

    var check = buildNodeVisitor({
      grammar:     checkSubnodes("rules"),

      rule:
        function(node, appliedRules) {
          check(node.expression, appliedRules.concat(node.name));
        },

      choice:      checkSubnodes("alternatives"),

      sequence:
        function(node, appliedRules) {
          if (node.elements.length > 0) {
            check(node.elements[0], appliedRules);
          }
        },

      labeled:      checkExpression,
      simple_and:   checkExpression,
      simple_not:   checkExpression,
      semantic_and: nop,
      semantic_not: nop,
      optional:     checkExpression,
      zero_or_more: checkExpression,
      one_or_more:  checkExpression,
      action:       checkExpression,

      rule_ref:
        function(node, appliedRules) {
          if (contains(appliedRules, node.name)) {
            throw new PEG.GrammarError(
              "Left recursion detected for rule \"" + node.name + "\"."
            );
          }
          check(findRuleByName(ast, node.name), appliedRules);
        },

      literal:      nop,
      any:          nop,
      "class":      nop
    });

    check(ast, []);
  },

  /*
   * Removes proxy rules -- that is, rules that only delegate to other rule.
   */
  removeProxyRules: function(ast) {
    function isProxyRule(node) {
      return node.type === "rule" && node.expression.type === "rule_ref";
    }

    function replaceRuleRefs(ast, from, to) {
      function nop() {}

      function replaceInExpression(node, from, to) {
        replace(node.expression, from, to);
      }

      function replaceInSubnodes(propertyName) {
        return function(node, from, to) {
          each(node[propertyName], function(subnode) {
            replace(subnode, from, to);
          });
        };
      }

      var replace = buildNodeVisitor({
        grammar:      replaceInSubnodes("rules"),
        rule:         replaceInExpression,
        choice:       replaceInSubnodes("alternatives"),
        sequence:     replaceInSubnodes("elements"),
        labeled:      replaceInExpression,
        simple_and:   replaceInExpression,
        simple_not:   replaceInExpression,
        semantic_and: nop,
        semantic_not: nop,
        optional:     replaceInExpression,
        zero_or_more: replaceInExpression,
        one_or_more:  replaceInExpression,
        action:       replaceInExpression,

        rule_ref:
          function(node, from, to) {
            if (node.name === from) {
              node.name = to;
            }
          },

        literal:      nop,
        any:          nop,
        "class":      nop
      });

      replace(ast, from, to);
    }

    var indices = [];

    each(ast.rules, function(rule, i) {
      if (isProxyRule(rule)) {
        replaceRuleRefs(ast, rule.name, rule.expression.name);
        if (rule.name === ast.startRule) {
          ast.startRule = rule.expression.name;
        }
        indices.push(i);
      }
    });

    indices.reverse();

    each(indices, function(index) {
      ast.rules.splice(index, 1);
    });
  },

  /*
   * Computes names of variables used for storing match results and parse
   * positions in generated code. These variables are organized as two stacks.
   * The following will hold after running this pass:
   *
   *   * All nodes except "grammar" and "rule" nodes will have a |resultVar|
   *     property. It will contain a name of the variable that will store a
   *     match result of the expression represented by the node in generated
   *     code.
   *
   *   * Some nodes will have a |posVar| property. It will contain a name of the
   *     variable that will store a parse position in generated code.
   *
   *   * All "rule" nodes will contain |resultVars| and |posVars| properties.
   *     They will contain a list of values of |resultVar| and |posVar|
   *     properties used in rule's subnodes. (This is useful to declare
   *     variables in generated code.)
   */
  computeVarNames: function(ast) {
    function resultVar(index) { return "result" + index; }
    function posVar(index)    { return "pos"    + index; }

    function computeLeaf(node, index) {
      node.resultVar = resultVar(index.result);

      return { result: 0, pos: 0 };
    }

    function computeFromExpression(delta) {
      return function(node, index) {
        var depth = compute(
              node.expression,
              {
                result: index.result + delta.result,
                pos:    index.pos    + delta.pos
              }
            );

        node.resultVar = resultVar(index.result);
        if (delta.pos !== 0) {
          node.posVar = posVar(index.pos);
        }

        return {
          result: depth.result + delta.result,
          pos:    depth.pos    + delta.pos
        };
      };
    }

    var compute = buildNodeVisitor({
      grammar:
        function(node, index) {
          each(node.rules, function(node) {
            compute(node, index);
          });
        },

      rule:
        function(node, index) {
          var depth = compute(node.expression, index);

          node.resultVar  = resultVar(index.result);
          node.resultVars = map(range(depth.result + 1), resultVar);
          node.posVars    = map(range(depth.pos),        posVar);
        },

      choice:
        function(node, index) {
          var depths = map(node.alternatives, function(alternative) {
            return compute(alternative, index);
          });

          node.resultVar = resultVar(index.result);

          return {
            result: Math.max.apply(null, pluck(depths, "result")),
            pos:    Math.max.apply(null, pluck(depths, "pos"))
          };
        },

      sequence:
        function(node, index) {
          var depths = map(node.elements, function(element, i) {
            return compute(
              element,
              { result: index.result + i, pos: index.pos + 1 }
            );
          });

          node.resultVar = resultVar(index.result);
          node.posVar    = posVar(index.pos);

          return {
            result:
              node.elements.length > 0
                ? Math.max.apply(
                    null,
                    map(depths, function(d, i) { return i + d.result; })
                  )
                : 0,

            pos:
              node.elements.length > 0
                ? 1 + Math.max.apply(null, pluck(depths, "pos"))
                : 1
          };
        },

      labeled:      computeFromExpression({ result: 0, pos: 0 }),
      simple_and:   computeFromExpression({ result: 0, pos: 1 }),
      simple_not:   computeFromExpression({ result: 0, pos: 1 }),
      semantic_and: computeLeaf,
      semantic_not: computeLeaf,
      optional:     computeFromExpression({ result: 0, pos: 0 }),
      zero_or_more: computeFromExpression({ result: 1, pos: 0 }),
      one_or_more:  computeFromExpression({ result: 1, pos: 0 }),
      action:       computeFromExpression({ result: 0, pos: 1 }),
      rule_ref:     computeLeaf,
      literal:      computeLeaf,
      any:          computeLeaf,
      "class":      computeLeaf
    });

    compute(ast, { result: 0, pos: 0 });
  },

  /*
   * This pass walks through the AST and tracks what labels are visible at each
   * point. For "action", "semantic_and" and "semantic_or" nodes it computes
   * parameter names and values for the function used in generated code. (In the
   * emitter, user's code is wrapped into a function that is immediately
   * executed. Its parameter names correspond to visible labels and its
   * parameter values to their captured values). Implicitly, this pass defines
   * scoping rules for labels.
   *
   * After running this pass, all "action", "semantic_and" and "semantic_or"
   * nodes will have a |params| property containing an object mapping parameter
   * names to the expressions that will be used as their values.
   */
  computeParams: function(ast) {
    var envs = [];

    function scoped(f) {
      envs.push({});
      f();
      envs.pop();
    }

    function nop() {}

    function computeForScopedExpression(node) {
      scoped(function() { compute(node.expression); });
    }

    function computeParams(node) {
      var env = envs[envs.length - 1], params = {}, name;

      for (name in env) {
        params[name] = env[name];
      }
      node.params = params;
    }

    var compute = buildNodeVisitor({
      grammar:
        function(node) {
          each(node.rules, compute);
        },

      rule:         computeForScopedExpression,

      choice:
        function(node) {
          scoped(function() { each(node.alternatives, compute); });
        },

      sequence:
        function(node) {
          var env = envs[envs.length - 1], name;

          function fixup(name) {
            each(pluck(node.elements, "resultVar"), function(resultVar, i) {
              if ((new RegExp("^" + resultVar + "(\\[\\d+\\])*$")).test(env[name])) {
                env[name] = node.resultVar + "[" + i + "]"
                          + env[name].substr(resultVar.length);
              }
            });
          }

          each(node.elements, compute);

          for (name in env) {
            fixup(name);
          }
        },

      labeled:
        function(node) {
          envs[envs.length - 1][node.label] = node.resultVar;

          scoped(function() { compute(node.expression); });
        },

      simple_and:   computeForScopedExpression,
      simple_not:   computeForScopedExpression,
      semantic_and: computeParams,
      semantic_not: computeParams,
      optional:     computeForScopedExpression,
      zero_or_more: computeForScopedExpression,
      one_or_more:  computeForScopedExpression,

      action:
        function(node) {
          scoped(function() {
            compute(node.expression);
            computeParams(node);
          });
        },

      rule_ref:     nop,
      literal:      nop,
      any:          nop,
      "class":      nop
    });

    compute(ast);
  }
};
/* Emits the generated code for the AST. */
PEG.compiler.emitter = function(ast, options) {
  options = options || {};
  if (options.cache === undefined) {
    options.cache = false;
  }
  if (options.trackLineAndColumn === undefined) {
    options.trackLineAndColumn = false;
  }

  /*
   * Codie 1.1.0
   *
   * https://github.com/dmajda/codie
   *
   * Copyright (c) 2011-2012 David Majda
   * Licensend under the MIT license.
   */
  var Codie = (function(undefined) {

  function stringEscape(s) {
    function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
    return s
      .replace(/\\/g,   '\\\\') // backslash
      .replace(/"/g,    '\\"')  // closing double quote
      .replace(/\x08/g, '\\b')  // backspace
      .replace(/\t/g,   '\\t')  // horizontal tab
      .replace(/\n/g,   '\\n')  // line feed
      .replace(/\f/g,   '\\f')  // form feed
      .replace(/\r/g,   '\\r')  // carriage return
      .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
      .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
      .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
  }

  function push(s) { return '__p.push(' + s + ');'; }

  function pushRaw(template, length, state) {
    function unindent(code, level, unindentFirst) {
      return code.replace(
        new RegExp('^.{' + level +'}', "gm"),
        function(str, offset) {
          if (offset === 0) {
            return unindentFirst ? '' : str;
          } else {
            return "";
          }
        }
      );
    }

    var escaped = stringEscape(unindent(
          template.substring(0, length),
          state.indentLevel(),
          state.atBOL
        ));

    return escaped.length > 0 ? push('"' + escaped + '"') : '';
  }


  var Codie = {
    /* Codie version (uses semantic versioning). */
    VERSION: "1.1.0",

    /*
     * Specifies by how many characters do #if/#else and #for unindent their
     * content in the generated code.
     */
    indentStep: 2,

    /* Description of #-commands. Extend to define your own commands. */
    commands: {
      "if":   {
        params:  /^(.*)$/,
        compile: function(state, prefix, params) {
          return ['if(' + params[0] + '){', []];
        },
        stackOp: "push"
      },
      "else": {
        params:  /^$/,
        compile: function(state) {
          var stack = state.commandStack,
              insideElse = stack[stack.length - 1] === "else",
              insideIf   = stack[stack.length - 1] === "if";

          if (insideElse) { throw new Error("Multiple #elses."); }
          if (!insideIf)  { throw new Error("Using #else outside of #if."); }

          return ['}else{', []];
        },
        stackOp: "replace"
      },
      "for":  {
        params:  /^([a-zA-Z_][a-zA-Z0-9_]*)[ \t]+in[ \t]+(.*)$/,
        init:    function(state) {
          state.forCurrLevel = 0;  // current level of #for loop nesting
          state.forMaxLevel  = 0;  // maximum level of #for loop nesting
        },
        compile: function(state, prefix, params) {
          var c = '__c' + state.forCurrLevel, // __c for "collection"
              l = '__l' + state.forCurrLevel, // __l for "length"
              i = '__i' + state.forCurrLevel; // __i for "index"

          state.forCurrLevel++;
          if (state.forMaxLevel < state.forCurrLevel) {
            state.forMaxLevel = state.forCurrLevel;
          }

          return [
            c + '=' + params[1] + ';'
              + l + '=' + c + '.length;'
              + 'for(' + i + '=0;' + i + '<' + l + ';' + i + '++){'
              + params[0] + '=' + c + '[' + i + '];',
            [params[0], c, l, i]
          ];
        },
        exit:    function(state) { state.forCurrLevel--; },
        stackOp: "push"
      },
      "end":  {
        params:  /^$/,
        compile: function(state) {
          var stack = state.commandStack, exit;

          if (stack.length === 0) { throw new Error("Too many #ends."); }

          exit = Codie.commands[stack[stack.length - 1]].exit;
          if (exit) { exit(state); }

          return ['}', []];
        },
        stackOp: "pop"
      },
      "block": {
        params: /^(.*)$/,
        compile: function(state, prefix, params) {
          var x = '__x', // __x for "prefix",
              n = '__n', // __n for "lines"
              l = '__l', // __l for "length"
              i = '__i'; // __i for "index"

          /*
           * Originally, the generated code used |String.prototype.replace|, but
           * it is buggy in certain versions of V8 so it was rewritten. See the
           * tests for details.
           */
          return [
            x + '="' + stringEscape(prefix.substring(state.indentLevel())) + '";'
              + n + '=(' + params[0] + ').toString().split("\\n");'
              + l + '=' + n + '.length;'
              + 'for(' + i + '=0;' + i + '<' + l + ';' + i + '++){'
              + n + '[' + i +']=' + x + '+' + n + '[' + i + ']+"\\n";'
              + '}'
              + push(n + '.join("")'),
            [x, n, l, i]
          ];
        },
        stackOp: "nop"
      }
    },

    /*
     * Compiles a template into a function. When called, this function will
     * execute the template in the context of an object passed in a parameter and
     * return the result.
     */
    template: function(template) {
      var stackOps = {
        push:    function(stack, name) { stack.push(name); },
        replace: function(stack, name) { stack[stack.length - 1] = name; },
        pop:     function(stack)       { stack.pop(); },
        nop:     function()            { }
      };

      function compileExpr(state, expr) {
        state.atBOL = false;
        return [push(expr), []];
      }

      function compileCommand(state, prefix, name, params) {
        var command, match, result;

        command = Codie.commands[name];
        if (!command) { throw new Error("Unknown command: #" + name + "."); }

        match = command.params.exec(params);
        if (match === null) {
          throw new Error(
            "Invalid params for command #" + name + ": " + params + "."
          );
        }

        result = command.compile(state, prefix, match.slice(1));
        stackOps[command.stackOp](state.commandStack, name);
        state.atBOL = true;
        return result;
      }

      var state = {               // compilation state
            commandStack: [],     //   stack of commands as they were nested
            atBOL:        true,   //   is the next character to process at BOL?
            indentLevel:  function() {
              return Codie.indentStep * this.commandStack.length;
            }
          },
          code = '',              // generated template function code
          vars = ['__p=[]'],      // variables used by generated code
          name, match, result, i;

      /* Initialize state. */
      for (name in Codie.commands) {
        if (Codie.commands[name].init) { Codie.commands[name].init(state); }
      }

      /* Compile the template. */
      while ((match = /^([ \t]*)#([a-zA-Z_][a-zA-Z0-9_]*)(?:[ \t]+([^ \t\n][^\n]*))?[ \t]*(?:\n|$)|#\{([^}]*)\}/m.exec(template)) !== null) {
        code += pushRaw(template, match.index, state);
        result = match[2] !== undefined && match[2] !== ""
          ? compileCommand(state, match[1], match[2], match[3] || "") // #-command
          : compileExpr(state, match[4]);                             // #{...}
        code += result[0];
        vars = vars.concat(result[1]);
        template = template.substring(match.index + match[0].length);
      }
      code += pushRaw(template, template.length, state);

      /* Check the final state. */
      if (state.commandStack.length > 0) { throw new Error("Missing #end."); }

      /* Sanitize the list of variables used by commands. */
      vars.sort();
      for (i = 0; i < vars.length; i++) {
        if (vars[i] === vars[i - 1]) { vars.splice(i--, 1); }
      }

      /* Create the resulting function. */
      return new Function("__v", [
        '__v=__v||{};',
        'var ' + vars.join(',') + ';',
        'with(__v){',
        code,
        'return __p.join("").replace(/^\\n+|\\n+$/g,"");};'
      ].join(''));
    }
  };

  return Codie;

  })();

  var templates = (function() {
    var name,
        templates = {},
        sources = {
          grammar: [
            '(function(){',
            '  /*',
            '   * Generated by PEG.js 0.7.0.',
            '   *',
            '   * http://pegjs.majda.cz/',
            '   */',
            '  ',
            /* This needs to be in sync with |quote| in utils.js. */
            '  function quote(s) {',
            '    /*',
            '     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a',
            '     * string literal except for the closing quote character, backslash,',
            '     * carriage return, line separator, paragraph separator, and line feed.',
            '     * Any character may appear in the form of an escape sequence.',
            '     *',
            '     * For portability, we also escape escape all control and non-ASCII',
            '     * characters. Note that "\\0" and "\\v" escape sequences are not used',
            '     * because JSHint does not like the first and IE the second.',
            '     */',
            '     return \'"\' + s',
            '      .replace(/\\\\/g, \'\\\\\\\\\')  // backslash',
            '      .replace(/"/g, \'\\\\"\')    // closing quote character',
            '      .replace(/\\x08/g, \'\\\\b\') // backspace',
            '      .replace(/\\t/g, \'\\\\t\')   // horizontal tab',
            '      .replace(/\\n/g, \'\\\\n\')   // line feed',
            '      .replace(/\\f/g, \'\\\\f\')   // form feed',
            '      .replace(/\\r/g, \'\\\\r\')   // carriage return',
            '      .replace(/[\\x00-\\x07\\x0B\\x0E-\\x1F\\x80-\\uFFFF]/g, escape)',
            '      + \'"\';',
            '  }',
            '  ',
            '  var result = {',
            '    /*',
            '     * Parses the input with a generated parser. If the parsing is successfull,',
            '     * returns a value explicitly or implicitly specified by the grammar from',
            '     * which the parser was generated (see |PEG.buildParser|). If the parsing is',
            '     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.',
            '     */',
            '    parse: function(input, startRule) {',
            '      var parseFunctions = {',
            '        #for rule in node.rules',
            '          #{string(rule.name) + ": parse_" + rule.name + (rule !== node.rules[node.rules.length - 1] ? "," : "")}',
            '        #end',
            '      };',
            '      ',
            '      if (startRule !== undefined) {',
            '        if (parseFunctions[startRule] === undefined) {',
            '          throw new Error("Invalid rule name: " + quote(startRule) + ".");',
            '        }',
            '      } else {',
            '        startRule = #{string(node.startRule)};',
            '      }',
            '      ',
            '      #{posInit("pos")};',
            '      var reportFailures = 0;', // 0 = report, anything > 0 = do not report
            '      #{posInit("rightmostFailuresPos")};',
            '      var rightmostFailuresExpected = [];',
            '      #if options.cache',
            '        var cache = {};',
            '      #end',
            '      ',
            /* This needs to be in sync with |padLeft| in utils.js. */
            '      function padLeft(input, padding, length) {',
            '        var result = input;',
            '        ',
            '        var padLength = length - input.length;',
            '        for (var i = 0; i < padLength; i++) {',
            '          result = padding + result;',
            '        }',
            '        ',
            '        return result;',
            '      }',
            '      ',
            /* This needs to be in sync with |escape| in utils.js. */
            '      function escape(ch) {',
            '        var charCode = ch.charCodeAt(0);',
            '        var escapeChar;',
            '        var length;',
            '        ',
            '        if (charCode <= 0xFF) {',
            '          escapeChar = \'x\';',
            '          length = 2;',
            '        } else {',
            '          escapeChar = \'u\';',
            '          length = 4;',
            '        }',
            '        ',
            '        return \'\\\\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), \'0\', length);',
            '      }',
            '      ',
            '      #if options.trackLineAndColumn',
            '        function clone(object) {',
            '          var result = {};',
            '          for (var key in object) {',
            '            result[key] = object[key];',
            '          }',
            '          return result;',
            '        }',
            '        ',
            '        function advance(pos, n) {',
            '          var endOffset = pos.offset + n;',
            '          ',
            '          for (var offset = pos.offset; offset < endOffset; offset++) {',
            '            var ch = input.charAt(offset);',
            '            if (ch === "\\n") {',
            '              if (!pos.seenCR) { pos.line++; }',
            '              pos.column = 1;',
            '              pos.seenCR = false;',
            '            } else if (ch === "\\r" || ch === "\\u2028" || ch === "\\u2029") {',
            '              pos.line++;',
            '              pos.column = 1;',
            '              pos.seenCR = true;',
            '            } else {',
            '              pos.column++;',
            '              pos.seenCR = false;',
            '            }',
            '          }',
            '          ',
            '          pos.offset += n;',
            '        }',
            '        ',
            '      #end',
            '      function matchFailed(failure) {',
            '        if (#{posOffset("pos")} < #{posOffset("rightmostFailuresPos")}) {',
            '          return;',
            '        }',
            '        ',
            '        if (#{posOffset("pos")} > #{posOffset("rightmostFailuresPos")}) {',
            '          rightmostFailuresPos = #{posClone("pos")};',
            '          rightmostFailuresExpected = [];',
            '        }',
            '        ',
            '        rightmostFailuresExpected.push(failure);',
            '      }',
            '      ',
            '      #for rule in node.rules',
            '        #block emit(rule)',
            '        ',
            '      #end',
            '      ',
            '      function cleanupExpected(expected) {',
            '        expected.sort();',
            '        ',
            '        var lastExpected = null;',
            '        var cleanExpected = [];',
            '        for (var i = 0; i < expected.length; i++) {',
            '          if (expected[i] !== lastExpected) {',
            '            cleanExpected.push(expected[i]);',
            '            lastExpected = expected[i];',
            '          }',
            '        }',
            '        return cleanExpected;',
            '      }',
            '      ',
            '      #if !options.trackLineAndColumn',
            '        function computeErrorPosition() {',
            '          /*',
            '           * The first idea was to use |String.split| to break the input up to the',
            '           * error position along newlines and derive the line and column from',
            '           * there. However IE\'s |split| implementation is so broken that it was',
            '           * enough to prevent it.',
            '           */',
            '          ',
            '          var line = 1;',
            '          var column = 1;',
            '          var seenCR = false;',
            '          ',
            '          for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {',
            '            var ch = input.charAt(i);',
            '            if (ch === "\\n") {',
            '              if (!seenCR) { line++; }',
            '              column = 1;',
            '              seenCR = false;',
            '            } else if (ch === "\\r" || ch === "\\u2028" || ch === "\\u2029") {',
            '              line++;',
            '              column = 1;',
            '              seenCR = true;',
            '            } else {',
            '              column++;',
            '              seenCR = false;',
            '            }',
            '          }',
            '          ',
            '          return { line: line, column: column };',
            '        }',
            '      #end',
            '      ',
            '      #if node.initializer',
            '        #block emit(node.initializer)',
            '      #end',
            '      ',
            '      var result = parseFunctions[startRule]();',
            '      ',
            '      /*',
            '       * The parser is now in one of the following three states:',
            '       *',
            '       * 1. The parser successfully parsed the whole input.',
            '       *',
            '       *    - |result !== null|',
            '       *    - |#{posOffset("pos")} === input.length|',
            '       *    - |rightmostFailuresExpected| may or may not contain something',
            '       *',
            '       * 2. The parser successfully parsed only a part of the input.',
            '       *',
            '       *    - |result !== null|',
            '       *    - |#{posOffset("pos")} < input.length|',
            '       *    - |rightmostFailuresExpected| may or may not contain something',
            '       *',
            '       * 3. The parser did not successfully parse any part of the input.',
            '       *',
            '       *   - |result === null|',
            '       *   - |#{posOffset("pos")} === 0|',
            '       *   - |rightmostFailuresExpected| contains at least one failure',
            '       *',
            '       * All code following this comment (including called functions) must',
            '       * handle these states.',
            '       */',
            '      if (result === null || #{posOffset("pos")} !== input.length) {',
            '        var offset = Math.max(#{posOffset("pos")}, #{posOffset("rightmostFailuresPos")});',
            '        var found = offset < input.length ? input.charAt(offset) : null;',
            '        #if options.trackLineAndColumn',
            '          var errorPosition = #{posOffset("pos")} > #{posOffset("rightmostFailuresPos")} ? pos : rightmostFailuresPos;',
            '        #else',
            '          var errorPosition = computeErrorPosition();',
            '        #end',
            '        ',
            '        throw new this.SyntaxError(',
            '          cleanupExpected(rightmostFailuresExpected),',
            '          found,',
            '          offset,',
            '          errorPosition.line,',
            '          errorPosition.column',
            '        );',
            '      }',
            '      ',
            '      return result;',
            '    },',
            '    ',
            '    /* Returns the parser source code. */',
            '    toSource: function() { return this._source; }',
            '  };',
            '  ',
            '  /* Thrown when a parser encounters a syntax error. */',
            '  ',
            '  result.SyntaxError = function(expected, found, offset, line, column) {',
            '    function buildMessage(expected, found) {',
            '      var expectedHumanized, foundHumanized;',
            '      ',
            '      switch (expected.length) {',
            '        case 0:',
            '          expectedHumanized = "end of input";',
            '          break;',
            '        case 1:',
            '          expectedHumanized = expected[0];',
            '          break;',
            '        default:',
            '          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")',
            '            + " or "',
            '            + expected[expected.length - 1];',
            '      }',
            '      ',
            '      foundHumanized = found ? quote(found) : "end of input";',
            '      ',
            '      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";',
            '    }',
            '    ',
            '    this.name = "SyntaxError";',
            '    this.expected = expected;',
            '    this.found = found;',
            '    this.message = buildMessage(expected, found);',
            '    this.offset = offset;',
            '    this.line = line;',
            '    this.column = column;',
            '  };',
            '  ',
            '  result.SyntaxError.prototype = Error.prototype;',
            '  ',
            '  return result;',
            '})()'
          ],
          rule: [
            'function parse_#{node.name}() {',
            '  #if options.cache',
            '    var cacheKey = "#{node.name}@" + #{posOffset("pos")};',
            '    var cachedResult = cache[cacheKey];',
            '    if (cachedResult) {',
            '      pos = #{posClone("cachedResult.nextPos")};',
            '      return cachedResult.result;',
            '    }',
            '    ',
            '  #end',
            '  #if node.resultVars.length > 0',
            '    var #{node.resultVars.join(", ")};',
            '  #end',
            '  #if node.posVars.length > 0',
            '    var #{node.posVars.join(", ")};',
            '  #end',
            '  ',
            '  #if node.displayName !== null',
            '    reportFailures++;',
            '  #end',
            '  #block emit(node.expression)',
            '  #if node.displayName !== null',
            '    reportFailures--;',
            '    if (reportFailures === 0 && #{node.resultVar} === null) {',
            '      matchFailed(#{string(node.displayName)});',
            '    }',
            '  #end',
            '  #if options.cache',
            '    ',
            '    cache[cacheKey] = {',
            '      nextPos: #{posClone("pos")},',
            '      result:  #{node.resultVar}',
            '    };',
            '  #end',
            '  return #{node.resultVar};',
            '}'
          ],
          choice: [
            '#block emit(alternative)',
            '#block nextAlternativesCode'
          ],
          "choice.next": [
            'if (#{node.resultVar} === null) {',
            '  #block code',
            '}'
          ],
          sequence: [
            '#{posSave(node)};',
            '#block code'
          ],
          "sequence.iteration": [
            '#block emit(element)',
            'if (#{element.resultVar} !== null) {',
            '  #block code',
            '} else {',
            '  #{node.resultVar} = null;',
            '  #{posRestore(node)};',
            '}'
          ],
          "sequence.inner": [
            '#{node.resultVar} = [#{pluck(node.elements, "resultVar").join(", ")}];'
          ],
          simple_and: [
            '#{posSave(node)};',
            'reportFailures++;',
            '#block emit(node.expression)',
            'reportFailures--;',
            'if (#{node.resultVar} !== null) {',
            '  #{node.resultVar} = "";',
            '  #{posRestore(node)};',
            '} else {',
            '  #{node.resultVar} = null;',
            '}'
          ],
          simple_not: [
            '#{posSave(node)};',
            'reportFailures++;',
            '#block emit(node.expression)',
            'reportFailures--;',
            'if (#{node.resultVar} === null) {',
            '  #{node.resultVar} = "";',
            '} else {',
            '  #{node.resultVar} = null;',
            '  #{posRestore(node)};',
            '}'
          ],
          semantic_and: [
            '#{node.resultVar} = (function(#{(options.trackLineAndColumn ? ["offset", "line", "column"] : ["offset"]).concat(keys(node.params)).join(", ")}) {#{node.code}})(#{(options.trackLineAndColumn ? ["pos.offset", "pos.line", "pos.column"] : ["pos"]).concat(values(node.params)).join(", ")}) ? "" : null;'
          ],
          semantic_not: [
            '#{node.resultVar} = (function(#{(options.trackLineAndColumn ? ["offset", "line", "column"] : ["offset"]).concat(keys(node.params)).join(", ")}) {#{node.code}})(#{(options.trackLineAndColumn ? ["pos.offset", "pos.line", "pos.column"] : ["pos"]).concat(values(node.params)).join(", ")}) ? null : "";'
          ],
          optional: [
            '#block emit(node.expression)',
            '#{node.resultVar} = #{node.resultVar} !== null ? #{node.resultVar} : "";'
          ],
          zero_or_more: [
            '#{node.resultVar} = [];',
            '#block emit(node.expression)',
            'while (#{node.expression.resultVar} !== null) {',
            '  #{node.resultVar}.push(#{node.expression.resultVar});',
            '  #block emit(node.expression)',
            '}'
          ],
          one_or_more: [
            '#block emit(node.expression)',
            'if (#{node.expression.resultVar} !== null) {',
            '  #{node.resultVar} = [];',
            '  while (#{node.expression.resultVar} !== null) {',
            '    #{node.resultVar}.push(#{node.expression.resultVar});',
            '    #block emit(node.expression)',
            '  }',
            '} else {',
            '  #{node.resultVar} = null;',
            '}'
          ],
          action: [
            '#{posSave(node)};',
            '#block emit(node.expression)',
            'if (#{node.resultVar} !== null) {',
            '  #{node.resultVar} = (function(#{(options.trackLineAndColumn ? ["offset", "line", "column"] : ["offset"]).concat(keys(node.params)).join(", ")}) {#{node.code}})(#{(options.trackLineAndColumn ? [node.posVar + ".offset", node.posVar + ".line", node.posVar + ".column"] : [node.posVar]).concat(values(node.params)).join(", ")});',
            '}',
            'if (#{node.resultVar} === null) {',
            '  #{posRestore(node)};',
            '}'
          ],
          rule_ref: [
            '#{node.resultVar} = parse_#{node.name}();'
          ],
          literal: [
            '#if node.value.length === 0',
            '  #{node.resultVar} = "";',
            '#else',
            '  #if !node.ignoreCase',
            '    #if node.value.length === 1',
            '      if (input.charCodeAt(#{posOffset("pos")}) === #{node.value.charCodeAt(0)}) {',
            '    #else',
            '      if (input.substr(#{posOffset("pos")}, #{node.value.length}) === #{string(node.value)}) {',
            '    #end',
            '  #else',
            /*
             * One-char literals are not optimized when case-insensitive
             * matching is enabled. This is because there is no simple way to
             * lowercase a character code that works for character outside ASCII
             * letters. Moreover, |toLowerCase| can change string length,
             * meaning the result of lowercasing a character can be more
             * characters.
             */
            '    if (input.substr(#{posOffset("pos")}, #{node.value.length}).toLowerCase() === #{string(node.value.toLowerCase())}) {',
            '  #end',
            '    #if !node.ignoreCase',
            '      #{node.resultVar} = #{string(node.value)};',
            '    #else',
            '      #{node.resultVar} = input.substr(#{posOffset("pos")}, #{node.value.length});',
            '    #end',
            '    #{posAdvance(node.value.length)};',
            '  } else {',
            '    #{node.resultVar} = null;',
            '    if (reportFailures === 0) {',
            '      matchFailed(#{string(string(node.value))});',
            '    }',
            '  }',
            '#end'
          ],
          any: [
            'if (input.length > #{posOffset("pos")}) {',
            '  #{node.resultVar} = input.charAt(#{posOffset("pos")});',
            '  #{posAdvance(1)};',
            '} else {',
            '  #{node.resultVar} = null;',
            '  if (reportFailures === 0) {',
            '    matchFailed("any character");',
            '  }',
            '}'
          ],
          "class": [
            'if (#{regexp}.test(input.charAt(#{posOffset("pos")}))) {',
            '  #{node.resultVar} = input.charAt(#{posOffset("pos")});',
            '  #{posAdvance(1)};',
            '} else {',
            '  #{node.resultVar} = null;',
            '  if (reportFailures === 0) {',
            '    matchFailed(#{string(node.rawText)});',
            '  }',
            '}'
          ]
        };

    for (name in sources) {
      templates[name] = Codie.template(sources[name].join('\n'));
    }

    return templates;
  })();

  function fill(name, vars) {
    vars.string  = quote;
    vars.pluck   = pluck;
    vars.keys    = keys;
    vars.values  = values;
    vars.emit    = emit;
    vars.options = options;

    /* Position-handling macros */
    if (options.trackLineAndColumn) {
      vars.posInit    = function(name) {
        return "var "
             + name
             + " = "
             + "{ offset: 0, line: 1, column: 1, seenCR: false }";
      };
      vars.posClone   = function(name) { return "clone(" + name + ")"; };
      vars.posOffset  = function(name) { return name + ".offset"; };

      vars.posAdvance = function(n)    { return "advance(pos, " + n + ")"; };
    } else {
      vars.posInit    = function(name) { return "var " + name + " = 0"; };
      vars.posClone   = function(name) { return name; };
      vars.posOffset  = function(name) { return name; };

      vars.posAdvance = function(n) {
        return n === 1 ? "pos++" : "pos += " + n;
      };
    }
    vars.posSave    = function(node) {
      return node.posVar + " = " + vars.posClone("pos");
    };
    vars.posRestore = function(node) {
      return "pos" + " = " + vars.posClone(node.posVar);
    };

    return templates[name](vars);
  }

  function emitSimple(name) {
    return function(node) { return fill(name, { node: node }); };
  }

  var emit = buildNodeVisitor({
    grammar: emitSimple("grammar"),

    initializer: function(node) { return node.code; },

    rule: emitSimple("rule"),

    /*
     * The contract for all code fragments generated by the following functions
     * is as follows.
     *
     * The code fragment tries to match a part of the input starting with the
     * position indicated in |pos|. That position may point past the end of the
     * input.
     *
     * * If the code fragment matches the input, it advances |pos| to point to
     *   the first chracter following the matched part of the input and sets
     *   variable with a name stored in |node.resultVar| to an appropriate
     *   value. This value is always non-|null|.
     *
     * * If the code fragment does not match the input, it returns with |pos|
     *   set to the original value and it sets a variable with a name stored in
     *   |node.resultVar| to |null|.
     *
     * The code can use variables with names stored in |resultVar| and |posVar|
     * properties of the current node's subnodes. It can't use any other
     * variables.
     */

    choice: function(node) {
      var code, nextAlternativesCode;

      for (var i = node.alternatives.length - 1; i >= 0; i--) {
        nextAlternativesCode = i !== node.alternatives.length - 1
          ? fill("choice.next", { node: node, code: code })
          : '';
        code = fill("choice", {
          alternative:          node.alternatives[i],
          nextAlternativesCode: nextAlternativesCode
        });
      }

      return code;
    },

    sequence: function(node) {
      var code = fill("sequence.inner", { node: node });

      for (var i = node.elements.length - 1; i >= 0; i--) {
        code = fill("sequence.iteration", {
          node:    node,
          element: node.elements[i],
          code:    code
        });
      }

      return fill("sequence", { node: node, code: code });
    },

    labeled: function(node) { return emit(node.expression); },

    simple_and:   emitSimple("simple_and"),
    simple_not:   emitSimple("simple_not"),
    semantic_and: emitSimple("semantic_and"),
    semantic_not: emitSimple("semantic_not"),
    optional:     emitSimple("optional"),
    zero_or_more: emitSimple("zero_or_more"),
    one_or_more:  emitSimple("one_or_more"),
    action:       emitSimple("action"),
    rule_ref:     emitSimple("rule_ref"),
    literal:      emitSimple("literal"),
    any:          emitSimple("any"),

    "class": function(node) {
      var regexp;

      if (node.parts.length > 0) {
        regexp = '/^['
          + (node.inverted ? '^' : '')
          + map(node.parts, function(part) {
              return part instanceof Array
                ? quoteForRegexpClass(part[0])
                  + '-'
                  + quoteForRegexpClass(part[1])
                : quoteForRegexpClass(part);
            }).join('')
          + ']/' + (node.ignoreCase ? 'i' : '');
      } else {
        /*
         * Stupid IE considers regexps /[]/ and /[^]/ syntactically invalid, so
         * we translate them into euqivalents it can handle.
         */
        regexp = node.inverted ? '/^[\\S\\s]/' : '/^(?!)/';
      }

      return fill("class", { node: node, regexp: regexp });
    }
  });

  return emit(ast);
};

return PEG;

})();

if (typeof module !== "undefined") {
  module.exports = PEG;
}

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/index.js":[function(require,module,exports){
(function (process){
var EventEmitter = require('events').EventEmitter;
var Hash = require('hashish');
var Chainsaw = require('chainsaw');

module.exports = Seq;
function Seq (xs) {
    if (xs && !Array.isArray(xs) || arguments.length > 1) {
        throw new Error('Optional argument to Seq() is exactly one Array');
    }
    
    var ch = Chainsaw(function (saw) {
        builder.call(this, saw, xs || []);
    });
    
    process.nextTick(function () {
        ch['catch'](function (err) {
            console.error(err.stack ? err.stack : err)
        });
    });
    return ch;
}

Seq.ap = Seq; // for compatability with versions <0.3

function builder (saw, xs) {
    var context = {
        vars : {},
        args : {},
        stack : xs,
        error : null
    };
    context.stack_ = context.stack;
    
    function action (step, key, f, g) {
        var cb = function (err) {
            var args = [].slice.call(arguments, 1);
            if (err) {
                context.error = { message : err, key : key };
                saw.jump(lastPar);
                saw.down('catch');
                g();
            }
            else {
                if (typeof key == 'number') {
                    context.stack_[key] = args[0];
                    context.args[key] = args;
                }
                else {
                    context.stack_.push.apply(context.stack_, args);
                    if (key !== undefined) {
                        context.vars[key] = args[0];
                        context.args[key] = args;
                    }
                }
                if (g) g(args, key);
            }
        };
        Hash(context).forEach(function (v,k) { cb[k] = v });
        
        cb.into = function (k) {
            key = k;
            return cb;
        };
        
        cb.next = function (err, xs) {
            context.stack_.push.apply(context.stack_, xs);
            cb.apply(cb, [err].concat(context.stack));
        };
        
        cb.pass = function (err) {
            cb.apply(cb, [err].concat(context.stack));
        };
        
        cb.ok = cb.bind(cb, null);
        
        f.apply(cb, context.stack);
    }
    
    var running = 0;
    var errors = 0;
    
    this.seq = function (key, cb) {
        var bound = [].slice.call(arguments, 2);
        
        if (typeof key === 'function') {
            if (arguments.length > 1) bound.unshift(cb);
            cb = key;
            key = undefined;
        }
        
        if (context.error) saw.next()
        else if (running === 0) {
            action(saw.step, key,
                function () {
                    context.stack_ = [];
                    var args = [].slice.call(arguments);
                    args.unshift.apply(args, bound.map(function (arg) {
                        return arg === Seq ? this : arg
                    }, this));
                    
                    cb.apply(this, args);
                }, function () {
                    context.stack = context.stack_;
                    saw.next()
                }
            );
        }
    };
    
    var lastPar = null;
    this.par = function (key, cb) {
        lastPar = saw.step;
        
        if (running == 0) {
            // empty the active stack for the first par() in a chain
            context.stack_ = [];
        }
        
        var bound = [].slice.call(arguments, 2);
        if (typeof key === 'function') {
            if (arguments.length > 1) bound.unshift(cb);
            cb = key;
            key = context.stack_.length;
            context.stack_.push(null);
        }
        var cb_ = function () {
            var args = [].slice.call(arguments);
            args.unshift.apply(args, bound.map(function (arg) {
                return arg === Seq ? this : arg
            }, this));
            
            cb.apply(this, args);
        };
        
        running ++;
        
        var step = saw.step;
        process.nextTick(function () {
            action(step, key, cb_, function (args) {
                if (!args) errors ++;
                
                running --;
                if (running == 0) {
                    context.stack = context.stack_.slice();
                    saw.step = lastPar;
                    if (errors > 0) saw.down('catch');
                    errors = 0;
                    saw.next();
                }
            });
        });
        saw.next();
    };
    
    [ 'seq', 'par' ].forEach(function (name) {
        this[name + '_'] = function (key) {
            var args = [].slice.call(arguments);
            
            var cb = typeof key === 'function'
                ? args[0] : args[1];
            
            var fn = function () {
                var argv = [].slice.call(arguments);
                argv.unshift(this);
                cb.apply(this, argv);
            };
            
            if (typeof key === 'function') {
                args[0] = fn;
            }
            else {
                args[1] = fn;
            }
            
            this[name].apply(this, args);
        };
    }, this);
    
    this['catch'] = function (cb) {
        if (context.error) {
            cb.call(context, context.error.message, context.error.key);
            context.error = null;
        }
        saw.next();
    };
    
    this.forEach = function (cb) {
        this.seq(function () {
            context.stack_ = context.stack.slice();
            var end = context.stack.length;
            
            if (end === 0) this(null)
            else context.stack.forEach(function (x, i) {
                action(saw.step, i, function () {
                    cb.call(this, x, i);
                    if (i == end - 1) saw.next();
                });
            });
        });
    };
    
    this.seqEach = function (cb) {
        this.seq(function () {
            context.stack_ = context.stack.slice();
            var xs = context.stack.slice();
            if (xs.length === 0) this(null);
            else (function next (i) {
                action(
                    saw.step, i,
                    function () { cb.call(this, xs[i], i) },
                    function (args) {
                        if (!args || i === xs.length - 1) saw.next();
                        else next(i + 1);
                    }
                );
            }).bind(this)(0);
        });
    };
    
    this.parEach = function (limit, cb) {
        var xs = context.stack.slice();
        if (cb === undefined) { cb = limit; limit = xs.length }
        context.stack_ = [];
        
        var active = 0;
        var finished = 0;
        var queue = [];
        
        if (xs.length === 0) saw.next()
        else xs.forEach(function call (x, i) {
            if (active >= limit) {
                queue.push(call.bind(this, x, i));
            }
            else {
                active ++;
                action(saw.step, i,
                    function () {
                        cb.call(this, x, i);
                    },
                    function () {
                        active --;
                        finished ++;
                        if (queue.length > 0) queue.shift()();
                        else if (finished === xs.length) {
                            saw.next();
                        }
                    }
                );
            }
        });
    };
    
    this.parMap = function (limit, cb) {
        var res = [];
        var len = context.stack.length;
        if (cb === undefined) { cb = limit; limit = len }
        var res = [];
        
        Seq()
            .extend(context.stack)
            .parEach(limit, function (x, i) {
                var self = this;
                
                var next = function () {
                    res[i] = arguments[1];
                    self.apply(self, arguments);
                };
                
                next.stack = self.stack;
                next.stack_ = self.stack_;
                next.vars = self.vars;
                next.args = self.args;
                next.error = self.error;
                
                next.into = function (key) {
                    return function () {
                        res[key] = arguments[1];
                        self.apply(self, arguments);
                    };
                };
                
                next.ok = function () {
                    var args = [].slice.call(arguments);
                    args.unshift(null);
                    return next.apply(next, args);
                };
                
                cb.apply(next, arguments);
            })
            .seq(function () {
                context.stack = res;
                saw.next();
            })
        ;
    };
    
    this.seqMap = function (cb) {
        var res = [];
        var lastIdx = context.stack.length - 1;
        
        this.seqEach(function (x, i) {
            var self = this;
            
            var next = function () {
                res[i] = arguments[1];
                if (i === lastIdx)
                    context.stack = res;
                self.apply(self, arguments);
            };
            
            next.stack = self.stack;
            next.stack_ = self.stack_;
            next.vars = self.vars;
            next.args = self.args;
            next.error = self.error;
            
            next.into = function (key) {
                return function () {
                    res[key] = arguments[1];
                    if (i === lastIdx)
                        context.stack = res;
                    self.apply(self, arguments);
                };
            };
            
            next.ok = function () {
                var args = [].slice.call(arguments);
                args.unshift(null);
                return next.apply(next, args);
            };
            
            cb.apply(next, arguments);
        });
    };
    
    /**
     * Consumes any errors that occur in `cb`. Calls to `this.into(i)` will place
     * that value, if accepted by the filter, at the index in the results as
     * if it were the i-th index before filtering. (This means it will never 
     * override another value, and will only actually appear at i if the filter
     * accepts all values before i.)
     */
    this.parFilter = function (limit, cb) {
        var res = [];
        var len = context.stack.length;
        if (cb === undefined) { cb = limit; limit = len }
        var res = [];
        
        Seq()
            .extend(context.stack)
            .parEach(limit, function (x, i) {
                var self = this;
                
                var next = function (err, ok) {
                    if (!err && ok)
                        res.push([i, x]);
                    arguments[0] = null; // discard errors
                    self.apply(self, arguments);
                };
                
                next.stack = self.stack;
                next.stack_ = self.stack_;
                next.vars = self.vars;
                next.args = self.args;
                next.error = self.error;
                
                next.into = function (key) {
                    return function (err, ok) {
                        if (!err && ok)
                            res.push([key, x]);
                        arguments[0] = null; // discard errors
                        self.apply(self, arguments);
                    };
                };
                
                next.ok = function () {
                    var args = [].slice.call(arguments);
                    args.unshift(null);
                    return next.apply(next, args);
                };
                
                cb.apply(next, arguments);
            })
            .seq(function () {
                context.stack = res.sort().map(function(pair){ return pair[1]; });
                saw.next();
            })
        ;
    };
    
    /**
     * Consumes any errors that occur in `cb`. Calls to `this.into(i)` will place
     * that value, if accepted by the filter, at the index in the results as
     * if it were the i-th index before filtering. (This means it will never 
     * override another value, and will only actually appear at i if the filter
     * accepts all values before i.)
     */
    this.seqFilter = function (cb) {
        var res = [];
        var lastIdx = context.stack.length - 1;
        
        this.seqEach(function (x, i) {
            var self = this;
            
            var next = function (err, ok) {
                if (!err && ok)
                    res.push([i, x]);
                if (i === lastIdx)
                    context.stack = res.sort().map(function(pair){ return pair[1]; });
                arguments[0] = null; // discard errors
                self.apply(self, arguments);
            };
            
            next.stack = self.stack;
            next.stack_ = self.stack_;
            next.vars = self.vars;
            next.args = self.args;
            next.error = self.error;
            
            next.into = function (key) {
                return function (err, ok) {
                    if (!err && ok)
                        res.push([key, x]);
                    if (i === lastIdx)
                        context.stack = res.sort().map(function(pair){ return pair[1]; });
                    arguments[0] = null; // discard errors
                    self.apply(self, arguments);
                };
            };
            
            next.ok = function () {
                var args = [].slice.call(arguments);
                args.unshift(null);
                return next.apply(next, args);
            };
            
            cb.apply(next, arguments);
        });
    };
    
    [ 'forEach', 'seqEach', 'parEach', 'seqMap', 'parMap', 'seqFilter', 'parFilter' ]
        .forEach(function (name) {
            this[name + '_'] = function (cb) {
                this[name].call(this, function () {
                    var args = [].slice.call(arguments);
                    args.unshift(this);
                    cb.apply(this, args);
                });
            };
        }, this)
    ;
    
    ['push','pop','shift','unshift','splice','reverse']
        .forEach(function (name) {
            this[name] = function () {
                context.stack[name].apply(
                    context.stack,
                    [].slice.call(arguments)
                );
                saw.next();
                return this;
            };
        }, this)
    ;
    
    [ 'map', 'filter', 'reduce' ]
        .forEach(function (name) {
            this[name] = function () {
                var res = context.stack[name].apply(
                    context.stack,
                    [].slice.call(arguments)
                );
                // stack must be an array, or bad things happen
                context.stack = (Array.isArray(res) ? res : [res]);
                saw.next();
                return this;
            };
        }, this)
    ;
    
    this.extend = function (xs) {
        if (!Array.isArray(xs)) {
            throw new Error('argument to .extend() is not an Array');
        }
        context.stack.push.apply(context.stack, xs);
        saw.next();
    };
    
    this.flatten = function (pancake) {
        var xs = [];
        // should we fully flatten this array? (default: true)
        if (pancake === undefined) { pancake = true; }
        context.stack.forEach(function f (x) {
            if (Array.isArray(x) && pancake) x.forEach(f);
            else if (Array.isArray(x)) xs = xs.concat(x);
            else xs.push(x);
        });
        context.stack = xs;
        saw.next();
    };
    
    this.unflatten = function () {
        context.stack = [context.stack];
        saw.next();
    };
    
    this.empty = function () {
        context.stack = [];
        saw.next();
    };
    
    this.set = function (stack) {
        context.stack = stack;
        saw.next();
    };
    
    this['do'] = function (cb) {
        saw.nest(cb, context);
    };
}

}).call(this,require('_process'))

},{"_process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js","chainsaw":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/chainsaw/index.js","events":"/Users/Jacob/workspace/scheduler/front-end/node_modules/events/events.js","hashish":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/hashish/index.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/chainsaw/index.js":[function(require,module,exports){
(function (process){
var Traverse = require('traverse');
var EventEmitter = require('events').EventEmitter;

module.exports = Chainsaw;
function Chainsaw (builder) {
    var saw = Chainsaw.saw(builder, {});
    var r = builder.call(saw.handlers, saw);
    if (r !== undefined) saw.handlers = r;
    return saw.chain();
};

Chainsaw.saw = function (builder, handlers) {
    var saw = new EventEmitter;
    saw.handlers = handlers;
    saw.actions = [];
    saw.step = 0;
    
    saw.chain = function () {
        var ch = Traverse(saw.handlers).map(function (node) {
            if (this.isRoot) return node;
            var ps = this.path;
            
            if (typeof node === 'function') {
                this.update(function () {
                    saw.actions.push({
                        path : ps,
                        args : [].slice.call(arguments)
                    });
                    return ch;
                });
            }
        });
        
        process.nextTick(function () {
            saw.emit('begin');
            saw.next();
        });
        
        return ch;
    };
    
    saw.next = function () {
        var action = saw.actions[saw.step];
        saw.step ++;
        
        if (!action) {
            saw.emit('end');
        }
        else if (!action.trap) {
            var node = saw.handlers;
            action.path.forEach(function (key) { node = node[key] });
            node.apply(saw.handlers, action.args);
        }
    };
    
    saw.nest = function (cb) {
        var args = [].slice.call(arguments, 1);
        var autonext = true;
        
        if (typeof cb === 'boolean') {
            var autonext = cb;
            cb = args.shift();
        }
        
        var s = Chainsaw.saw(builder, {});
        var r = builder.call(s.handlers, s);
        
        if (r !== undefined) s.handlers = r;
        cb.apply(s.chain(), args);
        if (autonext !== false) s.on('end', saw.next);
    };
    
    saw.trap = function (name, cb) {
        var ps = Array.isArray(name) ? name : [name];
        saw.actions.push({
            path : ps,
            step : saw.step,
            cb : cb,
            trap : true
        });
    };
    
    saw.down = function (name) {
        var ps = (Array.isArray(name) ? name : [name]).join('/');
        var i = saw.actions.slice(saw.step).map(function (x) {
            if (x.trap && x.step <= saw.step) return false;
            return x.path.join('/') == ps;
        }).indexOf(true);
        
        if (i >= 0) saw.step += i;
        else saw.step = saw.actions.length;
        
        var act = saw.actions[saw.step - 1];
        if (act && act.trap) {
            // It's a trap!
            saw.step = act.step;
            act.cb();
        }
        else saw.next();
    };
    
    saw.jump = function (step) {
        saw.step = step;
        saw.next();
    };
    
    return saw;
}; 

}).call(this,require('_process'))

},{"_process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js","events":"/Users/Jacob/workspace/scheduler/front-end/node_modules/events/events.js","traverse":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/chainsaw/node_modules/traverse/index.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/chainsaw/node_modules/traverse/index.js":[function(require,module,exports){
module.exports = Traverse;
function Traverse (obj) {
    if (!(this instanceof Traverse)) return new Traverse(obj);
    this.value = obj;
}

Traverse.prototype.get = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key)) {
            node = undefined;
            break;
        }
        node = node[key];
    }
    return node;
};

Traverse.prototype.set = function (ps, value) {
    var node = this.value;
    for (var i = 0; i < ps.length - 1; i ++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key)) node[key] = {};
        node = node[key];
    }
    node[ps[i]] = value;
    return value;
};

Traverse.prototype.map = function (cb) {
    return walk(this.value, cb, true);
};

Traverse.prototype.forEach = function (cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
};

Traverse.prototype.reduce = function (cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function (x) {
        if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x);
        }
    });
    return acc;
};

Traverse.prototype.deepEqual = function (obj) {
    if (arguments.length !== 1) {
        throw new Error(
            'deepEqual requires exactly one object to compare against'
        );
    }
    
    var equal = true;
    var node = obj;
    
    this.forEach(function (y) {
        var notEqual = (function () {
            equal = false;
            //this.stop();
            return undefined;
        }).bind(this);
        
        //if (node === undefined || node === null) return notEqual();
        
        if (!this.isRoot) {
        /*
            if (!Object.hasOwnProperty.call(node, this.key)) {
                return notEqual();
            }
        */
            if (typeof node !== 'object') return notEqual();
            node = node[this.key];
        }
        
        var x = node;
        
        this.post(function () {
            node = x;
        });
        
        var toS = function (o) {
            return Object.prototype.toString.call(o);
        };
        
        if (this.circular) {
            if (Traverse(obj).get(this.circular.path) !== x) notEqual();
        }
        else if (typeof x !== typeof y) {
            notEqual();
        }
        else if (x === null || y === null || x === undefined || y === undefined) {
            if (x !== y) notEqual();
        }
        else if (x.__proto__ !== y.__proto__) {
            notEqual();
        }
        else if (x === y) {
            // nop
        }
        else if (typeof x === 'function') {
            if (x instanceof RegExp) {
                // both regexps on account of the __proto__ check
                if (x.toString() != y.toString()) notEqual();
            }
            else if (x !== y) notEqual();
        }
        else if (typeof x === 'object') {
            if (toS(y) === '[object Arguments]'
            || toS(x) === '[object Arguments]') {
                if (toS(x) !== toS(y)) {
                    notEqual();
                }
            }
            else if (x instanceof Date || y instanceof Date) {
                if (!(x instanceof Date) || !(y instanceof Date)
                || x.getTime() !== y.getTime()) {
                    notEqual();
                }
            }
            else {
                var kx = Object.keys(x);
                var ky = Object.keys(y);
                if (kx.length !== ky.length) return notEqual();
                for (var i = 0; i < kx.length; i++) {
                    var k = kx[i];
                    if (!Object.hasOwnProperty.call(y, k)) {
                        notEqual();
                    }
                }
            }
        }
    });
    
    return equal;
};

Traverse.prototype.paths = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.path); 
    });
    return acc;
};

Traverse.prototype.nodes = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.node);
    });
    return acc;
};

Traverse.prototype.clone = function () {
    var parents = [], nodes = [];
    
    return (function clone (src) {
        for (var i = 0; i < parents.length; i++) {
            if (parents[i] === src) {
                return nodes[i];
            }
        }
        
        if (typeof src === 'object' && src !== null) {
            var dst = copy(src);
            
            parents.push(src);
            nodes.push(dst);
            
            Object.keys(src).forEach(function (key) {
                dst[key] = clone(src[key]);
            });
            
            parents.pop();
            nodes.pop();
            return dst;
        }
        else {
            return src;
        }
    })(this.value);
};

function walk (root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    
    return (function walker (node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        
        var state = {
            node : node,
            node_ : node_,
            path : [].concat(path),
            parent : parents.slice(-1)[0],
            key : path.slice(-1)[0],
            isRoot : path.length === 0,
            level : path.length,
            circular : null,
            update : function (x) {
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
            },
            'delete' : function () {
                delete state.parent.node[state.key];
            },
            remove : function () {
                if (Array.isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                }
                else {
                    delete state.parent.node[state.key];
                }
            },
            before : function (f) { modifiers.before = f },
            after : function (f) { modifiers.after = f },
            pre : function (f) { modifiers.pre = f },
            post : function (f) { modifiers.post = f },
            stop : function () { alive = false }
        };
        
        if (!alive) return state;
        
        if (typeof node === 'object' && node !== null) {
            state.isLeaf = Object.keys(node).length == 0;
            
            for (var i = 0; i < parents.length; i++) {
                if (parents[i].node_ === node_) {
                    state.circular = parents[i];
                    break;
                }
            }
        }
        else {
            state.isLeaf = true;
        }
        
        state.notLeaf = !state.isLeaf;
        state.notRoot = !state.isRoot;
        
        // use return values to update if defined
        var ret = cb.call(state, state.node);
        if (ret !== undefined && state.update) state.update(ret);
        if (modifiers.before) modifiers.before.call(state, state.node);
        
        if (typeof state.node == 'object'
        && state.node !== null && !state.circular) {
            parents.push(state);
            
            var keys = Object.keys(state.node);
            keys.forEach(function (key, i) {
                path.push(key);
                
                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
                
                var child = walker(state.node[key]);
                if (immutable && Object.hasOwnProperty.call(state.node, key)) {
                    state.node[key] = child.node;
                }
                
                child.isLast = i == keys.length - 1;
                child.isFirst = i == 0;
                
                if (modifiers.post) modifiers.post.call(state, child);
                
                path.pop();
            });
            parents.pop();
        }
        
        if (modifiers.after) modifiers.after.call(state, state.node);
        
        return state;
    })(root).node;
}

Object.keys(Traverse.prototype).forEach(function (key) {
    Traverse[key] = function (obj) {
        var args = [].slice.call(arguments, 1);
        var t = Traverse(obj);
        return t[key].apply(t, args);
    };
});

function copy (src) {
    if (typeof src === 'object' && src !== null) {
        var dst;
        
        if (Array.isArray(src)) {
            dst = [];
        }
        else if (src instanceof Date) {
            dst = new Date(src);
        }
        else if (src instanceof Boolean) {
            dst = new Boolean(src);
        }
        else if (src instanceof Number) {
            dst = new Number(src);
        }
        else if (src instanceof String) {
            dst = new String(src);
        }
        else {
            dst = Object.create(Object.getPrototypeOf(src));
        }
        
        Object.keys(src).forEach(function (key) {
            dst[key] = src[key];
        });
        return dst;
    }
    else return src;
}

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/hashish/index.js":[function(require,module,exports){
module.exports = Hash;
var Traverse = require('traverse');

function Hash (hash, xs) {
    if (Array.isArray(hash) && Array.isArray(xs)) {
        var to = Math.min(hash.length, xs.length);
        var acc = {};
        for (var i = 0; i < to; i++) {
            acc[hash[i]] = xs[i];
        }
        return Hash(acc);
    }
    
    if (hash === undefined) return Hash({});
    
    var self = {
        map : function (f) {
            var acc = { __proto__ : hash.__proto__ };
            Object.keys(hash).forEach(function (key) {
                acc[key] = f.call(self, hash[key], key);
            });
            return Hash(acc);
        },
        forEach : function (f) {
            Object.keys(hash).forEach(function (key) {
                f.call(self, hash[key], key);
            });
            return self;
        },
        filter : function (f) {
            var acc = { __proto__ : hash.__proto__ };
            Object.keys(hash).forEach(function (key) {
                if (f.call(self, hash[key], key)) {
                    acc[key] = hash[key];
                }
            });
            return Hash(acc);
        },
        detect : function (f) {
            for (var key in hash) {
                if (f.call(self, hash[key], key)) {
                    return hash[key];
                }
            }
            return undefined;
        },
        reduce : function (f, acc) {
            var keys = Object.keys(hash);
            if (acc === undefined) acc = keys.shift();
            keys.forEach(function (key) {
                acc = f.call(self, acc, hash[key], key);
            });
            return acc;
        },
        some : function (f) {
            for (var key in hash) {
                if (f.call(self, hash[key], key)) return true;
            }
            return false;
        },
        update : function (obj) {
            if (arguments.length > 1) {
                self.updateAll([].slice.call(arguments));
            }
            else {
                Object.keys(obj).forEach(function (key) {
                    hash[key] = obj[key];
                });
            }
            return self;
        },
        updateAll : function (xs) {
            xs.filter(Boolean).forEach(function (x) {
                self.update(x);
            });
            return self;
        },
        merge : function (obj) {
            if (arguments.length > 1) {
                return self.copy.updateAll([].slice.call(arguments));
            }
            else {
                return self.copy.update(obj);
            }
        },
        mergeAll : function (xs) {
            return self.copy.updateAll(xs);
        },
        has : function (key) { // only operates on enumerables
            return Array.isArray(key)
                ? key.every(function (k) { return self.has(k) })
                : self.keys.indexOf(key.toString()) >= 0;
        },
        valuesAt : function (keys) {
            return Array.isArray(keys)
                ? keys.map(function (key) { return hash[key] })
                : hash[keys]
            ;
        },
        tap : function (f) {
            f.call(self, hash);
            return self;
        },
        extract : function (keys) {
            var acc = {};
            keys.forEach(function (key) {
                acc[key] = hash[key];
            });
            return Hash(acc);
        },
        exclude : function (keys) {
            return self.filter(function (_, key) {
                return keys.indexOf(key) < 0
            });
        },
        end : hash,
        items : hash
    };
    
    var props = {
        keys : function () { return Object.keys(hash) },
        values : function () {
            return Object.keys(hash).map(function (key) { return hash[key] });
        },
        compact : function () {
            return self.filter(function (x) { return x !== undefined });
        },
        clone : function () { return Hash(Hash.clone(hash)) },
        copy : function () { return Hash(Hash.copy(hash)) },
        length : function () { return Object.keys(hash).length },
        size : function () { return self.length }
    };
    
    if (Object.defineProperty) {
        // es5-shim has an Object.defineProperty but it throws for getters
        try {
            for (var key in props) {
                Object.defineProperty(self, key, { get : props[key] });
            }
        }
        catch (err) {
            for (var key in props) {
                if (key !== 'clone' && key !== 'copy' && key !== 'compact') {
                    // ^ those keys use Hash() so can't call them without
                    // a stack overflow
                    self[key] = props[key]();
                }
            }
        }
    }
    else if (self.__defineGetter__) {
        for (var key in props) {
            self.__defineGetter__(key, props[key]);
        }
    }
    else {
        // non-lazy version for browsers that suck >_<
        for (var key in props) {
            self[key] = props[key]();
        }
    }
    
    return self;
};

// deep copy
Hash.clone = function (ref) {
    return Traverse.clone(ref);
};

// shallow copy
Hash.copy = function (ref) {
    var hash = { __proto__ : ref.__proto__ };
    Object.keys(ref).forEach(function (key) {
        hash[key] = ref[key];
    });
    return hash;
};

Hash.map = function (ref, f) {
    return Hash(ref).map(f).items;
};

Hash.forEach = function (ref, f) {
    Hash(ref).forEach(f);
};

Hash.filter = function (ref, f) {
    return Hash(ref).filter(f).items;
};

Hash.detect = function (ref, f) {
    return Hash(ref).detect(f);
};

Hash.reduce = function (ref, f, acc) {
    return Hash(ref).reduce(f, acc);
};

Hash.some = function (ref, f) {
    return Hash(ref).some(f);
};

Hash.update = function (a /*, b, c, ... */) {
    var args = Array.prototype.slice.call(arguments, 1);
    var hash = Hash(a);
    return hash.update.apply(hash, args).items;
};

Hash.merge = function (a /*, b, c, ... */) {
    var args = Array.prototype.slice.call(arguments, 1);
    var hash = Hash(a);
    return hash.merge.apply(hash, args).items;
};

Hash.has = function (ref, key) {
    return Hash(ref).has(key);
};

Hash.valuesAt = function (ref, keys) {
    return Hash(ref).valuesAt(keys);
};

Hash.tap = function (ref, f) {
    return Hash(ref).tap(f).items;
};

Hash.extract = function (ref, keys) {
    return Hash(ref).extract(keys).items;
};

Hash.exclude = function (ref, keys) {
    return Hash(ref).exclude(keys).items;
};

Hash.concat = function (xs) {
    var hash = Hash({});
    xs.forEach(function (x) { hash.update(x) });
    return hash.items;
};

Hash.zip = function (xs, ys) {
    return Hash(xs, ys).items;
};

// .length is already defined for function prototypes
Hash.size = function (ref) {
    return Hash(ref).size;
};

Hash.compact = function (ref) {
    return Hash(ref).compact.items;
};

},{"traverse":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/hashish/node_modules/traverse/index.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/hashish/node_modules/traverse/index.js":[function(require,module,exports){
var traverse = module.exports = function (obj) {
    return new Traverse(obj);
};

function Traverse (obj) {
    this.value = obj;
}

Traverse.prototype.get = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            node = undefined;
            break;
        }
        node = node[key];
    }
    return node;
};

Traverse.prototype.has = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            return false;
        }
        node = node[key];
    }
    return true;
};

Traverse.prototype.set = function (ps, value) {
    var node = this.value;
    for (var i = 0; i < ps.length - 1; i ++) {
        var key = ps[i];
        if (!hasOwnProperty.call(node, key)) node[key] = {};
        node = node[key];
    }
    node[ps[i]] = value;
    return value;
};

Traverse.prototype.map = function (cb) {
    return walk(this.value, cb, true);
};

Traverse.prototype.forEach = function (cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
};

Traverse.prototype.reduce = function (cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function (x) {
        if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x);
        }
    });
    return acc;
};

Traverse.prototype.paths = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.path); 
    });
    return acc;
};

Traverse.prototype.nodes = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.node);
    });
    return acc;
};

Traverse.prototype.clone = function () {
    var parents = [], nodes = [];
    
    return (function clone (src) {
        for (var i = 0; i < parents.length; i++) {
            if (parents[i] === src) {
                return nodes[i];
            }
        }
        
        if (typeof src === 'object' && src !== null) {
            var dst = copy(src);
            
            parents.push(src);
            nodes.push(dst);
            
            forEach(objectKeys(src), function (key) {
                dst[key] = clone(src[key]);
            });
            
            parents.pop();
            nodes.pop();
            return dst;
        }
        else {
            return src;
        }
    })(this.value);
};

function walk (root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    
    return (function walker (node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        
        var keepGoing = true;
        
        var state = {
            node : node,
            node_ : node_,
            path : [].concat(path),
            parent : parents[parents.length - 1],
            parents : parents,
            key : path.slice(-1)[0],
            isRoot : path.length === 0,
            level : path.length,
            circular : null,
            update : function (x, stopHere) {
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
                if (stopHere) keepGoing = false;
            },
            'delete' : function (stopHere) {
                delete state.parent.node[state.key];
                if (stopHere) keepGoing = false;
            },
            remove : function (stopHere) {
                if (isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                }
                else {
                    delete state.parent.node[state.key];
                }
                if (stopHere) keepGoing = false;
            },
            keys : null,
            before : function (f) { modifiers.before = f },
            after : function (f) { modifiers.after = f },
            pre : function (f) { modifiers.pre = f },
            post : function (f) { modifiers.post = f },
            stop : function () { alive = false },
            block : function () { keepGoing = false }
        };
        
        if (!alive) return state;
        
        function updateState() {
            if (typeof state.node === 'object' && state.node !== null) {
                if (!state.keys || state.node_ !== state.node) {
                    state.keys = objectKeys(state.node)
                }
                
                state.isLeaf = state.keys.length == 0;
                
                for (var i = 0; i < parents.length; i++) {
                    if (parents[i].node_ === node_) {
                        state.circular = parents[i];
                        break;
                    }
                }
            }
            else {
                state.isLeaf = true;
                state.keys = null;
            }
            
            state.notLeaf = !state.isLeaf;
            state.notRoot = !state.isRoot;
        }
        
        updateState();
        
        // use return values to update if defined
        var ret = cb.call(state, state.node);
        if (ret !== undefined && state.update) state.update(ret);
        
        if (modifiers.before) modifiers.before.call(state, state.node);
        
        if (!keepGoing) return state;
        
        if (typeof state.node == 'object'
        && state.node !== null && !state.circular) {
            parents.push(state);
            
            updateState();
            
            forEach(state.keys, function (key, i) {
                path.push(key);
                
                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
                
                var child = walker(state.node[key]);
                if (immutable && hasOwnProperty.call(state.node, key)) {
                    state.node[key] = child.node;
                }
                
                child.isLast = i == state.keys.length - 1;
                child.isFirst = i == 0;
                
                if (modifiers.post) modifiers.post.call(state, child);
                
                path.pop();
            });
            parents.pop();
        }
        
        if (modifiers.after) modifiers.after.call(state, state.node);
        
        return state;
    })(root).node;
}

function copy (src) {
    if (typeof src === 'object' && src !== null) {
        var dst;
        
        if (isArray(src)) {
            dst = [];
        }
        else if (isDate(src)) {
            dst = new Date(src.getTime ? src.getTime() : src);
        }
        else if (isRegExp(src)) {
            dst = new RegExp(src);
        }
        else if (isError(src)) {
            dst = { message: src.message };
        }
        else if (isBoolean(src)) {
            dst = new Boolean(src);
        }
        else if (isNumber(src)) {
            dst = new Number(src);
        }
        else if (isString(src)) {
            dst = new String(src);
        }
        else if (Object.create && Object.getPrototypeOf) {
            dst = Object.create(Object.getPrototypeOf(src));
        }
        else if (src.constructor === Object) {
            dst = {};
        }
        else {
            var proto =
                (src.constructor && src.constructor.prototype)
                || src.__proto__
                || {}
            ;
            var T = function () {};
            T.prototype = proto;
            dst = new T;
        }
        
        forEach(objectKeys(src), function (key) {
            dst[key] = src[key];
        });
        return dst;
    }
    else return src;
}

var objectKeys = Object.keys || function keys (obj) {
    var res = [];
    for (var key in obj) res.push(key)
    return res;
};

function toS (obj) { return Object.prototype.toString.call(obj) }
function isDate (obj) { return toS(obj) === '[object Date]' }
function isRegExp (obj) { return toS(obj) === '[object RegExp]' }
function isError (obj) { return toS(obj) === '[object Error]' }
function isBoolean (obj) { return toS(obj) === '[object Boolean]' }
function isNumber (obj) { return toS(obj) === '[object Number]' }
function isString (obj) { return toS(obj) === '[object String]' }

var isArray = Array.isArray || function isArray (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

forEach(objectKeys(Traverse.prototype), function (key) {
    traverse[key] = function (obj) {
        var args = [].slice.call(arguments, 1);
        var t = new Traverse(obj);
        return t[key].apply(t, args);
    };
});

var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
    return key in obj;
};

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/consolidator.js":[function(require,module,exports){
/**
 * @preserve Copyright 2012 Robert Gust-Bardon <http://robert.gust-bardon.org/>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *     * Redistributions of source code must retain the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/**
 * @fileoverview Enhances <a href="https://github.com/mishoo/UglifyJS/"
 * >UglifyJS</a> with consolidation of null, Boolean, and String values.
 * <p>Also known as aliasing, this feature has been deprecated in <a href=
 * "http://closure-compiler.googlecode.com/">the Closure Compiler</a> since its
 * initial release, where it is unavailable from the <abbr title=
 * "command line interface">CLI</a>. The Closure Compiler allows one to log and
 * influence this process. In contrast, this implementation does not introduce
 * any variable declarations in global code and derives String values from
 * identifier names used as property accessors.</p>
 * <p>Consolidating literals may worsen the data compression ratio when an <a
 * href="http://tools.ietf.org/html/rfc2616#section-3.5">encoding
 * transformation</a> is applied. For instance, <a href=
 * "http://code.jquery.com/jquery-1.7.1.js">jQuery 1.7.1</a> takes 248235 bytes.
 * Building it with <a href="https://github.com/mishoo/UglifyJS/tarball/v1.2.5">
 * UglifyJS v1.2.5</a> results in 93647 bytes (37.73% of the original) which are
 * then compressed to 33154 bytes (13.36% of the original) using <a href=
 * "http://linux.die.net/man/1/gzip">gzip(1)</a>. Building it with the same
 * version of UglifyJS 1.2.5 patched with the implementation of consolidation
 * results in 80784 bytes (a decrease of 12863 bytes, i.e. 13.74%, in comparison
 * to the aforementioned 93647 bytes) which are then compressed to 34013 bytes
 * (an increase of 859 bytes, i.e. 2.59%, in comparison to the aforementioned
 * 33154 bytes).</p>
 * <p>Written in <a href="http://es5.github.com/#x4.2.2">the strict variant</a>
 * of <a href="http://es5.github.com/">ECMA-262 5.1 Edition</a>. Encoded in <a
 * href="http://tools.ietf.org/html/rfc3629">UTF-8</a>. Follows <a href=
 * "http://google-styleguide.googlecode.com/svn-history/r76/trunk/javascriptguide.xml"
 * >Revision 2.28 of the Google JavaScript Style Guide</a> (except for the
 * discouraged use of the {@code function} tag and the {@code namespace} tag).
 * 100% typed for the <a href=
 * "http://closure-compiler.googlecode.com/files/compiler-20120123.tar.gz"
 * >Closure Compiler Version 1741</a>.</p>
 * <p>Should you find this software useful, please consider <a href=
 * "https://paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=JZLW72X8FD4WG"
 * >a donation</a>.</p>
 * @author follow.me@RGustBardon (Robert Gust-Bardon)
 * @supported Tested with:
 *     <ul>
 *     <li><a href="http://nodejs.org/dist/v0.6.10/">Node v0.6.10</a>,</li>
 *     <li><a href="https://github.com/mishoo/UglifyJS/tarball/v1.2.5">UglifyJS
 *       v1.2.5</a>.</li>
 *     </ul>
 */

/*global console:false, exports:true, module:false, require:false */
/*jshint sub:true */
/**
 * Consolidates null, Boolean, and String values found inside an <abbr title=
 * "abstract syntax tree">AST</abbr>.
 * @param {!TSyntacticCodeUnit} oAbstractSyntaxTree An array-like object
 *     representing an <abbr title="abstract syntax tree">AST</abbr>.
 * @return {!TSyntacticCodeUnit} An array-like object representing an <abbr
 *     title="abstract syntax tree">AST</abbr> with its null, Boolean, and
 *     String values consolidated.
 */
// TODO(user) Consolidation of mathematical values found in numeric literals.
// TODO(user) Unconsolidation.
// TODO(user) Consolidation of ECMA-262 6th Edition programs.
// TODO(user) Rewrite in ECMA-262 6th Edition.
exports['ast_consolidate'] = function(oAbstractSyntaxTree) {
  'use strict';
  /*jshint bitwise:true, curly:true, eqeqeq:true, forin:true, immed:true,
        latedef:true, newcap:true, noarge:true, noempty:true, nonew:true,
        onevar:true, plusplus:true, regexp:true, undef:true, strict:true,
        sub:false, trailing:true */

  var _,
      /**
       * A record consisting of data about one or more source elements.
       * @constructor
       * @nosideeffects
       */
      TSourceElementsData = function() {
        /**
         * The category of the elements.
         * @type {number}
         * @see ESourceElementCategories
         */
        this.nCategory = ESourceElementCategories.N_OTHER;
        /**
         * The number of occurrences (within the elements) of each primitive
         * value that could be consolidated.
         * @type {!Array.<!Object.<string, number>>}
         */
        this.aCount = [];
        this.aCount[EPrimaryExpressionCategories.N_IDENTIFIER_NAMES] = {};
        this.aCount[EPrimaryExpressionCategories.N_STRING_LITERALS] = {};
        this.aCount[EPrimaryExpressionCategories.N_NULL_AND_BOOLEAN_LITERALS] =
            {};
        /**
         * Identifier names found within the elements.
         * @type {!Array.<string>}
         */
        this.aIdentifiers = [];
        /**
         * Prefixed representation Strings of each primitive value that could be
         * consolidated within the elements.
         * @type {!Array.<string>}
         */
        this.aPrimitiveValues = [];
      },
      /**
       * A record consisting of data about a primitive value that could be
       * consolidated.
       * @constructor
       * @nosideeffects
       */
      TPrimitiveValue = function() {
        /**
         * The difference in the number of terminal symbols between the original
         * source text and the one with the primitive value consolidated. If the
         * difference is positive, the primitive value is considered worthwhile.
         * @type {number}
         */
        this.nSaving = 0;
        /**
         * An identifier name of the variable that will be declared and assigned
         * the primitive value if the primitive value is consolidated.
         * @type {string}
         */
        this.sName = '';
      },
      /**
       * A record consisting of data on what to consolidate within the range of
       * source elements that is currently being considered.
       * @constructor
       * @nosideeffects
       */
      TSolution = function() {
        /**
         * An object whose keys are prefixed representation Strings of each
         * primitive value that could be consolidated within the elements and
         * whose values are corresponding data about those primitive values.
         * @type {!Object.<string, {nSaving: number, sName: string}>}
         * @see TPrimitiveValue
         */
        this.oPrimitiveValues = {};
        /**
         * The difference in the number of terminal symbols between the original
         * source text and the one with all the worthwhile primitive values
         * consolidated.
         * @type {number}
         * @see TPrimitiveValue#nSaving
         */
        this.nSavings = 0;
      },
      /**
       * The processor of <abbr title="abstract syntax tree">AST</abbr>s found
       * in UglifyJS.
       * @namespace
       * @type {!TProcessor}
       */
      oProcessor = (/** @type {!TProcessor} */ require('./process')),
      /**
       * A record consisting of a number of constants that represent the
       * difference in the number of terminal symbols between a source text with
       * a modified syntactic code unit and the original one.
       * @namespace
       * @type {!Object.<string, number>}
       */
      oWeights = {
        /**
         * The difference in the number of punctuators required by the bracket
         * notation and the dot notation.
         * <p><code>'[]'.length - '.'.length</code></p>
         * @const
         * @type {number}
         */
        N_PROPERTY_ACCESSOR: 1,
        /**
         * The number of punctuators required by a variable declaration with an
         * initialiser.
         * <p><code>':'.length + ';'.length</code></p>
         * @const
         * @type {number}
         */
        N_VARIABLE_DECLARATION: 2,
        /**
         * The number of terminal symbols required to introduce a variable
         * statement (excluding its variable declaration list).
         * <p><code>'var '.length</code></p>
         * @const
         * @type {number}
         */
        N_VARIABLE_STATEMENT_AFFIXATION: 4,
        /**
         * The number of terminal symbols needed to enclose source elements
         * within a function call with no argument values to a function with an
         * empty parameter list.
         * <p><code>'(function(){}());'.length</code></p>
         * @const
         * @type {number}
         */
        N_CLOSURE: 17
      },
      /**
       * Categories of primary expressions from which primitive values that
       * could be consolidated are derivable.
       * @namespace
       * @enum {number}
       */
      EPrimaryExpressionCategories = {
        /**
         * Identifier names used as property accessors.
         * @type {number}
         */
        N_IDENTIFIER_NAMES: 0,
        /**
         * String literals.
         * @type {number}
         */
        N_STRING_LITERALS: 1,
        /**
         * Null and Boolean literals.
         * @type {number}
         */
        N_NULL_AND_BOOLEAN_LITERALS: 2
      },
      /**
       * Prefixes of primitive values that could be consolidated.
       * The String values of the prefixes must have same number of characters.
       * The prefixes must not be used in any properties defined in any version
       * of <a href=
       * "http://www.ecma-international.org/publications/standards/Ecma-262.htm"
       * >ECMA-262</a>.
       * @namespace
       * @enum {string}
       */
      EValuePrefixes = {
        /**
         * Identifies String values.
         * @type {string}
         */
        S_STRING: '#S',
        /**
         * Identifies null and Boolean values.
         * @type {string}
         */
        S_SYMBOLIC: '#O'
      },
      /**
       * Categories of source elements in terms of their appropriateness of
       * having their primitive values consolidated.
       * @namespace
       * @enum {number}
       */
      ESourceElementCategories = {
        /**
         * Identifies a source element that includes the <a href=
         * "http://es5.github.com/#x12.10">{@code with}</a> statement.
         * @type {number}
         */
        N_WITH: 0,
        /**
         * Identifies a source element that includes the <a href=
         * "http://es5.github.com/#x15.1.2.1">{@code eval}</a> identifier name.
         * @type {number}
         */
        N_EVAL: 1,
        /**
         * Identifies a source element that must be excluded from the process
         * unless its whole scope is examined.
         * @type {number}
         */
        N_EXCLUDABLE: 2,
        /**
         * Identifies source elements not posing any problems.
         * @type {number}
         */
        N_OTHER: 3
      },
      /**
       * The list of literals (other than the String ones) whose primitive
       * values can be consolidated.
       * @const
       * @type {!Array.<string>}
       */
      A_OTHER_SUBSTITUTABLE_LITERALS = [
        'null',   // The null literal.
        'false',  // The Boolean literal {@code false}.
        'true'    // The Boolean literal {@code true}.
      ];

  (/**
    * Consolidates all worthwhile primitive values in a syntactic code unit.
    * @param {!TSyntacticCodeUnit} oSyntacticCodeUnit An array-like object
    *     representing the branch of the abstract syntax tree representing the
    *     syntactic code unit along with its scope.
    * @see TPrimitiveValue#nSaving
    */
   function fExamineSyntacticCodeUnit(oSyntacticCodeUnit) {
     var _,
         /**
          * Indicates whether the syntactic code unit represents global code.
          * @type {boolean}
          */
         bIsGlobal = 'toplevel' === oSyntacticCodeUnit[0],
         /**
          * Indicates whether the whole scope is being examined.
          * @type {boolean}
          */
         bIsWhollyExaminable = !bIsGlobal,
         /**
          * An array-like object representing source elements that constitute a
          * syntactic code unit.
          * @type {!TSyntacticCodeUnit}
          */
         oSourceElements,
         /**
          * A record consisting of data about the source element that is
          * currently being examined.
          * @type {!TSourceElementsData}
          */
         oSourceElementData,
         /**
          * The scope of the syntactic code unit.
          * @type {!TScope}
          */
         oScope,
         /**
          * An instance of an object that allows the traversal of an <abbr
          * title="abstract syntax tree">AST</abbr>.
          * @type {!TWalker}
          */
         oWalker,
         /**
          * An object encompassing collections of functions used during the
          * traversal of an <abbr title="abstract syntax tree">AST</abbr>.
          * @namespace
          * @type {!Object.<string, !Object.<string, function(...[*])>>}
          */
         oWalkers = {
           /**
            * A collection of functions used during the surveyance of source
            * elements.
            * @namespace
            * @type {!Object.<string, function(...[*])>}
            */
           oSurveySourceElement: {
             /**#nocode+*/  // JsDoc Toolkit 2.4.0 hides some of the keys.
             /**
              * Classifies the source element as excludable if it does not
              * contain a {@code with} statement or the {@code eval} identifier
              * name. Adds the identifier of the function and its formal
              * parameters to the list of identifier names found.
              * @param {string} sIdentifier The identifier of the function.
              * @param {!Array.<string>} aFormalParameterList Formal parameters.
              * @param {!TSyntacticCodeUnit} oFunctionBody Function code.
              */
             'defun': function(
                 sIdentifier,
                 aFormalParameterList,
                 oFunctionBody) {
               fClassifyAsExcludable();
               fAddIdentifier(sIdentifier);
               aFormalParameterList.forEach(fAddIdentifier);
             },
             /**
              * Increments the count of the number of occurrences of the String
              * value that is equivalent to the sequence of terminal symbols
              * that constitute the encountered identifier name.
              * @param {!TSyntacticCodeUnit} oExpression The nonterminal
              *     MemberExpression.
              * @param {string} sIdentifierName The identifier name used as the
              *     property accessor.
              * @return {!Array} The encountered branch of an <abbr title=
              *     "abstract syntax tree">AST</abbr> with its nonterminal
              *     MemberExpression traversed.
              */
             'dot': function(oExpression, sIdentifierName) {
               fCountPrimaryExpression(
                   EPrimaryExpressionCategories.N_IDENTIFIER_NAMES,
                   EValuePrefixes.S_STRING + sIdentifierName);
               return ['dot', oWalker.walk(oExpression), sIdentifierName];
             },
             /**
              * Adds the optional identifier of the function and its formal
              * parameters to the list of identifier names found.
              * @param {?string} sIdentifier The optional identifier of the
              *     function.
              * @param {!Array.<string>} aFormalParameterList Formal parameters.
              * @param {!TSyntacticCodeUnit} oFunctionBody Function code.
              */
             'function': function(
                 sIdentifier,
                 aFormalParameterList,
                 oFunctionBody) {
               if ('string' === typeof sIdentifier) {
                 fAddIdentifier(sIdentifier);
               }
               aFormalParameterList.forEach(fAddIdentifier);
             },
             /**
              * Either increments the count of the number of occurrences of the
              * encountered null or Boolean value or classifies a source element
              * as containing the {@code eval} identifier name.
              * @param {string} sIdentifier The identifier encountered.
              */
             'name': function(sIdentifier) {
               if (-1 !== A_OTHER_SUBSTITUTABLE_LITERALS.indexOf(sIdentifier)) {
                 fCountPrimaryExpression(
                     EPrimaryExpressionCategories.N_NULL_AND_BOOLEAN_LITERALS,
                     EValuePrefixes.S_SYMBOLIC + sIdentifier);
               } else {
                 if ('eval' === sIdentifier) {
                   oSourceElementData.nCategory =
                       ESourceElementCategories.N_EVAL;
                 }
                 fAddIdentifier(sIdentifier);
               }
             },
             /**
              * Classifies the source element as excludable if it does not
              * contain a {@code with} statement or the {@code eval} identifier
              * name.
              * @param {TSyntacticCodeUnit} oExpression The expression whose
              *     value is to be returned.
              */
             'return': function(oExpression) {
               fClassifyAsExcludable();
             },
             /**
              * Increments the count of the number of occurrences of the
              * encountered String value.
              * @param {string} sStringValue The String value of the string
              *     literal encountered.
              */
             'string': function(sStringValue) {
               if (sStringValue.length > 0) {
                 fCountPrimaryExpression(
                     EPrimaryExpressionCategories.N_STRING_LITERALS,
                     EValuePrefixes.S_STRING + sStringValue);
               }
             },
             /**
              * Adds the identifier reserved for an exception to the list of
              * identifier names found.
              * @param {!TSyntacticCodeUnit} oTry A block of code in which an
              *     exception can occur.
              * @param {Array} aCatch The identifier reserved for an exception
              *     and a block of code to handle the exception.
              * @param {TSyntacticCodeUnit} oFinally An optional block of code
              *     to be evaluated regardless of whether an exception occurs.
              */
             'try': function(oTry, aCatch, oFinally) {
               if (Array.isArray(aCatch)) {
                 fAddIdentifier(aCatch[0]);
               }
             },
             /**
              * Classifies the source element as excludable if it does not
              * contain a {@code with} statement or the {@code eval} identifier
              * name. Adds the identifier of each declared variable to the list
              * of identifier names found.
              * @param {!Array.<!Array>} aVariableDeclarationList Variable
              *     declarations.
              */
             'var': function(aVariableDeclarationList) {
               fClassifyAsExcludable();
               aVariableDeclarationList.forEach(fAddVariable);
             },
             /**
              * Classifies a source element as containing the {@code with}
              * statement.
              * @param {!TSyntacticCodeUnit} oExpression An expression whose
              *     value is to be converted to a value of type Object and
              *     become the binding object of a new object environment
              *     record of a new lexical environment in which the statement
              *     is to be executed.
              * @param {!TSyntacticCodeUnit} oStatement The statement to be
              *     executed in the augmented lexical environment.
              * @return {!Array} An empty array to stop the traversal.
              */
             'with': function(oExpression, oStatement) {
               oSourceElementData.nCategory = ESourceElementCategories.N_WITH;
               return [];
             }
             /**#nocode-*/  // JsDoc Toolkit 2.4.0 hides some of the keys.
           },
           /**
            * A collection of functions used while looking for nested functions.
            * @namespace
            * @type {!Object.<string, function(...[*])>}
            */
           oExamineFunctions: {
             /**#nocode+*/  // JsDoc Toolkit 2.4.0 hides some of the keys.
             /**
              * Orders an examination of a nested function declaration.
              * @this {!TSyntacticCodeUnit} An array-like object representing
              *     the branch of an <abbr title="abstract syntax tree"
              *     >AST</abbr> representing the syntactic code unit along with
              *     its scope.
              * @return {!Array} An empty array to stop the traversal.
              */
             'defun': function() {
               fExamineSyntacticCodeUnit(this);
               return [];
             },
             /**
              * Orders an examination of a nested function expression.
              * @this {!TSyntacticCodeUnit} An array-like object representing
              *     the branch of an <abbr title="abstract syntax tree"
              *     >AST</abbr> representing the syntactic code unit along with
              *     its scope.
              * @return {!Array} An empty array to stop the traversal.
              */
             'function': function() {
               fExamineSyntacticCodeUnit(this);
               return [];
             }
             /**#nocode-*/  // JsDoc Toolkit 2.4.0 hides some of the keys.
           }
         },
         /**
          * Records containing data about source elements.
          * @type {Array.<TSourceElementsData>}
          */
         aSourceElementsData = [],
         /**
          * The index (in the source text order) of the source element
          * immediately following a <a href="http://es5.github.com/#x14.1"
          * >Directive Prologue</a>.
          * @type {number}
          */
         nAfterDirectivePrologue = 0,
         /**
          * The index (in the source text order) of the source element that is
          * currently being considered.
          * @type {number}
          */
         nPosition,
         /**
          * The index (in the source text order) of the source element that is
          * the last element of the range of source elements that is currently
          * being considered.
          * @type {(undefined|number)}
          */
         nTo,
         /**
          * Initiates the traversal of a source element.
          * @param {!TWalker} oWalker An instance of an object that allows the
          *     traversal of an abstract syntax tree.
          * @param {!TSyntacticCodeUnit} oSourceElement A source element from
          *     which the traversal should commence.
          * @return {function(): !TSyntacticCodeUnit} A function that is able to
          *     initiate the traversal from a given source element.
          */
         cContext = function(oWalker, oSourceElement) {
           /**
            * @return {!TSyntacticCodeUnit} A function that is able to
            *     initiate the traversal from a given source element.
            */
           var fLambda = function() {
             return oWalker.walk(oSourceElement);
           };

           return fLambda;
         },
         /**
          * Classifies the source element as excludable if it does not
          * contain a {@code with} statement or the {@code eval} identifier
          * name.
          */
         fClassifyAsExcludable = function() {
           if (oSourceElementData.nCategory ===
               ESourceElementCategories.N_OTHER) {
             oSourceElementData.nCategory =
                 ESourceElementCategories.N_EXCLUDABLE;
           }
         },
         /**
          * Adds an identifier to the list of identifier names found.
          * @param {string} sIdentifier The identifier to be added.
          */
         fAddIdentifier = function(sIdentifier) {
           if (-1 === oSourceElementData.aIdentifiers.indexOf(sIdentifier)) {
             oSourceElementData.aIdentifiers.push(sIdentifier);
           }
         },
         /**
          * Adds the identifier of a variable to the list of identifier names
          * found.
          * @param {!Array} aVariableDeclaration A variable declaration.
          */
         fAddVariable = function(aVariableDeclaration) {
           fAddIdentifier(/** @type {string} */ aVariableDeclaration[0]);
         },
         /**
          * Increments the count of the number of occurrences of the prefixed
          * String representation attributed to the primary expression.
          * @param {number} nCategory The category of the primary expression.
          * @param {string} sName The prefixed String representation attributed
          *     to the primary expression.
          */
         fCountPrimaryExpression = function(nCategory, sName) {
           if (!oSourceElementData.aCount[nCategory].hasOwnProperty(sName)) {
             oSourceElementData.aCount[nCategory][sName] = 0;
             if (-1 === oSourceElementData.aPrimitiveValues.indexOf(sName)) {
               oSourceElementData.aPrimitiveValues.push(sName);
             }
           }
           oSourceElementData.aCount[nCategory][sName] += 1;
         },
         /**
          * Consolidates all worthwhile primitive values in a range of source
          *     elements.
          * @param {number} nFrom The index (in the source text order) of the
          *     source element that is the first element of the range.
          * @param {number} nTo The index (in the source text order) of the
          *     source element that is the last element of the range.
          * @param {boolean} bEnclose Indicates whether the range should be
          *     enclosed within a function call with no argument values to a
          *     function with an empty parameter list if any primitive values
          *     are consolidated.
          * @see TPrimitiveValue#nSaving
          */
         fExamineSourceElements = function(nFrom, nTo, bEnclose) {
           var _,
               /**
                * The index of the last mangled name.
                * @type {number}
                */
               nIndex = oScope.cname,
               /**
                * The index of the source element that is currently being
                * considered.
                * @type {number}
                */
               nPosition,
               /**
                * A collection of functions used during the consolidation of
                * primitive values and identifier names used as property
                * accessors.
                * @namespace
                * @type {!Object.<string, function(...[*])>}
                */
               oWalkersTransformers = {
                 /**
                  * If the String value that is equivalent to the sequence of
                  * terminal symbols that constitute the encountered identifier
                  * name is worthwhile, a syntactic conversion from the dot
                  * notation to the bracket notation ensues with that sequence
                  * being substituted by an identifier name to which the value
                  * is assigned.
                  * Applies to property accessors that use the dot notation.
                  * @param {!TSyntacticCodeUnit} oExpression The nonterminal
                  *     MemberExpression.
                  * @param {string} sIdentifierName The identifier name used as
                  *     the property accessor.
                  * @return {!Array} A syntactic code unit that is equivalent to
                  *     the one encountered.
                  * @see TPrimitiveValue#nSaving
                  */
                 'dot': function(oExpression, sIdentifierName) {
                   /**
                    * The prefixed String value that is equivalent to the
                    * sequence of terminal symbols that constitute the
                    * encountered identifier name.
                    * @type {string}
                    */
                   var sPrefixed = EValuePrefixes.S_STRING + sIdentifierName;

                   return oSolutionBest.oPrimitiveValues.hasOwnProperty(
                       sPrefixed) &&
                       oSolutionBest.oPrimitiveValues[sPrefixed].nSaving > 0 ?
                       ['sub',
                        oWalker.walk(oExpression),
                        ['name',
                         oSolutionBest.oPrimitiveValues[sPrefixed].sName]] :
                       ['dot', oWalker.walk(oExpression), sIdentifierName];
                 },
                 /**
                  * If the encountered identifier is a null or Boolean literal
                  * and its value is worthwhile, the identifier is substituted
                  * by an identifier name to which that value is assigned.
                  * Applies to identifier names.
                  * @param {string} sIdentifier The identifier encountered.
                  * @return {!Array} A syntactic code unit that is equivalent to
                  *     the one encountered.
                  * @see TPrimitiveValue#nSaving
                  */
                 'name': function(sIdentifier) {
                   /**
                    * The prefixed representation String of the identifier.
                    * @type {string}
                    */
                   var sPrefixed = EValuePrefixes.S_SYMBOLIC + sIdentifier;

                   return [
                     'name',
                     oSolutionBest.oPrimitiveValues.hasOwnProperty(sPrefixed) &&
                     oSolutionBest.oPrimitiveValues[sPrefixed].nSaving > 0 ?
                     oSolutionBest.oPrimitiveValues[sPrefixed].sName :
                     sIdentifier
                   ];
                 },
                 /**
                  * If the encountered String value is worthwhile, it is
                  * substituted by an identifier name to which that value is
                  * assigned.
                  * Applies to String values.
                  * @param {string} sStringValue The String value of the string
                  *     literal encountered.
                  * @return {!Array} A syntactic code unit that is equivalent to
                  *     the one encountered.
                  * @see TPrimitiveValue#nSaving
                  */
                 'string': function(sStringValue) {
                   /**
                    * The prefixed representation String of the primitive value
                    * of the literal.
                    * @type {string}
                    */
                   var sPrefixed =
                       EValuePrefixes.S_STRING + sStringValue;

                   return oSolutionBest.oPrimitiveValues.hasOwnProperty(
                       sPrefixed) &&
                       oSolutionBest.oPrimitiveValues[sPrefixed].nSaving > 0 ?
                       ['name',
                        oSolutionBest.oPrimitiveValues[sPrefixed].sName] :
                       ['string', sStringValue];
                 }
               },
               /**
                * Such data on what to consolidate within the range of source
                * elements that is currently being considered that lead to the
                * greatest known reduction of the number of the terminal symbols
                * in comparison to the original source text.
                * @type {!TSolution}
                */
               oSolutionBest = new TSolution(),
               /**
                * Data representing an ongoing attempt to find a better
                * reduction of the number of the terminal symbols in comparison
                * to the original source text than the best one that is
                * currently known.
                * @type {!TSolution}
                * @see oSolutionBest
                */
               oSolutionCandidate = new TSolution(),
               /**
                * A record consisting of data about the range of source elements
                * that is currently being examined.
                * @type {!TSourceElementsData}
                */
               oSourceElementsData = new TSourceElementsData(),
               /**
                * Variable declarations for each primitive value that is to be
                * consolidated within the elements.
                * @type {!Array.<!Array>}
                */
               aVariableDeclarations = [],
               /**
                * Augments a list with a prefixed representation String.
                * @param {!Array.<string>} aList A list that is to be augmented.
                * @return {function(string)} A function that augments a list
                *     with a prefixed representation String.
                */
               cAugmentList = function(aList) {
                 /**
                  * @param {string} sPrefixed Prefixed representation String of
                  *     a primitive value that could be consolidated within the
                  *     elements.
                  */
                 var fLambda = function(sPrefixed) {
                   if (-1 === aList.indexOf(sPrefixed)) {
                     aList.push(sPrefixed);
                   }
                 };

                 return fLambda;
               },
               /**
                * Adds the number of occurrences of a primitive value of a given
                * category that could be consolidated in the source element with
                * a given index to the count of occurrences of that primitive
                * value within the range of source elements that is currently
                * being considered.
                * @param {number} nPosition The index (in the source text order)
                *     of a source element.
                * @param {number} nCategory The category of the primary
                *     expression from which the primitive value is derived.
                * @return {function(string)} A function that performs the
                *     addition.
                * @see cAddOccurrencesInCategory
                */
               cAddOccurrences = function(nPosition, nCategory) {
                 /**
                  * @param {string} sPrefixed The prefixed representation String
                  *     of a primitive value.
                  */
                 var fLambda = function(sPrefixed) {
                   if (!oSourceElementsData.aCount[nCategory].hasOwnProperty(
                           sPrefixed)) {
                     oSourceElementsData.aCount[nCategory][sPrefixed] = 0;
                   }
                   oSourceElementsData.aCount[nCategory][sPrefixed] +=
                       aSourceElementsData[nPosition].aCount[nCategory][
                           sPrefixed];
                 };

                 return fLambda;
               },
               /**
                * Adds the number of occurrences of each primitive value of a
                * given category that could be consolidated in the source
                * element with a given index to the count of occurrences of that
                * primitive values within the range of source elements that is
                * currently being considered.
                * @param {number} nPosition The index (in the source text order)
                *     of a source element.
                * @return {function(number)} A function that performs the
                *     addition.
                * @see fAddOccurrences
                */
               cAddOccurrencesInCategory = function(nPosition) {
                 /**
                  * @param {number} nCategory The category of the primary
                  *     expression from which the primitive value is derived.
                  */
                 var fLambda = function(nCategory) {
                   Object.keys(
                       aSourceElementsData[nPosition].aCount[nCategory]
                   ).forEach(cAddOccurrences(nPosition, nCategory));
                 };

                 return fLambda;
               },
               /**
                * Adds the number of occurrences of each primitive value that
                * could be consolidated in the source element with a given index
                * to the count of occurrences of that primitive values within
                * the range of source elements that is currently being
                * considered.
                * @param {number} nPosition The index (in the source text order)
                *     of a source element.
                */
               fAddOccurrences = function(nPosition) {
                 Object.keys(aSourceElementsData[nPosition].aCount).forEach(
                     cAddOccurrencesInCategory(nPosition));
               },
               /**
                * Creates a variable declaration for a primitive value if that
                * primitive value is to be consolidated within the elements.
                * @param {string} sPrefixed Prefixed representation String of a
                *     primitive value that could be consolidated within the
                *     elements.
                * @see aVariableDeclarations
                */
               cAugmentVariableDeclarations = function(sPrefixed) {
                 if (oSolutionBest.oPrimitiveValues[sPrefixed].nSaving > 0) {
                   aVariableDeclarations.push([
                     oSolutionBest.oPrimitiveValues[sPrefixed].sName,
                     [0 === sPrefixed.indexOf(EValuePrefixes.S_SYMBOLIC) ?
                      'name' : 'string',
                      sPrefixed.substring(EValuePrefixes.S_SYMBOLIC.length)]
                   ]);
                 }
               },
               /**
                * Sorts primitive values with regard to the difference in the
                * number of terminal symbols between the original source text
                * and the one with those primitive values consolidated.
                * @param {string} sPrefixed0 The prefixed representation String
                *     of the first of the two primitive values that are being
                *     compared.
                * @param {string} sPrefixed1 The prefixed representation String
                *     of the second of the two primitive values that are being
                *     compared.
                * @return {number}
                *     <dl>
                *         <dt>-1</dt>
                *         <dd>if the first primitive value must be placed before
                *              the other one,</dd>
                *         <dt>0</dt>
                *         <dd>if the first primitive value may be placed before
                *              the other one,</dd>
                *         <dt>1</dt>
                *         <dd>if the first primitive value must not be placed
                *              before the other one.</dd>
                *     </dl>
                * @see TSolution.oPrimitiveValues
                */
               cSortPrimitiveValues = function(sPrefixed0, sPrefixed1) {
                 /**
                  * The difference between:
                  * <ol>
                  * <li>the difference in the number of terminal symbols
                  *     between the original source text and the one with the
                  *     first primitive value consolidated, and</li>
                  * <li>the difference in the number of terminal symbols
                  *     between the original source text and the one with the
                  *     second primitive value consolidated.</li>
                  * </ol>
                  * @type {number}
                  */
                 var nDifference =
                     oSolutionCandidate.oPrimitiveValues[sPrefixed0].nSaving -
                     oSolutionCandidate.oPrimitiveValues[sPrefixed1].nSaving;

                 return nDifference > 0 ? -1 : nDifference < 0 ? 1 : 0;
               },
               /**
                * Assigns an identifier name to a primitive value and calculates
                * whether instances of that primitive value are worth
                * consolidating.
                * @param {string} sPrefixed The prefixed representation String
                *     of a primitive value that is being evaluated.
                */
               fEvaluatePrimitiveValue = function(sPrefixed) {
                 var _,
                     /**
                      * The index of the last mangled name.
                      * @type {number}
                      */
                     nIndex,
                     /**
                      * The representation String of the primitive value that is
                      * being evaluated.
                      * @type {string}
                      */
                     sName =
                         sPrefixed.substring(EValuePrefixes.S_SYMBOLIC.length),
                     /**
                      * The number of source characters taken up by the
                      * representation String of the primitive value that is
                      * being evaluated.
                      * @type {number}
                      */
                     nLengthOriginal = sName.length,
                     /**
                      * The number of source characters taken up by the
                      * identifier name that could substitute the primitive
                      * value that is being evaluated.
                      * substituted.
                      * @type {number}
                      */
                     nLengthSubstitution,
                     /**
                      * The number of source characters taken up by by the
                      * representation String of the primitive value that is
                      * being evaluated when it is represented by a string
                      * literal.
                      * @type {number}
                      */
                     nLengthString = oProcessor.make_string(sName).length;

                 oSolutionCandidate.oPrimitiveValues[sPrefixed] =
                     new TPrimitiveValue();
                 do {  // Find an identifier unused in this or any nested scope.
                   nIndex = oScope.cname;
                   oSolutionCandidate.oPrimitiveValues[sPrefixed].sName =
                       oScope.next_mangled();
                 } while (-1 !== oSourceElementsData.aIdentifiers.indexOf(
                     oSolutionCandidate.oPrimitiveValues[sPrefixed].sName));
                 nLengthSubstitution = oSolutionCandidate.oPrimitiveValues[
                     sPrefixed].sName.length;
                 if (0 === sPrefixed.indexOf(EValuePrefixes.S_SYMBOLIC)) {
                   // foo:null, or foo:null;
                   oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving -=
                       nLengthSubstitution + nLengthOriginal +
                       oWeights.N_VARIABLE_DECLARATION;
                   // null vs foo
                   oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving +=
                       oSourceElementsData.aCount[
                           EPrimaryExpressionCategories.
                               N_NULL_AND_BOOLEAN_LITERALS][sPrefixed] *
                       (nLengthOriginal - nLengthSubstitution);
                 } else {
                   // foo:'fromCharCode';
                   oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving -=
                       nLengthSubstitution + nLengthString +
                       oWeights.N_VARIABLE_DECLARATION;
                   // .fromCharCode vs [foo]
                   if (oSourceElementsData.aCount[
                           EPrimaryExpressionCategories.N_IDENTIFIER_NAMES
                       ].hasOwnProperty(sPrefixed)) {
                     oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving +=
                         oSourceElementsData.aCount[
                             EPrimaryExpressionCategories.N_IDENTIFIER_NAMES
                         ][sPrefixed] *
                         (nLengthOriginal - nLengthSubstitution -
                          oWeights.N_PROPERTY_ACCESSOR);
                   }
                   // 'fromCharCode' vs foo
                   if (oSourceElementsData.aCount[
                           EPrimaryExpressionCategories.N_STRING_LITERALS
                       ].hasOwnProperty(sPrefixed)) {
                     oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving +=
                         oSourceElementsData.aCount[
                             EPrimaryExpressionCategories.N_STRING_LITERALS
                         ][sPrefixed] *
                         (nLengthString - nLengthSubstitution);
                   }
                 }
                 if (oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving >
                     0) {
                   oSolutionCandidate.nSavings +=
                       oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving;
                 } else {
                   oScope.cname = nIndex; // Free the identifier name.
                 }
               },
               /**
                * Adds a variable declaration to an existing variable statement.
                * @param {!Array} aVariableDeclaration A variable declaration
                *     with an initialiser.
                */
               cAddVariableDeclaration = function(aVariableDeclaration) {
                 (/** @type {!Array} */ oSourceElements[nFrom][1]).unshift(
                     aVariableDeclaration);
               };

           if (nFrom > nTo) {
             return;
           }
           // If the range is a closure, reuse the closure.
           if (nFrom === nTo &&
               'stat' === oSourceElements[nFrom][0] &&
               'call' === oSourceElements[nFrom][1][0] &&
               'function' === oSourceElements[nFrom][1][1][0]) {
             fExamineSyntacticCodeUnit(oSourceElements[nFrom][1][1]);
             return;
           }
           // Create a list of all derived primitive values within the range.
           for (nPosition = nFrom; nPosition <= nTo; nPosition += 1) {
             aSourceElementsData[nPosition].aPrimitiveValues.forEach(
                 cAugmentList(oSourceElementsData.aPrimitiveValues));
           }
           if (0 === oSourceElementsData.aPrimitiveValues.length) {
             return;
           }
           for (nPosition = nFrom; nPosition <= nTo; nPosition += 1) {
             // Add the number of occurrences to the total count.
             fAddOccurrences(nPosition);
             // Add identifiers of this or any nested scope to the list.
             aSourceElementsData[nPosition].aIdentifiers.forEach(
                 cAugmentList(oSourceElementsData.aIdentifiers));
           }
           // Distribute identifier names among derived primitive values.
           do {  // If there was any progress, find a better distribution.
             oSolutionBest = oSolutionCandidate;
             if (Object.keys(oSolutionCandidate.oPrimitiveValues).length > 0) {
               // Sort primitive values descending by their worthwhileness.
               oSourceElementsData.aPrimitiveValues.sort(cSortPrimitiveValues);
             }
             oSolutionCandidate = new TSolution();
             oSourceElementsData.aPrimitiveValues.forEach(
                 fEvaluatePrimitiveValue);
             oScope.cname = nIndex;
           } while (oSolutionCandidate.nSavings > oSolutionBest.nSavings);
           // Take the necessity of adding a variable statement into account.
           if ('var' !== oSourceElements[nFrom][0]) {
             oSolutionBest.nSavings -= oWeights.N_VARIABLE_STATEMENT_AFFIXATION;
           }
           if (bEnclose) {
             // Take the necessity of forming a closure into account.
             oSolutionBest.nSavings -= oWeights.N_CLOSURE;
           }
           if (oSolutionBest.nSavings > 0) {
             // Create variable declarations suitable for UglifyJS.
             Object.keys(oSolutionBest.oPrimitiveValues).forEach(
                 cAugmentVariableDeclarations);
             // Rewrite expressions that contain worthwhile primitive values.
             for (nPosition = nFrom; nPosition <= nTo; nPosition += 1) {
               oWalker = oProcessor.ast_walker();
               oSourceElements[nPosition] =
                   oWalker.with_walkers(
                       oWalkersTransformers,
                       cContext(oWalker, oSourceElements[nPosition]));
             }
             if ('var' === oSourceElements[nFrom][0]) {  // Reuse the statement.
               (/** @type {!Array.<!Array>} */ aVariableDeclarations.reverse(
                   )).forEach(cAddVariableDeclaration);
             } else {  // Add a variable statement.
               Array.prototype.splice.call(
                   oSourceElements,
                   nFrom,
                   0,
                   ['var', aVariableDeclarations]);
               nTo += 1;
             }
             if (bEnclose) {
               // Add a closure.
               Array.prototype.splice.call(
                   oSourceElements,
                   nFrom,
                   0,
                   ['stat', ['call', ['function', null, [], []], []]]);
               // Copy source elements into the closure.
               for (nPosition = nTo + 1; nPosition > nFrom; nPosition -= 1) {
                 Array.prototype.unshift.call(
                     oSourceElements[nFrom][1][1][3],
                     oSourceElements[nPosition]);
               }
               // Remove source elements outside the closure.
               Array.prototype.splice.call(
                   oSourceElements,
                   nFrom + 1,
                   nTo - nFrom + 1);
             }
           }
           if (bEnclose) {
             // Restore the availability of identifier names.
             oScope.cname = nIndex;
           }
         };

     oSourceElements = (/** @type {!TSyntacticCodeUnit} */
         oSyntacticCodeUnit[bIsGlobal ? 1 : 3]);
     if (0 === oSourceElements.length) {
       return;
     }
     oScope = bIsGlobal ? oSyntacticCodeUnit.scope : oSourceElements.scope;
     // Skip a Directive Prologue.
     while (nAfterDirectivePrologue < oSourceElements.length &&
            'directive' === oSourceElements[nAfterDirectivePrologue][0]) {
       nAfterDirectivePrologue += 1;
       aSourceElementsData.push(null);
     }
     if (oSourceElements.length === nAfterDirectivePrologue) {
       return;
     }
     for (nPosition = nAfterDirectivePrologue;
          nPosition < oSourceElements.length;
          nPosition += 1) {
       oSourceElementData = new TSourceElementsData();
       oWalker = oProcessor.ast_walker();
       // Classify a source element.
       // Find its derived primitive values and count their occurrences.
       // Find all identifiers used (including nested scopes).
       oWalker.with_walkers(
           oWalkers.oSurveySourceElement,
           cContext(oWalker, oSourceElements[nPosition]));
       // Establish whether the scope is still wholly examinable.
       bIsWhollyExaminable = bIsWhollyExaminable &&
           ESourceElementCategories.N_WITH !== oSourceElementData.nCategory &&
           ESourceElementCategories.N_EVAL !== oSourceElementData.nCategory;
       aSourceElementsData.push(oSourceElementData);
     }
     if (bIsWhollyExaminable) {  // Examine the whole scope.
       fExamineSourceElements(
           nAfterDirectivePrologue,
           oSourceElements.length - 1,
           false);
     } else {  // Examine unexcluded ranges of source elements.
       for (nPosition = oSourceElements.length - 1;
            nPosition >= nAfterDirectivePrologue;
            nPosition -= 1) {
         oSourceElementData = (/** @type {!TSourceElementsData} */
             aSourceElementsData[nPosition]);
         if (ESourceElementCategories.N_OTHER ===
             oSourceElementData.nCategory) {
           if ('undefined' === typeof nTo) {
             nTo = nPosition;  // Indicate the end of a range.
           }
           // Examine the range if it immediately follows a Directive Prologue.
           if (nPosition === nAfterDirectivePrologue) {
             fExamineSourceElements(nPosition, nTo, true);
           }
         } else {
           if ('undefined' !== typeof nTo) {
             // Examine the range that immediately follows this source element.
             fExamineSourceElements(nPosition + 1, nTo, true);
             nTo = void 0;  // Obliterate the range.
           }
           // Examine nested functions.
           oWalker = oProcessor.ast_walker();
           oWalker.with_walkers(
               oWalkers.oExamineFunctions,
               cContext(oWalker, oSourceElements[nPosition]));
         }
       }
     }
   }(oAbstractSyntaxTree = oProcessor.ast_add_scope(oAbstractSyntaxTree)));
  return oAbstractSyntaxTree;
};
/*jshint sub:false */

/* Local Variables:      */
/* mode: js              */
/* coding: utf-8         */
/* indent-tabs-mode: nil */
/* tab-width: 2          */
/* End:                  */
/* vim: set ft=javascript fenc=utf-8 et ts=2 sts=2 sw=2: */
/* :mode=javascript:noTabs=true:tabSize=2:indentSize=2:deepIndent=true: */


},{"./process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/process.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/parse-js.js":[function(require,module,exports){
/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.

  This version is suitable for Node.js.  With minimal changes (the
  exports stuff) it should work on any JS platform.

  This file contains the tokenizer/parser.  It is a port to JavaScript
  of parse-js [1], a JavaScript parser library written in Common Lisp
  by Marijn Haverbeke.  Thank you Marijn!

  [1] http://marijn.haverbeke.nl/parse-js/

  Exported functions:

    - tokenizer(code) -- returns a function.  Call the returned
      function to fetch the next token.

    - parse(code) -- returns an AST of the given JavaScript code.

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2010 (c) Mihai Bazon <mihai.bazon@gmail.com>
    Based on parse-js (http://marijn.haverbeke.nl/parse-js/).

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

/* -----[ Tokenizer (constants) ]----- */

var KEYWORDS = array_to_hash([
        "break",
        "case",
        "catch",
        "const",
        "continue",
        "debugger",
        "default",
        "delete",
        "do",
        "else",
        "finally",
        "for",
        "function",
        "if",
        "in",
        "instanceof",
        "new",
        "return",
        "switch",
        "throw",
        "try",
        "typeof",
        "var",
        "void",
        "while",
        "with"
]);

var RESERVED_WORDS = array_to_hash([
        "abstract",
        "boolean",
        "byte",
        "char",
        "class",
        "double",
        "enum",
        "export",
        "extends",
        "final",
        "float",
        "goto",
        "implements",
        "import",
        "int",
        "interface",
        "long",
        "native",
        "package",
        "private",
        "protected",
        "public",
        "short",
        "static",
        "super",
        "synchronized",
        "throws",
        "transient",
        "volatile"
]);

var KEYWORDS_BEFORE_EXPRESSION = array_to_hash([
        "return",
        "new",
        "delete",
        "throw",
        "else",
        "case"
]);

var KEYWORDS_ATOM = array_to_hash([
        "false",
        "null",
        "true",
        "undefined"
]);

var OPERATOR_CHARS = array_to_hash(characters("+-*&%=<>!?|~^"));

var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;
var RE_OCT_NUMBER = /^0[0-7]+$/;
var RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i;

var OPERATORS = array_to_hash([
        "in",
        "instanceof",
        "typeof",
        "new",
        "void",
        "delete",
        "++",
        "--",
        "+",
        "-",
        "!",
        "~",
        "&",
        "|",
        "^",
        "*",
        "/",
        "%",
        ">>",
        "<<",
        ">>>",
        "<",
        ">",
        "<=",
        ">=",
        "==",
        "===",
        "!=",
        "!==",
        "?",
        "=",
        "+=",
        "-=",
        "/=",
        "*=",
        "%=",
        ">>=",
        "<<=",
        ">>>=",
        "|=",
        "^=",
        "&=",
        "&&",
        "||"
]);

var WHITESPACE_CHARS = array_to_hash(characters(" \u00a0\n\r\t\f\u000b\u200b\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000"));

var PUNC_BEFORE_EXPRESSION = array_to_hash(characters("[{(,.;:"));

var PUNC_CHARS = array_to_hash(characters("[]{}(),;:"));

var REGEXP_MODIFIERS = array_to_hash(characters("gmsiy"));

/* -----[ Tokenizer ]----- */

var UNICODE = {  // Unicode 6.1
        letter: new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
        combining_mark: new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08E4-\\u08FE\\u0900-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C01-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C82\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D02\\u0D03\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F\\u109A-\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF2-\\u1CF4\\u1DC0-\\u1DE6\\u1DFC-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA674-\\uA67D\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA7B\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),
        connector_punctuation: new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]"),
        digit: new RegExp("[\\u0030-\\u0039\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]")
};

function is_letter(ch) {
        return UNICODE.letter.test(ch);
};

function is_digit(ch) {
        ch = ch.charCodeAt(0);
        return ch >= 48 && ch <= 57;
};

function is_unicode_digit(ch) {
        return UNICODE.digit.test(ch);
}

function is_alphanumeric_char(ch) {
        return is_digit(ch) || is_letter(ch);
};

function is_unicode_combining_mark(ch) {
        return UNICODE.combining_mark.test(ch);
};

function is_unicode_connector_punctuation(ch) {
        return UNICODE.connector_punctuation.test(ch);
};

function is_identifier_start(ch) {
        return ch == "$" || ch == "_" || is_letter(ch);
};

function is_identifier_char(ch) {
        return is_identifier_start(ch)
                || is_unicode_combining_mark(ch)
                || is_unicode_digit(ch)
                || is_unicode_connector_punctuation(ch)
                || ch == "\u200c" // zero-width non-joiner <ZWNJ>
                || ch == "\u200d" // zero-width joiner <ZWJ> (in my ECMA-262 PDF, this is also 200c)
        ;
};

function parse_js_number(num) {
        if (RE_HEX_NUMBER.test(num)) {
                return parseInt(num.substr(2), 16);
        } else if (RE_OCT_NUMBER.test(num)) {
                return parseInt(num.substr(1), 8);
        } else if (RE_DEC_NUMBER.test(num)) {
                return parseFloat(num);
        }
};

function JS_Parse_Error(message, line, col, pos) {
        this.message = message;
        this.line = line + 1;
        this.col = col + 1;
        this.pos = pos + 1;
        this.stack = new Error().stack;
};

JS_Parse_Error.prototype.toString = function() {
        return this.message + " (line: " + this.line + ", col: " + this.col + ", pos: " + this.pos + ")" + "\n\n" + this.stack;
};

function js_error(message, line, col, pos) {
        throw new JS_Parse_Error(message, line, col, pos);
};

function is_token(token, type, val) {
        return token.type == type && (val == null || token.value == val);
};

var EX_EOF = {};

function tokenizer($TEXT) {

        var S = {
                text            : $TEXT.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/^\uFEFF/, ''),
                pos             : 0,
                tokpos          : 0,
                line            : 0,
                tokline         : 0,
                col             : 0,
                tokcol          : 0,
                newline_before  : false,
                regex_allowed   : false,
                comments_before : []
        };

        function peek() { return S.text.charAt(S.pos); };

        function next(signal_eof, in_string) {
                var ch = S.text.charAt(S.pos++);
                if (signal_eof && !ch)
                        throw EX_EOF;
                if (ch == "\n") {
                        S.newline_before = S.newline_before || !in_string;
                        ++S.line;
                        S.col = 0;
                } else {
                        ++S.col;
                }
                return ch;
        };

        function eof() {
                return !S.peek();
        };

        function find(what, signal_eof) {
                var pos = S.text.indexOf(what, S.pos);
                if (signal_eof && pos == -1) throw EX_EOF;
                return pos;
        };

        function start_token() {
                S.tokline = S.line;
                S.tokcol = S.col;
                S.tokpos = S.pos;
        };

        function token(type, value, is_comment) {
                S.regex_allowed = ((type == "operator" && !HOP(UNARY_POSTFIX, value)) ||
                                   (type == "keyword" && HOP(KEYWORDS_BEFORE_EXPRESSION, value)) ||
                                   (type == "punc" && HOP(PUNC_BEFORE_EXPRESSION, value)));
                var ret = {
                        type   : type,
                        value  : value,
                        line   : S.tokline,
                        col    : S.tokcol,
                        pos    : S.tokpos,
                        endpos : S.pos,
                        nlb    : S.newline_before
                };
                if (!is_comment) {
                        ret.comments_before = S.comments_before;
                        S.comments_before = [];
                        // make note of any newlines in the comments that came before
                        for (var i = 0, len = ret.comments_before.length; i < len; i++) {
                                ret.nlb = ret.nlb || ret.comments_before[i].nlb;
                        }
                }
                S.newline_before = false;
                return ret;
        };

        function skip_whitespace() {
                while (HOP(WHITESPACE_CHARS, peek()))
                        next();
        };

        function read_while(pred) {
                var ret = "", ch = peek(), i = 0;
                while (ch && pred(ch, i++)) {
                        ret += next();
                        ch = peek();
                }
                return ret;
        };

        function parse_error(err) {
                js_error(err, S.tokline, S.tokcol, S.tokpos);
        };

        function read_num(prefix) {
                var has_e = false, after_e = false, has_x = false, has_dot = prefix == ".";
                var num = read_while(function(ch, i){
                        if (ch == "x" || ch == "X") {
                                if (has_x) return false;
                                return has_x = true;
                        }
                        if (!has_x && (ch == "E" || ch == "e")) {
                                if (has_e) return false;
                                return has_e = after_e = true;
                        }
                        if (ch == "-") {
                                if (after_e || (i == 0 && !prefix)) return true;
                                return false;
                        }
                        if (ch == "+") return after_e;
                        after_e = false;
                        if (ch == ".") {
                                if (!has_dot && !has_x && !has_e)
                                        return has_dot = true;
                                return false;
                        }
                        return is_alphanumeric_char(ch);
                });
                if (prefix)
                        num = prefix + num;
                var valid = parse_js_number(num);
                if (!isNaN(valid)) {
                        return token("num", valid);
                } else {
                        parse_error("Invalid syntax: " + num);
                }
        };

        function read_escaped_char(in_string) {
                var ch = next(true, in_string);
                switch (ch) {
                    case "n" : return "\n";
                    case "r" : return "\r";
                    case "t" : return "\t";
                    case "b" : return "\b";
                    case "v" : return "\u000b";
                    case "f" : return "\f";
                    case "0" : return "\0";
                    case "x" : return String.fromCharCode(hex_bytes(2));
                    case "u" : return String.fromCharCode(hex_bytes(4));
                    case "\n": return "";
                    default  : return ch;
                }
        };

        function hex_bytes(n) {
                var num = 0;
                for (; n > 0; --n) {
                        var digit = parseInt(next(true), 16);
                        if (isNaN(digit))
                                parse_error("Invalid hex-character pattern in string");
                        num = (num << 4) | digit;
                }
                return num;
        };

        function read_string() {
                return with_eof_error("Unterminated string constant", function(){
                        var quote = next(), ret = "";
                        for (;;) {
                                var ch = next(true);
                                if (ch == "\\") {
                                        // read OctalEscapeSequence (XXX: deprecated if "strict mode")
                                        // https://github.com/mishoo/UglifyJS/issues/178
                                        var octal_len = 0, first = null;
                                        ch = read_while(function(ch){
                                                if (ch >= "0" && ch <= "7") {
                                                        if (!first) {
                                                                first = ch;
                                                                return ++octal_len;
                                                        }
                                                        else if (first <= "3" && octal_len <= 2) return ++octal_len;
                                                        else if (first >= "4" && octal_len <= 1) return ++octal_len;
                                                }
                                                return false;
                                        });
                                        if (octal_len > 0) ch = String.fromCharCode(parseInt(ch, 8));
                                        else ch = read_escaped_char(true);
                                }
                                else if (ch == quote) break;
                                ret += ch;
                        }
                        return token("string", ret);
                });
        };

        function read_line_comment() {
                next();
                var i = find("\n"), ret;
                if (i == -1) {
                        ret = S.text.substr(S.pos);
                        S.pos = S.text.length;
                } else {
                        ret = S.text.substring(S.pos, i);
                        S.pos = i;
                }
                return token("comment1", ret, true);
        };

        function read_multiline_comment() {
                next();
                return with_eof_error("Unterminated multiline comment", function(){
                        var i = find("*/", true),
                            text = S.text.substring(S.pos, i);
                        S.pos = i + 2;
                        S.line += text.split("\n").length - 1;
                        S.newline_before = S.newline_before || text.indexOf("\n") >= 0;

                        // https://github.com/mishoo/UglifyJS/issues/#issue/100
                        if (/^@cc_on/i.test(text)) {
                                warn("WARNING: at line " + S.line);
                                warn("*** Found \"conditional comment\": " + text);
                                warn("*** UglifyJS DISCARDS ALL COMMENTS.  This means your code might no longer work properly in Internet Explorer.");
                        }

                        return token("comment2", text, true);
                });
        };

        function read_name() {
                var backslash = false, name = "", ch, escaped = false, hex;
                while ((ch = peek()) != null) {
                        if (!backslash) {
                                if (ch == "\\") escaped = backslash = true, next();
                                else if (is_identifier_char(ch)) name += next();
                                else break;
                        }
                        else {
                                if (ch != "u") parse_error("Expecting UnicodeEscapeSequence -- uXXXX");
                                ch = read_escaped_char();
                                if (!is_identifier_char(ch)) parse_error("Unicode char: " + ch.charCodeAt(0) + " is not valid in identifier");
                                name += ch;
                                backslash = false;
                        }
                }
                if (HOP(KEYWORDS, name) && escaped) {
                        hex = name.charCodeAt(0).toString(16).toUpperCase();
                        name = "\\u" + "0000".substr(hex.length) + hex + name.slice(1);
                }
                return name;
        };

        function read_regexp(regexp) {
                return with_eof_error("Unterminated regular expression", function(){
                        var prev_backslash = false, ch, in_class = false;
                        while ((ch = next(true))) if (prev_backslash) {
                                regexp += "\\" + ch;
                                prev_backslash = false;
                        } else if (ch == "[") {
                                in_class = true;
                                regexp += ch;
                        } else if (ch == "]" && in_class) {
                                in_class = false;
                                regexp += ch;
                        } else if (ch == "/" && !in_class) {
                                break;
                        } else if (ch == "\\") {
                                prev_backslash = true;
                        } else {
                                regexp += ch;
                        }
                        var mods = read_name();
                        return token("regexp", [ regexp, mods ]);
                });
        };

        function read_operator(prefix) {
                function grow(op) {
                        if (!peek()) return op;
                        var bigger = op + peek();
                        if (HOP(OPERATORS, bigger)) {
                                next();
                                return grow(bigger);
                        } else {
                                return op;
                        }
                };
                return token("operator", grow(prefix || next()));
        };

        function handle_slash() {
                next();
                var regex_allowed = S.regex_allowed;
                switch (peek()) {
                    case "/":
                        S.comments_before.push(read_line_comment());
                        S.regex_allowed = regex_allowed;
                        return next_token();
                    case "*":
                        S.comments_before.push(read_multiline_comment());
                        S.regex_allowed = regex_allowed;
                        return next_token();
                }
                return S.regex_allowed ? read_regexp("") : read_operator("/");
        };

        function handle_dot() {
                next();
                return is_digit(peek())
                        ? read_num(".")
                        : token("punc", ".");
        };

        function read_word() {
                var word = read_name();
                return !HOP(KEYWORDS, word)
                        ? token("name", word)
                        : HOP(OPERATORS, word)
                        ? token("operator", word)
                        : HOP(KEYWORDS_ATOM, word)
                        ? token("atom", word)
                        : token("keyword", word);
        };

        function with_eof_error(eof_error, cont) {
                try {
                        return cont();
                } catch(ex) {
                        if (ex === EX_EOF) parse_error(eof_error);
                        else throw ex;
                }
        };

        function next_token(force_regexp) {
                if (force_regexp != null)
                        return read_regexp(force_regexp);
                skip_whitespace();
                start_token();
                var ch = peek();
                if (!ch) return token("eof");
                if (is_digit(ch)) return read_num();
                if (ch == '"' || ch == "'") return read_string();
                if (HOP(PUNC_CHARS, ch)) return token("punc", next());
                if (ch == ".") return handle_dot();
                if (ch == "/") return handle_slash();
                if (HOP(OPERATOR_CHARS, ch)) return read_operator();
                if (ch == "\\" || is_identifier_start(ch)) return read_word();
                parse_error("Unexpected character '" + ch + "'");
        };

        next_token.context = function(nc) {
                if (nc) S = nc;
                return S;
        };

        return next_token;

};

/* -----[ Parser (constants) ]----- */

var UNARY_PREFIX = array_to_hash([
        "typeof",
        "void",
        "delete",
        "--",
        "++",
        "!",
        "~",
        "-",
        "+"
]);

var UNARY_POSTFIX = array_to_hash([ "--", "++" ]);

var ASSIGNMENT = (function(a, ret, i){
        while (i < a.length) {
                ret[a[i]] = a[i].substr(0, a[i].length - 1);
                i++;
        }
        return ret;
})(
        ["+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&="],
        { "=": true },
        0
);

var PRECEDENCE = (function(a, ret){
        for (var i = 0, n = 1; i < a.length; ++i, ++n) {
                var b = a[i];
                for (var j = 0; j < b.length; ++j) {
                        ret[b[j]] = n;
                }
        }
        return ret;
})(
        [
                ["||"],
                ["&&"],
                ["|"],
                ["^"],
                ["&"],
                ["==", "===", "!=", "!=="],
                ["<", ">", "<=", ">=", "in", "instanceof"],
                [">>", "<<", ">>>"],
                ["+", "-"],
                ["*", "/", "%"]
        ],
        {}
);

var STATEMENTS_WITH_LABELS = array_to_hash([ "for", "do", "while", "switch" ]);

var ATOMIC_START_TOKEN = array_to_hash([ "atom", "num", "string", "regexp", "name" ]);

/* -----[ Parser ]----- */

function NodeWithToken(str, start, end) {
        this.name = str;
        this.start = start;
        this.end = end;
};

NodeWithToken.prototype.toString = function() { return this.name; };

function parse($TEXT, exigent_mode, embed_tokens) {

        var S = {
                input         : typeof $TEXT == "string" ? tokenizer($TEXT, true) : $TEXT,
                token         : null,
                prev          : null,
                peeked        : null,
                in_function   : 0,
                in_directives : true,
                in_loop       : 0,
                labels        : []
        };

        S.token = next();

        function is(type, value) {
                return is_token(S.token, type, value);
        };

        function peek() { return S.peeked || (S.peeked = S.input()); };

        function next() {
                S.prev = S.token;
                if (S.peeked) {
                        S.token = S.peeked;
                        S.peeked = null;
                } else {
                        S.token = S.input();
                }
                S.in_directives = S.in_directives && (
                        S.token.type == "string" || is("punc", ";")
                );
                return S.token;
        };

        function prev() {
                return S.prev;
        };

        function croak(msg, line, col, pos) {
                var ctx = S.input.context();
                js_error(msg,
                         line != null ? line : ctx.tokline,
                         col != null ? col : ctx.tokcol,
                         pos != null ? pos : ctx.tokpos);
        };

        function token_error(token, msg) {
                croak(msg, token.line, token.col);
        };

        function unexpected(token) {
                if (token == null)
                        token = S.token;
                token_error(token, "Unexpected token: " + token.type + " (" + token.value + ")");
        };

        function expect_token(type, val) {
                if (is(type, val)) {
                        return next();
                }
                token_error(S.token, "Unexpected token " + S.token.type + ", expected " + type);
        };

        function expect(punc) { return expect_token("punc", punc); };

        function can_insert_semicolon() {
                return !exigent_mode && (
                        S.token.nlb || is("eof") || is("punc", "}")
                );
        };

        function semicolon() {
                if (is("punc", ";")) next();
                else if (!can_insert_semicolon()) unexpected();
        };

        function as() {
                return slice(arguments);
        };

        function parenthesised() {
                expect("(");
                var ex = expression();
                expect(")");
                return ex;
        };

        function add_tokens(str, start, end) {
                return str instanceof NodeWithToken ? str : new NodeWithToken(str, start, end);
        };

        function maybe_embed_tokens(parser) {
                if (embed_tokens) return function() {
                        var start = S.token;
                        var ast = parser.apply(this, arguments);
                        ast[0] = add_tokens(ast[0], start, prev());
                        return ast;
                };
                else return parser;
        };

        var statement = maybe_embed_tokens(function() {
                if (is("operator", "/") || is("operator", "/=")) {
                        S.peeked = null;
                        S.token = S.input(S.token.value.substr(1)); // force regexp
                }
                switch (S.token.type) {
                    case "string":
                        var dir = S.in_directives, stat = simple_statement();
                        if (dir && stat[1][0] == "string" && !is("punc", ","))
                            return as("directive", stat[1][1]);
                        return stat;
                    case "num":
                    case "regexp":
                    case "operator":
                    case "atom":
                        return simple_statement();

                    case "name":
                        return is_token(peek(), "punc", ":")
                                ? labeled_statement(prog1(S.token.value, next, next))
                                : simple_statement();

                    case "punc":
                        switch (S.token.value) {
                            case "{":
                                return as("block", block_());
                            case "[":
                            case "(":
                                return simple_statement();
                            case ";":
                                next();
                                return as("block");
                            default:
                                unexpected();
                        }

                    case "keyword":
                        switch (prog1(S.token.value, next)) {
                            case "break":
                                return break_cont("break");

                            case "continue":
                                return break_cont("continue");

                            case "debugger":
                                semicolon();
                                return as("debugger");

                            case "do":
                                return (function(body){
                                        expect_token("keyword", "while");
                                        return as("do", prog1(parenthesised, semicolon), body);
                                })(in_loop(statement));

                            case "for":
                                return for_();

                            case "function":
                                return function_(true);

                            case "if":
                                return if_();

                            case "return":
                                if (S.in_function == 0)
                                        croak("'return' outside of function");
                                return as("return",
                                          is("punc", ";")
                                          ? (next(), null)
                                          : can_insert_semicolon()
                                          ? null
                                          : prog1(expression, semicolon));

                            case "switch":
                                return as("switch", parenthesised(), switch_block_());

                            case "throw":
                                if (S.token.nlb)
                                        croak("Illegal newline after 'throw'");
                                return as("throw", prog1(expression, semicolon));

                            case "try":
                                return try_();

                            case "var":
                                return prog1(var_, semicolon);

                            case "const":
                                return prog1(const_, semicolon);

                            case "while":
                                return as("while", parenthesised(), in_loop(statement));

                            case "with":
                                return as("with", parenthesised(), statement());

                            default:
                                unexpected();
                        }
                }
        });

        function labeled_statement(label) {
                S.labels.push(label);
                var start = S.token, stat = statement();
                if (exigent_mode && !HOP(STATEMENTS_WITH_LABELS, stat[0]))
                        unexpected(start);
                S.labels.pop();
                return as("label", label, stat);
        };

        function simple_statement() {
                return as("stat", prog1(expression, semicolon));
        };

        function break_cont(type) {
                var name;
                if (!can_insert_semicolon()) {
                        name = is("name") ? S.token.value : null;
                }
                if (name != null) {
                        next();
                        if (!member(name, S.labels))
                                croak("Label " + name + " without matching loop or statement");
                }
                else if (S.in_loop == 0)
                        croak(type + " not inside a loop or switch");
                semicolon();
                return as(type, name);
        };

        function for_() {
                expect("(");
                var init = null;
                if (!is("punc", ";")) {
                        init = is("keyword", "var")
                                ? (next(), var_(true))
                                : expression(true, true);
                        if (is("operator", "in")) {
                                if (init[0] == "var" && init[1].length > 1)
                                        croak("Only one variable declaration allowed in for..in loop");
                                return for_in(init);
                        }
                }
                return regular_for(init);
        };

        function regular_for(init) {
                expect(";");
                var test = is("punc", ";") ? null : expression();
                expect(";");
                var step = is("punc", ")") ? null : expression();
                expect(")");
                return as("for", init, test, step, in_loop(statement));
        };

        function for_in(init) {
                var lhs = init[0] == "var" ? as("name", init[1][0]) : init;
                next();
                var obj = expression();
                expect(")");
                return as("for-in", init, lhs, obj, in_loop(statement));
        };

        var function_ = function(in_statement) {
                var name = is("name") ? prog1(S.token.value, next) : null;
                if (in_statement && !name)
                        unexpected();
                expect("(");
                return as(in_statement ? "defun" : "function",
                          name,
                          // arguments
                          (function(first, a){
                                  while (!is("punc", ")")) {
                                          if (first) first = false; else expect(",");
                                          if (!is("name")) unexpected();
                                          a.push(S.token.value);
                                          next();
                                  }
                                  next();
                                  return a;
                          })(true, []),
                          // body
                          (function(){
                                  ++S.in_function;
                                  var loop = S.in_loop;
                                  S.in_directives = true;
                                  S.in_loop = 0;
                                  var a = block_();
                                  --S.in_function;
                                  S.in_loop = loop;
                                  return a;
                          })());
        };

        function if_() {
                var cond = parenthesised(), body = statement(), belse;
                if (is("keyword", "else")) {
                        next();
                        belse = statement();
                }
                return as("if", cond, body, belse);
        };

        function block_() {
                expect("{");
                var a = [];
                while (!is("punc", "}")) {
                        if (is("eof")) unexpected();
                        a.push(statement());
                }
                next();
                return a;
        };

        var switch_block_ = curry(in_loop, function(){
                expect("{");
                var a = [], cur = null;
                while (!is("punc", "}")) {
                        if (is("eof")) unexpected();
                        if (is("keyword", "case")) {
                                next();
                                cur = [];
                                a.push([ expression(), cur ]);
                                expect(":");
                        }
                        else if (is("keyword", "default")) {
                                next();
                                expect(":");
                                cur = [];
                                a.push([ null, cur ]);
                        }
                        else {
                                if (!cur) unexpected();
                                cur.push(statement());
                        }
                }
                next();
                return a;
        });

        function try_() {
                var body = block_(), bcatch, bfinally;
                if (is("keyword", "catch")) {
                        next();
                        expect("(");
                        if (!is("name"))
                                croak("Name expected");
                        var name = S.token.value;
                        next();
                        expect(")");
                        bcatch = [ name, block_() ];
                }
                if (is("keyword", "finally")) {
                        next();
                        bfinally = block_();
                }
                if (!bcatch && !bfinally)
                        croak("Missing catch/finally blocks");
                return as("try", body, bcatch, bfinally);
        };

        function vardefs(no_in) {
                var a = [];
                for (;;) {
                        if (!is("name"))
                                unexpected();
                        var name = S.token.value;
                        next();
                        if (is("operator", "=")) {
                                next();
                                a.push([ name, expression(false, no_in) ]);
                        } else {
                                a.push([ name ]);
                        }
                        if (!is("punc", ","))
                                break;
                        next();
                }
                return a;
        };

        function var_(no_in) {
                return as("var", vardefs(no_in));
        };

        function const_() {
                return as("const", vardefs());
        };

        function new_() {
                var newexp = expr_atom(false), args;
                if (is("punc", "(")) {
                        next();
                        args = expr_list(")");
                } else {
                        args = [];
                }
                return subscripts(as("new", newexp, args), true);
        };

        var expr_atom = maybe_embed_tokens(function(allow_calls) {
                if (is("operator", "new")) {
                        next();
                        return new_();
                }
                if (is("punc")) {
                        switch (S.token.value) {
                            case "(":
                                next();
                                return subscripts(prog1(expression, curry(expect, ")")), allow_calls);
                            case "[":
                                next();
                                return subscripts(array_(), allow_calls);
                            case "{":
                                next();
                                return subscripts(object_(), allow_calls);
                        }
                        unexpected();
                }
                if (is("keyword", "function")) {
                        next();
                        return subscripts(function_(false), allow_calls);
                }
                if (HOP(ATOMIC_START_TOKEN, S.token.type)) {
                        var atom = S.token.type == "regexp"
                                ? as("regexp", S.token.value[0], S.token.value[1])
                                : as(S.token.type, S.token.value);
                        return subscripts(prog1(atom, next), allow_calls);
                }
                unexpected();
        });

        function expr_list(closing, allow_trailing_comma, allow_empty) {
                var first = true, a = [];
                while (!is("punc", closing)) {
                        if (first) first = false; else expect(",");
                        if (allow_trailing_comma && is("punc", closing)) break;
                        if (is("punc", ",") && allow_empty) {
                                a.push([ "atom", "undefined" ]);
                        } else {
                                a.push(expression(false));
                        }
                }
                next();
                return a;
        };

        function array_() {
                return as("array", expr_list("]", !exigent_mode, true));
        };

        function object_() {
                var first = true, a = [];
                while (!is("punc", "}")) {
                        if (first) first = false; else expect(",");
                        if (!exigent_mode && is("punc", "}"))
                                // allow trailing comma
                                break;
                        var type = S.token.type;
                        var name = as_property_name();
                        if (type == "name" && (name == "get" || name == "set") && !is("punc", ":")) {
                                a.push([ as_name(), function_(false), name ]);
                        } else {
                                expect(":");
                                a.push([ name, expression(false) ]);
                        }
                }
                next();
                return as("object", a);
        };

        function as_property_name() {
                switch (S.token.type) {
                    case "num":
                    case "string":
                        return prog1(S.token.value, next);
                }
                return as_name();
        };

        function as_name() {
                switch (S.token.type) {
                    case "name":
                    case "operator":
                    case "keyword":
                    case "atom":
                        return prog1(S.token.value, next);
                    default:
                        unexpected();
                }
        };

        function subscripts(expr, allow_calls) {
                if (is("punc", ".")) {
                        next();
                        return subscripts(as("dot", expr, as_name()), allow_calls);
                }
                if (is("punc", "[")) {
                        next();
                        return subscripts(as("sub", expr, prog1(expression, curry(expect, "]"))), allow_calls);
                }
                if (allow_calls && is("punc", "(")) {
                        next();
                        return subscripts(as("call", expr, expr_list(")")), true);
                }
                return expr;
        };

        function maybe_unary(allow_calls) {
                if (is("operator") && HOP(UNARY_PREFIX, S.token.value)) {
                        return make_unary("unary-prefix",
                                          prog1(S.token.value, next),
                                          maybe_unary(allow_calls));
                }
                var val = expr_atom(allow_calls);
                while (is("operator") && HOP(UNARY_POSTFIX, S.token.value) && !S.token.nlb) {
                        val = make_unary("unary-postfix", S.token.value, val);
                        next();
                }
                return val;
        };

        function make_unary(tag, op, expr) {
                if ((op == "++" || op == "--") && !is_assignable(expr))
                        croak("Invalid use of " + op + " operator");
                return as(tag, op, expr);
        };

        function expr_op(left, min_prec, no_in) {
                var op = is("operator") ? S.token.value : null;
                if (op && op == "in" && no_in) op = null;
                var prec = op != null ? PRECEDENCE[op] : null;
                if (prec != null && prec > min_prec) {
                        next();
                        var right = expr_op(maybe_unary(true), prec, no_in);
                        return expr_op(as("binary", op, left, right), min_prec, no_in);
                }
                return left;
        };

        function expr_ops(no_in) {
                return expr_op(maybe_unary(true), 0, no_in);
        };

        function maybe_conditional(no_in) {
                var expr = expr_ops(no_in);
                if (is("operator", "?")) {
                        next();
                        var yes = expression(false);
                        expect(":");
                        return as("conditional", expr, yes, expression(false, no_in));
                }
                return expr;
        };

        function is_assignable(expr) {
                if (!exigent_mode) return true;
                switch (expr[0]+"") {
                    case "dot":
                    case "sub":
                    case "new":
                    case "call":
                        return true;
                    case "name":
                        return expr[1] != "this";
                }
        };

        function maybe_assign(no_in) {
                var left = maybe_conditional(no_in), val = S.token.value;
                if (is("operator") && HOP(ASSIGNMENT, val)) {
                        if (is_assignable(left)) {
                                next();
                                return as("assign", ASSIGNMENT[val], left, maybe_assign(no_in));
                        }
                        croak("Invalid assignment");
                }
                return left;
        };

        var expression = maybe_embed_tokens(function(commas, no_in) {
                if (arguments.length == 0)
                        commas = true;
                var expr = maybe_assign(no_in);
                if (commas && is("punc", ",")) {
                        next();
                        return as("seq", expr, expression(true, no_in));
                }
                return expr;
        });

        function in_loop(cont) {
                try {
                        ++S.in_loop;
                        return cont();
                } finally {
                        --S.in_loop;
                }
        };

        return as("toplevel", (function(a){
                while (!is("eof"))
                        a.push(statement());
                return a;
        })([]));

};

/* -----[ Utilities ]----- */

function curry(f) {
        var args = slice(arguments, 1);
        return function() { return f.apply(this, args.concat(slice(arguments))); };
};

function prog1(ret) {
        if (ret instanceof Function)
                ret = ret();
        for (var i = 1, n = arguments.length; --n > 0; ++i)
                arguments[i]();
        return ret;
};

function array_to_hash(a) {
        var ret = {};
        for (var i = 0; i < a.length; ++i)
                ret[a[i]] = true;
        return ret;
};

function slice(a, start) {
        return Array.prototype.slice.call(a, start || 0);
};

function characters(str) {
        return str.split("");
};

function member(name, array) {
        for (var i = array.length; --i >= 0;)
                if (array[i] == name)
                        return true;
        return false;
};

function HOP(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
};

var warn = function() {};

/* -----[ Exports ]----- */

exports.tokenizer = tokenizer;
exports.parse = parse;
exports.slice = slice;
exports.curry = curry;
exports.member = member;
exports.array_to_hash = array_to_hash;
exports.PRECEDENCE = PRECEDENCE;
exports.KEYWORDS_ATOM = KEYWORDS_ATOM;
exports.RESERVED_WORDS = RESERVED_WORDS;
exports.KEYWORDS = KEYWORDS;
exports.ATOMIC_START_TOKEN = ATOMIC_START_TOKEN;
exports.OPERATORS = OPERATORS;
exports.is_alphanumeric_char = is_alphanumeric_char;
exports.is_identifier_start = is_identifier_start;
exports.is_identifier_char = is_identifier_char;
exports.set_logger = function(logger) {
        warn = logger;
};

// Local variables:
// js-indent-level: 8
// End:

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/process.js":[function(require,module,exports){
/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.

  This version is suitable for Node.js.  With minimal changes (the
  exports stuff) it should work on any JS platform.

  This file implements some AST processors.  They work on data built
  by parse-js.

  Exported functions:

    - ast_mangle(ast, options) -- mangles the variable/function names
      in the AST.  Returns an AST.

    - ast_squeeze(ast) -- employs various optimizations to make the
      final generated code even smaller.  Returns an AST.

    - gen_code(ast, options) -- generates JS code from the AST.  Pass
      true (or an object, see the code for some options) as second
      argument to get "pretty" (indented) code.

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2010 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

var jsp = require("./parse-js"),
    curry = jsp.curry,
    slice = jsp.slice,
    member = jsp.member,
    is_identifier_char = jsp.is_identifier_char,
    PRECEDENCE = jsp.PRECEDENCE,
    OPERATORS = jsp.OPERATORS;

/* -----[ helper for AST traversal ]----- */

function ast_walker() {
        function _vardefs(defs) {
                return [ this[0], MAP(defs, function(def){
                        var a = [ def[0] ];
                        if (def.length > 1)
                                a[1] = walk(def[1]);
                        return a;
                }) ];
        };
        function _block(statements) {
                var out = [ this[0] ];
                if (statements != null)
                        out.push(MAP(statements, walk));
                return out;
        };
        var walkers = {
                "string": function(str) {
                        return [ this[0], str ];
                },
                "num": function(num) {
                        return [ this[0], num ];
                },
                "name": function(name) {
                        return [ this[0], name ];
                },
                "toplevel": function(statements) {
                        return [ this[0], MAP(statements, walk) ];
                },
                "block": _block,
                "splice": _block,
                "var": _vardefs,
                "const": _vardefs,
                "try": function(t, c, f) {
                        return [
                                this[0],
                                MAP(t, walk),
                                c != null ? [ c[0], MAP(c[1], walk) ] : null,
                                f != null ? MAP(f, walk) : null
                        ];
                },
                "throw": function(expr) {
                        return [ this[0], walk(expr) ];
                },
                "new": function(ctor, args) {
                        return [ this[0], walk(ctor), MAP(args, walk) ];
                },
                "switch": function(expr, body) {
                        return [ this[0], walk(expr), MAP(body, function(branch){
                                return [ branch[0] ? walk(branch[0]) : null,
                                         MAP(branch[1], walk) ];
                        }) ];
                },
                "break": function(label) {
                        return [ this[0], label ];
                },
                "continue": function(label) {
                        return [ this[0], label ];
                },
                "conditional": function(cond, t, e) {
                        return [ this[0], walk(cond), walk(t), walk(e) ];
                },
                "assign": function(op, lvalue, rvalue) {
                        return [ this[0], op, walk(lvalue), walk(rvalue) ];
                },
                "dot": function(expr) {
                        return [ this[0], walk(expr) ].concat(slice(arguments, 1));
                },
                "call": function(expr, args) {
                        return [ this[0], walk(expr), MAP(args, walk) ];
                },
                "function": function(name, args, body) {
                        return [ this[0], name, args.slice(), MAP(body, walk) ];
                },
                "debugger": function() {
                        return [ this[0] ];
                },
                "defun": function(name, args, body) {
                        return [ this[0], name, args.slice(), MAP(body, walk) ];
                },
                "if": function(conditional, t, e) {
                        return [ this[0], walk(conditional), walk(t), walk(e) ];
                },
                "for": function(init, cond, step, block) {
                        return [ this[0], walk(init), walk(cond), walk(step), walk(block) ];
                },
                "for-in": function(vvar, key, hash, block) {
                        return [ this[0], walk(vvar), walk(key), walk(hash), walk(block) ];
                },
                "while": function(cond, block) {
                        return [ this[0], walk(cond), walk(block) ];
                },
                "do": function(cond, block) {
                        return [ this[0], walk(cond), walk(block) ];
                },
                "return": function(expr) {
                        return [ this[0], walk(expr) ];
                },
                "binary": function(op, left, right) {
                        return [ this[0], op, walk(left), walk(right) ];
                },
                "unary-prefix": function(op, expr) {
                        return [ this[0], op, walk(expr) ];
                },
                "unary-postfix": function(op, expr) {
                        return [ this[0], op, walk(expr) ];
                },
                "sub": function(expr, subscript) {
                        return [ this[0], walk(expr), walk(subscript) ];
                },
                "object": function(props) {
                        return [ this[0], MAP(props, function(p){
                                return p.length == 2
                                        ? [ p[0], walk(p[1]) ]
                                        : [ p[0], walk(p[1]), p[2] ]; // get/set-ter
                        }) ];
                },
                "regexp": function(rx, mods) {
                        return [ this[0], rx, mods ];
                },
                "array": function(elements) {
                        return [ this[0], MAP(elements, walk) ];
                },
                "stat": function(stat) {
                        return [ this[0], walk(stat) ];
                },
                "seq": function() {
                        return [ this[0] ].concat(MAP(slice(arguments), walk));
                },
                "label": function(name, block) {
                        return [ this[0], name, walk(block) ];
                },
                "with": function(expr, block) {
                        return [ this[0], walk(expr), walk(block) ];
                },
                "atom": function(name) {
                        return [ this[0], name ];
                },
                "directive": function(dir) {
                        return [ this[0], dir ];
                }
        };

        var user = {};
        var stack = [];
        function walk(ast) {
                if (ast == null)
                        return null;
                try {
                        stack.push(ast);
                        var type = ast[0];
                        var gen = user[type];
                        if (gen) {
                                var ret = gen.apply(ast, ast.slice(1));
                                if (ret != null)
                                        return ret;
                        }
                        gen = walkers[type];
                        return gen.apply(ast, ast.slice(1));
                } finally {
                        stack.pop();
                }
        };

        function dive(ast) {
                if (ast == null)
                        return null;
                try {
                        stack.push(ast);
                        return walkers[ast[0]].apply(ast, ast.slice(1));
                } finally {
                        stack.pop();
                }
        };

        function with_walkers(walkers, cont){
                var save = {}, i;
                for (i in walkers) if (HOP(walkers, i)) {
                        save[i] = user[i];
                        user[i] = walkers[i];
                }
                var ret = cont();
                for (i in save) if (HOP(save, i)) {
                        if (!save[i]) delete user[i];
                        else user[i] = save[i];
                }
                return ret;
        };

        return {
                walk: walk,
                dive: dive,
                with_walkers: with_walkers,
                parent: function() {
                        return stack[stack.length - 2]; // last one is current node
                },
                stack: function() {
                        return stack;
                }
        };
};

/* -----[ Scope and mangling ]----- */

function Scope(parent) {
        this.names = {};        // names defined in this scope
        this.mangled = {};      // mangled names (orig.name => mangled)
        this.rev_mangled = {};  // reverse lookup (mangled => orig.name)
        this.cname = -1;        // current mangled name
        this.refs = {};         // names referenced from this scope
        this.uses_with = false; // will become TRUE if with() is detected in this or any subscopes
        this.uses_eval = false; // will become TRUE if eval() is detected in this or any subscopes
        this.directives = [];   // directives activated from this scope
        this.parent = parent;   // parent scope
        this.children = [];     // sub-scopes
        if (parent) {
                this.level = parent.level + 1;
                parent.children.push(this);
        } else {
                this.level = 0;
        }
};

function base54_digits() {
        if (typeof DIGITS_OVERRIDE_FOR_TESTING != "undefined")
                return DIGITS_OVERRIDE_FOR_TESTING;
        else
                return "etnrisouaflchpdvmgybwESxTNCkLAOM_DPHBjFIqRUzWXV$JKQGYZ0516372984";
}

var base54 = (function(){
        var DIGITS = base54_digits();
        return function(num) {
                var ret = "", base = 54;
                do {
                        ret += DIGITS.charAt(num % base);
                        num = Math.floor(num / base);
                        base = 64;
                } while (num > 0);
                return ret;
        };
})();

Scope.prototype = {
        has: function(name) {
                for (var s = this; s; s = s.parent)
                        if (HOP(s.names, name))
                                return s;
        },
        has_mangled: function(mname) {
                for (var s = this; s; s = s.parent)
                        if (HOP(s.rev_mangled, mname))
                                return s;
        },
        toJSON: function() {
                return {
                        names: this.names,
                        uses_eval: this.uses_eval,
                        uses_with: this.uses_with
                };
        },

        next_mangled: function() {
                // we must be careful that the new mangled name:
                //
                // 1. doesn't shadow a mangled name from a parent
                //    scope, unless we don't reference the original
                //    name from this scope OR from any sub-scopes!
                //    This will get slow.
                //
                // 2. doesn't shadow an original name from a parent
                //    scope, in the event that the name is not mangled
                //    in the parent scope and we reference that name
                //    here OR IN ANY SUBSCOPES!
                //
                // 3. doesn't shadow a name that is referenced but not
                //    defined (possibly global defined elsewhere).
                for (;;) {
                        var m = base54(++this.cname), prior;

                        // case 1.
                        prior = this.has_mangled(m);
                        if (prior && this.refs[prior.rev_mangled[m]] === prior)
                                continue;

                        // case 2.
                        prior = this.has(m);
                        if (prior && prior !== this && this.refs[m] === prior && !prior.has_mangled(m))
                                continue;

                        // case 3.
                        if (HOP(this.refs, m) && this.refs[m] == null)
                                continue;

                        // I got "do" once. :-/
                        if (!is_identifier(m))
                                continue;

                        return m;
                }
        },
        set_mangle: function(name, m) {
                this.rev_mangled[m] = name;
                return this.mangled[name] = m;
        },
        get_mangled: function(name, newMangle) {
                if (this.uses_eval || this.uses_with) return name; // no mangle if eval or with is in use
                var s = this.has(name);
                if (!s) return name; // not in visible scope, no mangle
                if (HOP(s.mangled, name)) return s.mangled[name]; // already mangled in this scope
                if (!newMangle) return name;                      // not found and no mangling requested
                return s.set_mangle(name, s.next_mangled());
        },
        references: function(name) {
                return name && !this.parent || this.uses_with || this.uses_eval || this.refs[name];
        },
        define: function(name, type) {
                if (name != null) {
                        if (type == "var" || !HOP(this.names, name))
                                this.names[name] = type || "var";
                        return name;
                }
        },
        active_directive: function(dir) {
                return member(dir, this.directives) || this.parent && this.parent.active_directive(dir);
        }
};

function ast_add_scope(ast) {

        var current_scope = null;
        var w = ast_walker(), walk = w.walk;
        var having_eval = [];

        function with_new_scope(cont) {
                current_scope = new Scope(current_scope);
                current_scope.labels = new Scope();
                var ret = current_scope.body = cont();
                ret.scope = current_scope;
                current_scope = current_scope.parent;
                return ret;
        };

        function define(name, type) {
                return current_scope.define(name, type);
        };

        function reference(name) {
                current_scope.refs[name] = true;
        };

        function _lambda(name, args, body) {
                var is_defun = this[0] == "defun";
                return [ this[0], is_defun ? define(name, "defun") : name, args, with_new_scope(function(){
                        if (!is_defun) define(name, "lambda");
                        MAP(args, function(name){ define(name, "arg") });
                        return MAP(body, walk);
                })];
        };

        function _vardefs(type) {
                return function(defs) {
                        MAP(defs, function(d){
                                define(d[0], type);
                                if (d[1]) reference(d[0]);
                        });
                };
        };

        function _breacont(label) {
                if (label)
                        current_scope.labels.refs[label] = true;
        };

        return with_new_scope(function(){
                // process AST
                var ret = w.with_walkers({
                        "function": _lambda,
                        "defun": _lambda,
                        "label": function(name, stat) { current_scope.labels.define(name) },
                        "break": _breacont,
                        "continue": _breacont,
                        "with": function(expr, block) {
                                for (var s = current_scope; s; s = s.parent)
                                        s.uses_with = true;
                        },
                        "var": _vardefs("var"),
                        "const": _vardefs("const"),
                        "try": function(t, c, f) {
                                if (c != null) return [
                                        this[0],
                                        MAP(t, walk),
                                        [ define(c[0], "catch"), MAP(c[1], walk) ],
                                        f != null ? MAP(f, walk) : null
                                ];
                        },
                        "name": function(name) {
                                if (name == "eval")
                                        having_eval.push(current_scope);
                                reference(name);
                        }
                }, function(){
                        return walk(ast);
                });

                // the reason why we need an additional pass here is
                // that names can be used prior to their definition.

                // scopes where eval was detected and their parents
                // are marked with uses_eval, unless they define the
                // "eval" name.
                MAP(having_eval, function(scope){
                        if (!scope.has("eval")) while (scope) {
                                scope.uses_eval = true;
                                scope = scope.parent;
                        }
                });

                // for referenced names it might be useful to know
                // their origin scope.  current_scope here is the
                // toplevel one.
                function fixrefs(scope, i) {
                        // do children first; order shouldn't matter
                        for (i = scope.children.length; --i >= 0;)
                                fixrefs(scope.children[i]);
                        for (i in scope.refs) if (HOP(scope.refs, i)) {
                                // find origin scope and propagate the reference to origin
                                for (var origin = scope.has(i), s = scope; s; s = s.parent) {
                                        s.refs[i] = origin;
                                        if (s === origin) break;
                                }
                        }
                };
                fixrefs(current_scope);

                return ret;
        });

};

/* -----[ mangle names ]----- */

function ast_mangle(ast, options) {
        var w = ast_walker(), walk = w.walk, scope;
        options = defaults(options, {
                mangle       : true,
                toplevel     : false,
                defines      : null,
                except       : null,
                no_functions : false
        });

        function get_mangled(name, newMangle) {
                if (!options.mangle) return name;
                if (!options.toplevel && !scope.parent) return name; // don't mangle toplevel
                if (options.except && member(name, options.except))
                        return name;
                if (options.no_functions && HOP(scope.names, name) &&
                    (scope.names[name] == 'defun' || scope.names[name] == 'lambda'))
                        return name;
                return scope.get_mangled(name, newMangle);
        };

        function get_define(name) {
                if (options.defines) {
                        // we always lookup a defined symbol for the current scope FIRST, so declared
                        // vars trump a DEFINE symbol, but if no such var is found, then match a DEFINE value
                        if (!scope.has(name)) {
                                if (HOP(options.defines, name)) {
                                        return options.defines[name];
                                }
                        }
                        return null;
                }
        };

        function _lambda(name, args, body) {
                if (!options.no_functions && options.mangle) {
                        var is_defun = this[0] == "defun", extra;
                        if (name) {
                                if (is_defun) name = get_mangled(name);
                                else if (body.scope.references(name)) {
                                        extra = {};
                                        if (!(scope.uses_eval || scope.uses_with))
                                                name = extra[name] = scope.next_mangled();
                                        else
                                                extra[name] = name;
                                }
                                else name = null;
                        }
                }
                body = with_scope(body.scope, function(){
                        args = MAP(args, function(name){ return get_mangled(name) });
                        return MAP(body, walk);
                }, extra);
                return [ this[0], name, args, body ];
        };

        function with_scope(s, cont, extra) {
                var _scope = scope;
                scope = s;
                if (extra) for (var i in extra) if (HOP(extra, i)) {
                        s.set_mangle(i, extra[i]);
                }
                for (var i in s.names) if (HOP(s.names, i)) {
                        get_mangled(i, true);
                }
                var ret = cont();
                ret.scope = s;
                scope = _scope;
                return ret;
        };

        function _vardefs(defs) {
                return [ this[0], MAP(defs, function(d){
                        return [ get_mangled(d[0]), walk(d[1]) ];
                }) ];
        };

        function _breacont(label) {
                if (label) return [ this[0], scope.labels.get_mangled(label) ];
        };

        return w.with_walkers({
                "function": _lambda,
                "defun": function() {
                        // move function declarations to the top when
                        // they are not in some block.
                        var ast = _lambda.apply(this, arguments);
                        switch (w.parent()[0]) {
                            case "toplevel":
                            case "function":
                            case "defun":
                                return MAP.at_top(ast);
                        }
                        return ast;
                },
                "label": function(label, stat) {
                        if (scope.labels.refs[label]) return [
                                this[0],
                                scope.labels.get_mangled(label, true),
                                walk(stat)
                        ];
                        return walk(stat);
                },
                "break": _breacont,
                "continue": _breacont,
                "var": _vardefs,
                "const": _vardefs,
                "name": function(name) {
                        return get_define(name) || [ this[0], get_mangled(name) ];
                },
                "try": function(t, c, f) {
                        return [ this[0],
                                 MAP(t, walk),
                                 c != null ? [ get_mangled(c[0]), MAP(c[1], walk) ] : null,
                                 f != null ? MAP(f, walk) : null ];
                },
                "toplevel": function(body) {
                        var self = this;
                        return with_scope(self.scope, function(){
                                return [ self[0], MAP(body, walk) ];
                        });
                },
                "directive": function() {
                        return MAP.at_top(this);
                }
        }, function() {
                return walk(ast_add_scope(ast));
        });
};

/* -----[
   - compress foo["bar"] into foo.bar,
   - remove block brackets {} where possible
   - join consecutive var declarations
   - various optimizations for IFs:
     - if (cond) foo(); else bar();  ==>  cond?foo():bar();
     - if (cond) foo();  ==>  cond&&foo();
     - if (foo) return bar(); else return baz();  ==> return foo?bar():baz(); // also for throw
     - if (foo) return bar(); else something();  ==> {if(foo)return bar();something()}
   ]----- */

var warn = function(){};

function best_of(ast1, ast2) {
        return gen_code(ast1).length > gen_code(ast2[0] == "stat" ? ast2[1] : ast2).length ? ast2 : ast1;
};

function last_stat(b) {
        if (b[0] == "block" && b[1] && b[1].length > 0)
                return b[1][b[1].length - 1];
        return b;
}

function aborts(t) {
        if (t) switch (last_stat(t)[0]) {
            case "return":
            case "break":
            case "continue":
            case "throw":
                return true;
        }
};

function boolean_expr(expr) {
        return ( (expr[0] == "unary-prefix"
                  && member(expr[1], [ "!", "delete" ])) ||

                 (expr[0] == "binary"
                  && member(expr[1], [ "in", "instanceof", "==", "!=", "===", "!==", "<", "<=", ">=", ">" ])) ||

                 (expr[0] == "binary"
                  && member(expr[1], [ "&&", "||" ])
                  && boolean_expr(expr[2])
                  && boolean_expr(expr[3])) ||

                 (expr[0] == "conditional"
                  && boolean_expr(expr[2])
                  && boolean_expr(expr[3])) ||

                 (expr[0] == "assign"
                  && expr[1] === true
                  && boolean_expr(expr[3])) ||

                 (expr[0] == "seq"
                  && boolean_expr(expr[expr.length - 1]))
               );
};

function empty(b) {
        return !b || (b[0] == "block" && (!b[1] || b[1].length == 0));
};

function is_string(node) {
        return (node[0] == "string" ||
                node[0] == "unary-prefix" && node[1] == "typeof" ||
                node[0] == "binary" && node[1] == "+" &&
                (is_string(node[2]) || is_string(node[3])));
};

var when_constant = (function(){

        var $NOT_CONSTANT = {};

        // this can only evaluate constant expressions.  If it finds anything
        // not constant, it throws $NOT_CONSTANT.
        function evaluate(expr) {
                switch (expr[0]) {
                    case "string":
                    case "num":
                        return expr[1];
                    case "name":
                    case "atom":
                        switch (expr[1]) {
                            case "true": return true;
                            case "false": return false;
                            case "null": return null;
                        }
                        break;
                    case "unary-prefix":
                        switch (expr[1]) {
                            case "!": return !evaluate(expr[2]);
                            case "typeof": return typeof evaluate(expr[2]);
                            case "~": return ~evaluate(expr[2]);
                            case "-": return -evaluate(expr[2]);
                            case "+": return +evaluate(expr[2]);
                        }
                        break;
                    case "binary":
                        var left = expr[2], right = expr[3];
                        switch (expr[1]) {
                            case "&&"         : return evaluate(left) &&         evaluate(right);
                            case "||"         : return evaluate(left) ||         evaluate(right);
                            case "|"          : return evaluate(left) |          evaluate(right);
                            case "&"          : return evaluate(left) &          evaluate(right);
                            case "^"          : return evaluate(left) ^          evaluate(right);
                            case "+"          : return evaluate(left) +          evaluate(right);
                            case "*"          : return evaluate(left) *          evaluate(right);
                            case "/"          : return evaluate(left) /          evaluate(right);
                            case "%"          : return evaluate(left) %          evaluate(right);
                            case "-"          : return evaluate(left) -          evaluate(right);
                            case "<<"         : return evaluate(left) <<         evaluate(right);
                            case ">>"         : return evaluate(left) >>         evaluate(right);
                            case ">>>"        : return evaluate(left) >>>        evaluate(right);
                            case "=="         : return evaluate(left) ==         evaluate(right);
                            case "==="        : return evaluate(left) ===        evaluate(right);
                            case "!="         : return evaluate(left) !=         evaluate(right);
                            case "!=="        : return evaluate(left) !==        evaluate(right);
                            case "<"          : return evaluate(left) <          evaluate(right);
                            case "<="         : return evaluate(left) <=         evaluate(right);
                            case ">"          : return evaluate(left) >          evaluate(right);
                            case ">="         : return evaluate(left) >=         evaluate(right);
                            case "in"         : return evaluate(left) in         evaluate(right);
                            case "instanceof" : return evaluate(left) instanceof evaluate(right);
                        }
                }
                throw $NOT_CONSTANT;
        };

        return function(expr, yes, no) {
                try {
                        var val = evaluate(expr), ast;
                        switch (typeof val) {
                            case "string": ast =  [ "string", val ]; break;
                            case "number": ast =  [ "num", val ]; break;
                            case "boolean": ast =  [ "name", String(val) ]; break;
                            default:
                                if (val === null) { ast = [ "atom", "null" ]; break; }
                                throw new Error("Can't handle constant of type: " + (typeof val));
                        }
                        return yes.call(expr, ast, val);
                } catch(ex) {
                        if (ex === $NOT_CONSTANT) {
                                if (expr[0] == "binary"
                                    && (expr[1] == "===" || expr[1] == "!==")
                                    && ((is_string(expr[2]) && is_string(expr[3]))
                                        || (boolean_expr(expr[2]) && boolean_expr(expr[3])))) {
                                        expr[1] = expr[1].substr(0, 2);
                                }
                                else if (no && expr[0] == "binary"
                                         && (expr[1] == "||" || expr[1] == "&&")) {
                                    // the whole expression is not constant but the lval may be...
                                    try {
                                        var lval = evaluate(expr[2]);
                                        expr = ((expr[1] == "&&" && (lval ? expr[3] : lval))    ||
                                                (expr[1] == "||" && (lval ? lval    : expr[3])) ||
                                                expr);
                                    } catch(ex2) {
                                        // IGNORE... lval is not constant
                                    }
                                }
                                return no ? no.call(expr, expr) : null;
                        }
                        else throw ex;
                }
        };

})();

function warn_unreachable(ast) {
        if (!empty(ast))
                warn("Dropping unreachable code: " + gen_code(ast, true));
};

function prepare_ifs(ast) {
        var w = ast_walker(), walk = w.walk;
        // In this first pass, we rewrite ifs which abort with no else with an
        // if-else.  For example:
        //
        // if (x) {
        //     blah();
        //     return y;
        // }
        // foobar();
        //
        // is rewritten into:
        //
        // if (x) {
        //     blah();
        //     return y;
        // } else {
        //     foobar();
        // }
        function redo_if(statements) {
                statements = MAP(statements, walk);

                for (var i = 0; i < statements.length; ++i) {
                        var fi = statements[i];
                        if (fi[0] != "if") continue;

                        if (fi[3]) continue;

                        var t = fi[2];
                        if (!aborts(t)) continue;

                        var conditional = walk(fi[1]);

                        var e_body = redo_if(statements.slice(i + 1));
                        var e = e_body.length == 1 ? e_body[0] : [ "block", e_body ];

                        return statements.slice(0, i).concat([ [
                                fi[0],          // "if"
                                conditional,    // conditional
                                t,              // then
                                e               // else
                        ] ]);
                }

                return statements;
        };

        function redo_if_lambda(name, args, body) {
                body = redo_if(body);
                return [ this[0], name, args, body ];
        };

        function redo_if_block(statements) {
                return [ this[0], statements != null ? redo_if(statements) : null ];
        };

        return w.with_walkers({
                "defun": redo_if_lambda,
                "function": redo_if_lambda,
                "block": redo_if_block,
                "splice": redo_if_block,
                "toplevel": function(statements) {
                        return [ this[0], redo_if(statements) ];
                },
                "try": function(t, c, f) {
                        return [
                                this[0],
                                redo_if(t),
                                c != null ? [ c[0], redo_if(c[1]) ] : null,
                                f != null ? redo_if(f) : null
                        ];
                }
        }, function() {
                return walk(ast);
        });
};

function for_side_effects(ast, handler) {
        var w = ast_walker(), walk = w.walk;
        var $stop = {}, $restart = {};
        function stop() { throw $stop };
        function restart() { throw $restart };
        function found(){ return handler.call(this, this, w, stop, restart) };
        function unary(op) {
                if (op == "++" || op == "--")
                        return found.apply(this, arguments);
        };
        function binary(op) {
                if (op == "&&" || op == "||")
                        return found.apply(this, arguments);
        };
        return w.with_walkers({
                "try": found,
                "throw": found,
                "return": found,
                "new": found,
                "switch": found,
                "break": found,
                "continue": found,
                "assign": found,
                "call": found,
                "if": found,
                "for": found,
                "for-in": found,
                "while": found,
                "do": found,
                "return": found,
                "unary-prefix": unary,
                "unary-postfix": unary,
                "conditional": found,
                "binary": binary,
                "defun": found
        }, function(){
                while (true) try {
                        walk(ast);
                        break;
                } catch(ex) {
                        if (ex === $stop) break;
                        if (ex === $restart) continue;
                        throw ex;
                }
        });
};

function ast_lift_variables(ast) {
        var w = ast_walker(), walk = w.walk, scope;
        function do_body(body, env) {
                var _scope = scope;
                scope = env;
                body = MAP(body, walk);
                var hash = {}, names = MAP(env.names, function(type, name){
                        if (type != "var") return MAP.skip;
                        if (!env.references(name)) return MAP.skip;
                        hash[name] = true;
                        return [ name ];
                });
                if (names.length > 0) {
                        // looking for assignments to any of these variables.
                        // we can save considerable space by moving the definitions
                        // in the var declaration.
                        for_side_effects([ "block", body ], function(ast, walker, stop, restart) {
                                if (ast[0] == "assign"
                                    && ast[1] === true
                                    && ast[2][0] == "name"
                                    && HOP(hash, ast[2][1])) {
                                        // insert the definition into the var declaration
                                        for (var i = names.length; --i >= 0;) {
                                                if (names[i][0] == ast[2][1]) {
                                                        if (names[i][1]) // this name already defined, we must stop
                                                                stop();
                                                        names[i][1] = ast[3]; // definition
                                                        names.push(names.splice(i, 1)[0]);
                                                        break;
                                                }
                                        }
                                        // remove this assignment from the AST.
                                        var p = walker.parent();
                                        if (p[0] == "seq") {
                                                var a = p[2];
                                                a.unshift(0, p.length);
                                                p.splice.apply(p, a);
                                        }
                                        else if (p[0] == "stat") {
                                                p.splice(0, p.length, "block"); // empty statement
                                        }
                                        else {
                                                stop();
                                        }
                                        restart();
                                }
                                stop();
                        });
                        body.unshift([ "var", names ]);
                }
                scope = _scope;
                return body;
        };
        function _vardefs(defs) {
                var ret = null;
                for (var i = defs.length; --i >= 0;) {
                        var d = defs[i];
                        if (!d[1]) continue;
                        d = [ "assign", true, [ "name", d[0] ], d[1] ];
                        if (ret == null) ret = d;
                        else ret = [ "seq", d, ret ];
                }
                if (ret == null && w.parent()[0] != "for") {
                        if (w.parent()[0] == "for-in")
                                return [ "name", defs[0][0] ];
                        return MAP.skip;
                }
                return [ "stat", ret ];
        };
        function _toplevel(body) {
                return [ this[0], do_body(body, this.scope) ];
        };
        return w.with_walkers({
                "function": function(name, args, body){
                        for (var i = args.length; --i >= 0 && !body.scope.references(args[i]);)
                                args.pop();
                        if (!body.scope.references(name)) name = null;
                        return [ this[0], name, args, do_body(body, body.scope) ];
                },
                "defun": function(name, args, body){
                        if (!scope.references(name)) return MAP.skip;
                        for (var i = args.length; --i >= 0 && !body.scope.references(args[i]);)
                                args.pop();
                        return [ this[0], name, args, do_body(body, body.scope) ];
                },
                "var": _vardefs,
                "toplevel": _toplevel
        }, function(){
                return walk(ast_add_scope(ast));
        });
};

function ast_squeeze(ast, options) {
        ast = squeeze_1(ast, options);
        ast = squeeze_2(ast, options);
        return ast;
};

function squeeze_1(ast, options) {
        options = defaults(options, {
                make_seqs   : true,
                dead_code   : true,
                no_warnings : false,
                keep_comps  : true,
                unsafe      : false
        });

        var w = ast_walker(), walk = w.walk, scope;

        function negate(c) {
                var not_c = [ "unary-prefix", "!", c ];
                switch (c[0]) {
                    case "unary-prefix":
                        return c[1] == "!" && boolean_expr(c[2]) ? c[2] : not_c;
                    case "seq":
                        c = slice(c);
                        c[c.length - 1] = negate(c[c.length - 1]);
                        return c;
                    case "conditional":
                        return best_of(not_c, [ "conditional", c[1], negate(c[2]), negate(c[3]) ]);
                    case "binary":
                        var op = c[1], left = c[2], right = c[3];
                        if (!options.keep_comps) switch (op) {
                            case "<="  : return [ "binary", ">", left, right ];
                            case "<"   : return [ "binary", ">=", left, right ];
                            case ">="  : return [ "binary", "<", left, right ];
                            case ">"   : return [ "binary", "<=", left, right ];
                        }
                        switch (op) {
                            case "=="  : return [ "binary", "!=", left, right ];
                            case "!="  : return [ "binary", "==", left, right ];
                            case "===" : return [ "binary", "!==", left, right ];
                            case "!==" : return [ "binary", "===", left, right ];
                            case "&&"  : return best_of(not_c, [ "binary", "||", negate(left), negate(right) ]);
                            case "||"  : return best_of(not_c, [ "binary", "&&", negate(left), negate(right) ]);
                        }
                        break;
                }
                return not_c;
        };

        function make_conditional(c, t, e) {
                var make_real_conditional = function() {
                        if (c[0] == "unary-prefix" && c[1] == "!") {
                                return e ? [ "conditional", c[2], e, t ] : [ "binary", "||", c[2], t ];
                        } else {
                                return e ? best_of(
                                        [ "conditional", c, t, e ],
                                        [ "conditional", negate(c), e, t ]
                                ) : [ "binary", "&&", c, t ];
                        }
                };
                // shortcut the conditional if the expression has a constant value
                return when_constant(c, function(ast, val){
                        warn_unreachable(val ? e : t);
                        return          (val ? t : e);
                }, make_real_conditional);
        };

        function rmblock(block) {
                if (block != null && block[0] == "block" && block[1]) {
                        if (block[1].length == 1)
                                block = block[1][0];
                        else if (block[1].length == 0)
                                block = [ "block" ];
                }
                return block;
        };

        function _lambda(name, args, body) {
                return [ this[0], name, args, tighten(body, "lambda") ];
        };

        // this function does a few things:
        // 1. discard useless blocks
        // 2. join consecutive var declarations
        // 3. remove obviously dead code
        // 4. transform consecutive statements using the comma operator
        // 5. if block_type == "lambda" and it detects constructs like if(foo) return ... - rewrite like if (!foo) { ... }
        function tighten(statements, block_type) {
                statements = MAP(statements, walk);

                statements = statements.reduce(function(a, stat){
                        if (stat[0] == "block") {
                                if (stat[1]) {
                                        a.push.apply(a, stat[1]);
                                }
                        } else {
                                a.push(stat);
                        }
                        return a;
                }, []);

                statements = (function(a, prev){
                        statements.forEach(function(cur){
                                if (prev && ((cur[0] == "var" && prev[0] == "var") ||
                                             (cur[0] == "const" && prev[0] == "const"))) {
                                        prev[1] = prev[1].concat(cur[1]);
                                } else {
                                        a.push(cur);
                                        prev = cur;
                                }
                        });
                        return a;
                })([]);

                if (options.dead_code) statements = (function(a, has_quit){
                        statements.forEach(function(st){
                                if (has_quit) {
                                        if (st[0] == "function" || st[0] == "defun") {
                                                a.push(st);
                                        }
                                        else if (st[0] == "var" || st[0] == "const") {
                                                if (!options.no_warnings)
                                                        warn("Variables declared in unreachable code");
                                                st[1] = MAP(st[1], function(def){
                                                        if (def[1] && !options.no_warnings)
                                                                warn_unreachable([ "assign", true, [ "name", def[0] ], def[1] ]);
                                                        return [ def[0] ];
                                                });
                                                a.push(st);
                                        }
                                        else if (!options.no_warnings)
                                                warn_unreachable(st);
                                }
                                else {
                                        a.push(st);
                                        if (member(st[0], [ "return", "throw", "break", "continue" ]))
                                                has_quit = true;
                                }
                        });
                        return a;
                })([]);

                if (options.make_seqs) statements = (function(a, prev) {
                        statements.forEach(function(cur){
                                if (prev && prev[0] == "stat" && cur[0] == "stat") {
                                        prev[1] = [ "seq", prev[1], cur[1] ];
                                } else {
                                        a.push(cur);
                                        prev = cur;
                                }
                        });
                        if (a.length >= 2
                            && a[a.length-2][0] == "stat"
                            && (a[a.length-1][0] == "return" || a[a.length-1][0] == "throw")
                            && a[a.length-1][1])
                        {
                                a.splice(a.length - 2, 2,
                                         [ a[a.length-1][0],
                                           [ "seq", a[a.length-2][1], a[a.length-1][1] ]]);
                        }
                        return a;
                })([]);

                // this increases jQuery by 1K.  Probably not such a good idea after all..
                // part of this is done in prepare_ifs anyway.
                // if (block_type == "lambda") statements = (function(i, a, stat){
                //         while (i < statements.length) {
                //                 stat = statements[i++];
                //                 if (stat[0] == "if" && !stat[3]) {
                //                         if (stat[2][0] == "return" && stat[2][1] == null) {
                //                                 a.push(make_if(negate(stat[1]), [ "block", statements.slice(i) ]));
                //                                 break;
                //                         }
                //                         var last = last_stat(stat[2]);
                //                         if (last[0] == "return" && last[1] == null) {
                //                                 a.push(make_if(stat[1], [ "block", stat[2][1].slice(0, -1) ], [ "block", statements.slice(i) ]));
                //                                 break;
                //                         }
                //                 }
                //                 a.push(stat);
                //         }
                //         return a;
                // })(0, []);

                return statements;
        };

        function make_if(c, t, e) {
                return when_constant(c, function(ast, val){
                        if (val) {
                                t = walk(t);
                                warn_unreachable(e);
                                return t || [ "block" ];
                        } else {
                                e = walk(e);
                                warn_unreachable(t);
                                return e || [ "block" ];
                        }
                }, function() {
                        return make_real_if(c, t, e);
                });
        };

        function abort_else(c, t, e) {
                var ret = [ [ "if", negate(c), e ] ];
                if (t[0] == "block") {
                        if (t[1]) ret = ret.concat(t[1]);
                } else {
                        ret.push(t);
                }
                return walk([ "block", ret ]);
        };

        function make_real_if(c, t, e) {
                c = walk(c);
                t = walk(t);
                e = walk(e);

                if (empty(e) && empty(t))
                        return [ "stat", c ];

                if (empty(t)) {
                        c = negate(c);
                        t = e;
                        e = null;
                } else if (empty(e)) {
                        e = null;
                } else {
                        // if we have both else and then, maybe it makes sense to switch them?
                        (function(){
                                var a = gen_code(c);
                                var n = negate(c);
                                var b = gen_code(n);
                                if (b.length < a.length) {
                                        var tmp = t;
                                        t = e;
                                        e = tmp;
                                        c = n;
                                }
                        })();
                }
                var ret = [ "if", c, t, e ];
                if (t[0] == "if" && empty(t[3]) && empty(e)) {
                        ret = best_of(ret, walk([ "if", [ "binary", "&&", c, t[1] ], t[2] ]));
                }
                else if (t[0] == "stat") {
                        if (e) {
                                if (e[0] == "stat")
                                        ret = best_of(ret, [ "stat", make_conditional(c, t[1], e[1]) ]);
                                else if (aborts(e))
                                        ret = abort_else(c, t, e);
                        }
                        else {
                                ret = best_of(ret, [ "stat", make_conditional(c, t[1]) ]);
                        }
                }
                else if (e && t[0] == e[0] && (t[0] == "return" || t[0] == "throw") && t[1] && e[1]) {
                        ret = best_of(ret, [ t[0], make_conditional(c, t[1], e[1] ) ]);
                }
                else if (e && aborts(t)) {
                        ret = [ [ "if", c, t ] ];
                        if (e[0] == "block") {
                                if (e[1]) ret = ret.concat(e[1]);
                        }
                        else {
                                ret.push(e);
                        }
                        ret = walk([ "block", ret ]);
                }
                else if (t && aborts(e)) {
                        ret = abort_else(c, t, e);
                }
                return ret;
        };

        function _do_while(cond, body) {
                return when_constant(cond, function(cond, val){
                        if (!val) {
                                warn_unreachable(body);
                                return [ "block" ];
                        } else {
                                return [ "for", null, null, null, walk(body) ];
                        }
                });
        };

        return w.with_walkers({
                "sub": function(expr, subscript) {
                        if (subscript[0] == "string") {
                                var name = subscript[1];
                                if (is_identifier(name))
                                        return [ "dot", walk(expr), name ];
                                else if (/^[1-9][0-9]*$/.test(name) || name === "0")
                                        return [ "sub", walk(expr), [ "num", parseInt(name, 10) ] ];
                        }
                },
                "if": make_if,
                "toplevel": function(body) {
                        return [ "toplevel", tighten(body) ];
                },
                "switch": function(expr, body) {
                        var last = body.length - 1;
                        return [ "switch", walk(expr), MAP(body, function(branch, i){
                                var block = tighten(branch[1]);
                                if (i == last && block.length > 0) {
                                        var node = block[block.length - 1];
                                        if (node[0] == "break" && !node[1])
                                                block.pop();
                                }
                                return [ branch[0] ? walk(branch[0]) : null, block ];
                        }) ];
                },
                "function": _lambda,
                "defun": _lambda,
                "block": function(body) {
                        if (body) return rmblock([ "block", tighten(body) ]);
                },
                "binary": function(op, left, right) {
                        return when_constant([ "binary", op, walk(left), walk(right) ], function yes(c){
                                return best_of(walk(c), this);
                        }, function no() {
                                return function(){
                                        if(op != "==" && op != "!=") return;
                                        var l = walk(left), r = walk(right);
                                        if(l && l[0] == "unary-prefix" && l[1] == "!" && l[2][0] == "num")
                                                left = ['num', +!l[2][1]];
                                        else if (r && r[0] == "unary-prefix" && r[1] == "!" && r[2][0] == "num")
                                                right = ['num', +!r[2][1]];
                                        return ["binary", op, left, right];
                                }() || this;
                        });
                },
                "conditional": function(c, t, e) {
                        return make_conditional(walk(c), walk(t), walk(e));
                },
                "try": function(t, c, f) {
                        return [
                                "try",
                                tighten(t),
                                c != null ? [ c[0], tighten(c[1]) ] : null,
                                f != null ? tighten(f) : null
                        ];
                },
                "unary-prefix": function(op, expr) {
                        expr = walk(expr);
                        var ret = [ "unary-prefix", op, expr ];
                        if (op == "!")
                                ret = best_of(ret, negate(expr));
                        return when_constant(ret, function(ast, val){
                                return walk(ast); // it's either true or false, so minifies to !0 or !1
                        }, function() { return ret });
                },
                "name": function(name) {
                        switch (name) {
                            case "true": return [ "unary-prefix", "!", [ "num", 0 ]];
                            case "false": return [ "unary-prefix", "!", [ "num", 1 ]];
                        }
                },
                "while": _do_while,
                "assign": function(op, lvalue, rvalue) {
                        lvalue = walk(lvalue);
                        rvalue = walk(rvalue);
                        var okOps = [ '+', '-', '/', '*', '%', '>>', '<<', '>>>', '|', '^', '&' ];
                        if (op === true && lvalue[0] === "name" && rvalue[0] === "binary" &&
                            ~okOps.indexOf(rvalue[1]) && rvalue[2][0] === "name" &&
                            rvalue[2][1] === lvalue[1]) {
                                return [ this[0], rvalue[1], lvalue, rvalue[3] ]
                        }
                        return [ this[0], op, lvalue, rvalue ];
                },
                "call": function(expr, args) {
                        expr = walk(expr);
                        if (options.unsafe && expr[0] == "dot" && expr[1][0] == "string" && expr[2] == "toString") {
                                return expr[1];
                        }
                        return [ this[0], expr,  MAP(args, walk) ];
                },
                "num": function (num) {
                        if (!isFinite(num))
                                return [ "binary", "/", num === 1 / 0
                                         ? [ "num", 1 ] : num === -1 / 0
                                         ? [ "unary-prefix", "-", [ "num", 1 ] ]
                                         : [ "num", 0 ], [ "num", 0 ] ];

                        return [ this[0], num ];
                }
        }, function() {
                return walk(prepare_ifs(walk(prepare_ifs(ast))));
        });
};

function squeeze_2(ast, options) {
        var w = ast_walker(), walk = w.walk, scope;
        function with_scope(s, cont) {
                var save = scope, ret;
                scope = s;
                ret = cont();
                scope = save;
                return ret;
        };
        function lambda(name, args, body) {
                return [ this[0], name, args, with_scope(body.scope, curry(MAP, body, walk)) ];
        };
        return w.with_walkers({
                "directive": function(dir) {
                        if (scope.active_directive(dir))
                                return [ "block" ];
                        scope.directives.push(dir);
                },
                "toplevel": function(body) {
                        return [ this[0], with_scope(this.scope, curry(MAP, body, walk)) ];
                },
                "function": lambda,
                "defun": lambda
        }, function(){
                return walk(ast_add_scope(ast));
        });
};

/* -----[ re-generate code from the AST ]----- */

var DOT_CALL_NO_PARENS = jsp.array_to_hash([
        "name",
        "array",
        "object",
        "string",
        "dot",
        "sub",
        "call",
        "regexp",
        "defun"
]);

function make_string(str, ascii_only) {
        var dq = 0, sq = 0;
        str = str.replace(/[\\\b\f\n\r\t\x22\x27\u2028\u2029\0]/g, function(s){
                switch (s) {
                    case "\\": return "\\\\";
                    case "\b": return "\\b";
                    case "\f": return "\\f";
                    case "\n": return "\\n";
                    case "\r": return "\\r";
                    case "\u2028": return "\\u2028";
                    case "\u2029": return "\\u2029";
                    case '"': ++dq; return '"';
                    case "'": ++sq; return "'";
                    case "\0": return "\\0";
                }
                return s;
        });
        if (ascii_only) str = to_ascii(str);
        if (dq > sq) return "'" + str.replace(/\x27/g, "\\'") + "'";
        else return '"' + str.replace(/\x22/g, '\\"') + '"';
};

function to_ascii(str) {
        return str.replace(/[\u0080-\uffff]/g, function(ch) {
                var code = ch.charCodeAt(0).toString(16);
                while (code.length < 4) code = "0" + code;
                return "\\u" + code;
        });
};

var SPLICE_NEEDS_BRACKETS = jsp.array_to_hash([ "if", "while", "do", "for", "for-in", "with" ]);

function gen_code(ast, options) {
        options = defaults(options, {
                indent_start : 0,
                indent_level : 4,
                quote_keys   : false,
                space_colon  : false,
                beautify     : false,
                ascii_only   : false,
                inline_script: false
        });
        var beautify = !!options.beautify;
        var indentation = 0,
            newline = beautify ? "\n" : "",
            space = beautify ? " " : "";

        function encode_string(str) {
                var ret = make_string(str, options.ascii_only);
                if (options.inline_script)
                        ret = ret.replace(/<\x2fscript([>\/\t\n\f\r ])/gi, "<\\/script$1");
                return ret;
        };

        function make_name(name) {
                name = name.toString();
                if (options.ascii_only)
                        name = to_ascii(name);
                return name;
        };

        function indent(line) {
                if (line == null)
                        line = "";
                if (beautify)
                        line = repeat_string(" ", options.indent_start + indentation * options.indent_level) + line;
                return line;
        };

        function with_indent(cont, incr) {
                if (incr == null) incr = 1;
                indentation += incr;
                try { return cont.apply(null, slice(arguments, 1)); }
                finally { indentation -= incr; }
        };

        function last_char(str) {
                str = str.toString();
                return str.charAt(str.length - 1);
        };

        function first_char(str) {
                return str.toString().charAt(0);
        };

        function add_spaces(a) {
                if (beautify)
                        return a.join(" ");
                var b = [];
                for (var i = 0; i < a.length; ++i) {
                        var next = a[i + 1];
                        b.push(a[i]);
                        if (next &&
                            ((is_identifier_char(last_char(a[i])) && (is_identifier_char(first_char(next))
                                                                      || first_char(next) == "\\")) ||
                             (/[\+\-]$/.test(a[i].toString()) && /^[\+\-]/.test(next.toString())))) {
                                b.push(" ");
                        }
                }
                return b.join("");
        };

        function add_commas(a) {
                return a.join("," + space);
        };

        function parenthesize(expr) {
                var gen = make(expr);
                for (var i = 1; i < arguments.length; ++i) {
                        var el = arguments[i];
                        if ((el instanceof Function && el(expr)) || expr[0] == el)
                                return "(" + gen + ")";
                }
                return gen;
        };

        function best_of(a) {
                if (a.length == 1) {
                        return a[0];
                }
                if (a.length == 2) {
                        var b = a[1];
                        a = a[0];
                        return a.length <= b.length ? a : b;
                }
                return best_of([ a[0], best_of(a.slice(1)) ]);
        };

        function needs_parens(expr) {
                if (expr[0] == "function" || expr[0] == "object") {
                        // dot/call on a literal function requires the
                        // function literal itself to be parenthesized
                        // only if it's the first "thing" in a
                        // statement.  This means that the parent is
                        // "stat", but it could also be a "seq" and
                        // we're the first in this "seq" and the
                        // parent is "stat", and so on.  Messy stuff,
                        // but it worths the trouble.
                        var a = slice(w.stack()), self = a.pop(), p = a.pop();
                        while (p) {
                                if (p[0] == "stat") return true;
                                if (((p[0] == "seq" || p[0] == "call" || p[0] == "dot" || p[0] == "sub" || p[0] == "conditional") && p[1] === self) ||
                                    ((p[0] == "binary" || p[0] == "assign" || p[0] == "unary-postfix") && p[2] === self)) {
                                        self = p;
                                        p = a.pop();
                                } else {
                                        return false;
                                }
                        }
                }
                return !HOP(DOT_CALL_NO_PARENS, expr[0]);
        };

        function make_num(num) {
                var str = num.toString(10), a = [ str.replace(/^0\./, ".").replace('e+', 'e') ], m;
                if (Math.floor(num) === num) {
                        if (num >= 0) {
                                a.push("0x" + num.toString(16).toLowerCase(), // probably pointless
                                       "0" + num.toString(8)); // same.
                        } else {
                                a.push("-0x" + (-num).toString(16).toLowerCase(), // probably pointless
                                       "-0" + (-num).toString(8)); // same.
                        }
                        if ((m = /^(.*?)(0+)$/.exec(num))) {
                                a.push(m[1] + "e" + m[2].length);
                        }
                } else if ((m = /^0?\.(0+)(.*)$/.exec(num))) {
                        a.push(m[2] + "e-" + (m[1].length + m[2].length),
                               str.substr(str.indexOf(".")));
                }
                return best_of(a);
        };

        var w = ast_walker();
        var make = w.walk;
        return w.with_walkers({
                "string": encode_string,
                "num": make_num,
                "name": make_name,
                "debugger": function(){ return "debugger;" },
                "toplevel": function(statements) {
                        return make_block_statements(statements)
                                .join(newline + newline);
                },
                "splice": function(statements) {
                        var parent = w.parent();
                        if (HOP(SPLICE_NEEDS_BRACKETS, parent)) {
                                // we need block brackets in this case
                                return make_block.apply(this, arguments);
                        } else {
                                return MAP(make_block_statements(statements, true),
                                           function(line, i) {
                                                   // the first line is already indented
                                                   return i > 0 ? indent(line) : line;
                                           }).join(newline);
                        }
                },
                "block": make_block,
                "var": function(defs) {
                        return "var " + add_commas(MAP(defs, make_1vardef)) + ";";
                },
                "const": function(defs) {
                        return "const " + add_commas(MAP(defs, make_1vardef)) + ";";
                },
                "try": function(tr, ca, fi) {
                        var out = [ "try", make_block(tr) ];
                        if (ca) out.push("catch", "(" + ca[0] + ")", make_block(ca[1]));
                        if (fi) out.push("finally", make_block(fi));
                        return add_spaces(out);
                },
                "throw": function(expr) {
                        return add_spaces([ "throw", make(expr) ]) + ";";
                },
                "new": function(ctor, args) {
                        args = args.length > 0 ? "(" + add_commas(MAP(args, function(expr){
                                return parenthesize(expr, "seq");
                        })) + ")" : "";
                        return add_spaces([ "new", parenthesize(ctor, "seq", "binary", "conditional", "assign", function(expr){
                                var w = ast_walker(), has_call = {};
                                try {
                                        w.with_walkers({
                                                "call": function() { throw has_call },
                                                "function": function() { return this }
                                        }, function(){
                                                w.walk(expr);
                                        });
                                } catch(ex) {
                                        if (ex === has_call)
                                                return true;
                                        throw ex;
                                }
                        }) + args ]);
                },
                "switch": function(expr, body) {
                        return add_spaces([ "switch", "(" + make(expr) + ")", make_switch_block(body) ]);
                },
                "break": function(label) {
                        var out = "break";
                        if (label != null)
                                out += " " + make_name(label);
                        return out + ";";
                },
                "continue": function(label) {
                        var out = "continue";
                        if (label != null)
                                out += " " + make_name(label);
                        return out + ";";
                },
                "conditional": function(co, th, el) {
                        return add_spaces([ parenthesize(co, "assign", "seq", "conditional"), "?",
                                            parenthesize(th, "seq"), ":",
                                            parenthesize(el, "seq") ]);
                },
                "assign": function(op, lvalue, rvalue) {
                        if (op && op !== true) op += "=";
                        else op = "=";
                        return add_spaces([ make(lvalue), op, parenthesize(rvalue, "seq") ]);
                },
                "dot": function(expr) {
                        var out = make(expr), i = 1;
                        if (expr[0] == "num") {
                                if (!/[a-f.]/i.test(out))
                                        out += ".";
                        } else if (expr[0] != "function" && needs_parens(expr))
                                out = "(" + out + ")";
                        while (i < arguments.length)
                                out += "." + make_name(arguments[i++]);
                        return out;
                },
                "call": function(func, args) {
                        var f = make(func);
                        if (f.charAt(0) != "(" && needs_parens(func))
                                f = "(" + f + ")";
                        return f + "(" + add_commas(MAP(args, function(expr){
                                return parenthesize(expr, "seq");
                        })) + ")";
                },
                "function": make_function,
                "defun": make_function,
                "if": function(co, th, el) {
                        var out = [ "if", "(" + make(co) + ")", el ? make_then(th) : make(th) ];
                        if (el) {
                                out.push("else", make(el));
                        }
                        return add_spaces(out);
                },
                "for": function(init, cond, step, block) {
                        var out = [ "for" ];
                        init = (init != null ? make(init) : "").replace(/;*\s*$/, ";" + space);
                        cond = (cond != null ? make(cond) : "").replace(/;*\s*$/, ";" + space);
                        step = (step != null ? make(step) : "").replace(/;*\s*$/, "");
                        var args = init + cond + step;
                        if (args == "; ; ") args = ";;";
                        out.push("(" + args + ")", make(block));
                        return add_spaces(out);
                },
                "for-in": function(vvar, key, hash, block) {
                        return add_spaces([ "for", "(" +
                                            (vvar ? make(vvar).replace(/;+$/, "") : make(key)),
                                            "in",
                                            make(hash) + ")", make(block) ]);
                },
                "while": function(condition, block) {
                        return add_spaces([ "while", "(" + make(condition) + ")", make(block) ]);
                },
                "do": function(condition, block) {
                        return add_spaces([ "do", make(block), "while", "(" + make(condition) + ")" ]) + ";";
                },
                "return": function(expr) {
                        var out = [ "return" ];
                        if (expr != null) out.push(make(expr));
                        return add_spaces(out) + ";";
                },
                "binary": function(operator, lvalue, rvalue) {
                        var left = make(lvalue), right = make(rvalue);
                        // XXX: I'm pretty sure other cases will bite here.
                        //      we need to be smarter.
                        //      adding parens all the time is the safest bet.
                        if (member(lvalue[0], [ "assign", "conditional", "seq" ]) ||
                            lvalue[0] == "binary" && PRECEDENCE[operator] > PRECEDENCE[lvalue[1]] ||
                            lvalue[0] == "function" && needs_parens(this)) {
                                left = "(" + left + ")";
                        }
                        if (member(rvalue[0], [ "assign", "conditional", "seq" ]) ||
                            rvalue[0] == "binary" && PRECEDENCE[operator] >= PRECEDENCE[rvalue[1]] &&
                            !(rvalue[1] == operator && member(operator, [ "&&", "||", "*" ]))) {
                                right = "(" + right + ")";
                        }
                        else if (!beautify && options.inline_script && (operator == "<" || operator == "<<")
                                 && rvalue[0] == "regexp" && /^script/i.test(rvalue[1])) {
                                right = " " + right;
                        }
                        return add_spaces([ left, operator, right ]);
                },
                "unary-prefix": function(operator, expr) {
                        var val = make(expr);
                        if (!(expr[0] == "num" || (expr[0] == "unary-prefix" && !HOP(OPERATORS, operator + expr[1])) || !needs_parens(expr)))
                                val = "(" + val + ")";
                        return operator + (jsp.is_alphanumeric_char(operator.charAt(0)) ? " " : "") + val;
                },
                "unary-postfix": function(operator, expr) {
                        var val = make(expr);
                        if (!(expr[0] == "num" || (expr[0] == "unary-postfix" && !HOP(OPERATORS, operator + expr[1])) || !needs_parens(expr)))
                                val = "(" + val + ")";
                        return val + operator;
                },
                "sub": function(expr, subscript) {
                        var hash = make(expr);
                        if (needs_parens(expr))
                                hash = "(" + hash + ")";
                        return hash + "[" + make(subscript) + "]";
                },
                "object": function(props) {
                        var obj_needs_parens = needs_parens(this);
                        if (props.length == 0)
                                return obj_needs_parens ? "({})" : "{}";
                        var out = "{" + newline + with_indent(function(){
                                return MAP(props, function(p){
                                        if (p.length == 3) {
                                                // getter/setter.  The name is in p[0], the arg.list in p[1][2], the
                                                // body in p[1][3] and type ("get" / "set") in p[2].
                                                return indent(make_function(p[0], p[1][2], p[1][3], p[2], true));
                                        }
                                        var key = p[0], val = parenthesize(p[1], "seq");
                                        if (options.quote_keys) {
                                                key = encode_string(key);
                                        } else if ((typeof key == "number" || !beautify && +key + "" == key)
                                                   && parseFloat(key) >= 0) {
                                                key = make_num(+key);
                                        } else if (!is_identifier(key)) {
                                                key = encode_string(key);
                                        }
                                        return indent(add_spaces(beautify && options.space_colon
                                                                 ? [ key, ":", val ]
                                                                 : [ key + ":", val ]));
                                }).join("," + newline);
                        }) + newline + indent("}");
                        return obj_needs_parens ? "(" + out + ")" : out;
                },
                "regexp": function(rx, mods) {
                        if (options.ascii_only) rx = to_ascii(rx);
                        return "/" + rx + "/" + mods;
                },
                "array": function(elements) {
                        if (elements.length == 0) return "[]";
                        return add_spaces([ "[", add_commas(MAP(elements, function(el, i){
                                if (!beautify && el[0] == "atom" && el[1] == "undefined") return i === elements.length - 1 ? "," : "";
                                return parenthesize(el, "seq");
                        })), "]" ]);
                },
                "stat": function(stmt) {
                        return stmt != null
                                ? make(stmt).replace(/;*\s*$/, ";")
                                : ";";
                },
                "seq": function() {
                        return add_commas(MAP(slice(arguments), make));
                },
                "label": function(name, block) {
                        return add_spaces([ make_name(name), ":", make(block) ]);
                },
                "with": function(expr, block) {
                        return add_spaces([ "with", "(" + make(expr) + ")", make(block) ]);
                },
                "atom": function(name) {
                        return make_name(name);
                },
                "directive": function(dir) {
                        return make_string(dir) + ";";
                }
        }, function(){ return make(ast) });

        // The squeezer replaces "block"-s that contain only a single
        // statement with the statement itself; technically, the AST
        // is correct, but this can create problems when we output an
        // IF having an ELSE clause where the THEN clause ends in an
        // IF *without* an ELSE block (then the outer ELSE would refer
        // to the inner IF).  This function checks for this case and
        // adds the block brackets if needed.
        function make_then(th) {
                if (th == null) return ";";
                if (th[0] == "do") {
                        // https://github.com/mishoo/UglifyJS/issues/#issue/57
                        // IE croaks with "syntax error" on code like this:
                        //     if (foo) do ... while(cond); else ...
                        // we need block brackets around do/while
                        return make_block([ th ]);
                }
                var b = th;
                while (true) {
                        var type = b[0];
                        if (type == "if") {
                                if (!b[3])
                                        // no else, we must add the block
                                        return make([ "block", [ th ]]);
                                b = b[3];
                        }
                        else if (type == "while" || type == "do") b = b[2];
                        else if (type == "for" || type == "for-in") b = b[4];
                        else break;
                }
                return make(th);
        };

        function make_function(name, args, body, keyword, no_parens) {
                var out = keyword || "function";
                if (name) {
                        out += " " + make_name(name);
                }
                out += "(" + add_commas(MAP(args, make_name)) + ")";
                out = add_spaces([ out, make_block(body) ]);
                return (!no_parens && needs_parens(this)) ? "(" + out + ")" : out;
        };

        function must_has_semicolon(node) {
                switch (node[0]) {
                    case "with":
                    case "while":
                        return empty(node[2]) || must_has_semicolon(node[2]);
                    case "for":
                    case "for-in":
                        return empty(node[4]) || must_has_semicolon(node[4]);
                    case "if":
                        if (empty(node[2]) && !node[3]) return true; // `if' with empty `then' and no `else'
                        if (node[3]) {
                                if (empty(node[3])) return true; // `else' present but empty
                                return must_has_semicolon(node[3]); // dive into the `else' branch
                        }
                        return must_has_semicolon(node[2]); // dive into the `then' branch
                    case "directive":
                        return true;
                }
        };

        function make_block_statements(statements, noindent) {
                for (var a = [], last = statements.length - 1, i = 0; i <= last; ++i) {
                        var stat = statements[i];
                        var code = make(stat);
                        if (code != ";") {
                                if (!beautify && i == last && !must_has_semicolon(stat)) {
                                        code = code.replace(/;+\s*$/, "");
                                }
                                a.push(code);
                        }
                }
                return noindent ? a : MAP(a, indent);
        };

        function make_switch_block(body) {
                var n = body.length;
                if (n == 0) return "{}";
                return "{" + newline + MAP(body, function(branch, i){
                        var has_body = branch[1].length > 0, code = with_indent(function(){
                                return indent(branch[0]
                                              ? add_spaces([ "case", make(branch[0]) + ":" ])
                                              : "default:");
                        }, 0.5) + (has_body ? newline + with_indent(function(){
                                return make_block_statements(branch[1]).join(newline);
                        }) : "");
                        if (!beautify && has_body && i < n - 1)
                                code += ";";
                        return code;
                }).join(newline) + newline + indent("}");
        };

        function make_block(statements) {
                if (!statements) return ";";
                if (statements.length == 0) return "{}";
                return "{" + newline + with_indent(function(){
                        return make_block_statements(statements).join(newline);
                }) + newline + indent("}");
        };

        function make_1vardef(def) {
                var name = def[0], val = def[1];
                if (val != null)
                        name = add_spaces([ make_name(name), "=", parenthesize(val, "seq") ]);
                return name;
        };

};

function split_lines(code, max_line_length) {
        var splits = [ 0 ];
        jsp.parse(function(){
                var next_token = jsp.tokenizer(code);
                var last_split = 0;
                var prev_token;
                function current_length(tok) {
                        return tok.pos - last_split;
                };
                function split_here(tok) {
                        last_split = tok.pos;
                        splits.push(last_split);
                };
                function custom(){
                        var tok = next_token.apply(this, arguments);
                        out: {
                                if (prev_token) {
                                        if (prev_token.type == "keyword") break out;
                                }
                                if (current_length(tok) > max_line_length) {
                                        switch (tok.type) {
                                            case "keyword":
                                            case "atom":
                                            case "name":
                                            case "punc":
                                                split_here(tok);
                                                break out;
                                        }
                                }
                        }
                        prev_token = tok;
                        return tok;
                };
                custom.context = function() {
                        return next_token.context.apply(this, arguments);
                };
                return custom;
        }());
        return splits.map(function(pos, i){
                return code.substring(pos, splits[i + 1] || code.length);
        }).join("\n");
};

/* -----[ Utilities ]----- */

function repeat_string(str, i) {
        if (i <= 0) return "";
        if (i == 1) return str;
        var d = repeat_string(str, i >> 1);
        d += d;
        if (i & 1) d += str;
        return d;
};

function defaults(args, defs) {
        var ret = {};
        if (args === true)
                args = {};
        for (var i in defs) if (HOP(defs, i)) {
                ret[i] = (args && HOP(args, i)) ? args[i] : defs[i];
        }
        return ret;
};

function is_identifier(name) {
        return /^[a-z_$][a-z0-9_$]*$/i.test(name)
                && name != "this"
                && !HOP(jsp.KEYWORDS_ATOM, name)
                && !HOP(jsp.RESERVED_WORDS, name)
                && !HOP(jsp.KEYWORDS, name);
};

function HOP(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
};

// some utilities

var MAP;

(function(){
        MAP = function(a, f, o) {
                var ret = [], top = [], i;
                function doit() {
                        var val = f.call(o, a[i], i);
                        if (val instanceof AtTop) {
                                val = val.v;
                                if (val instanceof Splice) {
                                        top.push.apply(top, val.v);
                                } else {
                                        top.push(val);
                                }
                        }
                        else if (val != skip) {
                                if (val instanceof Splice) {
                                        ret.push.apply(ret, val.v);
                                } else {
                                        ret.push(val);
                                }
                        }
                };
                if (a instanceof Array) for (i = 0; i < a.length; ++i) doit();
                else for (i in a) if (HOP(a, i)) doit();
                return top.concat(ret);
        };
        MAP.at_top = function(val) { return new AtTop(val) };
        MAP.splice = function(val) { return new Splice(val) };
        var skip = MAP.skip = {};
        function AtTop(val) { this.v = val };
        function Splice(val) { this.v = val };
})();

/* -----[ Exports ]----- */

exports.ast_walker = ast_walker;
exports.ast_mangle = ast_mangle;
exports.ast_squeeze = ast_squeeze;
exports.ast_lift_variables = ast_lift_variables;
exports.gen_code = gen_code;
exports.ast_add_scope = ast_add_scope;
exports.set_logger = function(logger) { warn = logger };
exports.make_string = make_string;
exports.split_lines = split_lines;
exports.MAP = MAP;

// keep this last!
exports.ast_squeeze_more = require("./squeeze-more").ast_squeeze_more;

// Local variables:
// js-indent-level: 8
// End:

},{"./parse-js":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/parse-js.js","./squeeze-more":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/squeeze-more.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/squeeze-more.js":[function(require,module,exports){
var jsp = require("./parse-js"),
    pro = require("./process"),
    slice = jsp.slice,
    member = jsp.member,
    curry = jsp.curry,
    MAP = pro.MAP,
    PRECEDENCE = jsp.PRECEDENCE,
    OPERATORS = jsp.OPERATORS;

function ast_squeeze_more(ast) {
        var w = pro.ast_walker(), walk = w.walk, scope;
        function with_scope(s, cont) {
                var save = scope, ret;
                scope = s;
                ret = cont();
                scope = save;
                return ret;
        };
        function _lambda(name, args, body) {
                return [ this[0], name, args, with_scope(body.scope, curry(MAP, body, walk)) ];
        };
        return w.with_walkers({
                "toplevel": function(body) {
                        return [ this[0], with_scope(this.scope, curry(MAP, body, walk)) ];
                },
                "function": _lambda,
                "defun": _lambda,
                "new": function(ctor, args) {
                        if (ctor[0] == "name") {
                                if (ctor[1] == "Array" && !scope.has("Array")) {
                                        if (args.length != 1) {
                                                return [ "array", args ];
                                        } else {
                                                return walk([ "call", [ "name", "Array" ], args ]);
                                        }
                                } else if (ctor[1] == "Object" && !scope.has("Object")) {
                                        if (!args.length) {
                                                return [ "object", [] ];
                                        } else {
                                                return walk([ "call", [ "name", "Object" ], args ]);
                                        }
                                } else if ((ctor[1] == "RegExp" || ctor[1] == "Function" || ctor[1] == "Error") && !scope.has(ctor[1])) {
                                        return walk([ "call", [ "name", ctor[1] ], args]);
                                }
                        }
                },
                "call": function(expr, args) {
                        if (expr[0] == "dot" && expr[1][0] == "string" && args.length == 1
                            && (args[0][1] > 0 && expr[2] == "substring" || expr[2] == "substr")) {
                                return [ "call", [ "dot", expr[1], "slice"], args];
                        }
                        if (expr[0] == "dot" && expr[2] == "toString" && args.length == 0) {
                                // foo.toString()  ==>  foo+""
                                if (expr[1][0] == "string") return expr[1];
                                return [ "binary", "+", expr[1], [ "string", "" ]];
                        }
                        if (expr[0] == "name") {
                                if (expr[1] == "Array" && args.length != 1 && !scope.has("Array")) {
                                        return [ "array", args ];
                                }
                                if (expr[1] == "Object" && !args.length && !scope.has("Object")) {
                                        return [ "object", [] ];
                                }
                                if (expr[1] == "String" && !scope.has("String")) {
                                        return [ "binary", "+", args[0], [ "string", "" ]];
                                }
                        }
                }
        }, function() {
                return walk(pro.ast_add_scope(ast));
        });
};

exports.ast_squeeze_more = ast_squeeze_more;

// Local variables:
// js-indent-level: 8
// End:

},{"./parse-js":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/parse-js.js","./process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/process.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/uglify-js.js":[function(require,module,exports){
//convienence function(src, [options]);
function uglify(orig_code, options){
  options || (options = {});
  var jsp = uglify.parser;
  var pro = uglify.uglify;

  var ast = jsp.parse(orig_code, options.strict_semicolons); // parse code and get the initial AST
  ast = pro.ast_mangle(ast, options.mangle_options); // get a new AST with mangled names
  ast = pro.ast_squeeze(ast, options.squeeze_options); // get an AST with compression optimizations
  var final_code = pro.gen_code(ast, options.gen_options); // compressed code here
  return final_code;
};

uglify.parser = require("./lib/parse-js");
uglify.uglify = require("./lib/process");
uglify.consolidator = require("./lib/consolidator");

module.exports = uglify

},{"./lib/consolidator":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/consolidator.js","./lib/parse-js":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/parse-js.js","./lib/process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/process.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/underscore/underscore.js":[function(require,module,exports){
//     Underscore.js 1.3.3
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore is freely distributable under the MIT license.
//     Portions of Underscore are inspired or borrowed from Prototype,
//     Oliver Steele's Functional, and John Resig's Micro-Templating.
//     For all details and documentation:
//     http://documentcloud.github.com/underscore

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var slice            = ArrayProto.slice,
      unshift          = ArrayProto.unshift,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) { return new wrapper(obj); };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root['_'] = _;
  }

  // Current version.
  _.VERSION = '1.3.3';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    if (obj.length === +obj.length) results.length = obj.length;
    return results;
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError('Reduce of empty array with no initial value');
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var reversed = _.toArray(obj).reverse();
    if (context && !initial) iterator = _.bind(iterator, context);
    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    each(obj, function(value, index, list) {
      if (!iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if a given value is included in the array or object using `===`.
  // Aliased as `contains`.
  _.include = _.contains = function(obj, target) {
    var found = false;
    if (obj == null) return found;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    found = any(obj, function(value) {
      return value === target;
    });
    return found;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    return _.map(obj, function(value) {
      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Return the maximum element or (element-based computation).
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var shuffled = [], rand;
    each(obj, function(value, index, list) {
      rand = Math.floor(Math.random() * (index + 1));
      shuffled[index] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, val, context) {
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      if (a === void 0) return 1;
      if (b === void 0) return -1;
      return a < b ? -1 : a > b ? 1 : 0;
    }), 'value');
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, val) {
    var result = {};
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    each(obj, function(value, index) {
      var key = iterator(value, index);
      (result[key] || (result[key] = [])).push(value);
    });
    return result;
  };

  // Use a comparator function to figure out at what index an object should
  // be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator) {
    iterator || (iterator = _.identity);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >> 1;
      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj)                                     return [];
    if (_.isArray(obj))                           return slice.call(obj);
    if (_.isArguments(obj))                       return slice.call(obj);
    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    return _.isArray(obj) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especcialy useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail`.
  // Especially useful on the arguments object. Passing an **index** will return
  // the rest of the values in the array from that index onward. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = function(array, index, guard) {
    return slice.call(array, (index == null) || guard ? 1 : index);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, function(value){ return !!value; });
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return _.reduce(array, function(memo, value) {
      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));
      memo[memo.length] = value;
      return memo;
    }, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator) {
    var initial = iterator ? _.map(array, iterator) : array;
    var results = [];
    // The `isSorted` flag is irrelevant if the array only contains two elements.
    if (array.length < 3) isSorted = true;
    _.reduce(initial, function (memo, value, index) {
      if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {
        memo.push(value);
        results.push(array[index]);
      }
      return memo;
    }, []);
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays. (Aliased as "intersect" for back-compat.)
  _.intersection = _.intersect = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = _.flatten(slice.call(arguments, 1), true);
    return _.filter(array, function(value){ return !_.include(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) results[i] = _.pluck(args, "" + i);
    return results;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i, l;
    if (isSorted) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item) {
    if (array == null) return -1;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
    var i = array.length;
    while (i--) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Binding with arguments is also known as `curry`.
  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
  // We check for `func.bind` first, to fail fast when `func` is undefined.
  _.bind = function bind(func, context) {
    var bound, args;
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length == 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, throttling, more, result;
    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);
    return function() {
      context = this; args = arguments;
      var later = function() {
        timeout = null;
        if (more) func.apply(context, args);
        whenDone();
      };
      if (!timeout) timeout = setTimeout(later, wait);
      if (throttling) {
        more = true;
      } else {
        result = func.apply(context, args);
      }
      whenDone();
      throttling = true;
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      if (immediate && !timeout) func.apply(context, args);
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      return memo = func.apply(this, arguments);
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func].concat(slice.call(arguments, 0));
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) { return func.apply(this, arguments); }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    return _.map(obj, _.identity);
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var result = {};
    each(_.flatten(slice.call(arguments, 1)), function(key) {
      if (key in obj) result[key] = obj[key];
    });
    return result;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        if (obj[prop] == null) obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function.
  function eq(a, b, stack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a._chain) a = a._wrapped;
    if (b._chain) b = b._wrapped;
    // Invoke a custom `isEqual` method if one is provided.
    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);
    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = stack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (stack[length] == a) return true;
    }
    // Add the first object to the stack of traversed objects.
    stack.push(a);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          // Ensure commutative equality for sparse arrays.
          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent.
      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    stack.pop();
    return result;
  }

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType == 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Is a given variable an arguments object?
  _.isArguments = function(obj) {
    return toString.call(obj) == '[object Arguments]';
  };
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Is a given value a function?
  _.isFunction = function(obj) {
    return toString.call(obj) == '[object Function]';
  };

  // Is a given value a string?
  _.isString = function(obj) {
    return toString.call(obj) == '[object String]';
  };

  // Is a given value a number?
  _.isNumber = function(obj) {
    return toString.call(obj) == '[object Number]';
  };

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return _.isNumber(obj) && isFinite(obj);
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    // `NaN` is the only value for which `===` is not reflexive.
    return obj !== obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value a date?
  _.isDate = function(obj) {
    return toString.call(obj) == '[object Date]';
  };

  // Is the given value a regular expression?
  _.isRegExp = function(obj) {
    return toString.call(obj) == '[object RegExp]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Has own property?
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function (n, iterator, context) {
    for (var i = 0; i < n; i++) iterator.call(context, i);
  };

  // Escape a string for HTML interpolation.
  _.escape = function(string) {
    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g,'&#x2F;');
  };

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object, ensuring that
  // they're correctly added to the OOP wrapper as well.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      addToWrapper(name, _[name] = obj[name]);
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = idCounter++;
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /.^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    '\\': '\\',
    "'": "'",
    'r': '\r',
    'n': '\n',
    't': '\t',
    'u2028': '\u2028',
    'u2029': '\u2029'
  };

  for (var p in escapes) escapes[escapes[p]] = p;
  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
  var unescaper = /\\(\\|'|r|n|t|u2028|u2029)/g;

  // Within an interpolation, evaluation, or escaping, remove HTML escaping
  // that had been previously added.
  var unescape = function(code) {
    return code.replace(unescaper, function(match, escape) {
      return escapes[escape];
    });
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    settings = _.defaults(settings || {}, _.templateSettings);

    // Compile the template source, taking care to escape characters that
    // cannot be included in a string literal and then unescape them in code
    // blocks.
    var source = "__p+='" + text
      .replace(escaper, function(match) {
        return '\\' + escapes[match];
      })
      .replace(settings.escape || noMatch, function(match, code) {
        return "'+\n_.escape(" + unescape(code) + ")+\n'";
      })
      .replace(settings.interpolate || noMatch, function(match, code) {
        return "'+\n(" + unescape(code) + ")+\n'";
      })
      .replace(settings.evaluate || noMatch, function(match, code) {
        return "';\n" + unescape(code) + "\n;__p+='";
      }) + "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __p='';" +
      "var print=function(){__p+=Array.prototype.join.call(arguments, '')};\n" +
      source + "return __p;\n";

    var render = new Function(settings.variable || 'obj', '_', source);
    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for build time
    // precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' +
      source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // The OOP Wrapper
  // ---------------

  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.
  var wrapper = function(obj) { this._wrapped = obj; };

  // Expose `wrapper.prototype` as `_.prototype`
  _.prototype = wrapper.prototype;

  // Helper function to continue chaining intermediate results.
  var result = function(obj, chain) {
    return chain ? _(obj).chain() : obj;
  };

  // A method to easily add functions to the OOP wrapper.
  var addToWrapper = function(name, func) {
    wrapper.prototype[name] = function() {
      var args = slice.call(arguments);
      unshift.call(args, this._wrapped);
      return result(func.apply(_, args), this._chain);
    };
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      var wrapped = this._wrapped;
      method.apply(wrapped, arguments);
      var length = wrapped.length;
      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];
      return result(wrapped, this._chain);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      return result(method.apply(this._wrapped, arguments), this._chain);
    };
  });

  // Start chaining a wrapped Underscore object.
  wrapper.prototype.chain = function() {
    this._chain = true;
    return this;
  };

  // Extracts the result from a wrapped and chained object.
  wrapper.prototype.value = function() {
    return this._wrapped;
  };

}).call(this);

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/unicoderegexp/lib/unicodeRegExp.js":[function(require,module,exports){
(function (root, factory) {
    // expose unicodeRegExp as
    // - an AMD module (require)
    // - a node module

    if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
        define(factory);
    } else {
        root.unicodeRegExp = factory();
    }
}(this, function (xregexp) {
    var unicodeRegExp = {};

    // These are taken from the XRegExp library (see ../extractRegExpsFromXRegExp.js):
    unicodeRegExp.letter = /[A-Za-z-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]/;
    unicodeRegExp.mark = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u08FE\u0900-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C01-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C82\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D02\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1DC0-\u1DE6\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE26]/;
    unicodeRegExp.number = /[0-9----------------------------------------------------------]/;
    unicodeRegExp.punctuation = /[\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
    unicodeRegExp.symbol = /[\u0024+<->\u005E`\u007C~--------------------------------------------------------------------]/;
    unicodeRegExp.separator = /[\u0020\u00A0\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
    unicodeRegExp.other = /[\u0000-\u001F\u007F-\u009F\u00AD\u0378\u0379\u037F-\u0383\u038B\u038D\u03A2\u0528-\u0530\u0557\u0558\u0560\u0588\u058B-\u058E\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u0605\u061C\u061D\u06DD\u070E\u070F\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08A1\u08AD-\u08E3\u08FF\u0978\u0980\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0C00\u0C04\u0C0D\u0C11\u0C29\u0C34\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5A-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C80\u0C81\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D01\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D4F-\u0D56\u0D58-\u0D5F\u0D64\u0D65\u0D76-\u0D78\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F5-\u13FF\u169D-\u169F\u16F1-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191D-\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C80-\u1CBF\u1CC8-\u1CCF\u1CF7-\u1CFF\u1DE7-\u1DFB\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u200B-\u200F\u202A-\u202E\u2060-\u206F\u2072\u2073\u208F\u209D-\u209F\u20BA-\u20CF\u20F1-\u20FF\u218A-\u218F\u23F4-\u23FF\u2427-\u243F\u244B-\u245F\u2700\u2B4D-\u2B4F\u2B5A-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E3C-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FCD-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA698-\uA69E\uA6F8-\uA6FF\uA78F\uA794-\uA79F\uA7AB-\uA7F7\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C5-\uA8CD\uA8DA-\uA8DF\uA8FC-\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9E0-\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAA7C-\uAA7F\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F-\uABBF\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE27-\uFE2F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD-\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFFB\uFFFE\uFFFF]/; // Other (control, format, private use, surrogate, and unassigned codes)

    var unicodePackageNamesMapping = {
        L: unicodeRegExp.letter,
        M: unicodeRegExp.mark,
        N: unicodeRegExp.number,
        P: unicodeRegExp.punctuation,
        S: unicodeRegExp.symbol,
        Z: unicodeRegExp.separator,
        C: unicodeRegExp.other,
        letter: unicodeRegExp.letter,
        mark: unicodeRegExp.mark,
        number: unicodeRegExp.number,
        digit: unicodeRegExp.number,
        punctuation: unicodeRegExp.punctuation,
        symbol: unicodeRegExp.symbol,
        separator: unicodeRegExp.separator,
        other: unicodeRegExp.other
    };

    unicodeRegExp.unicodePackageNameRegExp = new RegExp('^\\[\\:(\\^)?(' + Object.keys(unicodePackageNamesMapping).join('|') + ')\\:\\]$');

    unicodeRegExp.expandCldrUnicodeSetIdToCharacterClass = function (unicodeSetId) {
        return new RegExp(unicodeSetId.replace(unicodeRegExp.unicodePackageNameRegExp, function ($0, negated, packageName) {
            var characters = unicodePackageNamesMapping[packageName].source.replace(/^\[|\]$/g, '');
            return '[' + (negated ? '^' + characters : characters) + ']';
        }));
    };

    unicodeRegExp.spliceCharacterClassRegExps = function () { // ...
        var args = Array.prototype.slice.call(arguments);

        return new RegExp('[' + args.map(function (regExp) {
            return regExp.source.replace(/^\[|\]$/g, '');
        }).join("") + ']');
    };

    // All of the above combined, except 'separator', and 'other':
    unicodeRegExp.visible = unicodeRegExp.spliceCharacterClassRegExps(
        unicodeRegExp.letter,
        unicodeRegExp.mark,
        unicodeRegExp.number,
        unicodeRegExp.punctuation,
        unicodeRegExp.symbol
    );

    // The set of printable characters also includes space:
    unicodeRegExp.printable = unicodeRegExp.spliceCharacterClassRegExps(
        unicodeRegExp.visible,
        unicodeRegExp.separator
    );

    // Helper function for removing a char from a character class regular expression:

    function parseCharCode(u4, x2, literal) {
        if (u4 || x2) {
            return parseInt(u4 || x2, 16);
        } else {
            return literal.charCodeAt(0);
        }
    }

    function charCodeToRegExpToken(charCode) {
        if (charCode >= 0x20 && charCode < 0x7f) {
            return String.fromCharCode(charCode);
        } else {
            var hexStr = charCode.toString(16);
            return "\\u" + "0000".slice(hexStr.length) + hexStr;
        }
    }

    var characterClassToken = /(?:\\u([0-9a-f]{4})|\\x([0-9a-f]{2})|([^\-]))(?:-(?:\\u([0-9a-f]{4})|\\x([0-9a-f]{2})|([^\-])))?/gi;

    unicodeRegExp.removeCharacterFromCharacterClassRegExp = function (regExp, ch) {
        var charCode = ch.charCodeAt(0);

        return new RegExp('[' + regExp.source.replace(/^\[|\]$/g, '').replace(characterClassToken, function ($0, fromU4, fromX2, fromLiteral, toU4, toX2, toLiteral) {
            var fromCharCode = parseCharCode(fromU4, fromX2, fromLiteral);
            if (toU4 || toX2 || toLiteral) {
                var toCharCode = parseCharCode(toU4, toX2, toLiteral);
                if (charCode === fromCharCode) {
                    if (charCode + 1 < toCharCode) {
                        return charCodeToRegExpToken(charCode + 1) + '-' + charCodeToRegExpToken(toCharCode);
                    } else {
                        return charCodeToRegExpToken(toCharCode);
                    }
                } else if (charCode === toCharCode) {
                    if (fromCharCode < charCode - 1) {
                        return charCodeToRegExpToken(fromCharCode) + '-' + charCodeToRegExpToken(charCode - 1);
                    } else {
                        // fromCharCode === toCharCode - 1, rewrite to single char
                        return charCodeToRegExpToken(fromCharCode);
                    }
                } else if (charCode > fromCharCode && charCode < toCharCode) {
                    return charCodeToRegExpToken(fromCharCode) + (charCode > fromCharCode + 1 ? '-' + charCodeToRegExpToken(charCode - 1) : '') +
                        (charCode + 1 < toCharCode ? charCodeToRegExpToken(charCode + 1) + '-' : '') + charCodeToRegExpToken(toCharCode);
                } else {
                    return $0;
                }
            } else {
                if (charCode === fromCharCode) {
                    return "";
                } else {
                    return charCodeToRegExpToken(fromCharCode);
                }
            }
        }) + ']');
    };

    return unicodeRegExp;
}));

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xmldom/dom-parser.js":[function(require,module,exports){
function DOMParser(options){
	this.options = options ||{locator:{}};
	
}
DOMParser.prototype.parseFromString = function(source,mimeType){	
	var options = this.options;
	var sax =  new XMLReader();
	var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
	var errorHandler = options.errorHandler;
	var locator = options.locator;
	var defaultNSMap = options.xmlns||{};
	var entityMap = {'lt':'<','gt':'>','amp':'&','quot':'"','apos':"'"}
	if(locator){
		domBuilder.setDocumentLocator(locator)
	}
	
	sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);
	sax.domBuilder = options.domBuilder || domBuilder;
	if(/\/x?html?$/.test(mimeType)){
		entityMap.nbsp = '\xa0';
		entityMap.copy = '\xa9';
		defaultNSMap['']= 'http://www.w3.org/1999/xhtml';
	}
	if(source){
		sax.parse(source,defaultNSMap,entityMap);
	}else{
		sax.errorHandler.error("invalid document source");
	}
	return domBuilder.document;
}
function buildErrorHandler(errorImpl,domBuilder,locator){
	if(!errorImpl){
		if(domBuilder instanceof DOMHandler){
			return domBuilder;
		}
		errorImpl = domBuilder ;
	}
	var errorHandler = {}
	var isCallback = errorImpl instanceof Function;
	locator = locator||{}
	function build(key){
		var fn = errorImpl[key];
		if(!fn){
			if(isCallback){
				fn = errorImpl.length == 2?function(msg){errorImpl(key,msg)}:errorImpl;
			}else{
				var i=arguments.length;
				while(--i){
					if(fn = errorImpl[arguments[i]]){
						break;
					}
				}
			}
		}
		errorHandler[key] = fn && function(msg){
			fn(msg+_locator(locator));
		}||function(){};
	}
	build('warning','warn');
	build('error','warn','warning');
	build('fatalError','warn','warning','error');
	return errorHandler;
}
/**
 * +ContentHandler+ErrorHandler
 * +LexicalHandler+EntityResolver2
 * -DeclHandler-DTDHandler 
 * 
 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
 */
function DOMHandler() {
    this.cdata = false;
}
function position(locator,node){
	node.lineNumber = locator.lineNumber;
	node.columnNumber = locator.columnNumber;
}
/**
 * @see org.xml.sax.ContentHandler#startDocument
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
 */ 
DOMHandler.prototype = {
	startDocument : function() {
    	this.document = new DOMImplementation().createDocument(null, null, null);
    	if (this.locator) {
        	this.document.documentURI = this.locator.systemId;
    	}
	},
	startElement:function(namespaceURI, localName, qName, attrs) {
		var doc = this.document;
	    var el = doc.createElementNS(namespaceURI, qName||localName);
	    var len = attrs.length;
	    appendElement(this, el);
	    this.currentElement = el;
	    
		this.locator && position(this.locator,el)
	    for (var i = 0 ; i < len; i++) {
	        var namespaceURI = attrs.getURI(i);
	        var value = attrs.getValue(i);
	        var qName = attrs.getQName(i);
			var attr = doc.createAttributeNS(namespaceURI, qName);
			if( attr.getOffset){
				position(attr.getOffset(1),attr)
			}
			attr.value = attr.nodeValue = value;
			el.setAttributeNode(attr)
	    }
	},
	endElement:function(namespaceURI, localName, qName) {
		var current = this.currentElement
	    var tagName = current.tagName;
	    this.currentElement = current.parentNode;
	},
	startPrefixMapping:function(prefix, uri) {
	},
	endPrefixMapping:function(prefix) {
	},
	processingInstruction:function(target, data) {
	    var ins = this.document.createProcessingInstruction(target, data);
	    this.locator && position(this.locator,ins)
	    appendElement(this, ins);
	},
	ignorableWhitespace:function(ch, start, length) {
	},
	characters:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
		//console.log(chars)
		if(this.currentElement && chars){
			if (this.cdata) {
				var charNode = this.document.createCDATASection(chars);
				this.currentElement.appendChild(charNode);
			} else {
				var charNode = this.document.createTextNode(chars);
				this.currentElement.appendChild(charNode);
			}
			this.locator && position(this.locator,charNode)
		}
	},
	skippedEntity:function(name) {
	},
	endDocument:function() {
		this.document.normalize();
	},
	setDocumentLocator:function (locator) {
	    if(this.locator = locator){// && !('lineNumber' in locator)){
	    	locator.lineNumber = 0;
	    }
	},
	//LexicalHandler
	comment:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
	    var comm = this.document.createComment(chars);
	    this.locator && position(this.locator,comm)
	    appendElement(this, comm);
	},
	
	startCDATA:function() {
	    //used in characters() methods
	    this.cdata = true;
	},
	endCDATA:function() {
	    this.cdata = false;
	},
	
	startDTD:function(name, publicId, systemId) {
		var impl = this.document.implementation;
	    if (impl && impl.createDocumentType) {
	        var dt = impl.createDocumentType(name, publicId, systemId);
	        this.locator && position(this.locator,dt)
	        appendElement(this, dt);
	    }
	},
	/**
	 * @see org.xml.sax.ErrorHandler
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
	 */
	warning:function(error) {
		console.warn(error,_locator(this.locator));
	},
	error:function(error) {
		console.error(error,_locator(this.locator));
	},
	fatalError:function(error) {
		console.error(error,_locator(this.locator));
	    throw error;
	}
}
function _locator(l){
	if(l){
		return '\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'
	}
}
function _toString(chars,start,length){
	if(typeof chars == 'string'){
		return chars.substr(start,length)
	}else{//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
		if(chars.length >= start+length || start){
			return new java.lang.String(chars,start,length)+'';
		}
		return chars;
	}
}

/*
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
 * used method of org.xml.sax.ext.LexicalHandler:
 *  #comment(chars, start, length)
 *  #startCDATA()
 *  #endCDATA()
 *  #startDTD(name, publicId, systemId)
 *
 *
 * IGNORED method of org.xml.sax.ext.LexicalHandler:
 *  #endDTD()
 *  #startEntity(name)
 *  #endEntity(name)
 *
 *
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
 * IGNORED method of org.xml.sax.ext.DeclHandler
 * 	#attributeDecl(eName, aName, type, mode, value)
 *  #elementDecl(name, model)
 *  #externalEntityDecl(name, publicId, systemId)
 *  #internalEntityDecl(name, value)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
 * IGNORED method of org.xml.sax.EntityResolver2
 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
 *  #resolveEntity(publicId, systemId)
 *  #getExternalSubset(name, baseURI)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
 * IGNORED method of org.xml.sax.DTDHandler
 *  #notationDecl(name, publicId, systemId) {};
 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
 */
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){
	DOMHandler.prototype[key] = function(){return null}
})

/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
function appendElement (hander,node) {
    if (!hander.currentElement) {
        hander.document.appendChild(node);
    } else {
        hander.currentElement.appendChild(node);
    }
}//appendChild and setAttributeNS are preformance key

if(typeof require == 'function'){
	var XMLReader = require('./sax').XMLReader;
	var DOMImplementation = exports.DOMImplementation = require('./dom').DOMImplementation;
	exports.XMLSerializer = require('./dom').XMLSerializer ;
	exports.DOMParser = DOMParser;
}

},{"./dom":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xmldom/dom.js","./sax":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xmldom/sax.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xmldom/dom.js":[function(require,module,exports){
/*
 * DOM Level 2
 * Object DOMException
 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
 */

function copy(src,dest){
	for(var p in src){
		dest[p] = src[p];
	}
}
/**
^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
 */
function _extends(Class,Super){
	var pt = Class.prototype;
	if(Object.create){
		var ppt = Object.create(Super.prototype)
		pt.__proto__ = ppt;
	}
	if(!(pt instanceof Super)){
		function t(){};
		t.prototype = Super.prototype;
		t = new t();
		copy(pt,t);
		Class.prototype = pt = t;
	}
	if(pt.constructor != Class){
		if(typeof Class != 'function'){
			console.error("unknow Class:"+Class)
		}
		pt.constructor = Class
	}
}
var htmlns = 'http://www.w3.org/1999/xhtml' ;
// Node Types
var NodeType = {}
var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

// ExceptionCode
var ExceptionCode = {}
var ExceptionMessage = {};
var INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
var DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
var WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
var INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
var NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
var NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
//level2
var INVALID_STATE_ERR        	= ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
var SYNTAX_ERR               	= ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
var INVALID_MODIFICATION_ERR 	= ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
var NAMESPACE_ERR            	= ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
var INVALID_ACCESS_ERR       	= ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);


function DOMException(code, message) {
	if(message instanceof Error){
		var error = message;
	}else{
		error = this;
		Error.call(this, ExceptionMessage[code]);
		this.message = ExceptionMessage[code];
		if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
	}
	error.code = code;
	if(message) this.message = this.message + ": " + message;
	return error;
};
DOMException.prototype = Error.prototype;
copy(ExceptionCode,DOMException)
/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
 * The items in the NodeList are accessible via an integral index, starting from 0.
 */
function NodeList() {
};
NodeList.prototype = {
	/**
	 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
	 * @standard level1
	 */
	length:0, 
	/**
	 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
	 * @standard level1
	 * @param index  unsigned long 
	 *   Index into the collection.
	 * @return Node
	 * 	The node at the indexth position in the NodeList, or null if that is not a valid index. 
	 */
	item: function(index) {
		return this[index] || null;
	}
};
function LiveNodeList(node,refresh){
	this._node = node;
	this._refresh = refresh
	_updateLiveList(this);
}
function _updateLiveList(list){
	var inc = list._node._inc || list._node.ownerDocument._inc;
	if(list._inc != inc){
		var ls = list._refresh(list._node);
		//console.log(ls.length)
		__set__(list,'length',ls.length);
		copy(ls,list);
		list._inc = inc;
	}
}
LiveNodeList.prototype.item = function(i){
	_updateLiveList(this);
	return this[i];
}

_extends(LiveNodeList,NodeList);
/**
 * 
 * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.
 * NamedNodeMap objects in the DOM are live.
 * used for attributes or DocumentType entities 
 */
function NamedNodeMap() {
};

function _findNodeIndex(list,node){
	var i = list.length;
	while(i--){
		if(list[i] === node){return i}
	}
}

function _addNamedNode(el,list,newAttr,oldAttr){
	if(oldAttr){
		list[_findNodeIndex(list,oldAttr)] = newAttr;
	}else{
		list[list.length++] = newAttr;
	}
	if(el){
		newAttr.ownerElement = el;
		var doc = el.ownerDocument;
		if(doc){
			oldAttr && _onRemoveAttribute(doc,el,oldAttr);
			_onAddAttribute(doc,el,newAttr);
		}
	}
}
function _removeNamedNode(el,list,attr){
	var i = _findNodeIndex(list,attr);
	if(i>=0){
		var lastIndex = list.length-1
		while(i<lastIndex){
			list[i] = list[++i]
		}
		list.length = lastIndex;
		if(el){
			var doc = el.ownerDocument;
			if(doc){
				_onRemoveAttribute(doc,el,attr);
				attr.ownerElement = null;
			}
		}
	}else{
		throw DOMException(NOT_FOUND_ERR,new Error())
	}
}
NamedNodeMap.prototype = {
	length:0,
	item:NodeList.prototype.item,
	getNamedItem: function(key) {
//		if(key.indexOf(':')>0 || key == 'xmlns'){
//			return null;
//		}
		var i = this.length;
		while(i--){
			var attr = this[i];
			if(attr.nodeName == key){
				return attr;
			}
		}
	},
	setNamedItem: function(attr) {
		var el = attr.ownerElement;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		var oldAttr = this.getNamedItem(attr.nodeName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},
	/* returns Node */
	setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
		var el = attr.ownerElement, oldAttr;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},

	/* returns Node */
	removeNamedItem: function(key) {
		var attr = this.getNamedItem(key);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
		
		
	},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
	
	//for level2
	removeNamedItemNS:function(namespaceURI,localName){
		var attr = this.getNamedItemNS(namespaceURI,localName);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
	},
	getNamedItemNS: function(namespaceURI, localName) {
		var i = this.length;
		while(i--){
			var node = this[i];
			if(node.localName == localName && node.namespaceURI == namespaceURI){
				return node;
			}
		}
		return null;
	}
};
/**
 * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490
 */
function DOMImplementation(/* Object */ features) {
	this._features = {};
	if (features) {
		for (var feature in features) {
			 this._features = features[feature];
		}
	}
};

DOMImplementation.prototype = {
	hasFeature: function(/* string */ feature, /* string */ version) {
		var versions = this._features[feature.toLowerCase()];
		if (versions && (!version || version in versions)) {
			return true;
		} else {
			return false;
		}
	},
	// Introduced in DOM Level 2:
	createDocument:function(namespaceURI,  qualifiedName, doctype){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR
		var doc = new Document();
		doc.doctype = doctype;
		if(doctype){
			doc.appendChild(doctype);
		}
		doc.implementation = this;
		doc.childNodes = new NodeList();
		if(qualifiedName){
			var root = doc.createElementNS(namespaceURI,qualifiedName);
			doc.appendChild(root);
		}
		return doc;
	},
	// Introduced in DOM Level 2:
	createDocumentType:function(qualifiedName, publicId, systemId){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR
		var node = new DocumentType();
		node.name = qualifiedName;
		node.nodeName = qualifiedName;
		node.publicId = publicId;
		node.systemId = systemId;
		// Introduced in DOM Level 2:
		//readonly attribute DOMString        internalSubset;
		
		//TODO:..
		//  readonly attribute NamedNodeMap     entities;
		//  readonly attribute NamedNodeMap     notations;
		return node;
	}
};


/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
 */

function Node() {
};

Node.prototype = {
	firstChild : null,
	lastChild : null,
	previousSibling : null,
	nextSibling : null,
	attributes : null,
	parentNode : null,
	childNodes : null,
	ownerDocument : null,
	nodeValue : null,
	namespaceURI : null,
	prefix : null,
	localName : null,
	// Modified in DOM Level 2:
	insertBefore:function(newChild, refChild){//raises 
		return _insertBefore(this,newChild,refChild);
	},
	replaceChild:function(newChild, oldChild){//raises 
		this.insertBefore(newChild,oldChild);
		if(oldChild){
			this.removeChild(oldChild);
		}
	},
	removeChild:function(oldChild){
		return _removeChild(this,oldChild);
	},
	appendChild:function(newChild){
		return this.insertBefore(newChild,null);
	},
	hasChildNodes:function(){
		return this.firstChild != null;
	},
	cloneNode:function(deep){
		return cloneNode(this.ownerDocument||this,this,deep);
	},
	// Modified in DOM Level 2:
	normalize:function(){
		var child = this.firstChild;
		while(child){
			var next = child.nextSibling;
			if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
				this.removeChild(next);
				child.appendData(next.data);
			}else{
				child.normalize();
				child = next;
			}
		}
	},
  	// Introduced in DOM Level 2:
	isSupported:function(feature, version){
		return this.ownerDocument.implementation.hasFeature(feature,version);
	},
    // Introduced in DOM Level 2:
    hasAttributes:function(){
    	return this.attributes.length>0;
    },
    lookupPrefix:function(namespaceURI){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			for(var n in map){
    				if(map[n] == namespaceURI){
    					return n;
    				}
    			}
    		}
    		el = el.nodeType == 2?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI:function(prefix){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			if(prefix in map){
    				return map[prefix] ;
    			}
    		}
    		el = el.nodeType == 2?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace:function(namespaceURI){
    	var prefix = this.lookupPrefix(namespaceURI);
    	return prefix == null;
    }
};


function _xmlEncoder(c){
	return c == '<' && '&lt;' ||
         c == '>' && '&gt;' ||
         c == '&' && '&amp;' ||
         c == '"' && '&quot;' ||
         '&#'+c.charCodeAt()+';'
}


copy(NodeType,Node);
copy(NodeType,Node.prototype);

/**
 * @param callback return true for continue,false for break
 * @return boolean true: break visit;
 */
function _visitNode(node,callback){
	if(callback(node)){
		return true;
	}
	if(node = node.firstChild){
		do{
			if(_visitNode(node,callback)){return true}
        }while(node=node.nextSibling)
    }
}



function Document(){
}
function _onAddAttribute(doc,el,newAttr){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value
	}
}
function _onRemoveAttribute(doc,el,newAttr,remove){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		delete el._nsMap[newAttr.prefix?newAttr.localName:'']
	}
}
function _onUpdateChild(doc,el,newChild){
	if(doc && doc._inc){
		doc._inc++;
		//update childNodes
		var cs = el.childNodes;
		if(newChild){
			cs[cs.length++] = newChild;
		}else{
			//console.log(1)
			var child = el.firstChild;
			var i = 0;
			while(child){
				cs[i++] = child;
				child =child.nextSibling;
			}
			cs.length = i;
		}
	}
}

/**
 * attributes;
 * children;
 * 
 * writeable properties:
 * nodeValue,Attr:value,CharacterData:data
 * prefix
 */
function _removeChild(parentNode,child){
	var previous = child.previousSibling;
	var next = child.nextSibling;
	if(previous){
		previous.nextSibling = next;
	}else{
		parentNode.firstChild = next
	}
	if(next){
		next.previousSibling = previous;
	}else{
		parentNode.lastChild = previous;
	}
	_onUpdateChild(parentNode.ownerDocument,parentNode);
	return child;
}
/**
 * preformance key(refChild == null)
 */
function _insertBefore(parentNode,newChild,nextChild){
	var cp = newChild.parentNode;
	if(cp){
		cp.removeChild(newChild);//remove and update
	}
	if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
		var newFirst = newChild.firstChild;
		if (newFirst == null) {
			return newChild;
		}
		var newLast = newChild.lastChild;
	}else{
		newFirst = newLast = newChild;
	}
	var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;

	newFirst.previousSibling = pre;
	newLast.nextSibling = nextChild;
	
	
	if(pre){
		pre.nextSibling = newFirst;
	}else{
		parentNode.firstChild = newFirst;
	}
	if(nextChild == null){
		parentNode.lastChild = newLast;
	}else{
		nextChild.previousSibling = newLast;
	}
	do{
		newFirst.parentNode = parentNode;
	}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
	_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);
	//console.log(parentNode.lastChild.nextSibling == null)
	if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
		newChild.firstChild = newChild.lastChild = null;
	}
	return newChild;
}
function _appendSingleChild(parentNode,newChild){
	var cp = newChild.parentNode;
	if(cp){
		var pre = parentNode.lastChild;
		cp.removeChild(newChild);//remove and update
		var pre = parentNode.lastChild;
	}
	var pre = parentNode.lastChild;
	newChild.parentNode = parentNode;
	newChild.previousSibling = pre;
	newChild.nextSibling = null;
	if(pre){
		pre.nextSibling = newChild;
	}else{
		parentNode.firstChild = newChild;
	}
	parentNode.lastChild = newChild;
	_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);
	return newChild;
	//console.log("__aa",parentNode.lastChild.nextSibling == null)
}
Document.prototype = {
	//implementation : null,
	nodeName :  '#document',
	nodeType :  DOCUMENT_NODE,
	doctype :  null,
	documentElement :  null,
	_inc : 1,
	
	insertBefore :  function(newChild, refChild){//raises 
		if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
			var child = newChild.firstChild;
			while(child){
				var next = child.nextSibling;
				this.insertBefore(child,refChild);
				child = next;
			}
			return newChild;
		}
		if(this.documentElement == null && newChild.nodeType == 1){
			this.documentElement = newChild;
		}
		
		return _insertBefore(this,newChild,refChild),(newChild.ownerDocument = this),newChild;
	},
	removeChild :  function(oldChild){
		if(this.documentElement == oldChild){
			this.documentElement = null;
		}
		return _removeChild(this,oldChild);
	},
	// Introduced in DOM Level 2:
	importNode : function(importedNode,deep){
		return importNode(this,importedNode,deep);
	},
	// Introduced in DOM Level 2:
	getElementById :	function(id){
		var rtv = null;
		_visitNode(this.documentElement,function(node){
			if(node.nodeType == 1){
				if(node.getAttribute('id') == id){
					rtv = node;
					return true;
				}
			}
		})
		return rtv;
	},
	
	//document factory method:
	createElement :	function(tagName){
		var node = new Element();
		node.ownerDocument = this;
		node.nodeName = tagName;
		node.tagName = tagName;
		node.childNodes = new NodeList();
		var attrs	= node.attributes = new NamedNodeMap();
		attrs._ownerElement = node;
		return node;
	},
	createDocumentFragment :	function(){
		var node = new DocumentFragment();
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		return node;
	},
	createTextNode :	function(data){
		var node = new Text();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createComment :	function(data){
		var node = new Comment();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createCDATASection :	function(data){
		var node = new CDATASection();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createProcessingInstruction :	function(target,data){
		var node = new ProcessingInstruction();
		node.ownerDocument = this;
		node.tagName = node.target = target;
		node.nodeValue= node.data = data;
		return node;
	},
	createAttribute :	function(name){
		var node = new Attr();
		node.ownerDocument	= this;
		node.name = name;
		node.nodeName	= name;
		node.localName = name;
		node.specified = true;
		return node;
	},
	createEntityReference :	function(name){
		var node = new EntityReference();
		node.ownerDocument	= this;
		node.nodeName	= name;
		return node;
	},
	// Introduced in DOM Level 2:
	createElementNS :	function(namespaceURI,qualifiedName){
		var node = new Element();
		var pl = qualifiedName.split(':');
		var attrs	= node.attributes = new NamedNodeMap();
		node.childNodes = new NodeList();
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.tagName = qualifiedName;
		node.namespaceURI = namespaceURI;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		attrs._ownerElement = node;
		return node;
	},
	// Introduced in DOM Level 2:
	createAttributeNS :	function(namespaceURI,qualifiedName){
		var node = new Attr();
		var pl = qualifiedName.split(':');
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.name = qualifiedName;
		node.namespaceURI = namespaceURI;
		node.specified = true;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		return node;
	}
};
_extends(Document,Node);


function Element() {
	this._nsMap = {};
};
Element.prototype = {
	nodeType : ELEMENT_NODE,
	hasAttribute : function(name){
		return this.getAttributeNode(name)!=null;
	},
	getAttribute : function(name){
		var attr = this.getAttributeNode(name);
		return attr && attr.value || '';
	},
	getAttributeNode : function(name){
		return this.attributes.getNamedItem(name);
	},
	setAttribute : function(name, value){
		var attr = this.ownerDocument.createAttribute(name);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	removeAttribute : function(name){
		var attr = this.getAttributeNode(name)
		attr && this.removeAttributeNode(attr);
	},
	
	//four real opeartion method
	appendChild:function(newChild){
		if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
			return this.insertBefore(newChild,null);
		}else{
			return _appendSingleChild(this,newChild);
		}
	},
	setAttributeNode : function(newAttr){
		return this.attributes.setNamedItem(newAttr);
	},
	setAttributeNodeNS : function(newAttr){
		return this.attributes.setNamedItemNS(newAttr);
	},
	removeAttributeNode : function(oldAttr){
		return this.attributes.removeNamedItem(oldAttr.nodeName);
	},
	//get real attribute name,and remove it by removeAttributeNode
	removeAttributeNS : function(namespaceURI, localName){
		var old = this.getAttributeNodeNS(namespaceURI, localName);
		old && this.removeAttributeNode(old);
	},
	
	hasAttributeNS : function(namespaceURI, localName){
		return this.getAttributeNodeNS(namespaceURI, localName)!=null;
	},
	getAttributeNS : function(namespaceURI, localName){
		var attr = this.getAttributeNodeNS(namespaceURI, localName);
		return attr && attr.value || '';
	},
	setAttributeNS : function(namespaceURI, qualifiedName, value){
		var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
		attr.value = attr.nodeValue = value;
		this.setAttributeNode(attr)
	},
	getAttributeNodeNS : function(namespaceURI, localName){
		return this.attributes.getNamedItemNS(namespaceURI, localName);
	},
	
	getElementsByTagName : function(tagName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
					ls.push(node);
				}
			});
			return ls;
		});
	},
	getElementsByTagNameNS : function(namespaceURI, localName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType === ELEMENT_NODE && node.namespaceURI === namespaceURI && (localName === '*' || node.localName == localName)){
					ls.push(node);
				}
			});
			return ls;
		});
	}
};
Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


_extends(Element,Node);
function Attr() {
};
Attr.prototype.nodeType = ATTRIBUTE_NODE;
_extends(Attr,Node);


function CharacterData() {
};
CharacterData.prototype = {
	data : '',
	substringData : function(offset, count) {
		return this.data.substring(offset, offset+count);
	},
	appendData: function(text) {
		text = this.data+text;
		this.nodeValue = this.data = text;
		this.length = text.length;
	},
	insertData: function(offset,text) {
		this.replaceData(offset,0,text);
	
	},
	appendChild:function(newChild){
		//if(!(newChild instanceof CharacterData)){
			throw new Error(ExceptionMessage[3])
		//}
		return Node.prototype.appendChild.apply(this,arguments)
	},
	deleteData: function(offset, count) {
		this.replaceData(offset,count,"");
	},
	replaceData: function(offset, count, text) {
		var start = this.data.substring(0,offset);
		var end = this.data.substring(offset+count);
		text = start + text + end;
		this.nodeValue = this.data = text;
		this.length = text.length;
	}
}
_extends(CharacterData,Node);
function Text() {
};
Text.prototype = {
	nodeName : "#text",
	nodeType : TEXT_NODE,
	splitText : function(offset) {
		var text = this.data;
		var newText = text.substring(offset);
		text = text.substring(0, offset);
		this.data = this.nodeValue = text;
		this.length = text.length;
		var newNode = this.ownerDocument.createTextNode(newText);
		if(this.parentNode){
			this.parentNode.insertBefore(newNode, this.nextSibling);
		}
		return newNode;
	}
}
_extends(Text,CharacterData);
function Comment() {
};
Comment.prototype = {
	nodeName : "#comment",
	nodeType : COMMENT_NODE
}
_extends(Comment,CharacterData);

function CDATASection() {
};
CDATASection.prototype = {
	nodeName : "#cdata-section",
	nodeType : CDATA_SECTION_NODE
}
_extends(CDATASection,CharacterData);


function DocumentType() {
};
DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
_extends(DocumentType,Node);

function Notation() {
};
Notation.prototype.nodeType = NOTATION_NODE;
_extends(Notation,Node);

function Entity() {
};
Entity.prototype.nodeType = ENTITY_NODE;
_extends(Entity,Node);

function EntityReference() {
};
EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
_extends(EntityReference,Node);

function DocumentFragment() {
};
DocumentFragment.prototype.nodeName =	"#document-fragment";
DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
_extends(DocumentFragment,Node);


function ProcessingInstruction() {
}
ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
_extends(ProcessingInstruction,Node);
function XMLSerializer(){}
XMLSerializer.prototype.serializeToString = function(node){
	var buf = [];
	serializeToString(node,buf);
	return buf.join('');
}
Node.prototype.toString =function(){
	return XMLSerializer.prototype.serializeToString(this);
}
function serializeToString(node,buf){
	switch(node.nodeType){
	case ELEMENT_NODE:
		var attrs = node.attributes;
		var len = attrs.length;
		var child = node.firstChild;
		var nodeName = node.tagName;
		var isHTML = htmlns === node.namespaceURI
		buf.push('<',nodeName);
		for(var i=0;i<len;i++){
			serializeToString(attrs.item(i),buf,isHTML);
		}
		if(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){
			buf.push('>');
			//if is cdata child node
			if(isHTML && /^script$/i.test(nodeName)){
				if(child){
					buf.push(child.data);
				}
			}else{
				while(child){
					serializeToString(child,buf);
					child = child.nextSibling;
				}
			}
			buf.push('</',nodeName,'>');
		}else{
			buf.push('/>');
		}
		return;
	case DOCUMENT_NODE:
	case DOCUMENT_FRAGMENT_NODE:
		var child = node.firstChild;
		while(child){
			serializeToString(child,buf);
			child = child.nextSibling;
		}
		return;
	case ATTRIBUTE_NODE:
		return buf.push(' ',node.name,'="',node.value.replace(/[<&"]/g,_xmlEncoder),'"');
	case TEXT_NODE:
		return buf.push(node.data.replace(/[<&]/g,_xmlEncoder));
	case CDATA_SECTION_NODE:
		return buf.push( '<![CDATA[',node.data,']]>');
	case COMMENT_NODE:
		return buf.push( "<!--",node.data,"-->");
	case DOCUMENT_TYPE_NODE:
		var pubid = node.publicId;
		var sysid = node.systemId;
		buf.push('<!DOCTYPE ',node.name);
		if(pubid){
			buf.push(' PUBLIC "',pubid);
			if (sysid && sysid!='.') {
				buf.push( '" "',sysid);
			}
			buf.push('">');
		}else if(sysid && sysid!='.'){
			buf.push(' SYSTEM "',sysid,'">');
		}else{
			var sub = node.internalSubset;
			if(sub){
				buf.push(" [",sub,"]");
			}
			buf.push(">");
		}
		return;
	case PROCESSING_INSTRUCTION_NODE:
		return buf.push( "<?",node.target," ",node.data,"?>");
	case ENTITY_REFERENCE_NODE:
		return buf.push( '&',node.nodeName,';');
	//case ENTITY_NODE:
	//case NOTATION_NODE:
	default:
		buf.push('??',node.nodeName);
	}
}
function importNode(doc,node,deep){
	var node2;
	switch (node.nodeType) {
	case ELEMENT_NODE:
		node2 = node.cloneNode(false);
		node2.ownerDocument = doc;
		//var attrs = node2.attributes;
		//var len = attrs.length;
		//for(var i=0;i<len;i++){
			//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
		//}
	case DOCUMENT_FRAGMENT_NODE:
		break;
	case ATTRIBUTE_NODE:
		deep = true;
		break;
	//case ENTITY_REFERENCE_NODE:
	//case PROCESSING_INSTRUCTION_NODE:
	////case TEXT_NODE:
	//case CDATA_SECTION_NODE:
	//case COMMENT_NODE:
	//	deep = false;
	//	break;
	//case DOCUMENT_NODE:
	//case DOCUMENT_TYPE_NODE:
	//cannot be imported.
	//case ENTITY_NODE:
	//case NOTATION_NODE
	//can not hit in level3
	//default:throw e;
	}
	if(!node2){
		node2 = node.cloneNode(false);//false
	}
	node2.ownerDocument = doc;
	node2.parentNode = null;
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(importNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}
//
//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
function cloneNode(doc,node,deep){
	var node2 = new node.constructor();
	for(var n in node){
		var v = node[n];
		if(typeof v != 'object' ){
			if(v != node2[n]){
				node2[n] = v;
			}
		}
	}
	if(node.childNodes){
		node2.childNodes = new NodeList();
	}
	node2.ownerDocument = doc;
	switch (node2.nodeType) {
	case ELEMENT_NODE:
		var attrs	= node.attributes;
		var attrs2	= node2.attributes = new NamedNodeMap();
		var len = attrs.length
		attrs2._ownerElement = node2;
		for(var i=0;i<len;i++){
			node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
		}
		break;;
	case ATTRIBUTE_NODE:
		deep = true;
	}
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(cloneNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}

function __set__(object,key,value){
	object[key] = value
}
//do dynamic
try{
	if(Object.defineProperty){
		Object.defineProperty(LiveNodeList.prototype,'length',{
			get:function(){
				_updateLiveList(this);
				return this.$$length;
			}
		});
		Object.defineProperty(Node.prototype,'textContent',{
			get:function(){
				return getTextContent(this);
			},
			set:function(data){
				switch(this.nodeType){
				case 1:
				case 11:
					while(this.firstChild){
						this.removeChild(this.firstChild);
					}
					if(data || String(data)){
						this.appendChild(this.ownerDocument.createTextNode(data));
					}
					break;
				default:
					//TODO:
					this.data = data;
					this.value = value;
					this.nodeValue = data;
				}
			}
		})
		
		function getTextContent(node){
			switch(node.nodeType){
			case 1:
			case 11:
				var buf = [];
				node = node.firstChild;
				while(node){
					if(node.nodeType!==7 && node.nodeType !==8){
						buf.push(getTextContent(node));
					}
					node = node.nextSibling;
				}
				return buf.join('');
			default:
				return node.nodeValue;
			}
		}
		__set__ = function(object,key,value){
			//console.log(value)
			object['$$'+key] = value
		}
	}
}catch(e){//ie8
}

if(typeof require == 'function'){
	exports.DOMImplementation = DOMImplementation;
	exports.XMLSerializer = XMLSerializer;
}

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xmldom/sax.js":[function(require,module,exports){
//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
//[5]   	Name	   ::=   	NameStartChar (NameChar)*
var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]///\u10000-\uEFFFF
var nameChar = new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\u00B7\u0300-\u036F\\ux203F-\u2040]");
var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\:'+nameStartChar.source+nameChar.source+'*)?$');
//var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

//S_TAG,	S_ATTR,	S_EQ,	S_V
//S_ATTR_S,	S_E,	S_S,	S_C
var S_TAG = 0;//tag name offerring
var S_ATTR = 1;//attr name offerring 
var S_ATTR_S=2;//attr name end and space offer
var S_EQ = 3;//=space?
var S_V = 4;//attr value(no quot value only)
var S_E = 5;//attr value end and no space(quot end)
var S_S = 6;//(attr value end || tag end ) && (space offer)
var S_C = 7;//closed el<el />

function XMLReader(){
	
}

XMLReader.prototype = {
	parse:function(source,defaultNSMap,entityMap){
		var domBuilder = this.domBuilder;
		domBuilder.startDocument();
		_copy(defaultNSMap ,defaultNSMap = {})
		parse(source,defaultNSMap,entityMap,
				domBuilder,this.errorHandler);
		domBuilder.endDocument();
	}
}
function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){
  function fixedFromCharCode(code) {
		// String.prototype.fromCharCode does not supports
		// > 2 bytes unicode chars directly
		if (code > 0xffff) {
			code -= 0x10000;
			var surrogate1 = 0xd800 + (code >> 10)
				, surrogate2 = 0xdc00 + (code & 0x3ff);

			return String.fromCharCode(surrogate1, surrogate2);
		} else {
			return String.fromCharCode(code);
		}
	}
	function entityReplacer(a){
		var k = a.slice(1,-1);
		if(k in entityMap){
			return entityMap[k]; 
		}else if(k.charAt(0) === '#'){
			return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))
		}else{
			errorHandler.error('entity not found:'+a);
			return a;
		}
	}
	function appendText(end){//has some bugs
		var xt = source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);
		locator&&position(start);
		domBuilder.characters(xt,0,end-start);
		start = end
	}
	function position(start,m){
		while(start>=endPos && (m = linePattern.exec(source))){
			startPos = m.index;
			endPos = startPos + m[0].length;
			locator.lineNumber++;
			//console.log('line++:',locator,startPos,endPos)
		}
		locator.columnNumber = start-startPos+1;
	}
	var startPos = 0;
	var endPos = 0;
	var linePattern = /.+(?:\r\n?|\n)|.*$/g
	var locator = domBuilder.locator;
	
	var parseStack = [{currentNSMap:defaultNSMapCopy}]
	var closeMap = {};
	var start = 0;
	while(true){
		var i = source.indexOf('<',start);
		if(i<0){
			if(!source.substr(start).match(/^\s*$/)){
				var doc = domBuilder.document;
    			var text = doc.createTextNode(source.substr(start));
    			doc.appendChild(text);
    			domBuilder.currentElement = text;
			}
			return;
		}
		if(i>start){
			appendText(i);
		}
		switch(source.charAt(i+1)){
		case '/':
			var end = source.indexOf('>',i+3);
			var tagName = source.substring(i+2,end);
			var config = parseStack.pop();
			var localNSMap = config.localNSMap;
			
	        if(config.tagName != tagName){
	            errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName );
	        }
			domBuilder.endElement(config.uri,config.localName,tagName);
			if(localNSMap){
				for(var prefix in localNSMap){
					domBuilder.endPrefixMapping(prefix) ;
				}
			}
			end++;
			break;
			// end elment
		case '?':// <?...?>
			locator&&position(i);
			end = parseInstruction(source,i,domBuilder);
			break;
		case '!':// <!doctype,<![CDATA,<!--
			locator&&position(i);
			end = parseDCC(source,i,domBuilder,errorHandler);
			break;
		default:
			try{
				locator&&position(i);
				
				var el = new ElementAttributes();
				
				//elStartEnd
				var end = parseElementStartPart(source,i,el,entityReplacer,errorHandler);
				var len = el.length;
				//position fixed
				if(len && locator){
					var backup = copyLocator(locator,{});
					for(var i = 0;i<len;i++){
						var a = el[i];
						position(a.offset);
						a.offset = copyLocator(locator,{});
					}
					copyLocator(backup,locator);
				}
				if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){
					el.closed = true;
					if(!entityMap.nbsp){
						errorHandler.warning('unclosed xml attribute');
					}
				}
				appendElement(el,domBuilder,parseStack);
				
				
				if(el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed){
					end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)
				}else{
					end++;
				}
			}catch(e){
				errorHandler.error('element parse error: '+e);
				end = -1;
			}

		}
		if(end<0){
			//TODO: sax
			appendText(i+1);
		}else{
			start = end;
		}
	}
}
function copyLocator(f,t){
	t.lineNumber = f.lineNumber;
	t.columnNumber = f.columnNumber;
	return t;
	
}

/**
 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
 */
function parseElementStartPart(source,start,el,entityReplacer,errorHandler){
	var attrName;
	var value;
	var p = ++start;
	var s = S_TAG;//status
	while(true){
		var c = source.charAt(p);
		switch(c){
		case '=':
			if(s === S_ATTR){//attrName
				attrName = source.slice(start,p);
				s = S_EQ;
			}else if(s === S_ATTR_S){
				s = S_EQ;
			}else{
				//fatalError: equal must after attrName or space after attrName
				throw new Error('attribute equal must after attrName');
			}
			break;
		case '\'':
		case '"':
			if(s === S_EQ){//equal
				start = p+1;
				p = source.indexOf(c,start)
				if(p>0){
					value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					el.add(attrName,value,start-1);
					s = S_E;
				}else{
					//fatalError: no end quot match
					throw new Error('attribute value no end \''+c+'\' match');
				}
			}else if(s == S_V){
				value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
				//console.log(attrName,value,start,p)
				el.add(attrName,value,start);
				//console.dir(el)
				errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');
				start = p+1;
				s = S_E
			}else{
				//fatalError: no equal before
				throw new Error('attribute value must after "="');
			}
			break;
		case '/':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_E:
			case S_S:
			case S_C:
				s = S_C;
				el.closed = true;
			case S_V:
			case S_ATTR:
			case S_ATTR_S:
				break;
			//case S_EQ:
			default:
				throw new Error("attribute invalid close char('/')")
			}
			break;
		case ''://end document
			//throw new Error('unexpected end of input')
			errorHandler.error('unexpected end of input');
		case '>':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_E:
			case S_S:
			case S_C:
				break;//normal
			case S_V://Compatible state
			case S_ATTR:
				value = source.slice(start,p);
				if(value.slice(-1) === '/'){
					el.closed  = true;
					value = value.slice(0,-1)
				}
			case S_ATTR_S:
				if(s === S_ATTR_S){
					value = attrName;
				}
				if(s == S_V){
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					el.add(attrName,value.replace(/&#?\w+;/g,entityReplacer),start)
				}else{
					errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')
					el.add(value,value,start)
				}
				break;
			case S_EQ:
				throw new Error('attribute value missed!!');
			}
//			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
			return p;
		/*xml space '\x20' | #x9 | #xD | #xA; */
		case '\u0080':
			c = ' ';
		default:
			if(c<= ' '){//space
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));//tagName
					s = S_S;
					break;
				case S_ATTR:
					attrName = source.slice(start,p)
					s = S_ATTR_S;
					break;
				case S_V:
					var value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					el.add(attrName,value,start)
				case S_E:
					s = S_S;
					break;
				//case S_S:
				//case S_EQ:
				//case S_ATTR_S:
				//	void();break;
				//case S_C:
					//ignore warning
				}
			}else{//not space
//S_TAG,	S_ATTR,	S_EQ,	S_V
//S_ATTR_S,	S_E,	S_S,	S_C
				switch(s){
				//case S_TAG:void();break;
				//case S_ATTR:void();break;
				//case S_V:void();break;
				case S_ATTR_S:
					errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead!!')
					el.add(attrName,attrName,start);
					start = p;
					s = S_ATTR;
					break;
				case S_E:
					errorHandler.warning('attribute space is required"'+attrName+'"!!')
				case S_S:
					s = S_ATTR;
					start = p;
					break;
				case S_EQ:
					s = S_V;
					start = p;
					break;
				case S_C:
					throw new Error("elements closed character '/' and '>' must be connected to");
				}
			}
		}
		p++;
	}
}
/**
 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
 */
function appendElement(el,domBuilder,parseStack){
	var tagName = el.tagName;
	var localNSMap = null;
	var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
	var i = el.length;
	while(i--){
		var a = el[i];
		var qName = a.qName;
		var value = a.value;
		var nsp = qName.indexOf(':');
		if(nsp>0){
			var prefix = a.prefix = qName.slice(0,nsp);
			var localName = qName.slice(nsp+1);
			var nsPrefix = prefix === 'xmlns' && localName
		}else{
			localName = qName;
			prefix = null
			nsPrefix = qName === 'xmlns' && ''
		}
		//can not set prefix,because prefix !== ''
		a.localName = localName ;
		//prefix == null for no ns prefix attribute 
		if(nsPrefix !== false){//hack!!
			if(localNSMap == null){
				localNSMap = {}
				//console.log(currentNSMap,0)
				_copy(currentNSMap,currentNSMap={})
				//console.log(currentNSMap,1)
			}
			currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
			a.uri = 'http://www.w3.org/2000/xmlns/'
			domBuilder.startPrefixMapping(nsPrefix, value) 
		}
	}
	var i = el.length;
	while(i--){
		a = el[i];
		var prefix = a.prefix;
		if(prefix){//no prefix attribute has no namespace
			if(prefix === 'xml'){
				a.uri = 'http://www.w3.org/XML/1998/namespace';
			}if(prefix !== 'xmlns'){
				a.uri = currentNSMap[prefix]
				
				//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
			}
		}
	}
	var nsp = tagName.indexOf(':');
	if(nsp>0){
		prefix = el.prefix = tagName.slice(0,nsp);
		localName = el.localName = tagName.slice(nsp+1);
	}else{
		prefix = null;//important!!
		localName = el.localName = tagName;
	}
	//no prefix element has default namespace
	var ns = el.uri = currentNSMap[prefix || ''];
	domBuilder.startElement(ns,localName,tagName,el);
	//endPrefixMapping and startPrefixMapping have not any help for dom builder
	//localNSMap = null
	if(el.closed){
		domBuilder.endElement(ns,localName,tagName);
		if(localNSMap){
			for(prefix in localNSMap){
				domBuilder.endPrefixMapping(prefix) 
			}
		}
	}else{
		el.currentNSMap = currentNSMap;
		el.localNSMap = localNSMap;
		parseStack.push(el);
	}
}
function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){
	if(/^(?:script|textarea)$/i.test(tagName)){
		var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);
		var text = source.substring(elStartEnd+1,elEndStart);
		if(/[&<]/.test(text)){
			if(/^script$/i.test(tagName)){
				//if(!/\]\]>/.test(text)){
					//lexHandler.startCDATA();
					domBuilder.characters(text,0,text.length);
					//lexHandler.endCDATA();
					return elEndStart;
				//}
			}//}else{//text area
				text = text.replace(/&#?\w+;/g,entityReplacer);
				domBuilder.characters(text,0,text.length);
				return elEndStart;
			//}
			
		}
	}
	return elStartEnd+1;
}
function fixSelfClosed(source,elStartEnd,tagName,closeMap){
	//if(tagName in closeMap){
	var pos = closeMap[tagName];
	if(pos == null){
		//console.log(tagName)
		pos = closeMap[tagName] = source.lastIndexOf('</'+tagName+'>')
	}
	return pos<elStartEnd;
	//} 
}
function _copy(source,target){
	for(var n in source){target[n] = source[n]}
}
function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'
	var next= source.charAt(start+2)
	switch(next){
	case '-':
		if(source.charAt(start + 3) === '-'){
			var end = source.indexOf('-->',start+4);
			//append comment source.substring(4,end)//<!--
			if(end>start){
				domBuilder.comment(source,start+4,end-start-4);
				return end+3;
			}else{
				errorHandler.error("Unclosed comment");
				return -1;
			}
		}else{
			//error
			return -1;
		}
	default:
		if(source.substr(start+3,6) == 'CDATA['){
			var end = source.indexOf(']]>',start+9);
			domBuilder.startCDATA();
			domBuilder.characters(source,start+9,end-start-9);
			domBuilder.endCDATA() 
			return end+3;
		}
		//<!DOCTYPE
		//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) 
		var matchs = split(source,start);
		var len = matchs.length;
		if(len>1 && /!doctype/i.test(matchs[0][0])){
			var name = matchs[1][0];
			var pubid = len>3 && /^public$/i.test(matchs[2][0]) && matchs[3][0]
			var sysid = len>4 && matchs[4][0];
			var lastMatch = matchs[len-1]
			domBuilder.startDTD(name,pubid && pubid.replace(/^(['"])(.*?)\1$/,'$2'),
					sysid && sysid.replace(/^(['"])(.*?)\1$/,'$2'));
			domBuilder.endDTD();
			
			return lastMatch.index+lastMatch[0].length
		}
	}
	return -1;
}



function parseInstruction(source,start,domBuilder){
	var end = source.indexOf('?>',start);
	if(end){
		var match = source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
		if(match){
			var len = match[0].length;
			domBuilder.processingInstruction(match[1], match[2]) ;
			return end+2;
		}else{//error
			return -1;
		}
	}
	return -1;
}

/**
 * @param source
 */
function ElementAttributes(source){
	
}
ElementAttributes.prototype = {
	setTagName:function(tagName){
		if(!tagNamePattern.test(tagName)){
			throw new Error('invalid tagName:'+tagName)
		}
		this.tagName = tagName
	},
	add:function(qName,value,offset){
		if(!tagNamePattern.test(qName)){
			throw new Error('invalid attribute:'+qName)
		}
		this[this.length++] = {qName:qName,value:value,offset:offset}
	},
	length:0,
	getLocalName:function(i){return this[i].localName},
	getOffset:function(i){return this[i].offset},
	getQName:function(i){return this[i].qName},
	getURI:function(i){return this[i].uri},
	getValue:function(i){return this[i].value}
//	,getIndex:function(uri, localName)){
//		if(localName){
//			
//		}else{
//			var qName = uri
//		}
//	},
//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
//	getType:function(uri,localName){}
//	getType:function(i){},
}




function _set_proto_(thiz,parent){
	thiz.__proto__ = parent;
	return thiz;
}
if(!(_set_proto_({},_set_proto_.prototype) instanceof _set_proto_)){
	_set_proto_ = function(thiz,parent){
		function p(){};
		p.prototype = parent;
		p = new p();
		for(parent in thiz){
			p[parent] = thiz[parent];
		}
		return p;
	}
}

function split(source,start){
	var match;
	var buf = [];
	var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
	reg.lastIndex = start;
	reg.exec(source);//skip <
	while(match = reg.exec(source)){
		buf.push(match);
		if(match[1])return buf;
	}
}

if(typeof require == 'function'){
	exports.XMLReader = XMLReader;
}


},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xpath/xpath.js":[function(require,module,exports){
/*
 * xpath.js
 *
 * An XPath 1.0 library for JavaScript.
 *
 * Cameron McCormack <cam (at) mcc.id.au>
 *
 * This work is licensed under the Creative Commons Attribution-ShareAlike
 * License. To view a copy of this license, visit
 *
 *   http://creativecommons.org/licenses/by-sa/2.0/
 *
 * or send a letter to Creative Commons, 559 Nathan Abbott Way, Stanford,
 * California 94305, USA.
 *
 * Revision 20: April 26, 2011
 *   Fixed a typo resulting in FIRST_ORDERED_NODE_TYPE results being wrong,
 *   thanks to <shi_a009 (at) hotmail.com>.
 *
 * Revision 19: November 29, 2005
 *   Nodesets now store their nodes in a height balanced tree, increasing
 *   performance for the common case of selecting nodes in document order,
 *   thanks to Sastien Cramatte <contact (at) zeninteractif.com>.
 *   AVL tree code adapted from Raimund Neumann <rnova (at) gmx.net>.
 *
 * Revision 18: October 27, 2005
 *   DOM 3 XPath support.  Caveats:
 *     - namespace prefixes aren't resolved in XPathEvaluator.createExpression,
 *       but in XPathExpression.evaluate.
 *     - XPathResult.invalidIteratorState is not implemented.
 *
 * Revision 17: October 25, 2005
 *   Some core XPath function fixes and a patch to avoid crashing certain
 *   versions of MSXML in PathExpr.prototype.getOwnerElement, thanks to
 *   Sastien Cramatte <contact (at) zeninteractif.com>.
 *
 * Revision 16: September 22, 2005
 *   Workarounds for some IE 5.5 deficiencies.
 *   Fixed problem with prefix node tests on attribute nodes.
 *
 * Revision 15: May 21, 2005
 *   Fixed problem with QName node tests on elements with an xmlns="...".
 *
 * Revision 14: May 19, 2005
 *   Fixed QName node tests on attribute node regression.
 *
 * Revision 13: May 3, 2005
 *   Node tests are case insensitive now if working in an HTML DOM.
 *
 * Revision 12: April 26, 2005
 *   Updated licence.  Slight code changes to enable use of Dean
 *   Edwards' script compression, http://dean.edwards.name/packer/ .
 *
 * Revision 11: April 23, 2005
 *   Fixed bug with 'and' and 'or' operators, fix thanks to
 *   Sandy McArthur <sandy (at) mcarthur.org>.
 *
 * Revision 10: April 15, 2005
 *   Added support for a virtual root node, supposedly helpful for
 *   implementing XForms.  Fixed problem with QName node tests and
 *   the parent axis.
 *
 * Revision 9: March 17, 2005
 *   Namespace resolver tweaked so using the document node as the context
 *   for namespace lookups is equivalent to using the document element.
 *
 * Revision 8: February 13, 2005
 *   Handle implicit declaration of 'xmlns' namespace prefix.
 *   Fixed bug when comparing nodesets.
 *   Instance data can now be associated with a FunctionResolver, and
 *     workaround for MSXML not supporting 'localName' and 'getElementById',
 *     thanks to Grant Gongaware.
 *   Fix a few problems when the context node is the root node.
 *
 * Revision 7: February 11, 2005
 *   Default namespace resolver fix from Grant Gongaware
 *   <grant (at) gongaware.com>.
 *
 * Revision 6: February 10, 2005
 *   Fixed bug in 'number' function.
 *
 * Revision 5: February 9, 2005
 *   Fixed bug where text nodes not getting converted to string values.
 *
 * Revision 4: January 21, 2005
 *   Bug in 'name' function, fix thanks to Bill Edney.
 *   Fixed incorrect processing of namespace nodes.
 *   Fixed NamespaceResolver to resolve 'xml' namespace.
 *   Implemented union '|' operator.
 *
 * Revision 3: January 14, 2005
 *   Fixed bug with nodeset comparisons, bug lexing < and >.
 *
 * Revision 2: October 26, 2004
 *   QName node test namespace handling fixed.  Few other bug fixes.
 *
 * Revision 1: August 13, 2004
 *   Bug fixes from William J. Edney <bedney (at) technicalpursuit.com>.
 *   Added minimal licence.
 *
 * Initial version: June 14, 2004
 */

// non-node wrapper
if(typeof exports === 'undefined' ) {
	xpath = {};
}
(function(exports) {
	
// XPathParser ///////////////////////////////////////////////////////////////

XPathParser.prototype = new Object();
XPathParser.prototype.constructor = XPathParser;
XPathParser.superclass = Object.prototype;

function XPathParser() {
	this.init();
}

XPathParser.prototype.init = function() {
	this.reduceActions = [];

	this.reduceActions[3] = function(rhs) {
		return new OrOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[5] = function(rhs) {
		return new AndOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[7] = function(rhs) {
		return new EqualsOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[8] = function(rhs) {
		return new NotEqualOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[10] = function(rhs) {
		return new LessThanOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[11] = function(rhs) {
		return new GreaterThanOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[12] = function(rhs) {
		return new LessThanOrEqualOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[13] = function(rhs) {
		return new GreaterThanOrEqualOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[15] = function(rhs) {
		return new PlusOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[16] = function(rhs) {
		return new MinusOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[18] = function(rhs) {
		return new MultiplyOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[19] = function(rhs) {
		return new DivOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[20] = function(rhs) {
		return new ModOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[22] = function(rhs) {
		return new UnaryMinusOperation(rhs[1]);
	};
	this.reduceActions[24] = function(rhs) {
		return new BarOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[25] = function(rhs) {
		return new PathExpr(undefined, undefined, rhs[0]);
	};
	this.reduceActions[27] = function(rhs) {
		rhs[0].locationPath = rhs[2];
		return rhs[0];
	};
	this.reduceActions[28] = function(rhs) {
		rhs[0].locationPath = rhs[2];
		rhs[0].locationPath.steps.unshift(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));
		return rhs[0];
	};
	this.reduceActions[29] = function(rhs) {
		return new PathExpr(rhs[0], [], undefined);
	};
	this.reduceActions[30] = function(rhs) {
		if (Utilities.instance_of(rhs[0], PathExpr)) {
			if (rhs[0].filterPredicates == undefined) {
				rhs[0].filterPredicates = [];
			}
			rhs[0].filterPredicates.push(rhs[1]);
			return rhs[0];
		} else {
			return new PathExpr(rhs[0], [rhs[1]], undefined);
		}
	};
	this.reduceActions[32] = function(rhs) {
		return rhs[1];
	};
	this.reduceActions[33] = function(rhs) {
		return new XString(rhs[0]);
	};
	this.reduceActions[34] = function(rhs) {
		return new XNumber(rhs[0]);
	};
	this.reduceActions[36] = function(rhs) {
		return new FunctionCall(rhs[0], []);
	};
	this.reduceActions[37] = function(rhs) {
		return new FunctionCall(rhs[0], rhs[2]);
	};
	this.reduceActions[38] = function(rhs) {
		return [ rhs[0] ];
	};
	this.reduceActions[39] = function(rhs) {
		rhs[2].unshift(rhs[0]);
		return rhs[2];
	};
	this.reduceActions[43] = function(rhs) {
		return new LocationPath(true, []);
	};
	this.reduceActions[44] = function(rhs) {
		rhs[1].absolute = true;
		return rhs[1];
	};
	this.reduceActions[46] = function(rhs) {
		return new LocationPath(false, [ rhs[0] ]);
	};
	this.reduceActions[47] = function(rhs) {
		rhs[0].steps.push(rhs[2]);
		return rhs[0];
	};
	this.reduceActions[49] = function(rhs) {
		return new Step(rhs[0], rhs[1], []);
	};
	this.reduceActions[50] = function(rhs) {
		return new Step(Step.CHILD, rhs[0], []);
	};
	this.reduceActions[51] = function(rhs) {
		return new Step(rhs[0], rhs[1], rhs[2]);
	};
	this.reduceActions[52] = function(rhs) {
		return new Step(Step.CHILD, rhs[0], rhs[1]);
	};
	this.reduceActions[54] = function(rhs) {
		return [ rhs[0] ];
	};
	this.reduceActions[55] = function(rhs) {
		rhs[1].unshift(rhs[0]);
		return rhs[1];
	};
	this.reduceActions[56] = function(rhs) {
		if (rhs[0] == "ancestor") {
			return Step.ANCESTOR;
		} else if (rhs[0] == "ancestor-or-self") {
			return Step.ANCESTORORSELF;
		} else if (rhs[0] == "attribute") {
			return Step.ATTRIBUTE;
		} else if (rhs[0] == "child") {
			return Step.CHILD;
		} else if (rhs[0] == "descendant") {
			return Step.DESCENDANT;
		} else if (rhs[0] == "descendant-or-self") {
			return Step.DESCENDANTORSELF;
		} else if (rhs[0] == "following") {
			return Step.FOLLOWING;
		} else if (rhs[0] == "following-sibling") {
			return Step.FOLLOWINGSIBLING;
		} else if (rhs[0] == "namespace") {
			return Step.NAMESPACE;
		} else if (rhs[0] == "parent") {
			return Step.PARENT;
		} else if (rhs[0] == "preceding") {
			return Step.PRECEDING;
		} else if (rhs[0] == "preceding-sibling") {
			return Step.PRECEDINGSIBLING;
		} else if (rhs[0] == "self") {
			return Step.SELF;
		}
		return -1;
	};
	this.reduceActions[57] = function(rhs) {
		return Step.ATTRIBUTE;
	};
	this.reduceActions[59] = function(rhs) {
		if (rhs[0] == "comment") {
			return new NodeTest(NodeTest.COMMENT, undefined);
		} else if (rhs[0] == "text") {
			return new NodeTest(NodeTest.TEXT, undefined);
		} else if (rhs[0] == "processing-instruction") {
			return new NodeTest(NodeTest.PI, undefined);
		} else if (rhs[0] == "node") {
			return new NodeTest(NodeTest.NODE, undefined);
		}
		return new NodeTest(-1, undefined);
	};
	this.reduceActions[60] = function(rhs) {
		return new NodeTest(NodeTest.PI, rhs[2]);
	};
	this.reduceActions[61] = function(rhs) {
		return rhs[1];
	};
	this.reduceActions[63] = function(rhs) {
		rhs[1].absolute = true;
		rhs[1].steps.unshift(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));
		return rhs[1];
	};
	this.reduceActions[64] = function(rhs) {
		rhs[0].steps.push(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));
		rhs[0].steps.push(rhs[2]);
		return rhs[0];
	};
	this.reduceActions[65] = function(rhs) {
		return new Step(Step.SELF, new NodeTest(NodeTest.NODE, undefined), []);
	};
	this.reduceActions[66] = function(rhs) {
		return new Step(Step.PARENT, new NodeTest(NodeTest.NODE, undefined), []);
	};
	this.reduceActions[67] = function(rhs) {
		return new VariableReference(rhs[1]);
	};
	this.reduceActions[68] = function(rhs) {
		return new NodeTest(NodeTest.NAMETESTANY, undefined);
	};
	this.reduceActions[69] = function(rhs) {
		var prefix = rhs[0].substring(0, rhs[0].indexOf(":"));
		return new NodeTest(NodeTest.NAMETESTPREFIXANY, prefix);
	};
	this.reduceActions[70] = function(rhs) {
		return new NodeTest(NodeTest.NAMETESTQNAME, rhs[0]);
	};
};

XPathParser.actionTable = [
	" s s        sssssssss    s ss  s  ss",
	"                 s                  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"                rrrrr               ",
	" s s        sssssssss    s ss  s  ss",
	"rs  rrrrrrrr s  sssssrrrrrr  rrs rs ",
	" s s        sssssssss    s ss  s  ss",
	"                            s       ",
	"                            s       ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"  s                                 ",
	"                            s       ",
	" s           s  sssss          s  s ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"a                                   ",
	"r       s                    rr  r  ",
	"r      sr                    rr  r  ",
	"r   s  rr            s       rr  r  ",
	"r   rssrr            rss     rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrrsss         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrrs  rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r  srrrrrrrr         rrrrrrs rr sr  ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"                sssss               ",
	"r  rrrrrrrrr         rrrrrrr rr sr  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             s      ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"              s                     ",
	"                             s      ",
	"                rrrrr               ",
	" s s        sssssssss    s sss s  ss",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss      ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s           s  sssss          s  s ",
	" s           s  sssss          s  s ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	" s           s  sssss          s  s ",
	" s           s  sssss          s  s ",
	"r  rrrrrrrrr         rrrrrrr rr sr  ",
	"r  rrrrrrrrr         rrrrrrr rr sr  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             s      ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             rr     ",
	"                             s      ",
	"                             rs     ",
	"r      sr                    rr  r  ",
	"r   s  rr            s       rr  r  ",
	"r   rssrr            rss     rr  r  ",
	"r   rssrr            rss     rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrrsss         rrrrr   rr  r  ",
	"r   rrrrrsss         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"                                 r  ",
	"                                 s  ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	" s s        sssssssss    s ss  s  ss",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             r      "
];

XPathParser.actionTableNumber = [
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"                 J                  ",
	"a  aaaaaaaaa         aaaaaaa aa  a  ",
	"                YYYYY               ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"K1  KKKKKKKK .  +*)('KKKKKK  KK# K\" ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"                            N       ",
	"                            O       ",
	"e  eeeeeeeee         eeeeeee ee ee  ",
	"f  fffffffff         fffffff ff ff  ",
	"d  ddddddddd         ddddddd dd dd  ",
	"B  BBBBBBBBB         BBBBBBB BB BB  ",
	"A  AAAAAAAAA         AAAAAAA AA AA  ",
	"  P                                 ",
	"                            Q       ",
	" 1           .  +*)('          #  \" ",
	"b  bbbbbbbbb         bbbbbbb bb  b  ",
	"                                    ",
	"!       S                    !!  !  ",
	"\"      T\"                    \"\"  \"  ",
	"$   V  $$            U       $$  $  ",
	"&   &ZY&&            &XW     &&  &  ",
	")   )))))            )))\\[   ))  )  ",
	".   ....._^]         .....   ..  .  ",
	"1   11111111         11111   11  1  ",
	"5   55555555         55555`  55  5  ",
	"7   77777777         777777  77  7  ",
	"9   99999999         999999  99  9  ",
	":  c::::::::         ::::::b :: a:  ",
	"I  fIIIIIIII         IIIIIIe II  I  ",
	"=  =========         ======= == ==  ",
	"?  ?????????         ??????? ?? ??  ",
	"C  CCCCCCCCC         CCCCCCC CC CC  ",
	"J   JJJJJJJJ         JJJJJJ  JJ  J  ",
	"M   MMMMMMMM         MMMMMM  MM  M  ",
	"N  NNNNNNNNN         NNNNNNN NN  N  ",
	"P  PPPPPPPPP         PPPPPPP PP  P  ",
	"                +*)('               ",
	"R  RRRRRRRRR         RRRRRRR RR aR  ",
	"U  UUUUUUUUU         UUUUUUU UU  U  ",
	"Z  ZZZZZZZZZ         ZZZZZZZ ZZ ZZ  ",
	"c  ccccccccc         ccccccc cc cc  ",
	"                             j      ",
	"L  fLLLLLLLL         LLLLLLe LL  L  ",
	"6   66666666         66666   66  6  ",
	"              k                     ",
	"                             l      ",
	"                XXXXX               ",
	" 1 0        /.-,+*)('    & %$m #  \"!",
	"_  f________         ______e __  _  ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('      %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1           .  +*)('          #  \" ",
	" 1           .  +*)('          #  \" ",
	">  >>>>>>>>>         >>>>>>> >> >>  ",
	" 1           .  +*)('          #  \" ",
	" 1           .  +*)('          #  \" ",
	"Q  QQQQQQQQQ         QQQQQQQ QQ aQ  ",
	"V  VVVVVVVVV         VVVVVVV VV aV  ",
	"T  TTTTTTTTT         TTTTTTT TT  T  ",
	"@  @@@@@@@@@         @@@@@@@ @@ @@  ",
	"                             \x87      ",
	"[  [[[[[[[[[         [[[[[[[ [[ [[  ",
	"D  DDDDDDDDD         DDDDDDD DD DD  ",
	"                             HH     ",
	"                             \x88      ",
	"                             F\x89     ",
	"#      T#                    ##  #  ",
	"%   V  %%            U       %%  %  ",
	"'   'ZY''            'XW     ''  '  ",
	"(   (ZY((            (XW     ((  (  ",
	"+   +++++            +++\\[   ++  +  ",
	"*   *****            ***\\[   **  *  ",
	"-   -----            ---\\[   --  -  ",
	",   ,,,,,            ,,,\\[   ,,  ,  ",
	"0   00000_^]         00000   00  0  ",
	"/   /////_^]         /////   //  /  ",
	"2   22222222         22222   22  2  ",
	"3   33333333         33333   33  3  ",
	"4   44444444         44444   44  4  ",
	"8   88888888         888888  88  8  ",
	"                                 ^  ",
	"                                 \x8a  ",
	";  f;;;;;;;;         ;;;;;;e ;;  ;  ",
	"<  f<<<<<<<<         <<<<<<e <<  <  ",
	"O  OOOOOOOOO         OOOOOOO OO  O  ",
	"`  `````````         ``````` ``  `  ",
	"S  SSSSSSSSS         SSSSSSS SS  S  ",
	"W  WWWWWWWWW         WWWWWWW WW  W  ",
	"\\  \\\\\\\\\\\\\\\\\\         \\\\\\\\\\\\\\ \\\\ \\\\  ",
	"E  EEEEEEEEE         EEEEEEE EE EE  ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"]  ]]]]]]]]]         ]]]]]]] ]] ]]  ",
	"                             G      "
];

XPathParser.gotoTable = [
	"3456789:;<=>?@ AB  CDEFGH IJ ",
	"                             ",
	"                             ",
	"                             ",
	"L456789:;<=>?@ AB  CDEFGH IJ ",
	"            M        EFGH IJ ",
	"       N;<=>?@ AB  CDEFGH IJ ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"            S        EFGH IJ ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"              e              ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                        h  J ",
	"              i          j   ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"o456789:;<=>?@ ABpqCDEFGH IJ ",
	"                             ",
	"  r6789:;<=>?@ AB  CDEFGH IJ ",
	"   s789:;<=>?@ AB  CDEFGH IJ ",
	"    t89:;<=>?@ AB  CDEFGH IJ ",
	"    u89:;<=>?@ AB  CDEFGH IJ ",
	"     v9:;<=>?@ AB  CDEFGH IJ ",
	"     w9:;<=>?@ AB  CDEFGH IJ ",
	"     x9:;<=>?@ AB  CDEFGH IJ ",
	"     y9:;<=>?@ AB  CDEFGH IJ ",
	"      z:;<=>?@ AB  CDEFGH IJ ",
	"      {:;<=>?@ AB  CDEFGH IJ ",
	"       |;<=>?@ AB  CDEFGH IJ ",
	"       };<=>?@ AB  CDEFGH IJ ",
	"       ~;<=>?@ AB  CDEFGH IJ ",
	"         \x7f=>?@ AB  CDEFGH IJ ",
	"\x80456789:;<=>?@ AB  CDEFGH IJ\x81",
	"            \x82        EFGH IJ ",
	"            \x83        EFGH IJ ",
	"                             ",
	"                     \x84 GH IJ ",
	"                     \x85 GH IJ ",
	"              i          \x86   ",
	"              i          \x87   ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"o456789:;<=>?@ AB\x8cqCDEFGH IJ ",
	"                             ",
	"                             "
];

XPathParser.productions = [
	[1, 1, 2],
	[2, 1, 3],
	[3, 1, 4],
	[3, 3, 3, -9, 4],
	[4, 1, 5],
	[4, 3, 4, -8, 5],
	[5, 1, 6],
	[5, 3, 5, -22, 6],
	[5, 3, 5, -5, 6],
	[6, 1, 7],
	[6, 3, 6, -23, 7],
	[6, 3, 6, -24, 7],
	[6, 3, 6, -6, 7],
	[6, 3, 6, -7, 7],
	[7, 1, 8],
	[7, 3, 7, -25, 8],
	[7, 3, 7, -26, 8],
	[8, 1, 9],
	[8, 3, 8, -12, 9],
	[8, 3, 8, -11, 9],
	[8, 3, 8, -10, 9],
	[9, 1, 10],
	[9, 2, -26, 9],
	[10, 1, 11],
	[10, 3, 10, -27, 11],
	[11, 1, 12],
	[11, 1, 13],
	[11, 3, 13, -28, 14],
	[11, 3, 13, -4, 14],
	[13, 1, 15],
	[13, 2, 13, 16],
	[15, 1, 17],
	[15, 3, -29, 2, -30],
	[15, 1, -15],
	[15, 1, -16],
	[15, 1, 18],
	[18, 3, -13, -29, -30],
	[18, 4, -13, -29, 19, -30],
	[19, 1, 20],
	[19, 3, 20, -31, 19],
	[20, 1, 2],
	[12, 1, 14],
	[12, 1, 21],
	[21, 1, -28],
	[21, 2, -28, 14],
	[21, 1, 22],
	[14, 1, 23],
	[14, 3, 14, -28, 23],
	[14, 1, 24],
	[23, 2, 25, 26],
	[23, 1, 26],
	[23, 3, 25, 26, 27],
	[23, 2, 26, 27],
	[23, 1, 28],
	[27, 1, 16],
	[27, 2, 16, 27],
	[25, 2, -14, -3],
	[25, 1, -32],
	[26, 1, 29],
	[26, 3, -20, -29, -30],
	[26, 4, -21, -29, -15, -30],
	[16, 3, -33, 30, -34],
	[30, 1, 2],
	[22, 2, -4, 14],
	[24, 3, 14, -4, 23],
	[28, 1, -35],
	[28, 1, -2],
	[17, 2, -36, -18],
	[29, 1, -17],
	[29, 1, -19],
	[29, 1, -18]
];

XPathParser.DOUBLEDOT = 2;
XPathParser.DOUBLECOLON = 3;
XPathParser.DOUBLESLASH = 4;
XPathParser.NOTEQUAL = 5;
XPathParser.LESSTHANOREQUAL = 6;
XPathParser.GREATERTHANOREQUAL = 7;
XPathParser.AND = 8;
XPathParser.OR = 9;
XPathParser.MOD = 10;
XPathParser.DIV = 11;
XPathParser.MULTIPLYOPERATOR = 12;
XPathParser.FUNCTIONNAME = 13;
XPathParser.AXISNAME = 14;
XPathParser.LITERAL = 15;
XPathParser.NUMBER = 16;
XPathParser.ASTERISKNAMETEST = 17;
XPathParser.QNAME = 18;
XPathParser.NCNAMECOLONASTERISK = 19;
XPathParser.NODETYPE = 20;
XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL = 21;
XPathParser.EQUALS = 22;
XPathParser.LESSTHAN = 23;
XPathParser.GREATERTHAN = 24;
XPathParser.PLUS = 25;
XPathParser.MINUS = 26;
XPathParser.BAR = 27;
XPathParser.SLASH = 28;
XPathParser.LEFTPARENTHESIS = 29;
XPathParser.RIGHTPARENTHESIS = 30;
XPathParser.COMMA = 31;
XPathParser.AT = 32;
XPathParser.LEFTBRACKET = 33;
XPathParser.RIGHTBRACKET = 34;
XPathParser.DOT = 35;
XPathParser.DOLLAR = 36;

XPathParser.prototype.tokenize = function(s1) {
	var types = [];
	var values = [];
	var s = s1 + '\0';

	var pos = 0;
	var c = s.charAt(pos++);
	while (1) {
		while (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
			c = s.charAt(pos++);
		}
		if (c == '\0' || pos >= s.length) {
			break;
		}

		if (c == '(') {
			types.push(XPathParser.LEFTPARENTHESIS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == ')') {
			types.push(XPathParser.RIGHTPARENTHESIS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '[') {
			types.push(XPathParser.LEFTBRACKET);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == ']') {
			types.push(XPathParser.RIGHTBRACKET);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '@') {
			types.push(XPathParser.AT);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == ',') {
			types.push(XPathParser.COMMA);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '|') {
			types.push(XPathParser.BAR);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '+') {
			types.push(XPathParser.PLUS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '-') {
			types.push(XPathParser.MINUS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '=') {
			types.push(XPathParser.EQUALS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '$') {
			types.push(XPathParser.DOLLAR);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}

		if (c == '.') {
			c = s.charAt(pos++);
			if (c == '.') {
				types.push(XPathParser.DOUBLEDOT);
				values.push("..");
				c = s.charAt(pos++);
				continue;
			}
			if (c >= '0' && c <= '9') {
				var number = "." + c;
				c = s.charAt(pos++);
				while (c >= '0' && c <= '9') {
					number += c;
					c = s.charAt(pos++);
				}
				types.push(XPathParser.NUMBER);
				values.push(number);
				continue;
			}
			types.push(XPathParser.DOT);
			values.push('.');
			continue;
		}

		if (c == '\'' || c == '"') {
			var delimiter = c;
			var literal = "";
			while ((c = s.charAt(pos++)) != delimiter) {
				literal += c;
			}
			types.push(XPathParser.LITERAL);
			values.push(literal);
			c = s.charAt(pos++);
			continue;
		}

		if (c >= '0' && c <= '9') {
			var number = c;
			c = s.charAt(pos++);
			while (c >= '0' && c <= '9') {
				number += c;
				c = s.charAt(pos++);
			}
			if (c == '.') {
				if (s.charAt(pos) >= '0' && s.charAt(pos) <= '9') {
					number += c;
					number += s.charAt(pos++);
					c = s.charAt(pos++);
					while (c >= '0' && c <= '9') {
						number += c;
						c = s.charAt(pos++);
					}
				}
			}
			types.push(XPathParser.NUMBER);
			values.push(number);
			continue;
		}

		if (c == '*') {
			if (types.length > 0) {
				var last = types[types.length - 1];
				if (last != XPathParser.AT
						&& last != XPathParser.DOUBLECOLON
						&& last != XPathParser.LEFTPARENTHESIS
						&& last != XPathParser.LEFTBRACKET
						&& last != XPathParser.AND
						&& last != XPathParser.OR
						&& last != XPathParser.MOD
						&& last != XPathParser.DIV
						&& last != XPathParser.MULTIPLYOPERATOR
						&& last != XPathParser.SLASH
						&& last != XPathParser.DOUBLESLASH
						&& last != XPathParser.BAR
						&& last != XPathParser.PLUS
						&& last != XPathParser.MINUS
						&& last != XPathParser.EQUALS
						&& last != XPathParser.NOTEQUAL
						&& last != XPathParser.LESSTHAN
						&& last != XPathParser.LESSTHANOREQUAL
						&& last != XPathParser.GREATERTHAN
						&& last != XPathParser.GREATERTHANOREQUAL) {
					types.push(XPathParser.MULTIPLYOPERATOR);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
			}
			types.push(XPathParser.ASTERISKNAMETEST);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}

		if (c == ':') {
			if (s.charAt(pos) == ':') {
				types.push(XPathParser.DOUBLECOLON);
				values.push("::");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
		}

		if (c == '/') {
			c = s.charAt(pos++);
			if (c == '/') {
				types.push(XPathParser.DOUBLESLASH);
				values.push("//");
				c = s.charAt(pos++);
				continue;
			}
			types.push(XPathParser.SLASH);
			values.push('/');
			continue;
		}

		if (c == '!') {
			if (s.charAt(pos) == '=') {
				types.push(XPathParser.NOTEQUAL);
				values.push("!=");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
		}

		if (c == '<') {
			if (s.charAt(pos) == '=') {
				types.push(XPathParser.LESSTHANOREQUAL);
				values.push("<=");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
			types.push(XPathParser.LESSTHAN);
			values.push('<');
			c = s.charAt(pos++);
			continue;
		}

		if (c == '>') {
			if (s.charAt(pos) == '=') {
				types.push(XPathParser.GREATERTHANOREQUAL);
				values.push(">=");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
			types.push(XPathParser.GREATERTHAN);
			values.push('>');
			c = s.charAt(pos++);
			continue;
		}

		if (c == '_' || Utilities.isLetter(c.charCodeAt(0))) {
			var name = c;
			c = s.charAt(pos++);
			while (Utilities.isNCNameChar(c.charCodeAt(0))) {
				name += c;
				c = s.charAt(pos++);
			}
			if (types.length > 0) {
				var last = types[types.length - 1];
				if (last != XPathParser.AT
						&& last != XPathParser.DOUBLECOLON
						&& last != XPathParser.LEFTPARENTHESIS
						&& last != XPathParser.LEFTBRACKET
						&& last != XPathParser.AND
						&& last != XPathParser.OR
						&& last != XPathParser.MOD
						&& last != XPathParser.DIV
						&& last != XPathParser.MULTIPLYOPERATOR
						&& last != XPathParser.SLASH
						&& last != XPathParser.DOUBLESLASH
						&& last != XPathParser.BAR
						&& last != XPathParser.PLUS
						&& last != XPathParser.MINUS
						&& last != XPathParser.EQUALS
						&& last != XPathParser.NOTEQUAL
						&& last != XPathParser.LESSTHAN
						&& last != XPathParser.LESSTHANOREQUAL
						&& last != XPathParser.GREATERTHAN
						&& last != XPathParser.GREATERTHANOREQUAL) {
					if (name == "and") {
						types.push(XPathParser.AND);
						values.push(name);
						continue;
					}
					if (name == "or") {
						types.push(XPathParser.OR);
						values.push(name);
						continue;
					}
					if (name == "mod") {
						types.push(XPathParser.MOD);
						values.push(name);
						continue;
					}
					if (name == "div") {
						types.push(XPathParser.DIV);
						values.push(name);
						continue;
					}
				}
			}
			if (c == ':') {
				if (s.charAt(pos) == '*') {
					types.push(XPathParser.NCNAMECOLONASTERISK);
					values.push(name + ":*");
					pos++;
					c = s.charAt(pos++);
					continue;
				}
				if (s.charAt(pos) == '_' || Utilities.isLetter(s.charCodeAt(pos))) {
					name += ':';
					c = s.charAt(pos++);
					while (Utilities.isNCNameChar(c.charCodeAt(0))) {
						name += c;
						c = s.charAt(pos++);
					}
					if (c == '(') {
						types.push(XPathParser.FUNCTIONNAME);
						values.push(name);
						continue;
					}
					types.push(XPathParser.QNAME);
					values.push(name);
					continue;
				}
				if (s.charAt(pos) == ':') {
					types.push(XPathParser.AXISNAME);
					values.push(name);
					continue;
				}
			}
			if (c == '(') {
				if (name == "comment" || name == "text" || name == "node") {
					types.push(XPathParser.NODETYPE);
					values.push(name);
					continue;
				}
				if (name == "processing-instruction") {
					if (s.charAt(pos) == ')') {
						types.push(XPathParser.NODETYPE);
					} else {
						types.push(XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL);
					}
					values.push(name);
					continue;
				}
				types.push(XPathParser.FUNCTIONNAME);
				values.push(name);
				continue;
			}
			types.push(XPathParser.QNAME);
			values.push(name);
			continue;
		}

		throw new Error("Unexpected character " + c);
	}
	types.push(1);
	values.push("[EOF]");
	return [types, values];
};

XPathParser.SHIFT = 's';
XPathParser.REDUCE = 'r';
XPathParser.ACCEPT = 'a';

XPathParser.prototype.parse = function(s) {
	var types;
	var values;
	var res = this.tokenize(s);
	if (res == undefined) {
		return undefined;
	}
	types = res[0];
	values = res[1];
	var tokenPos = 0;
	var state = [];
	var tokenType = [];
	var tokenValue = [];
	var s;
	var a;
	var t;

	state.push(0);
	tokenType.push(1);
	tokenValue.push("_S");

	a = types[tokenPos];
	t = values[tokenPos++];
	while (1) {
		s = state[state.length - 1];
		switch (XPathParser.actionTable[s].charAt(a - 1)) {
			case XPathParser.SHIFT:
				tokenType.push(-a);
				tokenValue.push(t);
				state.push(XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32);
				a = types[tokenPos];
				t = values[tokenPos++];
				break;
			case XPathParser.REDUCE:
				var num = XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][1];
				var rhs = [];
				for (var i = 0; i < num; i++) {
					tokenType.pop();
					rhs.unshift(tokenValue.pop());
					state.pop();
				}
				var s_ = state[state.length - 1];
				tokenType.push(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0]);
				if (this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32] == undefined) {
					tokenValue.push(rhs[0]);
				} else {
					tokenValue.push(this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32](rhs));
				}
				state.push(XPathParser.gotoTable[s_].charCodeAt(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0] - 2) - 33);
				break;
			case XPathParser.ACCEPT:
				return new XPath(tokenValue.pop());
			default:
				throw new Error("XPath parse error");
		}
	}
};

// XPath /////////////////////////////////////////////////////////////////////

XPath.prototype = new Object();
XPath.prototype.constructor = XPath;
XPath.superclass = Object.prototype;

function XPath(e) {
	this.expression = e;
}

XPath.prototype.toString = function() {
	return this.expression.toString();
};

XPath.prototype.evaluate = function(c) {
	c.contextNode = c.expressionContextNode;
	c.contextSize = 1;
	c.contextPosition = 1;
	c.caseInsensitive = false;
	if (c.contextNode != null) {
		var doc = c.contextNode;
		if (doc.nodeType != 9 /*Node.DOCUMENT_NODE*/) {
			doc = doc.ownerDocument;
		}
		try {
			c.caseInsensitive = doc.implementation.hasFeature("HTML", "2.0");
		} catch (e) {
			c.caseInsensitive = true;
		}
	}
	return this.expression.evaluate(c);
};

XPath.XML_NAMESPACE_URI = "http://www.w3.org/XML/1998/namespace";
XPath.XMLNS_NAMESPACE_URI = "http://www.w3.org/2000/xmlns/";

// Expression ////////////////////////////////////////////////////////////////

Expression.prototype = new Object();
Expression.prototype.constructor = Expression;
Expression.superclass = Object.prototype;

function Expression() {
}

Expression.prototype.init = function() {
};

Expression.prototype.toString = function() {
	return "<Expression>";
};

Expression.prototype.evaluate = function(c) {
	throw new Error("Could not evaluate expression.");
};

// UnaryOperation ////////////////////////////////////////////////////////////

UnaryOperation.prototype = new Expression();
UnaryOperation.prototype.constructor = UnaryOperation;
UnaryOperation.superclass = Expression.prototype;

function UnaryOperation(rhs) {
	if (arguments.length > 0) {
		this.init(rhs);
	}
}

UnaryOperation.prototype.init = function(rhs) {
	this.rhs = rhs;
};

// UnaryMinusOperation ///////////////////////////////////////////////////////

UnaryMinusOperation.prototype = new UnaryOperation();
UnaryMinusOperation.prototype.constructor = UnaryMinusOperation;
UnaryMinusOperation.superclass = UnaryOperation.prototype;

function UnaryMinusOperation(rhs) {
	if (arguments.length > 0) {
		this.init(rhs);
	}
}

UnaryMinusOperation.prototype.init = function(rhs) {
	UnaryMinusOperation.superclass.init.call(this, rhs);
};

UnaryMinusOperation.prototype.evaluate = function(c) {
	return this.rhs.evaluate(c).number().negate();
};

UnaryMinusOperation.prototype.toString = function() {
	return "-" + this.rhs.toString();
};

// BinaryOperation ///////////////////////////////////////////////////////////

BinaryOperation.prototype = new Expression();
BinaryOperation.prototype.constructor = BinaryOperation;
BinaryOperation.superclass = Expression.prototype;

function BinaryOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

BinaryOperation.prototype.init = function(lhs, rhs) {
	this.lhs = lhs;
	this.rhs = rhs;
};

// OrOperation ///////////////////////////////////////////////////////////////

OrOperation.prototype = new BinaryOperation();
OrOperation.prototype.constructor = OrOperation;
OrOperation.superclass = BinaryOperation.prototype;

function OrOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

OrOperation.prototype.init = function(lhs, rhs) {
	OrOperation.superclass.init.call(this, lhs, rhs);
};

OrOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " or " + this.rhs.toString() + ")";
};

OrOperation.prototype.evaluate = function(c) {
	var b = this.lhs.evaluate(c).bool();
	if (b.booleanValue()) {
		return b;
	}
	return this.rhs.evaluate(c).bool();
};

// AndOperation //////////////////////////////////////////////////////////////

AndOperation.prototype = new BinaryOperation();
AndOperation.prototype.constructor = AndOperation;
AndOperation.superclass = BinaryOperation.prototype;

function AndOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

AndOperation.prototype.init = function(lhs, rhs) {
	AndOperation.superclass.init.call(this, lhs, rhs);
};

AndOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " and " + this.rhs.toString() + ")";
};

AndOperation.prototype.evaluate = function(c) {
	var b = this.lhs.evaluate(c).bool();
	if (!b.booleanValue()) {
		return b;
	}
	return this.rhs.evaluate(c).bool();
};

// EqualsOperation ///////////////////////////////////////////////////////////

EqualsOperation.prototype = new BinaryOperation();
EqualsOperation.prototype.constructor = EqualsOperation;
EqualsOperation.superclass = BinaryOperation.prototype;

function EqualsOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

EqualsOperation.prototype.init = function(lhs, rhs) {
	EqualsOperation.superclass.init.call(this, lhs, rhs);
};

EqualsOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " = " + this.rhs.toString() + ")";
};

EqualsOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).equals(this.rhs.evaluate(c));
};

// NotEqualOperation /////////////////////////////////////////////////////////

NotEqualOperation.prototype = new BinaryOperation();
NotEqualOperation.prototype.constructor = NotEqualOperation;
NotEqualOperation.superclass = BinaryOperation.prototype;

function NotEqualOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

NotEqualOperation.prototype.init = function(lhs, rhs) {
	NotEqualOperation.superclass.init.call(this, lhs, rhs);
};

NotEqualOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " != " + this.rhs.toString() + ")";
};

NotEqualOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).notequal(this.rhs.evaluate(c));
};

// LessThanOperation /////////////////////////////////////////////////////////

LessThanOperation.prototype = new BinaryOperation();
LessThanOperation.prototype.constructor = LessThanOperation;
LessThanOperation.superclass = BinaryOperation.prototype;

function LessThanOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

LessThanOperation.prototype.init = function(lhs, rhs) {
	LessThanOperation.superclass.init.call(this, lhs, rhs);
};

LessThanOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).lessthan(this.rhs.evaluate(c));
};

LessThanOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " < " + this.rhs.toString() + ")";
};

// GreaterThanOperation //////////////////////////////////////////////////////

GreaterThanOperation.prototype = new BinaryOperation();
GreaterThanOperation.prototype.constructor = GreaterThanOperation;
GreaterThanOperation.superclass = BinaryOperation.prototype;

function GreaterThanOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

GreaterThanOperation.prototype.init = function(lhs, rhs) {
	GreaterThanOperation.superclass.init.call(this, lhs, rhs);
};

GreaterThanOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).greaterthan(this.rhs.evaluate(c));
};

GreaterThanOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " > " + this.rhs.toString() + ")";
};

// LessThanOrEqualOperation //////////////////////////////////////////////////

LessThanOrEqualOperation.prototype = new BinaryOperation();
LessThanOrEqualOperation.prototype.constructor = LessThanOrEqualOperation;
LessThanOrEqualOperation.superclass = BinaryOperation.prototype;

function LessThanOrEqualOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

LessThanOrEqualOperation.prototype.init = function(lhs, rhs) {
	LessThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
};

LessThanOrEqualOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).lessthanorequal(this.rhs.evaluate(c));
};

LessThanOrEqualOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " <= " + this.rhs.toString() + ")";
};

// GreaterThanOrEqualOperation ///////////////////////////////////////////////

GreaterThanOrEqualOperation.prototype = new BinaryOperation();
GreaterThanOrEqualOperation.prototype.constructor = GreaterThanOrEqualOperation;
GreaterThanOrEqualOperation.superclass = BinaryOperation.prototype;

function GreaterThanOrEqualOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

GreaterThanOrEqualOperation.prototype.init = function(lhs, rhs) {
	GreaterThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
};

GreaterThanOrEqualOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).greaterthanorequal(this.rhs.evaluate(c));
};

GreaterThanOrEqualOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " >= " + this.rhs.toString() + ")";
};

// PlusOperation /////////////////////////////////////////////////////////////

PlusOperation.prototype = new BinaryOperation();
PlusOperation.prototype.constructor = PlusOperation;
PlusOperation.superclass = BinaryOperation.prototype;

function PlusOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

PlusOperation.prototype.init = function(lhs, rhs) {
	PlusOperation.superclass.init.call(this, lhs, rhs);
};

PlusOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().plus(this.rhs.evaluate(c).number());
};

PlusOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " + " + this.rhs.toString() + ")";
};

// MinusOperation ////////////////////////////////////////////////////////////

MinusOperation.prototype = new BinaryOperation();
MinusOperation.prototype.constructor = MinusOperation;
MinusOperation.superclass = BinaryOperation.prototype;

function MinusOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

MinusOperation.prototype.init = function(lhs, rhs) {
	MinusOperation.superclass.init.call(this, lhs, rhs);
};

MinusOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().minus(this.rhs.evaluate(c).number());
};

MinusOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " - " + this.rhs.toString() + ")";
};

// MultiplyOperation /////////////////////////////////////////////////////////

MultiplyOperation.prototype = new BinaryOperation();
MultiplyOperation.prototype.constructor = MultiplyOperation;
MultiplyOperation.superclass = BinaryOperation.prototype;

function MultiplyOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

MultiplyOperation.prototype.init = function(lhs, rhs) {
	MultiplyOperation.superclass.init.call(this, lhs, rhs);
};

MultiplyOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().multiply(this.rhs.evaluate(c).number());
};

MultiplyOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " * " + this.rhs.toString() + ")";
};

// DivOperation //////////////////////////////////////////////////////////////

DivOperation.prototype = new BinaryOperation();
DivOperation.prototype.constructor = DivOperation;
DivOperation.superclass = BinaryOperation.prototype;

function DivOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

DivOperation.prototype.init = function(lhs, rhs) {
	DivOperation.superclass.init.call(this, lhs, rhs);
};

DivOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().div(this.rhs.evaluate(c).number());
};

DivOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " div " + this.rhs.toString() + ")";
};

// ModOperation //////////////////////////////////////////////////////////////

ModOperation.prototype = new BinaryOperation();
ModOperation.prototype.constructor = ModOperation;
ModOperation.superclass = BinaryOperation.prototype;

function ModOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

ModOperation.prototype.init = function(lhs, rhs) {
	ModOperation.superclass.init.call(this, lhs, rhs);
};

ModOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().mod(this.rhs.evaluate(c).number());
};

ModOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " mod " + this.rhs.toString() + ")";
};

// BarOperation //////////////////////////////////////////////////////////////

BarOperation.prototype = new BinaryOperation();
BarOperation.prototype.constructor = BarOperation;
BarOperation.superclass = BinaryOperation.prototype;

function BarOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

BarOperation.prototype.init = function(lhs, rhs) {
	BarOperation.superclass.init.call(this, lhs, rhs);
};

BarOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).nodeset().union(this.rhs.evaluate(c).nodeset());
};

BarOperation.prototype.toString = function() {
	return this.lhs.toString() + " | " + this.rhs.toString();
};

// PathExpr //////////////////////////////////////////////////////////////////

PathExpr.prototype = new Expression();
PathExpr.prototype.constructor = PathExpr;
PathExpr.superclass = Expression.prototype;

function PathExpr(filter, filterPreds, locpath) {
	if (arguments.length > 0) {
		this.init(filter, filterPreds, locpath);
	}
}

PathExpr.prototype.init = function(filter, filterPreds, locpath) {
	PathExpr.superclass.init.call(this);
	this.filter = filter;
	this.filterPredicates = filterPreds;
	this.locationPath = locpath;
};

PathExpr.prototype.evaluate = function(c) {
	var nodes;
	var xpc = new XPathContext();
	xpc.variableResolver = c.variableResolver;
	xpc.functionResolver = c.functionResolver;
	xpc.namespaceResolver = c.namespaceResolver;
	xpc.expressionContextNode = c.expressionContextNode;
	xpc.virtualRoot = c.virtualRoot;
	xpc.caseInsensitive = c.caseInsensitive;
	if (this.filter == null) {
		nodes = [ c.contextNode ];
	} else {
		var ns = this.filter.evaluate(c);
		if (!Utilities.instance_of(ns, XNodeSet)) {
			if (this.filterPredicates != null && this.filterPredicates.length > 0 || this.locationPath != null) {
				throw new Error("Path expression filter must evaluate to a nodset if predicates or location path are used");
			}
			return ns;
		}
		nodes = ns.toArray();
		if (this.filterPredicates != null) {
			// apply each of the predicates in turn
			for (var j = 0; j < this.filterPredicates.length; j++) {
				var pred = this.filterPredicates[j];
				var newNodes = [];
				xpc.contextSize = nodes.length;
				for (xpc.contextPosition = 1; xpc.contextPosition <= xpc.contextSize; xpc.contextPosition++) {
					xpc.contextNode = nodes[xpc.contextPosition - 1];
					if (this.predicateMatches(pred, xpc)) {
						newNodes.push(xpc.contextNode);
					}
				}
				nodes = newNodes;
			}
		}
	}
	if (this.locationPath != null) {
		if (this.locationPath.absolute) {
			if (nodes[0].nodeType != 9 /*Node.DOCUMENT_NODE*/) {
				if (xpc.virtualRoot != null) {
					nodes = [ xpc.virtualRoot ];
				} else {
					if (nodes[0].ownerDocument == null) {
						// IE 5.5 doesn't have ownerDocument?
						var n = nodes[0];
						while (n.parentNode != null) {
							n = n.parentNode;
						}
						nodes = [ n ];
					} else {
						nodes = [ nodes[0].ownerDocument ];
					}
				}
			} else {
				nodes = [ nodes[0] ];
			}
		}
		for (var i = 0; i < this.locationPath.steps.length; i++) {
			var step = this.locationPath.steps[i];
			var newNodes = [];
			for (var j = 0; j < nodes.length; j++) {
				xpc.contextNode = nodes[j];
				switch (step.axis) {
					case Step.ANCESTOR:
						// look at all the ancestor nodes
						if (xpc.contextNode === xpc.virtualRoot) {
							break;
						}
						var m;
						if (xpc.contextNode.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
							m = this.getOwnerElement(xpc.contextNode);
						} else {
							m = xpc.contextNode.parentNode;
						}
						while (m != null) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
							if (m === xpc.virtualRoot) {
								break;
							}
							m = m.parentNode;
						}
						break;

					case Step.ANCESTORORSELF:
						// look at all the ancestor nodes and the current node
						for (var m = xpc.contextNode; m != null; m = m.nodeType == 2 /*Node.ATTRIBUTE_NODE*/ ? this.getOwnerElement(m) : m.parentNode) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
							if (m === xpc.virtualRoot) {
								break;
							}
						}
						break;

					case Step.ATTRIBUTE:
						// look at the attributes
						var nnm = xpc.contextNode.attributes;
						if (nnm != null) {
							for (var k = 0; k < nnm.length; k++) {
								var m = nnm.item(k);
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.push(m);
								}
							}
						}
						break;

					case Step.CHILD:
						// look at all child elements
						for (var m = xpc.contextNode.firstChild; m != null; m = m.nextSibling) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
						}
						break;

					case Step.DESCENDANT:
						// look at all descendant nodes
						var st = [ xpc.contextNode.firstChild ];
						while (st.length > 0) {
							for (var m = st.pop(); m != null; ) {
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.push(m);
								}
								if (m.firstChild != null) {
									st.push(m.nextSibling);
									m = m.firstChild;
								} else {
									m = m.nextSibling;
								}
							}
						}
						break;

					case Step.DESCENDANTORSELF:
						// look at self
						if (step.nodeTest.matches(xpc.contextNode, xpc)) {
							newNodes.push(xpc.contextNode);
						}
						// look at all descendant nodes
						var st = [ xpc.contextNode.firstChild ];
						while (st.length > 0) {
							for (var m = st.pop(); m != null; ) {
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.push(m);
								}
								if (m.firstChild != null) {
									st.push(m.nextSibling);
									m = m.firstChild;
								} else {
									m = m.nextSibling;
								}
							}
						}
						break;

					case Step.FOLLOWING:
						if (xpc.contextNode === xpc.virtualRoot) {
							break;
						}
						var st = [];
						if (xpc.contextNode.firstChild != null) {
							st.unshift(xpc.contextNode.firstChild);
						} else {
							st.unshift(xpc.contextNode.nextSibling);
						}
						for (var m = xpc.contextNode.parentNode; m != null && m.nodeType != 9 /*Node.DOCUMENT_NODE*/ && m !== xpc.virtualRoot; m = m.parentNode) {
							st.unshift(m.nextSibling);
						}
						do {
							for (var m = st.pop(); m != null; ) {
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.push(m);
								}
								if (m.firstChild != null) {
									st.push(m.nextSibling);
									m = m.firstChild;
								} else {
									m = m.nextSibling;
								}
							}
						} while (st.length > 0);
						break;

					case Step.FOLLOWINGSIBLING:
						if (xpc.contextNode === xpc.virtualRoot) {
							break;
						}
						for (var m = xpc.contextNode.nextSibling; m != null; m = m.nextSibling) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
						}
						break;

					case Step.NAMESPACE:
						var n = {};
						if (xpc.contextNode.nodeType == 1 /*Node.ELEMENT_NODE*/) {
							n["xml"] = XPath.XML_NAMESPACE_URI;
							n["xmlns"] = XPath.XMLNS_NAMESPACE_URI;
							for (var m = xpc.contextNode; m != null && m.nodeType == 1 /*Node.ELEMENT_NODE*/; m = m.parentNode) {
								for (var k = 0; k < m.attributes.length; k++) {
									var attr = m.attributes.item(k);
									var nm = String(attr.name);
									if (nm == "xmlns") {
										if (n[""] == undefined) {
											n[""] = attr.value;
										}
									} else if (nm.length > 6 && nm.substring(0, 6) == "xmlns:") {
										var pre = nm.substring(6, nm.length);
										if (n[pre] == undefined) {
											n[pre] = attr.value;
										}
									}
								}
							}
							for (var pre in n) {
								var nsn = new NamespaceNode(pre, n[pre], xpc.contextNode);
								if (step.nodeTest.matches(nsn, xpc)) {
									newNodes.push(nsn);
								}
							}
						}
						break;

					case Step.PARENT:
						m = null;
						if (xpc.contextNode !== xpc.virtualRoot) {
							if (xpc.contextNode.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
								m = this.getOwnerElement(xpc.contextNode);
							} else {
								m = xpc.contextNode.parentNode;
							}
						}
						if (m != null && step.nodeTest.matches(m, xpc)) {
							newNodes.push(m);
						}
						break;

					case Step.PRECEDING:
						var st;
						if (xpc.virtualRoot != null) {
							st = [ xpc.virtualRoot ];
						} else {
							st = xpc.contextNode.nodeType == 9 /*Node.DOCUMENT_NODE*/
								? [ xpc.contextNode ]
								: [ xpc.contextNode.ownerDocument ];
						}
						outer: while (st.length > 0) {
							for (var m = st.pop(); m != null; ) {
								if (m == xpc.contextNode) {
									break outer;
								}
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.unshift(m);
								}
								if (m.firstChild != null) {
									st.push(m.nextSibling);
									m = m.firstChild;
								} else {
									m = m.nextSibling;
								}
							}
						}
						break;

					case Step.PRECEDINGSIBLING:
						if (xpc.contextNode === xpc.virtualRoot) {
							break;
						}
						for (var m = xpc.contextNode.previousSibling; m != null; m = m.previousSibling) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
						}
						break;

					case Step.SELF:
						if (step.nodeTest.matches(xpc.contextNode, xpc)) {
							newNodes.push(xpc.contextNode);
						}
						break;

					default:
				}
			}
			nodes = newNodes;
			// apply each of the predicates in turn
			for (var j = 0; j < step.predicates.length; j++) {
				var pred = step.predicates[j];
				var newNodes = [];
				xpc.contextSize = nodes.length;
				for (xpc.contextPosition = 1; xpc.contextPosition <= xpc.contextSize; xpc.contextPosition++) {
					xpc.contextNode = nodes[xpc.contextPosition - 1];
					if (this.predicateMatches(pred, xpc)) {
						newNodes.push(xpc.contextNode);
					} else {
					}
				}
				nodes = newNodes;
			}
		}
	}
	var ns = new XNodeSet();
	ns.addArray(nodes);
	return ns;
};

PathExpr.prototype.predicateMatches = function(pred, c) {
	var res = pred.evaluate(c);
	if (Utilities.instance_of(res, XNumber)) {
		return c.contextPosition == res.numberValue();
	}
	return res.booleanValue();
};

PathExpr.prototype.toString = function() {
	if (this.filter != undefined) {
		var s = this.filter.toString();
		if (Utilities.instance_of(this.filter, XString)) {
			s = "'" + s + "'";
		}
		if (this.filterPredicates != undefined) {
			for (var i = 0; i < this.filterPredicates.length; i++) {
				s = s + "[" + this.filterPredicates[i].toString() + "]";
			}
		}
		if (this.locationPath != undefined) {
			if (!this.locationPath.absolute) {
				s += "/";
			}
			s += this.locationPath.toString();
		}
		return s;
	}
	return this.locationPath.toString();
};

PathExpr.prototype.getOwnerElement = function(n) {
	// DOM 2 has ownerElement
	if (n.ownerElement) {
		return n.ownerElement;
	}
	// DOM 1 Internet Explorer can use selectSingleNode (ironically)
	try {
		if (n.selectSingleNode) {
			return n.selectSingleNode("..");
		}
	} catch (e) {
	}
	// Other DOM 1 implementations must use this egregious search
	var doc = n.nodeType == 9 /*Node.DOCUMENT_NODE*/
			? n
			: n.ownerDocument;
	var elts = doc.getElementsByTagName("*");
	for (var i = 0; i < elts.length; i++) {
		var elt = elts.item(i);
		var nnm = elt.attributes;
		for (var j = 0; j < nnm.length; j++) {
			var an = nnm.item(j);
			if (an === n) {
				return elt;
			}
		}
	}
	return null;
};

// LocationPath //////////////////////////////////////////////////////////////

LocationPath.prototype = new Object();
LocationPath.prototype.constructor = LocationPath;
LocationPath.superclass = Object.prototype;

function LocationPath(abs, steps) {
	if (arguments.length > 0) {
		this.init(abs, steps);
	}
}

LocationPath.prototype.init = function(abs, steps) {
	this.absolute = abs;
	this.steps = steps;
};

LocationPath.prototype.toString = function() {
	var s;
	if (this.absolute) {
		s = "/";
	} else {
		s = "";
	}
	for (var i = 0; i < this.steps.length; i++) {
		if (i != 0) {
			s += "/";
		}
		s += this.steps[i].toString();
	}
	return s;
};

// Step //////////////////////////////////////////////////////////////////////

Step.prototype = new Object();
Step.prototype.constructor = Step;
Step.superclass = Object.prototype;

function Step(axis, nodetest, preds) {
	if (arguments.length > 0) {
		this.init(axis, nodetest, preds);
	}
}

Step.prototype.init = function(axis, nodetest, preds) {
	this.axis = axis;
	this.nodeTest = nodetest;
	this.predicates = preds;
};

Step.prototype.toString = function() {
	var s;
	switch (this.axis) {
		case Step.ANCESTOR:
			s = "ancestor";
			break;
		case Step.ANCESTORORSELF:
			s = "ancestor-or-self";
			break;
		case Step.ATTRIBUTE:
			s = "attribute";
			break;
		case Step.CHILD:
			s = "child";
			break;
		case Step.DESCENDANT:
			s = "descendant";
			break;
		case Step.DESCENDANTORSELF:
			s = "descendant-or-self";
			break;
		case Step.FOLLOWING:
			s = "following";
			break;
		case Step.FOLLOWINGSIBLING:
			s = "following-sibling";
			break;
		case Step.NAMESPACE:
			s = "namespace";
			break;
		case Step.PARENT:
			s = "parent";
			break;
		case Step.PRECEDING:
			s = "preceding";
			break;
		case Step.PRECEDINGSIBLING:
			s = "preceding-sibling";
			break;
		case Step.SELF:
			s = "self";
			break;
	}
	s += "::";
	s += this.nodeTest.toString();
	for (var i = 0; i < this.predicates.length; i++) {
		s += "[" + this.predicates[i].toString() + "]";
	}
	return s;
};

Step.ANCESTOR = 0;
Step.ANCESTORORSELF = 1;
Step.ATTRIBUTE = 2;
Step.CHILD = 3;
Step.DESCENDANT = 4;
Step.DESCENDANTORSELF = 5;
Step.FOLLOWING = 6;
Step.FOLLOWINGSIBLING = 7;
Step.NAMESPACE = 8;
Step.PARENT = 9;
Step.PRECEDING = 10;
Step.PRECEDINGSIBLING = 11;
Step.SELF = 12;

// NodeTest //////////////////////////////////////////////////////////////////

NodeTest.prototype = new Object();
NodeTest.prototype.constructor = NodeTest;
NodeTest.superclass = Object.prototype;

function NodeTest(type, value) {
	if (arguments.length > 0) {
		this.init(type, value);
	}
}

NodeTest.prototype.init = function(type, value) {
	this.type = type;
	this.value = value;
};

NodeTest.prototype.toString = function() {
	switch (this.type) {
		case NodeTest.NAMETESTANY:
			return "*";
		case NodeTest.NAMETESTPREFIXANY:
			return this.value + ":*";
		case NodeTest.NAMETESTRESOLVEDANY:
			return "{" + this.value + "}*";
		case NodeTest.NAMETESTQNAME:
			return this.value;
		case NodeTest.NAMETESTRESOLVEDNAME:
			return "{" + this.namespaceURI + "}" + this.value;
		case NodeTest.COMMENT:
			return "comment()";
		case NodeTest.TEXT:
			return "text()";
		case NodeTest.PI:
			if (this.value != undefined) {
				return "processing-instruction(\"" + this.value + "\")";
			}
			return "processing-instruction()";
		case NodeTest.NODE:
			return "node()";
	}
	return "<unknown nodetest type>";
};

NodeTest.prototype.matches = function(n, xpc) {
	switch (this.type) {
		case NodeTest.NAMETESTANY:
			if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/
					|| n.nodeType == 1 /*Node.ELEMENT_NODE*/
					|| n.nodeType == XPathNamespace.XPATH_NAMESPACE_NODE) {
				return true;
			}
			return false;
		case NodeTest.NAMETESTPREFIXANY:
			if ((n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/ || n.nodeType == 1 /*Node.ELEMENT_NODE*/)) {
				var ns = xpc.namespaceResolver.getNamespace(this.value, xpc.expressionContextNode);
				if (ns == null) {
					throw new Error("Cannot resolve QName " + this.value);
				}
				return ns == (n.namespaceURI || '');
			}
			return false;
		case NodeTest.NAMETESTQNAME:
			if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/
					|| n.nodeType == 1 /*Node.ELEMENT_NODE*/
					|| n.nodeType == XPathNamespace.XPATH_NAMESPACE_NODE) {
				var test = Utilities.resolveQName(this.value, xpc.namespaceResolver, xpc.expressionContextNode, false);
				if (test[0] == null) {
					throw new Error("Cannot resolve QName " + this.value);
				}
				test[0] = String(test[0]);
				test[1] = String(test[1]);
				if (test[0] == "") {
					test[0] = null;
				}
				var node = [n.namespaceURI || '', n.localName];
				node[0] = String(node[0]);
				node[1] = String(node[1]);
				if (node[0] == "") {
					node[0] = null;
				}
				if (xpc.caseInsensitive) {
					return test[0] == node[0] && String(test[1]).toLowerCase() == String(node[1]).toLowerCase();
				}
				return test[0] == node[0] && test[1] == node[1];
			}
			return false;
		case NodeTest.COMMENT:
			return n.nodeType == 8 /*Node.COMMENT_NODE*/;
		case NodeTest.TEXT:
			return n.nodeType == 3 /*Node.TEXT_NODE*/ || n.nodeType == 4 /*Node.CDATA_SECTION_NODE*/;
		case NodeTest.PI:
			return n.nodeType == 7 /*Node.PROCESSING_INSTRUCTION_NODE*/
				&& (this.value == null || n.nodeName == this.value);
		case NodeTest.NODE:
			return n.nodeType == 9 /*Node.DOCUMENT_NODE*/
				|| n.nodeType == 1 /*Node.ELEMENT_NODE*/
				|| n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/
				|| n.nodeType == 3 /*Node.TEXT_NODE*/
				|| n.nodeType == 4 /*Node.CDATA_SECTION_NODE*/
				|| n.nodeType == 8 /*Node.COMMENT_NODE*/
				|| n.nodeType == 7 /*Node.PROCESSING_INSTRUCTION_NODE*/;
	}
	return false;
};

NodeTest.NAMETESTANY = 0;
NodeTest.NAMETESTPREFIXANY = 1;
NodeTest.NAMETESTQNAME = 2;
NodeTest.COMMENT = 3;
NodeTest.TEXT = 4;
NodeTest.PI = 5;
NodeTest.NODE = 6;

// VariableReference /////////////////////////////////////////////////////////

VariableReference.prototype = new Expression();
VariableReference.prototype.constructor = VariableReference;
VariableReference.superclass = Expression.prototype;

function VariableReference(v) {
	if (arguments.length > 0) {
		this.init(v);
	}
}

VariableReference.prototype.init = function(v) {
	this.variable = v;
};

VariableReference.prototype.toString = function() {
	return "$" + this.variable;
};

VariableReference.prototype.evaluate = function(c) {
	return c.variableResolver.getVariable(this.variable, c);
};

// FunctionCall //////////////////////////////////////////////////////////////

FunctionCall.prototype = new Expression();
FunctionCall.prototype.constructor = FunctionCall;
FunctionCall.superclass = Expression.prototype;

function FunctionCall(fn, args) {
	if (arguments.length > 0) {
		this.init(fn, args);
	}
}

FunctionCall.prototype.init = function(fn, args) {
	this.functionName = fn;
	this.arguments = args;
};

FunctionCall.prototype.toString = function() {
	var s = this.functionName + "(";
	for (var i = 0; i < this.arguments.length; i++) {
		if (i > 0) {
			s += ", ";
		}
		s += this.arguments[i].toString();
	}
	return s + ")";
};

FunctionCall.prototype.evaluate = function(c) {
	var f = c.functionResolver.getFunction(this.functionName, c);
	if (f == undefined) {
		throw new Error("Unknown function " + this.functionName);
	}
	var a = [c].concat(this.arguments);
	return f.apply(c.functionResolver.thisArg, a);
};

// XString ///////////////////////////////////////////////////////////////////

XString.prototype = new Expression();
XString.prototype.constructor = XString;
XString.superclass = Expression.prototype;

function XString(s) {
	if (arguments.length > 0) {
		this.init(s);
	}
}

XString.prototype.init = function(s) {
	this.str = s;
};

XString.prototype.toString = function() {
	return this.str;
};

XString.prototype.evaluate = function(c) {
	return this;
};

XString.prototype.string = function() {
	return this;
};

XString.prototype.number = function() {
	return new XNumber(this.str);
};

XString.prototype.bool = function() {
	return new XBoolean(this.str);
};

XString.prototype.nodeset = function() {
	throw new Error("Cannot convert string to nodeset");
};

XString.prototype.stringValue = function() {
	return this.str;
};

XString.prototype.numberValue = function() {
	return this.number().numberValue();
};

XString.prototype.booleanValue = function() {
	return this.bool().booleanValue();
};

XString.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().equals(r);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.number().equals(r);
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithString(this, Operators.equals);
	}
	return new XBoolean(this.str == r.str);
};

XString.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().notequal(r);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.number().notequal(r);
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithString(this, Operators.notequal);
	}
	return new XBoolean(this.str != r.str);
};

XString.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.greaterthanorequal);
	}
	return this.number().lessthan(r.number());
};

XString.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.lessthanorequal);
	}
	return this.number().greaterthan(r.number());
};

XString.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.greaterthan);
	}
	return this.number().lessthanorequal(r.number());
};

XString.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.lessthan);
	}
	return this.number().greaterthanorequal(r.number());
};

// XNumber ///////////////////////////////////////////////////////////////////

XNumber.prototype = new Expression();
XNumber.prototype.constructor = XNumber;
XNumber.superclass = Expression.prototype;

function XNumber(n) {
	if (arguments.length > 0) {
		this.init(n);
	}
}

XNumber.prototype.init = function(n) {
	this.num = Number(n);
};

XNumber.prototype.toString = function() {
	return this.num;
};

XNumber.prototype.evaluate = function(c) {
	return this;
};

XNumber.prototype.string = function() {
	return new XString(this.num);
};

XNumber.prototype.number = function() {
	return this;
};

XNumber.prototype.bool = function() {
	return new XBoolean(this.num);
};

XNumber.prototype.nodeset = function() {
	throw new Error("Cannot convert number to nodeset");
};

XNumber.prototype.stringValue = function() {
	return this.string().stringValue();
};

XNumber.prototype.numberValue = function() {
	return this.num;
};

XNumber.prototype.booleanValue = function() {
	return this.bool().booleanValue();
};

XNumber.prototype.negate = function() {
	return new XNumber(-this.num);
};

XNumber.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().equals(r);
	}
	if (Utilities.instance_of(r, XString)) {
		return this.equals(r.number());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.equals);
	}
	return new XBoolean(this.num == r.num);
};

XNumber.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().notequal(r);
	}
	if (Utilities.instance_of(r, XString)) {
		return this.notequal(r.number());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.notequal);
	}
	return new XBoolean(this.num != r.num);
};

XNumber.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.greaterthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.lessthan(r.number());
	}
	return new XBoolean(this.num < r.num);
};

XNumber.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.lessthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.greaterthan(r.number());
	}
	return new XBoolean(this.num > r.num);
};

XNumber.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.greaterthan);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.lessthanorequal(r.number());
	}
	return new XBoolean(this.num <= r.num);
};

XNumber.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.lessthan);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.greaterthanorequal(r.number());
	}
	return new XBoolean(this.num >= r.num);
};

XNumber.prototype.plus = function(r) {
	return new XNumber(this.num + r.num);
};

XNumber.prototype.minus = function(r) {
	return new XNumber(this.num - r.num);
};

XNumber.prototype.multiply = function(r) {
	return new XNumber(this.num * r.num);
};

XNumber.prototype.div = function(r) {
	return new XNumber(this.num / r.num);
};

XNumber.prototype.mod = function(r) {
	return new XNumber(this.num % r.num);
};

// XBoolean //////////////////////////////////////////////////////////////////

XBoolean.prototype = new Expression();
XBoolean.prototype.constructor = XBoolean;
XBoolean.superclass = Expression.prototype;

function XBoolean(b) {
	if (arguments.length > 0) {
		this.init(b);
	}
}

XBoolean.prototype.init = function(b) {
	this.b = Boolean(b);
};

XBoolean.prototype.toString = function() {
	return this.b.toString();
};

XBoolean.prototype.evaluate = function(c) {
	return this;
};

XBoolean.prototype.string = function() {
	return new XString(this.b);
};

XBoolean.prototype.number = function() {
	return new XNumber(this.b);
};

XBoolean.prototype.bool = function() {
	return this;
};

XBoolean.prototype.nodeset = function() {
	throw new Error("Cannot convert boolean to nodeset");
};

XBoolean.prototype.stringValue = function() {
	return this.string().stringValue();
};

XBoolean.prototype.numberValue = function() {
	return this.num().numberValue();
};

XBoolean.prototype.booleanValue = function() {
	return this.b;
};

XBoolean.prototype.not = function() {
	return new XBoolean(!this.b);
};

XBoolean.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {
		return this.equals(r.bool());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithBoolean(this, Operators.equals);
	}
	return new XBoolean(this.b == r.b);
};

XBoolean.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {
		return this.notequal(r.bool());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithBoolean(this, Operators.notequal);
	}
	return new XBoolean(this.b != r.b);
};

XBoolean.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.greaterthanorequal);
	}
	return this.number().lessthan(r.number());
};

XBoolean.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.lessthanorequal);
	}
	return this.number().greaterthan(r.number());
};

XBoolean.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.greaterthan);
	}
	return this.number().lessthanorequal(r.number());
};

XBoolean.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.lessthan);
	}
	return this.number().greaterthanorequal(r.number());
};

// AVLTree ///////////////////////////////////////////////////////////////////

AVLTree.prototype = new Object();
AVLTree.prototype.constructor = AVLTree;
AVLTree.superclass = Object.prototype;

function AVLTree(n) {
	this.init(n);
}

AVLTree.prototype.init = function(n) {
	this.left = null;
    this.right = null;
	this.node = n;
	this.depth = 1;
};

AVLTree.prototype.balance = function() {
    var ldepth = this.left  == null ? 0 : this.left.depth;
    var rdepth = this.right == null ? 0 : this.right.depth;

	if (ldepth > rdepth + 1) {
        // LR or LL rotation
        var lldepth = this.left.left  == null ? 0 : this.left.left.depth;
        var lrdepth = this.left.right == null ? 0 : this.left.right.depth;

        if (lldepth < lrdepth) {
            // LR rotation consists of a RR rotation of the left child
            this.left.rotateRR();
            // plus a LL rotation of this node, which happens anyway
        }
        this.rotateLL();
    } else if (ldepth + 1 < rdepth) {
        // RR or RL rorarion
		var rrdepth = this.right.right == null ? 0 : this.right.right.depth;
		var rldepth = this.right.left  == null ? 0 : this.right.left.depth;

        if (rldepth > rrdepth) {
            // RR rotation consists of a LL rotation of the right child
            this.right.rotateLL();
            // plus a RR rotation of this node, which happens anyway
        }
        this.rotateRR();
    }
};

AVLTree.prototype.rotateLL = function() {
    // the left side is too long => rotate from the left (_not_ leftwards)
    var nodeBefore = this.node;
    var rightBefore = this.right;
    this.node = this.left.node;
    this.right = this.left;
    this.left = this.left.left;
    this.right.left = this.right.right;
    this.right.right = rightBefore;
    this.right.node = nodeBefore;
    this.right.updateInNewLocation();
    this.updateInNewLocation();
};

AVLTree.prototype.rotateRR = function() {
    // the right side is too long => rotate from the right (_not_ rightwards)
    var nodeBefore = this.node;
    var leftBefore = this.left;
    this.node = this.right.node;
    this.left = this.right;
    this.right = this.right.right;
    this.left.right = this.left.left;
    this.left.left = leftBefore;
    this.left.node = nodeBefore;
    this.left.updateInNewLocation();
    this.updateInNewLocation();
};

AVLTree.prototype.updateInNewLocation = function() {
    this.getDepthFromChildren();
};

AVLTree.prototype.getDepthFromChildren = function() {
    this.depth = this.node == null ? 0 : 1;
    if (this.left != null) {
        this.depth = this.left.depth + 1;
    }
    if (this.right != null && this.depth <= this.right.depth) {
        this.depth = this.right.depth + 1;
    }
};

AVLTree.prototype.order = function(n1, n2) {
	if (n1 === n2) {
		return 0;
	}
	var d1 = 0;
	var d2 = 0;
	for (var m1 = n1; m1 != null; m1 = m1.parentNode) {
		d1++;
	}
	for (var m2 = n2; m2 != null; m2 = m2.parentNode) {
		d2++;
	}
	if (d1 > d2) {
		while (d1 > d2) {
			n1 = n1.parentNode;
			d1--;
		}
		if (n1 == n2) {
			return 1;
		}
	} else if (d2 > d1) {
		while (d2 > d1) {
			n2 = n2.parentNode;
			d2--;
		}
		if (n1 == n2) {
			return -1;
		}
	}
	while (n1.parentNode != n2.parentNode) {
		n1 = n1.parentNode;
		n2 = n2.parentNode;
	}
	while (n1.previousSibling != null && n2.previousSibling != null) {
		n1 = n1.previousSibling;
		n2 = n2.previousSibling;
	}
	if (n1.previousSibling == null) {
		return -1;
	}
	return 1;
};

AVLTree.prototype.add = function(n)  {
	if (n === this.node) {
        return false;
    }

	var o = this.order(n, this.node);

    var ret = false;
    if (o == -1) {
        if (this.left == null) {
            this.left = new AVLTree(n);
            ret = true;
        } else {
            ret = this.left.add(n);
            if (ret) {
                this.balance();
            }
        }
    } else if (o == 1) {
        if (this.right == null) {
            this.right = new AVLTree(n);
            ret = true;
        } else {
            ret = this.right.add(n);
            if (ret) {
                this.balance();
            }
        }
    }

    if (ret) {
        this.getDepthFromChildren();
    }
    return ret;
};

// XNodeSet //////////////////////////////////////////////////////////////////

XNodeSet.prototype = new Expression();
XNodeSet.prototype.constructor = XNodeSet;
XNodeSet.superclass = Expression.prototype;

function XNodeSet() {
	this.init();
}

XNodeSet.prototype.init = function() {
	this.tree = null;
	this.size = 0;
};

XNodeSet.prototype.toString = function() {
	var p = this.first();
	if (p == null) {
		return "";
	}
	return this.stringForNode(p);
};

XNodeSet.prototype.evaluate = function(c) {
	return this;
};

XNodeSet.prototype.string = function() {
	return new XString(this.toString());
};

XNodeSet.prototype.stringValue = function() {
	return this.toString();
};

XNodeSet.prototype.number = function() {
	return new XNumber(this.string());
};

XNodeSet.prototype.numberValue = function() {
	return Number(this.string());
};

XNodeSet.prototype.bool = function() {
	return new XBoolean(this.tree != null);
};

XNodeSet.prototype.booleanValue = function() {
	return this.tree != null;
};

XNodeSet.prototype.nodeset = function() {
	return this;
};

XNodeSet.prototype.stringForNode = function(n) {
	if (n.nodeType == 9 /*Node.DOCUMENT_NODE*/) {
		n = n.documentElement;
	}
	if (n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
		return this.stringForNodeRec(n);
	}
	if (n.isNamespaceNode) {
		return n.namespace;
	}
	return n.nodeValue;
};

XNodeSet.prototype.stringForNodeRec = function(n) {
	var s = "";
	for (var n2 = n.firstChild; n2 != null; n2 = n2.nextSibling) {
		if (n2.nodeType == 3 /*Node.TEXT_NODE*/) {
			s += n2.nodeValue;
		} else if (n2.nodeType == 1 /*Node.ELEMENT_NODE*/) {
			s += this.stringForNodeRec(n2);
		}
	}
	return s;
};

XNodeSet.prototype.first = function() {
	var p = this.tree;
	if (p == null) {
		return null;
	}
	while (p.left != null) {
		p = p.left;
	}
	return p.node;
};

XNodeSet.prototype.add = function(n) {
    var added;
    if (this.tree == null) {
        this.tree = new AVLTree(n);
        added = true;
    } else {
        added = this.tree.add(n);
    }
    if (added) {
        this.size++;
    }
};

XNodeSet.prototype.addArray = function(ns) {
	for (var i = 0; i < ns.length; i++) {
		this.add(ns[i]);
	}
};

XNodeSet.prototype.toArray = function() {
	var a = [];
	this.toArrayRec(this.tree, a);
	return a;
};

XNodeSet.prototype.toArrayRec = function(t, a) {
	if (t != null) {
		this.toArrayRec(t.left, a);
		a.push(t.node);
		this.toArrayRec(t.right, a);
	}
};

XNodeSet.prototype.compareWithString = function(r, o) {
	var a = this.toArray();
	for (var i = 0; i < a.length; i++) {
		var n = a[i];
		var l = new XString(this.stringForNode(n));
		var res = o(l, r);
		if (res.booleanValue()) {
			return res;
		}
	}
	return new XBoolean(false);
};

XNodeSet.prototype.compareWithNumber = function(r, o) {
	var a = this.toArray();
	for (var i = 0; i < a.length; i++) {
		var n = a[i];
		var l = new XNumber(this.stringForNode(n));
		var res = o(l, r);
		if (res.booleanValue()) {
			return res;
		}
	}
	return new XBoolean(false);
};

XNodeSet.prototype.compareWithBoolean = function(r, o) {
	return o(this.bool(), r);
};

XNodeSet.prototype.compareWithNodeSet = function(r, o) {
	var a = this.toArray();
	for (var i = 0; i < a.length; i++) {
		var n = a[i];
		var l = new XString(this.stringForNode(n));
		var b = r.toArray();
		for (var j = 0; j < b.length; j++) {
			var n2 = b[j];
			var r = new XString(this.stringForNode(n2));
			var res = o(l, r);
			if (res.booleanValue()) {
				return res;
			}
		}
	}
	return new XBoolean(false);
};

XNodeSet.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithString(r, Operators.equals);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.equals);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.equals);
	}
	return this.compareWithNodeSet(r, Operators.equals);
};

XNodeSet.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithString(r, Operators.notequal);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.notequal);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.notequal);
	}
	return this.compareWithNodeSet(r, Operators.notequal);
};

XNodeSet.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithNumber(r.number(), Operators.lessthan);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.lessthan);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.lessthan);
	}
	return this.compareWithNodeSet(r, Operators.lessthan);
};

XNodeSet.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithNumber(r.number(), Operators.greaterthan);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.greaterthan);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.greaterthan);
	}
	return this.compareWithNodeSet(r, Operators.greaterthan);
};

XNodeSet.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithNumber(r.number(), Operators.lessthanorequal);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.lessthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.lessthanorequal);
	}
	return this.compareWithNodeSet(r, Operators.lessthanorequal);
};

XNodeSet.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithNumber(r.number(), Operators.greaterthanorequal);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.greaterthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.greaterthanorequal);
	}
	return this.compareWithNodeSet(r, Operators.greaterthanorequal);
};

XNodeSet.prototype.union = function(r) {
	var ns = new XNodeSet();
	ns.tree = this.tree;
	ns.size = this.size;
	ns.addArray(r.toArray());
	return ns;
};

// XPathNamespace ////////////////////////////////////////////////////////////

XPathNamespace.prototype = new Object();
XPathNamespace.prototype.constructor = XPathNamespace;
XPathNamespace.superclass = Object.prototype;

function XPathNamespace(pre, ns, p) {
	this.isXPathNamespace = true;
	this.ownerDocument = p.ownerDocument;
	this.nodeName = "#namespace";
	this.prefix = pre;
	this.localName = pre;
	this.namespaceURI = ns;
	this.nodeValue = ns;
	this.ownerElement = p;
	this.nodeType = XPathNamespace.XPATH_NAMESPACE_NODE;
}

XPathNamespace.prototype.toString = function() {
	return "{ \"" + this.prefix + "\", \"" + this.namespaceURI + "\" }";
};

// Operators /////////////////////////////////////////////////////////////////

var Operators = new Object();

Operators.equals = function(l, r) {
	return l.equals(r);
};

Operators.notequal = function(l, r) {
	return l.notequal(r);
};

Operators.lessthan = function(l, r) {
	return l.lessthan(r);
};

Operators.greaterthan = function(l, r) {
	return l.greaterthan(r);
};

Operators.lessthanorequal = function(l, r) {
	return l.lessthanorequal(r);
};

Operators.greaterthanorequal = function(l, r) {
	return l.greaterthanorequal(r);
};

// XPathContext //////////////////////////////////////////////////////////////

XPathContext.prototype = new Object();
XPathContext.prototype.constructor = XPathContext;
XPathContext.superclass = Object.prototype;

function XPathContext(vr, nr, fr) {
	this.variableResolver = vr != null ? vr : new VariableResolver();
	this.namespaceResolver = nr != null ? nr : new NamespaceResolver();
	this.functionResolver = fr != null ? fr : new FunctionResolver();
}

// VariableResolver //////////////////////////////////////////////////////////

VariableResolver.prototype = new Object();
VariableResolver.prototype.constructor = VariableResolver;
VariableResolver.superclass = Object.prototype;

function VariableResolver() {
}

VariableResolver.prototype.getVariable = function(vn, c) {
	var parts = Utilities.splitQName(vn);
	if (parts[0] != null) {
		parts[0] = c.namespaceResolver.getNamespace(parts[0], c.expressionContextNode);
        if (parts[0] == null) {
            throw new Error("Cannot resolve QName " + fn);
        }
	}
	return this.getVariableWithName(parts[0], parts[1], c.expressionContextNode);
};

VariableResolver.prototype.getVariableWithName = function(ns, ln, c) {
	return null;
};

// FunctionResolver //////////////////////////////////////////////////////////

FunctionResolver.prototype = new Object();
FunctionResolver.prototype.constructor = FunctionResolver;
FunctionResolver.superclass = Object.prototype;

function FunctionResolver(thisArg) {
	this.thisArg = thisArg != null ? thisArg : Functions;
	this.functions = new Object();
	this.addStandardFunctions();
}

FunctionResolver.prototype.addStandardFunctions = function() {
	this.functions["{}last"] = Functions.last;
	this.functions["{}position"] = Functions.position;
	this.functions["{}count"] = Functions.count;
	this.functions["{}id"] = Functions.id;
	this.functions["{}local-name"] = Functions.localName;
	this.functions["{}namespace-uri"] = Functions.namespaceURI;
	this.functions["{}name"] = Functions.name;
	this.functions["{}string"] = Functions.string;
	this.functions["{}concat"] = Functions.concat;
	this.functions["{}starts-with"] = Functions.startsWith;
	this.functions["{}contains"] = Functions.contains;
	this.functions["{}substring-before"] = Functions.substringBefore;
	this.functions["{}substring-after"] = Functions.substringAfter;
	this.functions["{}substring"] = Functions.substring;
	this.functions["{}string-length"] = Functions.stringLength;
	this.functions["{}normalize-space"] = Functions.normalizeSpace;
	this.functions["{}translate"] = Functions.translate;
	this.functions["{}boolean"] = Functions.boolean_;
	this.functions["{}not"] = Functions.not;
	this.functions["{}true"] = Functions.true_;
	this.functions["{}false"] = Functions.false_;
	this.functions["{}lang"] = Functions.lang;
	this.functions["{}number"] = Functions.number;
	this.functions["{}sum"] = Functions.sum;
	this.functions["{}floor"] = Functions.floor;
	this.functions["{}ceiling"] = Functions.ceiling;
	this.functions["{}round"] = Functions.round;
};

FunctionResolver.prototype.addFunction = function(ns, ln, f) {
	this.functions["{" + ns + "}" + ln] = f;
};

FunctionResolver.prototype.getFunction = function(fn, c) {
	var parts = Utilities.resolveQName(fn, c.namespaceResolver, c.contextNode, false);
    if (parts[0] == null) {
        throw new Error("Cannot resolve QName " + fn);
    }
	return this.getFunctionWithName(parts[0], parts[1], c.contextNode);
};

FunctionResolver.prototype.getFunctionWithName = function(ns, ln, c) {
	return this.functions["{" + ns + "}" + ln];
};

// NamespaceResolver /////////////////////////////////////////////////////////

NamespaceResolver.prototype = new Object();
NamespaceResolver.prototype.constructor = NamespaceResolver;
NamespaceResolver.superclass = Object.prototype;

function NamespaceResolver() {
}

NamespaceResolver.prototype.getNamespace = function(prefix, n) {
	if (prefix == "xml") {
		return XPath.XML_NAMESPACE_URI;
	} else if (prefix == "xmlns") {
		return XPath.XMLNS_NAMESPACE_URI;
	}
	if (n.nodeType == 9 /*Node.DOCUMENT_NODE*/) {
		n = n.documentElement;
	} else if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
		n = PathExpr.prototype.getOwnerElement(n);
	} else if (n.nodeType != 1 /*Node.ELEMENT_NODE*/) {
		n = n.parentNode;
	}
	while (n != null && n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
		var nnm = n.attributes;
		for (var i = 0; i < nnm.length; i++) {
			var a = nnm.item(i);
			var aname = a.nodeName;
			if (aname == "xmlns" && prefix == ""
					|| aname == "xmlns:" + prefix) {
				return String(a.nodeValue);
			}
		}
		n = n.parentNode;
	}
	return null;
};

// Functions /////////////////////////////////////////////////////////////////

Functions = new Object();

Functions.last = function() {
	var c = arguments[0];
	if (arguments.length != 1) {
		throw new Error("Function last expects ()");
	}
	return new XNumber(c.contextSize);
};

Functions.position = function() {
	var c = arguments[0];
	if (arguments.length != 1) {
		throw new Error("Function position expects ()");
	}
	return new XNumber(c.contextPosition);
};

Functions.count = function() {
	var c = arguments[0];
	var ns;
	if (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c), XNodeSet)) {
		throw new Error("Function count expects (node-set)");
	}
	return new XNumber(ns.size);
};

Functions.id = function() {
	var c = arguments[0];
	var id;
	if (arguments.length != 2) {
		throw new Error("Function id expects (object)");
	}
	id = arguments[1].evaluate(c);
	if (Utilities.instance_of(id, XNodeSet)) {
		id = id.toArray().join(" ");
	} else {
		id = id.stringValue();
	}
	var ids = id.split(/[\x0d\x0a\x09\x20]+/);
	var count = 0;
	var ns = new XNodeSet();
	var doc = c.contextNode.nodeType == 9 /*Node.DOCUMENT_NODE*/
			? c.contextNode
			: c.contextNode.ownerDocument;
	for (var i = 0; i < ids.length; i++) {
		var n;
		if (doc.getElementById) {
			n = doc.getElementById(ids[i]);
		} else {
			n = Utilities.getElementById(doc, ids[i]);
		}
		if (n != null) {
			ns.add(n);
			count++;
		}
	}
	return ns;
};

Functions.localName = function() {
	var c = arguments[0];
	var n;
	if (arguments.length == 1) {
		n = c.contextNode;
	} else if (arguments.length == 2) {
		n = arguments[1].evaluate(c).first();
	} else {
		throw new Error("Function local-name expects (node-set?)");
	}
	if (n == null) {
		return new XString("");
	}
	return new XString(n.localName ? n.localName : n.baseName);
};

Functions.namespaceURI = function() {
	var c = arguments[0];
	var n;
	if (arguments.length == 1) {
		n = c.contextNode;
	} else if (arguments.length == 2) {
		n = arguments[1].evaluate(c).first();
	} else {
		throw new Error("Function namespace-uri expects (node-set?)");
	}
	if (n == null) {
		return new XString("");
	}
	return new XString(n.namespaceURI);
};

Functions.name = function() {
	var c = arguments[0];
	var n;
	if (arguments.length == 1) {
		n = c.contextNode;
	} else if (arguments.length == 2) {
		n = arguments[1].evaluate(c).first();
	} else {
		throw new Error("Function name expects (node-set?)");
	}
	if (n == null) {
		return new XString("");
	}
	if (n.nodeType == 1 /*Node.ELEMENT_NODE*/ || n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
		return new XString(n.nodeName);
	} else if (n.localName == null) {
		return new XString("");
	} else {
		return new XString(n.localName);
	}
};

Functions.string = function() {
	var c = arguments[0];
	if (arguments.length == 1) {
		return XNodeSet.prototype.stringForNode(c.contextNode);
	} else if (arguments.length == 2) {
		return arguments[1].evaluate(c).string();
	}
	throw new Error("Function string expects (object?)");
};

Functions.concat = function() {
	var c = arguments[0];
	if (arguments.length < 3) {
		throw new Error("Function concat expects (string, string, string*)");
	}
	var s = "";
	for (var i = 1; i < arguments.length; i++) {
		s += arguments[i].evaluate(c).stringValue();
	}
	return new XString(s);
};

Functions.startsWith = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function startsWith expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	return new XBoolean(s1.substring(0, s2.length) == s2);
};

Functions.contains = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function contains expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	return new XBoolean(s1.indexOf(s2) != -1);
};

Functions.substringBefore = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function substring-before expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	return new XString(s1.substring(0, s1.indexOf(s2)));
};

Functions.substringAfter = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function substring-after expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	if (s2.length == 0) {
		return new XString(s1);
	}
	var i = s1.indexOf(s2);
	if (i == -1) {
		return new XString("");
	}
	return new XString(s1.substring(s1.indexOf(s2) + 1));
};

Functions.substring = function() {
	var c = arguments[0];
	if (!(arguments.length == 3 || arguments.length == 4)) {
		throw new Error("Function substring expects (string, number, number?)");
	}
	var s = arguments[1].evaluate(c).stringValue();
	var n1 = Math.round(arguments[2].evaluate(c).numberValue()) - 1;
	var n2 = arguments.length == 4 ? n1 + Math.round(arguments[3].evaluate(c).numberValue()) : undefined;
	return new XString(s.substring(n1, n2));
};

Functions.stringLength = function() {
	var c = arguments[0];
	var s;
	if (arguments.length == 1) {
		s = XNodeSet.prototype.stringForNode(c.contextNode);
	} else if (arguments.length == 2) {
		s = arguments[1].evaluate(c).stringValue();
	} else {
		throw new Error("Function string-length expects (string?)");
	}
	return new XNumber(s.length);
};

Functions.normalizeSpace = function() {
	var c = arguments[0];
	var s;
	if (arguments.length == 1) {
		s = XNodeSet.prototype.stringForNode(c.contextNode);
	} else if (arguments.length == 2) {
		s = arguments[1].evaluate(c).stringValue();
	} else {
		throw new Error("Function normalize-space expects (string?)");
	}
	var i = 0;
	var j = s.length - 1;
	while (Utilities.isSpace(s.charCodeAt(j))) {
		j--;
	}
	var t = "";
	while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {
		i++;
	}
	while (i <= j) {
		if (Utilities.isSpace(s.charCodeAt(i))) {
			t += " ";
			while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {
				i++;
			}
		} else {
			t += s.charAt(i);
			i++;
		}
	}
	return new XString(t);
};

Functions.translate = function() {
	var c = arguments[0];
	if (arguments.length != 4) {
		throw new Error("Function translate expects (string, string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	var s3 = arguments[3].evaluate(c).stringValue();
	var map = [];
	for (var i = 0; i < s2.length; i++) {
		var j = s2.charCodeAt(i);
		if (map[j] == undefined) {
			var k = i > s3.length ? "" : s3.charAt(i);
			map[j] = k;
		}
	}
	var t = "";
	for (var i = 0; i < s1.length; i++) {
		var c = s1.charCodeAt(i);
		var r = map[c];
		if (r == undefined) {
			t += s1.charAt(i);
		} else {
			t += r;
		}
	}
	return new XString(t);
};

Functions.boolean_ = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function boolean expects (object)");
	}
	return arguments[1].evaluate(c).bool();
};

Functions.not = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function not expects (object)");
	}
	return arguments[1].evaluate(c).bool().not();
};

Functions.true_ = function() {
	if (arguments.length != 1) {
		throw new Error("Function true expects ()");
	}
	return new XBoolean(true);
};

Functions.false_ = function() {
	if (arguments.length != 1) {
		throw new Error("Function false expects ()");
	}
	return new XBoolean(false);
};

Functions.lang = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function lang expects (string)");
	}
	var lang;
	for (var n = c.contextNode; n != null && n.nodeType != 9 /*Node.DOCUMENT_NODE*/; n = n.parentNode) {
		var a = n.getAttributeNS(XPath.XML_NAMESPACE_URI, "lang");
		if (a != null) {
			lang = String(a);
			break;
		}
	}
	if (lang == null) {
		return new XBoolean(false);
	}
	var s = arguments[1].evaluate(c).stringValue();
	return new XBoolean(lang.substring(0, s.length) == s
				&& (lang.length == s.length || lang.charAt(s.length) == '-'));
};

Functions.number = function() {
	var c = arguments[0];
	if (!(arguments.length == 1 || arguments.length == 2)) {
		throw new Error("Function number expects (object?)");
	}
	if (arguments.length == 1) {
		return new XNumber(XNodeSet.prototype.stringForNode(c.contextNode));
	}
	return arguments[1].evaluate(c).number();
};

Functions.sum = function() {
	var c = arguments[0];
	var ns;
	if (arguments.length != 2 || !Utilities.instance_of((ns = arguments[1].evaluate(c)), XNodeSet)) {
		throw new Error("Function sum expects (node-set)");
	}
	ns = ns.toArray();
	var n = 0;
	for (var i = 0; i < ns.length; i++) {
		n += new XNumber(XNodeSet.prototype.stringForNode(ns[i])).numberValue();
	}
	return new XNumber(n);
};

Functions.floor = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function floor expects (number)");
	}
	return new XNumber(Math.floor(arguments[1].evaluate(c).numberValue()));
};

Functions.ceiling = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function ceiling expects (number)");
	}
	return new XNumber(Math.ceil(arguments[1].evaluate(c).numberValue()));
};

Functions.round = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function round expects (number)");
	}
	return new XNumber(Math.round(arguments[1].evaluate(c).numberValue()));
};

// Utilities /////////////////////////////////////////////////////////////////

Utilities = new Object();

Utilities.splitQName = function(qn) {
	var i = qn.indexOf(":");
	if (i == -1) {
		return [ null, qn ];
	}
	return [ qn.substring(0, i), qn.substring(i + 1) ];
};

Utilities.resolveQName = function(qn, nr, n, useDefault) {
	var parts = Utilities.splitQName(qn);
	if (parts[0] != null) {
		parts[0] = nr.getNamespace(parts[0], n);
	} else {
		if (useDefault) {
			parts[0] = nr.getNamespace("", n);
			if (parts[0] == null) {
				parts[0] = "";
			}
		} else {
			parts[0] = "";
		}
	}
	return parts;
};

Utilities.isSpace = function(c) {
	return c == 0x9 || c == 0xd || c == 0xa || c == 0x20;
};

Utilities.isLetter = function(c) {
	return c >= 0x0041 && c <= 0x005A ||
		c >= 0x0061 && c <= 0x007A ||
		c >= 0x00C0 && c <= 0x00D6 ||
		c >= 0x00D8 && c <= 0x00F6 ||
		c >= 0x00F8 && c <= 0x00FF ||
		c >= 0x0100 && c <= 0x0131 ||
		c >= 0x0134 && c <= 0x013E ||
		c >= 0x0141 && c <= 0x0148 ||
		c >= 0x014A && c <= 0x017E ||
		c >= 0x0180 && c <= 0x01C3 ||
		c >= 0x01CD && c <= 0x01F0 ||
		c >= 0x01F4 && c <= 0x01F5 ||
		c >= 0x01FA && c <= 0x0217 ||
		c >= 0x0250 && c <= 0x02A8 ||
		c >= 0x02BB && c <= 0x02C1 ||
		c == 0x0386 ||
		c >= 0x0388 && c <= 0x038A ||
		c == 0x038C ||
		c >= 0x038E && c <= 0x03A1 ||
		c >= 0x03A3 && c <= 0x03CE ||
		c >= 0x03D0 && c <= 0x03D6 ||
		c == 0x03DA ||
		c == 0x03DC ||
		c == 0x03DE ||
		c == 0x03E0 ||
		c >= 0x03E2 && c <= 0x03F3 ||
		c >= 0x0401 && c <= 0x040C ||
		c >= 0x040E && c <= 0x044F ||
		c >= 0x0451 && c <= 0x045C ||
		c >= 0x045E && c <= 0x0481 ||
		c >= 0x0490 && c <= 0x04C4 ||
		c >= 0x04C7 && c <= 0x04C8 ||
		c >= 0x04CB && c <= 0x04CC ||
		c >= 0x04D0 && c <= 0x04EB ||
		c >= 0x04EE && c <= 0x04F5 ||
		c >= 0x04F8 && c <= 0x04F9 ||
		c >= 0x0531 && c <= 0x0556 ||
		c == 0x0559 ||
		c >= 0x0561 && c <= 0x0586 ||
		c >= 0x05D0 && c <= 0x05EA ||
		c >= 0x05F0 && c <= 0x05F2 ||
		c >= 0x0621 && c <= 0x063A ||
		c >= 0x0641 && c <= 0x064A ||
		c >= 0x0671 && c <= 0x06B7 ||
		c >= 0x06BA && c <= 0x06BE ||
		c >= 0x06C0 && c <= 0x06CE ||
		c >= 0x06D0 && c <= 0x06D3 ||
		c == 0x06D5 ||
		c >= 0x06E5 && c <= 0x06E6 ||
		c >= 0x0905 && c <= 0x0939 ||
		c == 0x093D ||
		c >= 0x0958 && c <= 0x0961 ||
		c >= 0x0985 && c <= 0x098C ||
		c >= 0x098F && c <= 0x0990 ||
		c >= 0x0993 && c <= 0x09A8 ||
		c >= 0x09AA && c <= 0x09B0 ||
		c == 0x09B2 ||
		c >= 0x09B6 && c <= 0x09B9 ||
		c >= 0x09DC && c <= 0x09DD ||
		c >= 0x09DF && c <= 0x09E1 ||
		c >= 0x09F0 && c <= 0x09F1 ||
		c >= 0x0A05 && c <= 0x0A0A ||
		c >= 0x0A0F && c <= 0x0A10 ||
		c >= 0x0A13 && c <= 0x0A28 ||
		c >= 0x0A2A && c <= 0x0A30 ||
		c >= 0x0A32 && c <= 0x0A33 ||
		c >= 0x0A35 && c <= 0x0A36 ||
		c >= 0x0A38 && c <= 0x0A39 ||
		c >= 0x0A59 && c <= 0x0A5C ||
		c == 0x0A5E ||
		c >= 0x0A72 && c <= 0x0A74 ||
		c >= 0x0A85 && c <= 0x0A8B ||
		c == 0x0A8D ||
		c >= 0x0A8F && c <= 0x0A91 ||
		c >= 0x0A93 && c <= 0x0AA8 ||
		c >= 0x0AAA && c <= 0x0AB0 ||
		c >= 0x0AB2 && c <= 0x0AB3 ||
		c >= 0x0AB5 && c <= 0x0AB9 ||
		c == 0x0ABD ||
		c == 0x0AE0 ||
		c >= 0x0B05 && c <= 0x0B0C ||
		c >= 0x0B0F && c <= 0x0B10 ||
		c >= 0x0B13 && c <= 0x0B28 ||
		c >= 0x0B2A && c <= 0x0B30 ||
		c >= 0x0B32 && c <= 0x0B33 ||
		c >= 0x0B36 && c <= 0x0B39 ||
		c == 0x0B3D ||
		c >= 0x0B5C && c <= 0x0B5D ||
		c >= 0x0B5F && c <= 0x0B61 ||
		c >= 0x0B85 && c <= 0x0B8A ||
		c >= 0x0B8E && c <= 0x0B90 ||
		c >= 0x0B92 && c <= 0x0B95 ||
		c >= 0x0B99 && c <= 0x0B9A ||
		c == 0x0B9C ||
		c >= 0x0B9E && c <= 0x0B9F ||
		c >= 0x0BA3 && c <= 0x0BA4 ||
		c >= 0x0BA8 && c <= 0x0BAA ||
		c >= 0x0BAE && c <= 0x0BB5 ||
		c >= 0x0BB7 && c <= 0x0BB9 ||
		c >= 0x0C05 && c <= 0x0C0C ||
		c >= 0x0C0E && c <= 0x0C10 ||
		c >= 0x0C12 && c <= 0x0C28 ||
		c >= 0x0C2A && c <= 0x0C33 ||
		c >= 0x0C35 && c <= 0x0C39 ||
		c >= 0x0C60 && c <= 0x0C61 ||
		c >= 0x0C85 && c <= 0x0C8C ||
		c >= 0x0C8E && c <= 0x0C90 ||
		c >= 0x0C92 && c <= 0x0CA8 ||
		c >= 0x0CAA && c <= 0x0CB3 ||
		c >= 0x0CB5 && c <= 0x0CB9 ||
		c == 0x0CDE ||
		c >= 0x0CE0 && c <= 0x0CE1 ||
		c >= 0x0D05 && c <= 0x0D0C ||
		c >= 0x0D0E && c <= 0x0D10 ||
		c >= 0x0D12 && c <= 0x0D28 ||
		c >= 0x0D2A && c <= 0x0D39 ||
		c >= 0x0D60 && c <= 0x0D61 ||
		c >= 0x0E01 && c <= 0x0E2E ||
		c == 0x0E30 ||
		c >= 0x0E32 && c <= 0x0E33 ||
		c >= 0x0E40 && c <= 0x0E45 ||
		c >= 0x0E81 && c <= 0x0E82 ||
		c == 0x0E84 ||
		c >= 0x0E87 && c <= 0x0E88 ||
		c == 0x0E8A ||
		c == 0x0E8D ||
		c >= 0x0E94 && c <= 0x0E97 ||
		c >= 0x0E99 && c <= 0x0E9F ||
		c >= 0x0EA1 && c <= 0x0EA3 ||
		c == 0x0EA5 ||
		c == 0x0EA7 ||
		c >= 0x0EAA && c <= 0x0EAB ||
		c >= 0x0EAD && c <= 0x0EAE ||
		c == 0x0EB0 ||
		c >= 0x0EB2 && c <= 0x0EB3 ||
		c == 0x0EBD ||
		c >= 0x0EC0 && c <= 0x0EC4 ||
		c >= 0x0F40 && c <= 0x0F47 ||
		c >= 0x0F49 && c <= 0x0F69 ||
		c >= 0x10A0 && c <= 0x10C5 ||
		c >= 0x10D0 && c <= 0x10F6 ||
		c == 0x1100 ||
		c >= 0x1102 && c <= 0x1103 ||
		c >= 0x1105 && c <= 0x1107 ||
		c == 0x1109 ||
		c >= 0x110B && c <= 0x110C ||
		c >= 0x110E && c <= 0x1112 ||
		c == 0x113C ||
		c == 0x113E ||
		c == 0x1140 ||
		c == 0x114C ||
		c == 0x114E ||
		c == 0x1150 ||
		c >= 0x1154 && c <= 0x1155 ||
		c == 0x1159 ||
		c >= 0x115F && c <= 0x1161 ||
		c == 0x1163 ||
		c == 0x1165 ||
		c == 0x1167 ||
		c == 0x1169 ||
		c >= 0x116D && c <= 0x116E ||
		c >= 0x1172 && c <= 0x1173 ||
		c == 0x1175 ||
		c == 0x119E ||
		c == 0x11A8 ||
		c == 0x11AB ||
		c >= 0x11AE && c <= 0x11AF ||
		c >= 0x11B7 && c <= 0x11B8 ||
		c == 0x11BA ||
		c >= 0x11BC && c <= 0x11C2 ||
		c == 0x11EB ||
		c == 0x11F0 ||
		c == 0x11F9 ||
		c >= 0x1E00 && c <= 0x1E9B ||
		c >= 0x1EA0 && c <= 0x1EF9 ||
		c >= 0x1F00 && c <= 0x1F15 ||
		c >= 0x1F18 && c <= 0x1F1D ||
		c >= 0x1F20 && c <= 0x1F45 ||
		c >= 0x1F48 && c <= 0x1F4D ||
		c >= 0x1F50 && c <= 0x1F57 ||
		c == 0x1F59 ||
		c == 0x1F5B ||
		c == 0x1F5D ||
		c >= 0x1F5F && c <= 0x1F7D ||
		c >= 0x1F80 && c <= 0x1FB4 ||
		c >= 0x1FB6 && c <= 0x1FBC ||
		c == 0x1FBE ||
		c >= 0x1FC2 && c <= 0x1FC4 ||
		c >= 0x1FC6 && c <= 0x1FCC ||
		c >= 0x1FD0 && c <= 0x1FD3 ||
		c >= 0x1FD6 && c <= 0x1FDB ||
		c >= 0x1FE0 && c <= 0x1FEC ||
		c >= 0x1FF2 && c <= 0x1FF4 ||
		c >= 0x1FF6 && c <= 0x1FFC ||
		c == 0x2126 ||
		c >= 0x212A && c <= 0x212B ||
		c == 0x212E ||
		c >= 0x2180 && c <= 0x2182 ||
		c >= 0x3041 && c <= 0x3094 ||
		c >= 0x30A1 && c <= 0x30FA ||
		c >= 0x3105 && c <= 0x312C ||
		c >= 0xAC00 && c <= 0xD7A3 ||
		c >= 0x4E00 && c <= 0x9FA5 ||
		c == 0x3007 ||
		c >= 0x3021 && c <= 0x3029;
};

Utilities.isNCNameChar = function(c) {
	return c >= 0x0030 && c <= 0x0039
		|| c >= 0x0660 && c <= 0x0669
		|| c >= 0x06F0 && c <= 0x06F9
		|| c >= 0x0966 && c <= 0x096F
		|| c >= 0x09E6 && c <= 0x09EF
		|| c >= 0x0A66 && c <= 0x0A6F
		|| c >= 0x0AE6 && c <= 0x0AEF
		|| c >= 0x0B66 && c <= 0x0B6F
		|| c >= 0x0BE7 && c <= 0x0BEF
		|| c >= 0x0C66 && c <= 0x0C6F
		|| c >= 0x0CE6 && c <= 0x0CEF
		|| c >= 0x0D66 && c <= 0x0D6F
		|| c >= 0x0E50 && c <= 0x0E59
		|| c >= 0x0ED0 && c <= 0x0ED9
		|| c >= 0x0F20 && c <= 0x0F29
		|| c == 0x002E
		|| c == 0x002D
		|| c == 0x005F
		|| Utilities.isLetter(c)
		|| c >= 0x0300 && c <= 0x0345
		|| c >= 0x0360 && c <= 0x0361
		|| c >= 0x0483 && c <= 0x0486
		|| c >= 0x0591 && c <= 0x05A1
		|| c >= 0x05A3 && c <= 0x05B9
		|| c >= 0x05BB && c <= 0x05BD
		|| c == 0x05BF
		|| c >= 0x05C1 && c <= 0x05C2
		|| c == 0x05C4
		|| c >= 0x064B && c <= 0x0652
		|| c == 0x0670
		|| c >= 0x06D6 && c <= 0x06DC
		|| c >= 0x06DD && c <= 0x06DF
		|| c >= 0x06E0 && c <= 0x06E4
		|| c >= 0x06E7 && c <= 0x06E8
		|| c >= 0x06EA && c <= 0x06ED
		|| c >= 0x0901 && c <= 0x0903
		|| c == 0x093C
		|| c >= 0x093E && c <= 0x094C
		|| c == 0x094D
		|| c >= 0x0951 && c <= 0x0954
		|| c >= 0x0962 && c <= 0x0963
		|| c >= 0x0981 && c <= 0x0983
		|| c == 0x09BC
		|| c == 0x09BE
		|| c == 0x09BF
		|| c >= 0x09C0 && c <= 0x09C4
		|| c >= 0x09C7 && c <= 0x09C8
		|| c >= 0x09CB && c <= 0x09CD
		|| c == 0x09D7
		|| c >= 0x09E2 && c <= 0x09E3
		|| c == 0x0A02
		|| c == 0x0A3C
		|| c == 0x0A3E
		|| c == 0x0A3F
		|| c >= 0x0A40 && c <= 0x0A42
		|| c >= 0x0A47 && c <= 0x0A48
		|| c >= 0x0A4B && c <= 0x0A4D
		|| c >= 0x0A70 && c <= 0x0A71
		|| c >= 0x0A81 && c <= 0x0A83
		|| c == 0x0ABC
		|| c >= 0x0ABE && c <= 0x0AC5
		|| c >= 0x0AC7 && c <= 0x0AC9
		|| c >= 0x0ACB && c <= 0x0ACD
		|| c >= 0x0B01 && c <= 0x0B03
		|| c == 0x0B3C
		|| c >= 0x0B3E && c <= 0x0B43
		|| c >= 0x0B47 && c <= 0x0B48
		|| c >= 0x0B4B && c <= 0x0B4D
		|| c >= 0x0B56 && c <= 0x0B57
		|| c >= 0x0B82 && c <= 0x0B83
		|| c >= 0x0BBE && c <= 0x0BC2
		|| c >= 0x0BC6 && c <= 0x0BC8
		|| c >= 0x0BCA && c <= 0x0BCD
		|| c == 0x0BD7
		|| c >= 0x0C01 && c <= 0x0C03
		|| c >= 0x0C3E && c <= 0x0C44
		|| c >= 0x0C46 && c <= 0x0C48
		|| c >= 0x0C4A && c <= 0x0C4D
		|| c >= 0x0C55 && c <= 0x0C56
		|| c >= 0x0C82 && c <= 0x0C83
		|| c >= 0x0CBE && c <= 0x0CC4
		|| c >= 0x0CC6 && c <= 0x0CC8
		|| c >= 0x0CCA && c <= 0x0CCD
		|| c >= 0x0CD5 && c <= 0x0CD6
		|| c >= 0x0D02 && c <= 0x0D03
		|| c >= 0x0D3E && c <= 0x0D43
		|| c >= 0x0D46 && c <= 0x0D48
		|| c >= 0x0D4A && c <= 0x0D4D
		|| c == 0x0D57
		|| c == 0x0E31
		|| c >= 0x0E34 && c <= 0x0E3A
		|| c >= 0x0E47 && c <= 0x0E4E
		|| c == 0x0EB1
		|| c >= 0x0EB4 && c <= 0x0EB9
		|| c >= 0x0EBB && c <= 0x0EBC
		|| c >= 0x0EC8 && c <= 0x0ECD
		|| c >= 0x0F18 && c <= 0x0F19
		|| c == 0x0F35
		|| c == 0x0F37
		|| c == 0x0F39
		|| c == 0x0F3E
		|| c == 0x0F3F
		|| c >= 0x0F71 && c <= 0x0F84
		|| c >= 0x0F86 && c <= 0x0F8B
		|| c >= 0x0F90 && c <= 0x0F95
		|| c == 0x0F97
		|| c >= 0x0F99 && c <= 0x0FAD
		|| c >= 0x0FB1 && c <= 0x0FB7
		|| c == 0x0FB9
		|| c >= 0x20D0 && c <= 0x20DC
		|| c == 0x20E1
		|| c >= 0x302A && c <= 0x302F
		|| c == 0x3099
		|| c == 0x309A
		|| c == 0x00B7
		|| c == 0x02D0
		|| c == 0x02D1
		|| c == 0x0387
		|| c == 0x0640
		|| c == 0x0E46
		|| c == 0x0EC6
		|| c == 0x3005
		|| c >= 0x3031 && c <= 0x3035
		|| c >= 0x309D && c <= 0x309E
		|| c >= 0x30FC && c <= 0x30FE;
};

Utilities.coalesceText = function(n) {
	for (var m = n.firstChild; m != null; m = m.nextSibling) {
		if (m.nodeType == 3 /*Node.TEXT_NODE*/ || m.nodeType == 4 /*Node.CDATA_SECTION_NODE*/) {
			var s = m.nodeValue;
			var first = m;
			m = m.nextSibling;
			while (m != null && (m.nodeType == 3 /*Node.TEXT_NODE*/ || m.nodeType == 4 /*Node.CDATA_SECTION_NODE*/)) {
				s += m.nodeValue;
				var del = m;
				m = m.nextSibling;
				del.parentNode.removeChild(del);
			}
			if (first.nodeType == 4 /*Node.CDATA_SECTION_NODE*/) {
				var p = first.parentNode;
				if (first.nextSibling == null) {
					p.removeChild(first);
					p.appendChild(p.ownerDocument.createTextNode(s));
				} else {
					var next = first.nextSibling;
					p.removeChild(first);
					p.insertBefore(p.ownerDocument.createTextNode(s), next);
				}
			} else {
				first.nodeValue = s;
			}
			if (m == null) {
				break;
			}
		} else if (m.nodeType == 1 /*Node.ELEMENT_NODE*/) {
			Utilities.coalesceText(m);
		}
	}
};

Utilities.instance_of = function(o, c) {
	while (o != null) {
		if (o.constructor === c) {
			return true;
		}
		if (o === Object) {
			return false;
		}
		o = o.constructor.superclass;
	}
	return false;
};

Utilities.getElementById = function(n, id) {
	// Note that this does not check the DTD to check for actual
	// attributes of type ID, so this may be a bit wrong.
	if (n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
		if (n.getAttribute("id") == id
				|| n.getAttributeNS(null, "id") == id) {
			return n;
		}
	}
	for (var m = n.firstChild; m != null; m = m.nextSibling) {
		var res = Utilities.getElementById(m, id);
		if (res != null) {
			return res;
		}
	}
	return null;
};

// XPathException ////////////////////////////////////////////////////////////

XPathException.prototype = {};
XPathException.prototype.constructor = XPathException;
XPathException.superclass = Object.prototype;

function XPathException(c, e) {
	this.code = c;
	this.exception = e;
}

XPathException.prototype.toString = function() {
	var msg = this.exception ? ": " + this.exception.toString() : "";
	switch (this.code) {
		case XPathException.INVALID_EXPRESSION_ERR:
			return "Invalid expression" + msg;
		case XPathException.TYPE_ERR:
			return "Type error" + msg;
	}
};

XPathException.INVALID_EXPRESSION_ERR = 51;
XPathException.TYPE_ERR = 52;

// XPathExpression ///////////////////////////////////////////////////////////

XPathExpression.prototype = {};
XPathExpression.prototype.constructor = XPathExpression;
XPathExpression.superclass = Object.prototype;

function XPathExpression(e, r, p) {
	this.xpath = p.parse(e);
	this.context = new XPathContext();
	this.context.namespaceResolver = new XPathNSResolverWrapper(r);
}

XPathExpression.prototype.evaluate = function(n, t, res) {
	this.context.expressionContextNode = n;
	var result = this.xpath.evaluate(this.context);
	return new XPathResult(result, t);
}

// XPathNSResolverWrapper ////////////////////////////////////////////////////

XPathNSResolverWrapper.prototype = {};
XPathNSResolverWrapper.prototype.constructor = XPathNSResolverWrapper;
XPathNSResolverWrapper.superclass = Object.prototype;

function XPathNSResolverWrapper(r) {
	this.xpathNSResolver = r;
}

XPathNSResolverWrapper.prototype.getNamespace = function(prefix, n) {
    if (this.xpathNSResolver == null) {
        return null;
    }
	return this.xpathNSResolver.lookupNamespaceURI(prefix);
};

// NodeXPathNSResolver ///////////////////////////////////////////////////////

NodeXPathNSResolver.prototype = {};
NodeXPathNSResolver.prototype.constructor = NodeXPathNSResolver;
NodeXPathNSResolver.superclass = Object.prototype;

function NodeXPathNSResolver(n) {
	this.node = n;
	this.namespaceResolver = new NamespaceResolver();
}

NodeXPathNSResolver.prototype.lookupNamespaceURI = function(prefix) {
	return this.namespaceResolver.getNamespace(prefix, this.node);
};

// XPathResult ///////////////////////////////////////////////////////////////

XPathResult.prototype = {};
XPathResult.prototype.constructor = XPathResult;
XPathResult.superclass = Object.prototype;

function XPathResult(v, t) {
	if (t == XPathResult.ANY_TYPE) {
		if (v.constructor === XString) {
			t = XPathResult.STRING_TYPE;
		} else if (v.constructor === XNumber) {
			t = XPathResult.NUMBER_TYPE;
		} else if (v.constructor === XBoolean) {
			t = XPathResult.BOOLEAN_TYPE;
		} else if (v.constructor === XNodeSet) {
			t = XPathResult.UNORDERED_NODE_ITERATOR_TYPE;
		}
	}
	this.resultType = t;
	switch (t) {
		case XPathResult.NUMBER_TYPE:
			this.numberValue = v.numberValue();
			return;
		case XPathResult.STRING_TYPE:
			this.stringValue = v.stringValue();
			return;
		case XPathResult.BOOLEAN_TYPE:
			this.booleanValue = v.booleanValue();
			return;
		case XPathResult.ANY_UNORDERED_NODE_TYPE:
		case XPathResult.FIRST_ORDERED_NODE_TYPE:
			if (v.constructor === XNodeSet) {
				this.singleNodeValue = v.first();
				return;
			}
			break;
		case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
		case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
			if (v.constructor === XNodeSet) {
				this.invalidIteratorState = false;
				this.nodes = v.toArray();
				this.iteratorIndex = 0;
				return;
			}
			break;
		case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
		case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
			if (v.constructor === XNodeSet) {
				this.nodes = v.toArray();
				this.snapshotLength = this.nodes.length;
				return;
			}
			break;
	}
	throw new XPathException(XPathException.TYPE_ERR);
};

XPathResult.prototype.iterateNext = function() {
	if (this.resultType != XPathResult.UNORDERED_NODE_ITERATOR_TYPE
			&& this.resultType != XPathResult.ORDERED_NODE_ITERATOR_TYPE) {
		throw new XPathException(XPathException.TYPE_ERR);
	}
	return this.nodes[this.iteratorIndex++];
};

XPathResult.prototype.snapshotItem = function(i) {
	if (this.resultType != XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE
			&& this.resultType != XPathResult.ORDERED_NODE_SNAPSHOT_TYPE) {
		throw new XPathException(XPathException.TYPE_ERR);
	}
	return this.nodes[i];
};

XPathResult.ANY_TYPE = 0;
XPathResult.NUMBER_TYPE = 1;
XPathResult.STRING_TYPE = 2;
XPathResult.BOOLEAN_TYPE = 3;
XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
XPathResult.FIRST_ORDERED_NODE_TYPE = 9;

// DOM 3 XPath support ///////////////////////////////////////////////////////

function installDOM3XPathSupport(doc, p) {
	doc.createExpression = function(e, r) {
		try {
			return new XPathExpression(e, r, p);
		} catch (e) {
			throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, e);
		}
	};
	doc.createNSResolver = function(n) {
		return new NodeXPathNSResolver(n);
	};
	doc.evaluate = function(e, cn, r, t, res) {
		if (t < 0 || t > 9) {
			throw { code: 0, toString: function() { return "Request type not supported"; } };
		}
        return doc.createExpression(e, r, p).evaluate(cn, t, res);
	};
};

// ---------------------------------------------------------------------------

// Install DOM 3 XPath support for the current document.
try {
	var shouldInstall = true;
	try {
		if (document.implementation
				&& document.implementation.hasFeature
				&& document.implementation.hasFeature("XPath", null)) {
			shouldInstall = false;
		}
	} catch (e) {
	}
	if (shouldInstall) {
		installDOM3XPathSupport(document, new XPathParser());
	}
} catch (e) {
}

// ---------------------------------------------------------------------------
// exports for node.js

installDOM3XPathSupport(exports, new XPathParser());

exports.XPathResult = XPathResult;

// helper
exports.select = function(e, doc, single) {
	return exports.selectWithResolver(e, doc, null, single);
};

exports.useNamespaces = function(mappings) {
	var resolver = {
		mappings: mappings || {},
		lookupNamespaceURI: function(prefix) {
			return this.mappings[prefix];
		}
	};

	return function(e, doc, single) {
		return exports.selectWithResolver(e, doc, resolver, single);
	};
};

exports.selectWithResolver = function(e, doc, resolver, single) {
	var expression = new XPathExpression(e, resolver, new XPathParser());
	var type = XPathResult.ANY_TYPE;

	var result = expression.evaluate(doc, type, null);

	if (result.resultType == XPathResult.STRING_TYPE) {
		result = result.stringValue;
	}
	else if (result.resultType == XPathResult.NUMBER_TYPE) {
		result = result.numberValue;
	}
	else if (result.resultType == XPathResult.BOOLEAN_TYPE) {
		result = result.booleanValue;
	}
	else {
		result = result.nodes;
		if (single) {
			result = result[0];
		}
	}

	return result;
};

exports.select1 = function(e, doc) {
	return exports.select(e, doc, true);
};

// end non-node wrapper
})(typeof exports !== 'undefined' ? exports : xpath);

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/events/events.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/flux/index.js":[function(require,module,exports){
/**
 * Copyright (c) 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

module.exports.Dispatcher = require('./lib/Dispatcher');

},{"./lib/Dispatcher":"/Users/Jacob/workspace/scheduler/front-end/node_modules/flux/lib/Dispatcher.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/flux/lib/Dispatcher.js":[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Dispatcher
 * 
 * @preventMunge
 */

'use strict';

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var invariant = require('fbjs/lib/invariant');

var _prefix = 'ID_';

/**
 * Dispatcher is used to broadcast payloads to registered callbacks. This is
 * different from generic pub-sub systems in two ways:
 *
 *   1) Callbacks are not subscribed to particular events. Every payload is
 *      dispatched to every registered callback.
 *   2) Callbacks can be deferred in whole or part until other callbacks have
 *      been executed.
 *
 * For example, consider this hypothetical flight destination form, which
 * selects a default city when a country is selected:
 *
 *   var flightDispatcher = new Dispatcher();
 *
 *   // Keeps track of which country is selected
 *   var CountryStore = {country: null};
 *
 *   // Keeps track of which city is selected
 *   var CityStore = {city: null};
 *
 *   // Keeps track of the base flight price of the selected city
 *   var FlightPriceStore = {price: null}
 *
 * When a user changes the selected city, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'city-update',
 *     selectedCity: 'paris'
 *   });
 *
 * This payload is digested by `CityStore`:
 *
 *   flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'city-update') {
 *       CityStore.city = payload.selectedCity;
 *     }
 *   });
 *
 * When the user selects a country, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'country-update',
 *     selectedCountry: 'australia'
 *   });
 *
 * This payload is digested by both stores:
 *
 *   CountryStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       CountryStore.country = payload.selectedCountry;
 *     }
 *   });
 *
 * When the callback to update `CountryStore` is registered, we save a reference
 * to the returned token. Using this token with `waitFor()`, we can guarantee
 * that `CountryStore` is updated before the callback that updates `CityStore`
 * needs to query its data.
 *
 *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       // `CountryStore.country` may not be updated.
 *       flightDispatcher.waitFor([CountryStore.dispatchToken]);
 *       // `CountryStore.country` is now guaranteed to be updated.
 *
 *       // Select the default city for the new country
 *       CityStore.city = getDefaultCityForCountry(CountryStore.country);
 *     }
 *   });
 *
 * The usage of `waitFor()` can be chained, for example:
 *
 *   FlightPriceStore.dispatchToken =
 *     flightDispatcher.register(function(payload) {
 *       switch (payload.actionType) {
 *         case 'country-update':
 *         case 'city-update':
 *           flightDispatcher.waitFor([CityStore.dispatchToken]);
 *           FlightPriceStore.price =
 *             getFlightPriceStore(CountryStore.country, CityStore.city);
 *           break;
 *     }
 *   });
 *
 * The `country-update` payload will be guaranteed to invoke the stores'
 * registered callbacks in order: `CountryStore`, `CityStore`, then
 * `FlightPriceStore`.
 */

var Dispatcher = (function () {
  function Dispatcher() {
    _classCallCheck(this, Dispatcher);

    this._callbacks = {};
    this._isDispatching = false;
    this._isHandled = {};
    this._isPending = {};
    this._lastID = 1;
  }

  /**
   * Registers a callback to be invoked with every dispatched payload. Returns
   * a token that can be used with `waitFor()`.
   */

  Dispatcher.prototype.register = function register(callback) {
    var id = _prefix + this._lastID++;
    this._callbacks[id] = callback;
    return id;
  };

  /**
   * Removes a callback based on its token.
   */

  Dispatcher.prototype.unregister = function unregister(id) {
    !this._callbacks[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.unregister(...): `%s` does not map to a registered callback.', id) : invariant(false) : undefined;
    delete this._callbacks[id];
  };

  /**
   * Waits for the callbacks specified to be invoked before continuing execution
   * of the current callback. This method should only be used by a callback in
   * response to a dispatched payload.
   */

  Dispatcher.prototype.waitFor = function waitFor(ids) {
    !this._isDispatching ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): Must be invoked while dispatching.') : invariant(false) : undefined;
    for (var ii = 0; ii < ids.length; ii++) {
      var id = ids[ii];
      if (this._isPending[id]) {
        !this._isHandled[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): Circular dependency detected while ' + 'waiting for `%s`.', id) : invariant(false) : undefined;
        continue;
      }
      !this._callbacks[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): `%s` does not map to a registered callback.', id) : invariant(false) : undefined;
      this._invokeCallback(id);
    }
  };

  /**
   * Dispatches a payload to all registered callbacks.
   */

  Dispatcher.prototype.dispatch = function dispatch(payload) {
    !!this._isDispatching ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.') : invariant(false) : undefined;
    this._startDispatching(payload);
    try {
      for (var id in this._callbacks) {
        if (this._isPending[id]) {
          continue;
        }
        this._invokeCallback(id);
      }
    } finally {
      this._stopDispatching();
    }
  };

  /**
   * Is this Dispatcher currently dispatching.
   */

  Dispatcher.prototype.isDispatching = function isDispatching() {
    return this._isDispatching;
  };

  /**
   * Call the callback stored with the given id. Also do some internal
   * bookkeeping.
   *
   * @internal
   */

  Dispatcher.prototype._invokeCallback = function _invokeCallback(id) {
    this._isPending[id] = true;
    this._callbacks[id](this._pendingPayload);
    this._isHandled[id] = true;
  };

  /**
   * Set up bookkeeping needed when dispatching.
   *
   * @internal
   */

  Dispatcher.prototype._startDispatching = function _startDispatching(payload) {
    for (var id in this._callbacks) {
      this._isPending[id] = false;
      this._isHandled[id] = false;
    }
    this._pendingPayload = payload;
    this._isDispatching = true;
  };

  /**
   * Clear bookkeeping used for dispatching.
   *
   * @internal
   */

  Dispatcher.prototype._stopDispatching = function _stopDispatching() {
    delete this._pendingPayload;
    this._isDispatching = false;
  };

  return Dispatcher;
})();

module.exports = Dispatcher;
}).call(this,require('_process'))

},{"_process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js","fbjs/lib/invariant":"/Users/Jacob/workspace/scheduler/front-end/node_modules/flux/node_modules/fbjs/lib/invariant.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/flux/node_modules/fbjs/lib/invariant.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

"use strict";

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function (condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error('Invariant Violation: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;
}).call(this,require('_process'))

},{"_process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/node-calendar/node-calendar.js":[function(require,module,exports){
/*!
 * node-calendar
 * Copyright(c) 2013 Armin Tamzarian <tamzarian1989@gmail.com>
 * MIT Licensed
 */

(function() {

    var _DAYS_IN_MONTH = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var _DAYS_BEFORE_MONTH = [-1, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];

    try {
      var cldr = require("cldr");
    }
    catch(err) {
      cldr = false;
    }

    /**
     * Adjust the provided weekday index from the Javascript index scheme
     * (SUN=0, MON=1, ...) to the Python scheme (MON=0, TUE=1, ...)
     *
     * @api private
     */
    function _adjustWeekday(weekday) {
      return weekday > 0 ? weekday - 1 : 6
    };

    /**
     * Extracts the wide or abbreviated day names for a specified locale.
     * If cldr is not installed values default to that for locale en_US.
     *
     * @param {Boolean} abbr
     * @param {String} locale
     * @api private
     */
    function _extractLocaleDays(abbr, locale) {
      short = typeof(abbr) === "undefined" ? false : abbr;

      if(abbr) {
        return cldr ? cldr.extractDayNames(locale).format.abbreviated : ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
      }
      else {
        return cldr ? cldr.extractDayNames(locale).format.wide : ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
      }
    };

    /**
     * Extracts the wide or abbreviated month names for a specified locale.
     * If cldr is not installed values default to that for locale en_US.
     *
     * @param {Boolean} abbr
     * @param {String} locale
     * @api private
     */
    function _extractLocaleMonths(abbr, locale) {
      short = typeof(abbr) === "undefined" ? false : abbr;

      var months = []
      if(abbr) {
        months = cldr ? cldr.extractMonthNames(locale).format.abbreviated : ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      }
      else {
        months = cldr ? cldr.extractMonthNames(locale).format.wide : ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
      }

      months.unshift('');
      return months;
    };

    /**
     * Calculates the ordinal time from given year, month, day values.
     *
     * @param {Number} year
     * @param {Number} month
     * @param {Number} day
     * @api private
     */
    function _toordinal(year, month, day) {
      var days_before_year = ((year - 1) * 365) + Math.floor((year - 1) / 4) - Math.floor((year - 1) / 100) + Math.floor((year - 1) / 400);
      var days_before_month = _DAYS_BEFORE_MONTH[month] + (month > 2 && isleap(year) ? 1 : 0);
      return (days_before_year + days_before_month + day);
    }

    /**
     * Return true for leap years, false for non-leap years.
     *
     * @param {Number} year
     * @api public
     */
    function isleap(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    };

    /**
     * Return number of leap years in range [y1, y2).
     * Assumes y1 <= y2.
     *
     * @param {Number} y1
     * @param {Number} y2
     * @api public
     */
    function leapdays(y1, y2) {
      y1--;
      y2--;
      return (Math.floor(y2/4) - Math.floor(y1/4)) - (Math.floor(y2/100) - Math.floor(y1/100)) + (Math.floor(y2/400) - Math.floor(y1/400));
    };

    /**
     * Return starting weekday (0-6 ~ Mon-Sun) and number of days (28-31) for
     * year, month.
     *
     * @param {Number} year
     * @param {Number} month
     * @throws {IllegalMonthError} If the provided month is invalid.
     * @api public
     */
    function monthrange(year, month) {
      if(month < 1 || month > 12) {
        throw new IllegalMonthError();
      }

      var day1 = weekday(year, month, 1);
      var ndays = _DAYS_IN_MONTH[month] + (month === 2 && isleap(year));

      return [day1, ndays];
    };

    /**
     * Sets the locale for use in extracting month and weekday names.
     *
     * @param {String} locale
     * @throws {IllegalLocaleError} If the provided locale is invalid.
     * @api public
     */
    function setlocale(locale) {
      locale = typeof(locale) === "undefined" ? "en_US" : locale;

      if((cldr && (cldr.localeIds.indexOf(locale.replace(/-/g, '_').toLowerCase()) === -1)) || (!cldr && ((locale.replace(/-/g, '_').toLowerCase() !== "en_us")))) {
         throw new IllegalLocaleError();
      }

      this.day_name   = _extractLocaleDays(false, locale);
      this.day_abbr   = _extractLocaleDays(true, locale);
      this.month_name = _extractLocaleMonths(false, locale);
      this.month_abbr = _extractLocaleMonths(true, locale);
    };

    /**
      * Unrelated but handy function to calculate Unix timestamp from GMT.
      *
      * @param {Array} tuple
      * @throws {IllegalMonthError} If the provided month element is invalid.
      * @throws {IllegalDayError} If the provided day element is invalid.
      * @api public
      */
    function timegm(timegmt) {
      var year   = timegmt[0];
      var month  = timegmt[1];
      var day    = timegmt[2];
      var hour   = timegmt[3];
      var minute = timegmt[4];
      var second = timegmt[5];

      if(month < 1 || month > 12) {
        throw new IllegalMonthError();
      }

      if(day < 1 || day > (_DAYS_IN_MONTH[month] + (month === 2 && isleap(year)))) {
        throw new IllegalDayError();
      }

      if(hour < 0 || hour > 23 || minute < 0 || minute > 59 || second < 0 || second > 59) {
        throw new IllegalTimeError();
      }

      var days = _toordinal(year, month, 1) - 719163 + day - 1;
      var hours = (days * 24) + hour;
      var minutes = (hours * 60) + minute;
      var seconds = (minutes * 60) + second;

      return seconds;
    }

    /**
     * Return weekday (0-6 ~ Mon-Sun) for year (1970-...), month (1-12),
     * day (1-31).
     *
     * @param {Number} year
     * @param {Number} month
     * @param {Number} day
     * @throws {IllegalMonthError} If the provided month element is invalid.
     * @throws {IllegalDayError} If the provided day element is invalid.
     * @api public
     */
    function weekday(year, month, day) {
      if(month < 1 || month > 12) {
        throw new IllegalMonthError();
      }

      if(day < 1 || day > (_DAYS_IN_MONTH[month] + (month === 2 && isleap(year)))) {
        throw new IllegalDayError();
      }

      var date = new Date(year, month - 1, day);
      return _adjustWeekday(date.getDay());
    };


    /**
     * Base calendar class. This class doesn't do any formatting. It simply
     * provides data to subclasses.
     *
     * @param {Number} firstweekday
     * @throws {IllegalWeekdayError} If the provided firstweekday is invalid.
     * @api public
     */
    function Calendar(firstweekday) {
      this._firstweekday = typeof(firstweekday) === "undefined" ? 0 : firstweekday;

      if(firstweekday < 0 || firstweekday > 6) {
        throw new IllegalWeekdayError();
      }

      this._oneday = 1000 * 60 * 60 * 24;
      this._onehour = 1000 * 60 * 60;
    };

    /**
     * GET-er for firstweekday
     *
     * @api public
     */
    Calendar.prototype.getfirstweekday = function() {
      return this._firstweekday;
    };

    /**
     * SET-er for firstweekday
     *
     * @param {Number} firstweekday
     * @throws {IllegalWeekdayError} If the provided firstweekday is invalid.
     * @api public
     */
    Calendar.prototype.setfirstweekday = function(firstweekday) {
      if(firstweekday < 0 || firstweekday > 6) {
        throw new IllegalWeekdayError();
      }

      this._firstweekday = firstweekday;
    };

    /**
     * Return an array for one week of weekday numbers starting with the
     * configured first one.
     *
     * @api public
     */
    Calendar.prototype.iterweekdays = function() {
      var weekdays = [];
      for(var i = this._firstweekday; i < this._firstweekday + 7; i++) {
        weekdays.push(i % 7);
      }

      return weekdays;
    };

    /**
     * Return an array for one month. The array will contain Date
     * values and will always iterate through complete weeks, so it will yield
     * dates outside the specified month.
     *
     * @param {Number} year
     * @param {Number} month
     * @api public
     */

    Calendar.prototype.itermonthdates = function(year, month) {
      if(month < 1 || month > 12) {
        throw new IllegalMonthError();
      }

      var date = new Date(year, month - 1, 1);
      var day = _adjustWeekday(date.getDay());
      var days = (day - this._firstweekday)  >= 0 ? (day - this._firstweekday) % 7 : 7 + (day - this._firstweekday);

      date.setTime(date.getTime() - (days * this._oneday));

      var dates = [];
      while(true) {
        dates.push(new Date(date.getTime()));

        var currentDate = date.getDate();
        date.setTime(date.getTime() + this._oneday);

        // Hack to account for DST
        while(date.getDate() === currentDate) {
          date.setTime(date.getTime() + this._onehour);
        }

        if(date.getMonth() !== month - 1 && _adjustWeekday(date.getDay()) === this._firstweekday) {
          break;
        }
      }

      return dates;
    };
    /**
     * Like itermonthdates(), but will yield day numbers. For days outside
     * the specified month the day number is 0.
     *
     * @param {Number} year
     * @param {Number} month
     * @api public
     */
    Calendar.prototype.itermonthdays = function(year, month) {
      return this.itermonthdates(year, month).map(function(value){
        return value.getMonth() === month - 1 ? value.getDate() : 0;
      });
    };

    /**
     * Like itermonthdates(), but will yield [day number, weekday number]
     * arrays. For days outside the specified month the day number is 0.
     *
     * @param {Number} year
     * @param {Number} month
     * @api public
     */
    Calendar.prototype.itermonthdays2 = function(year, month) {
      return this.itermonthdates(year, month).map(function(value){
        return value.getMonth() === month - 1 ? [value.getDate(), _adjustWeekday(value.getDay())] : [0, _adjustWeekday(value.getDay())];
      }, this);
    };

    /**
     * Return a matrix (array of array) representing a month's calendar.
     * Each row represents a week; week entries are Date values.
     *
     * @param {Number} year
     * @param {Number} month
     * @api public
     */
    Calendar.prototype.monthdatescalendar = function(year, month) {
      var days = [];
      dates = this.itermonthdates(year, month);
      for(var i = 0; i < dates.length; i += 7) {
        days.push(dates.slice(i, i + 7));
      }

      return days;
    };

    /**
     * Return a matrix representing a month's calendar.
     * Each row represents a week; days outside this month are zero.
     *
     * @param {Number} year
     * @param {Number} month
     * @api public
     */
    Calendar.prototype.monthdayscalendar = function(year, month) {
      var days = [];
      dates = this.itermonthdays(year, month);
      for(var i = 0; i < dates.length; i += 7) {
        days.push(dates.slice(i, i + 7));
      }

      return days;
    };

    /**
     * Return a matrix representing a month's calendar.
     * Each row represents a week; week entries are
     * [day number, weekday number] arrays. Day numbers outside this month
     * are zero.
     *
     * @param {Number} year
     * @param {Number} month
     * @api public
     */
    Calendar.prototype.monthdays2calendar = function(year, month) {
      var days = [];
      dates = this.itermonthdays2(year, month);
      for(var i = 0; i < dates.length; i += 7) {
        days.push(dates.slice(i, i + 7));
      }

      return days;
    };

    /**
     * Return the data for the specified year ready for formatting. The return
     * value is an array of month rows. Each month row contains up to width months.
     * Each month contains between 4 and 6 weeks and each week contains 1-7
     * days. Days are Date objects.
     *
     * @param {Number} year
     * @param {Number} width
     * @api public
     */
    Calendar.prototype.yeardatescalendar = function(year, width) {
      width = typeof(width) === "undefined" ? 3 : width;

      var months = [];
      for(var month = 1; month <= 12; month++) {
        months.push(this.monthdatescalendar(year, month));
      }

      var rows = [];
      for(var i = 0; i < months.length; i += width) {
        rows.push(months.slice(i, i + width));
      }
      return rows;
    };

    /**
     * Return the data for the specified year ready for formatting (similar to
     * yeardatescalendar()). Entries in the week arrays are day numbers.
     * Day numbers outside this month are zero.
     *
     * @param {Number} year
     * @param {Number} width
     * @api public
     */
    Calendar.prototype.yeardayscalendar = function(year, width) {
      width = typeof(width) === "undefined" ? 3 : width;

      var months = [];
      for(var month = 1; month <= 12; month++) {
        months.push(this.monthdayscalendar(year, month));
      }

      var rows = [];
      for(var i = 0; i < months.length; i += width) {
        rows.push(months.slice(i, i + width));
      }
      return rows;
    };

    /**
     * Return the data for the specified year ready for formatting (similar to
     * yeardatescalendar()). Entries in the week arrays are
     * [day number, weekday number] arrays. Day numbers outside this month are
     * zero.
     *
     * @param {Number} year
     * @param {Number} width
     * @api public
     */
    Calendar.prototype.yeardays2calendar = function(year, width) {
      width = typeof(width) === "undefined" ? 3 : width;

      var months = [];
      for(var month = 1; month <= 12; month++) {
        months.push(this.monthdays2calendar(year, month));
      }

      var rows = [];
      for(var i = 0; i < months.length; i += width) {
        rows.push(months.slice(i, i + width));
      }
      return rows;
    };

    /**
     * Error indicating a nonexistent or unsupported locale specified.
     *
     * @param {String} message
     * @api public
     */
    function IllegalLocaleError(message) {
      this.name = "IllegalLocaleError";
      this.message = typeof(message) === "undefined" ? "Invalid locale specified." : message;
    };
    IllegalLocaleError.prototype = new Error();
    IllegalLocaleError.prototype.constructor = IllegalLocaleError;

    /**
     * Error indicating a day index specified outside of the valid range.
     *
     * @param {String} message
     * @api public
     */
    function IllegalDayError(message) {
      this.name = "IllegalDayError";
      this.message = typeof(message) === "undefined" ? "Invalid day specified." : message;
    };
    IllegalDayError.prototype = new Error();
    IllegalDayError.prototype.constructor = IllegalDayError;

    /**
     * Error indicating a month index specified outside of the expected range (1-12 ~ Jan-Dec).
     *
     * @param {String} message
     * @api public
     */
    function IllegalMonthError(message) {
      this.name = "IllegalMonthError";
      this.message = typeof(message) === "undefined" ? "Invalid month specified." : message;
    };
    IllegalMonthError.prototype = new Error();
    IllegalMonthError.prototype.constructor = IllegalMonthError;

    /**
     * Error indicating a time element is outside of the valid range.
     *
     * @param {String} message
     * @api public
     */
    function IllegalTimeError(message) {
      this.name = "IllegalTimeError";
      this.message = typeof(message) === "undefined" ? "Invalid time element specified." : message;
    };
    IllegalTimeError.prototype = new Error();
    IllegalTimeError.prototype.constructor = IllegalTimeError;

    /**
     * Error indicating a weekday index specified outside of the expected range (0-6 ~ Mon-Sun).
     *
     * @param {String} message
     * @api public
     */
    function IllegalWeekdayError(message) {
      this.name = "IllegalWeekdayError";
      this.message = typeof(message) === "undefined" ? "Invalid weekday specified." : message;
    };
    IllegalWeekdayError .prototype = new Error();
    IllegalWeekdayError .prototype.constructor = IllegalWeekdayError ;

    // export of package-like object with explicit public API
    var calendar = function() {};

    calendar.isleap     = isleap;
    calendar.leapdays   = leapdays;
    calendar.monthrange = monthrange;
    calendar.weekday    = weekday;
    calendar.setlocale  = setlocale;
    calendar.timegm     = timegm;
    calendar.Calendar   = Calendar;

    calendar.IllegalLocaleError  = IllegalLocaleError;
    calendar.IllegalDayError     = IllegalDayError;
    calendar.IllegalMonthError   = IllegalMonthError;
    calendar.IllegalTimeError    = IllegalTimeError;
    calendar.IllegalWeekdayError = IllegalWeekdayError;

    calendar.MONDAY     = 0;
    calendar.TUESDAY    = 1;
    calendar.WEDNESDAY  = 2;
    calendar.THURSDAY   = 3;
    calendar.FRIDAY     = 4;
    calendar.SATURDAY   = 5;
    calendar.SUNDAY     = 6;

    calendar.JANUARY    =  1;
    calendar.FEBRUARY   =  2;
    calendar.MARCH      =  3;
    calendar.APRIL      =  4;
    calendar.MAY        =  5;
    calendar.JUNE       =  6;
    calendar.JULY       =  7;
    calendar.AUGUST     =  8;
    calendar.SEPTEMBER  =  9;
    calendar.OCTOBER    = 10;
    calendar.NOVEMBER   = 11;
    calendar.DECEMBER   = 12;

    calendar.setlocale();

    // Initialization methodology and noConflict courtesy node-uuid:
    // https://github.com/broofa/node-uuid

    var _global = this;

    // Publish as node.js module
    if (typeof(module) != 'undefined' && module.exports) {
      module.exports = calendar;
    }

    // Publish as global (in browsers)
    else {
      var _previousRoot = _global.calendar;

      /**
        * Reset global 'calendar' variable
        *
        * @api public
        */
      calendar.noconflict = function() {
        _global.calendar = _previousRoot;
        return calendar;
      };

      _global.calendar = calendar;
    }

}).call(this);

},{"cldr":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/cldr.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/react/lib/Object.assign.js":[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Object.assign
 */

// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign

'use strict';

function assign(target, sources) {
  if (target == null) {
    throw new TypeError('Object.assign target cannot be null or undefined');
  }

  var to = Object(target);
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
    var nextSource = arguments[nextIndex];
    if (nextSource == null) {
      continue;
    }

    var from = Object(nextSource);

    // We don't currently support accessors nor proxies. Therefore this
    // copy cannot throw. If we ever supported this then we must handle
    // exceptions and side-effects. We don't support symbols so they won't
    // be transferred.

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
  }

  return to;
}

module.exports = assign;

},{}],"/Users/Jacob/workspace/scheduler/front-end/src/js/Action.js":[function(require,module,exports){
var AppDispatcher = require('./Dispatcher.js');
var appConstants = require('./Constants.js');

var plannerActions = {
  newMonth: function (date) {
    AppDispatcher.handleViewAction({
      actionType: appConstants.NEW_MONTH,
      data: date
    });
  },
  findMonth: function (direction) {
    AppDispatcher.handleViewAction({
      actionType: appConstants.FIND_MONTH,
      data: direction
    });
  },
  selectedDay: function (dayNum) {
    AppDispatcher.handleViewAction({
      actionType: appConstants.SELECTED_DAY,
      data: dayNum
    });
  },
  addEvents: function (evt) {
    AppDispatcher.handleViewAction({
      actionType: appConstants.ADD_EVENTS,
      data: evt
    });
  }
};

module.exports = plannerActions;

},{"./Constants.js":"/Users/Jacob/workspace/scheduler/front-end/src/js/Constants.js","./Dispatcher.js":"/Users/Jacob/workspace/scheduler/front-end/src/js/Dispatcher.js"}],"/Users/Jacob/workspace/scheduler/front-end/src/js/Constants.js":[function(require,module,exports){
var appConstants = {
  NEW_MONTH: 'NEW_MONTH',
  FIND_MONTH: 'FIND_MONTH',
  SELECTED_DAY: 'SELECTED_DAY',
  ADD_EVENTS: 'ADD_EVENTS'
};

module.exports = appConstants;

},{}],"/Users/Jacob/workspace/scheduler/front-end/src/js/Dispatcher.js":[function(require,module,exports){
var Dispatcher = require('flux').Dispatcher;
var AppDispatcher = new Dispatcher();

AppDispatcher.handleViewAction = function(action) {
  this.dispatch({
    source: 'VIEW_ACTION',
    action: action
  });
}

module.exports = AppDispatcher;

},{"flux":"/Users/Jacob/workspace/scheduler/front-end/node_modules/flux/index.js"}],"/Users/Jacob/workspace/scheduler/front-end/src/js/assets/calendarConversions.js":[function(require,module,exports){
var monthConversion = {
  Jan : [1, 'January'],
  Feb : [2, 'February'],
  Mar : [3, 'March'],
  Apr : [4, 'April'],
  May : [5, 'March'],
  Jun : [6, 'June'],
  Jul : [7, 'July'],
  Aug : [8, 'August'],
  Sep : [9, 'September'],
  Oct : [10, 'October'],
  Nov : [11, 'November'],
  Dec : [12, 'December'],
  1 : 'Jan',
  2 : 'Feb',
  3 : 'Mar',
  4 : 'Apr',
  5 : 'May',
  6 : 'Jun',
  7 : 'Jul',
  8 : 'Aug',
  9 : 'Sep',
  10 : 'Oct',
  11 : 'Nov',
  12 : 'Dec'
}

var monthAnimation = function () {
  var mon = document.getElementsByClassName('monthGrid')[0].classList;
  mon.add('animated', 'zoomIn');
  setTimeout(function(){ mon.remove('animated', 'zoomIn') }, 1000);
}

module.exports = {
  monthConversion: monthConversion,
  monthAnimation: monthAnimation
}

},{}],"/Users/Jacob/workspace/scheduler/front-end/src/js/components/Day.jsx":[function(require,module,exports){
var Day = React.createClass({displayName: "Day",
  render: function () {
    return (
      React.createElement("div", null, 
        
         this.props.currentMonth.items.events[parseInt(this.props.day)]
         ? this.props.currentMonth.items.events[parseInt(this.props.day)].map(function (evt) {
            return React.createElement("p", null, evt.time.start +" - "+ evt.time.end +' : '+ evt.title)
           })
         : null
        
      )
    )
  }
})

module.exports = Day;

},{}],"/Users/Jacob/workspace/scheduler/front-end/src/js/components/month.jsx":[function(require,module,exports){
var Day = require('./Day.jsx');

var Month = React.createClass({displayName: "Month",
  render: function () {
    var that = this;
    return (
      React.createElement("section", null, 
        React.createElement("div", {className: "calendarHeader"}, 
          React.createElement("button", {className: "btn btn-primary", onClick: this.props.handlers.displayMonth}, "Back"), 
          React.createElement("div", {className: "monthName"}, 
            React.createElement("h1", null, this.props.currentMonth.name), 
            React.createElement("h4", null, this.props.currentMonth.year)
          ), 
          React.createElement("button", {className: "btn btn-primary", onClick: this.props.handlers.displayMonth}, "Forward")
        ), 
        React.createElement("table", {className: "monthGrid table-bordered"}, 
          React.createElement("thead", null, 
            React.createElement("tr", null, 
              React.createElement("th", null, "Sunday"), " ", React.createElement("th", null, "Monday"), " ", React.createElement("th", null, "Tuesday"), " ", React.createElement("th", null, "Wednesday"), " ", React.createElement("th", null, "Thursday"), " ", React.createElement("th", null, "Friday"), " ", React.createElement("th", null, "Saturday")
            )
          ), 
          React.createElement("tbody", null, 
            this.props.currentMonth.monthMatrix.map(function(week) {
              return (
                React.createElement("tr", {key: week}, 
                  week.map(function(day, i) {
                    return day == parseInt(this.props.currentMonth.selectedDay)
                      ? React.createElement("td", {className: "selectedDay", key: i}, React.createElement(Day, {day: day, currentMonth: this.props.currentMonth}), React.createElement("span", null, day))
                    : React.createElement("td", {onClick: this.props.handlers.selectedDay, key: i}, React.createElement(Day, {day: day, currentMonth: this.props.currentMonth}), React.createElement("span", null, day))
                  },this)
                )
              );
            },this)
          )
        )
      )
    );
  }
})

module.exports = Month;

},{"./Day.jsx":"/Users/Jacob/workspace/scheduler/front-end/src/js/components/Day.jsx"}],"/Users/Jacob/workspace/scheduler/front-end/src/js/components/planner.jsx":[function(require,module,exports){
var Month = require('./month.jsx');
var SelectedDay = require('./selectedDay.jsx');
var TaskManager = require('./taskManager.jsx');
var plannerStore = require('../stores/plannerStore.js');
var plannerActions = require('../Action.js');
var monthAnimation = require('../assets/calendarConversions').monthAnimation;

var Planner = React.createClass({displayName: "Planner",

  getInitialState: function () {
    var now = new Date().toString().split(' ');
    plannerActions.newMonth([now[1], now[3], now[2]]);
    return {
      currentMonth: plannerStore.getCurrentMonth(),
    }
  },
  componentDidMount: function () {
    plannerStore.addChangeListener(this._onChange);
  },
  componentWillUnmount: function () {
    plannerStore.removeChangeListener(this._onChange);
  },
  handlers: {
    selectedDay:  function (e) {
      plannerActions.selectedDay(e.target.childNodes[1].innerHTML);
    },
    displayMonth: function (e) {
      monthAnimation();
      e.target.innerHTML == 'Forward' ? plannerActions.findMonth(true) : plannerActions.findMonth(false);
    },
    addEvents: function (e) {
      plannerActions.addEvents(e);
    }
  },
  _onChange: function () {
    this.setState({
      currentMonth: plannerStore.getCurrentMonth()
    })
  },
  render: function() {
    return (
      React.createElement("div", {className: "animated zoomIn container-fluid"}, 
        React.createElement("div", {className: "row text-center"}, 
          React.createElement("div", {className: "col-md-8"}, 
            React.createElement(Month, {currentMonth: this.state.currentMonth, handlers: this.handlers})
          ), 
          React.createElement("div", {className: "col-md-4"}, 
            React.createElement(TaskManager, {currentMonth: this.state.currentMonth, addEvents: this.handlers.addEvents})
          )
        )
      )
    );
  }

});


React.render(React.createElement(Planner, null), document.getElementById('app'));

},{"../Action.js":"/Users/Jacob/workspace/scheduler/front-end/src/js/Action.js","../assets/calendarConversions":"/Users/Jacob/workspace/scheduler/front-end/src/js/assets/calendarConversions.js","../stores/plannerStore.js":"/Users/Jacob/workspace/scheduler/front-end/src/js/stores/plannerStore.js","./month.jsx":"/Users/Jacob/workspace/scheduler/front-end/src/js/components/month.jsx","./selectedDay.jsx":"/Users/Jacob/workspace/scheduler/front-end/src/js/components/selectedDay.jsx","./taskManager.jsx":"/Users/Jacob/workspace/scheduler/front-end/src/js/components/taskManager.jsx"}],"/Users/Jacob/workspace/scheduler/front-end/src/js/components/selectedDay.jsx":[function(require,module,exports){
var SelectedDay = React.createClass ({displayName: "SelectedDay",
  handleSubmit: function () {
    var form = document.getElementsByName('newEvent');
    this.props.addEvents({
      day: this.props.currentMonth.selectedDay, time: {start: form[1].value, end: form[2].value}, title: form[0].value, description: form[3].value
    });
    for (var i = 0; i < form.length; i++) {
      form[i].value = null;
    }
  },
  render: function () {
    return (
      React.createElement("div", {className: "animated zoomIn selectedDayHeader"}, 
        React.createElement("h4", null, "Add Event"), 
        React.createElement("form", null, 
          React.createElement("input", {type: "text", placeholder: "Title", name: "newEvent"}), 
          React.createElement("input", {type: "time", placeholder: "Start", name: "newEvent"}), 
          React.createElement("input", {type: "time", placeholder: "End", name: "newEvent"}), 
          React.createElement("textarea", {defaultValue: "Description", name: "newEvent"}), 
          React.createElement("span", {className: "glyphicon glyphicon-plus-sign", onClick: this.handleSubmit})
        )
      )
    )
  }

})

module.exports = SelectedDay

},{}],"/Users/Jacob/workspace/scheduler/front-end/src/js/components/taskManager.jsx":[function(require,module,exports){
var SelectedDay = require('./selectedDay.jsx')

var TaskManager = React.createClass({displayName: "TaskManager",

  getInitialState: function () {
    return {
      dateToggle: true,
      eventsToggle: false,
      toDoToggle: false
    }
  },
  handlers: {
    dateToggle: function () {
      this.setState({
        dateToggle: this.state.dateToggle ? this.state.dateToggle = false : this.state.dateToggle = true
      })
    },
    eventsToggle: function (e) {

    },
    toDoToggle: function (e) {

    }
  },
  render: function () {
    return (
      React.createElement("section", null, 
        React.createElement("h1", {className: "taskHeader"}, "Task Manager"), 
        React.createElement("div", {className: "taskContainer"}, 
          React.createElement("div", {className: "taskSection"}, 
            React.createElement("div", {onClick: this.handlers.dateToggle.bind(this)}, 
              React.createElement("span", {className: "taskIcon glyphicon glyphicon-triangle-" + (this.state.dateToggle ? "bottom" : "right")}), 
              React.createElement("h3", null, this.props.currentMonth.name +" "+ this.props.currentMonth.selectedDay +", "+ this.props.currentMonth.year)
            ), 
            this.state.dateToggle ? React.createElement(SelectedDay, {currentMonth: this.props.currentMonth, addEvents: this.props.addEvents}) : null
          ), 
          React.createElement("div", {className: "taskSection"}, 
            React.createElement("span", {className: "taskIcon glyphicon glyphicon-triangle-right"}), 
            React.createElement("h3", null, "Events")
          ), 
          React.createElement("div", {className: "taskSection"}, 
            React.createElement("span", {className: "taskIcon glyphicon glyphicon-triangle-right"}), 
            React.createElement("h3", null, "ToDo's")
          )
        )
      )
    )
  }
})

module.exports = TaskManager;

},{"./selectedDay.jsx":"/Users/Jacob/workspace/scheduler/front-end/src/js/components/selectedDay.jsx"}],"/Users/Jacob/workspace/scheduler/front-end/src/js/stores/plannerStore.js":[function(require,module,exports){
var AppDispatcher = require('../Dispatcher.js');
var appConstants = require('../Constants.js');
var objectAssign = require('react/lib/Object.assign');
var EventEmitter = require('events').EventEmitter;
var calendar = require('node-calendar');
var monthConversion = require('../assets/calendarConversions').monthConversion;

var CHANGE_EVENT = 'change';

var years = {};
var current = {};

function Month(date) {
  this.name = monthConversion[date[0]][1];
  this.monthKey = monthConversion[date[0]][0];
  this.year = parseInt(date[1]);
  this.monthMatrix = date;
  this.selectedDay = date[2] || 1;
  this.items = {
    events: {},
    todos: {}
  };
}

Month.prototype.newMonth = function () {
  this.monthMatrix = new calendar.Calendar(calendar.SUNDAY).monthdayscalendar(this.monthMatrix[1], monthConversion[this.monthMatrix[0]][0]);
};

var newMonth = function (date) {
  current = new Month(date);
  current.newMonth();
  years[current.year] ? years[current.year].push(current) : years[current.year] = [current];
}

var findMonth = function (direction) {
  if(direction)
    current.monthKey +1 < 13 ? newCurrent = [current.monthKey +1, current.year] : newCurrent = [1, current.year +1];
  else
    current.monthKey -1 > 0 ? newCurrent = [current.monthKey -1, current.year] : newCurrent = [12, current.year -1];
  if(years[newCurrent[1]]){
    var checker = years[newCurrent[1]].filter(function (mon) {
      if(mon.monthKey === newCurrent[0])
        return mon;
    })
    checker.length > 0 ? current = checker[0] : newMonth([monthConversion[newCurrent[0]], newCurrent[1]]);
  } else {
    newMonth([monthConversion[newCurrent[0]], newCurrent[1]]);
  }
}

var selectedDay = function (dayNum) {
  current.selectedDay = dayNum;
}

var addEvents = function (evt) {
  current.items.events[evt.day] ? current.items.events[evt.day].push(evt) : current.items.events[evt.day] = [evt];
}

var plannerStore = objectAssign({}, EventEmitter.prototype, {
  addChangeListener: function (cb) {
    this.on(CHANGE_EVENT, cb);
  },
  removeChangeListener: function (cb) {
    this.removeListener(CHANGE_EVENT, cb);
  },
  getCurrentMonth: function () {
    console.log(years, current);
    return current;
  }
});

AppDispatcher.register(function (payload) {
  var action = payload.action;
  switch(action.actionType){
    case appConstants.NEW_MONTH:
      newMonth(action.data);
      plannerStore.emit(CHANGE_EVENT);
      break;
    case appConstants.FIND_MONTH:
      findMonth(action.data);
      plannerStore.emit(CHANGE_EVENT);
      break;
    case appConstants.SELECTED_DAY:
      selectedDay(action.data);
      plannerStore.emit(CHANGE_EVENT);
      break;
    case appConstants.ADD_EVENTS:
      addEvents(action.data);
      plannerStore.emit(CHANGE_EVENT);
    default:
      return true;
  }
});

module.exports = plannerStore;

},{"../Constants.js":"/Users/Jacob/workspace/scheduler/front-end/src/js/Constants.js","../Dispatcher.js":"/Users/Jacob/workspace/scheduler/front-end/src/js/Dispatcher.js","../assets/calendarConversions":"/Users/Jacob/workspace/scheduler/front-end/src/js/assets/calendarConversions.js","events":"/Users/Jacob/workspace/scheduler/front-end/node_modules/events/events.js","node-calendar":"/Users/Jacob/workspace/scheduler/front-end/node_modules/node-calendar/node-calendar.js","react/lib/Object.assign":"/Users/Jacob/workspace/scheduler/front-end/node_modules/react/lib/Object.assign.js"}]},{},["/Users/Jacob/workspace/scheduler/front-end/src/js/components/planner.jsx"])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvY2xkci9saWIvQ2xkclBsdXJhbFJ1bGUuanMiLCJub2RlX21vZHVsZXMvY2xkci9saWIvQ2xkclBsdXJhbFJ1bGVTZXQuanMiLCJub2RlX21vZHVsZXMvY2xkci9saWIvQ2xkclJibmZSdWxlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbGliL2NsZHIuanMiLCJub2RlX21vZHVsZXMvY2xkci9saWIvY2xkclBsdXJhbFJ1bGVUZXJtRnVuY3Rpb25CeU5hbWUuanMiLCJub2RlX21vZHVsZXMvY2xkci9saWIvY29udmVydE9iamVjdHNXaXRoSW50ZWdlcktleXNUb0FycmF5cy5qcyIsIm5vZGVfbW9kdWxlcy9jbGRyL2xpYi9tZW1vaXplQXN5bmMuanMiLCJub2RlX21vZHVsZXMvY2xkci9saWIvbm9ybWFsaXplTG9jYWxlSWQuanMiLCJub2RlX21vZHVsZXMvY2xkci9saWIvbm9ybWFsaXplUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY2xkci9ub2RlX21vZHVsZXMvcGFzc2Vycm9yL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jbGRyL25vZGVfbW9kdWxlcy9wZWdqcy9saWIvcGVnLmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3NlcS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jbGRyL25vZGVfbW9kdWxlcy9zZXEvbm9kZV9tb2R1bGVzL2NoYWluc2F3L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3NlcS9ub2RlX21vZHVsZXMvY2hhaW5zYXcvbm9kZV9tb2R1bGVzL3RyYXZlcnNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3NlcS9ub2RlX21vZHVsZXMvaGFzaGlzaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jbGRyL25vZGVfbW9kdWxlcy9zZXEvbm9kZV9tb2R1bGVzL2hhc2hpc2gvbm9kZV9tb2R1bGVzL3RyYXZlcnNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9saWIvY29uc29saWRhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9saWIvcGFyc2UtanMuanMiLCJub2RlX21vZHVsZXMvY2xkci9ub2RlX21vZHVsZXMvdWdsaWZ5LWpzL2xpYi9wcm9jZXNzLmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9saWIvc3F1ZWV6ZS1tb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy91Z2xpZnktanMuanMiLCJub2RlX21vZHVsZXMvY2xkci9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3VuaWNvZGVyZWdleHAvbGliL3VuaWNvZGVSZWdFeHAuanMiLCJub2RlX21vZHVsZXMvY2xkci9ub2RlX21vZHVsZXMveG1sZG9tL2RvbS1wYXJzZXIuanMiLCJub2RlX21vZHVsZXMvY2xkci9ub2RlX21vZHVsZXMveG1sZG9tL2RvbS5qcyIsIm5vZGVfbW9kdWxlcy9jbGRyL25vZGVfbW9kdWxlcy94bWxkb20vc2F4LmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3hwYXRoL3hwYXRoLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvZmx1eC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mbHV4L2xpYi9EaXNwYXRjaGVyLmpzIiwibm9kZV9tb2R1bGVzL2ZsdXgvbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWNhbGVuZGFyL25vZGUtY2FsZW5kYXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL09iamVjdC5hc3NpZ24uanMiLCIvVXNlcnMvSmFjb2Ivd29ya3NwYWNlL3NjaGVkdWxlci9mcm9udC1lbmQvc3JjL2pzL0FjdGlvbi5qcyIsIi9Vc2Vycy9KYWNvYi93b3Jrc3BhY2Uvc2NoZWR1bGVyL2Zyb250LWVuZC9zcmMvanMvQ29uc3RhbnRzLmpzIiwiL1VzZXJzL0phY29iL3dvcmtzcGFjZS9zY2hlZHVsZXIvZnJvbnQtZW5kL3NyYy9qcy9EaXNwYXRjaGVyLmpzIiwiL1VzZXJzL0phY29iL3dvcmtzcGFjZS9zY2hlZHVsZXIvZnJvbnQtZW5kL3NyYy9qcy9hc3NldHMvY2FsZW5kYXJDb252ZXJzaW9ucy5qcyIsIi9Vc2Vycy9KYWNvYi93b3Jrc3BhY2Uvc2NoZWR1bGVyL2Zyb250LWVuZC9zcmMvanMvY29tcG9uZW50cy9EYXkuanN4IiwiL1VzZXJzL0phY29iL3dvcmtzcGFjZS9zY2hlZHVsZXIvZnJvbnQtZW5kL3NyYy9qcy9jb21wb25lbnRzL21vbnRoLmpzeCIsIi9Vc2Vycy9KYWNvYi93b3Jrc3BhY2Uvc2NoZWR1bGVyL2Zyb250LWVuZC9zcmMvanMvY29tcG9uZW50cy9wbGFubmVyLmpzeCIsIi9Vc2Vycy9KYWNvYi93b3Jrc3BhY2Uvc2NoZWR1bGVyL2Zyb250LWVuZC9zcmMvanMvY29tcG9uZW50cy9zZWxlY3RlZERheS5qc3giLCIvVXNlcnMvSmFjb2Ivd29ya3NwYWNlL3NjaGVkdWxlci9mcm9udC1lbmQvc3JjL2pzL2NvbXBvbmVudHMvdGFza01hbmFnZXIuanN4IiwiL1VzZXJzL0phY29iL3dvcmtzcGFjZS9zY2hlZHVsZXIvZnJvbnQtZW5kL3NyYy9qcy9zdG9yZXMvcGxhbm5lclN0b3JlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5MkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaDdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcHNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4MUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGtFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25pQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbG5DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ252SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQSxJQUFJLGFBQWEsR0FBRyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQztBQUMvQyxJQUFJLFlBQVksR0FBRyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQzs7QUFFN0MsSUFBSSxjQUFjLEdBQUc7RUFDbkIsUUFBUSxFQUFFLFVBQVUsSUFBSSxFQUFFO0lBQ3hCLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQztNQUM3QixVQUFVLEVBQUUsWUFBWSxDQUFDLFNBQVM7TUFDbEMsSUFBSSxFQUFFLElBQUk7S0FDWCxDQUFDLENBQUM7R0FDSjtFQUNELFNBQVMsRUFBRSxVQUFVLFNBQVMsRUFBRTtJQUM5QixhQUFhLENBQUMsZ0JBQWdCLENBQUM7TUFDN0IsVUFBVSxFQUFFLFlBQVksQ0FBQyxVQUFVO01BQ25DLElBQUksRUFBRSxTQUFTO0tBQ2hCLENBQUMsQ0FBQztHQUNKO0VBQ0QsV0FBVyxFQUFFLFVBQVUsTUFBTSxFQUFFO0lBQzdCLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQztNQUM3QixVQUFVLEVBQUUsWUFBWSxDQUFDLFlBQVk7TUFDckMsSUFBSSxFQUFFLE1BQU07S0FDYixDQUFDLENBQUM7R0FDSjtFQUNELFNBQVMsRUFBRSxVQUFVLEdBQUcsRUFBRTtJQUN4QixhQUFhLENBQUMsZ0JBQWdCLENBQUM7TUFDN0IsVUFBVSxFQUFFLFlBQVksQ0FBQyxVQUFVO01BQ25DLElBQUksRUFBRSxHQUFHO0tBQ1YsQ0FBQyxDQUFDO0dBQ0o7QUFDSCxDQUFDLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxjQUFjLENBQUM7OztBQzlCaEMsSUFBSSxZQUFZLEdBQUc7RUFDakIsU0FBUyxFQUFFLFdBQVc7RUFDdEIsVUFBVSxFQUFFLFlBQVk7RUFDeEIsWUFBWSxFQUFFLGNBQWM7RUFDNUIsVUFBVSxFQUFFLFlBQVk7QUFDMUIsQ0FBQyxDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsWUFBWSxDQUFDOzs7QUNQOUIsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFVBQVUsQ0FBQztBQUM1QyxJQUFJLGFBQWEsR0FBRyxJQUFJLFVBQVUsRUFBRSxDQUFDOztBQUVyQyxhQUFhLENBQUMsZ0JBQWdCLEdBQUcsU0FBUyxNQUFNLEVBQUU7RUFDaEQsSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUNaLE1BQU0sRUFBRSxhQUFhO0lBQ3JCLE1BQU0sRUFBRSxNQUFNO0dBQ2YsQ0FBQyxDQUFDO0FBQ0wsQ0FBQzs7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLGFBQWEsQ0FBQzs7O0FDVi9CLElBQUksZUFBZSxHQUFHO0VBQ3BCLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUM7RUFDcEIsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQztFQUNyQixHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDO0VBQ2xCLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUM7RUFDbEIsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQztFQUNsQixHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDO0VBQ2pCLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUM7RUFDakIsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQztFQUNuQixHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsV0FBVyxDQUFDO0VBQ3RCLEdBQUcsR0FBRyxDQUFDLEVBQUUsRUFBRSxTQUFTLENBQUM7RUFDckIsR0FBRyxHQUFHLENBQUMsRUFBRSxFQUFFLFVBQVUsQ0FBQztFQUN0QixHQUFHLEdBQUcsQ0FBQyxFQUFFLEVBQUUsVUFBVSxDQUFDO0VBQ3RCLENBQUMsR0FBRyxLQUFLO0VBQ1QsQ0FBQyxHQUFHLEtBQUs7RUFDVCxDQUFDLEdBQUcsS0FBSztFQUNULENBQUMsR0FBRyxLQUFLO0VBQ1QsQ0FBQyxHQUFHLEtBQUs7RUFDVCxDQUFDLEdBQUcsS0FBSztFQUNULENBQUMsR0FBRyxLQUFLO0VBQ1QsQ0FBQyxHQUFHLEtBQUs7RUFDVCxDQUFDLEdBQUcsS0FBSztFQUNULEVBQUUsR0FBRyxLQUFLO0VBQ1YsRUFBRSxHQUFHLEtBQUs7RUFDVixFQUFFLEdBQUcsS0FBSztBQUNaLENBQUM7O0FBRUQsSUFBSSxjQUFjLEdBQUcsWUFBWTtFQUMvQixJQUFJLEdBQUcsR0FBRyxRQUFRLENBQUMsc0JBQXNCLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0VBQ3BFLEdBQUcsQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0VBQzlCLFVBQVUsQ0FBQyxVQUFVLEVBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ25FLENBQUM7O0FBRUQsTUFBTSxDQUFDLE9BQU8sR0FBRztFQUNmLGVBQWUsRUFBRSxlQUFlO0VBQ2hDLGNBQWMsRUFBRSxjQUFjO0NBQy9COzs7QUNwQ0QsSUFBSSx5QkFBeUIsbUJBQUE7RUFDM0IsTUFBTSxFQUFFLFlBQVk7SUFDbEI7TUFDRSxvQkFBQSxLQUFJLEVBQUEsSUFBQyxFQUFBO1FBQ0Y7U0FDQSxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1dBQzVELElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBVSxHQUFHLEVBQUU7WUFDakYsT0FBTyxvQkFBQSxHQUFFLEVBQUEsSUFBQyxFQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsR0FBRyxDQUFDLEtBQVUsQ0FBQTtZQUNyRSxDQUFDO1dBQ0YsSUFBSTtRQUNOO01BQ0csQ0FBQTtLQUNQO0dBQ0Y7QUFDSCxDQUFDLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUM7OztBQ2hCckIsSUFBSSxHQUFHLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDOztBQUUvQixJQUFJLDJCQUEyQixxQkFBQTtFQUM3QixNQUFNLEVBQUUsWUFBWTtJQUNsQixJQUFJLElBQUksR0FBRyxJQUFJLENBQUM7SUFDaEI7TUFDRSxvQkFBQSxTQUFRLEVBQUEsSUFBQyxFQUFBO1FBQ1Asb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxnQkFBaUIsQ0FBQSxFQUFBO1VBQzlCLG9CQUFBLFFBQU8sRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsaUJBQUEsRUFBaUIsQ0FBQyxPQUFBLEVBQU8sQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxZQUFjLENBQUEsRUFBQSxNQUFhLENBQUEsRUFBQTtVQUM1RixvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLFdBQVksQ0FBQSxFQUFBO1lBQ3pCLG9CQUFBLElBQUcsRUFBQSxJQUFDLEVBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsSUFBVSxDQUFBLEVBQUE7WUFDdkMsb0JBQUEsSUFBRyxFQUFBLElBQUMsRUFBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxJQUFVLENBQUE7VUFDbkMsQ0FBQSxFQUFBO1VBQ04sb0JBQUEsUUFBTyxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxpQkFBQSxFQUFpQixDQUFDLE9BQUEsRUFBTyxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFlBQWMsQ0FBQSxFQUFBLFNBQWdCLENBQUE7UUFDM0YsQ0FBQSxFQUFBO1FBQ04sb0JBQUEsT0FBTSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQywwQkFBMkIsQ0FBQSxFQUFBO1VBQzFDLG9CQUFBLE9BQU0sRUFBQSxJQUFDLEVBQUE7WUFDTCxvQkFBQSxJQUFHLEVBQUEsSUFBQyxFQUFBO2NBQ0Ysb0JBQUEsSUFBRyxFQUFBLElBQUMsRUFBQSxRQUFXLENBQUEsRUFBQSxHQUFBLEVBQUMsb0JBQUEsSUFBRyxFQUFBLElBQUMsRUFBQSxRQUFXLENBQUEsRUFBQSxHQUFBLEVBQUMsb0JBQUEsSUFBRyxFQUFBLElBQUMsRUFBQSxTQUFZLENBQUEsRUFBQSxHQUFBLEVBQUMsb0JBQUEsSUFBRyxFQUFBLElBQUMsRUFBQSxXQUFjLENBQUEsRUFBQSxHQUFBLEVBQUMsb0JBQUEsSUFBRyxFQUFBLElBQUMsRUFBQSxVQUFhLENBQUEsRUFBQSxHQUFBLEVBQUMsb0JBQUEsSUFBRyxFQUFBLElBQUMsRUFBQSxRQUFXLENBQUEsRUFBQSxHQUFBLEVBQUMsb0JBQUEsSUFBRyxFQUFBLElBQUMsRUFBQSxVQUFhLENBQUE7WUFDcEgsQ0FBQTtVQUNDLENBQUEsRUFBQTtVQUNSLG9CQUFBLE9BQU0sRUFBQSxJQUFDLEVBQUE7WUFDSixJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLFNBQVMsSUFBSSxFQUFFO2NBQ3REO2dCQUNFLG9CQUFBLElBQUcsRUFBQSxDQUFBLENBQUMsR0FBQSxFQUFHLENBQUUsSUFBTSxDQUFBLEVBQUE7a0JBQ1osSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDLEVBQUU7b0JBQ3pCLE9BQU8sR0FBRyxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUM7d0JBQ3ZELG9CQUFBLElBQUcsRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsYUFBQSxFQUFhLENBQUMsR0FBQSxFQUFHLENBQUUsQ0FBRyxDQUFBLEVBQUEsb0JBQUMsR0FBRyxFQUFBLENBQUEsQ0FBQyxHQUFBLEVBQUcsQ0FBRSxHQUFHLEVBQUMsQ0FBQyxZQUFBLEVBQVksQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQWEsQ0FBQSxDQUFHLENBQUEsRUFBQSxvQkFBQSxNQUFLLEVBQUEsSUFBQyxFQUFDLEdBQVcsQ0FBSyxDQUFBO3NCQUNySCxvQkFBQSxJQUFHLEVBQUEsQ0FBQSxDQUFDLE9BQUEsRUFBTyxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBQyxDQUFDLEdBQUEsRUFBRyxDQUFFLENBQUcsQ0FBQSxFQUFBLG9CQUFDLEdBQUcsRUFBQSxDQUFBLENBQUMsR0FBQSxFQUFHLENBQUUsR0FBRyxFQUFDLENBQUMsWUFBQSxFQUFZLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFhLENBQUEsQ0FBRyxDQUFBLEVBQUEsb0JBQUEsTUFBSyxFQUFBLElBQUMsRUFBQyxHQUFXLENBQUssQ0FBQTttQkFDeEksQ0FBQyxJQUFJLENBQUU7Z0JBQ0wsQ0FBQTtnQkFDTDthQUNILENBQUMsSUFBSSxDQUFFO1VBQ0YsQ0FBQTtRQUNGLENBQUE7TUFDQSxDQUFBO01BQ1Y7R0FDSDtBQUNILENBQUMsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQzs7O0FDeEN2QixJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDbkMsSUFBSSxXQUFXLEdBQUcsT0FBTyxDQUFDLG1CQUFtQixDQUFDLENBQUM7QUFDL0MsSUFBSSxXQUFXLEdBQUcsT0FBTyxDQUFDLG1CQUFtQixDQUFDLENBQUM7QUFDL0MsSUFBSSxZQUFZLEdBQUcsT0FBTyxDQUFDLDJCQUEyQixDQUFDLENBQUM7QUFDeEQsSUFBSSxjQUFjLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQzdDLElBQUksY0FBYyxHQUFHLE9BQU8sQ0FBQywrQkFBK0IsQ0FBQyxDQUFDLGNBQWMsQ0FBQzs7QUFFN0UsSUFBSSw2QkFBNkIsdUJBQUE7O0VBRS9CLGVBQWUsRUFBRSxZQUFZO0lBQzNCLElBQUksR0FBRyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUMsUUFBUSxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzNDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbEQsT0FBTztNQUNMLFlBQVksRUFBRSxZQUFZLENBQUMsZUFBZSxFQUFFO0tBQzdDO0dBQ0Y7RUFDRCxpQkFBaUIsRUFBRSxZQUFZO0lBQzdCLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7R0FDaEQ7RUFDRCxvQkFBb0IsRUFBRSxZQUFZO0lBQ2hDLFlBQVksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7R0FDbkQ7RUFDRCxRQUFRLEVBQUU7SUFDUixXQUFXLEdBQUcsVUFBVSxDQUFDLEVBQUU7TUFDekIsY0FBYyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQztLQUM5RDtJQUNELFlBQVksRUFBRSxVQUFVLENBQUMsRUFBRTtNQUN6QixjQUFjLEVBQUUsQ0FBQztNQUNqQixDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsSUFBSSxTQUFTLEdBQUcsY0FBYyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxjQUFjLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ3BHO0lBQ0QsU0FBUyxFQUFFLFVBQVUsQ0FBQyxFQUFFO01BQ3RCLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDN0I7R0FDRjtFQUNELFNBQVMsRUFBRSxZQUFZO0lBQ3JCLElBQUksQ0FBQyxRQUFRLENBQUM7TUFDWixZQUFZLEVBQUUsWUFBWSxDQUFDLGVBQWUsRUFBRTtLQUM3QyxDQUFDO0dBQ0g7RUFDRCxNQUFNLEVBQUUsV0FBVztJQUNqQjtNQUNFLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsaUNBQWtDLENBQUEsRUFBQTtRQUMvQyxvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLGlCQUFrQixDQUFBLEVBQUE7VUFDL0Isb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxVQUFXLENBQUEsRUFBQTtZQUN4QixvQkFBQyxLQUFLLEVBQUEsQ0FBQSxDQUFDLFlBQUEsRUFBWSxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFDLENBQUMsUUFBQSxFQUFRLENBQUUsSUFBSSxDQUFDLFFBQVMsQ0FBQSxDQUFHLENBQUE7VUFDckUsQ0FBQSxFQUFBO1VBQ04sb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxVQUFXLENBQUEsRUFBQTtZQUN4QixvQkFBQyxXQUFXLEVBQUEsQ0FBQSxDQUFDLFlBQUEsRUFBWSxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFDLENBQUMsU0FBQSxFQUFTLENBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFVLENBQUEsQ0FBRyxDQUFBO1VBQ3RGLENBQUE7UUFDRixDQUFBO01BQ0YsQ0FBQTtNQUNOO0FBQ04sR0FBRzs7QUFFSCxDQUFDLENBQUMsQ0FBQztBQUNIOztBQUVBLEtBQUssQ0FBQyxNQUFNLENBQUMsb0JBQUMsT0FBTyxFQUFBLElBQUEsQ0FBRyxDQUFBLEVBQUUsUUFBUSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDOzs7QUN6RDFELElBQUksa0NBQWtDLDJCQUFBO0VBQ3BDLFlBQVksRUFBRSxZQUFZO0lBQ3hCLElBQUksSUFBSSxHQUFHLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNsRCxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQztNQUNuQixHQUFHLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsV0FBVyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLO0tBQzdJLENBQUMsQ0FBQztJQUNILEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO01BQ3BDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO0tBQ3RCO0dBQ0Y7RUFDRCxNQUFNLEVBQUUsWUFBWTtJQUNsQjtNQUNFLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsbUNBQW9DLENBQUEsRUFBQTtRQUNqRCxvQkFBQSxJQUFHLEVBQUEsSUFBQyxFQUFBLFdBQWMsQ0FBQSxFQUFBO1FBQ2xCLG9CQUFBLE1BQUssRUFBQSxJQUFDLEVBQUE7VUFDSixvQkFBQSxPQUFNLEVBQUEsQ0FBQSxDQUFDLElBQUEsRUFBSSxDQUFDLE1BQUEsRUFBTSxDQUFDLFdBQUEsRUFBVyxDQUFDLE9BQUEsRUFBTyxDQUFDLElBQUEsRUFBSSxDQUFDLFVBQVcsQ0FBUSxDQUFBLEVBQUE7VUFDL0Qsb0JBQUEsT0FBTSxFQUFBLENBQUEsQ0FBQyxJQUFBLEVBQUksQ0FBQyxNQUFBLEVBQU0sQ0FBQyxXQUFBLEVBQVcsQ0FBQyxPQUFBLEVBQU8sQ0FBQyxJQUFBLEVBQUksQ0FBQyxVQUFXLENBQVEsQ0FBQSxFQUFBO1VBQy9ELG9CQUFBLE9BQU0sRUFBQSxDQUFBLENBQUMsSUFBQSxFQUFJLENBQUMsTUFBQSxFQUFNLENBQUMsV0FBQSxFQUFXLENBQUMsS0FBQSxFQUFLLENBQUMsSUFBQSxFQUFJLENBQUMsVUFBVyxDQUFRLENBQUEsRUFBQTtVQUM3RCxvQkFBQSxVQUFTLEVBQUEsQ0FBQSxDQUFDLFlBQUEsRUFBWSxDQUFDLGFBQUEsRUFBYSxDQUFDLElBQUEsRUFBSSxDQUFDLFVBQVcsQ0FBVyxDQUFBLEVBQUE7VUFDaEUsb0JBQUEsTUFBSyxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQywrQkFBQSxFQUErQixDQUFDLE9BQUEsRUFBTyxDQUFFLElBQUksQ0FBQyxZQUFjLENBQU8sQ0FBQTtRQUM5RSxDQUFBO01BQ0gsQ0FBQTtLQUNQO0FBQ0wsR0FBRzs7QUFFSCxDQUFDLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxXQUFXOzs7QUMzQjVCLElBQUksV0FBVyxHQUFHLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQzs7QUFFOUMsSUFBSSxpQ0FBaUMsMkJBQUE7O0VBRW5DLGVBQWUsRUFBRSxZQUFZO0lBQzNCLE9BQU87TUFDTCxVQUFVLEVBQUUsSUFBSTtNQUNoQixZQUFZLEVBQUUsS0FBSztNQUNuQixVQUFVLEVBQUUsS0FBSztLQUNsQjtHQUNGO0VBQ0QsUUFBUSxFQUFFO0lBQ1IsVUFBVSxFQUFFLFlBQVk7TUFDdEIsSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUNaLFVBQVUsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsSUFBSTtPQUNqRyxDQUFDO0tBQ0g7QUFDTCxJQUFJLFlBQVksRUFBRSxVQUFVLENBQUMsRUFBRTs7S0FFMUI7QUFDTCxJQUFJLFVBQVUsRUFBRSxVQUFVLENBQUMsRUFBRTs7S0FFeEI7R0FDRjtFQUNELE1BQU0sRUFBRSxZQUFZO0lBQ2xCO01BQ0Usb0JBQUEsU0FBUSxFQUFBLElBQUMsRUFBQTtRQUNQLG9CQUFBLElBQUcsRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsWUFBYSxDQUFBLEVBQUEsY0FBaUIsQ0FBQSxFQUFBO1FBQzVDLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsZUFBZ0IsQ0FBQSxFQUFBO1VBQzdCLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsYUFBYyxDQUFBLEVBQUE7WUFDM0Isb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxPQUFBLEVBQU8sQ0FBRSxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFHLENBQUEsRUFBQTtjQUNqRCxvQkFBQSxNQUFLLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFFLHdDQUF3QyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLFFBQVEsR0FBRyxPQUFPLENBQUcsQ0FBTyxDQUFBLEVBQUE7Y0FDakgsb0JBQUEsSUFBRyxFQUFBLElBQUMsRUFBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsSUFBVSxDQUFBO1lBQ2pILENBQUEsRUFBQTtZQUNMLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLG9CQUFDLFdBQVcsRUFBQSxDQUFBLENBQUMsWUFBQSxFQUFZLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEVBQUMsQ0FBQyxTQUFBLEVBQVMsQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVUsQ0FBQSxDQUFHLENBQUEsR0FBRyxJQUFLO1VBQ3BILENBQUEsRUFBQTtVQUNOLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsYUFBYyxDQUFBLEVBQUE7WUFDM0Isb0JBQUEsTUFBSyxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyw2Q0FBOEMsQ0FBTyxDQUFBLEVBQUE7WUFDckUsb0JBQUEsSUFBRyxFQUFBLElBQUMsRUFBQSxRQUFXLENBQUE7VUFDWCxDQUFBLEVBQUE7VUFDTixvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLGFBQWMsQ0FBQSxFQUFBO1lBQzNCLG9CQUFBLE1BQUssRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsNkNBQThDLENBQU8sQ0FBQSxFQUFBO1lBQ3JFLG9CQUFBLElBQUcsRUFBQSxJQUFDLEVBQUEsUUFBVyxDQUFBO1VBQ1gsQ0FBQTtRQUNGLENBQUE7TUFDRSxDQUFBO0tBQ1g7R0FDRjtBQUNILENBQUMsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLFdBQVcsQ0FBQzs7O0FDbEQ3QixJQUFJLGFBQWEsR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUNoRCxJQUFJLFlBQVksR0FBRyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQztBQUM5QyxJQUFJLFlBQVksR0FBRyxPQUFPLENBQUMseUJBQXlCLENBQUMsQ0FBQztBQUN0RCxJQUFJLFlBQVksR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsWUFBWSxDQUFDO0FBQ2xELElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUN4QyxJQUFJLGVBQWUsR0FBRyxPQUFPLENBQUMsK0JBQStCLENBQUMsQ0FBQyxlQUFlLENBQUM7O0FBRS9FLElBQUksWUFBWSxHQUFHLFFBQVEsQ0FBQzs7QUFFNUIsSUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDO0FBQ2YsSUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDOztBQUVqQixTQUFTLEtBQUssQ0FBQyxJQUFJLEVBQUU7RUFDbkIsSUFBSSxDQUFDLElBQUksR0FBRyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDeEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDNUMsSUFBSSxDQUFDLElBQUksR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDOUIsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7RUFDeEIsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0VBQ2hDLElBQUksQ0FBQyxLQUFLLEdBQUc7SUFDWCxNQUFNLEVBQUUsRUFBRTtJQUNWLEtBQUssRUFBRSxFQUFFO0dBQ1YsQ0FBQztBQUNKLENBQUM7O0FBRUQsS0FBSyxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsWUFBWTtFQUNyQyxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksUUFBUSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxlQUFlLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDNUksQ0FBQyxDQUFDOztBQUVGLElBQUksUUFBUSxHQUFHLFVBQVUsSUFBSSxFQUFFO0VBQzdCLE9BQU8sR0FBRyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztFQUMxQixPQUFPLENBQUMsUUFBUSxFQUFFLENBQUM7RUFDbkIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDNUYsQ0FBQzs7QUFFRCxJQUFJLFNBQVMsR0FBRyxVQUFVLFNBQVMsRUFBRTtFQUNuQyxHQUFHLFNBQVM7QUFDZCxJQUFJLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxHQUFHLEVBQUUsR0FBRyxVQUFVLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsVUFBVSxHQUFHLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7O0lBRWhILE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxVQUFVLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsVUFBVSxHQUFHLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7RUFDbEgsR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEIsSUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEdBQUcsRUFBRTtNQUN2RCxHQUFHLEdBQUcsQ0FBQyxRQUFRLEtBQUssVUFBVSxDQUFDLENBQUMsQ0FBQztRQUMvQixPQUFPLEdBQUcsQ0FBQztLQUNkLENBQUM7SUFDRixPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsR0FBRyxPQUFPLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0dBQ3ZHLE1BQU07SUFDTCxRQUFRLENBQUMsQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUMzRDtBQUNILENBQUM7O0FBRUQsSUFBSSxXQUFXLEdBQUcsVUFBVSxNQUFNLEVBQUU7RUFDbEMsT0FBTyxDQUFDLFdBQVcsR0FBRyxNQUFNLENBQUM7QUFDL0IsQ0FBQzs7QUFFRCxJQUFJLFNBQVMsR0FBRyxVQUFVLEdBQUcsRUFBRTtFQUM3QixPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNsSCxDQUFDOztBQUVELElBQUksWUFBWSxHQUFHLFlBQVksQ0FBQyxFQUFFLEVBQUUsWUFBWSxDQUFDLFNBQVMsRUFBRTtFQUMxRCxpQkFBaUIsRUFBRSxVQUFVLEVBQUUsRUFBRTtJQUMvQixJQUFJLENBQUMsRUFBRSxDQUFDLFlBQVksRUFBRSxFQUFFLENBQUMsQ0FBQztHQUMzQjtFQUNELG9CQUFvQixFQUFFLFVBQVUsRUFBRSxFQUFFO0lBQ2xDLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0dBQ3ZDO0VBQ0QsZUFBZSxFQUFFLFlBQVk7SUFDM0IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDNUIsT0FBTyxPQUFPLENBQUM7R0FDaEI7QUFDSCxDQUFDLENBQUMsQ0FBQzs7QUFFSCxhQUFhLENBQUMsUUFBUSxDQUFDLFVBQVUsT0FBTyxFQUFFO0VBQ3hDLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUM7RUFDNUIsT0FBTyxNQUFNLENBQUMsVUFBVTtJQUN0QixLQUFLLFlBQVksQ0FBQyxTQUFTO01BQ3pCLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7TUFDdEIsWUFBWSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztNQUNoQyxNQUFNO0lBQ1IsS0FBSyxZQUFZLENBQUMsVUFBVTtNQUMxQixTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO01BQ3ZCLFlBQVksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7TUFDaEMsTUFBTTtJQUNSLEtBQUssWUFBWSxDQUFDLFlBQVk7TUFDNUIsV0FBVyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztNQUN6QixZQUFZLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO01BQ2hDLE1BQU07SUFDUixLQUFLLFlBQVksQ0FBQyxVQUFVO01BQzFCLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7TUFDdkIsWUFBWSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUNsQztNQUNFLE9BQU8sSUFBSSxDQUFDO0dBQ2Y7QUFDSCxDQUFDLENBQUMsQ0FBQzs7QUFFSCxNQUFNLENBQUMsT0FBTyxHQUFHLFlBQVksQ0FBQyIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLG51bGwsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJ2YXIgZnMgPSByZXF1aXJlKCdmcycpLFxuICAgIFBhdGggPSByZXF1aXJlKCdwYXRoJyksXG4gICAgUEVHID0gcmVxdWlyZSgncGVnanMnKSxcbiAgICBwYXJzZXIgPSBQRUcuYnVpbGRQYXJzZXIoZnMucmVhZEZpbGVTeW5jKFBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICdjbGRyUGx1cmFsUnVsZS5wZWdqcycpLCAndXRmLTgnKSk7XG5cbmZ1bmN0aW9uIHJhbmdlTGlzdFRvSmF2YVNjcmlwdEFzdChyYW5nZUxpc3ROb2RlLCBsaHNKYXZhU2NyaXB0QXN0LCB3aXRoaW5TZW1hbnRpY3MpIHtcbiAgICB2YXIgamF2YVNjcmlwdEFzdCxcbiAgICAgICAgc2VlblJhbmdlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IHJhbmdlTGlzdE5vZGUucmFuZ2VzLmxlbmd0aCAtIDEgOyBpID49IDAgOyBpIC09IDEpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gcmFuZ2VMaXN0Tm9kZS5yYW5nZXNbaV0sXG4gICAgICAgICAgICBpdGVtSmF2YVNjcmlwdEFzdDtcbiAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpdGVtSmF2YVNjcmlwdEFzdCA9IFsnYmluYXJ5JywgJz09PScsIGxoc0phdmFTY3JpcHRBc3QsIFsnbnVtJywgcmFuZ2UudmFsdWVdXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJhbmdlLnR5cGUgPT09ICdyYW5nZSdcbiAgICAgICAgICAgIHNlZW5SYW5nZSA9IHRydWU7XG4gICAgICAgICAgICBpdGVtSmF2YVNjcmlwdEFzdCA9IFsnYmluYXJ5JywgJyYmJywgWydiaW5hcnknLCAnPj0nLCBsaHNKYXZhU2NyaXB0QXN0LCBbJ251bScsIHJhbmdlLm1pbi52YWx1ZV1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsnYmluYXJ5JywgJzw9JywgbGhzSmF2YVNjcmlwdEFzdCwgWydudW0nLCByYW5nZS5tYXgudmFsdWVdXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGphdmFTY3JpcHRBc3QpIHtcbiAgICAgICAgICAgIGphdmFTY3JpcHRBc3QgPSBbJ2JpbmFyeScsICd8fCcsIGl0ZW1KYXZhU2NyaXB0QXN0LCBqYXZhU2NyaXB0QXN0XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGphdmFTY3JpcHRBc3QgPSBpdGVtSmF2YVNjcmlwdEFzdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VlblJhbmdlICYmICF3aXRoaW5TZW1hbnRpY3MpIHtcbiAgICAgICAgamF2YVNjcmlwdEFzdCA9IFsnYmluYXJ5JywgJyYmJywgWydiaW5hcnknLCAnPT09JywgbGhzSmF2YVNjcmlwdEFzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWydjYWxsJywgWydkb3QnLCBbJ25hbWUnLCAnTWF0aCddLCAnZmxvb3InXSwgW2xoc0phdmFTY3JpcHRBc3RdXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGphdmFTY3JpcHRBc3RdO1xuICAgIH1cbiAgICByZXR1cm4gamF2YVNjcmlwdEFzdDtcbn1cblxuZnVuY3Rpb24gbm9kZVRvSmF2YVNjcmlwdEFzdChub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gWydudW0nLCBub2RlLnZhbHVlXTtcbiAgICBjYXNlICduJzpcbiAgICBjYXNlICdpJzpcbiAgICBjYXNlICd2JzpcbiAgICBjYXNlICd3JzpcbiAgICBjYXNlICdmJzpcbiAgICBjYXNlICd0JzpcbiAgICAgICAgcmV0dXJuIFsnbmFtZScsIG5vZGUudHlwZV07XG4gICAgY2FzZSAnaXMnOlxuICAgICAgICByZXR1cm4gWydiaW5hcnknLCAnPT09J10uY29uY2F0KG5vZGUub3BlcmFuZHMubWFwKG5vZGVUb0phdmFTY3JpcHRBc3QpKTtcbiAgICBjYXNlICdpc25vdCc6XG4gICAgICAgIHJldHVybiBbJ2JpbmFyeScsICchPT0nXS5jb25jYXQobm9kZS5vcGVyYW5kcy5tYXAobm9kZVRvSmF2YVNjcmlwdEFzdCkpO1xuICAgIGNhc2UgJ21vZCc6XG4gICAgICAgIHJldHVybiBbJ2JpbmFyeScsICclJ10uY29uY2F0KG5vZGUub3BlcmFuZHMubWFwKG5vZGVUb0phdmFTY3JpcHRBc3QpKTtcbiAgICBjYXNlICdhbmQnOlxuICAgICAgICByZXR1cm4gWydiaW5hcnknLCAnJiYnXS5jb25jYXQobm9kZS5vcGVyYW5kcy5tYXAobm9kZVRvSmF2YVNjcmlwdEFzdCkpO1xuICAgIGNhc2UgJ29yJzpcbiAgICAgICAgcmV0dXJuIFsnYmluYXJ5JywgJ3x8J10uY29uY2F0KG5vZGUub3BlcmFuZHMubWFwKG5vZGVUb0phdmFTY3JpcHRBc3QpKTtcbiAgICBjYXNlICdub3QnOlxuICAgICAgICByZXR1cm4gWyd1bmFyeS1wcmVmaXgnLCAnIScsIG5vZGVUb0phdmFTY3JpcHRBc3Qobm9kZS5vcGVyYW5kcyldO1xuICAgIGNhc2UgJ2lzbm90JzpcbiAgICAgICAgcmV0dXJuIFsnYmluYXJ5JywgJyE9PSddLmNvbmNhdChub2RlLm9wZXJhbmRzLm1hcChub2RlVG9KYXZhU2NyaXB0QXN0KSk7XG4gICAgY2FzZSAnd2l0aGluJzpcbiAgICAgICAgcmV0dXJuIHJhbmdlTGlzdFRvSmF2YVNjcmlwdEFzdChub2RlLm9wZXJhbmRzWzFdLCBub2RlVG9KYXZhU2NyaXB0QXN0KG5vZGUub3BlcmFuZHNbMF0pLCB0cnVlKTtcbiAgICBjYXNlICdub3R3aXRoaW4nOlxuICAgICAgICByZXR1cm4gWyd1bmFyeS1wcmVmaXgnLCAnIScsIHJhbmdlTGlzdFRvSmF2YVNjcmlwdEFzdChub2RlLm9wZXJhbmRzWzFdLCBub2RlVG9KYXZhU2NyaXB0QXN0KG5vZGUub3BlcmFuZHNbMF0pLCB0cnVlKV07XG4gICAgY2FzZSAnaW4nOlxuICAgICAgICByZXR1cm4gcmFuZ2VMaXN0VG9KYXZhU2NyaXB0QXN0KG5vZGUub3BlcmFuZHNbMV0sIG5vZGVUb0phdmFTY3JpcHRBc3Qobm9kZS5vcGVyYW5kc1swXSksIGZhbHNlKTtcbiAgICBjYXNlICdub3Rpbic6XG4gICAgICAgIHJldHVybiBbJ3VuYXJ5LXByZWZpeCcsICchJywgcmFuZ2VMaXN0VG9KYXZhU2NyaXB0QXN0KG5vZGUub3BlcmFuZHNbMV0sIG5vZGVUb0phdmFTY3JpcHRBc3Qobm9kZS5vcGVyYW5kc1swXSksIGZhbHNlKV07XG4gICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub2RlVG9KYXZhU2NyaXB0QXN0OiBVbmtub3duIG5vZGUgdHlwZTogJyArIG5vZGUudHlwZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0cmF2ZXJzZShub2RlLCBsYW1iZGEpIHtcbiAgICBsYW1iZGEobm9kZSk7XG4gICAgaWYgKG5vZGUub3BlcmFuZHMpIHtcbiAgICAgICAgbm9kZS5vcGVyYW5kcy5mb3JFYWNoKGZ1bmN0aW9uIChvcGVyYW5kKSB7XG4gICAgICAgICAgICB0cmF2ZXJzZShvcGVyYW5kLCBsYW1iZGEpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIENsZHJQbHVyYWxSdWxlKHNyYykge1xuICAgIHRoaXMudG9wTGV2ZWxOb2RlID0gcGFyc2VyLnBhcnNlKHNyYy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJykucmVwbGFjZSgvXFxzezIsfS9nLCAnICcpKTtcbn1cblxuQ2xkclBsdXJhbFJ1bGUucHJvdG90eXBlID0ge1xuICAgIHRvSmF2YVNjcmlwdEFzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbm9kZVRvSmF2YVNjcmlwdEFzdCh0aGlzLnRvcExldmVsTm9kZSk7XG4gICAgfSxcblxuICAgIGVhY2hOb2RlOiBmdW5jdGlvbiAobGFtYmRhKSB7XG4gICAgICAgIHRyYXZlcnNlKHRoaXMudG9wTGV2ZWxOb2RlLCBsYW1iZGEpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVJc1VzZWRCeVRlcm06IGZ1bmN0aW9uIChpc1VzZWRCeVRlcm0pIHtcbiAgICAgICAgdGhpcy5lYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKFsnaScsICd2JywgJ3cnLCAnZicsICd0JywgJ24nXS5pbmRleE9mKG5vZGUudHlwZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaXNVc2VkQnlUZXJtW25vZGUudHlwZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGlzVXNlZEJ5VGVybTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsZHJQbHVyYWxSdWxlO1xuIiwidmFyIENsZHJQbHVyYWxSdWxlID0gcmVxdWlyZSgnLi9DbGRyUGx1cmFsUnVsZScpLFxuICAgIGNsZHJQbHVyYWxSdWxlVGVybUZ1bmN0aW9uQnlOYW1lID0gcmVxdWlyZSgnLi9jbGRyUGx1cmFsUnVsZVRlcm1GdW5jdGlvbkJ5TmFtZScpLFxuICAgIHVnbGlmeUpzID0gcmVxdWlyZSgndWdsaWZ5LWpzJyk7XG5cbmZ1bmN0aW9uIENsZHJQbHVyYWxSdWxlU2V0KCkge1xuICAgIHRoaXMuY2xkclBsdXJhbFJ1bGVCeUNvdW50ID0ge307XG59XG5cbkNsZHJQbHVyYWxSdWxlU2V0LnByb3RvdHlwZSA9IHtcbiAgICBhZGRSdWxlOiBmdW5jdGlvbiAoY2xkclBsdXJhbFJ1bGUsIGNvdW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xkclBsdXJhbFJ1bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjbGRyUGx1cmFsUnVsZSA9IGNsZHJQbHVyYWxSdWxlLnJlcGxhY2UoL1xccypAKD86ZGVjaW1hbHxpbnRlZ2VyKS4qJC8sICcnKTtcbiAgICAgICAgICAgIC8vIFNvbWUgY291bnQ9XCJvdGhlclwiIG5vZGVzIGluIENMRFIgMjQrIGNvbnNpc3QgcHVyZWx5IG9mIHNhbXBsZSB0ZXh0LlxuICAgICAgICAgICAgLy8gRG9uJ3QgYWRkIHRob3NlLlxuICAgICAgICAgICAgaWYgKGNsZHJQbHVyYWxSdWxlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZHJQbHVyYWxSdWxlID0gbmV3IENsZHJQbHVyYWxSdWxlKGNsZHJQbHVyYWxSdWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZHJQbHVyYWxSdWxlQnlDb3VudFtjb3VudF0gPSBjbGRyUGx1cmFsUnVsZTtcbiAgICB9LFxuXG4gICAgdG9KYXZhU2NyaXB0RnVuY3Rpb25Cb2R5QXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZW1lbnRBc3RzID0gW10sXG4gICAgICAgICAgICBpc1VzZWRCeVRlcm0gPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5jbGRyUGx1cmFsUnVsZUJ5Q291bnQpLmZvckVhY2goZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgICAgICAgICB2YXIgY2xkclBsdXJhbFJ1bGUgPSB0aGlzLmNsZHJQbHVyYWxSdWxlQnlDb3VudFtjb3VudF07XG4gICAgICAgICAgICBjbGRyUGx1cmFsUnVsZS51cGRhdGVJc1VzZWRCeVRlcm0oaXNVc2VkQnlUZXJtKTtcbiAgICAgICAgICAgIHN0YXRlbWVudEFzdHMucHVzaChcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICdpZicsXG4gICAgICAgICAgICAgICAgICAgIGNsZHJQbHVyYWxSdWxlLnRvSmF2YVNjcmlwdEFzdCgpLFxuICAgICAgICAgICAgICAgICAgICBbJ3JldHVybicsIFsnc3RyaW5nJywgY291bnRdXVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBzdGF0ZW1lbnRBc3RzLnB1c2goWydyZXR1cm4nLCBbJ3N0cmluZycsICdvdGhlciddXSk7XG4gICAgICAgIHZhciB2YXJBc3RzID0gW107XG5cbiAgICAgICAgWydpJywgJ3YnLCAndycsICdmJywgJ3QnXS5mb3JFYWNoKGZ1bmN0aW9uICh0ZXJtKSB7XG4gICAgICAgICAgICBpZiAoaXNVc2VkQnlUZXJtW3Rlcm1dKSB7XG4gICAgICAgICAgICAgICAgdmFyQXN0cy5wdXNoKFt0ZXJtLCB1Z2xpZnlKcy5wYXJzZXIucGFyc2UoY2xkclBsdXJhbFJ1bGVUZXJtRnVuY3Rpb25CeU5hbWVbdGVybV0udG9TdHJpbmcoKSlbMV1bMF1bM11bMF1bMV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGlzVXNlZEJ5VGVybSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRBc3RzLnVuc2hpZnQoXG4gICAgICAgICAgICAgICAgLy8gaWYgKHR5cGVvZiBuID09PSAnc3RyaW5nJykgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgICAgICAgICAgICAgICBbICdpZicsXG4gICAgICAgICAgICAgICAgICAgICAgWyAnYmluYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICc9PT0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgWyAndW5hcnktcHJlZml4JywgJ3R5cGVvZicsIFsgJ25hbWUnLCAnbicgXSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgWyAnc3RyaW5nJywgJ3N0cmluZycgXSBdLFxuICAgICAgICAgICAgICAgICAgICAgIFsgJ3N0YXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgWyAnYXNzaWduJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgWyAnbmFtZScsICduJyBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBbICdjYWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbICduYW1lJywgJ3BhcnNlSW50JyBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgWyAnbmFtZScsICduJyBdLCBbICdudW0nLCAxMCBdIF0gXSBdIF0sXG4gICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIF1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFyQXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRBc3RzLnVuc2hpZnQoWyd2YXInLCB2YXJBc3RzXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlbWVudEFzdHM7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGRyUGx1cmFsUnVsZVNldDtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG5mdW5jdGlvbiBDbGRyUmJuZlJ1bGVTZXQoY29uZmlnKSB7XG4gICAgXy5leHRlbmQodGhpcywgY29uZmlnKTtcbiAgICB0aGlzLnJ1bGVCeVZhbHVlID0ge307XG59XG5cbkNsZHJSYm5mUnVsZVNldC5nZXRTYWZlUmVuZGVyZXJOYW1lID0gZnVuY3Rpb24gKHJlbmRlcmVyTmFtZSkge1xuICAgIHJldHVybiAoXG4gICAgICAgIChcInJlbmRlci1cIiArIHJlbmRlcmVyTmFtZSlcbiAgICAgICAgLnJlcGxhY2UoL1teXFx3LV0vZywgJy0nKVxuICAgICAgICAucmVwbGFjZSgvWy1fXSsoWzAtOWEtel0pL2dpLCBmdW5jdGlvbiAoJDAsIGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2gudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnJlcGxhY2UoJ0dSRUVLTlVNRVJBTE1BSlVTQ1VMRVMnLCAnR3JlZWtOdW1lcmFsTWFqdXNjdWxlcycpXG4gICAgKTtcbn07XG5cbkNsZHJSYm5mUnVsZVNldC5wcm90b3R5cGUgPSB7XG4gICAgdG9GdW5jdGlvbkFzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICBpc1NlZW5CeVJ1bGVTZXRUeXBlID0ge307XG5cbiAgICAgICAgZnVuY3Rpb24gcnVsZVRvRXhwcmVzc2lvbkFzdChydWxlKSB7XG4gICAgICAgICAgICB2YXIgZXhwcmVzc2lvbkFzdHMgPSBbXSxcbiAgICAgICAgICAgICAgICByYm5mID0gcnVsZS5yYm5mO1xuXG4gICAgICAgICAgICAvLyBcIklmIGEgcnVsZSBib2R5IGJlZ2lucyB3aXRoIGFuIGFwb3N0cm9waGUsIHRoZSBhcG9zdHJvcGhlIGlzIGlnbm9yZWQsIGJ1dCBhbGwgdGV4dCBhZnRlciBpdCBiZWNvbWVzXG4gICAgICAgICAgICAvLyBzaWduaWZpY2FudCAodGhpcyBpcyBob3cgeW91IGNhbiBoYXZlIGEgcnVsZSdzIHJ1bGUgdGV4dCBiZWdpbiB3aXRoIHdoaXRlc3BhY2UpLlwiXG4gICAgICAgICAgICAvLyAtLSBodHRwOi8vd3d3LmljdS1wcm9qZWN0Lm9yZy9hcGlyZWYvaWN1NGMvY2xhc3NSdWxlQmFzZWROdW1iZXJGb3JtYXQuaHRtbFxuICAgICAgICAgICAgcmJuZiA9IHJibmYucmVwbGFjZSgvXicvLCAnJyk7XG5cbiAgICAgICAgICAgIHZhciByYWRpeCA9IHJ1bGUucmFkaXggfHwgMTA7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldERpdmlzb3IoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpdmlzb3IgPSAxO1xuICAgICAgICAgICAgICAgIHdoaWxlICgxMCAqIGRpdmlzb3IgPD0gcGFyc2VJbnQocnVsZS52YWx1ZSwgMTApKSB7IC8vIEluZWZmaWNpZW50LCBidXQgd29uJ3Qgc3VmZmVyIGZyb20gTWF0aC5sb2cgcm91bmRpbmcgZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgIGRpdmlzb3IgKj0gMTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkaXZpc29yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXBsYWNlIGlzIHVzZWQgZm9yIHRva2VuaXphdGlvbiwgdGhlIHJldHVybiB2YWx1ZSBpc24ndCB1c2VkOlxuICAgICAgICAgICAgcmJuZi5yZXBsYWNlKC8oPzooW1xcPFxcPlxcPV0pKD86KCUlP1tcXHdcXC1dKyl8KFsjLDAuXSspKT9cXDEpfCg/OlxcWyhbXlxcXV0rKVxcXSl8KFtcXHg3Zi1cXHVmZmZmOidcXC5cXHNcXHdcXGRcXC1dKykvZ2ksIGZ1bmN0aW9uICgkMCwgc3BlY2lhbENoYXIsIG90aGVyRm9ybWF0LCBkZWNpbWFsRm9ybWF0LCBvcHRpb25hbCwgbGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBtZWFuaW5ncyBvZiB0aGUgc3Vic3RpdHV0aW9uIHRva2VuIGNoYXJhY3RlcnMgYXJlIGFzIGZvbGxvd3M6XG4gICAgICAgICAgICAgICAgaWYgKHNwZWNpYWxDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHByO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BlY2lhbENoYXIgPT09ICc8JykgeyAvLyA8PFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QocnVsZS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBub3JtYWwgcnVsZTogRGl2aWRlIHRoZSBudW1iZXIgYnkgdGhlIHJ1bGUncyBkaXZpc29yIGFuZCBmb3JtYXQgdGhlIHF1b3RpZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IFsnY2FsbCcsIFsnZG90JywgWyduYW1lJywgJ01hdGgnXSwgJ2Zsb29yJ10sIFtbJ2JpbmFyeScsICcvJywgWyduYW1lJywgJ24nXSwgWydudW0nLCBnZXREaXZpc29yKCldXV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChydWxlLnZhbHVlID09PSAnLXgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCc8PCBub3QgYWxsb3dlZCBpbiBuZWdhdGl2ZSBudW1iZXIgcnVsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBmcmFjdGlvbiBvciBtYXN0ZXIgcnVsZTogSXNvbGF0ZSB0aGUgbnVtYmVyJ3MgaW50ZWdyYWwgcGFydCBhbmQgZm9ybWF0IGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSBbJ2NhbGwnLCBbJ2RvdCcsIFsnbmFtZScsICdNYXRoJ10sICdmbG9vciddLCBbWyduYW1lJywgJ24nXV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNpYWxDaGFyID09PSAnPicpIHsgLy8gPj5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXFwuLy50ZXN0KHJ1bGUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRnJhY3Rpb24gb3IgbWFzdGVyIHJ1bGUgPT4gcGFyc2VJbnQoU3RyaW5nKG4pLnJlcGxhY2UoL1xcZCpcXC4vLCAnJyksIDEwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSBbJ2NhbGwnLCBbJ25hbWUnLCAncGFyc2VJbnQnXSwgW1snY2FsbCcsIFsnZG90JywgWydjYWxsJywgWyduYW1lJywgJ1N0cmluZyddLCBbWyduYW1lJywgJ24nXV1dLCAncmVwbGFjZSddLCBbWydyZWdleHAnLCAnXFxcXGQqXFxcXC4nLCAnJ10sIFsnc3RyaW5nJywgJyddXV0sIFsnbnVtJywgMTBdXV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJ1bGUudmFsdWUgPT09ICcteCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gWyd1bmFyeS1wcmVmaXgnLCAnLScsIFsnbmFtZScsICduJ11dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gWydiaW5hcnknLCAnJScsIFsnbmFtZScsICduJ10sIFsnbnVtJywgZ2V0RGl2aXNvcigpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY2lhbENoYXIgPT09ICc9JykgeyAvLyA9PVxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IFsnbmFtZScsICduJ107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6ID4+PiBub3Qgc3VwcG9ydGVkXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHN1YnN0aXR1dGlvbiBkZXNjcmlwdG9yIChpLmUuLCB0aGUgdGV4dCBiZXR3ZWVuIHRoZSB0b2tlbiBjaGFyYWN0ZXJzKSBtYXkgdGFrZSBvbmUgb2YgdGhyZWUgZm9ybXM6XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckZvcm1hdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBydWxlIHNldCBuYW1lOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGVyZm9ybSB0aGUgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBvbiB0aGUgbnVtYmVyLCBhbmQgZm9ybWF0IHRoZSByZXN1bHQgdXNpbmcgdGhlIG5hbWVkIHJ1bGUgc2V0LlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyRm9ybWF0TmFtZSA9IENsZHJSYm5mUnVsZVNldC5nZXRTYWZlUmVuZGVyZXJOYW1lKG90aGVyRm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VlbkJ5UnVsZVNldFR5cGVbb3RoZXJGb3JtYXROYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUdXJuIGludG8gdGhpcy48b3RoZXJGb3JtYXROYW1lPig8ZXhwcj4pXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uQXN0cy5wdXNoKFsnY2FsbCcsIFsnZG90JywgWyduYW1lJywgJ3RoaXMnXSwgb3RoZXJGb3JtYXROYW1lXSwgW2V4cHJdXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVjaW1hbEZvcm1hdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBEZWNpbWFsRm9ybWF0IHBhdHRlcm46XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIHRoZSBtYXRoZW1hdGljYWwgb3BlcmF0aW9uIG9uIHRoZSBudW1iZXIsIGFuZCBmb3JtYXQgdGhlIHJlc3VsdCB1c2luZyBhIERlY2ltYWxGb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpdGggdGhlIHNwZWNpZmllZCBwYXR0ZXJuLiBUaGUgcGF0dGVybiBtdXN0IGJlZ2luIHdpdGggMCBvciAjLlxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbkFzdHMucHVzaChbJ2NhbGwnLCBbJ2RvdCcsIFsnbmFtZScsICd0aGlzJ10sICdyZW5kZXJOdW1iZXInXSwgW2V4cHIsIFsnc3RyaW5nJywgZGVjaW1hbEZvcm1hdF1dXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWNpYWxDaGFyID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB5b3Ugb21pdCB0aGUgc3Vic3RpdHV0aW9uIGRlc2NyaXB0b3IgaW4gYSA+PiBzdWJzdGl0dXRpb24gaW4gYSBmcmFjdGlvbiBydWxlLCBmb3JtYXQgdGhlIHJlc3VsdCBvbmUgZGlnaXQgYXQgYSB0aW1lIHVzaW5nIHRoZSBydWxlIHNldCBjb250YWluaW5nIHRoZSBjdXJyZW50IHJ1bGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbkFzdHMucHVzaChbJ2NhbGwnLCBbJ2RvdCcsIFsnbmFtZScsICd0aGlzJ10sIHRoYXQudHlwZV0sIFtleHByXV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzcGVjaWFsQ2hhciA9PT0gJzwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgeW91IG9taXQgdGhlIHN1YnN0aXR1dGlvbiBkZXNjcmlwdG9yIGluIGEgPDwgc3Vic3RpdHV0aW9uIGluIGEgcnVsZSBpbiBhIGZyYWN0aW9uIHJ1bGUgc2V0LCBmb3JtYXQgdGhlIHJlc3VsdCB1c2luZyB0aGUgZGVmYXVsdCBydWxlIHNldCBmb3IgdGhpcyByZW5kZXJlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogU2hvdWxkIGJlIHRoZSBkZWZhdWx0IHJ1bGUgc2V0IGZvciB0aGlzIHJlbmRlcmVyIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25Bc3RzLnB1c2goWydjYWxsJywgWydkb3QnLCBbJ25hbWUnLCAndGhpcyddLCB0aGF0LnR5cGVdLCBbZXhwcl1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCc9PSBub3Qgc3VwcG9ydGVkIScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbmFsKSB7IC8vIFsgLi4uIF1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbmFsUnVsZUV4cHJlc3Npb25Bc3QgPSBydWxlVG9FeHByZXNzaW9uQXN0KHtyYWRpeDogcnVsZS5yYWRpeCwgcmJuZjogb3B0aW9uYWwsIHZhbHVlOiBydWxlLnZhbHVlfSk7XG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25Bc3RzLnB1c2goWydjb25kaXRpb25hbCcsIFsnYmluYXJ5JywgJz09PScsIFsnbmFtZScsICduJ10sIFsnbnVtJywgcGFyc2VJbnQocnVsZS52YWx1ZSwgMTApXV0sIFsnc3RyaW5nJywgJyddLCBvcHRpb25hbFJ1bGVFeHByZXNzaW9uQXN0XSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25Bc3RzLnB1c2goWydzdHJpbmcnLCBsaXRlcmFsXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0b2tlbiBpbiBcIiArIHJ1bGUucmJuZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbkFzdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbkFzdHMgPSBbWydzdHJpbmcnLCAnJ11dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGV4cHJlc3Npb25Bc3QgPSBleHByZXNzaW9uQXN0cy5zaGlmdCgpO1xuICAgICAgICAgICAgd2hpbGUgKGV4cHJlc3Npb25Bc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uQXN0ID0gWydiaW5hcnknLCAnKycsIGV4cHJlc3Npb25Bc3QsIGV4cHJlc3Npb25Bc3RzLnNoaWZ0KCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25Bc3Q7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb25kaXRpb25Ub1N0YXRlbWVudEFzdChjb25kaXRpb25Bc3QsIHJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2lmJywgY29uZGl0aW9uQXN0LCBbJ3JldHVybicsIHJ1bGVUb0V4cHJlc3Npb25Bc3QocnVsZSldLCBudWxsXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGF0ZW1lbnRBc3RzID0gW107XG4gICAgICAgIGlmICh0aGlzLnJ1bGVCeVZhbHVlWyd4LjAnXSB8fCB0aGlzLnJ1bGVCeVZhbHVlWyd4LngnXSkge1xuICAgICAgICAgICAgLy8gdmFyIGlzRnJhY3Rpb25hbCA9IG4gIT09IE1hdGguZmxvb3Iobik7XG4gICAgICAgICAgICBzdGF0ZW1lbnRBc3RzLnB1c2goWyd2YXInLCBbWydpc0ZyYWN0aW9uYWwnLCBbJ2JpbmFyeScsICchPT0nLCBbJ25hbWUnLCAnbiddLCBbJ2NhbGwnLCBbJ2RvdCcsIFsnbmFtZScsICdNYXRoJ10sICdmbG9vciddLCBbWyduYW1lJywgJ24nXV1dXV1dXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucnVsZUJ5VmFsdWVbJ3guMCddKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRBc3RzLnB1c2goY29uZGl0aW9uVG9TdGF0ZW1lbnRBc3QoWyduYW1lJywgJ2lzRnJhY3Rpb25hbCddLCB0aGlzLnJ1bGVCeVZhbHVlWyd4LjAnXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJ1bGVCeVZhbHVlWycteCddKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRBc3RzLnB1c2goY29uZGl0aW9uVG9TdGF0ZW1lbnRBc3QoWydiaW5hcnknLCAnPCcsIFsnbmFtZScsICduJ10sIFsnbnVtJywgMF1dLCB0aGlzLnJ1bGVCeVZhbHVlWycteCddKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucnVsZUJ5VmFsdWVbJ3gueCddKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRBc3RzLnB1c2goY29uZGl0aW9uVG9TdGF0ZW1lbnRBc3QoWydiaW5hcnknLCAnJiYnLCBbJ25hbWUnLCAnaXNGcmFjdGlvbmFsJ10sIFsnYmluYXJ5JywgJz4nLCBbJ25hbWUnLCAnbiddLCBbJ251bScsIDFdXV0sIHRoaXMucnVsZUJ5VmFsdWVbJ3gueCddKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucnVsZUJ5VmFsdWVbJzAueCddKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRBc3RzLnB1c2goY29uZGl0aW9uVG9TdGF0ZW1lbnRBc3QoWydiaW5hcnknLCAnJiYnLCBbJ2JpbmFyeScsICc+JywgWyduYW1lJywgJ24nXSwgWydudW0nLCAwXV0sIFsnYmluYXJ5JywgJzwnLCBbJ25hbWUnLCAnbiddLCBbJ251bScsIDFdXV0sIHRoaXMucnVsZUJ5VmFsdWVbJzAueCddKSk7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnJ1bGVCeVZhbHVlKS5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gL15cXGQrJC8udGVzdCh2YWx1ZSk7XG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYiAtIGE7XG4gICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKG51bWVyaWNhbFZhbHVlKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRBc3RzLnB1c2goY29uZGl0aW9uVG9TdGF0ZW1lbnRBc3QoWydiaW5hcnknLCAnPj0nLCBbJ25hbWUnLCAnbiddLCBbJ251bScsIG51bWVyaWNhbFZhbHVlXV0sIHRoaXMucnVsZUJ5VmFsdWVbbnVtZXJpY2FsVmFsdWVdKSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB7ZnVuY3Rpb25Bc3Q6IFsnZnVuY3Rpb24nLCBudWxsLCBbJ24nXSwgc3RhdGVtZW50QXN0c10sIGRlcGVuZGVuY2llczogT2JqZWN0LmtleXMoaXNTZWVuQnlSdWxlU2V0VHlwZSl9O1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xkclJibmZSdWxlU2V0O1xuIiwidmFyIFBhdGggPSByZXF1aXJlKCdwYXRoJyksXG4gICAgZnMgPSByZXF1aXJlKCdmcycpLFxuICAgIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyksXG4gICAgcGFzc0Vycm9yID0gcmVxdWlyZSgncGFzc2Vycm9yJyksXG4gICAgbWVtb2l6ZUFzeW5jID0gcmVxdWlyZSgnLi9tZW1vaXplQXN5bmMnKSxcbiAgICBkb20gPSByZXF1aXJlKCd4bWxkb20nKS5ET01QYXJzZXIsXG4gICAgeHBhdGggPSByZXF1aXJlKCd4cGF0aCcpLFxuICAgIHNlcSA9IHJlcXVpcmUoJ3NlcScpLFxuICAgIG5vcm1hbGl6ZUxvY2FsZUlkID0gcmVxdWlyZSgnLi9ub3JtYWxpemVMb2NhbGVJZCcpLFxuICAgIG5vcm1hbGl6ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ub3JtYWxpemVQcm9wZXJ0eScpLFxuICAgIGNvbnZlcnRPYmplY3RzV2l0aEludGVnZXJLZXlzVG9BcnJheXMgPSByZXF1aXJlKCcuL2NvbnZlcnRPYmplY3RzV2l0aEludGVnZXJLZXlzVG9BcnJheXMnKSxcbiAgICBDbGRyUGx1cmFsUnVsZVNldCA9IHJlcXVpcmUoJy4vQ2xkclBsdXJhbFJ1bGVTZXQnKSxcbiAgICBDbGRyUmJuZlJ1bGVTZXQgPSByZXF1aXJlKCcuL0NsZHJSYm5mUnVsZVNldCcpLFxuICAgIHVnbGlmeUpzID0gcmVxdWlyZSgndWdsaWZ5LWpzJyksXG4gICAgdW5pY29kZXJlZ2V4cCA9IHJlcXVpcmUoJ3VuaWNvZGVyZWdleHAnKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplWFBhdGhRdWVyeSh4cGF0aFF1ZXJ5KSB7XG4gICAgdmFyIHhwYXRoUXVlcnlGcmFnbWVudHMgPSB4cGF0aFF1ZXJ5LnNwbGl0KCcvJyk7XG4gICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgeHBhdGhRdWVyeUZyYWdtZW50cy5sZW5ndGggOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGkgPiAwICYmIHhwYXRoUXVlcnlGcmFnbWVudHNbaV0gPT09ICcuLicgJiYgeHBhdGhRdWVyeUZyYWdtZW50c1tpIC0gMV0gIT09ICcuLicpIHtcbiAgICAgICAgICAgIHhwYXRoUXVlcnlGcmFnbWVudHMuc3BsaWNlKGkgLSAxLCAyKTtcbiAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geHBhdGhRdWVyeUZyYWdtZW50cy5qb2luKCcvJyk7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZExvY2FsZUlkVG9Qcmlvcml0aXplZExpc3QobG9jYWxlSWQpIHtcbiAgICBsb2NhbGVJZCA9IG5vcm1hbGl6ZUxvY2FsZUlkKGxvY2FsZUlkKTtcbiAgICBpZiAoIWxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIGxvY2FsZUlkcyA9IFtsb2NhbGVJZF07XG4gICAgd2hpbGUgKC9fW15fXSskLy50ZXN0KGxvY2FsZUlkKSkge1xuICAgICAgICBsb2NhbGVJZCA9IGxvY2FsZUlkLnJlcGxhY2UoL19bXl9dKyQvLCAnJyk7XG4gICAgICAgIGxvY2FsZUlkcy5wdXNoKGxvY2FsZUlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZUlkcztcbn1cblxuZnVuY3Rpb24gQ2xkcihjbGRyUGF0aCkge1xuICAgIC8vIFN1cHBvcnQgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBvcGVyYXRvcjpcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ2xkcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbGRyKGNsZHJQYXRoKTtcbiAgICB9XG4gICAgdGhpcy5jbGRyUGF0aCA9IGNsZHJQYXRoO1xuICAgIHRoaXMuZG9jdW1lbnRCeUZpbGVOYW1lID0ge307XG4gICAgdGhpcy5tZW1vaXplckJ5RmlsZU5hbWUgPSB7fTtcbn1cblxuQ2xkci5wcm90b3R5cGUgPSB7XG4gICAgZ2V0IGZpbGVOYW1lc0J5VHlwZUFuZE5vcm1hbGl6ZWRMb2NhbGVJZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maWxlTmFtZXNCeVR5cGVBbmROb3JtYWxpemVkTG9jYWxlSWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGVOYW1lc0J5VHlwZUFuZE5vcm1hbGl6ZWRMb2NhbGVJZCA9IHt9O1xuICAgICAgICAgICAgWydtYWluJywgJ3JibmYnXS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsZU5hbWVzQnlUeXBlQW5kTm9ybWFsaXplZExvY2FsZUlkW3R5cGVdID0ge307XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lcztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZXMgPSBmcy5yZWFkZGlyU3luYyhQYXRoLnJlc29sdmUodGhpcy5jbGRyUGF0aCwgXCJjb21tb25cIiwgdHlwZSkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpcmVjdG9yeSBkb2Vzbid0IGV4aXN0LCBqdXN0IHByZXRlbmQgaXQncyBlbXB0eS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaWxlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZmlsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoRmlsZU5hbWUgPSBmaWxlTmFtZS5tYXRjaCgvXiguKilcXC54bWwkLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaEZpbGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9maWxlTmFtZXNCeVR5cGVBbmROb3JtYWxpemVkTG9jYWxlSWRbdHlwZV1bbm9ybWFsaXplTG9jYWxlSWQobWF0Y2hGaWxlTmFtZVsxXSldID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQYXRoLnJlc29sdmUodGhpcy5jbGRyUGF0aCwgXCJjb21tb25cIiwgdHlwZSwgZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZmlsZU5hbWVzQnlUeXBlQW5kTm9ybWFsaXplZExvY2FsZUlkO1xuICAgIH0sXG5cbiAgICBnZXQgbG9jYWxlSWRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvY2FsZUlkcykge1xuICAgICAgICAgICAgdGhpcy5fbG9jYWxlSWRzID0gT2JqZWN0LmtleXModGhpcy5maWxlTmFtZXNCeVR5cGVBbmROb3JtYWxpemVkTG9jYWxlSWQubWFpbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZUlkcztcbiAgICB9LFxuXG4gICAgZ2V0IGNhbGVuZGFySWRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhbGVuZGFySWRzKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxlbmRhcklkcyA9IFtdO1xuICAgICAgICAgICAgeHBhdGguc2VsZWN0KCcvbGRtbEJDUDQ3L2tleXdvcmQva2V5W0BuYW1lPVwiY2FcIl0vdHlwZScsIHRoaXMuZ2V0RG9jdW1lbnQoUGF0aC5yZXNvbHZlKHRoaXMuY2xkclBhdGgsICdjb21tb24nLCAnYmNwNDcnLCAnY2FsZW5kYXIueG1sJykpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXlOb2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbGVuZGFySWQgPSBrZXlOb2RlLmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuICAgICAgICAgICAgICAgIGlmIChjYWxlbmRhcklkID09PSAnZ3JlZ29yeScpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJJZCA9ICdncmVnb3JpYW4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxlbmRhcklkcy5wdXNoKGNhbGVuZGFySWQpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGVuZGFySWRzO1xuICAgIH0sXG5cbiAgICBnZXQgbnVtYmVyU3lzdGVtSWRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX251bWJlclN5c3RlbUlkcykge1xuICAgICAgICAgICAgdGhpcy5fbnVtYmVyU3lzdGVtSWRzID0gW107XG4gICAgICAgICAgICB4cGF0aC5zZWxlY3QoJy9sZG1sQkNQNDcva2V5d29yZC9rZXlbQG5hbWU9XCJudVwiXS90eXBlJywgdGhpcy5nZXREb2N1bWVudChQYXRoLnJlc29sdmUodGhpcy5jbGRyUGF0aCwgJ2NvbW1vbicsICdiY3A0NycsICdudW1iZXIueG1sJykpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXlOb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbnVtYmVyU3lzdGVtSWRzLnB1c2goa2V5Tm9kZS5nZXRBdHRyaWJ1dGUoJ25hbWUnKSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbnVtYmVyU3lzdGVtSWRzO1xuICAgIH0sXG5cbiAgICAvLyBXb3JrcyBib3RoIGFzeW5jIGFuZCBzeW5jIChvbWl0IGNiKTpcbiAgICBnZXREb2N1bWVudDogZnVuY3Rpb24gKGZpbGVOYW1lLCBjYikge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIGlmICh0aGF0LmRvY3VtZW50QnlGaWxlTmFtZVtmaWxlTmFtZV0pIHtcbiAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjYihudWxsLCB0aGF0LmRvY3VtZW50QnlGaWxlTmFtZVtmaWxlTmFtZV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5kb2N1bWVudEJ5RmlsZU5hbWVbZmlsZU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIG5vdCB0byBsb2FkIGZpbGUgbW9yZSB0aGFuIG9uY2UgaWYgaXQncyBiZWluZyBsb2FkZWQgd2hlbiBnZXREb2N1bWVudCBpcyBjYWxsZWQgZm9yIHRoZSBzZWNvbmQgdGltZTpcbiAgICAgICAgICAgICAgICB0aGF0Lm1lbW9pemVyQnlGaWxlTmFtZVtmaWxlTmFtZV0gPSB0aGF0Lm1lbW9pemVyQnlGaWxlTmFtZVtmaWxlTmFtZV0gfHwgbWVtb2l6ZUFzeW5jKGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgICAgICBmcy5yZWFkRmlsZShmaWxlTmFtZSwgJ3V0Zi04JywgcGFzc0Vycm9yKGNiLCBmdW5jdGlvbiAoeG1sU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9jdW1lbnQgPSBuZXcgZG9tKCkucGFyc2VGcm9tU3RyaW5nKHhtbFN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmRvY3VtZW50QnlGaWxlTmFtZVtmaWxlTmFtZV0gPSBkb2N1bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoYXQubWVtb2l6ZXJCeUZpbGVOYW1lW2ZpbGVOYW1lXShjYik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmRvY3VtZW50QnlGaWxlTmFtZVtmaWxlTmFtZV0gPSBuZXcgZG9tKCkucGFyc2VGcm9tU3RyaW5nKGZzLnJlYWRGaWxlU3luYyhmaWxlTmFtZSwgJ3V0Zi04JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlOiBmdW5jdGlvbiAobG9jYWxlSWQsIHR5cGUpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZXhwYW5kTG9jYWxlSWRUb1ByaW9yaXRpemVkTGlzdChsb2NhbGVJZCkuY29uY2F0KCdyb290JykubWFwKGZ1bmN0aW9uIChzdWJMb2NhbGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoYXQuZmlsZU5hbWVzQnlUeXBlQW5kTm9ybWFsaXplZExvY2FsZUlkW3R5cGVdW25vcm1hbGl6ZUxvY2FsZUlkKHN1YkxvY2FsZUlkKV07XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoZmlsZU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWZpbGVOYW1lO1xuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKGZpbGVOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhhdC5nZXREb2N1bWVudChmaWxlTmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBwcmVsb2FkOiBmdW5jdGlvbiAobG9jYWxlSWRzLCBjYikge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlSWRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IGxvY2FsZUlkcztcbiAgICAgICAgICAgIGxvY2FsZUlkcyA9IHRoYXQubG9jYWxlSWRzO1xuICAgICAgICB9XG4gICAgICAgIGxvY2FsZUlkcyA9IChBcnJheS5pc0FycmF5KGxvY2FsZUlkcykgPyBsb2NhbGVJZHMgOiBbbG9jYWxlSWRzXSkubWFwKG5vcm1hbGl6ZUxvY2FsZUlkKTtcbiAgICAgICAgdmFyIG5lZWRlZExvY2FsZUJ5SWQgPSB7cm9vdDogdHJ1ZX07XG4gICAgICAgIGxvY2FsZUlkcy5mb3JFYWNoKGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuICAgICAgICAgICAgZXhwYW5kTG9jYWxlSWRUb1ByaW9yaXRpemVkTGlzdChsb2NhbGVJZCkuZm9yRWFjaChmdW5jdGlvbiAoc3ViTG9jYWxlSWQpIHtcbiAgICAgICAgICAgICAgICBuZWVkZWRMb2NhbGVCeUlkW3N1YkxvY2FsZUlkXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBmaWxlTmFtZXMgPSBbXG4gICAgICAgICAgICBQYXRoLnJlc29sdmUodGhhdC5jbGRyUGF0aCwgJ2NvbW1vbicsICdzdXBwbGVtZW50YWwnLCAncGx1cmFscy54bWwnKSxcbiAgICAgICAgICAgIFBhdGgucmVzb2x2ZSh0aGF0LmNsZHJQYXRoLCAnY29tbW9uJywgJ3N1cHBsZW1lbnRhbCcsICdudW1iZXJpbmdTeXN0ZW1zLnhtbCcpXG4gICAgICAgIF07XG4gICAgICAgIE9iamVjdC5rZXlzKG5lZWRlZExvY2FsZUJ5SWQpLmZvckVhY2goZnVuY3Rpb24gKGxvY2FsZUlkKSB7XG4gICAgICAgICAgICBbJ21haW4nLCAncmJuZiddLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSB0aGF0LmZpbGVOYW1lc0J5VHlwZUFuZE5vcm1hbGl6ZWRMb2NhbGVJZFt0eXBlXVtsb2NhbGVJZF07XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lcy5wdXNoKGZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNlcShmaWxlTmFtZXMpXG4gICAgICAgICAgICAucGFyRWFjaCgyMCwgZnVuY3Rpb24gKGZpbGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5nZXREb2N1bWVudChmaWxlTmFtZSwgdGhpcyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnNlcShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goY2IpO1xuICAgIH0sXG5cbiAgICBjcmVhdGVGaW5kZXI6IGZ1bmN0aW9uIChwcmlvcml0aXplZERvY3VtZW50cykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZmluZGVyKHhwYXRoUXVlcnkpIHtcbiAgICAgICAgICAgIHZhciBwcmlvcml0aXplZFJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIHByaW9yaXRpemVkRG9jdW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGRvY3VtZW50LCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdHNGb3JMb2NhbGVEb2N1bWVudCA9IHhwYXRoLnNlbGVjdCh4cGF0aFF1ZXJ5LCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdHNGb3JMb2NhbGVEb2N1bWVudC5sZW5ndGggPT09IDAgJiYgaSA9PT0gKHByaW9yaXRpemVkRG9jdW1lbnRzLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGluIHJvb3QgYW5kIHRoZXJlIHdlcmUgbm8gcmVzdWx0cywgbG9vayBmb3IgYWxpYXMgZWxlbWVudHMgaW4gcGF0aDpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5RnJhZ21lbnRzID0geHBhdGhRdWVyeS5zcGxpdCgnLycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9wcGVkUXVlcnlGcmFnbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHF1ZXJ5RnJhZ21lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbGlhc05vZGVzID0geHBhdGguc2VsZWN0KHF1ZXJ5RnJhZ21lbnRzLmpvaW4oJy8nKSArICcvYWxpYXMnLCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxpYXNOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsaWFzU3BlY2lmaWVkUXVlcnkgPSBub3JtYWxpemVYUGF0aFF1ZXJ5KHF1ZXJ5RnJhZ21lbnRzLmpvaW4oJy8nKSArICcvJyArIGFsaWFzTm9kZXNbMF0uZ2V0QXR0cmlidXRlKCdwYXRoJykgKyAnLycgKyBwb3BwZWRRdWVyeUZyYWdtZW50cy5qb2luKCcvJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHByaW9yaXRpemVkUmVzdWx0cywgZmluZGVyKGFsaWFzU3BlY2lmaWVkUXVlcnkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcHBlZFF1ZXJ5RnJhZ21lbnRzLnVuc2hpZnQocXVlcnlGcmFnbWVudHMucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocHJpb3JpdGl6ZWRSZXN1bHRzLCByZXN1bHRzRm9yTG9jYWxlRG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHByaW9yaXRpemVkUmVzdWx0cztcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZXh0cmFjdExvY2FsZURpc3BsYXlQYXR0ZXJuOiBmdW5jdGlvbiAobG9jYWxlSWQpIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgbG9jYWxlRGlzcGxheVBhdHRlcm4gPSB7fTtcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvbG9jYWxlRGlzcGxheU5hbWVzL2xvY2FsZURpc3BsYXlQYXR0ZXJuLypcIikuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgbG9jYWxlRGlzcGxheVBhdHRlcm5bbm9kZS5ub2RlTmFtZV0gPSBub2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZURpc3BsYXlQYXR0ZXJuO1xuICAgIH0sXG5cbiAgICBleHRyYWN0TGFuZ3VhZ2VEaXNwbGF5TmFtZXM6IGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBsYW5ndWFnZURpc3BsYXlOYW1lcyA9IHt9O1xuICAgICAgICBmaW5kZXIoJy9sZG1sL2xvY2FsZURpc3BsYXlOYW1lcy9sYW5ndWFnZXMvbGFuZ3VhZ2UnKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBub3JtYWxpemVMb2NhbGVJZChub2RlLmdldEF0dHJpYnV0ZSgndHlwZScpKTtcbiAgICAgICAgICAgIGxhbmd1YWdlRGlzcGxheU5hbWVzW2lkXSA9IGxhbmd1YWdlRGlzcGxheU5hbWVzW2lkXSB8fCBub2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlRGlzcGxheU5hbWVzO1xuICAgIH0sXG5cbiAgICBleHRyYWN0VGltZVpvbmVEaXNwbGF5TmFtZXM6IGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICB0aW1lWm9uZURpc3BsYXlOYW1lcyA9IHt9O1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC9kYXRlcy90aW1lWm9uZU5hbWVzL3pvbmVcIikuZm9yRWFjaChmdW5jdGlvbiAoem9uZU5vZGUpIHtcbiAgICAgICAgICAgIHZhciB0aW1lWm9uZUlkID0gem9uZU5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyksXG4gICAgICAgICAgICAgICAgZXhlbXBsYXJDaXR5Tm9kZXMgPSB4cGF0aC5zZWxlY3QoXCJleGVtcGxhckNpdHlcIiwgem9uZU5vZGUpLFxuICAgICAgICAgICAgICAgIHR6TmFtZUxvY2FsZTtcbiAgICAgICAgICAgIGlmIChleGVtcGxhckNpdHlOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdHpOYW1lTG9jYWxlID0gZXhlbXBsYXJDaXR5Tm9kZXNbMF0udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBnZW5lcmljRGlzcGxheU5hbWVOb2RlcyA9IHhwYXRoLnNlbGVjdChcImxvbmcvZ2VuZXJpY1wiLCB6b25lTm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyaWNEaXNwbGF5TmFtZU5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdHpOYW1lTG9jYWxlID0gZ2VuZXJpY0Rpc3BsYXlOYW1lTm9kZXNbMF0udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmdEaXNwbGF5TmFtZU5vZGVzID0geHBhdGguc2VsZWN0KFwibG9uZy9zdGFuZGFyZFwiLCB6b25lTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb25nRGlzcGxheU5hbWVOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ek5hbWVMb2NhbGUgPSBsb25nRGlzcGxheU5hbWVOb2Rlc1swXS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ek5hbWVMb2NhbGUpIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZURpc3BsYXlOYW1lc1t0aW1lWm9uZUlkXSA9IHRpbWVab25lRGlzcGxheU5hbWVzW3RpbWVab25lSWRdIHx8IHR6TmFtZUxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aW1lWm9uZURpc3BsYXlOYW1lcztcbiAgICB9LFxuXG4gICAgZXh0cmFjdFRpbWVab25lRm9ybWF0czogZnVuY3Rpb24gKGxvY2FsZUlkKSB7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIHRpbWVab25lRm9ybWF0cyA9IHt9O1xuICAgICAgICBbJ2hvdXJGb3JtYXQnLCAnZ210Rm9ybWF0JywgJ2dtdFplcm9Gb3JtYXQnLCAncmVnaW9uRm9ybWF0JywgJ2ZhbGxiYWNrRm9ybWF0JywgJ2ZhbGxiYWNrUmVnaW9uRm9ybWF0J10uZm9yRWFjaChmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgICAgICAgICAgZmluZGVyKFwiL2xkbWwvZGF0ZXMvdGltZVpvbmVOYW1lcy9cIiArIHRhZ05hbWUpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0TmFtZSA9IG5vZGUubm9kZU5hbWUucmVwbGFjZSgvRm9ybWF0JC8sICcnKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBub2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIGlmIChmb3JtYXROYW1lID09PSAnaG91cicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnOycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aW1lWm9uZUZvcm1hdHNbZm9ybWF0TmFtZV0gPSB0aW1lWm9uZUZvcm1hdHNbZm9ybWF0TmFtZV0gfHwgdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2RhdGVzL3RpbWVab25lTmFtZXMvcmVnaW9uRm9ybWF0W0B0eXBlXVwiKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgICAgICB0aW1lWm9uZUZvcm1hdHMucmVnaW9ucyA9IHRpbWVab25lRm9ybWF0cy5yZWdpb25zIHx8IHt9O1xuICAgICAgICAgICAgdGltZVpvbmVGb3JtYXRzLnJlZ2lvbnNbdHlwZV0gPSB0aW1lWm9uZUZvcm1hdHMucmVnaW9uc1t0eXBlXSB8fCBub2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRpbWVab25lRm9ybWF0cztcbiAgICB9LFxuXG4gICAgZXh0cmFjdFRlcnJpdG9yeURpc3BsYXlOYW1lczogZnVuY3Rpb24gKGxvY2FsZUlkKSB7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIHRlcnJpdG9yeURpc3BsYXlOYW1lcyA9IHt9O1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC9sb2NhbGVEaXNwbGF5TmFtZXMvdGVycml0b3JpZXMvdGVycml0b3J5XCIpLmZvckVhY2goZnVuY3Rpb24gKHRlcnJpdG9yeU5vZGUpIHtcbiAgICAgICAgICAgIHZhciB0ZXJyaXRvcnlJZCA9IHRlcnJpdG9yeU5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgICAgICB0ZXJyaXRvcnlEaXNwbGF5TmFtZXNbdGVycml0b3J5SWRdID0gdGVycml0b3J5RGlzcGxheU5hbWVzW3RlcnJpdG9yeUlkXSB8fCB0ZXJyaXRvcnlOb2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRlcnJpdG9yeURpc3BsYXlOYW1lcztcbiAgICB9LFxuXG4gICAgZXh0cmFjdEN1cnJlbmN5SW5mb0J5SWQ6IGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBjdXJyZW5jeURpc3BsYXlOYW1lQnlDdXJyZW5jeUlkID0ge30sXG4gICAgICAgICAgICBjdXJyZW5jeURpc3BsYXlOYW1lQnlDdXJyZW5jeUlkQW5kQ291bnQgPSB7fSxcbiAgICAgICAgICAgIGN1cnJlbmN5U3ltYm9sQnlDdXJyZW5jeUlkID0ge307XG5cbiAgICAgICAgZmluZGVyKFwiL2xkbWwvbnVtYmVycy9jdXJyZW5jaWVzL2N1cnJlbmN5L2Rpc3BsYXlOYW1lXCIpLmZvckVhY2goZnVuY3Rpb24gKGRpc3BsYXlOYW1lTm9kZSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbmN5SWQgPSBkaXNwbGF5TmFtZU5vZGUucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSxcbiAgICAgICAgICAgICAgICBjb3VudEF0dHJpYnV0ZSA9IGRpc3BsYXlOYW1lTm9kZS5nZXRBdHRyaWJ1dGUoJ2NvdW50Jyk7XG4gICAgICAgICAgICBpZiAoY291bnRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW5jeURpc3BsYXlOYW1lQnlDdXJyZW5jeUlkQW5kQ291bnRbY3VycmVuY3lJZF0gPSBjdXJyZW5jeURpc3BsYXlOYW1lQnlDdXJyZW5jeUlkQW5kQ291bnRbY3VycmVuY3lJZF0gfHwge307XG4gICAgICAgICAgICAgICAgY3VycmVuY3lEaXNwbGF5TmFtZUJ5Q3VycmVuY3lJZEFuZENvdW50W2N1cnJlbmN5SWRdW2NvdW50QXR0cmlidXRlXSA9IGRpc3BsYXlOYW1lTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVuY3lEaXNwbGF5TmFtZUJ5Q3VycmVuY3lJZFtjdXJyZW5jeUlkXSA9IGN1cnJlbmN5RGlzcGxheU5hbWVCeUN1cnJlbmN5SWRbY3VycmVuY3lJZF0gfHwgZGlzcGxheU5hbWVOb2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBmaW5kZXIoXCIvbGRtbC9udW1iZXJzL2N1cnJlbmNpZXMvY3VycmVuY3kvc3ltYm9sXCIpLmZvckVhY2goZnVuY3Rpb24gKHN5bWJvbE5vZGUpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW5jeUlkID0gc3ltYm9sTm9kZS5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICAgICAgY3VycmVuY3lTeW1ib2xCeUN1cnJlbmN5SWRbY3VycmVuY3lJZF0gPSBjdXJyZW5jeVN5bWJvbEJ5Q3VycmVuY3lJZFtjdXJyZW5jeUlkXSB8fCBzeW1ib2xOb2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgY3VycmVuY3lJbmZvQnlJZCA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhjdXJyZW5jeURpc3BsYXlOYW1lQnlDdXJyZW5jeUlkKS5mb3JFYWNoKGZ1bmN0aW9uIChjdXJyZW5jeUlkKSB7XG4gICAgICAgICAgICBjdXJyZW5jeUluZm9CeUlkW2N1cnJlbmN5SWRdID0gXy5leHRlbmQoe1xuICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBjdXJyZW5jeURpc3BsYXlOYW1lQnlDdXJyZW5jeUlkW2N1cnJlbmN5SWRdLFxuICAgICAgICAgICAgICAgIHN5bWJvbDogY3VycmVuY3lTeW1ib2xCeUN1cnJlbmN5SWRbY3VycmVuY3lJZF1cbiAgICAgICAgICAgIH0sIGN1cnJlbmN5RGlzcGxheU5hbWVCeUN1cnJlbmN5SWRBbmRDb3VudFtjdXJyZW5jeUlkXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3VycmVuY3lJbmZvQnlJZDtcbiAgICB9LFxuXG4gICAgZXh0cmFjdFNjcmlwdERpc3BsYXlOYW1lczogZnVuY3Rpb24gKGxvY2FsZUlkKSB7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIHNjcmlwdERpc3BsYXlOYW1lcyA9IHt9O1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC9sb2NhbGVEaXNwbGF5TmFtZXMvc2NyaXB0cy9zY3JpcHRcIikuZm9yRWFjaChmdW5jdGlvbiAoc2NyaXB0Tm9kZSkge1xuICAgICAgICAgICAgdmFyIGlkID0gc2NyaXB0Tm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgICAgIHNjcmlwdERpc3BsYXlOYW1lc1tpZF0gPSBzY3JpcHREaXNwbGF5TmFtZXNbaWRdIHx8IHNjcmlwdE5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2NyaXB0RGlzcGxheU5hbWVzO1xuICAgIH0sXG5cbiAgICBleHRyYWN0S2V5VHlwZXM6IGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBrZXlUeXBlcyA9IHt9O1xuICAgICAgICBmaW5kZXIoJy9sZG1sL2xvY2FsZURpc3BsYXlOYW1lcy9rZXlzL2tleScpLmZvckVhY2goZnVuY3Rpb24gKGtleU5vZGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0ga2V5Tm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgICAgIGtleVR5cGVzW3R5cGVdID0geyBkaXNwbGF5TmFtZToga2V5Tm9kZS50ZXh0Q29udGVudCB9O1xuICAgICAgICB9KTtcbiAgICAgICAgZmluZGVyKCcvbGRtbC9sb2NhbGVEaXNwbGF5TmFtZXMvdHlwZXMvdHlwZScpLmZvckVhY2goZnVuY3Rpb24gKHR5cGVOb2RlKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gdHlwZU5vZGUuZ2V0QXR0cmlidXRlKCdrZXknKSxcbiAgICAgICAgICAgICAgICB0eXBlID0gbm9ybWFsaXplUHJvcGVydHkodHlwZU5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJykpO1xuICAgICAgICAgICAga2V5VHlwZXNba2V5XSA9IGtleVR5cGVzW2tleV0gfHwge307XG4gICAgICAgICAgICBrZXlUeXBlc1trZXldLnR5cGVzID0ga2V5VHlwZXNba2V5XS50eXBlcyB8fCB7fTtcbiAgICAgICAgICAgIGtleVR5cGVzW2tleV0udHlwZXNbdHlwZV0gPSB0eXBlTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBrZXlUeXBlcztcbiAgICB9LFxuXG4gICAgZXh0cmFjdFRyYW5zZm9ybU5hbWVzOiBmdW5jdGlvbiAobG9jYWxlSWQpIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgdHJhbnNmb3JtTmFtZXMgPSB7fTtcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvbG9jYWxlRGlzcGxheU5hbWVzL3RyYW5zZm9ybU5hbWVzL3RyYW5zZm9ybU5hbWVcIikuZm9yRWFjaChmdW5jdGlvbiAodHJhbnNmb3JtTmFtZU5vZGUpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHRyYW5zZm9ybU5hbWVOb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICAgICAgdHJhbnNmb3JtTmFtZXNbaWRdID0gdHJhbnNmb3JtTmFtZXNbaWRdIHx8IHRyYW5zZm9ybU5hbWVOb2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybU5hbWVzO1xuICAgIH0sXG5cbiAgICBleHRyYWN0TWVhc3VyZW1lbnRTeXN0ZW1OYW1lczogZnVuY3Rpb24gKGxvY2FsZUlkKSB7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIG1lYXN1cmVtZW50U3lzdGVtTmFtZXMgPSB7fTtcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvbG9jYWxlRGlzcGxheU5hbWVzL21lYXN1cmVtZW50U3lzdGVtTmFtZXMvbWVhc3VyZW1lbnRTeXN0ZW1OYW1lXCIpLmZvckVhY2goZnVuY3Rpb24gKG1lYXN1cmVtZW50U3lzdGVtTmFtZU5vZGUpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IG1lYXN1cmVtZW50U3lzdGVtTmFtZU5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgICAgICBtZWFzdXJlbWVudFN5c3RlbU5hbWVzW2lkXSA9IG1lYXN1cmVtZW50U3lzdGVtTmFtZXNbaWRdIHx8IG1lYXN1cmVtZW50U3lzdGVtTmFtZU5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVhc3VyZW1lbnRTeXN0ZW1OYW1lcztcbiAgICB9LFxuXG4gICAgZXh0cmFjdENvZGVQYXR0ZXJuczogZnVuY3Rpb24gKGxvY2FsZUlkKSB7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIGNvZGVQYXR0ZXJucyA9IHt9O1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC9sb2NhbGVEaXNwbGF5TmFtZXMvY29kZVBhdHRlcm5zL2NvZGVQYXR0ZXJuXCIpLmZvckVhY2goZnVuY3Rpb24gKGNvZGVQYXR0ZXJuTm9kZSkge1xuICAgICAgICAgICAgdmFyIGlkID0gY29kZVBhdHRlcm5Ob2RlLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICAgICAgY29kZVBhdHRlcm5zW2lkXSA9IGNvZGVQYXR0ZXJuc1tpZF0gfHwgY29kZVBhdHRlcm5Ob2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvZGVQYXR0ZXJucztcbiAgICB9LFxuXG4gICAgLy8gQ2FsZW5kYXIgZXh0cmFjdGlvbiBtZXRob2RzOlxuXG4gICAgZXh0cmFjdEVyYU5hbWVzOiBmdW5jdGlvbiAobG9jYWxlSWQsIGNhbGVuZGFySWQpIHtcbiAgICAgICAgY2FsZW5kYXJJZCA9IGNhbGVuZGFySWQgfHwgJ2dyZWdvcmlhbic7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIGVyYU5hbWVzO1xuICAgICAgICBbJ2VyYU5hbWVzJywgJ2VyYUFiYnInXS5mb3JFYWNoKGZ1bmN0aW9uIChlcmFUeXBlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZUluT3V0cHV0ID0ge2VyYU5hbWVzOiAnd2lkZScsIGVyYUFiYnI6ICdhYmJyZXZpYXRlZCd9W2VyYVR5cGVdO1xuICAgICAgICAgICAgZmluZGVyKFwiL2xkbWwvZGF0ZXMvY2FsZW5kYXJzL2NhbGVuZGFyW0B0eXBlPSdcIiArIGNhbGVuZGFySWQgKyBcIiddL2VyYXMvXCIgKyBlcmFUeXBlICsgXCIvZXJhXCIpLmZvckVhY2goZnVuY3Rpb24gKGVyYU5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHBhcnNlSW50KGVyYU5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyksIDEwKTtcbiAgICAgICAgICAgICAgICBlcmFOYW1lcyA9IGVyYU5hbWVzIHx8IHt9O1xuICAgICAgICAgICAgICAgIGVyYU5hbWVzW3R5cGVJbk91dHB1dF0gPSBlcmFOYW1lc1t0eXBlSW5PdXRwdXRdIHx8IHt9O1xuICAgICAgICAgICAgICAgIGVyYU5hbWVzW3R5cGVJbk91dHB1dF1bdHlwZV0gPSBlcmFOYW1lc1t0eXBlSW5PdXRwdXRdW3R5cGVdIHx8IGVyYU5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb252ZXJ0T2JqZWN0c1dpdGhJbnRlZ2VyS2V5c1RvQXJyYXlzKGVyYU5hbWVzKTtcbiAgICB9LFxuXG4gICAgZXh0cmFjdFF1YXJ0ZXJOYW1lczogZnVuY3Rpb24gKGxvY2FsZUlkLCBjYWxlbmRhcklkKSB7XG4gICAgICAgIGNhbGVuZGFySWQgPSBjYWxlbmRhcklkIHx8ICdncmVnb3JpYW4nO1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBxdWFydGVyTmFtZXM7XG4gICAgICAgIFsnZm9ybWF0JywgJ3N0YW5kLWFsb25lJ10uZm9yRWFjaChmdW5jdGlvbiAocXVhcnRlckNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBxdWFydGVyQ29udGV4dENhbWVsQ2FzZSA9IG5vcm1hbGl6ZVByb3BlcnR5KHF1YXJ0ZXJDb250ZXh0KTsgLy8gc3RhbmQtYWxvbmUgPT4gc3RhbmRBbG9uZVxuICAgICAgICAgICAgWydhYmJyZXZpYXRlZCcsICduYXJyb3cnLCAnd2lkZSddLmZvckVhY2goZnVuY3Rpb24gKHF1YXJ0ZXJXaWR0aCkge1xuICAgICAgICAgICAgICAgIGZpbmRlcihcIi9sZG1sL2RhdGVzL2NhbGVuZGFycy9jYWxlbmRhcltAdHlwZT0nXCIgKyBjYWxlbmRhcklkICsgXCInXS9xdWFydGVycy9xdWFydGVyQ29udGV4dFtAdHlwZT0nXCIgKyBxdWFydGVyQ29udGV4dCArIFwiJ10vcXVhcnRlcldpZHRoW0B0eXBlPSdcIiArIHF1YXJ0ZXJXaWR0aCArIFwiJ10vcXVhcnRlclwiKS5mb3JFYWNoKGZ1bmN0aW9uIChxdWFydGVyTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcXVhcnRlck5vID0gcGFyc2VJbnQocXVhcnRlck5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyksIDEwKSAtIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgcXVhcnRlck5hbWVzID0gcXVhcnRlck5hbWVzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBxdWFydGVyTmFtZXNbcXVhcnRlckNvbnRleHRDYW1lbENhc2VdID0gcXVhcnRlck5hbWVzW3F1YXJ0ZXJDb250ZXh0Q2FtZWxDYXNlXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgcXVhcnRlck5hbWVzW3F1YXJ0ZXJDb250ZXh0Q2FtZWxDYXNlXVtxdWFydGVyV2lkdGhdID0gcXVhcnRlck5hbWVzW3F1YXJ0ZXJDb250ZXh0Q2FtZWxDYXNlXVtxdWFydGVyV2lkdGhdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBxdWFydGVyTmFtZXNbcXVhcnRlckNvbnRleHRDYW1lbENhc2VdW3F1YXJ0ZXJXaWR0aF1bcXVhcnRlck5vXSA9IHF1YXJ0ZXJOYW1lc1txdWFydGVyQ29udGV4dENhbWVsQ2FzZV1bcXVhcnRlcldpZHRoXVtxdWFydGVyTm9dIHx8IHF1YXJ0ZXJOb2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29udmVydE9iamVjdHNXaXRoSW50ZWdlcktleXNUb0FycmF5cyhxdWFydGVyTmFtZXMpO1xuICAgIH0sXG5cbiAgICBleHRyYWN0RGF5UGVyaW9kczogZnVuY3Rpb24gKGxvY2FsZUlkLCBjYWxlbmRhcklkKSB7XG4gICAgICAgIGNhbGVuZGFySWQgPSBjYWxlbmRhcklkIHx8ICdncmVnb3JpYW4nO1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBkYXlQZXJpb2RzO1xuICAgICAgICBbJ2Zvcm1hdCcsICdzdGFuZC1hbG9uZSddLmZvckVhY2goZnVuY3Rpb24gKGRheVBlcmlvZENvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBkYXlQZXJpb2RDb250ZXh0Q2FtZWxDYXNlID0gbm9ybWFsaXplUHJvcGVydHkoZGF5UGVyaW9kQ29udGV4dCk7IC8vIHN0YW5kLWFsb25lID0+IHN0YW5kQWxvbmVcbiAgICAgICAgICAgIFsnYWJicmV2aWF0ZWQnLCAnbmFycm93JywgJ3dpZGUnLCAnc2hvcnQnXS5mb3JFYWNoKGZ1bmN0aW9uIChkYXlQZXJpb2RXaWR0aCkge1xuICAgICAgICAgICAgICAgIGZpbmRlcihcIi9sZG1sL2RhdGVzL2NhbGVuZGFycy9jYWxlbmRhcltAdHlwZT0nXCIgKyBjYWxlbmRhcklkICsgXCInXS9kYXlQZXJpb2RzL2RheVBlcmlvZENvbnRleHRbQHR5cGU9J1wiICsgZGF5UGVyaW9kQ29udGV4dCArIFwiJ10vZGF5UGVyaW9kV2lkdGhbQHR5cGU9J1wiICsgZGF5UGVyaW9kV2lkdGggKyBcIiddL2RheVBlcmlvZFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChkYXlQZXJpb2ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZGF5UGVyaW9kTm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcblxuICAgICAgICAgICAgICAgICAgICBkYXlQZXJpb2RzID0gZGF5UGVyaW9kcyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgZGF5UGVyaW9kc1tkYXlQZXJpb2RDb250ZXh0Q2FtZWxDYXNlXSA9IGRheVBlcmlvZHNbZGF5UGVyaW9kQ29udGV4dENhbWVsQ2FzZV0gfHwge307XG4gICAgICAgICAgICAgICAgICAgIGRheVBlcmlvZHNbZGF5UGVyaW9kQ29udGV4dENhbWVsQ2FzZV1bZGF5UGVyaW9kV2lkdGhdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRheVBlcmlvZHNbZGF5UGVyaW9kQ29udGV4dENhbWVsQ2FzZV1bZGF5UGVyaW9kV2lkdGhdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBkYXlQZXJpb2RzW2RheVBlcmlvZENvbnRleHRDYW1lbENhc2VdW2RheVBlcmlvZFdpZHRoXVt0eXBlXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXlQZXJpb2RzW2RheVBlcmlvZENvbnRleHRDYW1lbENhc2VdW2RheVBlcmlvZFdpZHRoXVt0eXBlXSB8fCBkYXlQZXJpb2ROb2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF5UGVyaW9kcztcbiAgICB9LFxuXG4gICAgZXh0cmFjdEN5Y2xpY05hbWVzOiBmdW5jdGlvbiAobG9jYWxlSWQsIGNhbGVuZGFySWQpIHtcbiAgICAgICAgY2FsZW5kYXJJZCA9IGNhbGVuZGFySWQgfHwgJ2dyZWdvcmlhbic7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIGN5Y2xpY05hbWVzO1xuICAgICAgICBbJ2RheVBhcnRzJywgJ2RheXMnLCAnbW9udGhzJywgJ3llYXJzJywgJ3pvZGlhY3MnXS5mb3JFYWNoKGZ1bmN0aW9uIChjeWNsaWNOYW1lU2V0KSB7XG4gICAgICAgICAgICBbJ2Zvcm1hdCddLmZvckVhY2goZnVuY3Rpb24gKGN5Y2xpY05hbWVDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgWydhYmJyZXZpYXRlZCcsICduYXJyb3cnLCAnd2lkZSddLmZvckVhY2goZnVuY3Rpb24gKGN5Y2xpY05hbWVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBmaW5kZXIoXCIvbGRtbC9kYXRlcy9jYWxlbmRhcnMvY2FsZW5kYXJbQHR5cGU9J1wiICsgY2FsZW5kYXJJZCArIFwiJ10vY3ljbGljTmFtZVNldHMvY3ljbGljTmFtZVNldFtAdHlwZT0nXCIgKyBjeWNsaWNOYW1lU2V0ICsgXCInXS9jeWNsaWNOYW1lQ29udGV4dFtAdHlwZT0nXCIgKyBjeWNsaWNOYW1lQ29udGV4dCArIFwiJ10vY3ljbGljTmFtZVdpZHRoW0B0eXBlPSdcIiArIGN5Y2xpY05hbWVXaWR0aCArIFwiJ10vY3ljbGljTmFtZVwiKS5mb3JFYWNoKGZ1bmN0aW9uIChjeWNsaWNOYW1lTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBjeWNsaWNOYW1lTm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5Y2xpY05hbWVzID0gY3ljbGljTmFtZXMgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICBjeWNsaWNOYW1lc1tjeWNsaWNOYW1lU2V0XSA9IGN5Y2xpY05hbWVzW2N5Y2xpY05hbWVTZXRdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3ljbGljTmFtZXNbY3ljbGljTmFtZVNldF1bY3ljbGljTmFtZUNvbnRleHRdID0gY3ljbGljTmFtZXNbY3ljbGljTmFtZVNldF1bY3ljbGljTmFtZUNvbnRleHRdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3ljbGljTmFtZXNbY3ljbGljTmFtZVNldF1bY3ljbGljTmFtZUNvbnRleHRdW2N5Y2xpY05hbWVXaWR0aF0gPSBjeWNsaWNOYW1lc1tjeWNsaWNOYW1lU2V0XVtjeWNsaWNOYW1lQ29udGV4dF1bY3ljbGljTmFtZVdpZHRoXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5Y2xpY05hbWVzW2N5Y2xpY05hbWVTZXRdW2N5Y2xpY05hbWVDb250ZXh0XVtjeWNsaWNOYW1lV2lkdGhdW3R5cGVdID0gY3ljbGljTmFtZXNbY3ljbGljTmFtZVNldF1bY3ljbGljTmFtZUNvbnRleHRdW2N5Y2xpY05hbWVXaWR0aF1bdHlwZV0gfHwgY3ljbGljTmFtZU5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29udmVydE9iamVjdHNXaXRoSW50ZWdlcktleXNUb0FycmF5cyhjeWNsaWNOYW1lcyk7XG4gICAgfSxcblxuICAgIGV4dHJhY3RNb250aE5hbWVzOiBmdW5jdGlvbiAobG9jYWxlSWQsIGNhbGVuZGFySWQpIHtcbiAgICAgICAgY2FsZW5kYXJJZCA9IGNhbGVuZGFySWQgfHwgJ2dyZWdvcmlhbic7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIG1vbnRoTmFtZXM7XG4gICAgICAgIFsnZm9ybWF0JywgJ3N0YW5kLWFsb25lJ10uZm9yRWFjaChmdW5jdGlvbiAobW9udGhDb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbW9udGhDb250ZXh0Q2FtZWxDYXNlID0gbm9ybWFsaXplUHJvcGVydHkobW9udGhDb250ZXh0KTsgLy8gc3RhbmQtYWxvbmUgPT4gc3RhbmRBbG9uZVxuICAgICAgICAgICAgWydhYmJyZXZpYXRlZCcsICduYXJyb3cnLCAnd2lkZSddLmZvckVhY2goZnVuY3Rpb24gKG1vbnRoV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBmaW5kZXIoXCIvbGRtbC9kYXRlcy9jYWxlbmRhcnMvY2FsZW5kYXJbQHR5cGU9J1wiICsgY2FsZW5kYXJJZCArIFwiJ10vbW9udGhzL21vbnRoQ29udGV4dFtAdHlwZT0nXCIgKyBtb250aENvbnRleHQgKyBcIiddL21vbnRoV2lkdGhbQHR5cGU9J1wiICsgbW9udGhXaWR0aCArIFwiJ10vbW9udGhcIikuZm9yRWFjaChmdW5jdGlvbiAobW9udGhOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb250aE5vID0gcGFyc2VJbnQobW9udGhOb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpLCAxMCkgLSAxO1xuICAgICAgICAgICAgICAgICAgICBtb250aE5hbWVzID0gbW9udGhOYW1lcyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgbW9udGhOYW1lc1ttb250aENvbnRleHRDYW1lbENhc2VdID0gbW9udGhOYW1lc1ttb250aENvbnRleHRDYW1lbENhc2VdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBtb250aE5hbWVzW21vbnRoQ29udGV4dENhbWVsQ2FzZV1bbW9udGhXaWR0aF0gPSBtb250aE5hbWVzW21vbnRoQ29udGV4dENhbWVsQ2FzZV1bbW9udGhXaWR0aF0gfHwge307XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoTmFtZXNbbW9udGhDb250ZXh0Q2FtZWxDYXNlXVttb250aFdpZHRoXVttb250aE5vXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBtb250aE5hbWVzW21vbnRoQ29udGV4dENhbWVsQ2FzZV1bbW9udGhXaWR0aF1bbW9udGhOb10gfHwgbW9udGhOb2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29udmVydE9iamVjdHNXaXRoSW50ZWdlcktleXNUb0FycmF5cyhtb250aE5hbWVzKTtcbiAgICB9LFxuXG4gICAgZXh0cmFjdE1vbnRoUGF0dGVybnM6IGZ1bmN0aW9uIChsb2NhbGVJZCwgY2FsZW5kYXJJZCkge1xuICAgICAgICBjYWxlbmRhcklkID0gY2FsZW5kYXJJZCB8fCAnZ3JlZ29yaWFuJztcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgbW9udGhQYXR0ZXJucztcbiAgICAgICAgWydmb3JtYXQnLCAnbnVtZXJpYycsICdzdGFuZC1hbG9uZSddLmZvckVhY2goZnVuY3Rpb24gKG1vbnRoUGF0dGVybkNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBtb250aFBhdHRlcm5Db250ZXh0Q2FtZWxDYXNlID0gbm9ybWFsaXplUHJvcGVydHkobW9udGhQYXR0ZXJuQ29udGV4dCk7IC8vIHN0YW5kLWFsb25lID0+IHN0YW5kQWxvbmVcbiAgICAgICAgICAgIFsnYWJicmV2aWF0ZWQnLCAnbmFycm93JywgJ3dpZGUnLCAnYWxsJ10uZm9yRWFjaChmdW5jdGlvbiAobW9udGhQYXR0ZXJuV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBmaW5kZXIoXCIvbGRtbC9kYXRlcy9jYWxlbmRhcnMvY2FsZW5kYXJbQHR5cGU9J1wiICsgY2FsZW5kYXJJZCArIFwiJ10vbW9udGhQYXR0ZXJucy9tb250aFBhdHRlcm5Db250ZXh0W0B0eXBlPSdcIiArIG1vbnRoUGF0dGVybkNvbnRleHQgKyBcIiddL21vbnRoUGF0dGVybldpZHRoW0B0eXBlPSdcIiArIG1vbnRoUGF0dGVybldpZHRoICsgXCInXS9tb250aFBhdHRlcm5cIikuZm9yRWFjaChmdW5jdGlvbiAobW9udGhQYXR0ZXJuTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IG1vbnRoUGF0dGVybk5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoUGF0dGVybnMgPSBtb250aFBhdHRlcm5zIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBtb250aFBhdHRlcm5zW21vbnRoUGF0dGVybkNvbnRleHRDYW1lbENhc2VdID0gbW9udGhQYXR0ZXJuc1ttb250aFBhdHRlcm5Db250ZXh0Q2FtZWxDYXNlXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgbW9udGhQYXR0ZXJuc1ttb250aFBhdHRlcm5Db250ZXh0Q2FtZWxDYXNlXVttb250aFBhdHRlcm5XaWR0aF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgbW9udGhQYXR0ZXJuc1ttb250aFBhdHRlcm5Db250ZXh0Q2FtZWxDYXNlXVttb250aFBhdHRlcm5XaWR0aF0gfHwge307XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoUGF0dGVybnNbbW9udGhQYXR0ZXJuQ29udGV4dENhbWVsQ2FzZV1bbW9udGhQYXR0ZXJuV2lkdGhdW3R5cGVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoUGF0dGVybnNbbW9udGhQYXR0ZXJuQ29udGV4dENhbWVsQ2FzZV1bbW9udGhQYXR0ZXJuV2lkdGhdW3R5cGVdIHx8IG1vbnRoUGF0dGVybk5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtb250aFBhdHRlcm5zO1xuICAgIH0sXG5cbiAgICBleHRyYWN0RGF5TmFtZXM6IGZ1bmN0aW9uIChsb2NhbGVJZCwgY2FsZW5kYXJJZCkge1xuICAgICAgICBjYWxlbmRhcklkID0gY2FsZW5kYXJJZCB8fCAnZ3JlZ29yaWFuJztcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgZGF5Tm9CeUNsZHJJZCA9IHtzdW46IDAsIG1vbjogMSwgdHVlOiAyLCB3ZWQ6IDMsIHRodTogNCwgZnJpOiA1LCBzYXQ6IDZ9LFxuICAgICAgICAgICAgZGF5TmFtZXM7XG4gICAgICAgIFsnZm9ybWF0JywgJ251bWVyaWMnLCAnc3RhbmQtYWxvbmUnXS5mb3JFYWNoKGZ1bmN0aW9uIChkYXlDb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgZGF5Q29udGV4dENhbWVsQ2FzZSA9IG5vcm1hbGl6ZVByb3BlcnR5KGRheUNvbnRleHQpOyAvLyBzdGFuZC1hbG9uZSA9PiBzdGFuZEFsb25lXG4gICAgICAgICAgICBbJ2FiYnJldmlhdGVkJywgJ25hcnJvdycsICd3aWRlJywgJ3Nob3J0J10uZm9yRWFjaChmdW5jdGlvbiAoZGF5V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBmaW5kZXIoXCIvbGRtbC9kYXRlcy9jYWxlbmRhcnMvY2FsZW5kYXJbQHR5cGU9J1wiICsgY2FsZW5kYXJJZCArIFwiJ10vZGF5cy9kYXlDb250ZXh0W0B0eXBlPSdcIiArIGRheUNvbnRleHQgKyBcIiddL2RheVdpZHRoW0B0eXBlPSdcIiArIGRheVdpZHRoICsgXCInXS9kYXlcIikuZm9yRWFjaChmdW5jdGlvbiAoZGF5Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF5Tm8gPSBkYXlOb0J5Q2xkcklkW2RheU5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyldO1xuICAgICAgICAgICAgICAgICAgICBkYXlOYW1lcyA9IGRheU5hbWVzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBkYXlOYW1lc1tkYXlDb250ZXh0Q2FtZWxDYXNlXSA9IGRheU5hbWVzW2RheUNvbnRleHRDYW1lbENhc2VdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBkYXlOYW1lc1tkYXlDb250ZXh0Q2FtZWxDYXNlXVtkYXlXaWR0aF0gPSBkYXlOYW1lc1tkYXlDb250ZXh0Q2FtZWxDYXNlXVtkYXlXaWR0aF0gfHwge307XG4gICAgICAgICAgICAgICAgICAgIGRheU5hbWVzW2RheUNvbnRleHRDYW1lbENhc2VdW2RheVdpZHRoXVtkYXlOb10gPSBkYXlOYW1lc1tkYXlDb250ZXh0Q2FtZWxDYXNlXVtkYXlXaWR0aF1bZGF5Tm9dIHx8IGRheU5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb252ZXJ0T2JqZWN0c1dpdGhJbnRlZ2VyS2V5c1RvQXJyYXlzKGRheU5hbWVzKTtcbiAgICB9LFxuXG4gICAgZXh0cmFjdEZpZWxkczogZnVuY3Rpb24gKGxvY2FsZUlkKSB7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIGZpZWxkcztcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvZGF0ZXMvZmllbGRzL2ZpZWxkL2Rpc3BsYXlOYW1lXCIpLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkRGlzcGxheU5hbWVOb2RlKSB7XG4gICAgICAgICAgICB2YXIgZmllbGROYW1lID0gZmllbGREaXNwbGF5TmFtZU5vZGUucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgICAgIGZpZWxkcyA9IGZpZWxkcyB8fCB7fTtcbiAgICAgICAgICAgIGZpZWxkc1tmaWVsZE5hbWVdID0gZmllbGRzW2ZpZWxkTmFtZV0gfHwge307XG4gICAgICAgICAgICBmaWVsZHNbZmllbGROYW1lXS5kaXNwbGF5TmFtZSA9IGZpZWxkc1tmaWVsZE5hbWVdLmRpc3BsYXlOYW1lIHx8IGZpZWxkRGlzcGxheU5hbWVOb2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcblxuICAgICAgICBmaW5kZXIoXCIvbGRtbC9kYXRlcy9maWVsZHMvZmllbGQvcmVsYXRpdmVcIikuZm9yRWFjaChmdW5jdGlvbiAoZmllbGRSZWxhdGl2ZU5vZGUpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZE5hbWUgPSBmaWVsZFJlbGF0aXZlTm9kZS5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpLFxuICAgICAgICAgICAgICAgIHR5cGUgPSBmaWVsZFJlbGF0aXZlTm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgICAgIGZpZWxkcyA9IGZpZWxkcyB8fCB7fTtcbiAgICAgICAgICAgIGZpZWxkc1tmaWVsZE5hbWVdID0gZmllbGRzW2ZpZWxkTmFtZV0gfHwge307XG4gICAgICAgICAgICBmaWVsZHNbZmllbGROYW1lXS5yZWxhdGl2ZSA9IGZpZWxkc1tmaWVsZE5hbWVdLnJlbGF0aXZlIHx8IHt9O1xuICAgICAgICAgICAgZmllbGRzW2ZpZWxkTmFtZV0ucmVsYXRpdmVbdHlwZV0gPSBmaWVsZHNbZmllbGROYW1lXS5yZWxhdGl2ZVt0eXBlXSB8fCBmaWVsZFJlbGF0aXZlTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZmluZGVyKFwiL2xkbWwvZGF0ZXMvZmllbGRzL2ZpZWxkL3JlbGF0aXZlVGltZS9yZWxhdGl2ZVRpbWVQYXR0ZXJuXCIpLmZvckVhY2goZnVuY3Rpb24gKHJlbGF0aXZlVGltZVBhdHRlcm5Ob2RlKSB7XG4gICAgICAgICAgICB2YXIgcmVsYXRpdmVUaW1lTm9kZSA9IHJlbGF0aXZlVGltZVBhdHRlcm5Ob2RlLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgZmllbGROYW1lID0gcmVsYXRpdmVUaW1lTm9kZS5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpLFxuICAgICAgICAgICAgICAgIHR5cGUgPSByZWxhdGl2ZVRpbWVOb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpLFxuICAgICAgICAgICAgICAgIGNvdW50ID0gcmVsYXRpdmVUaW1lUGF0dGVybk5vZGUuZ2V0QXR0cmlidXRlKCdjb3VudCcpO1xuICAgICAgICAgICAgZmllbGRzID0gZmllbGRzIHx8IHt9O1xuICAgICAgICAgICAgZmllbGRzW2ZpZWxkTmFtZV0gPSBmaWVsZHNbZmllbGROYW1lXSB8fCB7fTtcbiAgICAgICAgICAgIGZpZWxkc1tmaWVsZE5hbWVdLnJlbGF0aXZlVGltZSA9IGZpZWxkc1tmaWVsZE5hbWVdLnJlbGF0aXZlVGltZSB8fCB7fTtcbiAgICAgICAgICAgIGZpZWxkc1tmaWVsZE5hbWVdLnJlbGF0aXZlVGltZVt0eXBlXSA9IGZpZWxkc1tmaWVsZE5hbWVdLnJlbGF0aXZlVGltZVt0eXBlXSB8fCB7fTtcbiAgICAgICAgICAgIGZpZWxkc1tmaWVsZE5hbWVdLnJlbGF0aXZlVGltZVt0eXBlXVtjb3VudF0gPSBmaWVsZHNbZmllbGROYW1lXS5yZWxhdGl2ZVRpbWVbdHlwZV1bY291bnRdIHx8IHJlbGF0aXZlVGltZVBhdHRlcm5Ob2RlLnRleHRDb250ZW50XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmllbGRzO1xuICAgIH0sXG5cbiAgICBleHRyYWN0RGF0ZVRpbWVQYXR0ZXJuczogZnVuY3Rpb24gKGxvY2FsZUlkLCBjYWxlbmRhcklkKSB7XG4gICAgICAgIGNhbGVuZGFySWQgPSBjYWxlbmRhcklkIHx8ICdncmVnb3JpYW4nO1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBkYXRlVGltZVBhdHRlcm5zO1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC9kYXRlcy9jYWxlbmRhcnMvY2FsZW5kYXJbQHR5cGU9J1wiICsgY2FsZW5kYXJJZCArIFwiJ10vZGF0ZVRpbWVGb3JtYXRzL2RhdGVUaW1lRm9ybWF0TGVuZ3RoL2RhdGVUaW1lRm9ybWF0XCIpLmZvckVhY2goZnVuY3Rpb24gKGRhdGVUaW1lRm9ybWF0Tm9kZSkge1xuICAgICAgICAgICAgdmFyIGRhdGVUaW1lRm9ybWF0TGVuZ3RoVHlwZSA9IGRhdGVUaW1lRm9ybWF0Tm9kZS5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpLFxuICAgICAgICAgICAgICAgIHBhdHRlcm5Ob2RlcyA9IHhwYXRoLnNlbGVjdChcInBhdHRlcm5cIiwgZGF0ZVRpbWVGb3JtYXROb2RlKTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuTm9kZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBleGFjdGx5IG9uZSBwYXR0ZXJuIGluIGRhdGVUaW1lRm9ybWF0Tm9kZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0ZVRpbWVQYXR0ZXJucyA9IGRhdGVUaW1lUGF0dGVybnMgfHwge307XG4gICAgICAgICAgICBkYXRlVGltZVBhdHRlcm5zW2RhdGVUaW1lRm9ybWF0TGVuZ3RoVHlwZV0gPSBkYXRlVGltZVBhdHRlcm5zW2RhdGVUaW1lRm9ybWF0TGVuZ3RoVHlwZV0gfHwgcGF0dGVybk5vZGVzWzBdLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGVUaW1lUGF0dGVybnM7XG4gICAgfSxcblxuICAgIGV4dHJhY3REYXRlT3JUaW1lRm9ybWF0czogZnVuY3Rpb24gKGxvY2FsZUlkLCBjYWxlbmRhcklkLCBkYXRlT3JUaW1lKSB7XG4gICAgICAgIGNhbGVuZGFySWQgPSBjYWxlbmRhcklkIHx8ICdncmVnb3JpYW4nO1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBmb3JtYXRzO1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC9kYXRlcy9jYWxlbmRhcnMvY2FsZW5kYXJbQHR5cGU9J1wiICsgY2FsZW5kYXJJZCArIFwiJ10vXCIgKyBkYXRlT3JUaW1lICsgXCJGb3JtYXRzL1wiICsgZGF0ZU9yVGltZSArIFwiRm9ybWF0TGVuZ3RoL1wiICsgZGF0ZU9yVGltZSArIFwiRm9ybWF0LypcIikuZm9yRWFjaChmdW5jdGlvbiAocGF0dGVybk5vZGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gcGF0dGVybk5vZGUucGFyZW50Tm9kZS5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICAgICAgZm9ybWF0cyA9IGZvcm1hdHMgfHwge307XG4gICAgICAgICAgICBmb3JtYXRzW3R5cGVdID0gZm9ybWF0c1t0eXBlXSB8fCBwYXR0ZXJuTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3JtYXRzO1xuICAgIH0sXG5cbiAgICBleHRyYWN0RGF0ZUZvcm1hdHM6IGZ1bmN0aW9uIChsb2NhbGVJZCwgY2FsZW5kYXJJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHRyYWN0RGF0ZU9yVGltZUZvcm1hdHMobG9jYWxlSWQsIGNhbGVuZGFySWQsICdkYXRlJyk7XG4gICAgfSxcblxuICAgIGV4dHJhY3RUaW1lRm9ybWF0czogZnVuY3Rpb24gKGxvY2FsZUlkLCBjYWxlbmRhcklkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3REYXRlT3JUaW1lRm9ybWF0cyhsb2NhbGVJZCwgY2FsZW5kYXJJZCwgJ3RpbWUnKTtcbiAgICB9LFxuXG4gICAgZXh0cmFjdERhdGVGb3JtYXRJdGVtczogZnVuY3Rpb24gKGxvY2FsZUlkLCBjYWxlbmRhcklkKSB7XG4gICAgICAgIGNhbGVuZGFySWQgPSBjYWxlbmRhcklkIHx8ICdncmVnb3JpYW4nO1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBkYXRlRm9ybWF0SXRlbXM7XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2RhdGVzL2NhbGVuZGFycy9jYWxlbmRhcltAdHlwZT0nXCIgKyBjYWxlbmRhcklkICsgXCInXS9kYXRlVGltZUZvcm1hdHMvYXZhaWxhYmxlRm9ybWF0cy9kYXRlRm9ybWF0SXRlbVwiKS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRlRm9ybWF0SXRlbU5vZGUpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IGRhdGVGb3JtYXRJdGVtTm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgICAgICBkYXRlRm9ybWF0SXRlbXMgPSBkYXRlRm9ybWF0SXRlbXMgfHwge307XG4gICAgICAgICAgICBkYXRlRm9ybWF0SXRlbXNbaWRdID0gZGF0ZUZvcm1hdEl0ZW1zW2lkXSB8fCBkYXRlRm9ybWF0SXRlbU5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0ZUZvcm1hdEl0ZW1zO1xuICAgIH0sXG5cbiAgICBleHRyYWN0RGF0ZUludGVydmFsRm9ybWF0czogZnVuY3Rpb24gKGxvY2FsZUlkLCBjYWxlbmRhcklkKSB7XG4gICAgICAgIGNhbGVuZGFySWQgPSBjYWxlbmRhcklkIHx8ICdncmVnb3JpYW4nO1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBkYXRlSW50ZXJ2YWxGb3JtYXRzO1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC9kYXRlcy9jYWxlbmRhcnMvY2FsZW5kYXJbQHR5cGU9J1wiICsgY2FsZW5kYXJJZCArIFwiJ10vZGF0ZVRpbWVGb3JtYXRzL2ludGVydmFsRm9ybWF0cy9pbnRlcnZhbEZvcm1hdEl0ZW1cIikuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJ2YWxGb3JtYXRJdGVtTm9kZSkge1xuICAgICAgICAgICAgdmFyIGRhdGVJbnRlcnZhbEZvcm1hdCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgaW50ZXJ2YWxGb3JtYXRJdGVtTm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBncmVhdGVzdERpZmZlcmVuY2VOb2RlID0gaW50ZXJ2YWxGb3JtYXRJdGVtTm9kZS5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChncmVhdGVzdERpZmZlcmVuY2VOb2RlLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSBub2RlXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZ3JlYXRlc3REaWZmZXJlbmNlSWRBdHRyaWJ1dGUgPSBncmVhdGVzdERpZmZlcmVuY2VOb2RlLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JlYXRlc3REaWZmZXJlbmNlSWQgPSBncmVhdGVzdERpZmZlcmVuY2VJZEF0dHJpYnV0ZTtcbiAgICAgICAgICAgICAgICBkYXRlSW50ZXJ2YWxGb3JtYXRbZ3JlYXRlc3REaWZmZXJlbmNlSWRdID0gZGF0ZUludGVydmFsRm9ybWF0W2dyZWF0ZXN0RGlmZmVyZW5jZUlkXSB8fCBncmVhdGVzdERpZmZlcmVuY2VOb2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlkID0gaW50ZXJ2YWxGb3JtYXRJdGVtTm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgICAgICBkYXRlSW50ZXJ2YWxGb3JtYXRzID0gZGF0ZUludGVydmFsRm9ybWF0cyB8fCB7fTtcbiAgICAgICAgICAgIGRhdGVJbnRlcnZhbEZvcm1hdHNbaWRdID0gZGF0ZUludGVydmFsRm9ybWF0c1tpZF0gfHwgZGF0ZUludGVydmFsRm9ybWF0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGVJbnRlcnZhbEZvcm1hdHM7XG4gICAgfSxcblxuICAgIGV4dHJhY3REYXRlSW50ZXJ2YWxGYWxsYmFja0Zvcm1hdDogZnVuY3Rpb24gKGxvY2FsZUlkLCBjYWxlbmRhcklkKSB7XG4gICAgICAgIGNhbGVuZGFySWQgPSBjYWxlbmRhcklkIHx8ICdncmVnb3JpYW4nO1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBkYXRlSW50ZXJ2YWxGYWxsYmFja0Zvcm1hdDtcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvZGF0ZXMvY2FsZW5kYXJzL2NhbGVuZGFyW0B0eXBlPSdcIiArIGNhbGVuZGFySWQgKyBcIiddL2RhdGVUaW1lRm9ybWF0cy9pbnRlcnZhbEZvcm1hdHMvaW50ZXJ2YWxGb3JtYXRGYWxsYmFja1wiKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcnZhbEZvcm1hdEZhbGxiYWNrTm9kZSkge1xuICAgICAgICAgICAgZGF0ZUludGVydmFsRmFsbGJhY2tGb3JtYXQgPSBkYXRlSW50ZXJ2YWxGYWxsYmFja0Zvcm1hdCB8fCBpbnRlcnZhbEZvcm1hdEZhbGxiYWNrTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRlSW50ZXJ2YWxGYWxsYmFja0Zvcm1hdDtcbiAgICB9LFxuXG4gICAgLy8gTnVtYmVyIGV4dHJhY3Rpb24gY29kZTpcblxuICAgIGV4dHJhY3ROdW1iZXJTeW1ib2xzOiBmdW5jdGlvbiAobG9jYWxlSWQsIG51bWJlclN5c3RlbUlkKSB7XG4gICAgICAgIG51bWJlclN5c3RlbUlkID0gbnVtYmVyU3lzdGVtSWQgfHwgJ2xhdG4nO1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBudW1iZXJTeW1ib2xzO1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC9udW1iZXJzL3N5bWJvbHNbQG51bWJlclN5c3RlbSA9ICdcIiArIG51bWJlclN5c3RlbUlkICsgXCInXS8qW25hbWUoKSAhPSAnYWxpYXMnXVwiKS5jb25jYXQoZmluZGVyKFwiL2xkbWwvbnVtYmVycy9zeW1ib2xzLypbbmFtZSgpICE9ICdhbGlhcyddXCIpKS5mb3JFYWNoKGZ1bmN0aW9uIChudW1iZXJTeW1ib2xOb2RlKSB7XG4gICAgICAgICAgICB2YXIgc3ltYm9sSWQgPSBudW1iZXJTeW1ib2xOb2RlLm5vZGVOYW1lO1xuICAgICAgICAgICAgbnVtYmVyU3ltYm9scyA9IG51bWJlclN5bWJvbHMgfHwge307XG4gICAgICAgICAgICBudW1iZXJTeW1ib2xzW3N5bWJvbElkXSA9IG51bWJlclN5bWJvbHNbc3ltYm9sSWRdIHx8IG51bWJlclN5bWJvbE5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbnVtYmVyU3ltYm9scztcbiAgICB9LFxuXG4gICAgZXh0cmFjdE51bWJlckZvcm1hdHM6IGZ1bmN0aW9uIChsb2NhbGVJZCwgbnVtYmVyU3lzdGVtSWQpIHtcbiAgICAgICAgbnVtYmVyU3lzdGVtSWQgPSBudW1iZXJTeXN0ZW1JZCB8fCAnbGF0bic7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIG51bWJlckZvcm1hdHM7XG4gICAgICAgIFsnc2NpZW50aWZpYycsICdkZWNpbWFsJywgJ2N1cnJlbmN5JywgJ3BlcmNlbnQnXS5mb3JFYWNoKGZ1bmN0aW9uIChmb3JtYXRUeXBlKSB7XG4gICAgICAgICAgICBbJ2Z1bGwnLCAnbG9uZycsICdtZWRpdW0nLCAnc2hvcnQnXS5mb3JFYWNoKGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmaW5kZXIoXCIvbGRtbC9udW1iZXJzL1wiICsgZm9ybWF0VHlwZSArIFwiRm9ybWF0c1tAbnVtYmVyU3lzdGVtID0gJ1wiICsgbnVtYmVyU3lzdGVtSWQgKyBcIiddL1wiICsgZm9ybWF0VHlwZSArIFwiRm9ybWF0TGVuZ3RoW0B0eXBlPSdcIiArIGxlbmd0aCArIFwiJ10vXCIgKyBmb3JtYXRUeXBlICsgXCJGb3JtYXQvcGF0dGVyblwiKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXR0ZXJuTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHBhdHRlcm5Ob2RlLmdldEF0dHJpYnV0ZSgndHlwZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgPSBwYXR0ZXJuTm9kZS5nZXRBdHRyaWJ1dGUoJ2NvdW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIG51bWJlckZvcm1hdHMgPSBudW1iZXJGb3JtYXRzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBudW1iZXJGb3JtYXRzW2Zvcm1hdFR5cGVdID0gbnVtYmVyRm9ybWF0c1tmb3JtYXRUeXBlXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyRm9ybWF0c1tmb3JtYXRUeXBlXVtsZW5ndGhdID0gbnVtYmVyRm9ybWF0c1tmb3JtYXRUeXBlXVtsZW5ndGhdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBudW1iZXJGb3JtYXRzW2Zvcm1hdFR5cGVdW2xlbmd0aF1bdHlwZV0gPSBudW1iZXJGb3JtYXRzW2Zvcm1hdFR5cGVdW2xlbmd0aF1bdHlwZV0gfHwge307XG4gICAgICAgICAgICAgICAgICAgIG51bWJlckZvcm1hdHNbZm9ybWF0VHlwZV1bbGVuZ3RoXVt0eXBlXVtjb3VudF0gPSBudW1iZXJGb3JtYXRzW2Zvcm1hdFR5cGVdW2xlbmd0aF1bdHlwZV1bY291bnRdIHx8IHBhdHRlcm5Ob2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaW5kZXIoXCIvbGRtbC9udW1iZXJzL1wiICsgZm9ybWF0VHlwZSArIFwiRm9ybWF0c1tAbnVtYmVyU3lzdGVtID0gJ1wiICsgbnVtYmVyU3lzdGVtSWQgKyBcIiddL1wiICsgZm9ybWF0VHlwZSArIFwiRm9ybWF0TGVuZ3RoW25vdChAdHlwZSldL1wiICsgZm9ybWF0VHlwZSArIFwiRm9ybWF0L3BhdHRlcm5cIikuZm9yRWFjaChmdW5jdGlvbiAocGF0dGVybk5vZGUpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJGb3JtYXRzID0gbnVtYmVyRm9ybWF0cyB8fCB7fTtcbiAgICAgICAgICAgICAgICBudW1iZXJGb3JtYXRzW2Zvcm1hdFR5cGVdID0gbnVtYmVyRm9ybWF0c1tmb3JtYXRUeXBlXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBudW1iZXJGb3JtYXRzW2Zvcm1hdFR5cGVdLmRlZmF1bHQgPSBudW1iZXJGb3JtYXRzW2Zvcm1hdFR5cGVdLmRlZmF1bHQgfHwgcGF0dGVybk5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpbmRlcihcIi9sZG1sL251bWJlcnMvXCIgKyBmb3JtYXRUeXBlICsgXCJGb3JtYXRzW0BudW1iZXJTeXN0ZW0gPSAnXCIgKyBudW1iZXJTeXN0ZW1JZCArIFwiJ10vdW5pdFBhdHRlcm5cIikuZm9yRWFjaChmdW5jdGlvbiAodW5pdFBhdHRlcm5Ob2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gdW5pdFBhdHRlcm5Ob2RlLmdldEF0dHJpYnV0ZSgnY291bnQnKTtcbiAgICAgICAgICAgICAgICBudW1iZXJGb3JtYXRzID0gbnVtYmVyRm9ybWF0cyB8fCB7fTtcbiAgICAgICAgICAgICAgICBudW1iZXJGb3JtYXRzW2Zvcm1hdFR5cGVdID0gbnVtYmVyRm9ybWF0c1tmb3JtYXRUeXBlXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBudW1iZXJGb3JtYXRzW2Zvcm1hdFR5cGVdW2NvdW50XSA9IG51bWJlckZvcm1hdHNbZm9ybWF0VHlwZV1bY291bnRdIHx8IHVuaXRQYXR0ZXJuTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBmaW5kZXIoXCIvbGRtbC9udW1iZXJzL2N1cnJlbmN5Rm9ybWF0c1tAbnVtYmVyU3lzdGVtID0gJ1wiICsgbnVtYmVyU3lzdGVtSWQgKyBcIiddL2N1cnJlbmN5U3BhY2luZ1wiKS5mb3JFYWNoKGZ1bmN0aW9uIChjdXJyZW5jeVNwYWNpbmdOb2RlKSB7XG4gICAgICAgICAgICBudW1iZXJGb3JtYXRzID0gbnVtYmVyRm9ybWF0cyB8fCB7fTtcbiAgICAgICAgICAgIG51bWJlckZvcm1hdHMuY3VycmVuY3kgPSBudW1iZXJGb3JtYXRzLmN1cnJlbmN5IHx8IHt9O1xuICAgICAgICAgICAgbnVtYmVyRm9ybWF0cy5jdXJyZW5jeS5jdXJyZW5jeVNwYWNpbmcgPSBudW1iZXJGb3JtYXRzLmN1cnJlbmN5LmN1cnJlbmN5U3BhY2luZyB8fCB7fTtcblxuICAgICAgICAgICAgWydiZWZvcmUnLCAnYWZ0ZXInXS5mb3JFYWNoKGZ1bmN0aW9uIChwbGFjZSkge1xuICAgICAgICAgICAgICAgIHZhciBwbGFjZURhdGEgPSBudW1iZXJGb3JtYXRzLmN1cnJlbmN5LmN1cnJlbmN5U3BhY2luZ1twbGFjZSArICdDdXJyZW5jeSddID0gbnVtYmVyRm9ybWF0cy5jdXJyZW5jeS5jdXJyZW5jeVNwYWNpbmdbcGxhY2UgKyAnQ3VycmVuY3knXSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIFsnY3VycmVuY3lNYXRjaCcsICdzdXJyb3VuZGluZ01hdGNoJywgJ2luc2VydEJldHdlZW4nXS5mb3JFYWNoKGZ1bmN0aW9uIChzcGFjaW5nUHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHhwYXRoLnNlbGVjdChwbGFjZSArIFwiQ3VycmVuY3kvXCIgKyBzcGFjaW5nUHJvcGVydHlOYW1lLCBjdXJyZW5jeVNwYWNpbmdOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlckZvcm1hdHMuY3VycmVuY3kuY3VycmVuY3lTcGFjaW5nW3BsYWNlICsgJ0N1cnJlbmN5J11bc3BhY2luZ1Byb3BlcnR5TmFtZV0gPSBtYXRjaFswXS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgWydjdXJyZW5jeU1hdGNoJywgJ3N1cnJvdW5kaW5nTWF0Y2gnXS5mb3JFYWNoKGZ1bmN0aW9uIChzcGFjaW5nUHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbGFjZURhdGFbc3BhY2luZ1Byb3BlcnR5TmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlRGF0YVtzcGFjaW5nUHJvcGVydHlOYW1lXSA9IHVuaWNvZGVyZWdleHAuZXhwYW5kQ2xkclVuaWNvZGVTZXRJZFRvQ2hhcmFjdGVyQ2xhc3MocGxhY2VEYXRhW3NwYWNpbmdQcm9wZXJ0eU5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBudW1iZXJGb3JtYXRzO1xuICAgIH0sXG5cbiAgICBleHRyYWN0RGVmYXVsdE51bWJlclN5c3RlbUlkOiBmdW5jdGlvbiAobG9jYWxlSWQpIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgZGVmYXVsdE51bWJlclN5c3RlbUlkO1xuICAgICAgICBmaW5kZXIoJy9sZG1sL251bWJlcnMvZGVmYXVsdE51bWJlcmluZ1N5c3RlbScpLmZvckVhY2goZnVuY3Rpb24gKGRlZmF1bHROdW1iZXJpbmdTeXN0ZW1Ob2RlKSB7XG4gICAgICAgICAgICBkZWZhdWx0TnVtYmVyU3lzdGVtSWQgPSBkZWZhdWx0TnVtYmVyU3lzdGVtSWQgfHwgZGVmYXVsdE51bWJlcmluZ1N5c3RlbU5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmYXVsdE51bWJlclN5c3RlbUlkO1xuICAgIH0sXG5cbiAgICBleHRyYWN0VW5pdFBhdHRlcm5zOiBmdW5jdGlvbiAobG9jYWxlSWQpIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgdW5pdFBhdHRlcm5zID0ge307XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL3VuaXRzL3VuaXRMZW5ndGgvdW5pdC91bml0UGF0dGVyblwiKS5mb3JFYWNoKGZ1bmN0aW9uICh1bml0UGF0dGVybk5vZGUpIHtcbiAgICAgICAgICAgIHZhciB1bml0Tm9kZSA9IHVuaXRQYXR0ZXJuTm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgIHVuaXRMZW5ndGggPSB1bml0Tm9kZS5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpLFxuICAgICAgICAgICAgICAgIHVuaXRJZCA9IG5vcm1hbGl6ZVByb3BlcnR5KHVuaXROb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpKTtcbiAgICAgICAgICAgIHVuaXRQYXR0ZXJuc1t1bml0TGVuZ3RoXSA9IHVuaXRQYXR0ZXJuc1t1bml0TGVuZ3RoXSB8fCB7fTtcbiAgICAgICAgICAgIHVuaXRQYXR0ZXJuc1t1bml0TGVuZ3RoXS51bml0ID0gdW5pdFBhdHRlcm5zW3VuaXRMZW5ndGhdLnVuaXQgfHwge307XG4gICAgICAgICAgICB1bml0UGF0dGVybnNbdW5pdExlbmd0aF0udW5pdFt1bml0SWRdID0gdW5pdFBhdHRlcm5zW3VuaXRMZW5ndGhdLnVuaXRbdW5pdElkXSB8fCB7fTtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IHVuaXRQYXR0ZXJuTm9kZS5nZXRBdHRyaWJ1dGUoJ2NvdW50Jyk7XG4gICAgICAgICAgICB1bml0UGF0dGVybnNbdW5pdExlbmd0aF0udW5pdFt1bml0SWRdW2NvdW50XSA9IHVuaXRQYXR0ZXJuc1t1bml0TGVuZ3RoXS51bml0W3VuaXRJZF1bY291bnRdIHx8IHVuaXRQYXR0ZXJuTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL3VuaXRzL3VuaXRMZW5ndGgvY29tcG91bmRVbml0L2NvbXBvdW5kVW5pdFBhdHRlcm5cIikuZm9yRWFjaChmdW5jdGlvbiAoY29tcG91bmRVbml0UGF0dGVybk5vZGUpIHtcbiAgICAgICAgICAgIHZhciBjb21wb3VuZFVuaXROb2RlID0gY29tcG91bmRVbml0UGF0dGVybk5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICB1bml0TGVuZ3RoID0gY29tcG91bmRVbml0Tm9kZS5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpLFxuICAgICAgICAgICAgICAgIGNvbXBvdW5kVW5pdElkID0gY29tcG91bmRVbml0Tm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcblxuICAgICAgICAgICAgdW5pdFBhdHRlcm5zW3VuaXRMZW5ndGhdLmNvbXBvdW5kVW5pdCA9IHVuaXRQYXR0ZXJuc1t1bml0TGVuZ3RoXS5jb21wb3VuZFVuaXQgfHwge307XG4gICAgICAgICAgICB1bml0UGF0dGVybnNbdW5pdExlbmd0aF0uY29tcG91bmRVbml0W2NvbXBvdW5kVW5pdElkXSA9IGNvbXBvdW5kVW5pdFBhdHRlcm5Ob2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVuaXRQYXR0ZXJucztcbiAgICB9LFxuXG4gICAgZXh0cmFjdERlbGltaXRlcnM6IGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBkZWxpbWl0ZXJzID0ge307XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2RlbGltaXRlcnMvKlwiKS5mb3JFYWNoKGZ1bmN0aW9uIChkZWxpbWl0ZXJOb2RlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGRlbGltaXRlck5vZGUubm9kZU5hbWU7XG4gICAgICAgICAgICBkZWxpbWl0ZXJzW3R5cGVdID0gZGVsaW1pdGVyc1t0eXBlXSB8fCBkZWxpbWl0ZXJOb2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlbGltaXRlcnM7XG4gICAgfSxcblxuICAgIGV4dHJhY3RMaXN0UGF0dGVybnM6IGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBsaXN0UGF0dGVybnMgPSB7fTtcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvbGlzdFBhdHRlcm5zL2xpc3RQYXR0ZXJuL2xpc3RQYXR0ZXJuUGFydFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0UGF0dGVyblBhcnROb2RlKSB7XG4gICAgICAgICAgICB2YXIgbGlzdFBhdHRlcm5UeXBlQXR0cmlidXRlID0gbGlzdFBhdHRlcm5QYXJ0Tm9kZS5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpLFxuICAgICAgICAgICAgICAgIHR5cGUgPSBsaXN0UGF0dGVyblR5cGVBdHRyaWJ1dGUgPyBub3JtYWxpemVQcm9wZXJ0eShsaXN0UGF0dGVyblR5cGVBdHRyaWJ1dGUpIDogJ2RlZmF1bHQnLFxuICAgICAgICAgICAgICAgIHBhcnQgPSBsaXN0UGF0dGVyblBhcnROb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICAgICAgbGlzdFBhdHRlcm5zW3R5cGVdID0gbGlzdFBhdHRlcm5zW3R5cGVdIHx8IHt9O1xuICAgICAgICAgICAgbGlzdFBhdHRlcm5zW3R5cGVdW3BhcnRdID0gbGlzdFBhdHRlcm5zW3R5cGVdW3BhcnRdIHx8IGxpc3RQYXR0ZXJuUGFydE5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGlzdFBhdHRlcm5zO1xuICAgIH0sXG5cbiAgICBleHRyYWN0Q2hhcmFjdGVyczogZnVuY3Rpb24gKGxvY2FsZUlkKSB7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIGNoYXJhY3RlcnMgPSB7XG4gICAgICAgICAgICAgICAgZXhlbXBsYXI6IHt9LFxuICAgICAgICAgICAgICAgIGVsbGlwc2lzOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvY2hhcmFjdGVycy9leGVtcGxhckNoYXJhY3RlcnNcIikuZm9yRWFjaChmdW5jdGlvbiAoZXhlbXBsYXJDaGFyYWN0ZXJzTm9kZSkge1xuICAgICAgICAgICAgdmFyIHR5cGVBdHRyID0gZXhlbXBsYXJDaGFyYWN0ZXJzTm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSxcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZUF0dHIgfHwgJ2RlZmF1bHQnO1xuICAgICAgICAgICAgY2hhcmFjdGVycy5leGVtcGxhclt0eXBlXSA9IGNoYXJhY3RlcnMuZXhlbXBsYXJbdHlwZV0gfHwgZXhlbXBsYXJDaGFyYWN0ZXJzTm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2NoYXJhY3RlcnMvZWxsaXBzaXNcIikuZm9yRWFjaChmdW5jdGlvbiAoZWxsaXBzaXNOb2RlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGVsbGlwc2lzTm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgICAgIGNoYXJhY3RlcnMuZWxsaXBzaXNbdHlwZV0gPSBjaGFyYWN0ZXJzLmVsbGlwc2lzW3R5cGVdIHx8IGVsbGlwc2lzTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2NoYXJhY3RlcnMvbW9yZUluZm9ybWF0aW9uXCIpLmZvckVhY2goZnVuY3Rpb24gKG1vcmVJbmZvcm1hdGlvbk5vZGUpIHtcbiAgICAgICAgICAgIGNoYXJhY3RlcnMubW9yZUluZm9ybWF0aW9uID0gY2hhcmFjdGVycy5tb3JlSW5mb3JtYXRpb24gfHwgbW9yZUluZm9ybWF0aW9uTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjaGFyYWN0ZXJzO1xuICAgIH0sXG5cbiAgICBleHRyYWN0UGx1cmFsUnVsZUZ1bmN0aW9uOiBmdW5jdGlvbiAobG9jYWxlSWQpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgZG9jdW1lbnQgPSB0aGF0LmdldERvY3VtZW50KFBhdGgucmVzb2x2ZSh0aGF0LmNsZHJQYXRoLCAnY29tbW9uJywgJ3N1cHBsZW1lbnRhbCcsICdwbHVyYWxzLnhtbCcpKSxcbiAgICAgICAgICAgIHN1YkxvY2FsZUlkcyA9IGV4cGFuZExvY2FsZUlkVG9Qcmlvcml0aXplZExpc3QobG9jYWxlSWQpLFxuICAgICAgICAgICAgc3RhdGVtZW50QXN0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBzdWJMb2NhbGVJZHMubGVuZ3RoIDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgc3ViTG9jYWxlSWQgPSBzdWJMb2NhbGVJZHNbaV0sXG4gICAgICAgICAgICAgICAgbWF0Y2hMb2NhbGVzWFBhdGhFeHByID1cbiAgICAgICAgICAgICAgICAgICAgXCJAbG9jYWxlcyA9ICdcIiArIHN1YkxvY2FsZUlkICsgXCInIG9yIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJzdGFydHMtd2l0aChAbG9jYWxlcywgJ1wiICsgc3ViTG9jYWxlSWQgKyBcIicpIG9yIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJjb250YWlucyhAbG9jYWxlcywgJyBcIiArIHN1YkxvY2FsZUlkICsgXCIgJykgb3IgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInN1YnN0cmluZyhAbG9jYWxlcywgc3RyaW5nLWxlbmd0aChAbG9jYWxlcykgLSBzdHJpbmctbGVuZ3RoKCcgXCIgKyBzdWJMb2NhbGVJZCArIFwiJykgKyAxKSA9ICcgXCIgKyBzdWJMb2NhbGVJZCArIFwiJ1wiLFxuICAgICAgICAgICAgICAgIHBsdXJhbFJ1bGVzTm9kZXMgPSB4cGF0aC5zZWxlY3QoXCIvc3VwcGxlbWVudGFsRGF0YS9wbHVyYWxzL3BsdXJhbFJ1bGVzW1wiICsgbWF0Y2hMb2NhbGVzWFBhdGhFeHByICsgXCJdXCIsIGRvY3VtZW50KSxcbiAgICAgICAgICAgICAgICBjbGRyUGx1cmFsUnVsZVNldCA9IG5ldyBDbGRyUGx1cmFsUnVsZVNldCgpO1xuICAgICAgICAgICAgaWYgKHBsdXJhbFJ1bGVzTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHhwYXRoLnNlbGVjdChcInBsdXJhbFJ1bGVcIiwgcGx1cmFsUnVsZXNOb2Rlc1swXSkuZm9yRWFjaChmdW5jdGlvbiAocGx1cmFsUnVsZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xkclBsdXJhbFJ1bGVTZXQuYWRkUnVsZShwbHVyYWxSdWxlTm9kZS50ZXh0Q29udGVudCwgcGx1cmFsUnVsZU5vZGUuZ2V0QXR0cmlidXRlKCdjb3VudCcpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRBc3RzID0gY2xkclBsdXJhbFJ1bGVTZXQudG9KYXZhU2NyaXB0RnVuY3Rpb25Cb2R5QXN0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcIm5cIiwgdWdsaWZ5SnMudWdsaWZ5Lmdlbl9jb2RlKFsndG9wbGV2ZWwnLCBzdGF0ZW1lbnRBc3RzXSkpO1xuICAgIH0sXG5cbiAgICAvLyAndHlwZXMnIGlzIG9wdGlvbmFsLCBkZWZhdWx0cyB0byBhbGwgYXZhaWxhYmxlXG4gICAgZXh0cmFjdFJibmZGdW5jdGlvbkJ5VHlwZTogZnVuY3Rpb24gKGxvY2FsZUlkLCB0eXBlcykge1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ3JibmYnKSksXG4gICAgICAgICAgICBjbGRyUmJuZlJ1bGVTZXRCeVR5cGUgPSB7fTtcbiAgICAgICAgZmluZGVyKCcvbGRtbC9yYm5mL3J1bGVzZXRHcm91cGluZy9ydWxlc2V0L3JibmZydWxlJykuZm9yRWFjaChmdW5jdGlvbiAocmJuZlJ1bGVOb2RlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IENsZHJSYm5mUnVsZVNldC5nZXRTYWZlUmVuZGVyZXJOYW1lKHJibmZSdWxlTm9kZS5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpKSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHJibmZSdWxlTm9kZS5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICAgICAgICBjbGRyUmJuZlJ1bGVTZXRCeVR5cGVbdHlwZV0gPSBjbGRyUmJuZlJ1bGVTZXRCeVR5cGVbdHlwZV0gfHwgbmV3IENsZHJSYm5mUnVsZVNldCh7dHlwZTogdHlwZX0pO1xuICAgICAgICAgICAgaWYgKCFjbGRyUmJuZlJ1bGVTZXRCeVR5cGVbdHlwZV0ucnVsZUJ5VmFsdWVbdmFsdWVdKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhZGl4QXR0cmlidXRlID0gcmJuZlJ1bGVOb2RlLmdldEF0dHJpYnV0ZSgncmFkaXgnKTtcbiAgICAgICAgICAgICAgICBjbGRyUmJuZlJ1bGVTZXRCeVR5cGVbdHlwZV0ucnVsZUJ5VmFsdWVbdmFsdWVdID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHJibmY6IHJibmZSdWxlTm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKC87JC8sICcnKS5yZXBsYWNlKC/ihpAvZywgJzwnKS5yZXBsYWNlKC/ihpIvZywgJz4nKSxcbiAgICAgICAgICAgICAgICAgICAgcmFkaXg6IHJhZGl4QXR0cmlidXRlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpc0FkZGVkQnlUeXBlID0ge30sXG4gICAgICAgICAgICB0eXBlc1RvQWRkID0gdHlwZXMgPyBbXS5jb25jYXQodHlwZXMpIDogT2JqZWN0LmtleXMoY2xkclJibmZSdWxlU2V0QnlUeXBlKSxcbiAgICAgICAgICAgIHJibmZGdW5jdGlvbkJ5VHlwZSA9IHtcbiAgICAgICAgICAgICAgICByZW5kZXJOdW1iZXI6IFN0cmluZyAvLyBQcm92aWRlIGEgKGJhZCkgZGVmYXVsdCBudW1iZXIgcmVuZGVyaW5nIGltcGxlbWVudGF0aW9uIHRvIGF2b2lkICMxM1xuICAgICAgICAgICAgfTtcbiAgICAgICAgd2hpbGUgKHR5cGVzVG9BZGQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlc1RvQWRkLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoISh0eXBlIGluIGlzQWRkZWRCeVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaXNBZGRlZEJ5VHlwZVt0eXBlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIGNsZHJSYm5mUnVsZVNldCA9IGNsZHJSYm5mUnVsZVNldEJ5VHlwZVt0eXBlXTtcbiAgICAgICAgICAgICAgICAvLyBTb21lIHJ1bGVzIGFyZW4ndCBhdmFpbGFibGUgaW4gc29tZSBsb2NhbGVzIChzdWNoIGFzIHNwZWxsb3V0LWNhcmRpbmFsLWZpbmFuY2lhbCkuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGVhc2llc3QgdGhpbmcgaXMganVzdCB0byBza2lwIHRoZSBtaXNzaW5nIG9uZXMgaGVyZSwgZXZlbiB0aG91Z2ggaXQgY2FuIHByb2R1Y2VcbiAgICAgICAgICAgICAgICAvLyBzb21lIGJyb2tlbiBmdW5jdGlvbiBzZXRzOlxuICAgICAgICAgICAgICAgIGlmIChjbGRyUmJuZlJ1bGVTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNsZHJSYm5mUnVsZVNldC50b0Z1bmN0aW9uQXN0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmJuZkZ1bmN0aW9uQnlUeXBlW3R5cGVdID0gbmV3IEZ1bmN0aW9uKFwiblwiLCB1Z2xpZnlKcy51Z2xpZnkuZ2VuX2NvZGUoWyd0b3BsZXZlbCcsIHJlc3VsdC5mdW5jdGlvbkFzdFszXV0pKTtcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodHlwZXNUb0FkZCwgcmVzdWx0LmRlcGVuZGVuY2llcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYm5mRnVuY3Rpb25CeVR5cGU7XG4gICAgfSxcblxuICAgIGV4dHJhY3REaWdpdHNCeU51bWJlclN5c3RlbUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb2N1bWVudCA9IHRoaXMuZ2V0RG9jdW1lbnQoUGF0aC5yZXNvbHZlKHRoaXMuY2xkclBhdGgsICdjb21tb24nLCAnc3VwcGxlbWVudGFsJywgJ251bWJlcmluZ1N5c3RlbXMueG1sJykpLFxuICAgICAgICAgICAgZGlnaXRzQnlOdW1iZXJTeXN0ZW1JZCA9IHt9O1xuXG4gICAgICAgIHhwYXRoLnNlbGVjdCgnL3N1cHBsZW1lbnRhbERhdGEvbnVtYmVyaW5nU3lzdGVtcy9udW1iZXJpbmdTeXN0ZW0nLCBkb2N1bWVudCkuZm9yRWFjaChmdW5jdGlvbiAobnVtYmVyaW5nU3lzdGVtTm9kZSkge1xuICAgICAgICAgICAgdmFyIG51bWJlclN5c3RlbUlkID0gbnVtYmVyaW5nU3lzdGVtTm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgICAgICBpZiAobnVtYmVyaW5nU3lzdGVtTm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PT0gJ251bWVyaWMnKSB7XG4gICAgICAgICAgICAgICAgZGlnaXRzQnlOdW1iZXJTeXN0ZW1JZFtudW1iZXJTeXN0ZW1JZF0gPSBudW1iZXJpbmdTeXN0ZW1Ob2RlLmdldEF0dHJpYnV0ZSgnZGlnaXRzJykuc3BsaXQoLyg/OikvKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdHlwZT0nYWxnb3JpdGhtaWMnXG4gICAgICAgICAgICAgICAgdmFyIHJ1bGVzQXR0cmlidXRlRnJhZ21lbnRzID0gbnVtYmVyaW5nU3lzdGVtTm9kZS5nZXRBdHRyaWJ1dGUoJ3J1bGVzJykuc3BsaXQoJy8nKSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlTG9jYWxlSWQgPSBydWxlc0F0dHJpYnV0ZUZyYWdtZW50cy5sZW5ndGggPT09IDMgPyBub3JtYWxpemVMb2NhbGVJZChydWxlc0F0dHJpYnV0ZUZyYWdtZW50c1swXSkgOiAncm9vdCcsXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVUeXBlID0gQ2xkclJibmZSdWxlU2V0LmdldFNhZmVSZW5kZXJlck5hbWUocnVsZXNBdHRyaWJ1dGVGcmFnbWVudHNbcnVsZXNBdHRyaWJ1dGVGcmFnbWVudHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgIGRpZ2l0c0J5TnVtYmVyU3lzdGVtSWRbbnVtYmVyU3lzdGVtSWRdID0gcnVsZVR5cGU7IC8vIEEgc3RyaW5nIHZhbHVlIG1lYW5zIFwidXNlIHRoaXMgcmJuZiByZW5kZXJlciBmb3IgdGhlIGRpZ2l0c1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICByZXR1cm4gZGlnaXRzQnlOdW1iZXJTeXN0ZW1JZDtcbiAgICB9LFxuXG4gICAgZXh0cmFjdExheW91dDogZnVuY3Rpb24gKGxvY2FsZUlkKSB7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIGxheW91dCA9IHt9O1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC9sYXlvdXQvKi8qXCIpLmZvckVhY2goZnVuY3Rpb24gKGxlYWZOb2RlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGxlYWZOb2RlLm5vZGVOYW1lLFxuICAgICAgICAgICAgICAgIHBhcmVudFR5cGUgPSBsZWFmTm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lO1xuICAgICAgICAgICAgbGF5b3V0W3BhcmVudFR5cGVdID0gbGF5b3V0W3BhcmVudFR5cGVdIHx8IHt9O1xuICAgICAgICAgICAgbGF5b3V0W3BhcmVudFR5cGVdW3R5cGVdID0gbGF5b3V0W3BhcmVudFR5cGVdW3R5cGVdIHx8IGxlYWZOb2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGxheW91dDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBDbGRyKFBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuLi8zcmRwYXJ0eS9jbGRyLycpKTtcbm1vZHVsZS5leHBvcnRzLmxvYWQgPSBmdW5jdGlvbiAoY2xkclBhdGgpIHtcbiAgICByZXR1cm4gbmV3IENsZHIoY2xkclBhdGgpO1xufTtcbiIsImV4cG9ydHMuaSA9IGZ1bmN0aW9uIGkobikge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcbn07XG5cbmV4cG9ydHMudiA9IGZ1bmN0aW9uIHYobikge1xuICAgIHJldHVybiBuLnRvU3RyaW5nKCkucmVwbGFjZSgvXlteLl0qXFwuPy8sICcnKS5sZW5ndGg7XG59O1xuXG5leHBvcnRzLncgPSBmdW5jdGlvbiB3KG4pIHtcbiAgICByZXR1cm4gbi50b1N0cmluZygpLnJlcGxhY2UoL15bXi5dKlxcLj98MCskL2csICcnKS5sZW5ndGg7XG59O1xuXG5leHBvcnRzLmYgPSBmdW5jdGlvbiBmKG4pIHtcbiAgICByZXR1cm4gcGFyc2VJbnQobi50b1N0cmluZygpLnJlcGxhY2UoL15bXi5dKlxcLj8vLCAnJyksIDEwKSB8fCAwO1xufTtcblxuZXhwb3J0cy50ID0gZnVuY3Rpb24gdChuKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KG4udG9TdHJpbmcoKS5yZXBsYWNlKC9eW14uXSpcXC4/fDArJC9nLCAnJyksIDEwKSB8fCAwO1xufTtcbiIsIi8vIENvbnZlcnQgb2JqZWN0cyB3aXRoIGFsbCBpbnRlZ2VyIGtleXMgc3RhcnRpbmcgZnJvbSAwIHRvIGFycmF5cyBhbmQgcmVtb3ZlIHVuZGVmaW5lZCB2YWx1ZXM6XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbnZlcnRPYmplY3RzV2l0aEludGVnZXJLZXlzVG9BcnJheXMob2JqKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICByZXR1cm4gb2JqLm1hcChjb252ZXJ0T2JqZWN0c1dpdGhJbnRlZ2VyS2V5c1RvQXJyYXlzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGlmICgwIGluIG9iaiB8fCAxIGluIG9iaikge1xuICAgICAgICAgICAgdmFyIGZpcnN0TnVtZXJpY0tleU51bWJlciA9IDAgaW4gb2JqID8gMCA6IDEsXG4gICAgICAgICAgICAgICAgbmV4dE51bWVyaWNLZXlOdW1iZXIgPSBmaXJzdE51bWVyaWNLZXlOdW1iZXIgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKG5leHROdW1lcmljS2V5TnVtYmVyIGluIG9iaikge1xuICAgICAgICAgICAgICAgIG5leHROdW1lcmljS2V5TnVtYmVyICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggPiAwICYmIG5leHROdW1lcmljS2V5TnVtYmVyID09PSBrZXlzLmxlbmd0aCArIGZpcnN0TnVtZXJpY0tleU51bWJlcikge1xuICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAgOyBpIDwgZmlyc3ROdW1lcmljS2V5TnVtYmVyIDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5LnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpID0gZmlyc3ROdW1lcmljS2V5TnVtYmVyIDsgaSA8IGtleXMubGVuZ3RoIDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5LnB1c2goY29udmVydE9iamVjdHNXaXRoSW50ZWdlcktleXNUb0FycmF5cyhvYmpbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRPYmogPSB7fTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0T2JqW2tleV0gPSBjb252ZXJ0T2JqZWN0c1dpdGhJbnRlZ2VyS2V5c1RvQXJyYXlzKG9ialtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHRPYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG59O1xuIiwiLy8gQ3JlYXRlIGEgbWVtb2l6ZXIgZm9yIGFuIGFzeW5jIGZ1bmN0aW9uXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lbW9pemVBc3luYyhmbikge1xuICAgIHZhciByZXN1bHRBcmd1bWVudHMsXG4gICAgICAgIHdhaXRpbmdDYWxsYmFja3M7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIGlmIChyZXN1bHRBcmd1bWVudHMpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIHJlc3VsdEFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh3YWl0aW5nQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgd2FpdGluZ0NhbGxiYWNrcy5wdXNoKGNiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2FpdGluZ0NhbGxiYWNrcyA9IFtjYl07XG4gICAgICAgICAgICAgICAgZm4oZnVuY3Rpb24gKCkgeyAvLyAuLi5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdEFyZ3VtZW50cyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgd2FpdGluZ0NhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh3YWl0aW5nQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhaXRpbmdDYWxsYmFjay5hcHBseSh0aGlzLCByZXN1bHRBcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgd2FpdGluZ0NhbGxiYWNrcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcbiIsIi8qXG4gKiBSZXBsYWNlIC0gd2l0aCBfIGFuZCBjb252ZXJ0IHRvIGxvd2VyIGNhc2U6IGVuLUdCID0+IGVuX2diXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlSWQobG9jYWxlSWQpIHtcbiAgICByZXR1cm4gbG9jYWxlSWQgJiYgbG9jYWxlSWQucmVwbGFjZSgvLS9nLCAnXycpLnRvTG93ZXJDYXNlKCk7XG59O1xuIiwiLypcbiAqIENvbnZlcnQgZm9vLWJhciBhdHRyaWJ1dGUgdmFsdWVzIHRvIGZvb0JhciBKYXZhU2NyaXB0IGtleXNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVQcm9wZXJ0eShzdHIpIHtcblx0cmV0dXJuIHN0ci5yZXBsYWNlKC8tKFthLXpdKS9nLCBmdW5jdGlvbiAoJDAsIGNoKSB7XG4gICAgICAgIHJldHVybiBjaC50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFzc0Vycm9yKGVycm9yQ2FsbGJhY2ssIHN1Y2Nlc3NDYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7IC8vIC4uLlxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrKGVycik7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VjY2Vzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2suYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuIiwiLypcbiAqIFBFRy5qcyAwLjcuMFxuICpcbiAqIGh0dHA6Ly9wZWdqcy5tYWpkYS5jei9cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMiBEYXZpZCBNYWpkYVxuICogTGljZW5zZW5kIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xudmFyIFBFRyA9IChmdW5jdGlvbih1bmRlZmluZWQpIHtcblxudmFyIFBFRyA9IHtcbiAgLyogUEVHLmpzIHZlcnNpb24gKHVzZXMgc2VtYW50aWMgdmVyc2lvbmluZykuICovXG4gIFZFUlNJT046IFwiMC43LjBcIixcblxuICAvKlxuICAgKiBHZW5lcmF0ZXMgYSBwYXJzZXIgZnJvbSBhIHNwZWNpZmllZCBncmFtbWFyIGFuZCByZXR1cm5zIGl0LlxuICAgKlxuICAgKiBUaGUgZ3JhbW1hciBtdXN0IGJlIGEgc3RyaW5nIGluIHRoZSBmb3JtYXQgZGVzY3JpYmVkIGJ5IHRoZSBtZXRhZ3JhbWFyIGluXG4gICAqIHRoZSBwYXJzZXIucGVnanMgZmlsZS5cbiAgICpcbiAgICogVGhyb3dzIHxQRUcucGFyc2VyLlN5bnRheEVycm9yfCBpZiB0aGUgZ3JhbW1hciBjb250YWlucyBhIHN5bnRheCBlcnJvciBvclxuICAgKiB8UEVHLkdyYW1tYXJFcnJvcnwgaWYgaXQgY29udGFpbnMgYSBzZW1hbnRpYyBlcnJvci4gTm90ZSB0aGF0IG5vdCBhbGxcbiAgICogZXJyb3JzIGFyZSBkZXRlY3RlZCBkdXJpbmcgdGhlIGdlbmVyYXRpb24gYW5kIHNvbWUgbWF5IHByb3RydWRlIHRvIHRoZVxuICAgKiBnZW5lcmF0ZWQgcGFyc2VyIGFuZCBjYXVzZSBpdHMgbWFsZnVuY3Rpb24uXG4gICAqL1xuICBidWlsZFBhcnNlcjogZnVuY3Rpb24oZ3JhbW1hciwgb3B0aW9ucykge1xuICAgIHJldHVybiBQRUcuY29tcGlsZXIuY29tcGlsZShQRUcucGFyc2VyLnBhcnNlKGdyYW1tYXIpLCBvcHRpb25zKTtcbiAgfVxufTtcblxuLyogVGhyb3duIHdoZW4gdGhlIGdyYW1tYXIgY29udGFpbnMgYW4gZXJyb3IuICovXG5cblBFRy5HcmFtbWFyRXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9IFwiUEVHLkdyYW1tYXJFcnJvclwiO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufTtcblxuUEVHLkdyYW1tYXJFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbi8qIExpa2UgUHl0aG9uJ3MgfHJhbmdlfCwgYnV0IHdpdGhvdXQgfHN0ZXB8LiAqL1xuZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIHN0b3ApIHtcbiAgaWYgKHN0b3AgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0b3AgPSBzdGFydDtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KE1hdGgubWF4KDAsIHN0b3AgLSBzdGFydCkpO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IHN0YXJ0OyBqIDwgc3RvcDsgaSsrLCBqKyspIHtcbiAgICByZXN1bHRbaV0gPSBqO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZpbmQoYXJyYXksIGNhbGxiYWNrKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY2FsbGJhY2soYXJyYXlbaV0pKSB7XG4gICAgICByZXR1cm4gYXJyYXlbaV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGFycmF5LCB2YWx1ZSkge1xuICAvKlxuICAgKiBTdHVwaWQgSUUgZG9lcyBub3QgaGF2ZSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiwgb3RoZXJ3aXNlIHRoaXMgZnVuY3Rpb25cbiAgICogd291bGQgYmUgYSBvbmUtbGluZXIuXG4gICAqL1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZWFjaChhcnJheSwgY2FsbGJhY2spIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNhbGxiYWNrKGFycmF5W2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXAoYXJyYXksIGNhbGxiYWNrKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IGNhbGxiYWNrKGFycmF5W2ldLCBpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwbHVjayhhcnJheSwga2V5KSB7XG4gIHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uIChlKSB7IHJldHVybiBlW2tleV07IH0pO1xufVxuXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgcmVzdWx0LnB1c2gob2JqZWN0W2tleV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHBhZGRlZCBvbiB0aGUgbGVmdCB0byBhIGRlc2lyZWQgbGVuZ3RoIHdpdGggYSBjaGFyYWN0ZXIuXG4gKlxuICogVGhlIGNvZGUgbmVlZHMgdG8gYmUgaW4gc3luYyB3aXRoIHRoZSBjb2RlIHRlbXBsYXRlIGluIHRoZSBjb21waWxhdGlvblxuICogZnVuY3Rpb24gZm9yIFwiYWN0aW9uXCIgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIHBhZExlZnQoaW5wdXQsIHBhZGRpbmcsIGxlbmd0aCkge1xuICB2YXIgcmVzdWx0ID0gaW5wdXQ7XG5cbiAgdmFyIHBhZExlbmd0aCA9IGxlbmd0aCAtIGlucHV0Lmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRMZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdCA9IHBhZGRpbmcgKyByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKlxuICogUmV0dXJucyBhbiBlc2NhcGUgc2VxdWVuY2UgZm9yIGdpdmVuIGNoYXJhY3Rlci4gVXNlcyBcXHggZm9yIGNoYXJhY3RlcnMgPD1cbiAqIDB4RkYgdG8gc2F2ZSBzcGFjZSwgXFx1IGZvciB0aGUgcmVzdC5cbiAqXG4gKiBUaGUgY29kZSBuZWVkcyB0byBiZSBpbiBzeW5jIHdpdGggdGhlIGNvZGUgdGVtcGxhdGUgaW4gdGhlIGNvbXBpbGF0aW9uXG4gKiBmdW5jdGlvbiBmb3IgXCJhY3Rpb25cIiBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlKGNoKSB7XG4gIHZhciBjaGFyQ29kZSA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBlc2NhcGVDaGFyO1xuICB2YXIgbGVuZ3RoO1xuXG4gIGlmIChjaGFyQ29kZSA8PSAweEZGKSB7XG4gICAgZXNjYXBlQ2hhciA9ICd4JztcbiAgICBsZW5ndGggPSAyO1xuICB9IGVsc2Uge1xuICAgIGVzY2FwZUNoYXIgPSAndSc7XG4gICAgbGVuZ3RoID0gNDtcbiAgfVxuXG4gIHJldHVybiAnXFxcXCcgKyBlc2NhcGVDaGFyICsgcGFkTGVmdChjaGFyQ29kZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSwgJzAnLCBsZW5ndGgpO1xufVxuXG4vKlxuICogU3Vycm91bmRzIHRoZSBzdHJpbmcgd2l0aCBxdW90ZXMgYW5kIGVzY2FwZXMgY2hhcmFjdGVycyBpbnNpZGUgc28gdGhhdCB0aGVcbiAqIHJlc3VsdCBpcyBhIHZhbGlkIEphdmFTY3JpcHQgc3RyaW5nLlxuICpcbiAqIFRoZSBjb2RlIG5lZWRzIHRvIGJlIGluIHN5bmMgd2l0aCB0aGUgY29kZSB0ZW1wbGF0ZSBpbiB0aGUgY29tcGlsYXRpb25cbiAqIGZ1bmN0aW9uIGZvciBcImFjdGlvblwiIG5vZGVzLlxuICovXG5mdW5jdGlvbiBxdW90ZShzKSB7XG4gIC8qXG4gICAqIEVDTUEtMjYyLCA1dGggZWQuLCA3LjguNDogQWxsIGNoYXJhY3RlcnMgbWF5IGFwcGVhciBsaXRlcmFsbHkgaW4gYSBzdHJpbmdcbiAgICogbGl0ZXJhbCBleGNlcHQgZm9yIHRoZSBjbG9zaW5nIHF1b3RlIGNoYXJhY3RlciwgYmFja3NsYXNoLCBjYXJyaWFnZSByZXR1cm4sXG4gICAqIGxpbmUgc2VwYXJhdG9yLCBwYXJhZ3JhcGggc2VwYXJhdG9yLCBhbmQgbGluZSBmZWVkLiBBbnkgY2hhcmFjdGVyIG1heVxuICAgKiBhcHBlYXIgaW4gdGhlIGZvcm0gb2YgYW4gZXNjYXBlIHNlcXVlbmNlLlxuICAgKlxuICAgKiBGb3IgcG9ydGFiaWxpdHksIHdlIGFsc28gZXNjYXBlIGVzY2FwZSBhbGwgY29udHJvbCBhbmQgbm9uLUFTQ0lJXG4gICAqIGNoYXJhY3RlcnMuIE5vdGUgdGhhdCBcIlxcMFwiIGFuZCBcIlxcdlwiIGVzY2FwZSBzZXF1ZW5jZXMgYXJlIG5vdCB1c2VkIGJlY2F1c2VcbiAgICogSlNIaW50IGRvZXMgbm90IGxpa2UgdGhlIGZpcnN0IGFuZCBJRSB0aGUgc2Vjb25kLlxuICAgKi9cbiAgcmV0dXJuICdcIicgKyBzXG4gICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykgIC8vIGJhY2tzbGFzaFxuICAgIC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykgICAgLy8gY2xvc2luZyBxdW90ZSBjaGFyYWN0ZXJcbiAgICAucmVwbGFjZSgvXFx4MDgvZywgJ1xcXFxiJykgLy8gYmFja3NwYWNlXG4gICAgLnJlcGxhY2UoL1xcdC9nLCAnXFxcXHQnKSAgIC8vIGhvcml6b250YWwgdGFiXG4gICAgLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKSAgIC8vIGxpbmUgZmVlZFxuICAgIC5yZXBsYWNlKC9cXGYvZywgJ1xcXFxmJykgICAvLyBmb3JtIGZlZWRcbiAgICAucmVwbGFjZSgvXFxyL2csICdcXFxccicpICAgLy8gY2FycmlhZ2UgcmV0dXJuXG4gICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgwN1xceDBCXFx4MEUtXFx4MUZcXHg4MC1cXHVGRkZGXS9nLCBlc2NhcGUpXG4gICAgKyAnXCInO1xufVxuXG4vKlxuICogRXNjYXBlcyBjaGFyYWN0ZXJzIGluc2lkZSB0aGUgc3RyaW5nIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWQgYXMgYSBsaXN0IG9mXG4gKiBjaGFyYWN0ZXJzIGluIGEgY2hhcmFjdGVyIGNsYXNzIG9mIGEgcmVndWxhciBleHByZXNzaW9uLlxuICovXG5mdW5jdGlvbiBxdW90ZUZvclJlZ2V4cENsYXNzKHMpIHtcbiAgLypcbiAgICogQmFzZWQgb24gRUNNQS0yNjIsIDV0aCBlZC4sIDcuOC41ICYgMTUuMTAuMS5cbiAgICpcbiAgICogRm9yIHBvcnRhYmlsaXR5LCB3ZSBhbHNvIGVzY2FwZSBlc2NhcGUgYWxsIGNvbnRyb2wgYW5kIG5vbi1BU0NJSVxuICAgKiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgcmV0dXJuIHNcbiAgICAucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKSAgLy8gYmFja3NsYXNoXG4gICAgLnJlcGxhY2UoL1xcLy9nLCAnXFxcXC8nKSAgIC8vIGNsb3Npbmcgc2xhc2hcbiAgICAucmVwbGFjZSgvXFxdL2csICdcXFxcXScpICAgLy8gY2xvc2luZyBicmFja2V0XG4gICAgLnJlcGxhY2UoLy0vZywgJ1xcXFwtJykgICAgLy8gZGFzaFxuICAgIC5yZXBsYWNlKC9cXDAvZywgJ1xcXFwwJykgICAvLyBudWxsXG4gICAgLnJlcGxhY2UoL1xcdC9nLCAnXFxcXHQnKSAgIC8vIGhvcml6b250YWwgdGFiXG4gICAgLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKSAgIC8vIGxpbmUgZmVlZFxuICAgIC5yZXBsYWNlKC9cXHYvZywgJ1xcXFx4MEInKSAvLyB2ZXJ0aWNhbCB0YWJcbiAgICAucmVwbGFjZSgvXFxmL2csICdcXFxcZicpICAgLy8gZm9ybSBmZWVkXG4gICAgLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKSAgIC8vIGNhcnJpYWdlIHJldHVyblxuICAgIC5yZXBsYWNlKC9bXFx4MDEtXFx4MDhcXHgwRS1cXHgxRlxceDgwLVxcdUZGRkZdL2csIGVzY2FwZSk7XG59XG5cbi8qXG4gKiBCdWlsZHMgYSBub2RlIHZpc2l0b3IgLS0gYSBmdW5jdGlvbiB3aGljaCB0YWtlcyBhIG5vZGUgYW5kIGFueSBudW1iZXIgb2ZcbiAqIG90aGVyIHBhcmFtZXRlcnMsIGNhbGxzIGFuIGFwcHJvcHJpYXRlIGZ1bmN0aW9uIGFjY29yZGluZyB0byB0aGUgbm9kZSB0eXBlLFxuICogcGFzc2VzIGl0IGFsbCBpdHMgcGFyYW1ldGVycyBhbmQgcmV0dXJucyBpdHMgdmFsdWUuIFRoZSBmdW5jdGlvbnMgZm9yIHZhcmlvdXNcbiAqIG5vZGUgdHlwZXMgYXJlIHBhc3NlZCBpbiBhIHBhcmFtZXRlciB0byB8YnVpbGROb2RlVmlzaXRvcnwgYXMgYSBoYXNoLlxuICovXG5mdW5jdGlvbiBidWlsZE5vZGVWaXNpdG9yKGZ1bmN0aW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiBmdW5jdGlvbnNbbm9kZS50eXBlXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmaW5kUnVsZUJ5TmFtZShhc3QsIG5hbWUpIHtcbiAgcmV0dXJuIGZpbmQoYXN0LnJ1bGVzLCBmdW5jdGlvbihyKSB7IHJldHVybiByLm5hbWUgPT09IG5hbWU7IH0pO1xufVxuUEVHLnBhcnNlciA9IChmdW5jdGlvbigpe1xuICAvKlxuICAgKiBHZW5lcmF0ZWQgYnkgUEVHLmpzIDAuNy4wLlxuICAgKlxuICAgKiBodHRwOi8vcGVnanMubWFqZGEuY3ovXG4gICAqL1xuICBcbiAgZnVuY3Rpb24gcXVvdGUocykge1xuICAgIC8qXG4gICAgICogRUNNQS0yNjIsIDV0aCBlZC4sIDcuOC40OiBBbGwgY2hhcmFjdGVycyBtYXkgYXBwZWFyIGxpdGVyYWxseSBpbiBhXG4gICAgICogc3RyaW5nIGxpdGVyYWwgZXhjZXB0IGZvciB0aGUgY2xvc2luZyBxdW90ZSBjaGFyYWN0ZXIsIGJhY2tzbGFzaCxcbiAgICAgKiBjYXJyaWFnZSByZXR1cm4sIGxpbmUgc2VwYXJhdG9yLCBwYXJhZ3JhcGggc2VwYXJhdG9yLCBhbmQgbGluZSBmZWVkLlxuICAgICAqIEFueSBjaGFyYWN0ZXIgbWF5IGFwcGVhciBpbiB0aGUgZm9ybSBvZiBhbiBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBGb3IgcG9ydGFiaWxpdHksIHdlIGFsc28gZXNjYXBlIGVzY2FwZSBhbGwgY29udHJvbCBhbmQgbm9uLUFTQ0lJXG4gICAgICogY2hhcmFjdGVycy4gTm90ZSB0aGF0IFwiXFwwXCIgYW5kIFwiXFx2XCIgZXNjYXBlIHNlcXVlbmNlcyBhcmUgbm90IHVzZWRcbiAgICAgKiBiZWNhdXNlIEpTSGludCBkb2VzIG5vdCBsaWtlIHRoZSBmaXJzdCBhbmQgSUUgdGhlIHNlY29uZC5cbiAgICAgKi9cbiAgICAgcmV0dXJuICdcIicgKyBzXG4gICAgICAucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKSAgLy8gYmFja3NsYXNoXG4gICAgICAucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpICAgIC8vIGNsb3NpbmcgcXVvdGUgY2hhcmFjdGVyXG4gICAgICAucmVwbGFjZSgvXFx4MDgvZywgJ1xcXFxiJykgLy8gYmFja3NwYWNlXG4gICAgICAucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpICAgLy8gaG9yaXpvbnRhbCB0YWJcbiAgICAgIC5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJykgICAvLyBsaW5lIGZlZWRcbiAgICAgIC5yZXBsYWNlKC9cXGYvZywgJ1xcXFxmJykgICAvLyBmb3JtIGZlZWRcbiAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJykgICAvLyBjYXJyaWFnZSByZXR1cm5cbiAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MDdcXHgwQlxceDBFLVxceDFGXFx4ODAtXFx1RkZGRl0vZywgZXNjYXBlKVxuICAgICAgKyAnXCInO1xuICB9XG4gIFxuICB2YXIgcmVzdWx0ID0ge1xuICAgIC8qXG4gICAgICogUGFyc2VzIHRoZSBpbnB1dCB3aXRoIGEgZ2VuZXJhdGVkIHBhcnNlci4gSWYgdGhlIHBhcnNpbmcgaXMgc3VjY2Vzc2Z1bGwsXG4gICAgICogcmV0dXJucyBhIHZhbHVlIGV4cGxpY2l0bHkgb3IgaW1wbGljaXRseSBzcGVjaWZpZWQgYnkgdGhlIGdyYW1tYXIgZnJvbVxuICAgICAqIHdoaWNoIHRoZSBwYXJzZXIgd2FzIGdlbmVyYXRlZCAoc2VlIHxQRUcuYnVpbGRQYXJzZXJ8KS4gSWYgdGhlIHBhcnNpbmcgaXNcbiAgICAgKiB1bnN1Y2Nlc3NmdWwsIHRocm93cyB8UEVHLnBhcnNlci5TeW50YXhFcnJvcnwgZGVzY3JpYmluZyB0aGUgZXJyb3IuXG4gICAgICovXG4gICAgcGFyc2U6IGZ1bmN0aW9uKGlucHV0LCBzdGFydFJ1bGUpIHtcbiAgICAgIHZhciBwYXJzZUZ1bmN0aW9ucyA9IHtcbiAgICAgICAgXCJncmFtbWFyXCI6IHBhcnNlX2dyYW1tYXIsXG4gICAgICAgIFwiaW5pdGlhbGl6ZXJcIjogcGFyc2VfaW5pdGlhbGl6ZXIsXG4gICAgICAgIFwicnVsZVwiOiBwYXJzZV9ydWxlLFxuICAgICAgICBcImNob2ljZVwiOiBwYXJzZV9jaG9pY2UsXG4gICAgICAgIFwic2VxdWVuY2VcIjogcGFyc2Vfc2VxdWVuY2UsXG4gICAgICAgIFwibGFiZWxlZFwiOiBwYXJzZV9sYWJlbGVkLFxuICAgICAgICBcInByZWZpeGVkXCI6IHBhcnNlX3ByZWZpeGVkLFxuICAgICAgICBcInN1ZmZpeGVkXCI6IHBhcnNlX3N1ZmZpeGVkLFxuICAgICAgICBcInByaW1hcnlcIjogcGFyc2VfcHJpbWFyeSxcbiAgICAgICAgXCJhY3Rpb25cIjogcGFyc2VfYWN0aW9uLFxuICAgICAgICBcImJyYWNlZFwiOiBwYXJzZV9icmFjZWQsXG4gICAgICAgIFwibm9uQnJhY2VDaGFyYWN0ZXJzXCI6IHBhcnNlX25vbkJyYWNlQ2hhcmFjdGVycyxcbiAgICAgICAgXCJub25CcmFjZUNoYXJhY3RlclwiOiBwYXJzZV9ub25CcmFjZUNoYXJhY3RlcixcbiAgICAgICAgXCJlcXVhbHNcIjogcGFyc2VfZXF1YWxzLFxuICAgICAgICBcImNvbG9uXCI6IHBhcnNlX2NvbG9uLFxuICAgICAgICBcInNlbWljb2xvblwiOiBwYXJzZV9zZW1pY29sb24sXG4gICAgICAgIFwic2xhc2hcIjogcGFyc2Vfc2xhc2gsXG4gICAgICAgIFwiYW5kXCI6IHBhcnNlX2FuZCxcbiAgICAgICAgXCJub3RcIjogcGFyc2Vfbm90LFxuICAgICAgICBcInF1ZXN0aW9uXCI6IHBhcnNlX3F1ZXN0aW9uLFxuICAgICAgICBcInN0YXJcIjogcGFyc2Vfc3RhcixcbiAgICAgICAgXCJwbHVzXCI6IHBhcnNlX3BsdXMsXG4gICAgICAgIFwibHBhcmVuXCI6IHBhcnNlX2xwYXJlbixcbiAgICAgICAgXCJycGFyZW5cIjogcGFyc2VfcnBhcmVuLFxuICAgICAgICBcImRvdFwiOiBwYXJzZV9kb3QsXG4gICAgICAgIFwiaWRlbnRpZmllclwiOiBwYXJzZV9pZGVudGlmaWVyLFxuICAgICAgICBcImxpdGVyYWxcIjogcGFyc2VfbGl0ZXJhbCxcbiAgICAgICAgXCJzdHJpbmdcIjogcGFyc2Vfc3RyaW5nLFxuICAgICAgICBcImRvdWJsZVF1b3RlZFN0cmluZ1wiOiBwYXJzZV9kb3VibGVRdW90ZWRTdHJpbmcsXG4gICAgICAgIFwiZG91YmxlUXVvdGVkQ2hhcmFjdGVyXCI6IHBhcnNlX2RvdWJsZVF1b3RlZENoYXJhY3RlcixcbiAgICAgICAgXCJzaW1wbGVEb3VibGVRdW90ZWRDaGFyYWN0ZXJcIjogcGFyc2Vfc2ltcGxlRG91YmxlUXVvdGVkQ2hhcmFjdGVyLFxuICAgICAgICBcInNpbmdsZVF1b3RlZFN0cmluZ1wiOiBwYXJzZV9zaW5nbGVRdW90ZWRTdHJpbmcsXG4gICAgICAgIFwic2luZ2xlUXVvdGVkQ2hhcmFjdGVyXCI6IHBhcnNlX3NpbmdsZVF1b3RlZENoYXJhY3RlcixcbiAgICAgICAgXCJzaW1wbGVTaW5nbGVRdW90ZWRDaGFyYWN0ZXJcIjogcGFyc2Vfc2ltcGxlU2luZ2xlUXVvdGVkQ2hhcmFjdGVyLFxuICAgICAgICBcImNsYXNzXCI6IHBhcnNlX2NsYXNzLFxuICAgICAgICBcImNsYXNzQ2hhcmFjdGVyUmFuZ2VcIjogcGFyc2VfY2xhc3NDaGFyYWN0ZXJSYW5nZSxcbiAgICAgICAgXCJjbGFzc0NoYXJhY3RlclwiOiBwYXJzZV9jbGFzc0NoYXJhY3RlcixcbiAgICAgICAgXCJicmFja2V0RGVsaW1pdGVkQ2hhcmFjdGVyXCI6IHBhcnNlX2JyYWNrZXREZWxpbWl0ZWRDaGFyYWN0ZXIsXG4gICAgICAgIFwic2ltcGxlQnJhY2tldERlbGltaXRlZENoYXJhY3RlclwiOiBwYXJzZV9zaW1wbGVCcmFja2V0RGVsaW1pdGVkQ2hhcmFjdGVyLFxuICAgICAgICBcInNpbXBsZUVzY2FwZVNlcXVlbmNlXCI6IHBhcnNlX3NpbXBsZUVzY2FwZVNlcXVlbmNlLFxuICAgICAgICBcInplcm9Fc2NhcGVTZXF1ZW5jZVwiOiBwYXJzZV96ZXJvRXNjYXBlU2VxdWVuY2UsXG4gICAgICAgIFwiaGV4RXNjYXBlU2VxdWVuY2VcIjogcGFyc2VfaGV4RXNjYXBlU2VxdWVuY2UsXG4gICAgICAgIFwidW5pY29kZUVzY2FwZVNlcXVlbmNlXCI6IHBhcnNlX3VuaWNvZGVFc2NhcGVTZXF1ZW5jZSxcbiAgICAgICAgXCJlb2xFc2NhcGVTZXF1ZW5jZVwiOiBwYXJzZV9lb2xFc2NhcGVTZXF1ZW5jZSxcbiAgICAgICAgXCJkaWdpdFwiOiBwYXJzZV9kaWdpdCxcbiAgICAgICAgXCJoZXhEaWdpdFwiOiBwYXJzZV9oZXhEaWdpdCxcbiAgICAgICAgXCJsZXR0ZXJcIjogcGFyc2VfbGV0dGVyLFxuICAgICAgICBcImxvd2VyQ2FzZUxldHRlclwiOiBwYXJzZV9sb3dlckNhc2VMZXR0ZXIsXG4gICAgICAgIFwidXBwZXJDYXNlTGV0dGVyXCI6IHBhcnNlX3VwcGVyQ2FzZUxldHRlcixcbiAgICAgICAgXCJfX1wiOiBwYXJzZV9fXyxcbiAgICAgICAgXCJjb21tZW50XCI6IHBhcnNlX2NvbW1lbnQsXG4gICAgICAgIFwic2luZ2xlTGluZUNvbW1lbnRcIjogcGFyc2Vfc2luZ2xlTGluZUNvbW1lbnQsXG4gICAgICAgIFwibXVsdGlMaW5lQ29tbWVudFwiOiBwYXJzZV9tdWx0aUxpbmVDb21tZW50LFxuICAgICAgICBcImVvbFwiOiBwYXJzZV9lb2wsXG4gICAgICAgIFwiZW9sQ2hhclwiOiBwYXJzZV9lb2xDaGFyLFxuICAgICAgICBcIndoaXRlc3BhY2VcIjogcGFyc2Vfd2hpdGVzcGFjZVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgaWYgKHN0YXJ0UnVsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwYXJzZUZ1bmN0aW9uc1tzdGFydFJ1bGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJ1bGUgbmFtZTogXCIgKyBxdW90ZShzdGFydFJ1bGUpICsgXCIuXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydFJ1bGUgPSBcImdyYW1tYXJcIjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICB2YXIgcmVwb3J0RmFpbHVyZXMgPSAwO1xuICAgICAgdmFyIHJpZ2h0bW9zdEZhaWx1cmVzUG9zID0gMDtcbiAgICAgIHZhciByaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkID0gW107XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhZExlZnQoaW5wdXQsIHBhZGRpbmcsIGxlbmd0aCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gaW5wdXQ7XG4gICAgICAgIFxuICAgICAgICB2YXIgcGFkTGVuZ3RoID0gbGVuZ3RoIC0gaW5wdXQubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcGFkZGluZyArIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gZXNjYXBlKGNoKSB7XG4gICAgICAgIHZhciBjaGFyQ29kZSA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHZhciBlc2NhcGVDaGFyO1xuICAgICAgICB2YXIgbGVuZ3RoO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNoYXJDb2RlIDw9IDB4RkYpIHtcbiAgICAgICAgICBlc2NhcGVDaGFyID0gJ3gnO1xuICAgICAgICAgIGxlbmd0aCA9IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXNjYXBlQ2hhciA9ICd1JztcbiAgICAgICAgICBsZW5ndGggPSA0O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlQ2hhciArIHBhZExlZnQoY2hhckNvZGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCksICcwJywgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gbWF0Y2hGYWlsZWQoZmFpbHVyZSkge1xuICAgICAgICBpZiAocG9zIDwgcmlnaHRtb3N0RmFpbHVyZXNQb3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChwb3MgPiByaWdodG1vc3RGYWlsdXJlc1Bvcykge1xuICAgICAgICAgIHJpZ2h0bW9zdEZhaWx1cmVzUG9zID0gcG9zO1xuICAgICAgICAgIHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZC5wdXNoKGZhaWx1cmUpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9ncmFtbWFyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MztcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICByZXN1bHQwID0gcGFyc2VfX18oKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfaW5pdGlhbGl6ZXIoKTtcbiAgICAgICAgICByZXN1bHQxID0gcmVzdWx0MSAhPT0gbnVsbCA/IHJlc3VsdDEgOiBcIlwiO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQzID0gcGFyc2VfcnVsZSgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IFtdO1xuICAgICAgICAgICAgICB3aGlsZSAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIucHVzaChyZXN1bHQzKTtcbiAgICAgICAgICAgICAgICByZXN1bHQzID0gcGFyc2VfcnVsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0Ml07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGluaXRpYWxpemVyLCBydWxlcykge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgICBcImdyYW1tYXJcIixcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplcjogaW5pdGlhbGl6ZXIgIT09IFwiXCIgPyBpbml0aWFsaXplciA6IG51bGwsXG4gICAgICAgICAgICAgICAgcnVsZXM6ICAgICAgIHJ1bGVzLFxuICAgICAgICAgICAgICAgIHN0YXJ0UnVsZTogICBydWxlc1swXS5uYW1lXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzFdLCByZXN1bHQwWzJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2luaXRpYWxpemVyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICByZXN1bHQwID0gcGFyc2VfYWN0aW9uKCk7XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX3NlbWljb2xvbigpO1xuICAgICAgICAgIHJlc3VsdDEgPSByZXN1bHQxICE9PSBudWxsID8gcmVzdWx0MSA6IFwiXCI7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBjb2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbml0aWFsaXplclwiLFxuICAgICAgICAgICAgICAgIGNvZGU6IGNvZGVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfcnVsZSgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDMsIHJlc3VsdDQ7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2lkZW50aWZpZXIoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2Vfc3RyaW5nKCk7XG4gICAgICAgICAgcmVzdWx0MSA9IHJlc3VsdDEgIT09IG51bGwgPyByZXN1bHQxIDogXCJcIjtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX2VxdWFscygpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MyA9IHBhcnNlX2Nob2ljZSgpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDQgPSBwYXJzZV9zZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgICByZXN1bHQ0ID0gcmVzdWx0NCAhPT0gbnVsbCA/IHJlc3VsdDQgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDMsIHJlc3VsdDRdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgbmFtZSwgZGlzcGxheU5hbWUsIGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAgICAgICAgXCJydWxlXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lICE9PSBcIlwiID8gZGlzcGxheU5hbWUgOiBudWxsLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246ICBleHByZXNzaW9uXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzBdLCByZXN1bHQwWzFdLCByZXN1bHQwWzNdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2Nob2ljZSgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDM7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxLCBwb3MyO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3NlcXVlbmNlKCk7XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IFtdO1xuICAgICAgICAgIHBvczIgPSBwb3M7XG4gICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX3NsYXNoKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDMgPSBwYXJzZV9zZXF1ZW5jZSgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IFtyZXN1bHQyLCByZXN1bHQzXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQxLnB1c2gocmVzdWx0Mik7XG4gICAgICAgICAgICBwb3MyID0gcG9zO1xuICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX3NsYXNoKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQzID0gcGFyc2Vfc2VxdWVuY2UoKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gW3Jlc3VsdDIsIHJlc3VsdDNdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHBvcyA9IHBvczI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGhlYWQsIHRhaWwpIHtcbiAgICAgICAgICAgICAgaWYgKHRhaWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBhbHRlcm5hdGl2ZXMgPSBbaGVhZF0uY29uY2F0KG1hcChcbiAgICAgICAgICAgICAgICAgICAgdGFpbCxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudFsxXTsgfVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAgICAgICAgIFwiY2hvaWNlXCIsXG4gICAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZXM6IGFsdGVybmF0aXZlc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMF0sIHJlc3VsdDBbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc2VxdWVuY2UoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIHJlc3VsdDAgPSBbXTtcbiAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2xhYmVsZWQoKTtcbiAgICAgICAgd2hpbGUgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwLnB1c2gocmVzdWx0MSk7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2xhYmVsZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9hY3Rpb24oKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGVsZW1lbnRzLCBjb2RlKSB7XG4gICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gZWxlbWVudHMubGVuZ3RoICE9PSAxXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgICBcInNlcXVlbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogZWxlbWVudHNbMF07XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIGNvZGU6ICAgICAgIGNvZGVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMF0sIHJlc3VsdDBbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgcmVzdWx0MCA9IFtdO1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9sYWJlbGVkKCk7XG4gICAgICAgICAgd2hpbGUgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAucHVzaChyZXN1bHQxKTtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9sYWJlbGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudHMubGVuZ3RoICE9PSAxXG4gICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAgICAgXCJzZXF1ZW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICA6IGVsZW1lbnRzWzBdO1xuICAgICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9sYWJlbGVkKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICByZXN1bHQwID0gcGFyc2VfaWRlbnRpZmllcigpO1xuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9jb2xvbigpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfcHJlZml4ZWQoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0Ml07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGxhYmVsLCBleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJsYWJlbGVkXCIsXG4gICAgICAgICAgICAgICAgbGFiZWw6ICAgICAgbGFiZWwsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvblxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3ByZWZpeGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3ByZWZpeGVkKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICByZXN1bHQwID0gcGFyc2VfYW5kKCk7XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2FjdGlvbigpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgY29kZSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic2VtYW50aWNfYW5kXCIsXG4gICAgICAgICAgICAgICAgY29kZTogY29kZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9hbmQoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX3N1ZmZpeGVkKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgIFwic2ltcGxlX2FuZFwiLFxuICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX25vdCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2FjdGlvbigpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgY29kZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZW1hbnRpY19ub3RcIixcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29kZVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2Vfbm90KCk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX3N1ZmZpeGVkKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJzaW1wbGVfbm90XCIsXG4gICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3N1ZmZpeGVkKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3N1ZmZpeGVkKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICByZXN1bHQwID0gcGFyc2VfcHJpbWFyeSgpO1xuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9xdWVzdGlvbigpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgIFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3ByaW1hcnkoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX3N0YXIoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJ6ZXJvX29yX21vcmVcIixcbiAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9wcmltYXJ5KCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQxID0gcGFyc2VfcGx1cygpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJvbmVfb3JfbW9yZVwiLFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9wcmltYXJ5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9wcmltYXJ5KCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgdmFyIHBvczAsIHBvczEsIHBvczIsIHBvczM7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICByZXN1bHQwID0gcGFyc2VfaWRlbnRpZmllcigpO1xuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHBvczIgPSBwb3M7XG4gICAgICAgICAgcmVwb3J0RmFpbHVyZXMrKztcbiAgICAgICAgICBwb3MzID0gcG9zO1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9zdHJpbmcoKTtcbiAgICAgICAgICByZXN1bHQxID0gcmVzdWx0MSAhPT0gbnVsbCA/IHJlc3VsdDEgOiBcIlwiO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfZXF1YWxzKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQxID0gW3Jlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVwb3J0RmFpbHVyZXMtLTtcbiAgICAgICAgICBpZiAocmVzdWx0MSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MSA9IFwiXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBuYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJydWxlX3JlZlwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9saXRlcmFsKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfZG90KCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4geyB0eXBlOiBcImFueVwiIH07IH0pKHBvczApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9jbGFzcygpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfbHBhcmVuKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9jaG9pY2UoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9ycGFyZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgZXhwcmVzc2lvbikgeyByZXR1cm4gZXhwcmVzc2lvbjsgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfYWN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICByZXBvcnRGYWlsdXJlcysrO1xuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICByZXN1bHQwID0gcGFyc2VfYnJhY2VkKCk7XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX19fKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBicmFjZWQpIHsgcmV0dXJuIGJyYWNlZC5zdWJzdHIoMSwgYnJhY2VkLmxlbmd0aCAtIDIpOyB9KShwb3MwLCByZXN1bHQwWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmVwb3J0RmFpbHVyZXMtLTtcbiAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwICYmIHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBtYXRjaEZhaWxlZChcImFjdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfYnJhY2VkKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAxMjMpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCJ7XCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJ7XFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gW107XG4gICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX2JyYWNlZCgpO1xuICAgICAgICAgIGlmIChyZXN1bHQyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gcGFyc2Vfbm9uQnJhY2VDaGFyYWN0ZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDEucHVzaChyZXN1bHQyKTtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9icmFjZWQoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9ub25CcmFjZUNoYXJhY3RlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMTI1KSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBcIn1cIjtcbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwifVxcXCJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0Ml07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIHBhcnRzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcIntcIiArIHBhcnRzLmpvaW4oXCJcIikgKyBcIn1cIjtcbiAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfbm9uQnJhY2VDaGFyYWN0ZXJzKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczA7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICByZXN1bHQxID0gcGFyc2Vfbm9uQnJhY2VDaGFyYWN0ZXIoKTtcbiAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gW107XG4gICAgICAgICAgd2hpbGUgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAucHVzaChyZXN1bHQxKTtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9ub25CcmFjZUNoYXJhY3RlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBjaGFycykgeyByZXR1cm4gY2hhcnMuam9pbihcIlwiKTsgfSkocG9zMCwgcmVzdWx0MCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9ub25CcmFjZUNoYXJhY3RlcigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgIFxuICAgICAgICBpZiAoL15bXnt9XS8udGVzdChpbnB1dC5jaGFyQXQocG9zKSkpIHtcbiAgICAgICAgICByZXN1bHQwID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIltee31dXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfZXF1YWxzKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA2MSkge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIj1cIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIj1cXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9fXygpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCI9XCI7IH0pKHBvczApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfY29sb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDU4KSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiOlwiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiOlxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX19fKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIjpcIjsgfSkocG9zMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zZW1pY29sb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDU5KSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiO1wiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiO1xcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX19fKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIjtcIjsgfSkocG9zMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zbGFzaCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDcpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCIvXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIvXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfX18oKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIFwiL1wiOyB9KShwb3MwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2FuZCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMzgpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCImXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCImXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfX18oKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIFwiJlwiOyB9KShwb3MwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX25vdCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMzMpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCIhXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIhXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfX18oKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIFwiIVwiOyB9KShwb3MwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3F1ZXN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA2Mykge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIj9cIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIj9cXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9fXygpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCI/XCI7IH0pKHBvczApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc3RhcigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDIpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCIqXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIqXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfX18oKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIFwiKlwiOyB9KShwb3MwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3BsdXMoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDQzKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiK1wiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiK1xcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX19fKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIitcIjsgfSkocG9zMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9scGFyZW4oKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDQwKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiKFwiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiKFxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX19fKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIihcIjsgfSkocG9zMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9ycGFyZW4oKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDQxKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiKVwiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiKVxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX19fKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIilcIjsgfSkocG9zMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9kb3QoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDQ2KSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiLlwiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiLlxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX19fKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIi5cIjsgfSkocG9zMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9pZGVudGlmaWVyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICByZXBvcnRGYWlsdXJlcysrO1xuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICByZXN1bHQwID0gcGFyc2VfbGV0dGVyKCk7XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gOTUpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBcIl9cIjtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJfXFxcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDM2KSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBcIiRcIjtcbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiJFxcXCJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gW107XG4gICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX2xldHRlcigpO1xuICAgICAgICAgIGlmIChyZXN1bHQyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfZGlnaXQoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDk1KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiA9IFwiX1wiO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiX1xcXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMzYpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBcIiRcIjtcbiAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIkXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDEucHVzaChyZXN1bHQyKTtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9sZXR0ZXIoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9kaWdpdCgpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0MiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDk1KSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQyID0gXCJfXCI7XG4gICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiX1xcXCJcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAzNikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gXCIkXCI7XG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIiRcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfX18oKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0Ml07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGhlYWQsIHRhaWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsLmpvaW4oXCJcIik7XG4gICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzBdLCByZXN1bHQwWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmVwb3J0RmFpbHVyZXMtLTtcbiAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwICYmIHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBtYXRjaEZhaWxlZChcImlkZW50aWZpZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2xpdGVyYWwoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHJlcG9ydEZhaWx1cmVzKys7XG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV9kb3VibGVRdW90ZWRTdHJpbmcoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gcGFyc2Vfc2luZ2xlUXVvdGVkU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAxMDUpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBcImlcIjtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJpXFxcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0MSA9IHJlc3VsdDEgIT09IG51bGwgPyByZXN1bHQxIDogXCJcIjtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX19fKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAgICAgICBcImxpdGVyYWxcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBpZ25vcmVDYXNlOiBmbGFncyA9PT0gXCJpXCJcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMF0sIHJlc3VsdDBbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXBvcnRGYWlsdXJlcy0tO1xuICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDAgJiYgcmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIG1hdGNoRmFpbGVkKFwibGl0ZXJhbFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc3RyaW5nKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICByZXBvcnRGYWlsdXJlcysrO1xuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICByZXN1bHQwID0gcGFyc2VfZG91YmxlUXVvdGVkU3RyaW5nKCk7XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3NpbmdsZVF1b3RlZFN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX19fKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBzdHJpbmcpIHsgcmV0dXJuIHN0cmluZzsgfSkocG9zMCwgcmVzdWx0MFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJlcG9ydEZhaWx1cmVzLS07XG4gICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCAmJiByZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgbWF0Y2hGYWlsZWQoXCJzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2RvdWJsZVF1b3RlZFN0cmluZygpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMzQpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCJcXFwiXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcIlxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IFtdO1xuICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9kb3VibGVRdW90ZWRDaGFyYWN0ZXIoKTtcbiAgICAgICAgICB3aGlsZSAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MS5wdXNoKHJlc3VsdDIpO1xuICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX2RvdWJsZVF1b3RlZENoYXJhY3RlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMzQpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IFwiXFxcIlwiO1xuICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcIlxcXCJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0Ml07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGNoYXJzKSB7IHJldHVybiBjaGFycy5qb2luKFwiXCIpOyB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2RvdWJsZVF1b3RlZENoYXJhY3RlcigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgIFxuICAgICAgICByZXN1bHQwID0gcGFyc2Vfc2ltcGxlRG91YmxlUXVvdGVkQ2hhcmFjdGVyKCk7XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3NpbXBsZUVzY2FwZVNlcXVlbmNlKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV96ZXJvRXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9oZXhFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV91bmljb2RlRXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2VvbEVzY2FwZVNlcXVlbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zaW1wbGVEb3VibGVRdW90ZWRDaGFyYWN0ZXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMSwgcG9zMjtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIHBvczIgPSBwb3M7XG4gICAgICAgIHJlcG9ydEZhaWx1cmVzKys7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDM0KSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiXFxcIlwiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXCJcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDkyKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gXCJcXFxcXCI7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXFxcXFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2VvbENoYXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVwb3J0RmFpbHVyZXMtLTtcbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IHBvcykge1xuICAgICAgICAgICAgcmVzdWx0MSA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiYW55IGNoYXJhY3RlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBjaGFyXykgeyByZXR1cm4gY2hhcl87IH0pKHBvczAsIHJlc3VsdDBbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc2luZ2xlUXVvdGVkU3RyaW5nKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAzOSkge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIidcIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIidcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBbXTtcbiAgICAgICAgICByZXN1bHQyID0gcGFyc2Vfc2luZ2xlUXVvdGVkQ2hhcmFjdGVyKCk7XG4gICAgICAgICAgd2hpbGUgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDEucHVzaChyZXN1bHQyKTtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9zaW5nbGVRdW90ZWRDaGFyYWN0ZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDM5KSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBcIidcIjtcbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiJ1xcXCJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0Ml07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGNoYXJzKSB7IHJldHVybiBjaGFycy5qb2luKFwiXCIpOyB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3NpbmdsZVF1b3RlZENoYXJhY3RlcigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgIFxuICAgICAgICByZXN1bHQwID0gcGFyc2Vfc2ltcGxlU2luZ2xlUXVvdGVkQ2hhcmFjdGVyKCk7XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3NpbXBsZUVzY2FwZVNlcXVlbmNlKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV96ZXJvRXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9oZXhFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV91bmljb2RlRXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2VvbEVzY2FwZVNlcXVlbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zaW1wbGVTaW5nbGVRdW90ZWRDaGFyYWN0ZXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMSwgcG9zMjtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIHBvczIgPSBwb3M7XG4gICAgICAgIHJlcG9ydEZhaWx1cmVzKys7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDM5KSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiJ1wiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiJ1xcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gOTIpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXFxcIjtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXFxcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfZW9sQ2hhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXBvcnRGYWlsdXJlcy0tO1xuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gcG9zKSB7XG4gICAgICAgICAgICByZXN1bHQxID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJhbnkgY2hhcmFjdGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGNoYXJfKSB7IHJldHVybiBjaGFyXzsgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9jbGFzcygpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDMsIHJlc3VsdDQsIHJlc3VsdDU7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcmVwb3J0RmFpbHVyZXMrKztcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gOTEpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCJbXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJbXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA5NCkge1xuICAgICAgICAgICAgcmVzdWx0MSA9IFwiXlwiO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIl5cXFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQxID0gcmVzdWx0MSAhPT0gbnVsbCA/IHJlc3VsdDEgOiBcIlwiO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gW107XG4gICAgICAgICAgICByZXN1bHQzID0gcGFyc2VfY2xhc3NDaGFyYWN0ZXJSYW5nZSgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MyA9IHBhcnNlX2NsYXNzQ2hhcmFjdGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQyLnB1c2gocmVzdWx0Myk7XG4gICAgICAgICAgICAgIHJlc3VsdDMgPSBwYXJzZV9jbGFzc0NoYXJhY3RlclJhbmdlKCk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MyA9IHBhcnNlX2NsYXNzQ2hhcmFjdGVyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDkzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MyA9IFwiXVwiO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXVxcXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMTA1KSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQ0ID0gXCJpXCI7XG4gICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0NCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiaVxcXCJcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdDQgPSByZXN1bHQ0ICE9PSBudWxsID8gcmVzdWx0NCA6IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDUgPSBwYXJzZV9fXygpO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzLCByZXN1bHQ0LCByZXN1bHQ1XTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgaW52ZXJ0ZWQsIHBhcnRzLCBmbGFncykge1xuICAgICAgICAgICAgICB2YXIgcGFydHNDb252ZXJ0ZWQgPSBtYXAocGFydHMsIGZ1bmN0aW9uKHBhcnQpIHsgcmV0dXJuIHBhcnQuZGF0YTsgfSk7XG4gICAgICAgICAgICAgIHZhciByYXdUZXh0ID0gXCJbXCJcbiAgICAgICAgICAgICAgICArIGludmVydGVkXG4gICAgICAgICAgICAgICAgKyBtYXAocGFydHMsIGZ1bmN0aW9uKHBhcnQpIHsgcmV0dXJuIHBhcnQucmF3VGV4dDsgfSkuam9pbihcIlwiKVxuICAgICAgICAgICAgICAgICsgXCJdXCJcbiAgICAgICAgICAgICAgICArIGZsYWdzO1xuICAgICAgICBcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAgICAgICBcImNsYXNzXCIsXG4gICAgICAgICAgICAgICAgaW52ZXJ0ZWQ6ICAgaW52ZXJ0ZWQgPT09IFwiXlwiLFxuICAgICAgICAgICAgICAgIGlnbm9yZUNhc2U6IGZsYWdzID09PSBcImlcIixcbiAgICAgICAgICAgICAgICBwYXJ0czogICAgICBwYXJ0c0NvbnZlcnRlZCxcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogR2V0IHRoZSByYXcgdGV4dCBmcm9tIHRoZSBpbnB1dCBkaXJlY3RseS5cbiAgICAgICAgICAgICAgICByYXdUZXh0OiAgICByYXdUZXh0XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzFdLCByZXN1bHQwWzJdLCByZXN1bHQwWzRdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmVwb3J0RmFpbHVyZXMtLTtcbiAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwICYmIHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBtYXRjaEZhaWxlZChcImNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfY2xhc3NDaGFyYWN0ZXJSYW5nZSgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2NsYXNzQ2hhcmFjdGVyKCk7XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDUpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBcIi1cIjtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCItXFxcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9jbGFzc0NoYXJhY3RlcigpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgYmVnaW4sIGVuZCkge1xuICAgICAgICAgICAgICBpZiAoYmVnaW4uZGF0YS5jaGFyQ29kZUF0KDApID4gZW5kLmRhdGEuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyB0aGlzLlN5bnRheEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJJbnZhbGlkIGNoYXJhY3RlciByYW5nZTogXCIgKyBiZWdpbi5yYXdUZXh0ICsgXCItXCIgKyBlbmQucmF3VGV4dCArIFwiLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiAgICBbYmVnaW4uZGF0YSwgZW5kLmRhdGFdLFxuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBHZXQgdGhlIHJhdyB0ZXh0IGZyb20gdGhlIGlucHV0IGRpcmVjdGx5LlxuICAgICAgICAgICAgICAgIHJhd1RleHQ6IGJlZ2luLnJhd1RleHQgKyBcIi1cIiArIGVuZC5yYXdUZXh0XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzBdLCByZXN1bHQwWzJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2NsYXNzQ2hhcmFjdGVyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgdmFyIHBvczA7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICByZXN1bHQwID0gcGFyc2VfYnJhY2tldERlbGltaXRlZENoYXJhY3RlcigpO1xuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBjaGFyXykge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6ICAgIGNoYXJfLFxuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBHZXQgdGhlIHJhdyB0ZXh0IGZyb20gdGhlIGlucHV0IGRpcmVjdGx5LlxuICAgICAgICAgICAgICAgIHJhd1RleHQ6IHF1b3RlRm9yUmVnZXhwQ2xhc3MoY2hhcl8pXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2JyYWNrZXREZWxpbWl0ZWRDaGFyYWN0ZXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICBcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3NpbXBsZUJyYWNrZXREZWxpbWl0ZWRDaGFyYWN0ZXIoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gcGFyc2Vfc2ltcGxlRXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3plcm9Fc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2hleEVzY2FwZVNlcXVlbmNlKCk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3VuaWNvZGVFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfZW9sRXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3NpbXBsZUJyYWNrZXREZWxpbWl0ZWRDaGFyYWN0ZXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMSwgcG9zMjtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIHBvczIgPSBwb3M7XG4gICAgICAgIHJlcG9ydEZhaWx1cmVzKys7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDkzKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiXVwiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXVxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gOTIpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXFxcIjtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXFxcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfZW9sQ2hhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXBvcnRGYWlsdXJlcy0tO1xuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gcG9zKSB7XG4gICAgICAgICAgICByZXN1bHQxID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJhbnkgY2hhcmFjdGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGNoYXJfKSB7IHJldHVybiBjaGFyXzsgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zaW1wbGVFc2NhcGVTZXF1ZW5jZSgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxLCBwb3MyO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gOTIpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCJcXFxcXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXFxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcG9zMiA9IHBvcztcbiAgICAgICAgICByZXBvcnRGYWlsdXJlcysrO1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9kaWdpdCgpO1xuICAgICAgICAgIGlmIChyZXN1bHQxID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAxMjApIHtcbiAgICAgICAgICAgICAgcmVzdWx0MSA9IFwieFwiO1xuICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJ4XFxcIlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMTE3KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MSA9IFwidVwiO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwidVxcXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQxID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2VvbENoYXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXBvcnRGYWlsdXJlcy0tO1xuICAgICAgICAgIGlmIChyZXN1bHQxID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQxID0gXCJcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IHBvcykge1xuICAgICAgICAgICAgICByZXN1bHQyID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiYW55IGNoYXJhY3RlclwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgY2hhcl8pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNoYXJfXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJiXCIsIFwiXFxiXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJmXCIsIFwiXFxmXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJuXCIsIFwiXFxuXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJyXCIsIFwiXFxyXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJ0XCIsIFwiXFx0XCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJ2XCIsIFwiXFx4MEJcIik7IC8vIElFIGRvZXMgbm90IHJlY29nbml6ZSBcIlxcdlwiLlxuICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV96ZXJvRXNjYXBlU2VxdWVuY2UoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMSwgcG9zMjtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJcXFxcMFwiKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiXFxcXDBcIjtcbiAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxcMFxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcG9zMiA9IHBvcztcbiAgICAgICAgICByZXBvcnRGYWlsdXJlcysrO1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9kaWdpdCgpO1xuICAgICAgICAgIHJlcG9ydEZhaWx1cmVzLS07XG4gICAgICAgICAgaWYgKHJlc3VsdDEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBcIlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCJcXHgwMFwiOyB9KShwb3MwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2hleEVzY2FwZVNlcXVlbmNlKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMikgPT09IFwiXFxcXHhcIikge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXFx4XCI7XG4gICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXHhcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9oZXhEaWdpdCgpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfaGV4RGlnaXQoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0Ml07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGgxLCBoMikge1xuICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoMSArIGgyLCAxNikpO1xuICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFsxXSwgcmVzdWx0MFsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV91bmljb2RlRXNjYXBlU2VxdWVuY2UoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzLCByZXN1bHQ0O1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJcXFxcdVwiKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiXFxcXHVcIjtcbiAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxcdVxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2hleERpZ2l0KCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9oZXhEaWdpdCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MyA9IHBhcnNlX2hleERpZ2l0KCk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0NCA9IHBhcnNlX2hleERpZ2l0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MywgcmVzdWx0NF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBoMSwgaDIsIGgzLCBoNCkge1xuICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoMSArIGgyICsgaDMgKyBoNCwgMTYpKTtcbiAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMV0sIHJlc3VsdDBbMl0sIHJlc3VsdDBbM10sIHJlc3VsdDBbNF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfZW9sRXNjYXBlU2VxdWVuY2UoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDkyKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiXFxcXFwiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXFxcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9lb2woKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGVvbCkgeyByZXR1cm4gZW9sOyB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2RpZ2l0KCkge1xuICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgXG4gICAgICAgIGlmICgvXlswLTldLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgIHJlc3VsdDAgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiWzAtOV1cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9oZXhEaWdpdCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgIFxuICAgICAgICBpZiAoL15bMC05YS1mQS1GXS8udGVzdChpbnB1dC5jaGFyQXQocG9zKSkpIHtcbiAgICAgICAgICByZXN1bHQwID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlswLTlhLWZBLUZdXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfbGV0dGVyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgXG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV9sb3dlckNhc2VMZXR0ZXIoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gcGFyc2VfdXBwZXJDYXNlTGV0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2xvd2VyQ2FzZUxldHRlcigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgIFxuICAgICAgICBpZiAoL15bYS16XS8udGVzdChpbnB1dC5jaGFyQXQocG9zKSkpIHtcbiAgICAgICAgICByZXN1bHQwID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlthLXpdXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfdXBwZXJDYXNlTGV0dGVyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgXG4gICAgICAgIGlmICgvXltBLVpdLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgIHJlc3VsdDAgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiW0EtWl1cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9fXygpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIFxuICAgICAgICByZXN1bHQwID0gW107XG4gICAgICAgIHJlc3VsdDEgPSBwYXJzZV93aGl0ZXNwYWNlKCk7XG4gICAgICAgIGlmIChyZXN1bHQxID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2VvbCgpO1xuICAgICAgICAgIGlmIChyZXN1bHQxID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQxID0gcGFyc2VfY29tbWVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAucHVzaChyZXN1bHQxKTtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2Vfd2hpdGVzcGFjZSgpO1xuICAgICAgICAgIGlmIChyZXN1bHQxID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQxID0gcGFyc2VfZW9sKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQxID0gcGFyc2VfY29tbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfY29tbWVudCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgIFxuICAgICAgICByZXBvcnRGYWlsdXJlcysrO1xuICAgICAgICByZXN1bHQwID0gcGFyc2Vfc2luZ2xlTGluZUNvbW1lbnQoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gcGFyc2VfbXVsdGlMaW5lQ29tbWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcG9ydEZhaWx1cmVzLS07XG4gICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCAmJiByZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgbWF0Y2hGYWlsZWQoXCJjb21tZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zaW5nbGVMaW5lQ29tbWVudCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDM7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxLCBwb3MyO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIi8vXCIpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCIvL1wiO1xuICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiLy9cXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBbXTtcbiAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgIHBvczIgPSBwb3M7XG4gICAgICAgICAgcmVwb3J0RmFpbHVyZXMrKztcbiAgICAgICAgICByZXN1bHQyID0gcGFyc2VfZW9sQ2hhcigpO1xuICAgICAgICAgIHJlcG9ydEZhaWx1cmVzLS07XG4gICAgICAgICAgaWYgKHJlc3VsdDIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBcIlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gcG9zKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDMgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQzID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJhbnkgY2hhcmFjdGVyXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQyID0gW3Jlc3VsdDIsIHJlc3VsdDNdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDEucHVzaChyZXN1bHQyKTtcbiAgICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgICBwb3MyID0gcG9zO1xuICAgICAgICAgICAgcmVwb3J0RmFpbHVyZXMrKztcbiAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9lb2xDaGFyKCk7XG4gICAgICAgICAgICByZXBvcnRGYWlsdXJlcy0tO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IFwiXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGggPiBwb3MpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQzID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MyA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcImFueSBjaGFyYWN0ZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiA9IFtyZXN1bHQyLCByZXN1bHQzXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfbXVsdGlMaW5lQ29tbWVudCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDM7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxLCBwb3MyO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIi8qXCIpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCIvKlwiO1xuICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiLypcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBbXTtcbiAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgIHBvczIgPSBwb3M7XG4gICAgICAgICAgcmVwb3J0RmFpbHVyZXMrKztcbiAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMikgPT09IFwiKi9cIikge1xuICAgICAgICAgICAgcmVzdWx0MiA9IFwiKi9cIjtcbiAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIqL1xcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcG9ydEZhaWx1cmVzLS07XG4gICAgICAgICAgaWYgKHJlc3VsdDIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBcIlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gcG9zKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDMgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQzID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJhbnkgY2hhcmFjdGVyXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQyID0gW3Jlc3VsdDIsIHJlc3VsdDNdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDEucHVzaChyZXN1bHQyKTtcbiAgICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgICBwb3MyID0gcG9zO1xuICAgICAgICAgICAgcmVwb3J0RmFpbHVyZXMrKztcbiAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCIqL1wiKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBcIiovXCI7XG4gICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIiovXFxcIlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVwb3J0RmFpbHVyZXMtLTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBcIlwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MyA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJhbnkgY2hhcmFjdGVyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBbcmVzdWx0MiwgcmVzdWx0M107XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMikgPT09IFwiKi9cIikge1xuICAgICAgICAgICAgICByZXN1bHQyID0gXCIqL1wiO1xuICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIqL1xcXCJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0Ml07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9lb2woKSB7XG4gICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICBcbiAgICAgICAgcmVwb3J0RmFpbHVyZXMrKztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMTApIHtcbiAgICAgICAgICByZXN1bHQwID0gXCJcXG5cIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxuXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMikgPT09IFwiXFxyXFxuXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcclxcblwiO1xuICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxyXFxcXG5cXFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMTMpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiXFxyXCI7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxyXFxcIlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gODIzMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcdTIwMjhcIjtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFx1MjAyOFxcXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gODIzMykge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiXFx1MjAyOVwiO1xuICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFx1MjAyOVxcXCJcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcG9ydEZhaWx1cmVzLS07XG4gICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCAmJiByZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgbWF0Y2hGYWlsZWQoXCJlbmQgb2YgbGluZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfZW9sQ2hhcigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgIFxuICAgICAgICBpZiAoL15bXFxuXFxyXFx1MjAyOFxcdTIwMjldLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgIHJlc3VsdDAgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiW1xcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjldXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfd2hpdGVzcGFjZSgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgIFxuICAgICAgICByZXBvcnRGYWlsdXJlcysrO1xuICAgICAgICBpZiAoL15bIFxcdFxceDBCXFxmXFx4QTBcXHVGRUZGXFx1MTY4MFxcdTE4MEVcXHUyMDAwLVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBdLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgIHJlc3VsdDAgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiWyBcXFxcdFxcXFx4MEJcXFxcZlxcXFx4QTBcXFxcdUZFRkZcXFxcdTE2ODBcXFxcdTE4MEVcXFxcdTIwMDAtXFxcXHUyMDBBXFxcXHUyMDJGXFxcXHUyMDVGXFxcXHUzMDAwXVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVwb3J0RmFpbHVyZXMtLTtcbiAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwICYmIHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBtYXRjaEZhaWxlZChcIndoaXRlc3BhY2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIFxuICAgICAgZnVuY3Rpb24gY2xlYW51cEV4cGVjdGVkKGV4cGVjdGVkKSB7XG4gICAgICAgIGV4cGVjdGVkLnNvcnQoKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBsYXN0RXhwZWN0ZWQgPSBudWxsO1xuICAgICAgICB2YXIgY2xlYW5FeHBlY3RlZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGV4cGVjdGVkW2ldICE9PSBsYXN0RXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIGNsZWFuRXhwZWN0ZWQucHVzaChleHBlY3RlZFtpXSk7XG4gICAgICAgICAgICBsYXN0RXhwZWN0ZWQgPSBleHBlY3RlZFtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsZWFuRXhwZWN0ZWQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIGNvbXB1dGVFcnJvclBvc2l0aW9uKCkge1xuICAgICAgICAvKlxuICAgICAgICAgKiBUaGUgZmlyc3QgaWRlYSB3YXMgdG8gdXNlIHxTdHJpbmcuc3BsaXR8IHRvIGJyZWFrIHRoZSBpbnB1dCB1cCB0byB0aGVcbiAgICAgICAgICogZXJyb3IgcG9zaXRpb24gYWxvbmcgbmV3bGluZXMgYW5kIGRlcml2ZSB0aGUgbGluZSBhbmQgY29sdW1uIGZyb21cbiAgICAgICAgICogdGhlcmUuIEhvd2V2ZXIgSUUncyB8c3BsaXR8IGltcGxlbWVudGF0aW9uIGlzIHNvIGJyb2tlbiB0aGF0IGl0IHdhc1xuICAgICAgICAgKiBlbm91Z2ggdG8gcHJldmVudCBpdC5cbiAgICAgICAgICovXG4gICAgICAgIFxuICAgICAgICB2YXIgbGluZSA9IDE7XG4gICAgICAgIHZhciBjb2x1bW4gPSAxO1xuICAgICAgICB2YXIgc2VlbkNSID0gZmFsc2U7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWF4KHBvcywgcmlnaHRtb3N0RmFpbHVyZXNQb3MpOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2ggPSBpbnB1dC5jaGFyQXQoaSk7XG4gICAgICAgICAgaWYgKGNoID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICBpZiAoIXNlZW5DUikgeyBsaW5lKys7IH1cbiAgICAgICAgICAgIGNvbHVtbiA9IDE7XG4gICAgICAgICAgICBzZWVuQ1IgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIlxcclwiIHx8IGNoID09PSBcIlxcdTIwMjhcIiB8fCBjaCA9PT0gXCJcXHUyMDI5XCIpIHtcbiAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICAgIGNvbHVtbiA9IDE7XG4gICAgICAgICAgICBzZWVuQ1IgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW4rKztcbiAgICAgICAgICAgIHNlZW5DUiA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHsgbGluZTogbGluZSwgY29sdW1uOiBjb2x1bW4gfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgXG4gICAgICB2YXIgcmVzdWx0ID0gcGFyc2VGdW5jdGlvbnNbc3RhcnRSdWxlXSgpO1xuICAgICAgXG4gICAgICAvKlxuICAgICAgICogVGhlIHBhcnNlciBpcyBub3cgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgdGhyZWUgc3RhdGVzOlxuICAgICAgICpcbiAgICAgICAqIDEuIFRoZSBwYXJzZXIgc3VjY2Vzc2Z1bGx5IHBhcnNlZCB0aGUgd2hvbGUgaW5wdXQuXG4gICAgICAgKlxuICAgICAgICogICAgLSB8cmVzdWx0ICE9PSBudWxsfFxuICAgICAgICogICAgLSB8cG9zID09PSBpbnB1dC5sZW5ndGh8XG4gICAgICAgKiAgICAtIHxyaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkfCBtYXkgb3IgbWF5IG5vdCBjb250YWluIHNvbWV0aGluZ1xuICAgICAgICpcbiAgICAgICAqIDIuIFRoZSBwYXJzZXIgc3VjY2Vzc2Z1bGx5IHBhcnNlZCBvbmx5IGEgcGFydCBvZiB0aGUgaW5wdXQuXG4gICAgICAgKlxuICAgICAgICogICAgLSB8cmVzdWx0ICE9PSBudWxsfFxuICAgICAgICogICAgLSB8cG9zIDwgaW5wdXQubGVuZ3RofFxuICAgICAgICogICAgLSB8cmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZHwgbWF5IG9yIG1heSBub3QgY29udGFpbiBzb21ldGhpbmdcbiAgICAgICAqXG4gICAgICAgKiAzLiBUaGUgcGFyc2VyIGRpZCBub3Qgc3VjY2Vzc2Z1bGx5IHBhcnNlIGFueSBwYXJ0IG9mIHRoZSBpbnB1dC5cbiAgICAgICAqXG4gICAgICAgKiAgIC0gfHJlc3VsdCA9PT0gbnVsbHxcbiAgICAgICAqICAgLSB8cG9zID09PSAwfFxuICAgICAgICogICAtIHxyaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkfCBjb250YWlucyBhdCBsZWFzdCBvbmUgZmFpbHVyZVxuICAgICAgICpcbiAgICAgICAqIEFsbCBjb2RlIGZvbGxvd2luZyB0aGlzIGNvbW1lbnQgKGluY2x1ZGluZyBjYWxsZWQgZnVuY3Rpb25zKSBtdXN0XG4gICAgICAgKiBoYW5kbGUgdGhlc2Ugc3RhdGVzLlxuICAgICAgICovXG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHBvcyAhPT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBNYXRoLm1heChwb3MsIHJpZ2h0bW9zdEZhaWx1cmVzUG9zKTtcbiAgICAgICAgdmFyIGZvdW5kID0gb2Zmc2V0IDwgaW5wdXQubGVuZ3RoID8gaW5wdXQuY2hhckF0KG9mZnNldCkgOiBudWxsO1xuICAgICAgICB2YXIgZXJyb3JQb3NpdGlvbiA9IGNvbXB1dGVFcnJvclBvc2l0aW9uKCk7XG4gICAgICAgIFxuICAgICAgICB0aHJvdyBuZXcgdGhpcy5TeW50YXhFcnJvcihcbiAgICAgICAgICBjbGVhbnVwRXhwZWN0ZWQocmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZCksXG4gICAgICAgICAgZm91bmQsXG4gICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgIGVycm9yUG9zaXRpb24ubGluZSxcbiAgICAgICAgICBlcnJvclBvc2l0aW9uLmNvbHVtblxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgXG4gICAgLyogUmV0dXJucyB0aGUgcGFyc2VyIHNvdXJjZSBjb2RlLiAqL1xuICAgIHRvU291cmNlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3NvdXJjZTsgfVxuICB9O1xuICBcbiAgLyogVGhyb3duIHdoZW4gYSBwYXJzZXIgZW5jb3VudGVycyBhIHN5bnRheCBlcnJvci4gKi9cbiAgXG4gIHJlc3VsdC5TeW50YXhFcnJvciA9IGZ1bmN0aW9uKGV4cGVjdGVkLCBmb3VuZCwgb2Zmc2V0LCBsaW5lLCBjb2x1bW4pIHtcbiAgICBmdW5jdGlvbiBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKSB7XG4gICAgICB2YXIgZXhwZWN0ZWRIdW1hbml6ZWQsIGZvdW5kSHVtYW5pemVkO1xuICAgICAgXG4gICAgICBzd2l0Y2ggKGV4cGVjdGVkLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgZXhwZWN0ZWRIdW1hbml6ZWQgPSBcImVuZCBvZiBpbnB1dFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgZXhwZWN0ZWRIdW1hbml6ZWQgPSBleHBlY3RlZFswXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBleHBlY3RlZEh1bWFuaXplZCA9IGV4cGVjdGVkLnNsaWNlKDAsIGV4cGVjdGVkLmxlbmd0aCAtIDEpLmpvaW4oXCIsIFwiKVxuICAgICAgICAgICAgKyBcIiBvciBcIlxuICAgICAgICAgICAgKyBleHBlY3RlZFtleHBlY3RlZC5sZW5ndGggLSAxXTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZm91bmRIdW1hbml6ZWQgPSBmb3VuZCA/IHF1b3RlKGZvdW5kKSA6IFwiZW5kIG9mIGlucHV0XCI7XG4gICAgICBcbiAgICAgIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZXhwZWN0ZWRIdW1hbml6ZWQgKyBcIiBidXQgXCIgKyBmb3VuZEh1bWFuaXplZCArIFwiIGZvdW5kLlwiO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLm5hbWUgPSBcIlN5bnRheEVycm9yXCI7XG4gICAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgIHRoaXMuZm91bmQgPSBmb3VuZDtcbiAgICB0aGlzLm1lc3NhZ2UgPSBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICB9O1xuICBcbiAgcmVzdWx0LlN5bnRheEVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcbiAgXG4gIHJldHVybiByZXN1bHQ7XG59KSgpO1xuUEVHLmNvbXBpbGVyID0ge1xuICAvKlxuICAgKiBOYW1lcyBvZiBwYXNzZXMgdGhhdCB3aWxsIGdldCBydW4gZHVyaW5nIHRoZSBjb21waWxhdGlvbiAoaW4gdGhlIHNwZWNpZmllZFxuICAgKiBvcmRlcikuXG4gICAqL1xuICBhcHBsaWVkUGFzc05hbWVzOiBbXG4gICAgXCJyZXBvcnRNaXNzaW5nUnVsZXNcIixcbiAgICBcInJlcG9ydExlZnRSZWN1cnNpb25cIixcbiAgICBcInJlbW92ZVByb3h5UnVsZXNcIixcbiAgICBcImNvbXB1dGVWYXJOYW1lc1wiLFxuICAgIFwiY29tcHV0ZVBhcmFtc1wiXG4gIF0sXG5cbiAgLypcbiAgICogR2VuZXJhdGVzIGEgcGFyc2VyIGZyb20gYSBzcGVjaWZpZWQgZ3JhbW1hciBBU1QuIFRocm93cyB8UEVHLkdyYW1tYXJFcnJvcnxcbiAgICogaWYgdGhlIEFTVCBjb250YWlucyBhIHNlbWFudGljIGVycm9yLiBOb3RlIHRoYXQgbm90IGFsbCBlcnJvcnMgYXJlIGRldGVjdGVkXG4gICAqIGR1cmluZyB0aGUgZ2VuZXJhdGlvbiBhbmQgc29tZSBtYXkgcHJvdHJ1ZGUgdG8gdGhlIGdlbmVyYXRlZCBwYXJzZXIgYW5kXG4gICAqIGNhdXNlIGl0cyBtYWxmdW5jdGlvbi5cbiAgICovXG4gIGNvbXBpbGU6IGZ1bmN0aW9uKGFzdCwgb3B0aW9ucykge1xuICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgIGVhY2godGhpcy5hcHBsaWVkUGFzc05hbWVzLCBmdW5jdGlvbihwYXNzTmFtZSkge1xuICAgICAgdGhhdC5wYXNzZXNbcGFzc05hbWVdKGFzdCk7XG4gICAgfSk7XG5cbiAgICB2YXIgc291cmNlID0gdGhpcy5lbWl0dGVyKGFzdCwgb3B0aW9ucyk7XG4gICAgdmFyIHJlc3VsdCA9IGV2YWwoc291cmNlKTtcbiAgICByZXN1bHQuX3NvdXJjZSA9IHNvdXJjZTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbi8qXG4gKiBDb21waWxlciBwYXNzZXMuXG4gKlxuICogRWFjaCBwYXNzIGlzIGEgZnVuY3Rpb24gdGhhdCBpcyBwYXNzZWQgdGhlIEFTVC4gSXQgY2FuIHBlcmZvcm0gY2hlY2tzIG9uIGl0XG4gKiBvciBtb2RpZnkgaXQgYXMgbmVlZGVkLiBJZiB0aGUgcGFzcyBlbmNvdW50ZXJzIGEgc2VtYW50aWMgZXJyb3IsIGl0IHRocm93c1xuICogfFBFRy5HcmFtbWFyRXJyb3J8LlxuICovXG5QRUcuY29tcGlsZXIucGFzc2VzID0ge1xuICAvKiBDaGVja3MgdGhhdCBhbGwgcmVmZXJlbmNlZCBydWxlcyBleGlzdC4gKi9cbiAgcmVwb3J0TWlzc2luZ1J1bGVzOiBmdW5jdGlvbihhc3QpIHtcbiAgICBmdW5jdGlvbiBub3AoKSB7fVxuXG4gICAgZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uKG5vZGUpIHsgY2hlY2sobm9kZS5leHByZXNzaW9uKTsgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tTdWJub2Rlcyhwcm9wZXJ0eU5hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihub2RlKSB7IGVhY2gobm9kZVtwcm9wZXJ0eU5hbWVdLCBjaGVjayk7IH07XG4gICAgfVxuXG4gICAgdmFyIGNoZWNrID0gYnVpbGROb2RlVmlzaXRvcih7XG4gICAgICBncmFtbWFyOiAgICAgIGNoZWNrU3Vibm9kZXMoXCJydWxlc1wiKSxcbiAgICAgIHJ1bGU6ICAgICAgICAgY2hlY2tFeHByZXNzaW9uLFxuICAgICAgY2hvaWNlOiAgICAgICBjaGVja1N1Ym5vZGVzKFwiYWx0ZXJuYXRpdmVzXCIpLFxuICAgICAgc2VxdWVuY2U6ICAgICBjaGVja1N1Ym5vZGVzKFwiZWxlbWVudHNcIiksXG4gICAgICBsYWJlbGVkOiAgICAgIGNoZWNrRXhwcmVzc2lvbixcbiAgICAgIHNpbXBsZV9hbmQ6ICAgY2hlY2tFeHByZXNzaW9uLFxuICAgICAgc2ltcGxlX25vdDogICBjaGVja0V4cHJlc3Npb24sXG4gICAgICBzZW1hbnRpY19hbmQ6IG5vcCxcbiAgICAgIHNlbWFudGljX25vdDogbm9wLFxuICAgICAgb3B0aW9uYWw6ICAgICBjaGVja0V4cHJlc3Npb24sXG4gICAgICB6ZXJvX29yX21vcmU6IGNoZWNrRXhwcmVzc2lvbixcbiAgICAgIG9uZV9vcl9tb3JlOiAgY2hlY2tFeHByZXNzaW9uLFxuICAgICAgYWN0aW9uOiAgICAgICBjaGVja0V4cHJlc3Npb24sXG5cbiAgICAgIHJ1bGVfcmVmOlxuICAgICAgICBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgaWYgKCFmaW5kUnVsZUJ5TmFtZShhc3QsIG5vZGUubmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQRUcuR3JhbW1hckVycm9yKFxuICAgICAgICAgICAgICBcIlJlZmVyZW5jZWQgcnVsZSBcXFwiXCIgKyBub2RlLm5hbWUgKyBcIlxcXCIgZG9lcyBub3QgZXhpc3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICBsaXRlcmFsOiAgICAgIG5vcCxcbiAgICAgIGFueTogICAgICAgICAgbm9wLFxuICAgICAgXCJjbGFzc1wiOiAgICAgIG5vcFxuICAgIH0pO1xuXG4gICAgY2hlY2soYXN0KTtcbiAgfSxcblxuICAvKiBDaGVja3MgdGhhdCBubyBsZWZ0IHJlY3Vyc2lvbiBpcyBwcmVzZW50LiAqL1xuICByZXBvcnRMZWZ0UmVjdXJzaW9uOiBmdW5jdGlvbihhc3QpIHtcbiAgICBmdW5jdGlvbiBub3AoKSB7fVxuXG4gICAgZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uKG5vZGUsIGFwcGxpZWRSdWxlcykge1xuICAgICAgY2hlY2sobm9kZS5leHByZXNzaW9uLCBhcHBsaWVkUnVsZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrU3Vibm9kZXMocHJvcGVydHlOYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24obm9kZSwgYXBwbGllZFJ1bGVzKSB7XG4gICAgICAgIGVhY2gobm9kZVtwcm9wZXJ0eU5hbWVdLCBmdW5jdGlvbihzdWJub2RlKSB7XG4gICAgICAgICAgY2hlY2soc3Vibm9kZSwgYXBwbGllZFJ1bGVzKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBjaGVjayA9IGJ1aWxkTm9kZVZpc2l0b3Ioe1xuICAgICAgZ3JhbW1hcjogICAgIGNoZWNrU3Vibm9kZXMoXCJydWxlc1wiKSxcblxuICAgICAgcnVsZTpcbiAgICAgICAgZnVuY3Rpb24obm9kZSwgYXBwbGllZFJ1bGVzKSB7XG4gICAgICAgICAgY2hlY2sobm9kZS5leHByZXNzaW9uLCBhcHBsaWVkUnVsZXMuY29uY2F0KG5vZGUubmFtZSkpO1xuICAgICAgICB9LFxuXG4gICAgICBjaG9pY2U6ICAgICAgY2hlY2tTdWJub2RlcyhcImFsdGVybmF0aXZlc1wiKSxcblxuICAgICAgc2VxdWVuY2U6XG4gICAgICAgIGZ1bmN0aW9uKG5vZGUsIGFwcGxpZWRSdWxlcykge1xuICAgICAgICAgIGlmIChub2RlLmVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNoZWNrKG5vZGUuZWxlbWVudHNbMF0sIGFwcGxpZWRSdWxlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICBsYWJlbGVkOiAgICAgIGNoZWNrRXhwcmVzc2lvbixcbiAgICAgIHNpbXBsZV9hbmQ6ICAgY2hlY2tFeHByZXNzaW9uLFxuICAgICAgc2ltcGxlX25vdDogICBjaGVja0V4cHJlc3Npb24sXG4gICAgICBzZW1hbnRpY19hbmQ6IG5vcCxcbiAgICAgIHNlbWFudGljX25vdDogbm9wLFxuICAgICAgb3B0aW9uYWw6ICAgICBjaGVja0V4cHJlc3Npb24sXG4gICAgICB6ZXJvX29yX21vcmU6IGNoZWNrRXhwcmVzc2lvbixcbiAgICAgIG9uZV9vcl9tb3JlOiAgY2hlY2tFeHByZXNzaW9uLFxuICAgICAgYWN0aW9uOiAgICAgICBjaGVja0V4cHJlc3Npb24sXG5cbiAgICAgIHJ1bGVfcmVmOlxuICAgICAgICBmdW5jdGlvbihub2RlLCBhcHBsaWVkUnVsZXMpIHtcbiAgICAgICAgICBpZiAoY29udGFpbnMoYXBwbGllZFJ1bGVzLCBub2RlLm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUEVHLkdyYW1tYXJFcnJvcihcbiAgICAgICAgICAgICAgXCJMZWZ0IHJlY3Vyc2lvbiBkZXRlY3RlZCBmb3IgcnVsZSBcXFwiXCIgKyBub2RlLm5hbWUgKyBcIlxcXCIuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoZWNrKGZpbmRSdWxlQnlOYW1lKGFzdCwgbm9kZS5uYW1lKSwgYXBwbGllZFJ1bGVzKTtcbiAgICAgICAgfSxcblxuICAgICAgbGl0ZXJhbDogICAgICBub3AsXG4gICAgICBhbnk6ICAgICAgICAgIG5vcCxcbiAgICAgIFwiY2xhc3NcIjogICAgICBub3BcbiAgICB9KTtcblxuICAgIGNoZWNrKGFzdCwgW10pO1xuICB9LFxuXG4gIC8qXG4gICAqIFJlbW92ZXMgcHJveHkgcnVsZXMgLS0gdGhhdCBpcywgcnVsZXMgdGhhdCBvbmx5IGRlbGVnYXRlIHRvIG90aGVyIHJ1bGUuXG4gICAqL1xuICByZW1vdmVQcm94eVJ1bGVzOiBmdW5jdGlvbihhc3QpIHtcbiAgICBmdW5jdGlvbiBpc1Byb3h5UnVsZShub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInJ1bGVcIiAmJiBub2RlLmV4cHJlc3Npb24udHlwZSA9PT0gXCJydWxlX3JlZlwiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VSdWxlUmVmcyhhc3QsIGZyb20sIHRvKSB7XG4gICAgICBmdW5jdGlvbiBub3AoKSB7fVxuXG4gICAgICBmdW5jdGlvbiByZXBsYWNlSW5FeHByZXNzaW9uKG5vZGUsIGZyb20sIHRvKSB7XG4gICAgICAgIHJlcGxhY2Uobm9kZS5leHByZXNzaW9uLCBmcm9tLCB0byk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlcGxhY2VJblN1Ym5vZGVzKHByb3BlcnR5TmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24obm9kZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgICBlYWNoKG5vZGVbcHJvcGVydHlOYW1lXSwgZnVuY3Rpb24oc3Vibm9kZSkge1xuICAgICAgICAgICAgcmVwbGFjZShzdWJub2RlLCBmcm9tLCB0byk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciByZXBsYWNlID0gYnVpbGROb2RlVmlzaXRvcih7XG4gICAgICAgIGdyYW1tYXI6ICAgICAgcmVwbGFjZUluU3Vibm9kZXMoXCJydWxlc1wiKSxcbiAgICAgICAgcnVsZTogICAgICAgICByZXBsYWNlSW5FeHByZXNzaW9uLFxuICAgICAgICBjaG9pY2U6ICAgICAgIHJlcGxhY2VJblN1Ym5vZGVzKFwiYWx0ZXJuYXRpdmVzXCIpLFxuICAgICAgICBzZXF1ZW5jZTogICAgIHJlcGxhY2VJblN1Ym5vZGVzKFwiZWxlbWVudHNcIiksXG4gICAgICAgIGxhYmVsZWQ6ICAgICAgcmVwbGFjZUluRXhwcmVzc2lvbixcbiAgICAgICAgc2ltcGxlX2FuZDogICByZXBsYWNlSW5FeHByZXNzaW9uLFxuICAgICAgICBzaW1wbGVfbm90OiAgIHJlcGxhY2VJbkV4cHJlc3Npb24sXG4gICAgICAgIHNlbWFudGljX2FuZDogbm9wLFxuICAgICAgICBzZW1hbnRpY19ub3Q6IG5vcCxcbiAgICAgICAgb3B0aW9uYWw6ICAgICByZXBsYWNlSW5FeHByZXNzaW9uLFxuICAgICAgICB6ZXJvX29yX21vcmU6IHJlcGxhY2VJbkV4cHJlc3Npb24sXG4gICAgICAgIG9uZV9vcl9tb3JlOiAgcmVwbGFjZUluRXhwcmVzc2lvbixcbiAgICAgICAgYWN0aW9uOiAgICAgICByZXBsYWNlSW5FeHByZXNzaW9uLFxuXG4gICAgICAgIHJ1bGVfcmVmOlxuICAgICAgICAgIGZ1bmN0aW9uKG5vZGUsIGZyb20sIHRvKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSBmcm9tKSB7XG4gICAgICAgICAgICAgIG5vZGUubmFtZSA9IHRvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgbGl0ZXJhbDogICAgICBub3AsXG4gICAgICAgIGFueTogICAgICAgICAgbm9wLFxuICAgICAgICBcImNsYXNzXCI6ICAgICAgbm9wXG4gICAgICB9KTtcblxuICAgICAgcmVwbGFjZShhc3QsIGZyb20sIHRvKTtcbiAgICB9XG5cbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuXG4gICAgZWFjaChhc3QucnVsZXMsIGZ1bmN0aW9uKHJ1bGUsIGkpIHtcbiAgICAgIGlmIChpc1Byb3h5UnVsZShydWxlKSkge1xuICAgICAgICByZXBsYWNlUnVsZVJlZnMoYXN0LCBydWxlLm5hbWUsIHJ1bGUuZXhwcmVzc2lvbi5uYW1lKTtcbiAgICAgICAgaWYgKHJ1bGUubmFtZSA9PT0gYXN0LnN0YXJ0UnVsZSkge1xuICAgICAgICAgIGFzdC5zdGFydFJ1bGUgPSBydWxlLmV4cHJlc3Npb24ubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpbmRpY2VzLnB1c2goaSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpbmRpY2VzLnJldmVyc2UoKTtcblxuICAgIGVhY2goaW5kaWNlcywgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGFzdC5ydWxlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qXG4gICAqIENvbXB1dGVzIG5hbWVzIG9mIHZhcmlhYmxlcyB1c2VkIGZvciBzdG9yaW5nIG1hdGNoIHJlc3VsdHMgYW5kIHBhcnNlXG4gICAqIHBvc2l0aW9ucyBpbiBnZW5lcmF0ZWQgY29kZS4gVGhlc2UgdmFyaWFibGVzIGFyZSBvcmdhbml6ZWQgYXMgdHdvIHN0YWNrcy5cbiAgICogVGhlIGZvbGxvd2luZyB3aWxsIGhvbGQgYWZ0ZXIgcnVubmluZyB0aGlzIHBhc3M6XG4gICAqXG4gICAqICAgKiBBbGwgbm9kZXMgZXhjZXB0IFwiZ3JhbW1hclwiIGFuZCBcInJ1bGVcIiBub2RlcyB3aWxsIGhhdmUgYSB8cmVzdWx0VmFyfFxuICAgKiAgICAgcHJvcGVydHkuIEl0IHdpbGwgY29udGFpbiBhIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRoYXQgd2lsbCBzdG9yZSBhXG4gICAqICAgICBtYXRjaCByZXN1bHQgb2YgdGhlIGV4cHJlc3Npb24gcmVwcmVzZW50ZWQgYnkgdGhlIG5vZGUgaW4gZ2VuZXJhdGVkXG4gICAqICAgICBjb2RlLlxuICAgKlxuICAgKiAgICogU29tZSBub2RlcyB3aWxsIGhhdmUgYSB8cG9zVmFyfCBwcm9wZXJ0eS4gSXQgd2lsbCBjb250YWluIGEgbmFtZSBvZiB0aGVcbiAgICogICAgIHZhcmlhYmxlIHRoYXQgd2lsbCBzdG9yZSBhIHBhcnNlIHBvc2l0aW9uIGluIGdlbmVyYXRlZCBjb2RlLlxuICAgKlxuICAgKiAgICogQWxsIFwicnVsZVwiIG5vZGVzIHdpbGwgY29udGFpbiB8cmVzdWx0VmFyc3wgYW5kIHxwb3NWYXJzfCBwcm9wZXJ0aWVzLlxuICAgKiAgICAgVGhleSB3aWxsIGNvbnRhaW4gYSBsaXN0IG9mIHZhbHVlcyBvZiB8cmVzdWx0VmFyfCBhbmQgfHBvc1ZhcnxcbiAgICogICAgIHByb3BlcnRpZXMgdXNlZCBpbiBydWxlJ3Mgc3Vibm9kZXMuIChUaGlzIGlzIHVzZWZ1bCB0byBkZWNsYXJlXG4gICAqICAgICB2YXJpYWJsZXMgaW4gZ2VuZXJhdGVkIGNvZGUuKVxuICAgKi9cbiAgY29tcHV0ZVZhck5hbWVzOiBmdW5jdGlvbihhc3QpIHtcbiAgICBmdW5jdGlvbiByZXN1bHRWYXIoaW5kZXgpIHsgcmV0dXJuIFwicmVzdWx0XCIgKyBpbmRleDsgfVxuICAgIGZ1bmN0aW9uIHBvc1ZhcihpbmRleCkgICAgeyByZXR1cm4gXCJwb3NcIiAgICArIGluZGV4OyB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTGVhZihub2RlLCBpbmRleCkge1xuICAgICAgbm9kZS5yZXN1bHRWYXIgPSByZXN1bHRWYXIoaW5kZXgucmVzdWx0KTtcblxuICAgICAgcmV0dXJuIHsgcmVzdWx0OiAwLCBwb3M6IDAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlRnJvbUV4cHJlc3Npb24oZGVsdGEpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihub2RlLCBpbmRleCkge1xuICAgICAgICB2YXIgZGVwdGggPSBjb21wdXRlKFxuICAgICAgICAgICAgICBub2RlLmV4cHJlc3Npb24sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGluZGV4LnJlc3VsdCArIGRlbHRhLnJlc3VsdCxcbiAgICAgICAgICAgICAgICBwb3M6ICAgIGluZGV4LnBvcyAgICArIGRlbHRhLnBvc1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgIG5vZGUucmVzdWx0VmFyID0gcmVzdWx0VmFyKGluZGV4LnJlc3VsdCk7XG4gICAgICAgIGlmIChkZWx0YS5wb3MgIT09IDApIHtcbiAgICAgICAgICBub2RlLnBvc1ZhciA9IHBvc1ZhcihpbmRleC5wb3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IGRlcHRoLnJlc3VsdCArIGRlbHRhLnJlc3VsdCxcbiAgICAgICAgICBwb3M6ICAgIGRlcHRoLnBvcyAgICArIGRlbHRhLnBvc1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgY29tcHV0ZSA9IGJ1aWxkTm9kZVZpc2l0b3Ioe1xuICAgICAgZ3JhbW1hcjpcbiAgICAgICAgZnVuY3Rpb24obm9kZSwgaW5kZXgpIHtcbiAgICAgICAgICBlYWNoKG5vZGUucnVsZXMsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIGNvbXB1dGUobm9kZSwgaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICBydWxlOlxuICAgICAgICBmdW5jdGlvbihub2RlLCBpbmRleCkge1xuICAgICAgICAgIHZhciBkZXB0aCA9IGNvbXB1dGUobm9kZS5leHByZXNzaW9uLCBpbmRleCk7XG5cbiAgICAgICAgICBub2RlLnJlc3VsdFZhciAgPSByZXN1bHRWYXIoaW5kZXgucmVzdWx0KTtcbiAgICAgICAgICBub2RlLnJlc3VsdFZhcnMgPSBtYXAocmFuZ2UoZGVwdGgucmVzdWx0ICsgMSksIHJlc3VsdFZhcik7XG4gICAgICAgICAgbm9kZS5wb3NWYXJzICAgID0gbWFwKHJhbmdlKGRlcHRoLnBvcyksICAgICAgICBwb3NWYXIpO1xuICAgICAgICB9LFxuXG4gICAgICBjaG9pY2U6XG4gICAgICAgIGZ1bmN0aW9uKG5vZGUsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIGRlcHRocyA9IG1hcChub2RlLmFsdGVybmF0aXZlcywgZnVuY3Rpb24oYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlKGFsdGVybmF0aXZlLCBpbmRleCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBub2RlLnJlc3VsdFZhciA9IHJlc3VsdFZhcihpbmRleC5yZXN1bHQpO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogTWF0aC5tYXguYXBwbHkobnVsbCwgcGx1Y2soZGVwdGhzLCBcInJlc3VsdFwiKSksXG4gICAgICAgICAgICBwb3M6ICAgIE1hdGgubWF4LmFwcGx5KG51bGwsIHBsdWNrKGRlcHRocywgXCJwb3NcIikpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgc2VxdWVuY2U6XG4gICAgICAgIGZ1bmN0aW9uKG5vZGUsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIGRlcHRocyA9IG1hcChub2RlLmVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcHV0ZShcbiAgICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgICAgeyByZXN1bHQ6IGluZGV4LnJlc3VsdCArIGksIHBvczogaW5kZXgucG9zICsgMSB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbm9kZS5yZXN1bHRWYXIgPSByZXN1bHRWYXIoaW5kZXgucmVzdWx0KTtcbiAgICAgICAgICBub2RlLnBvc1ZhciAgICA9IHBvc1ZhcihpbmRleC5wb3MpO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDpcbiAgICAgICAgICAgICAgbm9kZS5lbGVtZW50cy5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgPyBNYXRoLm1heC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbWFwKGRlcHRocywgZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gaSArIGQucmVzdWx0OyB9KVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogMCxcblxuICAgICAgICAgICAgcG9zOlxuICAgICAgICAgICAgICBub2RlLmVsZW1lbnRzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICA/IDEgKyBNYXRoLm1heC5hcHBseShudWxsLCBwbHVjayhkZXB0aHMsIFwicG9zXCIpKVxuICAgICAgICAgICAgICAgIDogMVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgIGxhYmVsZWQ6ICAgICAgY29tcHV0ZUZyb21FeHByZXNzaW9uKHsgcmVzdWx0OiAwLCBwb3M6IDAgfSksXG4gICAgICBzaW1wbGVfYW5kOiAgIGNvbXB1dGVGcm9tRXhwcmVzc2lvbih7IHJlc3VsdDogMCwgcG9zOiAxIH0pLFxuICAgICAgc2ltcGxlX25vdDogICBjb21wdXRlRnJvbUV4cHJlc3Npb24oeyByZXN1bHQ6IDAsIHBvczogMSB9KSxcbiAgICAgIHNlbWFudGljX2FuZDogY29tcHV0ZUxlYWYsXG4gICAgICBzZW1hbnRpY19ub3Q6IGNvbXB1dGVMZWFmLFxuICAgICAgb3B0aW9uYWw6ICAgICBjb21wdXRlRnJvbUV4cHJlc3Npb24oeyByZXN1bHQ6IDAsIHBvczogMCB9KSxcbiAgICAgIHplcm9fb3JfbW9yZTogY29tcHV0ZUZyb21FeHByZXNzaW9uKHsgcmVzdWx0OiAxLCBwb3M6IDAgfSksXG4gICAgICBvbmVfb3JfbW9yZTogIGNvbXB1dGVGcm9tRXhwcmVzc2lvbih7IHJlc3VsdDogMSwgcG9zOiAwIH0pLFxuICAgICAgYWN0aW9uOiAgICAgICBjb21wdXRlRnJvbUV4cHJlc3Npb24oeyByZXN1bHQ6IDAsIHBvczogMSB9KSxcbiAgICAgIHJ1bGVfcmVmOiAgICAgY29tcHV0ZUxlYWYsXG4gICAgICBsaXRlcmFsOiAgICAgIGNvbXB1dGVMZWFmLFxuICAgICAgYW55OiAgICAgICAgICBjb21wdXRlTGVhZixcbiAgICAgIFwiY2xhc3NcIjogICAgICBjb21wdXRlTGVhZlxuICAgIH0pO1xuXG4gICAgY29tcHV0ZShhc3QsIHsgcmVzdWx0OiAwLCBwb3M6IDAgfSk7XG4gIH0sXG5cbiAgLypcbiAgICogVGhpcyBwYXNzIHdhbGtzIHRocm91Z2ggdGhlIEFTVCBhbmQgdHJhY2tzIHdoYXQgbGFiZWxzIGFyZSB2aXNpYmxlIGF0IGVhY2hcbiAgICogcG9pbnQuIEZvciBcImFjdGlvblwiLCBcInNlbWFudGljX2FuZFwiIGFuZCBcInNlbWFudGljX29yXCIgbm9kZXMgaXQgY29tcHV0ZXNcbiAgICogcGFyYW1ldGVyIG5hbWVzIGFuZCB2YWx1ZXMgZm9yIHRoZSBmdW5jdGlvbiB1c2VkIGluIGdlbmVyYXRlZCBjb2RlLiAoSW4gdGhlXG4gICAqIGVtaXR0ZXIsIHVzZXIncyBjb2RlIGlzIHdyYXBwZWQgaW50byBhIGZ1bmN0aW9uIHRoYXQgaXMgaW1tZWRpYXRlbHlcbiAgICogZXhlY3V0ZWQuIEl0cyBwYXJhbWV0ZXIgbmFtZXMgY29ycmVzcG9uZCB0byB2aXNpYmxlIGxhYmVscyBhbmQgaXRzXG4gICAqIHBhcmFtZXRlciB2YWx1ZXMgdG8gdGhlaXIgY2FwdHVyZWQgdmFsdWVzKS4gSW1wbGljaXRseSwgdGhpcyBwYXNzIGRlZmluZXNcbiAgICogc2NvcGluZyBydWxlcyBmb3IgbGFiZWxzLlxuICAgKlxuICAgKiBBZnRlciBydW5uaW5nIHRoaXMgcGFzcywgYWxsIFwiYWN0aW9uXCIsIFwic2VtYW50aWNfYW5kXCIgYW5kIFwic2VtYW50aWNfb3JcIlxuICAgKiBub2RlcyB3aWxsIGhhdmUgYSB8cGFyYW1zfCBwcm9wZXJ0eSBjb250YWluaW5nIGFuIG9iamVjdCBtYXBwaW5nIHBhcmFtZXRlclxuICAgKiBuYW1lcyB0byB0aGUgZXhwcmVzc2lvbnMgdGhhdCB3aWxsIGJlIHVzZWQgYXMgdGhlaXIgdmFsdWVzLlxuICAgKi9cbiAgY29tcHV0ZVBhcmFtczogZnVuY3Rpb24oYXN0KSB7XG4gICAgdmFyIGVudnMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIHNjb3BlZChmKSB7XG4gICAgICBlbnZzLnB1c2goe30pO1xuICAgICAgZigpO1xuICAgICAgZW52cy5wb3AoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3AoKSB7fVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZUZvclNjb3BlZEV4cHJlc3Npb24obm9kZSkge1xuICAgICAgc2NvcGVkKGZ1bmN0aW9uKCkgeyBjb21wdXRlKG5vZGUuZXhwcmVzc2lvbik7IH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVQYXJhbXMobm9kZSkge1xuICAgICAgdmFyIGVudiA9IGVudnNbZW52cy5sZW5ndGggLSAxXSwgcGFyYW1zID0ge30sIG5hbWU7XG5cbiAgICAgIGZvciAobmFtZSBpbiBlbnYpIHtcbiAgICAgICAgcGFyYW1zW25hbWVdID0gZW52W25hbWVdO1xuICAgICAgfVxuICAgICAgbm9kZS5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfVxuXG4gICAgdmFyIGNvbXB1dGUgPSBidWlsZE5vZGVWaXNpdG9yKHtcbiAgICAgIGdyYW1tYXI6XG4gICAgICAgIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBlYWNoKG5vZGUucnVsZXMsIGNvbXB1dGUpO1xuICAgICAgICB9LFxuXG4gICAgICBydWxlOiAgICAgICAgIGNvbXB1dGVGb3JTY29wZWRFeHByZXNzaW9uLFxuXG4gICAgICBjaG9pY2U6XG4gICAgICAgIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBzY29wZWQoZnVuY3Rpb24oKSB7IGVhY2gobm9kZS5hbHRlcm5hdGl2ZXMsIGNvbXB1dGUpOyB9KTtcbiAgICAgICAgfSxcblxuICAgICAgc2VxdWVuY2U6XG4gICAgICAgIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICB2YXIgZW52ID0gZW52c1tlbnZzLmxlbmd0aCAtIDFdLCBuYW1lO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZml4dXAobmFtZSkge1xuICAgICAgICAgICAgZWFjaChwbHVjayhub2RlLmVsZW1lbnRzLCBcInJlc3VsdFZhclwiKSwgZnVuY3Rpb24ocmVzdWx0VmFyLCBpKSB7XG4gICAgICAgICAgICAgIGlmICgobmV3IFJlZ0V4cChcIl5cIiArIHJlc3VsdFZhciArIFwiKFxcXFxbXFxcXGQrXFxcXF0pKiRcIikpLnRlc3QoZW52W25hbWVdKSkge1xuICAgICAgICAgICAgICAgIGVudltuYW1lXSA9IG5vZGUucmVzdWx0VmFyICsgXCJbXCIgKyBpICsgXCJdXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBlbnZbbmFtZV0uc3Vic3RyKHJlc3VsdFZhci5sZW5ndGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlYWNoKG5vZGUuZWxlbWVudHMsIGNvbXB1dGUpO1xuXG4gICAgICAgICAgZm9yIChuYW1lIGluIGVudikge1xuICAgICAgICAgICAgZml4dXAobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICBsYWJlbGVkOlxuICAgICAgICBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgZW52c1tlbnZzLmxlbmd0aCAtIDFdW25vZGUubGFiZWxdID0gbm9kZS5yZXN1bHRWYXI7XG5cbiAgICAgICAgICBzY29wZWQoZnVuY3Rpb24oKSB7IGNvbXB1dGUobm9kZS5leHByZXNzaW9uKTsgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgIHNpbXBsZV9hbmQ6ICAgY29tcHV0ZUZvclNjb3BlZEV4cHJlc3Npb24sXG4gICAgICBzaW1wbGVfbm90OiAgIGNvbXB1dGVGb3JTY29wZWRFeHByZXNzaW9uLFxuICAgICAgc2VtYW50aWNfYW5kOiBjb21wdXRlUGFyYW1zLFxuICAgICAgc2VtYW50aWNfbm90OiBjb21wdXRlUGFyYW1zLFxuICAgICAgb3B0aW9uYWw6ICAgICBjb21wdXRlRm9yU2NvcGVkRXhwcmVzc2lvbixcbiAgICAgIHplcm9fb3JfbW9yZTogY29tcHV0ZUZvclNjb3BlZEV4cHJlc3Npb24sXG4gICAgICBvbmVfb3JfbW9yZTogIGNvbXB1dGVGb3JTY29wZWRFeHByZXNzaW9uLFxuXG4gICAgICBhY3Rpb246XG4gICAgICAgIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBzY29wZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb21wdXRlKG5vZGUuZXhwcmVzc2lvbik7XG4gICAgICAgICAgICBjb21wdXRlUGFyYW1zKG5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICBydWxlX3JlZjogICAgIG5vcCxcbiAgICAgIGxpdGVyYWw6ICAgICAgbm9wLFxuICAgICAgYW55OiAgICAgICAgICBub3AsXG4gICAgICBcImNsYXNzXCI6ICAgICAgbm9wXG4gICAgfSk7XG5cbiAgICBjb21wdXRlKGFzdCk7XG4gIH1cbn07XG4vKiBFbWl0cyB0aGUgZ2VuZXJhdGVkIGNvZGUgZm9yIHRoZSBBU1QuICovXG5QRUcuY29tcGlsZXIuZW1pdHRlciA9IGZ1bmN0aW9uKGFzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKG9wdGlvbnMuY2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuY2FjaGUgPSBmYWxzZTtcbiAgfVxuICBpZiAob3B0aW9ucy50cmFja0xpbmVBbmRDb2x1bW4gPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMudHJhY2tMaW5lQW5kQ29sdW1uID0gZmFsc2U7XG4gIH1cblxuICAvKlxuICAgKiBDb2RpZSAxLjEuMFxuICAgKlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vZG1hamRhL2NvZGllXG4gICAqXG4gICAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIERhdmlkIE1hamRhXG4gICAqIExpY2Vuc2VuZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gICAqL1xuICB2YXIgQ29kaWUgPSAoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG5cbiAgZnVuY3Rpb24gc3RyaW5nRXNjYXBlKHMpIHtcbiAgICBmdW5jdGlvbiBoZXgoY2gpIHsgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH1cblxuICAgIC8qXG4gICAgICogRUNNQS0yNjIsIDV0aCBlZC4sIDcuOC40OiBBbGwgY2hhcmFjdGVycyBtYXkgYXBwZWFyIGxpdGVyYWxseSBpbiBhXG4gICAgICogc3RyaW5nIGxpdGVyYWwgZXhjZXB0IGZvciB0aGUgY2xvc2luZyBxdW90ZSBjaGFyYWN0ZXIsIGJhY2tzbGFzaCxcbiAgICAgKiBjYXJyaWFnZSByZXR1cm4sIGxpbmUgc2VwYXJhdG9yLCBwYXJhZ3JhcGggc2VwYXJhdG9yLCBhbmQgbGluZSBmZWVkLlxuICAgICAqIEFueSBjaGFyYWN0ZXIgbWF5IGFwcGVhciBpbiB0aGUgZm9ybSBvZiBhbiBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBGb3IgcG9ydGFiaWxpdHksIHdlIGFsc28gZXNjYXBlIGVzY2FwZSBhbGwgY29udHJvbCBhbmQgbm9uLUFTQ0lJXG4gICAgICogY2hhcmFjdGVycy4gTm90ZSB0aGF0IFwiXFwwXCIgYW5kIFwiXFx2XCIgZXNjYXBlIHNlcXVlbmNlcyBhcmUgbm90IHVzZWRcbiAgICAgKiBiZWNhdXNlIEpTSGludCBkb2VzIG5vdCBsaWtlIHRoZSBmaXJzdCBhbmQgSUUgdGhlIHNlY29uZC5cbiAgICAgKi9cbiAgICByZXR1cm4gc1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgICAnXFxcXFxcXFwnKSAvLyBiYWNrc2xhc2hcbiAgICAgIC5yZXBsYWNlKC9cIi9nLCAgICAnXFxcXFwiJykgIC8vIGNsb3NpbmcgZG91YmxlIHF1b3RlXG4gICAgICAucmVwbGFjZSgvXFx4MDgvZywgJ1xcXFxiJykgIC8vIGJhY2tzcGFjZVxuICAgICAgLnJlcGxhY2UoL1xcdC9nLCAgICdcXFxcdCcpICAvLyBob3Jpem9udGFsIHRhYlxuICAgICAgLnJlcGxhY2UoL1xcbi9nLCAgICdcXFxcbicpICAvLyBsaW5lIGZlZWRcbiAgICAgIC5yZXBsYWNlKC9cXGYvZywgICAnXFxcXGYnKSAgLy8gZm9ybSBmZWVkXG4gICAgICAucmVwbGFjZSgvXFxyL2csICAgJ1xcXFxyJykgIC8vIGNhcnJpYWdlIHJldHVyblxuICAgICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgwN1xceDBCXFx4MEVcXHgwRl0vZywgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceDAnICsgaGV4KGNoKTsgfSlcbiAgICAgIC5yZXBsYWNlKC9bXFx4MTAtXFx4MUZcXHg4MC1cXHhGRl0vZywgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceCcgICsgaGV4KGNoKTsgfSlcbiAgICAgIC5yZXBsYWNlKC9bXFx1MDE4MC1cXHUwRkZGXS9nLCAgICAgICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHUwJyArIGhleChjaCk7IH0pXG4gICAgICAucmVwbGFjZSgvW1xcdTEwODAtXFx1RkZGRl0vZywgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx1JyAgKyBoZXgoY2gpOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2gocykgeyByZXR1cm4gJ19fcC5wdXNoKCcgKyBzICsgJyk7JzsgfVxuXG4gIGZ1bmN0aW9uIHB1c2hSYXcodGVtcGxhdGUsIGxlbmd0aCwgc3RhdGUpIHtcbiAgICBmdW5jdGlvbiB1bmluZGVudChjb2RlLCBsZXZlbCwgdW5pbmRlbnRGaXJzdCkge1xuICAgICAgcmV0dXJuIGNvZGUucmVwbGFjZShcbiAgICAgICAgbmV3IFJlZ0V4cCgnXi57JyArIGxldmVsICsnfScsIFwiZ21cIiksXG4gICAgICAgIGZ1bmN0aW9uKHN0ciwgb2Zmc2V0KSB7XG4gICAgICAgICAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuaW5kZW50Rmlyc3QgPyAnJyA6IHN0cjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBlc2NhcGVkID0gc3RyaW5nRXNjYXBlKHVuaW5kZW50KFxuICAgICAgICAgIHRlbXBsYXRlLnN1YnN0cmluZygwLCBsZW5ndGgpLFxuICAgICAgICAgIHN0YXRlLmluZGVudExldmVsKCksXG4gICAgICAgICAgc3RhdGUuYXRCT0xcbiAgICAgICAgKSk7XG5cbiAgICByZXR1cm4gZXNjYXBlZC5sZW5ndGggPiAwID8gcHVzaCgnXCInICsgZXNjYXBlZCArICdcIicpIDogJyc7XG4gIH1cblxuXG4gIHZhciBDb2RpZSA9IHtcbiAgICAvKiBDb2RpZSB2ZXJzaW9uICh1c2VzIHNlbWFudGljIHZlcnNpb25pbmcpLiAqL1xuICAgIFZFUlNJT046IFwiMS4xLjBcIixcblxuICAgIC8qXG4gICAgICogU3BlY2lmaWVzIGJ5IGhvdyBtYW55IGNoYXJhY3RlcnMgZG8gI2lmLyNlbHNlIGFuZCAjZm9yIHVuaW5kZW50IHRoZWlyXG4gICAgICogY29udGVudCBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUuXG4gICAgICovXG4gICAgaW5kZW50U3RlcDogMixcblxuICAgIC8qIERlc2NyaXB0aW9uIG9mICMtY29tbWFuZHMuIEV4dGVuZCB0byBkZWZpbmUgeW91ciBvd24gY29tbWFuZHMuICovXG4gICAgY29tbWFuZHM6IHtcbiAgICAgIFwiaWZcIjogICB7XG4gICAgICAgIHBhcmFtczogIC9eKC4qKSQvLFxuICAgICAgICBjb21waWxlOiBmdW5jdGlvbihzdGF0ZSwgcHJlZml4LCBwYXJhbXMpIHtcbiAgICAgICAgICByZXR1cm4gWydpZignICsgcGFyYW1zWzBdICsgJyl7JywgW11dO1xuICAgICAgICB9LFxuICAgICAgICBzdGFja09wOiBcInB1c2hcIlxuICAgICAgfSxcbiAgICAgIFwiZWxzZVwiOiB7XG4gICAgICAgIHBhcmFtczogIC9eJC8sXG4gICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgdmFyIHN0YWNrID0gc3RhdGUuY29tbWFuZFN0YWNrLFxuICAgICAgICAgICAgICBpbnNpZGVFbHNlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiZWxzZVwiLFxuICAgICAgICAgICAgICBpbnNpZGVJZiAgID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiaWZcIjtcblxuICAgICAgICAgIGlmIChpbnNpZGVFbHNlKSB7IHRocm93IG5ldyBFcnJvcihcIk11bHRpcGxlICNlbHNlcy5cIik7IH1cbiAgICAgICAgICBpZiAoIWluc2lkZUlmKSAgeyB0aHJvdyBuZXcgRXJyb3IoXCJVc2luZyAjZWxzZSBvdXRzaWRlIG9mICNpZi5cIik7IH1cblxuICAgICAgICAgIHJldHVybiBbJ31lbHNleycsIFtdXTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RhY2tPcDogXCJyZXBsYWNlXCJcbiAgICAgIH0sXG4gICAgICBcImZvclwiOiAge1xuICAgICAgICBwYXJhbXM6ICAvXihbYS16QS1aX11bYS16QS1aMC05X10qKVsgXFx0XStpblsgXFx0XSsoLiopJC8sXG4gICAgICAgIGluaXQ6ICAgIGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgc3RhdGUuZm9yQ3VyckxldmVsID0gMDsgIC8vIGN1cnJlbnQgbGV2ZWwgb2YgI2ZvciBsb29wIG5lc3RpbmdcbiAgICAgICAgICBzdGF0ZS5mb3JNYXhMZXZlbCAgPSAwOyAgLy8gbWF4aW11bSBsZXZlbCBvZiAjZm9yIGxvb3AgbmVzdGluZ1xuICAgICAgICB9LFxuICAgICAgICBjb21waWxlOiBmdW5jdGlvbihzdGF0ZSwgcHJlZml4LCBwYXJhbXMpIHtcbiAgICAgICAgICB2YXIgYyA9ICdfX2MnICsgc3RhdGUuZm9yQ3VyckxldmVsLCAvLyBfX2MgZm9yIFwiY29sbGVjdGlvblwiXG4gICAgICAgICAgICAgIGwgPSAnX19sJyArIHN0YXRlLmZvckN1cnJMZXZlbCwgLy8gX19sIGZvciBcImxlbmd0aFwiXG4gICAgICAgICAgICAgIGkgPSAnX19pJyArIHN0YXRlLmZvckN1cnJMZXZlbDsgLy8gX19pIGZvciBcImluZGV4XCJcblxuICAgICAgICAgIHN0YXRlLmZvckN1cnJMZXZlbCsrO1xuICAgICAgICAgIGlmIChzdGF0ZS5mb3JNYXhMZXZlbCA8IHN0YXRlLmZvckN1cnJMZXZlbCkge1xuICAgICAgICAgICAgc3RhdGUuZm9yTWF4TGV2ZWwgPSBzdGF0ZS5mb3JDdXJyTGV2ZWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGMgKyAnPScgKyBwYXJhbXNbMV0gKyAnOydcbiAgICAgICAgICAgICAgKyBsICsgJz0nICsgYyArICcubGVuZ3RoOydcbiAgICAgICAgICAgICAgKyAnZm9yKCcgKyBpICsgJz0wOycgKyBpICsgJzwnICsgbCArICc7JyArIGkgKyAnKyspeydcbiAgICAgICAgICAgICAgKyBwYXJhbXNbMF0gKyAnPScgKyBjICsgJ1snICsgaSArICddOycsXG4gICAgICAgICAgICBbcGFyYW1zWzBdLCBjLCBsLCBpXVxuICAgICAgICAgIF07XG4gICAgICAgIH0sXG4gICAgICAgIGV4aXQ6ICAgIGZ1bmN0aW9uKHN0YXRlKSB7IHN0YXRlLmZvckN1cnJMZXZlbC0tOyB9LFxuICAgICAgICBzdGFja09wOiBcInB1c2hcIlxuICAgICAgfSxcbiAgICAgIFwiZW5kXCI6ICB7XG4gICAgICAgIHBhcmFtczogIC9eJC8sXG4gICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgdmFyIHN0YWNrID0gc3RhdGUuY29tbWFuZFN0YWNrLCBleGl0O1xuXG4gICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJUb28gbWFueSAjZW5kcy5cIik7IH1cblxuICAgICAgICAgIGV4aXQgPSBDb2RpZS5jb21tYW5kc1tzdGFja1tzdGFjay5sZW5ndGggLSAxXV0uZXhpdDtcbiAgICAgICAgICBpZiAoZXhpdCkgeyBleGl0KHN0YXRlKTsgfVxuXG4gICAgICAgICAgcmV0dXJuIFsnfScsIFtdXTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RhY2tPcDogXCJwb3BcIlxuICAgICAgfSxcbiAgICAgIFwiYmxvY2tcIjoge1xuICAgICAgICBwYXJhbXM6IC9eKC4qKSQvLFxuICAgICAgICBjb21waWxlOiBmdW5jdGlvbihzdGF0ZSwgcHJlZml4LCBwYXJhbXMpIHtcbiAgICAgICAgICB2YXIgeCA9ICdfX3gnLCAvLyBfX3ggZm9yIFwicHJlZml4XCIsXG4gICAgICAgICAgICAgIG4gPSAnX19uJywgLy8gX19uIGZvciBcImxpbmVzXCJcbiAgICAgICAgICAgICAgbCA9ICdfX2wnLCAvLyBfX2wgZm9yIFwibGVuZ3RoXCJcbiAgICAgICAgICAgICAgaSA9ICdfX2knOyAvLyBfX2kgZm9yIFwiaW5kZXhcIlxuXG4gICAgICAgICAgLypcbiAgICAgICAgICAgKiBPcmlnaW5hbGx5LCB0aGUgZ2VuZXJhdGVkIGNvZGUgdXNlZCB8U3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlfCwgYnV0XG4gICAgICAgICAgICogaXQgaXMgYnVnZ3kgaW4gY2VydGFpbiB2ZXJzaW9ucyBvZiBWOCBzbyBpdCB3YXMgcmV3cml0dGVuLiBTZWUgdGhlXG4gICAgICAgICAgICogdGVzdHMgZm9yIGRldGFpbHMuXG4gICAgICAgICAgICovXG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHggKyAnPVwiJyArIHN0cmluZ0VzY2FwZShwcmVmaXguc3Vic3RyaW5nKHN0YXRlLmluZGVudExldmVsKCkpKSArICdcIjsnXG4gICAgICAgICAgICAgICsgbiArICc9KCcgKyBwYXJhbXNbMF0gKyAnKS50b1N0cmluZygpLnNwbGl0KFwiXFxcXG5cIik7J1xuICAgICAgICAgICAgICArIGwgKyAnPScgKyBuICsgJy5sZW5ndGg7J1xuICAgICAgICAgICAgICArICdmb3IoJyArIGkgKyAnPTA7JyArIGkgKyAnPCcgKyBsICsgJzsnICsgaSArICcrKyl7J1xuICAgICAgICAgICAgICArIG4gKyAnWycgKyBpICsnXT0nICsgeCArICcrJyArIG4gKyAnWycgKyBpICsgJ10rXCJcXFxcblwiOydcbiAgICAgICAgICAgICAgKyAnfSdcbiAgICAgICAgICAgICAgKyBwdXNoKG4gKyAnLmpvaW4oXCJcIiknKSxcbiAgICAgICAgICAgIFt4LCBuLCBsLCBpXVxuICAgICAgICAgIF07XG4gICAgICAgIH0sXG4gICAgICAgIHN0YWNrT3A6IFwibm9wXCJcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDb21waWxlcyBhIHRlbXBsYXRlIGludG8gYSBmdW5jdGlvbi4gV2hlbiBjYWxsZWQsIHRoaXMgZnVuY3Rpb24gd2lsbFxuICAgICAqIGV4ZWN1dGUgdGhlIHRlbXBsYXRlIGluIHRoZSBjb250ZXh0IG9mIGFuIG9iamVjdCBwYXNzZWQgaW4gYSBwYXJhbWV0ZXIgYW5kXG4gICAgICogcmV0dXJuIHRoZSByZXN1bHQuXG4gICAgICovXG4gICAgdGVtcGxhdGU6IGZ1bmN0aW9uKHRlbXBsYXRlKSB7XG4gICAgICB2YXIgc3RhY2tPcHMgPSB7XG4gICAgICAgIHB1c2g6ICAgIGZ1bmN0aW9uKHN0YWNrLCBuYW1lKSB7IHN0YWNrLnB1c2gobmFtZSk7IH0sXG4gICAgICAgIHJlcGxhY2U6IGZ1bmN0aW9uKHN0YWNrLCBuYW1lKSB7IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID0gbmFtZTsgfSxcbiAgICAgICAgcG9wOiAgICAgZnVuY3Rpb24oc3RhY2spICAgICAgIHsgc3RhY2sucG9wKCk7IH0sXG4gICAgICAgIG5vcDogICAgIGZ1bmN0aW9uKCkgICAgICAgICAgICB7IH1cbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGNvbXBpbGVFeHByKHN0YXRlLCBleHByKSB7XG4gICAgICAgIHN0YXRlLmF0Qk9MID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBbcHVzaChleHByKSwgW11dO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjb21waWxlQ29tbWFuZChzdGF0ZSwgcHJlZml4LCBuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIGNvbW1hbmQsIG1hdGNoLCByZXN1bHQ7XG5cbiAgICAgICAgY29tbWFuZCA9IENvZGllLmNvbW1hbmRzW25hbWVdO1xuICAgICAgICBpZiAoIWNvbW1hbmQpIHsgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjb21tYW5kOiAjXCIgKyBuYW1lICsgXCIuXCIpOyB9XG5cbiAgICAgICAgbWF0Y2ggPSBjb21tYW5kLnBhcmFtcy5leGVjKHBhcmFtcyk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiSW52YWxpZCBwYXJhbXMgZm9yIGNvbW1hbmQgI1wiICsgbmFtZSArIFwiOiBcIiArIHBhcmFtcyArIFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IGNvbW1hbmQuY29tcGlsZShzdGF0ZSwgcHJlZml4LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgIHN0YWNrT3BzW2NvbW1hbmQuc3RhY2tPcF0oc3RhdGUuY29tbWFuZFN0YWNrLCBuYW1lKTtcbiAgICAgICAgc3RhdGUuYXRCT0wgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhdGUgPSB7ICAgICAgICAgICAgICAgLy8gY29tcGlsYXRpb24gc3RhdGVcbiAgICAgICAgICAgIGNvbW1hbmRTdGFjazogW10sICAgICAvLyAgIHN0YWNrIG9mIGNvbW1hbmRzIGFzIHRoZXkgd2VyZSBuZXN0ZWRcbiAgICAgICAgICAgIGF0Qk9MOiAgICAgICAgdHJ1ZSwgICAvLyAgIGlzIHRoZSBuZXh0IGNoYXJhY3RlciB0byBwcm9jZXNzIGF0IEJPTD9cbiAgICAgICAgICAgIGluZGVudExldmVsOiAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBDb2RpZS5pbmRlbnRTdGVwICogdGhpcy5jb21tYW5kU3RhY2subGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29kZSA9ICcnLCAgICAgICAgICAgICAgLy8gZ2VuZXJhdGVkIHRlbXBsYXRlIGZ1bmN0aW9uIGNvZGVcbiAgICAgICAgICB2YXJzID0gWydfX3A9W10nXSwgICAgICAvLyB2YXJpYWJsZXMgdXNlZCBieSBnZW5lcmF0ZWQgY29kZVxuICAgICAgICAgIG5hbWUsIG1hdGNoLCByZXN1bHQsIGk7XG5cbiAgICAgIC8qIEluaXRpYWxpemUgc3RhdGUuICovXG4gICAgICBmb3IgKG5hbWUgaW4gQ29kaWUuY29tbWFuZHMpIHtcbiAgICAgICAgaWYgKENvZGllLmNvbW1hbmRzW25hbWVdLmluaXQpIHsgQ29kaWUuY29tbWFuZHNbbmFtZV0uaW5pdChzdGF0ZSk7IH1cbiAgICAgIH1cblxuICAgICAgLyogQ29tcGlsZSB0aGUgdGVtcGxhdGUuICovXG4gICAgICB3aGlsZSAoKG1hdGNoID0gL14oWyBcXHRdKikjKFthLXpBLVpfXVthLXpBLVowLTlfXSopKD86WyBcXHRdKyhbXiBcXHRcXG5dW15cXG5dKikpP1sgXFx0XSooPzpcXG58JCl8I1xceyhbXn1dKilcXH0vbS5leGVjKHRlbXBsYXRlKSkgIT09IG51bGwpIHtcbiAgICAgICAgY29kZSArPSBwdXNoUmF3KHRlbXBsYXRlLCBtYXRjaC5pbmRleCwgc3RhdGUpO1xuICAgICAgICByZXN1bHQgPSBtYXRjaFsyXSAhPT0gdW5kZWZpbmVkICYmIG1hdGNoWzJdICE9PSBcIlwiXG4gICAgICAgICAgPyBjb21waWxlQ29tbWFuZChzdGF0ZSwgbWF0Y2hbMV0sIG1hdGNoWzJdLCBtYXRjaFszXSB8fCBcIlwiKSAvLyAjLWNvbW1hbmRcbiAgICAgICAgICA6IGNvbXBpbGVFeHByKHN0YXRlLCBtYXRjaFs0XSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAjey4uLn1cbiAgICAgICAgY29kZSArPSByZXN1bHRbMF07XG4gICAgICAgIHZhcnMgPSB2YXJzLmNvbmNhdChyZXN1bHRbMV0pO1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnN1YnN0cmluZyhtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBjb2RlICs9IHB1c2hSYXcodGVtcGxhdGUsIHRlbXBsYXRlLmxlbmd0aCwgc3RhdGUpO1xuXG4gICAgICAvKiBDaGVjayB0aGUgZmluYWwgc3RhdGUuICovXG4gICAgICBpZiAoc3RhdGUuY29tbWFuZFN0YWNrLmxlbmd0aCA+IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyAjZW5kLlwiKTsgfVxuXG4gICAgICAvKiBTYW5pdGl6ZSB0aGUgbGlzdCBvZiB2YXJpYWJsZXMgdXNlZCBieSBjb21tYW5kcy4gKi9cbiAgICAgIHZhcnMuc29ydCgpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHZhcnNbaV0gPT09IHZhcnNbaSAtIDFdKSB7IHZhcnMuc3BsaWNlKGktLSwgMSk7IH1cbiAgICAgIH1cblxuICAgICAgLyogQ3JlYXRlIHRoZSByZXN1bHRpbmcgZnVuY3Rpb24uICovXG4gICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwiX192XCIsIFtcbiAgICAgICAgJ19fdj1fX3Z8fHt9OycsXG4gICAgICAgICd2YXIgJyArIHZhcnMuam9pbignLCcpICsgJzsnLFxuICAgICAgICAnd2l0aChfX3YpeycsXG4gICAgICAgIGNvZGUsXG4gICAgICAgICdyZXR1cm4gX19wLmpvaW4oXCJcIikucmVwbGFjZSgvXlxcXFxuK3xcXFxcbiskL2csXCJcIik7fTsnXG4gICAgICBdLmpvaW4oJycpKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENvZGllO1xuXG4gIH0pKCk7XG5cbiAgdmFyIHRlbXBsYXRlcyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgbmFtZSxcbiAgICAgICAgdGVtcGxhdGVzID0ge30sXG4gICAgICAgIHNvdXJjZXMgPSB7XG4gICAgICAgICAgZ3JhbW1hcjogW1xuICAgICAgICAgICAgJyhmdW5jdGlvbigpeycsXG4gICAgICAgICAgICAnICAvKicsXG4gICAgICAgICAgICAnICAgKiBHZW5lcmF0ZWQgYnkgUEVHLmpzIDAuNy4wLicsXG4gICAgICAgICAgICAnICAgKicsXG4gICAgICAgICAgICAnICAgKiBodHRwOi8vcGVnanMubWFqZGEuY3ovJyxcbiAgICAgICAgICAgICcgICAqLycsXG4gICAgICAgICAgICAnICAnLFxuICAgICAgICAgICAgLyogVGhpcyBuZWVkcyB0byBiZSBpbiBzeW5jIHdpdGggfHF1b3RlfCBpbiB1dGlscy5qcy4gKi9cbiAgICAgICAgICAgICcgIGZ1bmN0aW9uIHF1b3RlKHMpIHsnLFxuICAgICAgICAgICAgJyAgICAvKicsXG4gICAgICAgICAgICAnICAgICAqIEVDTUEtMjYyLCA1dGggZWQuLCA3LjguNDogQWxsIGNoYXJhY3RlcnMgbWF5IGFwcGVhciBsaXRlcmFsbHkgaW4gYScsXG4gICAgICAgICAgICAnICAgICAqIHN0cmluZyBsaXRlcmFsIGV4Y2VwdCBmb3IgdGhlIGNsb3NpbmcgcXVvdGUgY2hhcmFjdGVyLCBiYWNrc2xhc2gsJyxcbiAgICAgICAgICAgICcgICAgICogY2FycmlhZ2UgcmV0dXJuLCBsaW5lIHNlcGFyYXRvciwgcGFyYWdyYXBoIHNlcGFyYXRvciwgYW5kIGxpbmUgZmVlZC4nLFxuICAgICAgICAgICAgJyAgICAgKiBBbnkgY2hhcmFjdGVyIG1heSBhcHBlYXIgaW4gdGhlIGZvcm0gb2YgYW4gZXNjYXBlIHNlcXVlbmNlLicsXG4gICAgICAgICAgICAnICAgICAqJyxcbiAgICAgICAgICAgICcgICAgICogRm9yIHBvcnRhYmlsaXR5LCB3ZSBhbHNvIGVzY2FwZSBlc2NhcGUgYWxsIGNvbnRyb2wgYW5kIG5vbi1BU0NJSScsXG4gICAgICAgICAgICAnICAgICAqIGNoYXJhY3RlcnMuIE5vdGUgdGhhdCBcIlxcXFwwXCIgYW5kIFwiXFxcXHZcIiBlc2NhcGUgc2VxdWVuY2VzIGFyZSBub3QgdXNlZCcsXG4gICAgICAgICAgICAnICAgICAqIGJlY2F1c2UgSlNIaW50IGRvZXMgbm90IGxpa2UgdGhlIGZpcnN0IGFuZCBJRSB0aGUgc2Vjb25kLicsXG4gICAgICAgICAgICAnICAgICAqLycsXG4gICAgICAgICAgICAnICAgICByZXR1cm4gXFwnXCJcXCcgKyBzJyxcbiAgICAgICAgICAgICcgICAgICAucmVwbGFjZSgvXFxcXFxcXFwvZywgXFwnXFxcXFxcXFxcXFxcXFxcXFxcJykgIC8vIGJhY2tzbGFzaCcsXG4gICAgICAgICAgICAnICAgICAgLnJlcGxhY2UoL1wiL2csIFxcJ1xcXFxcXFxcXCJcXCcpICAgIC8vIGNsb3NpbmcgcXVvdGUgY2hhcmFjdGVyJyxcbiAgICAgICAgICAgICcgICAgICAucmVwbGFjZSgvXFxcXHgwOC9nLCBcXCdcXFxcXFxcXGJcXCcpIC8vIGJhY2tzcGFjZScsXG4gICAgICAgICAgICAnICAgICAgLnJlcGxhY2UoL1xcXFx0L2csIFxcJ1xcXFxcXFxcdFxcJykgICAvLyBob3Jpem9udGFsIHRhYicsXG4gICAgICAgICAgICAnICAgICAgLnJlcGxhY2UoL1xcXFxuL2csIFxcJ1xcXFxcXFxcblxcJykgICAvLyBsaW5lIGZlZWQnLFxuICAgICAgICAgICAgJyAgICAgIC5yZXBsYWNlKC9cXFxcZi9nLCBcXCdcXFxcXFxcXGZcXCcpICAgLy8gZm9ybSBmZWVkJyxcbiAgICAgICAgICAgICcgICAgICAucmVwbGFjZSgvXFxcXHIvZywgXFwnXFxcXFxcXFxyXFwnKSAgIC8vIGNhcnJpYWdlIHJldHVybicsXG4gICAgICAgICAgICAnICAgICAgLnJlcGxhY2UoL1tcXFxceDAwLVxcXFx4MDdcXFxceDBCXFxcXHgwRS1cXFxceDFGXFxcXHg4MC1cXFxcdUZGRkZdL2csIGVzY2FwZSknLFxuICAgICAgICAgICAgJyAgICAgICsgXFwnXCJcXCc7JyxcbiAgICAgICAgICAgICcgIH0nLFxuICAgICAgICAgICAgJyAgJyxcbiAgICAgICAgICAgICcgIHZhciByZXN1bHQgPSB7JyxcbiAgICAgICAgICAgICcgICAgLyonLFxuICAgICAgICAgICAgJyAgICAgKiBQYXJzZXMgdGhlIGlucHV0IHdpdGggYSBnZW5lcmF0ZWQgcGFyc2VyLiBJZiB0aGUgcGFyc2luZyBpcyBzdWNjZXNzZnVsbCwnLFxuICAgICAgICAgICAgJyAgICAgKiByZXR1cm5zIGEgdmFsdWUgZXhwbGljaXRseSBvciBpbXBsaWNpdGx5IHNwZWNpZmllZCBieSB0aGUgZ3JhbW1hciBmcm9tJyxcbiAgICAgICAgICAgICcgICAgICogd2hpY2ggdGhlIHBhcnNlciB3YXMgZ2VuZXJhdGVkIChzZWUgfFBFRy5idWlsZFBhcnNlcnwpLiBJZiB0aGUgcGFyc2luZyBpcycsXG4gICAgICAgICAgICAnICAgICAqIHVuc3VjY2Vzc2Z1bCwgdGhyb3dzIHxQRUcucGFyc2VyLlN5bnRheEVycm9yfCBkZXNjcmliaW5nIHRoZSBlcnJvci4nLFxuICAgICAgICAgICAgJyAgICAgKi8nLFxuICAgICAgICAgICAgJyAgICBwYXJzZTogZnVuY3Rpb24oaW5wdXQsIHN0YXJ0UnVsZSkgeycsXG4gICAgICAgICAgICAnICAgICAgdmFyIHBhcnNlRnVuY3Rpb25zID0geycsXG4gICAgICAgICAgICAnICAgICAgICAjZm9yIHJ1bGUgaW4gbm9kZS5ydWxlcycsXG4gICAgICAgICAgICAnICAgICAgICAgICN7c3RyaW5nKHJ1bGUubmFtZSkgKyBcIjogcGFyc2VfXCIgKyBydWxlLm5hbWUgKyAocnVsZSAhPT0gbm9kZS5ydWxlc1tub2RlLnJ1bGVzLmxlbmd0aCAtIDFdID8gXCIsXCIgOiBcIlwiKX0nLFxuICAgICAgICAgICAgJyAgICAgICAgI2VuZCcsXG4gICAgICAgICAgICAnICAgICAgfTsnLFxuICAgICAgICAgICAgJyAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgaWYgKHN0YXJ0UnVsZSAhPT0gdW5kZWZpbmVkKSB7JyxcbiAgICAgICAgICAgICcgICAgICAgIGlmIChwYXJzZUZ1bmN0aW9uc1tzdGFydFJ1bGVdID09PSB1bmRlZmluZWQpIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJ1bGUgbmFtZTogXCIgKyBxdW90ZShzdGFydFJ1bGUpICsgXCIuXCIpOycsXG4gICAgICAgICAgICAnICAgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICB9IGVsc2UgeycsXG4gICAgICAgICAgICAnICAgICAgICBzdGFydFJ1bGUgPSAje3N0cmluZyhub2RlLnN0YXJ0UnVsZSl9OycsXG4gICAgICAgICAgICAnICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAje3Bvc0luaXQoXCJwb3NcIil9OycsXG4gICAgICAgICAgICAnICAgICAgdmFyIHJlcG9ydEZhaWx1cmVzID0gMDsnLCAvLyAwID0gcmVwb3J0LCBhbnl0aGluZyA+IDAgPSBkbyBub3QgcmVwb3J0XG4gICAgICAgICAgICAnICAgICAgI3twb3NJbml0KFwicmlnaHRtb3N0RmFpbHVyZXNQb3NcIil9OycsXG4gICAgICAgICAgICAnICAgICAgdmFyIHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWQgPSBbXTsnLFxuICAgICAgICAgICAgJyAgICAgICNpZiBvcHRpb25zLmNhY2hlJyxcbiAgICAgICAgICAgICcgICAgICAgIHZhciBjYWNoZSA9IHt9OycsXG4gICAgICAgICAgICAnICAgICAgI2VuZCcsXG4gICAgICAgICAgICAnICAgICAgJyxcbiAgICAgICAgICAgIC8qIFRoaXMgbmVlZHMgdG8gYmUgaW4gc3luYyB3aXRoIHxwYWRMZWZ0fCBpbiB1dGlscy5qcy4gKi9cbiAgICAgICAgICAgICcgICAgICBmdW5jdGlvbiBwYWRMZWZ0KGlucHV0LCBwYWRkaW5nLCBsZW5ndGgpIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgdmFyIHJlc3VsdCA9IGlucHV0OycsXG4gICAgICAgICAgICAnICAgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgICAgdmFyIHBhZExlbmd0aCA9IGxlbmd0aCAtIGlucHV0Lmxlbmd0aDsnLFxuICAgICAgICAgICAgJyAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRMZW5ndGg7IGkrKykgeycsXG4gICAgICAgICAgICAnICAgICAgICAgIHJlc3VsdCA9IHBhZGRpbmcgKyByZXN1bHQ7JyxcbiAgICAgICAgICAgICcgICAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAgIHJldHVybiByZXN1bHQ7JyxcbiAgICAgICAgICAgICcgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICAnLFxuICAgICAgICAgICAgLyogVGhpcyBuZWVkcyB0byBiZSBpbiBzeW5jIHdpdGggfGVzY2FwZXwgaW4gdXRpbHMuanMuICovXG4gICAgICAgICAgICAnICAgICAgZnVuY3Rpb24gZXNjYXBlKGNoKSB7JyxcbiAgICAgICAgICAgICcgICAgICAgIHZhciBjaGFyQ29kZSA9IGNoLmNoYXJDb2RlQXQoMCk7JyxcbiAgICAgICAgICAgICcgICAgICAgIHZhciBlc2NhcGVDaGFyOycsXG4gICAgICAgICAgICAnICAgICAgICB2YXIgbGVuZ3RoOycsXG4gICAgICAgICAgICAnICAgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgICAgaWYgKGNoYXJDb2RlIDw9IDB4RkYpIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgICBlc2NhcGVDaGFyID0gXFwneFxcJzsnLFxuICAgICAgICAgICAgJyAgICAgICAgICBsZW5ndGggPSAyOycsXG4gICAgICAgICAgICAnICAgICAgICB9IGVsc2UgeycsXG4gICAgICAgICAgICAnICAgICAgICAgIGVzY2FwZUNoYXIgPSBcXCd1XFwnOycsXG4gICAgICAgICAgICAnICAgICAgICAgIGxlbmd0aCA9IDQ7JyxcbiAgICAgICAgICAgICcgICAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAgIHJldHVybiBcXCdcXFxcXFxcXFxcJyArIGVzY2FwZUNoYXIgKyBwYWRMZWZ0KGNoYXJDb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLCBcXCcwXFwnLCBsZW5ndGgpOycsXG4gICAgICAgICAgICAnICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAjaWYgb3B0aW9ucy50cmFja0xpbmVBbmRDb2x1bW4nLFxuICAgICAgICAgICAgJyAgICAgICAgZnVuY3Rpb24gY2xvbmUob2JqZWN0KSB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9OycsXG4gICAgICAgICAgICAnICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07JyxcbiAgICAgICAgICAgICcgICAgICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgICAgIHJldHVybiByZXN1bHQ7JyxcbiAgICAgICAgICAgICcgICAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAgIGZ1bmN0aW9uIGFkdmFuY2UocG9zLCBuKSB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgdmFyIGVuZE9mZnNldCA9IHBvcy5vZmZzZXQgKyBuOycsXG4gICAgICAgICAgICAnICAgICAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgICAgIGZvciAodmFyIG9mZnNldCA9IHBvcy5vZmZzZXQ7IG9mZnNldCA8IGVuZE9mZnNldDsgb2Zmc2V0KyspIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgIHZhciBjaCA9IGlucHV0LmNoYXJBdChvZmZzZXQpOycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgaWYgKGNoID09PSBcIlxcXFxuXCIpIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgICAgaWYgKCFwb3Muc2VlbkNSKSB7IHBvcy5saW5lKys7IH0nLFxuICAgICAgICAgICAgJyAgICAgICAgICAgICAgcG9zLmNvbHVtbiA9IDE7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICAgIHBvcy5zZWVuQ1IgPSBmYWxzZTsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiXFxcXHJcIiB8fCBjaCA9PT0gXCJcXFxcdTIwMjhcIiB8fCBjaCA9PT0gXCJcXFxcdTIwMjlcIikgeycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgICBwb3MubGluZSsrOycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgICBwb3MuY29sdW1uID0gMTsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgICAgcG9zLnNlZW5DUiA9IHRydWU7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICB9IGVsc2UgeycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgICBwb3MuY29sdW1uKys7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICAgIHBvcy5zZWVuQ1IgPSBmYWxzZTsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAgICAgcG9zLm9mZnNldCArPSBuOycsXG4gICAgICAgICAgICAnICAgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgI2VuZCcsXG4gICAgICAgICAgICAnICAgICAgZnVuY3Rpb24gbWF0Y2hGYWlsZWQoZmFpbHVyZSkgeycsXG4gICAgICAgICAgICAnICAgICAgICBpZiAoI3twb3NPZmZzZXQoXCJwb3NcIil9IDwgI3twb3NPZmZzZXQoXCJyaWdodG1vc3RGYWlsdXJlc1Bvc1wiKX0pIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgICByZXR1cm47JyxcbiAgICAgICAgICAgICcgICAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAgIGlmICgje3Bvc09mZnNldChcInBvc1wiKX0gPiAje3Bvc09mZnNldChcInJpZ2h0bW9zdEZhaWx1cmVzUG9zXCIpfSkgeycsXG4gICAgICAgICAgICAnICAgICAgICAgIHJpZ2h0bW9zdEZhaWx1cmVzUG9zID0gI3twb3NDbG9uZShcInBvc1wiKX07JyxcbiAgICAgICAgICAgICcgICAgICAgICAgcmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZCA9IFtdOycsXG4gICAgICAgICAgICAnICAgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgICByaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkLnB1c2goZmFpbHVyZSk7JyxcbiAgICAgICAgICAgICcgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgICNmb3IgcnVsZSBpbiBub2RlLnJ1bGVzJyxcbiAgICAgICAgICAgICcgICAgICAgICNibG9jayBlbWl0KHJ1bGUpJyxcbiAgICAgICAgICAgICcgICAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgI2VuZCcsXG4gICAgICAgICAgICAnICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICBmdW5jdGlvbiBjbGVhbnVwRXhwZWN0ZWQoZXhwZWN0ZWQpIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgZXhwZWN0ZWQuc29ydCgpOycsXG4gICAgICAgICAgICAnICAgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgICAgdmFyIGxhc3RFeHBlY3RlZCA9IG51bGw7JyxcbiAgICAgICAgICAgICcgICAgICAgIHZhciBjbGVhbkV4cGVjdGVkID0gW107JyxcbiAgICAgICAgICAgICcgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWQubGVuZ3RoOyBpKyspIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgICBpZiAoZXhwZWN0ZWRbaV0gIT09IGxhc3RFeHBlY3RlZCkgeycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgY2xlYW5FeHBlY3RlZC5wdXNoKGV4cGVjdGVkW2ldKTsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgIGxhc3RFeHBlY3RlZCA9IGV4cGVjdGVkW2ldOycsXG4gICAgICAgICAgICAnICAgICAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgICByZXR1cm4gY2xlYW5FeHBlY3RlZDsnLFxuICAgICAgICAgICAgJyAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgI2lmICFvcHRpb25zLnRyYWNrTGluZUFuZENvbHVtbicsXG4gICAgICAgICAgICAnICAgICAgICBmdW5jdGlvbiBjb21wdXRlRXJyb3JQb3NpdGlvbigpIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAvKicsXG4gICAgICAgICAgICAnICAgICAgICAgICAqIFRoZSBmaXJzdCBpZGVhIHdhcyB0byB1c2UgfFN0cmluZy5zcGxpdHwgdG8gYnJlYWsgdGhlIGlucHV0IHVwIHRvIHRoZScsXG4gICAgICAgICAgICAnICAgICAgICAgICAqIGVycm9yIHBvc2l0aW9uIGFsb25nIG5ld2xpbmVzIGFuZCBkZXJpdmUgdGhlIGxpbmUgYW5kIGNvbHVtbiBmcm9tJyxcbiAgICAgICAgICAgICcgICAgICAgICAgICogdGhlcmUuIEhvd2V2ZXIgSUVcXCdzIHxzcGxpdHwgaW1wbGVtZW50YXRpb24gaXMgc28gYnJva2VuIHRoYXQgaXQgd2FzJyxcbiAgICAgICAgICAgICcgICAgICAgICAgICogZW5vdWdoIHRvIHByZXZlbnQgaXQuJyxcbiAgICAgICAgICAgICcgICAgICAgICAgICovJyxcbiAgICAgICAgICAgICcgICAgICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAgICAgdmFyIGxpbmUgPSAxOycsXG4gICAgICAgICAgICAnICAgICAgICAgIHZhciBjb2x1bW4gPSAxOycsXG4gICAgICAgICAgICAnICAgICAgICAgIHZhciBzZWVuQ1IgPSBmYWxzZTsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWF4KHBvcywgcmlnaHRtb3N0RmFpbHVyZXNQb3MpOyBpKyspIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgIHZhciBjaCA9IGlucHV0LmNoYXJBdChpKTsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgIGlmIChjaCA9PT0gXCJcXFxcblwiKSB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICAgIGlmICghc2VlbkNSKSB7IGxpbmUrKzsgfScsXG4gICAgICAgICAgICAnICAgICAgICAgICAgICBjb2x1bW4gPSAxOycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgICBzZWVuQ1IgPSBmYWxzZTsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiXFxcXHJcIiB8fCBjaCA9PT0gXCJcXFxcdTIwMjhcIiB8fCBjaCA9PT0gXCJcXFxcdTIwMjlcIikgeycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgICBsaW5lKys7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICAgIGNvbHVtbiA9IDE7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICAgIHNlZW5DUiA9IHRydWU7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICB9IGVsc2UgeycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgICBjb2x1bW4rKzsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgICAgc2VlbkNSID0gZmFsc2U7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgICAgIHJldHVybiB7IGxpbmU6IGxpbmUsIGNvbHVtbjogY29sdW1uIH07JyxcbiAgICAgICAgICAgICcgICAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgICNlbmQnLFxuICAgICAgICAgICAgJyAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgI2lmIG5vZGUuaW5pdGlhbGl6ZXInLFxuICAgICAgICAgICAgJyAgICAgICAgI2Jsb2NrIGVtaXQobm9kZS5pbml0aWFsaXplciknLFxuICAgICAgICAgICAgJyAgICAgICNlbmQnLFxuICAgICAgICAgICAgJyAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlRnVuY3Rpb25zW3N0YXJ0UnVsZV0oKTsnLFxuICAgICAgICAgICAgJyAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgLyonLFxuICAgICAgICAgICAgJyAgICAgICAqIFRoZSBwYXJzZXIgaXMgbm93IGluIG9uZSBvZiB0aGUgZm9sbG93aW5nIHRocmVlIHN0YXRlczonLFxuICAgICAgICAgICAgJyAgICAgICAqJyxcbiAgICAgICAgICAgICcgICAgICAgKiAxLiBUaGUgcGFyc2VyIHN1Y2Nlc3NmdWxseSBwYXJzZWQgdGhlIHdob2xlIGlucHV0LicsXG4gICAgICAgICAgICAnICAgICAgIConLFxuICAgICAgICAgICAgJyAgICAgICAqICAgIC0gfHJlc3VsdCAhPT0gbnVsbHwnLFxuICAgICAgICAgICAgJyAgICAgICAqICAgIC0gfCN7cG9zT2Zmc2V0KFwicG9zXCIpfSA9PT0gaW5wdXQubGVuZ3RofCcsXG4gICAgICAgICAgICAnICAgICAgICogICAgLSB8cmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZHwgbWF5IG9yIG1heSBub3QgY29udGFpbiBzb21ldGhpbmcnLFxuICAgICAgICAgICAgJyAgICAgICAqJyxcbiAgICAgICAgICAgICcgICAgICAgKiAyLiBUaGUgcGFyc2VyIHN1Y2Nlc3NmdWxseSBwYXJzZWQgb25seSBhIHBhcnQgb2YgdGhlIGlucHV0LicsXG4gICAgICAgICAgICAnICAgICAgIConLFxuICAgICAgICAgICAgJyAgICAgICAqICAgIC0gfHJlc3VsdCAhPT0gbnVsbHwnLFxuICAgICAgICAgICAgJyAgICAgICAqICAgIC0gfCN7cG9zT2Zmc2V0KFwicG9zXCIpfSA8IGlucHV0Lmxlbmd0aHwnLFxuICAgICAgICAgICAgJyAgICAgICAqICAgIC0gfHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWR8IG1heSBvciBtYXkgbm90IGNvbnRhaW4gc29tZXRoaW5nJyxcbiAgICAgICAgICAgICcgICAgICAgKicsXG4gICAgICAgICAgICAnICAgICAgICogMy4gVGhlIHBhcnNlciBkaWQgbm90IHN1Y2Nlc3NmdWxseSBwYXJzZSBhbnkgcGFydCBvZiB0aGUgaW5wdXQuJyxcbiAgICAgICAgICAgICcgICAgICAgKicsXG4gICAgICAgICAgICAnICAgICAgICogICAtIHxyZXN1bHQgPT09IG51bGx8JyxcbiAgICAgICAgICAgICcgICAgICAgKiAgIC0gfCN7cG9zT2Zmc2V0KFwicG9zXCIpfSA9PT0gMHwnLFxuICAgICAgICAgICAgJyAgICAgICAqICAgLSB8cmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZHwgY29udGFpbnMgYXQgbGVhc3Qgb25lIGZhaWx1cmUnLFxuICAgICAgICAgICAgJyAgICAgICAqJyxcbiAgICAgICAgICAgICcgICAgICAgKiBBbGwgY29kZSBmb2xsb3dpbmcgdGhpcyBjb21tZW50IChpbmNsdWRpbmcgY2FsbGVkIGZ1bmN0aW9ucykgbXVzdCcsXG4gICAgICAgICAgICAnICAgICAgICogaGFuZGxlIHRoZXNlIHN0YXRlcy4nLFxuICAgICAgICAgICAgJyAgICAgICAqLycsXG4gICAgICAgICAgICAnICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCAje3Bvc09mZnNldChcInBvc1wiKX0gIT09IGlucHV0Lmxlbmd0aCkgeycsXG4gICAgICAgICAgICAnICAgICAgICB2YXIgb2Zmc2V0ID0gTWF0aC5tYXgoI3twb3NPZmZzZXQoXCJwb3NcIil9LCAje3Bvc09mZnNldChcInJpZ2h0bW9zdEZhaWx1cmVzUG9zXCIpfSk7JyxcbiAgICAgICAgICAgICcgICAgICAgIHZhciBmb3VuZCA9IG9mZnNldCA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChvZmZzZXQpIDogbnVsbDsnLFxuICAgICAgICAgICAgJyAgICAgICAgI2lmIG9wdGlvbnMudHJhY2tMaW5lQW5kQ29sdW1uJyxcbiAgICAgICAgICAgICcgICAgICAgICAgdmFyIGVycm9yUG9zaXRpb24gPSAje3Bvc09mZnNldChcInBvc1wiKX0gPiAje3Bvc09mZnNldChcInJpZ2h0bW9zdEZhaWx1cmVzUG9zXCIpfSA/IHBvcyA6IHJpZ2h0bW9zdEZhaWx1cmVzUG9zOycsXG4gICAgICAgICAgICAnICAgICAgICAjZWxzZScsXG4gICAgICAgICAgICAnICAgICAgICAgIHZhciBlcnJvclBvc2l0aW9uID0gY29tcHV0ZUVycm9yUG9zaXRpb24oKTsnLFxuICAgICAgICAgICAgJyAgICAgICAgI2VuZCcsXG4gICAgICAgICAgICAnICAgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgICAgdGhyb3cgbmV3IHRoaXMuU3ludGF4RXJyb3IoJyxcbiAgICAgICAgICAgICcgICAgICAgICAgY2xlYW51cEV4cGVjdGVkKHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWQpLCcsXG4gICAgICAgICAgICAnICAgICAgICAgIGZvdW5kLCcsXG4gICAgICAgICAgICAnICAgICAgICAgIG9mZnNldCwnLFxuICAgICAgICAgICAgJyAgICAgICAgICBlcnJvclBvc2l0aW9uLmxpbmUsJyxcbiAgICAgICAgICAgICcgICAgICAgICAgZXJyb3JQb3NpdGlvbi5jb2x1bW4nLFxuICAgICAgICAgICAgJyAgICAgICAgKTsnLFxuICAgICAgICAgICAgJyAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgcmV0dXJuIHJlc3VsdDsnLFxuICAgICAgICAgICAgJyAgICB9LCcsXG4gICAgICAgICAgICAnICAgICcsXG4gICAgICAgICAgICAnICAgIC8qIFJldHVybnMgdGhlIHBhcnNlciBzb3VyY2UgY29kZS4gKi8nLFxuICAgICAgICAgICAgJyAgICB0b1NvdXJjZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9zb3VyY2U7IH0nLFxuICAgICAgICAgICAgJyAgfTsnLFxuICAgICAgICAgICAgJyAgJyxcbiAgICAgICAgICAgICcgIC8qIFRocm93biB3aGVuIGEgcGFyc2VyIGVuY291bnRlcnMgYSBzeW50YXggZXJyb3IuICovJyxcbiAgICAgICAgICAgICcgICcsXG4gICAgICAgICAgICAnICByZXN1bHQuU3ludGF4RXJyb3IgPSBmdW5jdGlvbihleHBlY3RlZCwgZm91bmQsIG9mZnNldCwgbGluZSwgY29sdW1uKSB7JyxcbiAgICAgICAgICAgICcgICAgZnVuY3Rpb24gYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCkgeycsXG4gICAgICAgICAgICAnICAgICAgdmFyIGV4cGVjdGVkSHVtYW5pemVkLCBmb3VuZEh1bWFuaXplZDsnLFxuICAgICAgICAgICAgJyAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgc3dpdGNoIChleHBlY3RlZC5sZW5ndGgpIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgY2FzZSAwOicsXG4gICAgICAgICAgICAnICAgICAgICAgIGV4cGVjdGVkSHVtYW5pemVkID0gXCJlbmQgb2YgaW5wdXRcIjsnLFxuICAgICAgICAgICAgJyAgICAgICAgICBicmVhazsnLFxuICAgICAgICAgICAgJyAgICAgICAgY2FzZSAxOicsXG4gICAgICAgICAgICAnICAgICAgICAgIGV4cGVjdGVkSHVtYW5pemVkID0gZXhwZWN0ZWRbMF07JyxcbiAgICAgICAgICAgICcgICAgICAgICAgYnJlYWs7JyxcbiAgICAgICAgICAgICcgICAgICAgIGRlZmF1bHQ6JyxcbiAgICAgICAgICAgICcgICAgICAgICAgZXhwZWN0ZWRIdW1hbml6ZWQgPSBleHBlY3RlZC5zbGljZSgwLCBleHBlY3RlZC5sZW5ndGggLSAxKS5qb2luKFwiLCBcIiknLFxuICAgICAgICAgICAgJyAgICAgICAgICAgICsgXCIgb3IgXCInLFxuICAgICAgICAgICAgJyAgICAgICAgICAgICsgZXhwZWN0ZWRbZXhwZWN0ZWQubGVuZ3RoIC0gMV07JyxcbiAgICAgICAgICAgICcgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgIGZvdW5kSHVtYW5pemVkID0gZm91bmQgPyBxdW90ZShmb3VuZCkgOiBcImVuZCBvZiBpbnB1dFwiOycsXG4gICAgICAgICAgICAnICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICByZXR1cm4gXCJFeHBlY3RlZCBcIiArIGV4cGVjdGVkSHVtYW5pemVkICsgXCIgYnV0IFwiICsgZm91bmRIdW1hbml6ZWQgKyBcIiBmb3VuZC5cIjsnLFxuICAgICAgICAgICAgJyAgICB9JyxcbiAgICAgICAgICAgICcgICAgJyxcbiAgICAgICAgICAgICcgICAgdGhpcy5uYW1lID0gXCJTeW50YXhFcnJvclwiOycsXG4gICAgICAgICAgICAnICAgIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDsnLFxuICAgICAgICAgICAgJyAgICB0aGlzLmZvdW5kID0gZm91bmQ7JyxcbiAgICAgICAgICAgICcgICAgdGhpcy5tZXNzYWdlID0gYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCk7JyxcbiAgICAgICAgICAgICcgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7JyxcbiAgICAgICAgICAgICcgICAgdGhpcy5saW5lID0gbGluZTsnLFxuICAgICAgICAgICAgJyAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjsnLFxuICAgICAgICAgICAgJyAgfTsnLFxuICAgICAgICAgICAgJyAgJyxcbiAgICAgICAgICAgICcgIHJlc3VsdC5TeW50YXhFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7JyxcbiAgICAgICAgICAgICcgICcsXG4gICAgICAgICAgICAnICByZXR1cm4gcmVzdWx0OycsXG4gICAgICAgICAgICAnfSkoKSdcbiAgICAgICAgICBdLFxuICAgICAgICAgIHJ1bGU6IFtcbiAgICAgICAgICAgICdmdW5jdGlvbiBwYXJzZV8je25vZGUubmFtZX0oKSB7JyxcbiAgICAgICAgICAgICcgICNpZiBvcHRpb25zLmNhY2hlJyxcbiAgICAgICAgICAgICcgICAgdmFyIGNhY2hlS2V5ID0gXCIje25vZGUubmFtZX1AXCIgKyAje3Bvc09mZnNldChcInBvc1wiKX07JyxcbiAgICAgICAgICAgICcgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTsnLFxuICAgICAgICAgICAgJyAgICBpZiAoY2FjaGVkUmVzdWx0KSB7JyxcbiAgICAgICAgICAgICcgICAgICBwb3MgPSAje3Bvc0Nsb25lKFwiY2FjaGVkUmVzdWx0Lm5leHRQb3NcIil9OycsXG4gICAgICAgICAgICAnICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7JyxcbiAgICAgICAgICAgICcgICAgfScsXG4gICAgICAgICAgICAnICAgICcsXG4gICAgICAgICAgICAnICAjZW5kJyxcbiAgICAgICAgICAgICcgICNpZiBub2RlLnJlc3VsdFZhcnMubGVuZ3RoID4gMCcsXG4gICAgICAgICAgICAnICAgIHZhciAje25vZGUucmVzdWx0VmFycy5qb2luKFwiLCBcIil9OycsXG4gICAgICAgICAgICAnICAjZW5kJyxcbiAgICAgICAgICAgICcgICNpZiBub2RlLnBvc1ZhcnMubGVuZ3RoID4gMCcsXG4gICAgICAgICAgICAnICAgIHZhciAje25vZGUucG9zVmFycy5qb2luKFwiLCBcIil9OycsXG4gICAgICAgICAgICAnICAjZW5kJyxcbiAgICAgICAgICAgICcgICcsXG4gICAgICAgICAgICAnICAjaWYgbm9kZS5kaXNwbGF5TmFtZSAhPT0gbnVsbCcsXG4gICAgICAgICAgICAnICAgIHJlcG9ydEZhaWx1cmVzKys7JyxcbiAgICAgICAgICAgICcgICNlbmQnLFxuICAgICAgICAgICAgJyAgI2Jsb2NrIGVtaXQobm9kZS5leHByZXNzaW9uKScsXG4gICAgICAgICAgICAnICAjaWYgbm9kZS5kaXNwbGF5TmFtZSAhPT0gbnVsbCcsXG4gICAgICAgICAgICAnICAgIHJlcG9ydEZhaWx1cmVzLS07JyxcbiAgICAgICAgICAgICcgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwICYmICN7bm9kZS5yZXN1bHRWYXJ9ID09PSBudWxsKSB7JyxcbiAgICAgICAgICAgICcgICAgICBtYXRjaEZhaWxlZCgje3N0cmluZyhub2RlLmRpc3BsYXlOYW1lKX0pOycsXG4gICAgICAgICAgICAnICAgIH0nLFxuICAgICAgICAgICAgJyAgI2VuZCcsXG4gICAgICAgICAgICAnICAjaWYgb3B0aW9ucy5jYWNoZScsXG4gICAgICAgICAgICAnICAgICcsXG4gICAgICAgICAgICAnICAgIGNhY2hlW2NhY2hlS2V5XSA9IHsnLFxuICAgICAgICAgICAgJyAgICAgIG5leHRQb3M6ICN7cG9zQ2xvbmUoXCJwb3NcIil9LCcsXG4gICAgICAgICAgICAnICAgICAgcmVzdWx0OiAgI3tub2RlLnJlc3VsdFZhcn0nLFxuICAgICAgICAgICAgJyAgICB9OycsXG4gICAgICAgICAgICAnICAjZW5kJyxcbiAgICAgICAgICAgICcgIHJldHVybiAje25vZGUucmVzdWx0VmFyfTsnLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgICAgXSxcbiAgICAgICAgICBjaG9pY2U6IFtcbiAgICAgICAgICAgICcjYmxvY2sgZW1pdChhbHRlcm5hdGl2ZSknLFxuICAgICAgICAgICAgJyNibG9jayBuZXh0QWx0ZXJuYXRpdmVzQ29kZSdcbiAgICAgICAgICBdLFxuICAgICAgICAgIFwiY2hvaWNlLm5leHRcIjogW1xuICAgICAgICAgICAgJ2lmICgje25vZGUucmVzdWx0VmFyfSA9PT0gbnVsbCkgeycsXG4gICAgICAgICAgICAnICAjYmxvY2sgY29kZScsXG4gICAgICAgICAgICAnfSdcbiAgICAgICAgICBdLFxuICAgICAgICAgIHNlcXVlbmNlOiBbXG4gICAgICAgICAgICAnI3twb3NTYXZlKG5vZGUpfTsnLFxuICAgICAgICAgICAgJyNibG9jayBjb2RlJ1xuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJzZXF1ZW5jZS5pdGVyYXRpb25cIjogW1xuICAgICAgICAgICAgJyNibG9jayBlbWl0KGVsZW1lbnQpJyxcbiAgICAgICAgICAgICdpZiAoI3tlbGVtZW50LnJlc3VsdFZhcn0gIT09IG51bGwpIHsnLFxuICAgICAgICAgICAgJyAgI2Jsb2NrIGNvZGUnLFxuICAgICAgICAgICAgJ30gZWxzZSB7JyxcbiAgICAgICAgICAgICcgICN7bm9kZS5yZXN1bHRWYXJ9ID0gbnVsbDsnLFxuICAgICAgICAgICAgJyAgI3twb3NSZXN0b3JlKG5vZGUpfTsnLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcInNlcXVlbmNlLmlubmVyXCI6IFtcbiAgICAgICAgICAgICcje25vZGUucmVzdWx0VmFyfSA9IFsje3BsdWNrKG5vZGUuZWxlbWVudHMsIFwicmVzdWx0VmFyXCIpLmpvaW4oXCIsIFwiKX1dOydcbiAgICAgICAgICBdLFxuICAgICAgICAgIHNpbXBsZV9hbmQ6IFtcbiAgICAgICAgICAgICcje3Bvc1NhdmUobm9kZSl9OycsXG4gICAgICAgICAgICAncmVwb3J0RmFpbHVyZXMrKzsnLFxuICAgICAgICAgICAgJyNibG9jayBlbWl0KG5vZGUuZXhwcmVzc2lvbiknLFxuICAgICAgICAgICAgJ3JlcG9ydEZhaWx1cmVzLS07JyxcbiAgICAgICAgICAgICdpZiAoI3tub2RlLnJlc3VsdFZhcn0gIT09IG51bGwpIHsnLFxuICAgICAgICAgICAgJyAgI3tub2RlLnJlc3VsdFZhcn0gPSBcIlwiOycsXG4gICAgICAgICAgICAnICAje3Bvc1Jlc3RvcmUobm9kZSl9OycsXG4gICAgICAgICAgICAnfSBlbHNlIHsnLFxuICAgICAgICAgICAgJyAgI3tub2RlLnJlc3VsdFZhcn0gPSBudWxsOycsXG4gICAgICAgICAgICAnfSdcbiAgICAgICAgICBdLFxuICAgICAgICAgIHNpbXBsZV9ub3Q6IFtcbiAgICAgICAgICAgICcje3Bvc1NhdmUobm9kZSl9OycsXG4gICAgICAgICAgICAncmVwb3J0RmFpbHVyZXMrKzsnLFxuICAgICAgICAgICAgJyNibG9jayBlbWl0KG5vZGUuZXhwcmVzc2lvbiknLFxuICAgICAgICAgICAgJ3JlcG9ydEZhaWx1cmVzLS07JyxcbiAgICAgICAgICAgICdpZiAoI3tub2RlLnJlc3VsdFZhcn0gPT09IG51bGwpIHsnLFxuICAgICAgICAgICAgJyAgI3tub2RlLnJlc3VsdFZhcn0gPSBcIlwiOycsXG4gICAgICAgICAgICAnfSBlbHNlIHsnLFxuICAgICAgICAgICAgJyAgI3tub2RlLnJlc3VsdFZhcn0gPSBudWxsOycsXG4gICAgICAgICAgICAnICAje3Bvc1Jlc3RvcmUobm9kZSl9OycsXG4gICAgICAgICAgICAnfSdcbiAgICAgICAgICBdLFxuICAgICAgICAgIHNlbWFudGljX2FuZDogW1xuICAgICAgICAgICAgJyN7bm9kZS5yZXN1bHRWYXJ9ID0gKGZ1bmN0aW9uKCN7KG9wdGlvbnMudHJhY2tMaW5lQW5kQ29sdW1uID8gW1wib2Zmc2V0XCIsIFwibGluZVwiLCBcImNvbHVtblwiXSA6IFtcIm9mZnNldFwiXSkuY29uY2F0KGtleXMobm9kZS5wYXJhbXMpKS5qb2luKFwiLCBcIil9KSB7I3tub2RlLmNvZGV9fSkoI3sob3B0aW9ucy50cmFja0xpbmVBbmRDb2x1bW4gPyBbXCJwb3Mub2Zmc2V0XCIsIFwicG9zLmxpbmVcIiwgXCJwb3MuY29sdW1uXCJdIDogW1wicG9zXCJdKS5jb25jYXQodmFsdWVzKG5vZGUucGFyYW1zKSkuam9pbihcIiwgXCIpfSkgPyBcIlwiIDogbnVsbDsnXG4gICAgICAgICAgXSxcbiAgICAgICAgICBzZW1hbnRpY19ub3Q6IFtcbiAgICAgICAgICAgICcje25vZGUucmVzdWx0VmFyfSA9IChmdW5jdGlvbigjeyhvcHRpb25zLnRyYWNrTGluZUFuZENvbHVtbiA/IFtcIm9mZnNldFwiLCBcImxpbmVcIiwgXCJjb2x1bW5cIl0gOiBbXCJvZmZzZXRcIl0pLmNvbmNhdChrZXlzKG5vZGUucGFyYW1zKSkuam9pbihcIiwgXCIpfSkgeyN7bm9kZS5jb2RlfX0pKCN7KG9wdGlvbnMudHJhY2tMaW5lQW5kQ29sdW1uID8gW1wicG9zLm9mZnNldFwiLCBcInBvcy5saW5lXCIsIFwicG9zLmNvbHVtblwiXSA6IFtcInBvc1wiXSkuY29uY2F0KHZhbHVlcyhub2RlLnBhcmFtcykpLmpvaW4oXCIsIFwiKX0pID8gbnVsbCA6IFwiXCI7J1xuICAgICAgICAgIF0sXG4gICAgICAgICAgb3B0aW9uYWw6IFtcbiAgICAgICAgICAgICcjYmxvY2sgZW1pdChub2RlLmV4cHJlc3Npb24pJyxcbiAgICAgICAgICAgICcje25vZGUucmVzdWx0VmFyfSA9ICN7bm9kZS5yZXN1bHRWYXJ9ICE9PSBudWxsID8gI3tub2RlLnJlc3VsdFZhcn0gOiBcIlwiOydcbiAgICAgICAgICBdLFxuICAgICAgICAgIHplcm9fb3JfbW9yZTogW1xuICAgICAgICAgICAgJyN7bm9kZS5yZXN1bHRWYXJ9ID0gW107JyxcbiAgICAgICAgICAgICcjYmxvY2sgZW1pdChub2RlLmV4cHJlc3Npb24pJyxcbiAgICAgICAgICAgICd3aGlsZSAoI3tub2RlLmV4cHJlc3Npb24ucmVzdWx0VmFyfSAhPT0gbnVsbCkgeycsXG4gICAgICAgICAgICAnICAje25vZGUucmVzdWx0VmFyfS5wdXNoKCN7bm9kZS5leHByZXNzaW9uLnJlc3VsdFZhcn0pOycsXG4gICAgICAgICAgICAnICAjYmxvY2sgZW1pdChub2RlLmV4cHJlc3Npb24pJyxcbiAgICAgICAgICAgICd9J1xuICAgICAgICAgIF0sXG4gICAgICAgICAgb25lX29yX21vcmU6IFtcbiAgICAgICAgICAgICcjYmxvY2sgZW1pdChub2RlLmV4cHJlc3Npb24pJyxcbiAgICAgICAgICAgICdpZiAoI3tub2RlLmV4cHJlc3Npb24ucmVzdWx0VmFyfSAhPT0gbnVsbCkgeycsXG4gICAgICAgICAgICAnICAje25vZGUucmVzdWx0VmFyfSA9IFtdOycsXG4gICAgICAgICAgICAnICB3aGlsZSAoI3tub2RlLmV4cHJlc3Npb24ucmVzdWx0VmFyfSAhPT0gbnVsbCkgeycsXG4gICAgICAgICAgICAnICAgICN7bm9kZS5yZXN1bHRWYXJ9LnB1c2goI3tub2RlLmV4cHJlc3Npb24ucmVzdWx0VmFyfSk7JyxcbiAgICAgICAgICAgICcgICAgI2Jsb2NrIGVtaXQobm9kZS5leHByZXNzaW9uKScsXG4gICAgICAgICAgICAnICB9JyxcbiAgICAgICAgICAgICd9IGVsc2UgeycsXG4gICAgICAgICAgICAnICAje25vZGUucmVzdWx0VmFyfSA9IG51bGw7JyxcbiAgICAgICAgICAgICd9J1xuICAgICAgICAgIF0sXG4gICAgICAgICAgYWN0aW9uOiBbXG4gICAgICAgICAgICAnI3twb3NTYXZlKG5vZGUpfTsnLFxuICAgICAgICAgICAgJyNibG9jayBlbWl0KG5vZGUuZXhwcmVzc2lvbiknLFxuICAgICAgICAgICAgJ2lmICgje25vZGUucmVzdWx0VmFyfSAhPT0gbnVsbCkgeycsXG4gICAgICAgICAgICAnICAje25vZGUucmVzdWx0VmFyfSA9IChmdW5jdGlvbigjeyhvcHRpb25zLnRyYWNrTGluZUFuZENvbHVtbiA/IFtcIm9mZnNldFwiLCBcImxpbmVcIiwgXCJjb2x1bW5cIl0gOiBbXCJvZmZzZXRcIl0pLmNvbmNhdChrZXlzKG5vZGUucGFyYW1zKSkuam9pbihcIiwgXCIpfSkgeyN7bm9kZS5jb2RlfX0pKCN7KG9wdGlvbnMudHJhY2tMaW5lQW5kQ29sdW1uID8gW25vZGUucG9zVmFyICsgXCIub2Zmc2V0XCIsIG5vZGUucG9zVmFyICsgXCIubGluZVwiLCBub2RlLnBvc1ZhciArIFwiLmNvbHVtblwiXSA6IFtub2RlLnBvc1Zhcl0pLmNvbmNhdCh2YWx1ZXMobm9kZS5wYXJhbXMpKS5qb2luKFwiLCBcIil9KTsnLFxuICAgICAgICAgICAgJ30nLFxuICAgICAgICAgICAgJ2lmICgje25vZGUucmVzdWx0VmFyfSA9PT0gbnVsbCkgeycsXG4gICAgICAgICAgICAnICAje3Bvc1Jlc3RvcmUobm9kZSl9OycsXG4gICAgICAgICAgICAnfSdcbiAgICAgICAgICBdLFxuICAgICAgICAgIHJ1bGVfcmVmOiBbXG4gICAgICAgICAgICAnI3tub2RlLnJlc3VsdFZhcn0gPSBwYXJzZV8je25vZGUubmFtZX0oKTsnXG4gICAgICAgICAgXSxcbiAgICAgICAgICBsaXRlcmFsOiBbXG4gICAgICAgICAgICAnI2lmIG5vZGUudmFsdWUubGVuZ3RoID09PSAwJyxcbiAgICAgICAgICAgICcgICN7bm9kZS5yZXN1bHRWYXJ9ID0gXCJcIjsnLFxuICAgICAgICAgICAgJyNlbHNlJyxcbiAgICAgICAgICAgICcgICNpZiAhbm9kZS5pZ25vcmVDYXNlJyxcbiAgICAgICAgICAgICcgICAgI2lmIG5vZGUudmFsdWUubGVuZ3RoID09PSAxJyxcbiAgICAgICAgICAgICcgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdCgje3Bvc09mZnNldChcInBvc1wiKX0pID09PSAje25vZGUudmFsdWUuY2hhckNvZGVBdCgwKX0pIHsnLFxuICAgICAgICAgICAgJyAgICAjZWxzZScsXG4gICAgICAgICAgICAnICAgICAgaWYgKGlucHV0LnN1YnN0cigje3Bvc09mZnNldChcInBvc1wiKX0sICN7bm9kZS52YWx1ZS5sZW5ndGh9KSA9PT0gI3tzdHJpbmcobm9kZS52YWx1ZSl9KSB7JyxcbiAgICAgICAgICAgICcgICAgI2VuZCcsXG4gICAgICAgICAgICAnICAjZWxzZScsXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogT25lLWNoYXIgbGl0ZXJhbHMgYXJlIG5vdCBvcHRpbWl6ZWQgd2hlbiBjYXNlLWluc2Vuc2l0aXZlXG4gICAgICAgICAgICAgKiBtYXRjaGluZyBpcyBlbmFibGVkLiBUaGlzIGlzIGJlY2F1c2UgdGhlcmUgaXMgbm8gc2ltcGxlIHdheSB0b1xuICAgICAgICAgICAgICogbG93ZXJjYXNlIGEgY2hhcmFjdGVyIGNvZGUgdGhhdCB3b3JrcyBmb3IgY2hhcmFjdGVyIG91dHNpZGUgQVNDSUlcbiAgICAgICAgICAgICAqIGxldHRlcnMuIE1vcmVvdmVyLCB8dG9Mb3dlckNhc2V8IGNhbiBjaGFuZ2Ugc3RyaW5nIGxlbmd0aCxcbiAgICAgICAgICAgICAqIG1lYW5pbmcgdGhlIHJlc3VsdCBvZiBsb3dlcmNhc2luZyBhIGNoYXJhY3RlciBjYW4gYmUgbW9yZVxuICAgICAgICAgICAgICogY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJyAgICBpZiAoaW5wdXQuc3Vic3RyKCN7cG9zT2Zmc2V0KFwicG9zXCIpfSwgI3tub2RlLnZhbHVlLmxlbmd0aH0pLnRvTG93ZXJDYXNlKCkgPT09ICN7c3RyaW5nKG5vZGUudmFsdWUudG9Mb3dlckNhc2UoKSl9KSB7JyxcbiAgICAgICAgICAgICcgICNlbmQnLFxuICAgICAgICAgICAgJyAgICAjaWYgIW5vZGUuaWdub3JlQ2FzZScsXG4gICAgICAgICAgICAnICAgICAgI3tub2RlLnJlc3VsdFZhcn0gPSAje3N0cmluZyhub2RlLnZhbHVlKX07JyxcbiAgICAgICAgICAgICcgICAgI2Vsc2UnLFxuICAgICAgICAgICAgJyAgICAgICN7bm9kZS5yZXN1bHRWYXJ9ID0gaW5wdXQuc3Vic3RyKCN7cG9zT2Zmc2V0KFwicG9zXCIpfSwgI3tub2RlLnZhbHVlLmxlbmd0aH0pOycsXG4gICAgICAgICAgICAnICAgICNlbmQnLFxuICAgICAgICAgICAgJyAgICAje3Bvc0FkdmFuY2Uobm9kZS52YWx1ZS5sZW5ndGgpfTsnLFxuICAgICAgICAgICAgJyAgfSBlbHNlIHsnLFxuICAgICAgICAgICAgJyAgICAje25vZGUucmVzdWx0VmFyfSA9IG51bGw7JyxcbiAgICAgICAgICAgICcgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7JyxcbiAgICAgICAgICAgICcgICAgICBtYXRjaEZhaWxlZCgje3N0cmluZyhzdHJpbmcobm9kZS52YWx1ZSkpfSk7JyxcbiAgICAgICAgICAgICcgICAgfScsXG4gICAgICAgICAgICAnICB9JyxcbiAgICAgICAgICAgICcjZW5kJ1xuICAgICAgICAgIF0sXG4gICAgICAgICAgYW55OiBbXG4gICAgICAgICAgICAnaWYgKGlucHV0Lmxlbmd0aCA+ICN7cG9zT2Zmc2V0KFwicG9zXCIpfSkgeycsXG4gICAgICAgICAgICAnICAje25vZGUucmVzdWx0VmFyfSA9IGlucHV0LmNoYXJBdCgje3Bvc09mZnNldChcInBvc1wiKX0pOycsXG4gICAgICAgICAgICAnICAje3Bvc0FkdmFuY2UoMSl9OycsXG4gICAgICAgICAgICAnfSBlbHNlIHsnLFxuICAgICAgICAgICAgJyAgI3tub2RlLnJlc3VsdFZhcn0gPSBudWxsOycsXG4gICAgICAgICAgICAnICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHsnLFxuICAgICAgICAgICAgJyAgICBtYXRjaEZhaWxlZChcImFueSBjaGFyYWN0ZXJcIik7JyxcbiAgICAgICAgICAgICcgIH0nLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcImNsYXNzXCI6IFtcbiAgICAgICAgICAgICdpZiAoI3tyZWdleHB9LnRlc3QoaW5wdXQuY2hhckF0KCN7cG9zT2Zmc2V0KFwicG9zXCIpfSkpKSB7JyxcbiAgICAgICAgICAgICcgICN7bm9kZS5yZXN1bHRWYXJ9ID0gaW5wdXQuY2hhckF0KCN7cG9zT2Zmc2V0KFwicG9zXCIpfSk7JyxcbiAgICAgICAgICAgICcgICN7cG9zQWR2YW5jZSgxKX07JyxcbiAgICAgICAgICAgICd9IGVsc2UgeycsXG4gICAgICAgICAgICAnICAje25vZGUucmVzdWx0VmFyfSA9IG51bGw7JyxcbiAgICAgICAgICAgICcgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkgeycsXG4gICAgICAgICAgICAnICAgIG1hdGNoRmFpbGVkKCN7c3RyaW5nKG5vZGUucmF3VGV4dCl9KTsnLFxuICAgICAgICAgICAgJyAgfScsXG4gICAgICAgICAgICAnfSdcbiAgICAgICAgICBdXG4gICAgICAgIH07XG5cbiAgICBmb3IgKG5hbWUgaW4gc291cmNlcykge1xuICAgICAgdGVtcGxhdGVzW25hbWVdID0gQ29kaWUudGVtcGxhdGUoc291cmNlc1tuYW1lXS5qb2luKCdcXG4nKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlbXBsYXRlcztcbiAgfSkoKTtcblxuICBmdW5jdGlvbiBmaWxsKG5hbWUsIHZhcnMpIHtcbiAgICB2YXJzLnN0cmluZyAgPSBxdW90ZTtcbiAgICB2YXJzLnBsdWNrICAgPSBwbHVjaztcbiAgICB2YXJzLmtleXMgICAgPSBrZXlzO1xuICAgIHZhcnMudmFsdWVzICA9IHZhbHVlcztcbiAgICB2YXJzLmVtaXQgICAgPSBlbWl0O1xuICAgIHZhcnMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAvKiBQb3NpdGlvbi1oYW5kbGluZyBtYWNyb3MgKi9cbiAgICBpZiAob3B0aW9ucy50cmFja0xpbmVBbmRDb2x1bW4pIHtcbiAgICAgIHZhcnMucG9zSW5pdCAgICA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIFwidmFyIFwiXG4gICAgICAgICAgICAgKyBuYW1lXG4gICAgICAgICAgICAgKyBcIiA9IFwiXG4gICAgICAgICAgICAgKyBcInsgb2Zmc2V0OiAwLCBsaW5lOiAxLCBjb2x1bW46IDEsIHNlZW5DUjogZmFsc2UgfVwiO1xuICAgICAgfTtcbiAgICAgIHZhcnMucG9zQ2xvbmUgICA9IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIFwiY2xvbmUoXCIgKyBuYW1lICsgXCIpXCI7IH07XG4gICAgICB2YXJzLnBvc09mZnNldCAgPSBmdW5jdGlvbihuYW1lKSB7IHJldHVybiBuYW1lICsgXCIub2Zmc2V0XCI7IH07XG5cbiAgICAgIHZhcnMucG9zQWR2YW5jZSA9IGZ1bmN0aW9uKG4pICAgIHsgcmV0dXJuIFwiYWR2YW5jZShwb3MsIFwiICsgbiArIFwiKVwiOyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXJzLnBvc0luaXQgICAgPSBmdW5jdGlvbihuYW1lKSB7IHJldHVybiBcInZhciBcIiArIG5hbWUgKyBcIiA9IDBcIjsgfTtcbiAgICAgIHZhcnMucG9zQ2xvbmUgICA9IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIG5hbWU7IH07XG4gICAgICB2YXJzLnBvc09mZnNldCAgPSBmdW5jdGlvbihuYW1lKSB7IHJldHVybiBuYW1lOyB9O1xuXG4gICAgICB2YXJzLnBvc0FkdmFuY2UgPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBuID09PSAxID8gXCJwb3MrK1wiIDogXCJwb3MgKz0gXCIgKyBuO1xuICAgICAgfTtcbiAgICB9XG4gICAgdmFycy5wb3NTYXZlICAgID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUucG9zVmFyICsgXCIgPSBcIiArIHZhcnMucG9zQ2xvbmUoXCJwb3NcIik7XG4gICAgfTtcbiAgICB2YXJzLnBvc1Jlc3RvcmUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gXCJwb3NcIiArIFwiID0gXCIgKyB2YXJzLnBvc0Nsb25lKG5vZGUucG9zVmFyKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlc1tuYW1lXSh2YXJzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRTaW1wbGUobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihub2RlKSB7IHJldHVybiBmaWxsKG5hbWUsIHsgbm9kZTogbm9kZSB9KTsgfTtcbiAgfVxuXG4gIHZhciBlbWl0ID0gYnVpbGROb2RlVmlzaXRvcih7XG4gICAgZ3JhbW1hcjogZW1pdFNpbXBsZShcImdyYW1tYXJcIiksXG5cbiAgICBpbml0aWFsaXplcjogZnVuY3Rpb24obm9kZSkgeyByZXR1cm4gbm9kZS5jb2RlOyB9LFxuXG4gICAgcnVsZTogZW1pdFNpbXBsZShcInJ1bGVcIiksXG5cbiAgICAvKlxuICAgICAqIFRoZSBjb250cmFjdCBmb3IgYWxsIGNvZGUgZnJhZ21lbnRzIGdlbmVyYXRlZCBieSB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uc1xuICAgICAqIGlzIGFzIGZvbGxvd3MuXG4gICAgICpcbiAgICAgKiBUaGUgY29kZSBmcmFnbWVudCB0cmllcyB0byBtYXRjaCBhIHBhcnQgb2YgdGhlIGlucHV0IHN0YXJ0aW5nIHdpdGggdGhlXG4gICAgICogcG9zaXRpb24gaW5kaWNhdGVkIGluIHxwb3N8LiBUaGF0IHBvc2l0aW9uIG1heSBwb2ludCBwYXN0IHRoZSBlbmQgb2YgdGhlXG4gICAgICogaW5wdXQuXG4gICAgICpcbiAgICAgKiAqIElmIHRoZSBjb2RlIGZyYWdtZW50IG1hdGNoZXMgdGhlIGlucHV0LCBpdCBhZHZhbmNlcyB8cG9zfCB0byBwb2ludCB0b1xuICAgICAqICAgdGhlIGZpcnN0IGNocmFjdGVyIGZvbGxvd2luZyB0aGUgbWF0Y2hlZCBwYXJ0IG9mIHRoZSBpbnB1dCBhbmQgc2V0c1xuICAgICAqICAgdmFyaWFibGUgd2l0aCBhIG5hbWUgc3RvcmVkIGluIHxub2RlLnJlc3VsdFZhcnwgdG8gYW4gYXBwcm9wcmlhdGVcbiAgICAgKiAgIHZhbHVlLiBUaGlzIHZhbHVlIGlzIGFsd2F5cyBub24tfG51bGx8LlxuICAgICAqXG4gICAgICogKiBJZiB0aGUgY29kZSBmcmFnbWVudCBkb2VzIG5vdCBtYXRjaCB0aGUgaW5wdXQsIGl0IHJldHVybnMgd2l0aCB8cG9zfFxuICAgICAqICAgc2V0IHRvIHRoZSBvcmlnaW5hbCB2YWx1ZSBhbmQgaXQgc2V0cyBhIHZhcmlhYmxlIHdpdGggYSBuYW1lIHN0b3JlZCBpblxuICAgICAqICAgfG5vZGUucmVzdWx0VmFyfCB0byB8bnVsbHwuXG4gICAgICpcbiAgICAgKiBUaGUgY29kZSBjYW4gdXNlIHZhcmlhYmxlcyB3aXRoIG5hbWVzIHN0b3JlZCBpbiB8cmVzdWx0VmFyfCBhbmQgfHBvc1ZhcnxcbiAgICAgKiBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IG5vZGUncyBzdWJub2Rlcy4gSXQgY2FuJ3QgdXNlIGFueSBvdGhlclxuICAgICAqIHZhcmlhYmxlcy5cbiAgICAgKi9cblxuICAgIGNob2ljZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGNvZGUsIG5leHRBbHRlcm5hdGl2ZXNDb2RlO1xuXG4gICAgICBmb3IgKHZhciBpID0gbm9kZS5hbHRlcm5hdGl2ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbmV4dEFsdGVybmF0aXZlc0NvZGUgPSBpICE9PSBub2RlLmFsdGVybmF0aXZlcy5sZW5ndGggLSAxXG4gICAgICAgICAgPyBmaWxsKFwiY2hvaWNlLm5leHRcIiwgeyBub2RlOiBub2RlLCBjb2RlOiBjb2RlIH0pXG4gICAgICAgICAgOiAnJztcbiAgICAgICAgY29kZSA9IGZpbGwoXCJjaG9pY2VcIiwge1xuICAgICAgICAgIGFsdGVybmF0aXZlOiAgICAgICAgICBub2RlLmFsdGVybmF0aXZlc1tpXSxcbiAgICAgICAgICBuZXh0QWx0ZXJuYXRpdmVzQ29kZTogbmV4dEFsdGVybmF0aXZlc0NvZGVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2RlO1xuICAgIH0sXG5cbiAgICBzZXF1ZW5jZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGNvZGUgPSBmaWxsKFwic2VxdWVuY2UuaW5uZXJcIiwgeyBub2RlOiBub2RlIH0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gbm9kZS5lbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb2RlID0gZmlsbChcInNlcXVlbmNlLml0ZXJhdGlvblwiLCB7XG4gICAgICAgICAgbm9kZTogICAgbm9kZSxcbiAgICAgICAgICBlbGVtZW50OiBub2RlLmVsZW1lbnRzW2ldLFxuICAgICAgICAgIGNvZGU6ICAgIGNvZGVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaWxsKFwic2VxdWVuY2VcIiwgeyBub2RlOiBub2RlLCBjb2RlOiBjb2RlIH0pO1xuICAgIH0sXG5cbiAgICBsYWJlbGVkOiBmdW5jdGlvbihub2RlKSB7IHJldHVybiBlbWl0KG5vZGUuZXhwcmVzc2lvbik7IH0sXG5cbiAgICBzaW1wbGVfYW5kOiAgIGVtaXRTaW1wbGUoXCJzaW1wbGVfYW5kXCIpLFxuICAgIHNpbXBsZV9ub3Q6ICAgZW1pdFNpbXBsZShcInNpbXBsZV9ub3RcIiksXG4gICAgc2VtYW50aWNfYW5kOiBlbWl0U2ltcGxlKFwic2VtYW50aWNfYW5kXCIpLFxuICAgIHNlbWFudGljX25vdDogZW1pdFNpbXBsZShcInNlbWFudGljX25vdFwiKSxcbiAgICBvcHRpb25hbDogICAgIGVtaXRTaW1wbGUoXCJvcHRpb25hbFwiKSxcbiAgICB6ZXJvX29yX21vcmU6IGVtaXRTaW1wbGUoXCJ6ZXJvX29yX21vcmVcIiksXG4gICAgb25lX29yX21vcmU6ICBlbWl0U2ltcGxlKFwib25lX29yX21vcmVcIiksXG4gICAgYWN0aW9uOiAgICAgICBlbWl0U2ltcGxlKFwiYWN0aW9uXCIpLFxuICAgIHJ1bGVfcmVmOiAgICAgZW1pdFNpbXBsZShcInJ1bGVfcmVmXCIpLFxuICAgIGxpdGVyYWw6ICAgICAgZW1pdFNpbXBsZShcImxpdGVyYWxcIiksXG4gICAgYW55OiAgICAgICAgICBlbWl0U2ltcGxlKFwiYW55XCIpLFxuXG4gICAgXCJjbGFzc1wiOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcmVnZXhwO1xuXG4gICAgICBpZiAobm9kZS5wYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlZ2V4cCA9ICcvXlsnXG4gICAgICAgICAgKyAobm9kZS5pbnZlcnRlZCA/ICdeJyA6ICcnKVxuICAgICAgICAgICsgbWFwKG5vZGUucGFydHMsIGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnQgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgICAgID8gcXVvdGVGb3JSZWdleHBDbGFzcyhwYXJ0WzBdKVxuICAgICAgICAgICAgICAgICAgKyAnLSdcbiAgICAgICAgICAgICAgICAgICsgcXVvdGVGb3JSZWdleHBDbGFzcyhwYXJ0WzFdKVxuICAgICAgICAgICAgICAgIDogcXVvdGVGb3JSZWdleHBDbGFzcyhwYXJ0KTtcbiAgICAgICAgICAgIH0pLmpvaW4oJycpXG4gICAgICAgICAgKyAnXS8nICsgKG5vZGUuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFN0dXBpZCBJRSBjb25zaWRlcnMgcmVnZXhwcyAvW10vIGFuZCAvW15dLyBzeW50YWN0aWNhbGx5IGludmFsaWQsIHNvXG4gICAgICAgICAqIHdlIHRyYW5zbGF0ZSB0aGVtIGludG8gZXVxaXZhbGVudHMgaXQgY2FuIGhhbmRsZS5cbiAgICAgICAgICovXG4gICAgICAgIHJlZ2V4cCA9IG5vZGUuaW52ZXJ0ZWQgPyAnL15bXFxcXFNcXFxcc10vJyA6ICcvXig/ISkvJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpbGwoXCJjbGFzc1wiLCB7IG5vZGU6IG5vZGUsIHJlZ2V4cDogcmVnZXhwIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGVtaXQoYXN0KTtcbn07XG5cbnJldHVybiBQRUc7XG5cbn0pKCk7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gUEVHO1xufVxuIiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBIYXNoID0gcmVxdWlyZSgnaGFzaGlzaCcpO1xudmFyIENoYWluc2F3ID0gcmVxdWlyZSgnY2hhaW5zYXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXE7XG5mdW5jdGlvbiBTZXEgKHhzKSB7XG4gICAgaWYgKHhzICYmICFBcnJheS5pc0FycmF5KHhzKSB8fCBhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbmFsIGFyZ3VtZW50IHRvIFNlcSgpIGlzIGV4YWN0bHkgb25lIEFycmF5Jyk7XG4gICAgfVxuICAgIFxuICAgIHZhciBjaCA9IENoYWluc2F3KGZ1bmN0aW9uIChzYXcpIHtcbiAgICAgICAgYnVpbGRlci5jYWxsKHRoaXMsIHNhdywgeHMgfHwgW10pO1xuICAgIH0pO1xuICAgIFxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBjaFsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyci5zdGFjayA/IGVyci5zdGFjayA6IGVycilcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNoO1xufVxuXG5TZXEuYXAgPSBTZXE7IC8vIGZvciBjb21wYXRhYmlsaXR5IHdpdGggdmVyc2lvbnMgPDAuM1xuXG5mdW5jdGlvbiBidWlsZGVyIChzYXcsIHhzKSB7XG4gICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgIHZhcnMgOiB7fSxcbiAgICAgICAgYXJncyA6IHt9LFxuICAgICAgICBzdGFjayA6IHhzLFxuICAgICAgICBlcnJvciA6IG51bGxcbiAgICB9O1xuICAgIGNvbnRleHQuc3RhY2tfID0gY29udGV4dC5zdGFjaztcbiAgICBcbiAgICBmdW5jdGlvbiBhY3Rpb24gKHN0ZXAsIGtleSwgZiwgZykge1xuICAgICAgICB2YXIgY2IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVycm9yID0geyBtZXNzYWdlIDogZXJyLCBrZXkgOiBrZXkgfTtcbiAgICAgICAgICAgICAgICBzYXcuanVtcChsYXN0UGFyKTtcbiAgICAgICAgICAgICAgICBzYXcuZG93bignY2F0Y2gnKTtcbiAgICAgICAgICAgICAgICBnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN0YWNrX1trZXldID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hcmdzW2tleV0gPSBhcmdzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdGFja18ucHVzaC5hcHBseShjb250ZXh0LnN0YWNrXywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC52YXJzW2tleV0gPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hcmdzW2tleV0gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnKSBnKGFyZ3MsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEhhc2goY29udGV4dCkuZm9yRWFjaChmdW5jdGlvbiAodixrKSB7IGNiW2tdID0gdiB9KTtcbiAgICAgICAgXG4gICAgICAgIGNiLmludG8gPSBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAga2V5ID0gaztcbiAgICAgICAgICAgIHJldHVybiBjYjtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNiLm5leHQgPSBmdW5jdGlvbiAoZXJyLCB4cykge1xuICAgICAgICAgICAgY29udGV4dC5zdGFja18ucHVzaC5hcHBseShjb250ZXh0LnN0YWNrXywgeHMpO1xuICAgICAgICAgICAgY2IuYXBwbHkoY2IsIFtlcnJdLmNvbmNhdChjb250ZXh0LnN0YWNrKSk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBjYi5wYXNzID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2IuYXBwbHkoY2IsIFtlcnJdLmNvbmNhdChjb250ZXh0LnN0YWNrKSk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBjYi5vayA9IGNiLmJpbmQoY2IsIG51bGwpO1xuICAgICAgICBcbiAgICAgICAgZi5hcHBseShjYiwgY29udGV4dC5zdGFjayk7XG4gICAgfVxuICAgIFxuICAgIHZhciBydW5uaW5nID0gMDtcbiAgICB2YXIgZXJyb3JzID0gMDtcbiAgICBcbiAgICB0aGlzLnNlcSA9IGZ1bmN0aW9uIChrZXksIGNiKSB7XG4gICAgICAgIHZhciBib3VuZCA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIGJvdW5kLnVuc2hpZnQoY2IpO1xuICAgICAgICAgICAgY2IgPSBrZXk7XG4gICAgICAgICAgICBrZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChjb250ZXh0LmVycm9yKSBzYXcubmV4dCgpXG4gICAgICAgIGVsc2UgaWYgKHJ1bm5pbmcgPT09IDApIHtcbiAgICAgICAgICAgIGFjdGlvbihzYXcuc3RlcCwga2V5LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdGFja18gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MudW5zaGlmdC5hcHBseShhcmdzLCBib3VuZC5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZyA9PT0gU2VxID8gdGhpcyA6IGFyZ1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhY2sgPSBjb250ZXh0LnN0YWNrXztcbiAgICAgICAgICAgICAgICAgICAgc2F3Lm5leHQoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIHZhciBsYXN0UGFyID0gbnVsbDtcbiAgICB0aGlzLnBhciA9IGZ1bmN0aW9uIChrZXksIGNiKSB7XG4gICAgICAgIGxhc3RQYXIgPSBzYXcuc3RlcDtcbiAgICAgICAgXG4gICAgICAgIGlmIChydW5uaW5nID09IDApIHtcbiAgICAgICAgICAgIC8vIGVtcHR5IHRoZSBhY3RpdmUgc3RhY2sgZm9yIHRoZSBmaXJzdCBwYXIoKSBpbiBhIGNoYWluXG4gICAgICAgICAgICBjb250ZXh0LnN0YWNrXyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgYm91bmQgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIGJvdW5kLnVuc2hpZnQoY2IpO1xuICAgICAgICAgICAgY2IgPSBrZXk7XG4gICAgICAgICAgICBrZXkgPSBjb250ZXh0LnN0YWNrXy5sZW5ndGg7XG4gICAgICAgICAgICBjb250ZXh0LnN0YWNrXy5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYl8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGFyZ3MudW5zaGlmdC5hcHBseShhcmdzLCBib3VuZC5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmcgPT09IFNlcSA/IHRoaXMgOiBhcmdcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBydW5uaW5nICsrO1xuICAgICAgICBcbiAgICAgICAgdmFyIHN0ZXAgPSBzYXcuc3RlcDtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhY3Rpb24oc3RlcCwga2V5LCBjYl8sIGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhcmdzKSBlcnJvcnMgKys7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcnVubmluZyAtLTtcbiAgICAgICAgICAgICAgICBpZiAocnVubmluZyA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhY2sgPSBjb250ZXh0LnN0YWNrXy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICBzYXcuc3RlcCA9IGxhc3RQYXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcnMgPiAwKSBzYXcuZG93bignY2F0Y2gnKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgc2F3Lm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNhdy5uZXh0KCk7XG4gICAgfTtcbiAgICBcbiAgICBbICdzZXEnLCAncGFyJyBdLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpc1tuYW1lICsgJ18nXSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgY2IgPSB0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgPyBhcmdzWzBdIDogYXJnc1sxXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmd2ID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGFyZ3YudW5zaGlmdCh0aGlzKTtcbiAgICAgICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgYXJnc1swXSA9IGZuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJnc1sxXSA9IGZuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzW25hbWVdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXNbJ2NhdGNoJ10gPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuZXJyb3IpIHtcbiAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgY29udGV4dC5lcnJvci5tZXNzYWdlLCBjb250ZXh0LmVycm9yLmtleSk7XG4gICAgICAgICAgICBjb250ZXh0LmVycm9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzYXcubmV4dCgpO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5mb3JFYWNoID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHRoaXMuc2VxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3RhY2tfID0gY29udGV4dC5zdGFjay5zbGljZSgpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGNvbnRleHQuc3RhY2subGVuZ3RoO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZW5kID09PSAwKSB0aGlzKG51bGwpXG4gICAgICAgICAgICBlbHNlIGNvbnRleHQuc3RhY2suZm9yRWFjaChmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbihzYXcuc3RlcCwgaSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKHRoaXMsIHgsIGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSBlbmQgLSAxKSBzYXcubmV4dCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5zZXFFYWNoID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHRoaXMuc2VxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3RhY2tfID0gY29udGV4dC5zdGFjay5zbGljZSgpO1xuICAgICAgICAgICAgdmFyIHhzID0gY29udGV4dC5zdGFjay5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKHhzLmxlbmd0aCA9PT0gMCkgdGhpcyhudWxsKTtcbiAgICAgICAgICAgIGVsc2UgKGZ1bmN0aW9uIG5leHQgKGkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgIHNhdy5zdGVwLCBpLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IGNiLmNhbGwodGhpcywgeHNbaV0sIGkpIH0sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFyZ3MgfHwgaSA9PT0geHMubGVuZ3RoIC0gMSkgc2F3Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgbmV4dChpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSkuYmluZCh0aGlzKSgwKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnBhckVhY2ggPSBmdW5jdGlvbiAobGltaXQsIGNiKSB7XG4gICAgICAgIHZhciB4cyA9IGNvbnRleHQuc3RhY2suc2xpY2UoKTtcbiAgICAgICAgaWYgKGNiID09PSB1bmRlZmluZWQpIHsgY2IgPSBsaW1pdDsgbGltaXQgPSB4cy5sZW5ndGggfVxuICAgICAgICBjb250ZXh0LnN0YWNrXyA9IFtdO1xuICAgICAgICBcbiAgICAgICAgdmFyIGFjdGl2ZSA9IDA7XG4gICAgICAgIHZhciBmaW5pc2hlZCA9IDA7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICBcbiAgICAgICAgaWYgKHhzLmxlbmd0aCA9PT0gMCkgc2F3Lm5leHQoKVxuICAgICAgICBlbHNlIHhzLmZvckVhY2goZnVuY3Rpb24gY2FsbCAoeCwgaSkge1xuICAgICAgICAgICAgaWYgKGFjdGl2ZSA+PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goY2FsbC5iaW5kKHRoaXMsIHgsIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjdGl2ZSArKztcbiAgICAgICAgICAgICAgICBhY3Rpb24oc2F3LnN0ZXAsIGksXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiLmNhbGwodGhpcywgeCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZSAtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkICsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHF1ZXVlLnNoaWZ0KCkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpbmlzaGVkID09PSB4cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXcubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnBhck1hcCA9IGZ1bmN0aW9uIChsaW1pdCwgY2IpIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICB2YXIgbGVuID0gY29udGV4dC5zdGFjay5sZW5ndGg7XG4gICAgICAgIGlmIChjYiA9PT0gdW5kZWZpbmVkKSB7IGNiID0gbGltaXQ7IGxpbWl0ID0gbGVuIH1cbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICBcbiAgICAgICAgU2VxKClcbiAgICAgICAgICAgIC5leHRlbmQoY29udGV4dC5zdGFjaylcbiAgICAgICAgICAgIC5wYXJFYWNoKGxpbWl0LCBmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW2ldID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBuZXh0LnN0YWNrID0gc2VsZi5zdGFjaztcbiAgICAgICAgICAgICAgICBuZXh0LnN0YWNrXyA9IHNlbGYuc3RhY2tfO1xuICAgICAgICAgICAgICAgIG5leHQudmFycyA9IHNlbGYudmFycztcbiAgICAgICAgICAgICAgICBuZXh0LmFyZ3MgPSBzZWxmLmFyZ3M7XG4gICAgICAgICAgICAgICAgbmV4dC5lcnJvciA9IHNlbGYuZXJyb3I7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbmV4dC5pbnRvID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBuZXh0Lm9rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgYXJncy51bnNoaWZ0KG51bGwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dC5hcHBseShuZXh0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNiLmFwcGx5KG5leHQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnNlcShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdGFjayA9IHJlcztcbiAgICAgICAgICAgICAgICBzYXcubmV4dCgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5zZXFNYXAgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICB2YXIgbGFzdElkeCA9IGNvbnRleHQuc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuc2VxRWFjaChmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGxhc3RJZHgpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhY2sgPSByZXM7XG4gICAgICAgICAgICAgICAgc2VsZi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbmV4dC5zdGFjayA9IHNlbGYuc3RhY2s7XG4gICAgICAgICAgICBuZXh0LnN0YWNrXyA9IHNlbGYuc3RhY2tfO1xuICAgICAgICAgICAgbmV4dC52YXJzID0gc2VsZi52YXJzO1xuICAgICAgICAgICAgbmV4dC5hcmdzID0gc2VsZi5hcmdzO1xuICAgICAgICAgICAgbmV4dC5lcnJvciA9IHNlbGYuZXJyb3I7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG5leHQuaW50byA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGxhc3RJZHgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN0YWNrID0gcmVzO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG5leHQub2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgYXJncy51bnNoaWZ0KG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0LmFwcGx5KG5leHQsIGFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2IuYXBwbHkobmV4dCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBDb25zdW1lcyBhbnkgZXJyb3JzIHRoYXQgb2NjdXIgaW4gYGNiYC4gQ2FsbHMgdG8gYHRoaXMuaW50byhpKWAgd2lsbCBwbGFjZVxuICAgICAqIHRoYXQgdmFsdWUsIGlmIGFjY2VwdGVkIGJ5IHRoZSBmaWx0ZXIsIGF0IHRoZSBpbmRleCBpbiB0aGUgcmVzdWx0cyBhc1xuICAgICAqIGlmIGl0IHdlcmUgdGhlIGktdGggaW5kZXggYmVmb3JlIGZpbHRlcmluZy4gKFRoaXMgbWVhbnMgaXQgd2lsbCBuZXZlciBcbiAgICAgKiBvdmVycmlkZSBhbm90aGVyIHZhbHVlLCBhbmQgd2lsbCBvbmx5IGFjdHVhbGx5IGFwcGVhciBhdCBpIGlmIHRoZSBmaWx0ZXJcbiAgICAgKiBhY2NlcHRzIGFsbCB2YWx1ZXMgYmVmb3JlIGkuKVxuICAgICAqL1xuICAgIHRoaXMucGFyRmlsdGVyID0gZnVuY3Rpb24gKGxpbWl0LCBjYikge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIHZhciBsZW4gPSBjb250ZXh0LnN0YWNrLmxlbmd0aDtcbiAgICAgICAgaWYgKGNiID09PSB1bmRlZmluZWQpIHsgY2IgPSBsaW1pdDsgbGltaXQgPSBsZW4gfVxuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIFxuICAgICAgICBTZXEoKVxuICAgICAgICAgICAgLmV4dGVuZChjb250ZXh0LnN0YWNrKVxuICAgICAgICAgICAgLnBhckVhY2gobGltaXQsIGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gKGVyciwgb2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIgJiYgb2spXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChbaSwgeF0pO1xuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNbMF0gPSBudWxsOyAvLyBkaXNjYXJkIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBuZXh0LnN0YWNrID0gc2VsZi5zdGFjaztcbiAgICAgICAgICAgICAgICBuZXh0LnN0YWNrXyA9IHNlbGYuc3RhY2tfO1xuICAgICAgICAgICAgICAgIG5leHQudmFycyA9IHNlbGYudmFycztcbiAgICAgICAgICAgICAgICBuZXh0LmFyZ3MgPSBzZWxmLmFyZ3M7XG4gICAgICAgICAgICAgICAgbmV4dC5lcnJvciA9IHNlbGYuZXJyb3I7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbmV4dC5pbnRvID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVyciwgb2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyICYmIG9rKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKFtrZXksIHhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c1swXSA9IG51bGw7IC8vIGRpc2NhcmQgZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBuZXh0Lm9rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgYXJncy51bnNoaWZ0KG51bGwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dC5hcHBseShuZXh0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNiLmFwcGx5KG5leHQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnNlcShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdGFjayA9IHJlcy5zb3J0KCkubWFwKGZ1bmN0aW9uKHBhaXIpeyByZXR1cm4gcGFpclsxXTsgfSk7XG4gICAgICAgICAgICAgICAgc2F3Lm5leHQoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIDtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIENvbnN1bWVzIGFueSBlcnJvcnMgdGhhdCBvY2N1ciBpbiBgY2JgLiBDYWxscyB0byBgdGhpcy5pbnRvKGkpYCB3aWxsIHBsYWNlXG4gICAgICogdGhhdCB2YWx1ZSwgaWYgYWNjZXB0ZWQgYnkgdGhlIGZpbHRlciwgYXQgdGhlIGluZGV4IGluIHRoZSByZXN1bHRzIGFzXG4gICAgICogaWYgaXQgd2VyZSB0aGUgaS10aCBpbmRleCBiZWZvcmUgZmlsdGVyaW5nLiAoVGhpcyBtZWFucyBpdCB3aWxsIG5ldmVyIFxuICAgICAqIG92ZXJyaWRlIGFub3RoZXIgdmFsdWUsIGFuZCB3aWxsIG9ubHkgYWN0dWFsbHkgYXBwZWFyIGF0IGkgaWYgdGhlIGZpbHRlclxuICAgICAqIGFjY2VwdHMgYWxsIHZhbHVlcyBiZWZvcmUgaS4pXG4gICAgICovXG4gICAgdGhpcy5zZXFGaWx0ZXIgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICB2YXIgbGFzdElkeCA9IGNvbnRleHQuc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuc2VxRWFjaChmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIChlcnIsIG9rKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnIgJiYgb2spXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKFtpLCB4XSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGxhc3RJZHgpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhY2sgPSByZXMuc29ydCgpLm1hcChmdW5jdGlvbihwYWlyKXsgcmV0dXJuIHBhaXJbMV07IH0pO1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50c1swXSA9IG51bGw7IC8vIGRpc2NhcmQgZXJyb3JzXG4gICAgICAgICAgICAgICAgc2VsZi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbmV4dC5zdGFjayA9IHNlbGYuc3RhY2s7XG4gICAgICAgICAgICBuZXh0LnN0YWNrXyA9IHNlbGYuc3RhY2tfO1xuICAgICAgICAgICAgbmV4dC52YXJzID0gc2VsZi52YXJzO1xuICAgICAgICAgICAgbmV4dC5hcmdzID0gc2VsZi5hcmdzO1xuICAgICAgICAgICAgbmV4dC5lcnJvciA9IHNlbGYuZXJyb3I7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG5leHQuaW50byA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVyciwgb2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIgJiYgb2spXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChba2V5LCB4XSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBsYXN0SWR4KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdGFjayA9IHJlcy5zb3J0KCkubWFwKGZ1bmN0aW9uKHBhaXIpeyByZXR1cm4gcGFpclsxXTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c1swXSA9IG51bGw7IC8vIGRpc2NhcmQgZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbmV4dC5vayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQobnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQuYXBwbHkobmV4dCwgYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYi5hcHBseShuZXh0LCBhcmd1bWVudHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIFsgJ2ZvckVhY2gnLCAnc2VxRWFjaCcsICdwYXJFYWNoJywgJ3NlcU1hcCcsICdwYXJNYXAnLCAnc2VxRmlsdGVyJywgJ3BhckZpbHRlcicgXVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lICsgJ18nXSA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIHRoaXNbbmFtZV0uY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcylcbiAgICA7XG4gICAgXG4gICAgWydwdXNoJywncG9wJywnc2hpZnQnLCd1bnNoaWZ0Jywnc3BsaWNlJywncmV2ZXJzZSddXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhY2tbbmFtZV0uYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgc2F3Lm5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMpXG4gICAgO1xuICAgIFxuICAgIFsgJ21hcCcsICdmaWx0ZXInLCAncmVkdWNlJyBdXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBjb250ZXh0LnN0YWNrW25hbWVdLmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIC8vIHN0YWNrIG11c3QgYmUgYW4gYXJyYXksIG9yIGJhZCB0aGluZ3MgaGFwcGVuXG4gICAgICAgICAgICAgICAgY29udGV4dC5zdGFjayA9IChBcnJheS5pc0FycmF5KHJlcykgPyByZXMgOiBbcmVzXSk7XG4gICAgICAgICAgICAgICAgc2F3Lm5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMpXG4gICAgO1xuICAgIFxuICAgIHRoaXMuZXh0ZW5kID0gZnVuY3Rpb24gKHhzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh4cykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXJndW1lbnQgdG8gLmV4dGVuZCgpIGlzIG5vdCBhbiBBcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuc3RhY2sucHVzaC5hcHBseShjb250ZXh0LnN0YWNrLCB4cyk7XG4gICAgICAgIHNhdy5uZXh0KCk7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmZsYXR0ZW4gPSBmdW5jdGlvbiAocGFuY2FrZSkge1xuICAgICAgICB2YXIgeHMgPSBbXTtcbiAgICAgICAgLy8gc2hvdWxkIHdlIGZ1bGx5IGZsYXR0ZW4gdGhpcyBhcnJheT8gKGRlZmF1bHQ6IHRydWUpXG4gICAgICAgIGlmIChwYW5jYWtlID09PSB1bmRlZmluZWQpIHsgcGFuY2FrZSA9IHRydWU7IH1cbiAgICAgICAgY29udGV4dC5zdGFjay5mb3JFYWNoKGZ1bmN0aW9uIGYgKHgpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHgpICYmIHBhbmNha2UpIHguZm9yRWFjaChmKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHhzID0geHMuY29uY2F0KHgpO1xuICAgICAgICAgICAgZWxzZSB4cy5wdXNoKHgpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29udGV4dC5zdGFjayA9IHhzO1xuICAgICAgICBzYXcubmV4dCgpO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy51bmZsYXR0ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRleHQuc3RhY2sgPSBbY29udGV4dC5zdGFja107XG4gICAgICAgIHNhdy5uZXh0KCk7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZXh0LnN0YWNrID0gW107XG4gICAgICAgIHNhdy5uZXh0KCk7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnNldCA9IGZ1bmN0aW9uIChzdGFjaykge1xuICAgICAgICBjb250ZXh0LnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHNhdy5uZXh0KCk7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzWydkbyddID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHNhdy5uZXN0KGNiLCBjb250ZXh0KTtcbiAgICB9O1xufVxuIiwidmFyIFRyYXZlcnNlID0gcmVxdWlyZSgndHJhdmVyc2UnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhaW5zYXc7XG5mdW5jdGlvbiBDaGFpbnNhdyAoYnVpbGRlcikge1xuICAgIHZhciBzYXcgPSBDaGFpbnNhdy5zYXcoYnVpbGRlciwge30pO1xuICAgIHZhciByID0gYnVpbGRlci5jYWxsKHNhdy5oYW5kbGVycywgc2F3KTtcbiAgICBpZiAociAhPT0gdW5kZWZpbmVkKSBzYXcuaGFuZGxlcnMgPSByO1xuICAgIHJldHVybiBzYXcuY2hhaW4oKTtcbn07XG5cbkNoYWluc2F3LnNhdyA9IGZ1bmN0aW9uIChidWlsZGVyLCBoYW5kbGVycykge1xuICAgIHZhciBzYXcgPSBuZXcgRXZlbnRFbWl0dGVyO1xuICAgIHNhdy5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgIHNhdy5hY3Rpb25zID0gW107XG4gICAgc2F3LnN0ZXAgPSAwO1xuICAgIFxuICAgIHNhdy5jaGFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoID0gVHJhdmVyc2Uoc2F3LmhhbmRsZXJzKS5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUm9vdCkgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB2YXIgcHMgPSB0aGlzLnBhdGg7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2F3LmFjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoIDogcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzIDogW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2g7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzYXcuZW1pdCgnYmVnaW4nKTtcbiAgICAgICAgICAgIHNhdy5uZXh0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGNoO1xuICAgIH07XG4gICAgXG4gICAgc2F3Lm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSBzYXcuYWN0aW9uc1tzYXcuc3RlcF07XG4gICAgICAgIHNhdy5zdGVwICsrO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgICAgIHNhdy5lbWl0KCdlbmQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghYWN0aW9uLnRyYXApIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gc2F3LmhhbmRsZXJzO1xuICAgICAgICAgICAgYWN0aW9uLnBhdGguZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IG5vZGUgPSBub2RlW2tleV0gfSk7XG4gICAgICAgICAgICBub2RlLmFwcGx5KHNhdy5oYW5kbGVycywgYWN0aW9uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBzYXcubmVzdCA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgdmFyIGF1dG9uZXh0ID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdmFyIGF1dG9uZXh0ID0gY2I7XG4gICAgICAgICAgICBjYiA9IGFyZ3Muc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHMgPSBDaGFpbnNhdy5zYXcoYnVpbGRlciwge30pO1xuICAgICAgICB2YXIgciA9IGJ1aWxkZXIuY2FsbChzLmhhbmRsZXJzLCBzKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChyICE9PSB1bmRlZmluZWQpIHMuaGFuZGxlcnMgPSByO1xuICAgICAgICBjYi5hcHBseShzLmNoYWluKCksIGFyZ3MpO1xuICAgICAgICBpZiAoYXV0b25leHQgIT09IGZhbHNlKSBzLm9uKCdlbmQnLCBzYXcubmV4dCk7XG4gICAgfTtcbiAgICBcbiAgICBzYXcudHJhcCA9IGZ1bmN0aW9uIChuYW1lLCBjYikge1xuICAgICAgICB2YXIgcHMgPSBBcnJheS5pc0FycmF5KG5hbWUpID8gbmFtZSA6IFtuYW1lXTtcbiAgICAgICAgc2F3LmFjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBwYXRoIDogcHMsXG4gICAgICAgICAgICBzdGVwIDogc2F3LnN0ZXAsXG4gICAgICAgICAgICBjYiA6IGNiLFxuICAgICAgICAgICAgdHJhcCA6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBcbiAgICBzYXcuZG93biA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBwcyA9IChBcnJheS5pc0FycmF5KG5hbWUpID8gbmFtZSA6IFtuYW1lXSkuam9pbignLycpO1xuICAgICAgICB2YXIgaSA9IHNhdy5hY3Rpb25zLnNsaWNlKHNhdy5zdGVwKS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIGlmICh4LnRyYXAgJiYgeC5zdGVwIDw9IHNhdy5zdGVwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4geC5wYXRoLmpvaW4oJy8nKSA9PSBwcztcbiAgICAgICAgfSkuaW5kZXhPZih0cnVlKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChpID49IDApIHNhdy5zdGVwICs9IGk7XG4gICAgICAgIGVsc2Ugc2F3LnN0ZXAgPSBzYXcuYWN0aW9ucy5sZW5ndGg7XG4gICAgICAgIFxuICAgICAgICB2YXIgYWN0ID0gc2F3LmFjdGlvbnNbc2F3LnN0ZXAgLSAxXTtcbiAgICAgICAgaWYgKGFjdCAmJiBhY3QudHJhcCkge1xuICAgICAgICAgICAgLy8gSXQncyBhIHRyYXAhXG4gICAgICAgICAgICBzYXcuc3RlcCA9IGFjdC5zdGVwO1xuICAgICAgICAgICAgYWN0LmNiKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBzYXcubmV4dCgpO1xuICAgIH07XG4gICAgXG4gICAgc2F3Lmp1bXAgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICBzYXcuc3RlcCA9IHN0ZXA7XG4gICAgICAgIHNhdy5uZXh0KCk7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gc2F3O1xufTsgXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFRyYXZlcnNlO1xuZnVuY3Rpb24gVHJhdmVyc2UgKG9iaikge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmF2ZXJzZSkpIHJldHVybiBuZXcgVHJhdmVyc2Uob2JqKTtcbiAgICB0aGlzLnZhbHVlID0gb2JqO1xufVxuXG5UcmF2ZXJzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBzKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHMubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBwc1tpXTtcbiAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCBrZXkpKSB7XG4gICAgICAgICAgICBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHBzLCB2YWx1ZSkge1xuICAgIHZhciBub2RlID0gdGhpcy52YWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aCAtIDE7IGkgKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHBzW2ldO1xuICAgICAgICBpZiAoIU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGUsIGtleSkpIG5vZGVba2V5XSA9IHt9O1xuICAgICAgICBub2RlID0gbm9kZVtrZXldO1xuICAgIH1cbiAgICBub2RlW3BzW2ldXSA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICByZXR1cm4gd2Fsayh0aGlzLnZhbHVlLCBjYiwgdHJ1ZSk7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYikge1xuICAgIHRoaXMudmFsdWUgPSB3YWxrKHRoaXMudmFsdWUsIGNiLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGNiLCBpbml0KSB7XG4gICAgdmFyIHNraXAgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxO1xuICAgIHZhciBhY2MgPSBza2lwID8gdGhpcy52YWx1ZSA6IGluaXQ7XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1Jvb3QgfHwgIXNraXApIHtcbiAgICAgICAgICAgIGFjYyA9IGNiLmNhbGwodGhpcywgYWNjLCB4KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhY2M7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUuZGVlcEVxdWFsID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdkZWVwRXF1YWwgcmVxdWlyZXMgZXhhY3RseSBvbmUgb2JqZWN0IHRvIGNvbXBhcmUgYWdhaW5zdCdcbiAgICAgICAgKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGVxdWFsID0gdHJ1ZTtcbiAgICB2YXIgbm9kZSA9IG9iajtcbiAgICBcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgdmFyIG5vdEVxdWFsID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICAvL3RoaXMuc3RvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSkuYmluZCh0aGlzKTtcbiAgICAgICAgXG4gICAgICAgIC8vaWYgKG5vZGUgPT09IHVuZGVmaW5lZCB8fCBub2RlID09PSBudWxsKSByZXR1cm4gbm90RXF1YWwoKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghdGhpcy5pc1Jvb3QpIHtcbiAgICAgICAgLypcbiAgICAgICAgICAgIGlmICghT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobm9kZSwgdGhpcy5rZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdEVxdWFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSByZXR1cm4gbm90RXF1YWwoKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlW3RoaXMua2V5XTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHggPSBub2RlO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5wb3N0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG5vZGUgPSB4O1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHZhciB0b1MgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0aGlzLmNpcmN1bGFyKSB7XG4gICAgICAgICAgICBpZiAoVHJhdmVyc2Uob2JqKS5nZXQodGhpcy5jaXJjdWxhci5wYXRoKSAhPT0geCkgbm90RXF1YWwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgeCAhPT0gdHlwZW9mIHkpIHtcbiAgICAgICAgICAgIG5vdEVxdWFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeCA9PT0gbnVsbCB8fCB5ID09PSBudWxsIHx8IHggPT09IHVuZGVmaW5lZCB8fCB5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh4ICE9PSB5KSBub3RFcXVhbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHguX19wcm90b19fICE9PSB5Ll9fcHJvdG9fXykge1xuICAgICAgICAgICAgbm90RXF1YWwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4ID09PSB5KSB7XG4gICAgICAgICAgICAvLyBub3BcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICAvLyBib3RoIHJlZ2V4cHMgb24gYWNjb3VudCBvZiB0aGUgX19wcm90b19fIGNoZWNrXG4gICAgICAgICAgICAgICAgaWYgKHgudG9TdHJpbmcoKSAhPSB5LnRvU3RyaW5nKCkpIG5vdEVxdWFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh4ICE9PSB5KSBub3RFcXVhbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKHRvUyh5KSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSdcbiAgICAgICAgICAgIHx8IHRvUyh4KSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXScpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9TKHgpICE9PSB0b1MoeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm90RXF1YWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh4IGluc3RhbmNlb2YgRGF0ZSB8fCB5IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghKHggaW5zdGFuY2VvZiBEYXRlKSB8fCAhKHkgaW5zdGFuY2VvZiBEYXRlKVxuICAgICAgICAgICAgICAgIHx8IHguZ2V0VGltZSgpICE9PSB5LmdldFRpbWUoKSkge1xuICAgICAgICAgICAgICAgICAgICBub3RFcXVhbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBreCA9IE9iamVjdC5rZXlzKHgpO1xuICAgICAgICAgICAgICAgIHZhciBreSA9IE9iamVjdC5rZXlzKHkpO1xuICAgICAgICAgICAgICAgIGlmIChreC5sZW5ndGggIT09IGt5Lmxlbmd0aCkgcmV0dXJuIG5vdEVxdWFsKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBreC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgayA9IGt4W2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHksIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RFcXVhbCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIGVxdWFsO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLnBhdGhzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhY2MgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgYWNjLnB1c2godGhpcy5wYXRoKTsgXG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5ub2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWNjID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGFjYy5wdXNoKHRoaXMubm9kZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50cyA9IFtdLCBub2RlcyA9IFtdO1xuICAgIFxuICAgIHJldHVybiAoZnVuY3Rpb24gY2xvbmUgKHNyYykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRzW2ldID09PSBzcmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnb2JqZWN0JyAmJiBzcmMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkc3QgPSBjb3B5KHNyYyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChzcmMpO1xuICAgICAgICAgICAgbm9kZXMucHVzaChkc3QpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzcmMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGRzdFtrZXldID0gY2xvbmUoc3JjW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHBhcmVudHMucG9wKCk7XG4gICAgICAgICAgICBub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiBkc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjO1xuICAgICAgICB9XG4gICAgfSkodGhpcy52YWx1ZSk7XG59O1xuXG5mdW5jdGlvbiB3YWxrIChyb290LCBjYiwgaW1tdXRhYmxlKSB7XG4gICAgdmFyIHBhdGggPSBbXTtcbiAgICB2YXIgcGFyZW50cyA9IFtdO1xuICAgIHZhciBhbGl2ZSA9IHRydWU7XG4gICAgXG4gICAgcmV0dXJuIChmdW5jdGlvbiB3YWxrZXIgKG5vZGVfKSB7XG4gICAgICAgIHZhciBub2RlID0gaW1tdXRhYmxlID8gY29weShub2RlXykgOiBub2RlXztcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IHt9O1xuICAgICAgICBcbiAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgbm9kZSA6IG5vZGUsXG4gICAgICAgICAgICBub2RlXyA6IG5vZGVfLFxuICAgICAgICAgICAgcGF0aCA6IFtdLmNvbmNhdChwYXRoKSxcbiAgICAgICAgICAgIHBhcmVudCA6IHBhcmVudHMuc2xpY2UoLTEpWzBdLFxuICAgICAgICAgICAga2V5IDogcGF0aC5zbGljZSgtMSlbMF0sXG4gICAgICAgICAgICBpc1Jvb3QgOiBwYXRoLmxlbmd0aCA9PT0gMCxcbiAgICAgICAgICAgIGxldmVsIDogcGF0aC5sZW5ndGgsXG4gICAgICAgICAgICBjaXJjdWxhciA6IG51bGwsXG4gICAgICAgICAgICB1cGRhdGUgOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaXNSb290KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnBhcmVudC5ub2RlW3N0YXRlLmtleV0gPSB4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS5ub2RlID0geDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZGVsZXRlJyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGUucGFyZW50Lm5vZGVbc3RhdGUua2V5XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3RhdGUucGFyZW50Lm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnBhcmVudC5ub2RlLnNwbGljZShzdGF0ZS5rZXksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLnBhcmVudC5ub2RlW3N0YXRlLmtleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJlZm9yZSA6IGZ1bmN0aW9uIChmKSB7IG1vZGlmaWVycy5iZWZvcmUgPSBmIH0sXG4gICAgICAgICAgICBhZnRlciA6IGZ1bmN0aW9uIChmKSB7IG1vZGlmaWVycy5hZnRlciA9IGYgfSxcbiAgICAgICAgICAgIHByZSA6IGZ1bmN0aW9uIChmKSB7IG1vZGlmaWVycy5wcmUgPSBmIH0sXG4gICAgICAgICAgICBwb3N0IDogZnVuY3Rpb24gKGYpIHsgbW9kaWZpZXJzLnBvc3QgPSBmIH0sXG4gICAgICAgICAgICBzdG9wIDogZnVuY3Rpb24gKCkgeyBhbGl2ZSA9IGZhbHNlIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGlmICghYWxpdmUpIHJldHVybiBzdGF0ZTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGUuaXNMZWFmID0gT2JqZWN0LmtleXMobm9kZSkubGVuZ3RoID09IDA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRzW2ldLm5vZGVfID09PSBub2RlXykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jaXJjdWxhciA9IHBhcmVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmlzTGVhZiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHN0YXRlLm5vdExlYWYgPSAhc3RhdGUuaXNMZWFmO1xuICAgICAgICBzdGF0ZS5ub3RSb290ID0gIXN0YXRlLmlzUm9vdDtcbiAgICAgICAgXG4gICAgICAgIC8vIHVzZSByZXR1cm4gdmFsdWVzIHRvIHVwZGF0ZSBpZiBkZWZpbmVkXG4gICAgICAgIHZhciByZXQgPSBjYi5jYWxsKHN0YXRlLCBzdGF0ZS5ub2RlKTtcbiAgICAgICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkICYmIHN0YXRlLnVwZGF0ZSkgc3RhdGUudXBkYXRlKHJldCk7XG4gICAgICAgIGlmIChtb2RpZmllcnMuYmVmb3JlKSBtb2RpZmllcnMuYmVmb3JlLmNhbGwoc3RhdGUsIHN0YXRlLm5vZGUpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZS5ub2RlID09ICdvYmplY3QnXG4gICAgICAgICYmIHN0YXRlLm5vZGUgIT09IG51bGwgJiYgIXN0YXRlLmNpcmN1bGFyKSB7XG4gICAgICAgICAgICBwYXJlbnRzLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHN0YXRlLm5vZGUpO1xuICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGkpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXJzLnByZSkgbW9kaWZpZXJzLnByZS5jYWxsKHN0YXRlLCBzdGF0ZS5ub2RlW2tleV0sIGtleSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gd2Fsa2VyKHN0YXRlLm5vZGVba2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKGltbXV0YWJsZSAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS5ub2RlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm5vZGVba2V5XSA9IGNoaWxkLm5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNoaWxkLmlzTGFzdCA9IGkgPT0ga2V5cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGNoaWxkLmlzRmlyc3QgPSBpID09IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5wb3N0KSBtb2RpZmllcnMucG9zdC5jYWxsKHN0YXRlLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcGF0aC5wb3AoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyZW50cy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKG1vZGlmaWVycy5hZnRlcikgbW9kaWZpZXJzLmFmdGVyLmNhbGwoc3RhdGUsIHN0YXRlLm5vZGUpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0pKHJvb3QpLm5vZGU7XG59XG5cbk9iamVjdC5rZXlzKFRyYXZlcnNlLnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgVHJhdmVyc2Vba2V5XSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHZhciB0ID0gVHJhdmVyc2Uob2JqKTtcbiAgICAgICAgcmV0dXJuIHRba2V5XS5hcHBseSh0LCBhcmdzKTtcbiAgICB9O1xufSk7XG5cbmZ1bmN0aW9uIGNvcHkgKHNyYykge1xuICAgIGlmICh0eXBlb2Ygc3JjID09PSAnb2JqZWN0JyAmJiBzcmMgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGRzdDtcbiAgICAgICAgXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNyYykpIHtcbiAgICAgICAgICAgIGRzdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIGRzdCA9IG5ldyBEYXRlKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgICAgICAgZHN0ID0gbmV3IEJvb2xlYW4oc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgICAgIGRzdCA9IG5ldyBOdW1iZXIoc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICAgIGRzdCA9IG5ldyBTdHJpbmcoc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRzdCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHNyYykpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBPYmplY3Qua2V5cyhzcmMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgZHN0W2tleV0gPSBzcmNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkc3Q7XG4gICAgfVxuICAgIGVsc2UgcmV0dXJuIHNyYztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gSGFzaDtcbnZhciBUcmF2ZXJzZSA9IHJlcXVpcmUoJ3RyYXZlcnNlJyk7XG5cbmZ1bmN0aW9uIEhhc2ggKGhhc2gsIHhzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFzaCkgJiYgQXJyYXkuaXNBcnJheSh4cykpIHtcbiAgICAgICAgdmFyIHRvID0gTWF0aC5taW4oaGFzaC5sZW5ndGgsIHhzLmxlbmd0aCk7XG4gICAgICAgIHZhciBhY2MgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBhY2NbaGFzaFtpXV0gPSB4c1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSGFzaChhY2MpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoaGFzaCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gSGFzaCh7fSk7XG4gICAgXG4gICAgdmFyIHNlbGYgPSB7XG4gICAgICAgIG1hcCA6IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICB2YXIgYWNjID0geyBfX3Byb3RvX18gOiBoYXNoLl9fcHJvdG9fXyB9O1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoaGFzaCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSBmLmNhbGwoc2VsZiwgaGFzaFtrZXldLCBrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSGFzaChhY2MpO1xuICAgICAgICB9LFxuICAgICAgICBmb3JFYWNoIDogZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGhhc2gpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGYuY2FsbChzZWxmLCBoYXNoW2tleV0sIGtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9LFxuICAgICAgICBmaWx0ZXIgOiBmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgdmFyIGFjYyA9IHsgX19wcm90b19fIDogaGFzaC5fX3Byb3RvX18gfTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGhhc2gpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChmLmNhbGwoc2VsZiwgaGFzaFtrZXldLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY1trZXldID0gaGFzaFtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIEhhc2goYWNjKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGV0ZWN0IDogZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBoYXNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGYuY2FsbChzZWxmLCBoYXNoW2tleV0sIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc2hba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgICByZWR1Y2UgOiBmdW5jdGlvbiAoZiwgYWNjKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGhhc2gpO1xuICAgICAgICAgICAgaWYgKGFjYyA9PT0gdW5kZWZpbmVkKSBhY2MgPSBrZXlzLnNoaWZ0KCk7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGFjYyA9IGYuY2FsbChzZWxmLCBhY2MsIGhhc2hba2V5XSwga2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSxcbiAgICAgICAgc29tZSA6IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gaGFzaCkge1xuICAgICAgICAgICAgICAgIGlmIChmLmNhbGwoc2VsZiwgaGFzaFtrZXldLCBrZXkpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlIDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGVBbGwoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc2hba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZUFsbCA6IGZ1bmN0aW9uICh4cykge1xuICAgICAgICAgICAgeHMuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZSh4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmdlIDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29weS51cGRhdGVBbGwoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNvcHkudXBkYXRlKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmdlQWxsIDogZnVuY3Rpb24gKHhzKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jb3B5LnVwZGF0ZUFsbCh4cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhcyA6IGZ1bmN0aW9uIChrZXkpIHsgLy8gb25seSBvcGVyYXRlcyBvbiBlbnVtZXJhYmxlc1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoa2V5KVxuICAgICAgICAgICAgICAgID8ga2V5LmV2ZXJ5KGZ1bmN0aW9uIChrKSB7IHJldHVybiBzZWxmLmhhcyhrKSB9KVxuICAgICAgICAgICAgICAgIDogc2VsZi5rZXlzLmluZGV4T2Yoa2V5LnRvU3RyaW5nKCkpID49IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlc0F0IDogZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGtleXMpXG4gICAgICAgICAgICAgICAgPyBrZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBoYXNoW2tleV0gfSlcbiAgICAgICAgICAgICAgICA6IGhhc2hba2V5c11cbiAgICAgICAgICAgIDtcbiAgICAgICAgfSxcbiAgICAgICAgdGFwIDogZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIGYuY2FsbChzZWxmLCBoYXNoKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9LFxuICAgICAgICBleHRyYWN0IDogZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICAgIHZhciBhY2MgPSB7fTtcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSBoYXNoW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBIYXNoKGFjYyk7XG4gICAgICAgIH0sXG4gICAgICAgIGV4Y2x1ZGUgOiBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuZmlsdGVyKGZ1bmN0aW9uIChfLCBrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5pbmRleE9mKGtleSkgPCAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5kIDogaGFzaCxcbiAgICAgICAgaXRlbXMgOiBoYXNoXG4gICAgfTtcbiAgICBcbiAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGtleXMgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBPYmplY3Qua2V5cyhoYXNoKSB9LFxuICAgICAgICB2YWx1ZXMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoaGFzaCkubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGhhc2hba2V5XSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGFjdCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAhPT0gdW5kZWZpbmVkIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjbG9uZSA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEhhc2goSGFzaC5jbG9uZShoYXNoKSkgfSxcbiAgICAgICAgY29weSA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEhhc2goSGFzaC5jb3B5KGhhc2gpKSB9LFxuICAgICAgICBsZW5ndGggOiBmdW5jdGlvbiAoKSB7IHJldHVybiBPYmplY3Qua2V5cyhoYXNoKS5sZW5ndGggfSxcbiAgICAgICAgc2l6ZSA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYubGVuZ3RoIH1cbiAgICB9O1xuICAgIFxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgLy8gZXM1LXNoaW0gaGFzIGFuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBidXQgaXQgdGhyb3dzIGZvciBnZXR0ZXJzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwga2V5LCB7IGdldCA6IHByb3BzW2tleV0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2Nsb25lJyAmJiBrZXkgIT09ICdjb3B5JyAmJiBrZXkgIT09ICdjb21wYWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBeIHRob3NlIGtleXMgdXNlIEhhc2goKSBzbyBjYW4ndCBjYWxsIHRoZW0gd2l0aG91dFxuICAgICAgICAgICAgICAgICAgICAvLyBhIHN0YWNrIG92ZXJmbG93XG4gICAgICAgICAgICAgICAgICAgIHNlbGZba2V5XSA9IHByb3BzW2tleV0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2VsZi5fX2RlZmluZUdldHRlcl9fKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgICAgICAgc2VsZi5fX2RlZmluZUdldHRlcl9fKGtleSwgcHJvcHNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIG5vbi1sYXp5IHZlcnNpb24gZm9yIGJyb3dzZXJzIHRoYXQgc3VjayA+XzxcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgICBzZWxmW2tleV0gPSBwcm9wc1trZXldKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHNlbGY7XG59O1xuXG4vLyBkZWVwIGNvcHlcbkhhc2guY2xvbmUgPSBmdW5jdGlvbiAocmVmKSB7XG4gICAgcmV0dXJuIFRyYXZlcnNlLmNsb25lKHJlZik7XG59O1xuXG4vLyBzaGFsbG93IGNvcHlcbkhhc2guY29weSA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIgaGFzaCA9IHsgX19wcm90b19fIDogcmVmLl9fcHJvdG9fXyB9O1xuICAgIE9iamVjdC5rZXlzKHJlZikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGhhc2hba2V5XSA9IHJlZltrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiBoYXNoO1xufTtcblxuSGFzaC5tYXAgPSBmdW5jdGlvbiAocmVmLCBmKSB7XG4gICAgcmV0dXJuIEhhc2gocmVmKS5tYXAoZikuaXRlbXM7XG59O1xuXG5IYXNoLmZvckVhY2ggPSBmdW5jdGlvbiAocmVmLCBmKSB7XG4gICAgSGFzaChyZWYpLmZvckVhY2goZik7XG59O1xuXG5IYXNoLmZpbHRlciA9IGZ1bmN0aW9uIChyZWYsIGYpIHtcbiAgICByZXR1cm4gSGFzaChyZWYpLmZpbHRlcihmKS5pdGVtcztcbn07XG5cbkhhc2guZGV0ZWN0ID0gZnVuY3Rpb24gKHJlZiwgZikge1xuICAgIHJldHVybiBIYXNoKHJlZikuZGV0ZWN0KGYpO1xufTtcblxuSGFzaC5yZWR1Y2UgPSBmdW5jdGlvbiAocmVmLCBmLCBhY2MpIHtcbiAgICByZXR1cm4gSGFzaChyZWYpLnJlZHVjZShmLCBhY2MpO1xufTtcblxuSGFzaC5zb21lID0gZnVuY3Rpb24gKHJlZiwgZikge1xuICAgIHJldHVybiBIYXNoKHJlZikuc29tZShmKTtcbn07XG5cbkhhc2gudXBkYXRlID0gZnVuY3Rpb24gKGEgLyosIGIsIGMsIC4uLiAqLykge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgaGFzaCA9IEhhc2goYSk7XG4gICAgcmV0dXJuIGhhc2gudXBkYXRlLmFwcGx5KGhhc2gsIGFyZ3MpLml0ZW1zO1xufTtcblxuSGFzaC5tZXJnZSA9IGZ1bmN0aW9uIChhIC8qLCBiLCBjLCAuLi4gKi8pIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGhhc2ggPSBIYXNoKGEpO1xuICAgIHJldHVybiBoYXNoLm1lcmdlLmFwcGx5KGhhc2gsIGFyZ3MpLml0ZW1zO1xufTtcblxuSGFzaC5oYXMgPSBmdW5jdGlvbiAocmVmLCBrZXkpIHtcbiAgICByZXR1cm4gSGFzaChyZWYpLmhhcyhrZXkpO1xufTtcblxuSGFzaC52YWx1ZXNBdCA9IGZ1bmN0aW9uIChyZWYsIGtleXMpIHtcbiAgICByZXR1cm4gSGFzaChyZWYpLnZhbHVlc0F0KGtleXMpO1xufTtcblxuSGFzaC50YXAgPSBmdW5jdGlvbiAocmVmLCBmKSB7XG4gICAgcmV0dXJuIEhhc2gocmVmKS50YXAoZikuaXRlbXM7XG59O1xuXG5IYXNoLmV4dHJhY3QgPSBmdW5jdGlvbiAocmVmLCBrZXlzKSB7XG4gICAgcmV0dXJuIEhhc2gocmVmKS5leHRyYWN0KGtleXMpLml0ZW1zO1xufTtcblxuSGFzaC5leGNsdWRlID0gZnVuY3Rpb24gKHJlZiwga2V5cykge1xuICAgIHJldHVybiBIYXNoKHJlZikuZXhjbHVkZShrZXlzKS5pdGVtcztcbn07XG5cbkhhc2guY29uY2F0ID0gZnVuY3Rpb24gKHhzKSB7XG4gICAgdmFyIGhhc2ggPSBIYXNoKHt9KTtcbiAgICB4cy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7IGhhc2gudXBkYXRlKHgpIH0pO1xuICAgIHJldHVybiBoYXNoLml0ZW1zO1xufTtcblxuSGFzaC56aXAgPSBmdW5jdGlvbiAoeHMsIHlzKSB7XG4gICAgcmV0dXJuIEhhc2goeHMsIHlzKS5pdGVtcztcbn07XG5cbi8vIC5sZW5ndGggaXMgYWxyZWFkeSBkZWZpbmVkIGZvciBmdW5jdGlvbiBwcm90b3R5cGVzXG5IYXNoLnNpemUgPSBmdW5jdGlvbiAocmVmKSB7XG4gICAgcmV0dXJuIEhhc2gocmVmKS5zaXplO1xufTtcblxuSGFzaC5jb21wYWN0ID0gZnVuY3Rpb24gKHJlZikge1xuICAgIHJldHVybiBIYXNoKHJlZikuY29tcGFjdC5pdGVtcztcbn07XG4iLCJ2YXIgdHJhdmVyc2UgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gbmV3IFRyYXZlcnNlKG9iaik7XG59O1xuXG5mdW5jdGlvbiBUcmF2ZXJzZSAob2JqKSB7XG4gICAgdGhpcy52YWx1ZSA9IG9iajtcbn1cblxuVHJhdmVyc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwcykge1xuICAgIHZhciBub2RlID0gdGhpcy52YWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aDsgaSArKykge1xuICAgICAgICB2YXIga2V5ID0gcHNbaV07XG4gICAgICAgIGlmICghbm9kZSB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCBrZXkpKSB7XG4gICAgICAgICAgICBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKHBzKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHMubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBwc1tpXTtcbiAgICAgICAgaWYgKCFub2RlIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGUsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAocHMsIHZhbHVlKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHMubGVuZ3RoIC0gMTsgaSArKykge1xuICAgICAgICB2YXIga2V5ID0gcHNbaV07XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCBrZXkpKSBub2RlW2tleV0gPSB7fTtcbiAgICAgICAgbm9kZSA9IG5vZGVba2V5XTtcbiAgICB9XG4gICAgbm9kZVtwc1tpXV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgcmV0dXJuIHdhbGsodGhpcy52YWx1ZSwgY2IsIHRydWUpO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2IpIHtcbiAgICB0aGlzLnZhbHVlID0gd2Fsayh0aGlzLnZhbHVlLCBjYiwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChjYiwgaW5pdCkge1xuICAgIHZhciBza2lwID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMTtcbiAgICB2YXIgYWNjID0gc2tpcCA/IHRoaXMudmFsdWUgOiBpbml0O1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSb290IHx8ICFza2lwKSB7XG4gICAgICAgICAgICBhY2MgPSBjYi5jYWxsKHRoaXMsIGFjYywgeCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYWNjO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLnBhdGhzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhY2MgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgYWNjLnB1c2godGhpcy5wYXRoKTsgXG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5ub2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWNjID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGFjYy5wdXNoKHRoaXMubm9kZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50cyA9IFtdLCBub2RlcyA9IFtdO1xuICAgIFxuICAgIHJldHVybiAoZnVuY3Rpb24gY2xvbmUgKHNyYykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRzW2ldID09PSBzcmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnb2JqZWN0JyAmJiBzcmMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkc3QgPSBjb3B5KHNyYyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChzcmMpO1xuICAgICAgICAgICAgbm9kZXMucHVzaChkc3QpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3JFYWNoKG9iamVjdEtleXMoc3JjKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGRzdFtrZXldID0gY2xvbmUoc3JjW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHBhcmVudHMucG9wKCk7XG4gICAgICAgICAgICBub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiBkc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjO1xuICAgICAgICB9XG4gICAgfSkodGhpcy52YWx1ZSk7XG59O1xuXG5mdW5jdGlvbiB3YWxrIChyb290LCBjYiwgaW1tdXRhYmxlKSB7XG4gICAgdmFyIHBhdGggPSBbXTtcbiAgICB2YXIgcGFyZW50cyA9IFtdO1xuICAgIHZhciBhbGl2ZSA9IHRydWU7XG4gICAgXG4gICAgcmV0dXJuIChmdW5jdGlvbiB3YWxrZXIgKG5vZGVfKSB7XG4gICAgICAgIHZhciBub2RlID0gaW1tdXRhYmxlID8gY29weShub2RlXykgOiBub2RlXztcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IHt9O1xuICAgICAgICBcbiAgICAgICAgdmFyIGtlZXBHb2luZyA9IHRydWU7XG4gICAgICAgIFxuICAgICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgICAgICBub2RlIDogbm9kZSxcbiAgICAgICAgICAgIG5vZGVfIDogbm9kZV8sXG4gICAgICAgICAgICBwYXRoIDogW10uY29uY2F0KHBhdGgpLFxuICAgICAgICAgICAgcGFyZW50IDogcGFyZW50c1twYXJlbnRzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcGFyZW50cyA6IHBhcmVudHMsXG4gICAgICAgICAgICBrZXkgOiBwYXRoLnNsaWNlKC0xKVswXSxcbiAgICAgICAgICAgIGlzUm9vdCA6IHBhdGgubGVuZ3RoID09PSAwLFxuICAgICAgICAgICAgbGV2ZWwgOiBwYXRoLmxlbmd0aCxcbiAgICAgICAgICAgIGNpcmN1bGFyIDogbnVsbCxcbiAgICAgICAgICAgIHVwZGF0ZSA6IGZ1bmN0aW9uICh4LCBzdG9wSGVyZSkge1xuICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaXNSb290KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnBhcmVudC5ub2RlW3N0YXRlLmtleV0gPSB4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS5ub2RlID0geDtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcEhlcmUpIGtlZXBHb2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkZWxldGUnIDogZnVuY3Rpb24gKHN0b3BIZXJlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLnBhcmVudC5ub2RlW3N0YXRlLmtleV07XG4gICAgICAgICAgICAgICAgaWYgKHN0b3BIZXJlKSBrZWVwR29pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmUgOiBmdW5jdGlvbiAoc3RvcEhlcmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShzdGF0ZS5wYXJlbnQubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucGFyZW50Lm5vZGUuc3BsaWNlKHN0YXRlLmtleSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGUucGFyZW50Lm5vZGVbc3RhdGUua2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0b3BIZXJlKSBrZWVwR29pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZXlzIDogbnVsbCxcbiAgICAgICAgICAgIGJlZm9yZSA6IGZ1bmN0aW9uIChmKSB7IG1vZGlmaWVycy5iZWZvcmUgPSBmIH0sXG4gICAgICAgICAgICBhZnRlciA6IGZ1bmN0aW9uIChmKSB7IG1vZGlmaWVycy5hZnRlciA9IGYgfSxcbiAgICAgICAgICAgIHByZSA6IGZ1bmN0aW9uIChmKSB7IG1vZGlmaWVycy5wcmUgPSBmIH0sXG4gICAgICAgICAgICBwb3N0IDogZnVuY3Rpb24gKGYpIHsgbW9kaWZpZXJzLnBvc3QgPSBmIH0sXG4gICAgICAgICAgICBzdG9wIDogZnVuY3Rpb24gKCkgeyBhbGl2ZSA9IGZhbHNlIH0sXG4gICAgICAgICAgICBibG9jayA6IGZ1bmN0aW9uICgpIHsga2VlcEdvaW5nID0gZmFsc2UgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgaWYgKCFhbGl2ZSkgcmV0dXJuIHN0YXRlO1xuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlU3RhdGUoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlLm5vZGUgPT09ICdvYmplY3QnICYmIHN0YXRlLm5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmtleXMgfHwgc3RhdGUubm9kZV8gIT09IHN0YXRlLm5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUua2V5cyA9IG9iamVjdEtleXMoc3RhdGUubm9kZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc3RhdGUuaXNMZWFmID0gc3RhdGUua2V5cy5sZW5ndGggPT0gMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudHNbaV0ubm9kZV8gPT09IG5vZGVfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jaXJjdWxhciA9IHBhcmVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLmlzTGVhZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGUua2V5cyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHN0YXRlLm5vdExlYWYgPSAhc3RhdGUuaXNMZWFmO1xuICAgICAgICAgICAgc3RhdGUubm90Um9vdCA9ICFzdGF0ZS5pc1Jvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHVwZGF0ZVN0YXRlKCk7XG4gICAgICAgIFxuICAgICAgICAvLyB1c2UgcmV0dXJuIHZhbHVlcyB0byB1cGRhdGUgaWYgZGVmaW5lZFxuICAgICAgICB2YXIgcmV0ID0gY2IuY2FsbChzdGF0ZSwgc3RhdGUubm9kZSk7XG4gICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZS51cGRhdGUpIHN0YXRlLnVwZGF0ZShyZXQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKG1vZGlmaWVycy5iZWZvcmUpIG1vZGlmaWVycy5iZWZvcmUuY2FsbChzdGF0ZSwgc3RhdGUubm9kZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWtlZXBHb2luZykgcmV0dXJuIHN0YXRlO1xuICAgICAgICBcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZS5ub2RlID09ICdvYmplY3QnXG4gICAgICAgICYmIHN0YXRlLm5vZGUgIT09IG51bGwgJiYgIXN0YXRlLmNpcmN1bGFyKSB7XG4gICAgICAgICAgICBwYXJlbnRzLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB1cGRhdGVTdGF0ZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3JFYWNoKHN0YXRlLmtleXMsIGZ1bmN0aW9uIChrZXksIGkpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXJzLnByZSkgbW9kaWZpZXJzLnByZS5jYWxsKHN0YXRlLCBzdGF0ZS5ub2RlW2tleV0sIGtleSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gd2Fsa2VyKHN0YXRlLm5vZGVba2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKGltbXV0YWJsZSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLm5vZGUsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUubm9kZVtrZXldID0gY2hpbGQubm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY2hpbGQuaXNMYXN0ID0gaSA9PSBzdGF0ZS5rZXlzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgY2hpbGQuaXNGaXJzdCA9IGkgPT0gMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXJzLnBvc3QpIG1vZGlmaWVycy5wb3N0LmNhbGwoc3RhdGUsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJlbnRzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAobW9kaWZpZXJzLmFmdGVyKSBtb2RpZmllcnMuYWZ0ZXIuY2FsbChzdGF0ZSwgc3RhdGUubm9kZSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSkocm9vdCkubm9kZTtcbn1cblxuZnVuY3Rpb24gY29weSAoc3JjKSB7XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdvYmplY3QnICYmIHNyYyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZHN0O1xuICAgICAgICBcbiAgICAgICAgaWYgKGlzQXJyYXkoc3JjKSkge1xuICAgICAgICAgICAgZHN0ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEYXRlKHNyYykpIHtcbiAgICAgICAgICAgIGRzdCA9IG5ldyBEYXRlKHNyYy5nZXRUaW1lID8gc3JjLmdldFRpbWUoKSA6IHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSZWdFeHAoc3JjKSkge1xuICAgICAgICAgICAgZHN0ID0gbmV3IFJlZ0V4cChzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRXJyb3Ioc3JjKSkge1xuICAgICAgICAgICAgZHN0ID0geyBtZXNzYWdlOiBzcmMubWVzc2FnZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQm9vbGVhbihzcmMpKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgQm9vbGVhbihzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTnVtYmVyKHNyYykpIHtcbiAgICAgICAgICAgIGRzdCA9IG5ldyBOdW1iZXIoc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1N0cmluZyhzcmMpKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgU3RyaW5nKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoT2JqZWN0LmNyZWF0ZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICAgIGRzdCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHNyYykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNyYy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICBkc3QgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcm90byA9XG4gICAgICAgICAgICAgICAgKHNyYy5jb25zdHJ1Y3RvciAmJiBzcmMuY29uc3RydWN0b3IucHJvdG90eXBlKVxuICAgICAgICAgICAgICAgIHx8IHNyYy5fX3Byb3RvX19cbiAgICAgICAgICAgICAgICB8fCB7fVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgdmFyIFQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgIFQucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgICAgICBkc3QgPSBuZXcgVDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZm9yRWFjaChvYmplY3RLZXlzKHNyYyksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGRzdFtrZXldID0gc3JjW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZHN0O1xuICAgIH1cbiAgICBlbHNlIHJldHVybiBzcmM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyAob2JqKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHJlcy5wdXNoKGtleSlcbiAgICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gdG9TIChvYmopIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopIH1cbmZ1bmN0aW9uIGlzRGF0ZSAob2JqKSB7IHJldHVybiB0b1Mob2JqKSA9PT0gJ1tvYmplY3QgRGF0ZV0nIH1cbmZ1bmN0aW9uIGlzUmVnRXhwIChvYmopIHsgcmV0dXJuIHRvUyhvYmopID09PSAnW29iamVjdCBSZWdFeHBdJyB9XG5mdW5jdGlvbiBpc0Vycm9yIChvYmopIHsgcmV0dXJuIHRvUyhvYmopID09PSAnW29iamVjdCBFcnJvcl0nIH1cbmZ1bmN0aW9uIGlzQm9vbGVhbiAob2JqKSB7IHJldHVybiB0b1Mob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nIH1cbmZ1bmN0aW9uIGlzTnVtYmVyIChvYmopIHsgcmV0dXJuIHRvUyhvYmopID09PSAnW29iamVjdCBOdW1iZXJdJyB9XG5mdW5jdGlvbiBpc1N0cmluZyAob2JqKSB7IHJldHVybiB0b1Mob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXScgfVxuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheSAoeHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnZhciBmb3JFYWNoID0gZnVuY3Rpb24gKHhzLCBmbikge1xuICAgIGlmICh4cy5mb3JFYWNoKSByZXR1cm4geHMuZm9yRWFjaChmbilcbiAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm4oeHNbaV0sIGksIHhzKTtcbiAgICB9XG59O1xuXG5mb3JFYWNoKG9iamVjdEtleXMoVHJhdmVyc2UucHJvdG90eXBlKSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHRyYXZlcnNlW2tleV0gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICB2YXIgdCA9IG5ldyBUcmF2ZXJzZShvYmopO1xuICAgICAgICByZXR1cm4gdFtrZXldLmFwcGx5KHQsIGFyZ3MpO1xuICAgIH07XG59KTtcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0Lmhhc093blByb3BlcnR5IHx8IGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAgIHJldHVybiBrZXkgaW4gb2JqO1xufTtcbiIsIi8qKlxuICogQHByZXNlcnZlIENvcHlyaWdodCAyMDEyIFJvYmVydCBHdXN0LUJhcmRvbiA8aHR0cDovL3JvYmVydC5ndXN0LWJhcmRvbi5vcmcvPi5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAqIGFyZSBtZXQ6XG4gKlxuICogICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICogICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgICAgIGRpc2NsYWltZXIuXG4gKlxuICogICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICogICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIgXCJBUyBJU1wiIEFORCBBTllcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAqIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gKiBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAqIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gKiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAqIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICogU1VDSCBEQU1BR0UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEVuaGFuY2VzIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTL1wiXG4gKiA+VWdsaWZ5SlM8L2E+IHdpdGggY29uc29saWRhdGlvbiBvZiBudWxsLCBCb29sZWFuLCBhbmQgU3RyaW5nIHZhbHVlcy5cbiAqIDxwPkFsc28ga25vd24gYXMgYWxpYXNpbmcsIHRoaXMgZmVhdHVyZSBoYXMgYmVlbiBkZXByZWNhdGVkIGluIDxhIGhyZWY9XG4gKiBcImh0dHA6Ly9jbG9zdXJlLWNvbXBpbGVyLmdvb2dsZWNvZGUuY29tL1wiPnRoZSBDbG9zdXJlIENvbXBpbGVyPC9hPiBzaW5jZSBpdHNcbiAqIGluaXRpYWwgcmVsZWFzZSwgd2hlcmUgaXQgaXMgdW5hdmFpbGFibGUgZnJvbSB0aGUgPGFiYnIgdGl0bGU9XG4gKiBcImNvbW1hbmQgbGluZSBpbnRlcmZhY2VcIj5DTEk8L2E+LiBUaGUgQ2xvc3VyZSBDb21waWxlciBhbGxvd3Mgb25lIHRvIGxvZyBhbmRcbiAqIGluZmx1ZW5jZSB0aGlzIHByb2Nlc3MuIEluIGNvbnRyYXN0LCB0aGlzIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IGludHJvZHVjZVxuICogYW55IHZhcmlhYmxlIGRlY2xhcmF0aW9ucyBpbiBnbG9iYWwgY29kZSBhbmQgZGVyaXZlcyBTdHJpbmcgdmFsdWVzIGZyb21cbiAqIGlkZW50aWZpZXIgbmFtZXMgdXNlZCBhcyBwcm9wZXJ0eSBhY2Nlc3NvcnMuPC9wPlxuICogPHA+Q29uc29saWRhdGluZyBsaXRlcmFscyBtYXkgd29yc2VuIHRoZSBkYXRhIGNvbXByZXNzaW9uIHJhdGlvIHdoZW4gYW4gPGFcbiAqIGhyZWY9XCJodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyNjE2I3NlY3Rpb24tMy41XCI+ZW5jb2RpbmdcbiAqIHRyYW5zZm9ybWF0aW9uPC9hPiBpcyBhcHBsaWVkLiBGb3IgaW5zdGFuY2UsIDxhIGhyZWY9XG4gKiBcImh0dHA6Ly9jb2RlLmpxdWVyeS5jb20vanF1ZXJ5LTEuNy4xLmpzXCI+alF1ZXJ5IDEuNy4xPC9hPiB0YWtlcyAyNDgyMzUgYnl0ZXMuXG4gKiBCdWlsZGluZyBpdCB3aXRoIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTL3RhcmJhbGwvdjEuMi41XCI+XG4gKiBVZ2xpZnlKUyB2MS4yLjU8L2E+IHJlc3VsdHMgaW4gOTM2NDcgYnl0ZXMgKDM3LjczJSBvZiB0aGUgb3JpZ2luYWwpIHdoaWNoIGFyZVxuICogdGhlbiBjb21wcmVzc2VkIHRvIDMzMTU0IGJ5dGVzICgxMy4zNiUgb2YgdGhlIG9yaWdpbmFsKSB1c2luZyA8YSBocmVmPVxuICogXCJodHRwOi8vbGludXguZGllLm5ldC9tYW4vMS9nemlwXCI+Z3ppcCgxKTwvYT4uIEJ1aWxkaW5nIGl0IHdpdGggdGhlIHNhbWVcbiAqIHZlcnNpb24gb2YgVWdsaWZ5SlMgMS4yLjUgcGF0Y2hlZCB3aXRoIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBjb25zb2xpZGF0aW9uXG4gKiByZXN1bHRzIGluIDgwNzg0IGJ5dGVzIChhIGRlY3JlYXNlIG9mIDEyODYzIGJ5dGVzLCBpLmUuIDEzLjc0JSwgaW4gY29tcGFyaXNvblxuICogdG8gdGhlIGFmb3JlbWVudGlvbmVkIDkzNjQ3IGJ5dGVzKSB3aGljaCBhcmUgdGhlbiBjb21wcmVzc2VkIHRvIDM0MDEzIGJ5dGVzXG4gKiAoYW4gaW5jcmVhc2Ugb2YgODU5IGJ5dGVzLCBpLmUuIDIuNTklLCBpbiBjb21wYXJpc29uIHRvIHRoZSBhZm9yZW1lbnRpb25lZFxuICogMzMxNTQgYnl0ZXMpLjwvcD5cbiAqIDxwPldyaXR0ZW4gaW4gPGEgaHJlZj1cImh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDQuMi4yXCI+dGhlIHN0cmljdCB2YXJpYW50PC9hPlxuICogb2YgPGEgaHJlZj1cImh0dHA6Ly9lczUuZ2l0aHViLmNvbS9cIj5FQ01BLTI2MiA1LjEgRWRpdGlvbjwvYT4uIEVuY29kZWQgaW4gPGFcbiAqIGhyZWY9XCJodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNjI5XCI+VVRGLTg8L2E+LiBGb2xsb3dzIDxhIGhyZWY9XG4gKiBcImh0dHA6Ly9nb29nbGUtc3R5bGVndWlkZS5nb29nbGVjb2RlLmNvbS9zdm4taGlzdG9yeS9yNzYvdHJ1bmsvamF2YXNjcmlwdGd1aWRlLnhtbFwiXG4gKiA+UmV2aXNpb24gMi4yOCBvZiB0aGUgR29vZ2xlIEphdmFTY3JpcHQgU3R5bGUgR3VpZGU8L2E+IChleGNlcHQgZm9yIHRoZVxuICogZGlzY291cmFnZWQgdXNlIG9mIHRoZSB7QGNvZGUgZnVuY3Rpb259IHRhZyBhbmQgdGhlIHtAY29kZSBuYW1lc3BhY2V9IHRhZykuXG4gKiAxMDAlIHR5cGVkIGZvciB0aGUgPGEgaHJlZj1cbiAqIFwiaHR0cDovL2Nsb3N1cmUtY29tcGlsZXIuZ29vZ2xlY29kZS5jb20vZmlsZXMvY29tcGlsZXItMjAxMjAxMjMudGFyLmd6XCJcbiAqID5DbG9zdXJlIENvbXBpbGVyIFZlcnNpb24gMTc0MTwvYT4uPC9wPlxuICogPHA+U2hvdWxkIHlvdSBmaW5kIHRoaXMgc29mdHdhcmUgdXNlZnVsLCBwbGVhc2UgY29uc2lkZXIgPGEgaHJlZj1cbiAqIFwiaHR0cHM6Ly9wYXlwYWwuY29tL2NnaS1iaW4vd2Vic2NyP2NtZD1fcy14Y2xpY2smaG9zdGVkX2J1dHRvbl9pZD1KWkxXNzJYOEZENFdHXCJcbiAqID5hIGRvbmF0aW9uPC9hPi48L3A+XG4gKiBAYXV0aG9yIGZvbGxvdy5tZUBSR3VzdEJhcmRvbiAoUm9iZXJ0IEd1c3QtQmFyZG9uKVxuICogQHN1cHBvcnRlZCBUZXN0ZWQgd2l0aDpcbiAqICAgICA8dWw+XG4gKiAgICAgPGxpPjxhIGhyZWY9XCJodHRwOi8vbm9kZWpzLm9yZy9kaXN0L3YwLjYuMTAvXCI+Tm9kZSB2MC42LjEwPC9hPiw8L2xpPlxuICogICAgIDxsaT48YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUy90YXJiYWxsL3YxLjIuNVwiPlVnbGlmeUpTXG4gKiAgICAgICB2MS4yLjU8L2E+LjwvbGk+XG4gKiAgICAgPC91bD5cbiAqL1xuXG4vKmdsb2JhbCBjb25zb2xlOmZhbHNlLCBleHBvcnRzOnRydWUsIG1vZHVsZTpmYWxzZSwgcmVxdWlyZTpmYWxzZSAqL1xuLypqc2hpbnQgc3ViOnRydWUgKi9cbi8qKlxuICogQ29uc29saWRhdGVzIG51bGwsIEJvb2xlYW4sIGFuZCBTdHJpbmcgdmFsdWVzIGZvdW5kIGluc2lkZSBhbiA8YWJiciB0aXRsZT1cbiAqIFwiYWJzdHJhY3Qgc3ludGF4IHRyZWVcIj5BU1Q8L2FiYnI+LlxuICogQHBhcmFtIHshVFN5bnRhY3RpY0NvZGVVbml0fSBvQWJzdHJhY3RTeW50YXhUcmVlIEFuIGFycmF5LWxpa2Ugb2JqZWN0XG4gKiAgICAgcmVwcmVzZW50aW5nIGFuIDxhYmJyIHRpdGxlPVwiYWJzdHJhY3Qgc3ludGF4IHRyZWVcIj5BU1Q8L2FiYnI+LlxuICogQHJldHVybiB7IVRTeW50YWN0aWNDb2RlVW5pdH0gQW4gYXJyYXktbGlrZSBvYmplY3QgcmVwcmVzZW50aW5nIGFuIDxhYmJyXG4gKiAgICAgdGl0bGU9XCJhYnN0cmFjdCBzeW50YXggdHJlZVwiPkFTVDwvYWJicj4gd2l0aCBpdHMgbnVsbCwgQm9vbGVhbiwgYW5kXG4gKiAgICAgU3RyaW5nIHZhbHVlcyBjb25zb2xpZGF0ZWQuXG4gKi9cbi8vIFRPRE8odXNlcikgQ29uc29saWRhdGlvbiBvZiBtYXRoZW1hdGljYWwgdmFsdWVzIGZvdW5kIGluIG51bWVyaWMgbGl0ZXJhbHMuXG4vLyBUT0RPKHVzZXIpIFVuY29uc29saWRhdGlvbi5cbi8vIFRPRE8odXNlcikgQ29uc29saWRhdGlvbiBvZiBFQ01BLTI2MiA2dGggRWRpdGlvbiBwcm9ncmFtcy5cbi8vIFRPRE8odXNlcikgUmV3cml0ZSBpbiBFQ01BLTI2MiA2dGggRWRpdGlvbi5cbmV4cG9ydHNbJ2FzdF9jb25zb2xpZGF0ZSddID0gZnVuY3Rpb24ob0Fic3RyYWN0U3ludGF4VHJlZSkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qanNoaW50IGJpdHdpc2U6dHJ1ZSwgY3VybHk6dHJ1ZSwgZXFlcWVxOnRydWUsIGZvcmluOnRydWUsIGltbWVkOnRydWUsXG4gICAgICAgIGxhdGVkZWY6dHJ1ZSwgbmV3Y2FwOnRydWUsIG5vYXJnZTp0cnVlLCBub2VtcHR5OnRydWUsIG5vbmV3OnRydWUsXG4gICAgICAgIG9uZXZhcjp0cnVlLCBwbHVzcGx1czp0cnVlLCByZWdleHA6dHJ1ZSwgdW5kZWY6dHJ1ZSwgc3RyaWN0OnRydWUsXG4gICAgICAgIHN1YjpmYWxzZSwgdHJhaWxpbmc6dHJ1ZSAqL1xuXG4gIHZhciBfLFxuICAgICAgLyoqXG4gICAgICAgKiBBIHJlY29yZCBjb25zaXN0aW5nIG9mIGRhdGEgYWJvdXQgb25lIG9yIG1vcmUgc291cmNlIGVsZW1lbnRzLlxuICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgKiBAbm9zaWRlZWZmZWN0c1xuICAgICAgICovXG4gICAgICBUU291cmNlRWxlbWVudHNEYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2F0ZWdvcnkgb2YgdGhlIGVsZW1lbnRzLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAc2VlIEVTb3VyY2VFbGVtZW50Q2F0ZWdvcmllc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uQ2F0ZWdvcnkgPSBFU291cmNlRWxlbWVudENhdGVnb3JpZXMuTl9PVEhFUjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgKHdpdGhpbiB0aGUgZWxlbWVudHMpIG9mIGVhY2ggcHJpbWl0aXZlXG4gICAgICAgICAqIHZhbHVlIHRoYXQgY291bGQgYmUgY29uc29saWRhdGVkLlxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5LjwhT2JqZWN0LjxzdHJpbmcsIG51bWJlcj4+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hQ291bnQgPSBbXTtcbiAgICAgICAgdGhpcy5hQ291bnRbRVByaW1hcnlFeHByZXNzaW9uQ2F0ZWdvcmllcy5OX0lERU5USUZJRVJfTkFNRVNdID0ge307XG4gICAgICAgIHRoaXMuYUNvdW50W0VQcmltYXJ5RXhwcmVzc2lvbkNhdGVnb3JpZXMuTl9TVFJJTkdfTElURVJBTFNdID0ge307XG4gICAgICAgIHRoaXMuYUNvdW50W0VQcmltYXJ5RXhwcmVzc2lvbkNhdGVnb3JpZXMuTl9OVUxMX0FORF9CT09MRUFOX0xJVEVSQUxTXSA9XG4gICAgICAgICAgICB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElkZW50aWZpZXIgbmFtZXMgZm91bmQgd2l0aGluIHRoZSBlbGVtZW50cy5cbiAgICAgICAgICogQHR5cGUgeyFBcnJheS48c3RyaW5nPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYUlkZW50aWZpZXJzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmVmaXhlZCByZXByZXNlbnRhdGlvbiBTdHJpbmdzIG9mIGVhY2ggcHJpbWl0aXZlIHZhbHVlIHRoYXQgY291bGQgYmVcbiAgICAgICAgICogY29uc29saWRhdGVkIHdpdGhpbiB0aGUgZWxlbWVudHMuXG4gICAgICAgICAqIEB0eXBlIHshQXJyYXkuPHN0cmluZz59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFQcmltaXRpdmVWYWx1ZXMgPSBbXTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEEgcmVjb3JkIGNvbnNpc3Rpbmcgb2YgZGF0YSBhYm91dCBhIHByaW1pdGl2ZSB2YWx1ZSB0aGF0IGNvdWxkIGJlXG4gICAgICAgKiBjb25zb2xpZGF0ZWQuXG4gICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAqIEBub3NpZGVlZmZlY3RzXG4gICAgICAgKi9cbiAgICAgIFRQcmltaXRpdmVWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpZmZlcmVuY2UgaW4gdGhlIG51bWJlciBvZiB0ZXJtaW5hbCBzeW1ib2xzIGJldHdlZW4gdGhlIG9yaWdpbmFsXG4gICAgICAgICAqIHNvdXJjZSB0ZXh0IGFuZCB0aGUgb25lIHdpdGggdGhlIHByaW1pdGl2ZSB2YWx1ZSBjb25zb2xpZGF0ZWQuIElmIHRoZVxuICAgICAgICAgKiBkaWZmZXJlbmNlIGlzIHBvc2l0aXZlLCB0aGUgcHJpbWl0aXZlIHZhbHVlIGlzIGNvbnNpZGVyZWQgd29ydGh3aGlsZS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMublNhdmluZyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBpZGVudGlmaWVyIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRoYXQgd2lsbCBiZSBkZWNsYXJlZCBhbmQgYXNzaWduZWRcbiAgICAgICAgICogdGhlIHByaW1pdGl2ZSB2YWx1ZSBpZiB0aGUgcHJpbWl0aXZlIHZhbHVlIGlzIGNvbnNvbGlkYXRlZC5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc05hbWUgPSAnJztcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEEgcmVjb3JkIGNvbnNpc3Rpbmcgb2YgZGF0YSBvbiB3aGF0IHRvIGNvbnNvbGlkYXRlIHdpdGhpbiB0aGUgcmFuZ2Ugb2ZcbiAgICAgICAqIHNvdXJjZSBlbGVtZW50cyB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBjb25zaWRlcmVkLlxuICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgKiBAbm9zaWRlZWZmZWN0c1xuICAgICAgICovXG4gICAgICBUU29sdXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9iamVjdCB3aG9zZSBrZXlzIGFyZSBwcmVmaXhlZCByZXByZXNlbnRhdGlvbiBTdHJpbmdzIG9mIGVhY2hcbiAgICAgICAgICogcHJpbWl0aXZlIHZhbHVlIHRoYXQgY291bGQgYmUgY29uc29saWRhdGVkIHdpdGhpbiB0aGUgZWxlbWVudHMgYW5kXG4gICAgICAgICAqIHdob3NlIHZhbHVlcyBhcmUgY29ycmVzcG9uZGluZyBkYXRhIGFib3V0IHRob3NlIHByaW1pdGl2ZSB2YWx1ZXMuXG4gICAgICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIHtuU2F2aW5nOiBudW1iZXIsIHNOYW1lOiBzdHJpbmd9Pn1cbiAgICAgICAgICogQHNlZSBUUHJpbWl0aXZlVmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub1ByaW1pdGl2ZVZhbHVlcyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpZmZlcmVuY2UgaW4gdGhlIG51bWJlciBvZiB0ZXJtaW5hbCBzeW1ib2xzIGJldHdlZW4gdGhlIG9yaWdpbmFsXG4gICAgICAgICAqIHNvdXJjZSB0ZXh0IGFuZCB0aGUgb25lIHdpdGggYWxsIHRoZSB3b3J0aHdoaWxlIHByaW1pdGl2ZSB2YWx1ZXNcbiAgICAgICAgICogY29uc29saWRhdGVkLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAc2VlIFRQcmltaXRpdmVWYWx1ZSNuU2F2aW5nXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5TYXZpbmdzID0gMDtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBwcm9jZXNzb3Igb2YgPGFiYnIgdGl0bGU9XCJhYnN0cmFjdCBzeW50YXggdHJlZVwiPkFTVDwvYWJicj5zIGZvdW5kXG4gICAgICAgKiBpbiBVZ2xpZnlKUy5cbiAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAqIEB0eXBlIHshVFByb2Nlc3Nvcn1cbiAgICAgICAqL1xuICAgICAgb1Byb2Nlc3NvciA9ICgvKiogQHR5cGUgeyFUUHJvY2Vzc29yfSAqLyByZXF1aXJlKCcuL3Byb2Nlc3MnKSksXG4gICAgICAvKipcbiAgICAgICAqIEEgcmVjb3JkIGNvbnNpc3Rpbmcgb2YgYSBudW1iZXIgb2YgY29uc3RhbnRzIHRoYXQgcmVwcmVzZW50IHRoZVxuICAgICAgICogZGlmZmVyZW5jZSBpbiB0aGUgbnVtYmVyIG9mIHRlcm1pbmFsIHN5bWJvbHMgYmV0d2VlbiBhIHNvdXJjZSB0ZXh0IHdpdGhcbiAgICAgICAqIGEgbW9kaWZpZWQgc3ludGFjdGljIGNvZGUgdW5pdCBhbmQgdGhlIG9yaWdpbmFsIG9uZS5cbiAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIG51bWJlcj59XG4gICAgICAgKi9cbiAgICAgIG9XZWlnaHRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpZmZlcmVuY2UgaW4gdGhlIG51bWJlciBvZiBwdW5jdHVhdG9ycyByZXF1aXJlZCBieSB0aGUgYnJhY2tldFxuICAgICAgICAgKiBub3RhdGlvbiBhbmQgdGhlIGRvdCBub3RhdGlvbi5cbiAgICAgICAgICogPHA+PGNvZGU+J1tdJy5sZW5ndGggLSAnLicubGVuZ3RoPC9jb2RlPjwvcD5cbiAgICAgICAgICogQGNvbnN0XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBOX1BST1BFUlRZX0FDQ0VTU09SOiAxLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBwdW5jdHVhdG9ycyByZXF1aXJlZCBieSBhIHZhcmlhYmxlIGRlY2xhcmF0aW9uIHdpdGggYW5cbiAgICAgICAgICogaW5pdGlhbGlzZXIuXG4gICAgICAgICAqIDxwPjxjb2RlPic6Jy5sZW5ndGggKyAnOycubGVuZ3RoPC9jb2RlPjwvcD5cbiAgICAgICAgICogQGNvbnN0XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBOX1ZBUklBQkxFX0RFQ0xBUkFUSU9OOiAyLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiB0ZXJtaW5hbCBzeW1ib2xzIHJlcXVpcmVkIHRvIGludHJvZHVjZSBhIHZhcmlhYmxlXG4gICAgICAgICAqIHN0YXRlbWVudCAoZXhjbHVkaW5nIGl0cyB2YXJpYWJsZSBkZWNsYXJhdGlvbiBsaXN0KS5cbiAgICAgICAgICogPHA+PGNvZGU+J3ZhciAnLmxlbmd0aDwvY29kZT48L3A+XG4gICAgICAgICAqIEBjb25zdFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgTl9WQVJJQUJMRV9TVEFURU1FTlRfQUZGSVhBVElPTjogNCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgdGVybWluYWwgc3ltYm9scyBuZWVkZWQgdG8gZW5jbG9zZSBzb3VyY2UgZWxlbWVudHNcbiAgICAgICAgICogd2l0aGluIGEgZnVuY3Rpb24gY2FsbCB3aXRoIG5vIGFyZ3VtZW50IHZhbHVlcyB0byBhIGZ1bmN0aW9uIHdpdGggYW5cbiAgICAgICAgICogZW1wdHkgcGFyYW1ldGVyIGxpc3QuXG4gICAgICAgICAqIDxwPjxjb2RlPicoZnVuY3Rpb24oKXt9KCkpOycubGVuZ3RoPC9jb2RlPjwvcD5cbiAgICAgICAgICogQGNvbnN0XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBOX0NMT1NVUkU6IDE3XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBDYXRlZ29yaWVzIG9mIHByaW1hcnkgZXhwcmVzc2lvbnMgZnJvbSB3aGljaCBwcmltaXRpdmUgdmFsdWVzIHRoYXRcbiAgICAgICAqIGNvdWxkIGJlIGNvbnNvbGlkYXRlZCBhcmUgZGVyaXZhYmxlLlxuICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICogQGVudW0ge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgRVByaW1hcnlFeHByZXNzaW9uQ2F0ZWdvcmllcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElkZW50aWZpZXIgbmFtZXMgdXNlZCBhcyBwcm9wZXJ0eSBhY2Nlc3NvcnMuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBOX0lERU5USUZJRVJfTkFNRVM6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdHJpbmcgbGl0ZXJhbHMuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBOX1NUUklOR19MSVRFUkFMUzogMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bGwgYW5kIEJvb2xlYW4gbGl0ZXJhbHMuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBOX05VTExfQU5EX0JPT0xFQU5fTElURVJBTFM6IDJcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFByZWZpeGVzIG9mIHByaW1pdGl2ZSB2YWx1ZXMgdGhhdCBjb3VsZCBiZSBjb25zb2xpZGF0ZWQuXG4gICAgICAgKiBUaGUgU3RyaW5nIHZhbHVlcyBvZiB0aGUgcHJlZml4ZXMgbXVzdCBoYXZlIHNhbWUgbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG4gICAgICAgKiBUaGUgcHJlZml4ZXMgbXVzdCBub3QgYmUgdXNlZCBpbiBhbnkgcHJvcGVydGllcyBkZWZpbmVkIGluIGFueSB2ZXJzaW9uXG4gICAgICAgKiBvZiA8YSBocmVmPVxuICAgICAgICogXCJodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvcHVibGljYXRpb25zL3N0YW5kYXJkcy9FY21hLTI2Mi5odG1cIlxuICAgICAgICogPkVDTUEtMjYyPC9hPi5cbiAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAqIEBlbnVtIHtzdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIEVWYWx1ZVByZWZpeGVzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWRlbnRpZmllcyBTdHJpbmcgdmFsdWVzLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgU19TVFJJTkc6ICcjUycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVudGlmaWVzIG51bGwgYW5kIEJvb2xlYW4gdmFsdWVzLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgU19TWU1CT0xJQzogJyNPJ1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogQ2F0ZWdvcmllcyBvZiBzb3VyY2UgZWxlbWVudHMgaW4gdGVybXMgb2YgdGhlaXIgYXBwcm9wcmlhdGVuZXNzIG9mXG4gICAgICAgKiBoYXZpbmcgdGhlaXIgcHJpbWl0aXZlIHZhbHVlcyBjb25zb2xpZGF0ZWQuXG4gICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgKiBAZW51bSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICBFU291cmNlRWxlbWVudENhdGVnb3JpZXMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVudGlmaWVzIGEgc291cmNlIGVsZW1lbnQgdGhhdCBpbmNsdWRlcyB0aGUgPGEgaHJlZj1cbiAgICAgICAgICogXCJodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxMi4xMFwiPntAY29kZSB3aXRofTwvYT4gc3RhdGVtZW50LlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgTl9XSVRIOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogSWRlbnRpZmllcyBhIHNvdXJjZSBlbGVtZW50IHRoYXQgaW5jbHVkZXMgdGhlIDxhIGhyZWY9XG4gICAgICAgICAqIFwiaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMS4yLjFcIj57QGNvZGUgZXZhbH08L2E+IGlkZW50aWZpZXIgbmFtZS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIE5fRVZBTDogMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElkZW50aWZpZXMgYSBzb3VyY2UgZWxlbWVudCB0aGF0IG11c3QgYmUgZXhjbHVkZWQgZnJvbSB0aGUgcHJvY2Vzc1xuICAgICAgICAgKiB1bmxlc3MgaXRzIHdob2xlIHNjb3BlIGlzIGV4YW1pbmVkLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgTl9FWENMVURBQkxFOiAyLFxuICAgICAgICAvKipcbiAgICAgICAgICogSWRlbnRpZmllcyBzb3VyY2UgZWxlbWVudHMgbm90IHBvc2luZyBhbnkgcHJvYmxlbXMuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBOX09USEVSOiAzXG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbGlzdCBvZiBsaXRlcmFscyAob3RoZXIgdGhhbiB0aGUgU3RyaW5nIG9uZXMpIHdob3NlIHByaW1pdGl2ZVxuICAgICAgICogdmFsdWVzIGNhbiBiZSBjb25zb2xpZGF0ZWQuXG4gICAgICAgKiBAY29uc3RcbiAgICAgICAqIEB0eXBlIHshQXJyYXkuPHN0cmluZz59XG4gICAgICAgKi9cbiAgICAgIEFfT1RIRVJfU1VCU1RJVFVUQUJMRV9MSVRFUkFMUyA9IFtcbiAgICAgICAgJ251bGwnLCAgIC8vIFRoZSBudWxsIGxpdGVyYWwuXG4gICAgICAgICdmYWxzZScsICAvLyBUaGUgQm9vbGVhbiBsaXRlcmFsIHtAY29kZSBmYWxzZX0uXG4gICAgICAgICd0cnVlJyAgICAvLyBUaGUgQm9vbGVhbiBsaXRlcmFsIHtAY29kZSB0cnVlfS5cbiAgICAgIF07XG5cbiAgKC8qKlxuICAgICogQ29uc29saWRhdGVzIGFsbCB3b3J0aHdoaWxlIHByaW1pdGl2ZSB2YWx1ZXMgaW4gYSBzeW50YWN0aWMgY29kZSB1bml0LlxuICAgICogQHBhcmFtIHshVFN5bnRhY3RpY0NvZGVVbml0fSBvU3ludGFjdGljQ29kZVVuaXQgQW4gYXJyYXktbGlrZSBvYmplY3RcbiAgICAqICAgICByZXByZXNlbnRpbmcgdGhlIGJyYW5jaCBvZiB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgcmVwcmVzZW50aW5nIHRoZVxuICAgICogICAgIHN5bnRhY3RpYyBjb2RlIHVuaXQgYWxvbmcgd2l0aCBpdHMgc2NvcGUuXG4gICAgKiBAc2VlIFRQcmltaXRpdmVWYWx1ZSNuU2F2aW5nXG4gICAgKi9cbiAgIGZ1bmN0aW9uIGZFeGFtaW5lU3ludGFjdGljQ29kZVVuaXQob1N5bnRhY3RpY0NvZGVVbml0KSB7XG4gICAgIHZhciBfLFxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3ludGFjdGljIGNvZGUgdW5pdCByZXByZXNlbnRzIGdsb2JhbCBjb2RlLlxuICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAgKi9cbiAgICAgICAgIGJJc0dsb2JhbCA9ICd0b3BsZXZlbCcgPT09IG9TeW50YWN0aWNDb2RlVW5pdFswXSxcbiAgICAgICAgIC8qKlxuICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHdob2xlIHNjb3BlIGlzIGJlaW5nIGV4YW1pbmVkLlxuICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAgKi9cbiAgICAgICAgIGJJc1dob2xseUV4YW1pbmFibGUgPSAhYklzR2xvYmFsLFxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBBbiBhcnJheS1saWtlIG9iamVjdCByZXByZXNlbnRpbmcgc291cmNlIGVsZW1lbnRzIHRoYXQgY29uc3RpdHV0ZSBhXG4gICAgICAgICAgKiBzeW50YWN0aWMgY29kZSB1bml0LlxuICAgICAgICAgICogQHR5cGUgeyFUU3ludGFjdGljQ29kZVVuaXR9XG4gICAgICAgICAgKi9cbiAgICAgICAgIG9Tb3VyY2VFbGVtZW50cyxcbiAgICAgICAgIC8qKlxuICAgICAgICAgICogQSByZWNvcmQgY29uc2lzdGluZyBvZiBkYXRhIGFib3V0IHRoZSBzb3VyY2UgZWxlbWVudCB0aGF0IGlzXG4gICAgICAgICAgKiBjdXJyZW50bHkgYmVpbmcgZXhhbWluZWQuXG4gICAgICAgICAgKiBAdHlwZSB7IVRTb3VyY2VFbGVtZW50c0RhdGF9XG4gICAgICAgICAgKi9cbiAgICAgICAgIG9Tb3VyY2VFbGVtZW50RGF0YSxcbiAgICAgICAgIC8qKlxuICAgICAgICAgICogVGhlIHNjb3BlIG9mIHRoZSBzeW50YWN0aWMgY29kZSB1bml0LlxuICAgICAgICAgICogQHR5cGUgeyFUU2NvcGV9XG4gICAgICAgICAgKi9cbiAgICAgICAgIG9TY29wZSxcbiAgICAgICAgIC8qKlxuICAgICAgICAgICogQW4gaW5zdGFuY2Ugb2YgYW4gb2JqZWN0IHRoYXQgYWxsb3dzIHRoZSB0cmF2ZXJzYWwgb2YgYW4gPGFiYnJcbiAgICAgICAgICAqIHRpdGxlPVwiYWJzdHJhY3Qgc3ludGF4IHRyZWVcIj5BU1Q8L2FiYnI+LlxuICAgICAgICAgICogQHR5cGUgeyFUV2Fsa2VyfVxuICAgICAgICAgICovXG4gICAgICAgICBvV2Fsa2VyLFxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBBbiBvYmplY3QgZW5jb21wYXNzaW5nIGNvbGxlY3Rpb25zIG9mIGZ1bmN0aW9ucyB1c2VkIGR1cmluZyB0aGVcbiAgICAgICAgICAqIHRyYXZlcnNhbCBvZiBhbiA8YWJiciB0aXRsZT1cImFic3RyYWN0IHN5bnRheCB0cmVlXCI+QVNUPC9hYmJyPi5cbiAgICAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsICFPYmplY3QuPHN0cmluZywgZnVuY3Rpb24oLi4uWypdKT4+fVxuICAgICAgICAgICovXG4gICAgICAgICBvV2Fsa2VycyA9IHtcbiAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAqIEEgY29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgdXNlZCBkdXJpbmcgdGhlIHN1cnZleWFuY2Ugb2Ygc291cmNlXG4gICAgICAgICAgICAqIGVsZW1lbnRzLlxuICAgICAgICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uKC4uLlsqXSk+fVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgb1N1cnZleVNvdXJjZUVsZW1lbnQ6IHtcbiAgICAgICAgICAgICAvKiojbm9jb2RlKyovICAvLyBKc0RvYyBUb29sa2l0IDIuNC4wIGhpZGVzIHNvbWUgb2YgdGhlIGtleXMuXG4gICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICogQ2xhc3NpZmllcyB0aGUgc291cmNlIGVsZW1lbnQgYXMgZXhjbHVkYWJsZSBpZiBpdCBkb2VzIG5vdFxuICAgICAgICAgICAgICAqIGNvbnRhaW4gYSB7QGNvZGUgd2l0aH0gc3RhdGVtZW50IG9yIHRoZSB7QGNvZGUgZXZhbH0gaWRlbnRpZmllclxuICAgICAgICAgICAgICAqIG5hbWUuIEFkZHMgdGhlIGlkZW50aWZpZXIgb2YgdGhlIGZ1bmN0aW9uIGFuZCBpdHMgZm9ybWFsXG4gICAgICAgICAgICAgICogcGFyYW1ldGVycyB0byB0aGUgbGlzdCBvZiBpZGVudGlmaWVyIG5hbWVzIGZvdW5kLlxuICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzSWRlbnRpZmllciBUaGUgaWRlbnRpZmllciBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICogQHBhcmFtIHshQXJyYXkuPHN0cmluZz59IGFGb3JtYWxQYXJhbWV0ZXJMaXN0IEZvcm1hbCBwYXJhbWV0ZXJzLlxuICAgICAgICAgICAgICAqIEBwYXJhbSB7IVRTeW50YWN0aWNDb2RlVW5pdH0gb0Z1bmN0aW9uQm9keSBGdW5jdGlvbiBjb2RlLlxuICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICdkZWZ1bic6IGZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICBzSWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgYUZvcm1hbFBhcmFtZXRlckxpc3QsXG4gICAgICAgICAgICAgICAgIG9GdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgICAgICAgIGZDbGFzc2lmeUFzRXhjbHVkYWJsZSgpO1xuICAgICAgICAgICAgICAgZkFkZElkZW50aWZpZXIoc0lkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgYUZvcm1hbFBhcmFtZXRlckxpc3QuZm9yRWFjaChmQWRkSWRlbnRpZmllcik7XG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgKiBJbmNyZW1lbnRzIHRoZSBjb3VudCBvZiB0aGUgbnVtYmVyIG9mIG9jY3VycmVuY2VzIG9mIHRoZSBTdHJpbmdcbiAgICAgICAgICAgICAgKiB2YWx1ZSB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gdGhlIHNlcXVlbmNlIG9mIHRlcm1pbmFsIHN5bWJvbHNcbiAgICAgICAgICAgICAgKiB0aGF0IGNvbnN0aXR1dGUgdGhlIGVuY291bnRlcmVkIGlkZW50aWZpZXIgbmFtZS5cbiAgICAgICAgICAgICAgKiBAcGFyYW0geyFUU3ludGFjdGljQ29kZVVuaXR9IG9FeHByZXNzaW9uIFRoZSBub250ZXJtaW5hbFxuICAgICAgICAgICAgICAqICAgICBNZW1iZXJFeHByZXNzaW9uLlxuICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzSWRlbnRpZmllck5hbWUgVGhlIGlkZW50aWZpZXIgbmFtZSB1c2VkIGFzIHRoZVxuICAgICAgICAgICAgICAqICAgICBwcm9wZXJ0eSBhY2Nlc3Nvci5cbiAgICAgICAgICAgICAgKiBAcmV0dXJuIHshQXJyYXl9IFRoZSBlbmNvdW50ZXJlZCBicmFuY2ggb2YgYW4gPGFiYnIgdGl0bGU9XG4gICAgICAgICAgICAgICogICAgIFwiYWJzdHJhY3Qgc3ludGF4IHRyZWVcIj5BU1Q8L2FiYnI+IHdpdGggaXRzIG5vbnRlcm1pbmFsXG4gICAgICAgICAgICAgICogICAgIE1lbWJlckV4cHJlc3Npb24gdHJhdmVyc2VkLlxuICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICdkb3QnOiBmdW5jdGlvbihvRXhwcmVzc2lvbiwgc0lkZW50aWZpZXJOYW1lKSB7XG4gICAgICAgICAgICAgICBmQ291bnRQcmltYXJ5RXhwcmVzc2lvbihcbiAgICAgICAgICAgICAgICAgICBFUHJpbWFyeUV4cHJlc3Npb25DYXRlZ29yaWVzLk5fSURFTlRJRklFUl9OQU1FUyxcbiAgICAgICAgICAgICAgICAgICBFVmFsdWVQcmVmaXhlcy5TX1NUUklORyArIHNJZGVudGlmaWVyTmFtZSk7XG4gICAgICAgICAgICAgICByZXR1cm4gWydkb3QnLCBvV2Fsa2VyLndhbGsob0V4cHJlc3Npb24pLCBzSWRlbnRpZmllck5hbWVdO1xuICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICogQWRkcyB0aGUgb3B0aW9uYWwgaWRlbnRpZmllciBvZiB0aGUgZnVuY3Rpb24gYW5kIGl0cyBmb3JtYWxcbiAgICAgICAgICAgICAgKiBwYXJhbWV0ZXJzIHRvIHRoZSBsaXN0IG9mIGlkZW50aWZpZXIgbmFtZXMgZm91bmQuXG4gICAgICAgICAgICAgICogQHBhcmFtIHs/c3RyaW5nfSBzSWRlbnRpZmllciBUaGUgb3B0aW9uYWwgaWRlbnRpZmllciBvZiB0aGVcbiAgICAgICAgICAgICAgKiAgICAgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICogQHBhcmFtIHshQXJyYXkuPHN0cmluZz59IGFGb3JtYWxQYXJhbWV0ZXJMaXN0IEZvcm1hbCBwYXJhbWV0ZXJzLlxuICAgICAgICAgICAgICAqIEBwYXJhbSB7IVRTeW50YWN0aWNDb2RlVW5pdH0gb0Z1bmN0aW9uQm9keSBGdW5jdGlvbiBjb2RlLlxuICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICdmdW5jdGlvbic6IGZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICBzSWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgYUZvcm1hbFBhcmFtZXRlckxpc3QsXG4gICAgICAgICAgICAgICAgIG9GdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHNJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgIGZBZGRJZGVudGlmaWVyKHNJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGFGb3JtYWxQYXJhbWV0ZXJMaXN0LmZvckVhY2goZkFkZElkZW50aWZpZXIpO1xuICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICogRWl0aGVyIGluY3JlbWVudHMgdGhlIGNvdW50IG9mIHRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgb2YgdGhlXG4gICAgICAgICAgICAgICogZW5jb3VudGVyZWQgbnVsbCBvciBCb29sZWFuIHZhbHVlIG9yIGNsYXNzaWZpZXMgYSBzb3VyY2UgZWxlbWVudFxuICAgICAgICAgICAgICAqIGFzIGNvbnRhaW5pbmcgdGhlIHtAY29kZSBldmFsfSBpZGVudGlmaWVyIG5hbWUuXG4gICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNJZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICduYW1lJzogZnVuY3Rpb24oc0lkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgIGlmICgtMSAhPT0gQV9PVEhFUl9TVUJTVElUVVRBQkxFX0xJVEVSQUxTLmluZGV4T2Yoc0lkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICAgICAgIGZDb3VudFByaW1hcnlFeHByZXNzaW9uKFxuICAgICAgICAgICAgICAgICAgICAgRVByaW1hcnlFeHByZXNzaW9uQ2F0ZWdvcmllcy5OX05VTExfQU5EX0JPT0xFQU5fTElURVJBTFMsXG4gICAgICAgICAgICAgICAgICAgICBFVmFsdWVQcmVmaXhlcy5TX1NZTUJPTElDICsgc0lkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgaWYgKCdldmFsJyA9PT0gc0lkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICBvU291cmNlRWxlbWVudERhdGEubkNhdGVnb3J5ID1cbiAgICAgICAgICAgICAgICAgICAgICAgRVNvdXJjZUVsZW1lbnRDYXRlZ29yaWVzLk5fRVZBTDtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICBmQWRkSWRlbnRpZmllcihzSWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgKiBDbGFzc2lmaWVzIHRoZSBzb3VyY2UgZWxlbWVudCBhcyBleGNsdWRhYmxlIGlmIGl0IGRvZXMgbm90XG4gICAgICAgICAgICAgICogY29udGFpbiBhIHtAY29kZSB3aXRofSBzdGF0ZW1lbnQgb3IgdGhlIHtAY29kZSBldmFsfSBpZGVudGlmaWVyXG4gICAgICAgICAgICAgICogbmFtZS5cbiAgICAgICAgICAgICAgKiBAcGFyYW0ge1RTeW50YWN0aWNDb2RlVW5pdH0gb0V4cHJlc3Npb24gVGhlIGV4cHJlc3Npb24gd2hvc2VcbiAgICAgICAgICAgICAgKiAgICAgdmFsdWUgaXMgdG8gYmUgcmV0dXJuZWQuXG4gICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgJ3JldHVybic6IGZ1bmN0aW9uKG9FeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICBmQ2xhc3NpZnlBc0V4Y2x1ZGFibGUoKTtcbiAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAqIEluY3JlbWVudHMgdGhlIGNvdW50IG9mIHRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgb2YgdGhlXG4gICAgICAgICAgICAgICogZW5jb3VudGVyZWQgU3RyaW5nIHZhbHVlLlxuICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzU3RyaW5nVmFsdWUgVGhlIFN0cmluZyB2YWx1ZSBvZiB0aGUgc3RyaW5nXG4gICAgICAgICAgICAgICogICAgIGxpdGVyYWwgZW5jb3VudGVyZWQuXG4gICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgJ3N0cmluZyc6IGZ1bmN0aW9uKHNTdHJpbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgaWYgKHNTdHJpbmdWYWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgIGZDb3VudFByaW1hcnlFeHByZXNzaW9uKFxuICAgICAgICAgICAgICAgICAgICAgRVByaW1hcnlFeHByZXNzaW9uQ2F0ZWdvcmllcy5OX1NUUklOR19MSVRFUkFMUyxcbiAgICAgICAgICAgICAgICAgICAgIEVWYWx1ZVByZWZpeGVzLlNfU1RSSU5HICsgc1N0cmluZ1ZhbHVlKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAqIEFkZHMgdGhlIGlkZW50aWZpZXIgcmVzZXJ2ZWQgZm9yIGFuIGV4Y2VwdGlvbiB0byB0aGUgbGlzdCBvZlxuICAgICAgICAgICAgICAqIGlkZW50aWZpZXIgbmFtZXMgZm91bmQuXG4gICAgICAgICAgICAgICogQHBhcmFtIHshVFN5bnRhY3RpY0NvZGVVbml0fSBvVHJ5IEEgYmxvY2sgb2YgY29kZSBpbiB3aGljaCBhblxuICAgICAgICAgICAgICAqICAgICBleGNlcHRpb24gY2FuIG9jY3VyLlxuICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGFDYXRjaCBUaGUgaWRlbnRpZmllciByZXNlcnZlZCBmb3IgYW4gZXhjZXB0aW9uXG4gICAgICAgICAgICAgICogICAgIGFuZCBhIGJsb2NrIG9mIGNvZGUgdG8gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgICAgICogQHBhcmFtIHtUU3ludGFjdGljQ29kZVVuaXR9IG9GaW5hbGx5IEFuIG9wdGlvbmFsIGJsb2NrIG9mIGNvZGVcbiAgICAgICAgICAgICAgKiAgICAgdG8gYmUgZXZhbHVhdGVkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBhbiBleGNlcHRpb24gb2NjdXJzLlxuICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICd0cnknOiBmdW5jdGlvbihvVHJ5LCBhQ2F0Y2gsIG9GaW5hbGx5KSB7XG4gICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhQ2F0Y2gpKSB7XG4gICAgICAgICAgICAgICAgIGZBZGRJZGVudGlmaWVyKGFDYXRjaFswXSk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgKiBDbGFzc2lmaWVzIHRoZSBzb3VyY2UgZWxlbWVudCBhcyBleGNsdWRhYmxlIGlmIGl0IGRvZXMgbm90XG4gICAgICAgICAgICAgICogY29udGFpbiBhIHtAY29kZSB3aXRofSBzdGF0ZW1lbnQgb3IgdGhlIHtAY29kZSBldmFsfSBpZGVudGlmaWVyXG4gICAgICAgICAgICAgICogbmFtZS4gQWRkcyB0aGUgaWRlbnRpZmllciBvZiBlYWNoIGRlY2xhcmVkIHZhcmlhYmxlIHRvIHRoZSBsaXN0XG4gICAgICAgICAgICAgICogb2YgaWRlbnRpZmllciBuYW1lcyBmb3VuZC5cbiAgICAgICAgICAgICAgKiBAcGFyYW0geyFBcnJheS48IUFycmF5Pn0gYVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0IFZhcmlhYmxlXG4gICAgICAgICAgICAgICogICAgIGRlY2xhcmF0aW9ucy5cbiAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAndmFyJzogZnVuY3Rpb24oYVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KSB7XG4gICAgICAgICAgICAgICBmQ2xhc3NpZnlBc0V4Y2x1ZGFibGUoKTtcbiAgICAgICAgICAgICAgIGFWYXJpYWJsZURlY2xhcmF0aW9uTGlzdC5mb3JFYWNoKGZBZGRWYXJpYWJsZSk7XG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgKiBDbGFzc2lmaWVzIGEgc291cmNlIGVsZW1lbnQgYXMgY29udGFpbmluZyB0aGUge0Bjb2RlIHdpdGh9XG4gICAgICAgICAgICAgICogc3RhdGVtZW50LlxuICAgICAgICAgICAgICAqIEBwYXJhbSB7IVRTeW50YWN0aWNDb2RlVW5pdH0gb0V4cHJlc3Npb24gQW4gZXhwcmVzc2lvbiB3aG9zZVxuICAgICAgICAgICAgICAqICAgICB2YWx1ZSBpcyB0byBiZSBjb252ZXJ0ZWQgdG8gYSB2YWx1ZSBvZiB0eXBlIE9iamVjdCBhbmRcbiAgICAgICAgICAgICAgKiAgICAgYmVjb21lIHRoZSBiaW5kaW5nIG9iamVjdCBvZiBhIG5ldyBvYmplY3QgZW52aXJvbm1lbnRcbiAgICAgICAgICAgICAgKiAgICAgcmVjb3JkIG9mIGEgbmV3IGxleGljYWwgZW52aXJvbm1lbnQgaW4gd2hpY2ggdGhlIHN0YXRlbWVudFxuICAgICAgICAgICAgICAqICAgICBpcyB0byBiZSBleGVjdXRlZC5cbiAgICAgICAgICAgICAgKiBAcGFyYW0geyFUU3ludGFjdGljQ29kZVVuaXR9IG9TdGF0ZW1lbnQgVGhlIHN0YXRlbWVudCB0byBiZVxuICAgICAgICAgICAgICAqICAgICBleGVjdXRlZCBpbiB0aGUgYXVnbWVudGVkIGxleGljYWwgZW52aXJvbm1lbnQuXG4gICAgICAgICAgICAgICogQHJldHVybiB7IUFycmF5fSBBbiBlbXB0eSBhcnJheSB0byBzdG9wIHRoZSB0cmF2ZXJzYWwuXG4gICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgJ3dpdGgnOiBmdW5jdGlvbihvRXhwcmVzc2lvbiwgb1N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgb1NvdXJjZUVsZW1lbnREYXRhLm5DYXRlZ29yeSA9IEVTb3VyY2VFbGVtZW50Q2F0ZWdvcmllcy5OX1dJVEg7XG4gICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgIC8qKiNub2NvZGUtKi8gIC8vIEpzRG9jIFRvb2xraXQgMi40LjAgaGlkZXMgc29tZSBvZiB0aGUga2V5cy5cbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAqIEEgY29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgdXNlZCB3aGlsZSBsb29raW5nIGZvciBuZXN0ZWQgZnVuY3Rpb25zLlxuICAgICAgICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uKC4uLlsqXSk+fVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgb0V4YW1pbmVGdW5jdGlvbnM6IHtcbiAgICAgICAgICAgICAvKiojbm9jb2RlKyovICAvLyBKc0RvYyBUb29sa2l0IDIuNC4wIGhpZGVzIHNvbWUgb2YgdGhlIGtleXMuXG4gICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICogT3JkZXJzIGFuIGV4YW1pbmF0aW9uIG9mIGEgbmVzdGVkIGZ1bmN0aW9uIGRlY2xhcmF0aW9uLlxuICAgICAgICAgICAgICAqIEB0aGlzIHshVFN5bnRhY3RpY0NvZGVVbml0fSBBbiBhcnJheS1saWtlIG9iamVjdCByZXByZXNlbnRpbmdcbiAgICAgICAgICAgICAgKiAgICAgdGhlIGJyYW5jaCBvZiBhbiA8YWJiciB0aXRsZT1cImFic3RyYWN0IHN5bnRheCB0cmVlXCJcbiAgICAgICAgICAgICAgKiAgICAgPkFTVDwvYWJicj4gcmVwcmVzZW50aW5nIHRoZSBzeW50YWN0aWMgY29kZSB1bml0IGFsb25nIHdpdGhcbiAgICAgICAgICAgICAgKiAgICAgaXRzIHNjb3BlLlxuICAgICAgICAgICAgICAqIEByZXR1cm4geyFBcnJheX0gQW4gZW1wdHkgYXJyYXkgdG8gc3RvcCB0aGUgdHJhdmVyc2FsLlxuICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICdkZWZ1bic6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgZkV4YW1pbmVTeW50YWN0aWNDb2RlVW5pdCh0aGlzKTtcbiAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAqIE9yZGVycyBhbiBleGFtaW5hdGlvbiBvZiBhIG5lc3RlZCBmdW5jdGlvbiBleHByZXNzaW9uLlxuICAgICAgICAgICAgICAqIEB0aGlzIHshVFN5bnRhY3RpY0NvZGVVbml0fSBBbiBhcnJheS1saWtlIG9iamVjdCByZXByZXNlbnRpbmdcbiAgICAgICAgICAgICAgKiAgICAgdGhlIGJyYW5jaCBvZiBhbiA8YWJiciB0aXRsZT1cImFic3RyYWN0IHN5bnRheCB0cmVlXCJcbiAgICAgICAgICAgICAgKiAgICAgPkFTVDwvYWJicj4gcmVwcmVzZW50aW5nIHRoZSBzeW50YWN0aWMgY29kZSB1bml0IGFsb25nIHdpdGhcbiAgICAgICAgICAgICAgKiAgICAgaXRzIHNjb3BlLlxuICAgICAgICAgICAgICAqIEByZXR1cm4geyFBcnJheX0gQW4gZW1wdHkgYXJyYXkgdG8gc3RvcCB0aGUgdHJhdmVyc2FsLlxuICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICdmdW5jdGlvbic6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgZkV4YW1pbmVTeW50YWN0aWNDb2RlVW5pdCh0aGlzKTtcbiAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgLyoqI25vY29kZS0qLyAgLy8gSnNEb2MgVG9vbGtpdCAyLjQuMCBoaWRlcyBzb21lIG9mIHRoZSBrZXlzLlxuICAgICAgICAgICB9XG4gICAgICAgICB9LFxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBSZWNvcmRzIGNvbnRhaW5pbmcgZGF0YSBhYm91dCBzb3VyY2UgZWxlbWVudHMuXG4gICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPFRTb3VyY2VFbGVtZW50c0RhdGE+fVxuICAgICAgICAgICovXG4gICAgICAgICBhU291cmNlRWxlbWVudHNEYXRhID0gW10sXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIFRoZSBpbmRleCAoaW4gdGhlIHNvdXJjZSB0ZXh0IG9yZGVyKSBvZiB0aGUgc291cmNlIGVsZW1lbnRcbiAgICAgICAgICAqIGltbWVkaWF0ZWx5IGZvbGxvd2luZyBhIDxhIGhyZWY9XCJodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNC4xXCJcbiAgICAgICAgICAqID5EaXJlY3RpdmUgUHJvbG9ndWU8L2E+LlxuICAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICAqL1xuICAgICAgICAgbkFmdGVyRGlyZWN0aXZlUHJvbG9ndWUgPSAwLFxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBUaGUgaW5kZXggKGluIHRoZSBzb3VyY2UgdGV4dCBvcmRlcikgb2YgdGhlIHNvdXJjZSBlbGVtZW50IHRoYXQgaXNcbiAgICAgICAgICAqIGN1cnJlbnRseSBiZWluZyBjb25zaWRlcmVkLlxuICAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICAqL1xuICAgICAgICAgblBvc2l0aW9uLFxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBUaGUgaW5kZXggKGluIHRoZSBzb3VyY2UgdGV4dCBvcmRlcikgb2YgdGhlIHNvdXJjZSBlbGVtZW50IHRoYXQgaXNcbiAgICAgICAgICAqIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIHJhbmdlIG9mIHNvdXJjZSBlbGVtZW50cyB0aGF0IGlzIGN1cnJlbnRseVxuICAgICAgICAgICogYmVpbmcgY29uc2lkZXJlZC5cbiAgICAgICAgICAqIEB0eXBlIHsodW5kZWZpbmVkfG51bWJlcil9XG4gICAgICAgICAgKi9cbiAgICAgICAgIG5UbyxcbiAgICAgICAgIC8qKlxuICAgICAgICAgICogSW5pdGlhdGVzIHRoZSB0cmF2ZXJzYWwgb2YgYSBzb3VyY2UgZWxlbWVudC5cbiAgICAgICAgICAqIEBwYXJhbSB7IVRXYWxrZXJ9IG9XYWxrZXIgQW4gaW5zdGFuY2Ugb2YgYW4gb2JqZWN0IHRoYXQgYWxsb3dzIHRoZVxuICAgICAgICAgICogICAgIHRyYXZlcnNhbCBvZiBhbiBhYnN0cmFjdCBzeW50YXggdHJlZS5cbiAgICAgICAgICAqIEBwYXJhbSB7IVRTeW50YWN0aWNDb2RlVW5pdH0gb1NvdXJjZUVsZW1lbnQgQSBzb3VyY2UgZWxlbWVudCBmcm9tXG4gICAgICAgICAgKiAgICAgd2hpY2ggdGhlIHRyYXZlcnNhbCBzaG91bGQgY29tbWVuY2UuXG4gICAgICAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbigpOiAhVFN5bnRhY3RpY0NvZGVVbml0fSBBIGZ1bmN0aW9uIHRoYXQgaXMgYWJsZSB0b1xuICAgICAgICAgICogICAgIGluaXRpYXRlIHRoZSB0cmF2ZXJzYWwgZnJvbSBhIGdpdmVuIHNvdXJjZSBlbGVtZW50LlxuICAgICAgICAgICovXG4gICAgICAgICBjQ29udGV4dCA9IGZ1bmN0aW9uKG9XYWxrZXIsIG9Tb3VyY2VFbGVtZW50KSB7XG4gICAgICAgICAgIC8qKlxuICAgICAgICAgICAgKiBAcmV0dXJuIHshVFN5bnRhY3RpY0NvZGVVbml0fSBBIGZ1bmN0aW9uIHRoYXQgaXMgYWJsZSB0b1xuICAgICAgICAgICAgKiAgICAgaW5pdGlhdGUgdGhlIHRyYXZlcnNhbCBmcm9tIGEgZ2l2ZW4gc291cmNlIGVsZW1lbnQuXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICB2YXIgZkxhbWJkYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgIHJldHVybiBvV2Fsa2VyLndhbGsob1NvdXJjZUVsZW1lbnQpO1xuICAgICAgICAgICB9O1xuXG4gICAgICAgICAgIHJldHVybiBmTGFtYmRhO1xuICAgICAgICAgfSxcbiAgICAgICAgIC8qKlxuICAgICAgICAgICogQ2xhc3NpZmllcyB0aGUgc291cmNlIGVsZW1lbnQgYXMgZXhjbHVkYWJsZSBpZiBpdCBkb2VzIG5vdFxuICAgICAgICAgICogY29udGFpbiBhIHtAY29kZSB3aXRofSBzdGF0ZW1lbnQgb3IgdGhlIHtAY29kZSBldmFsfSBpZGVudGlmaWVyXG4gICAgICAgICAgKiBuYW1lLlxuICAgICAgICAgICovXG4gICAgICAgICBmQ2xhc3NpZnlBc0V4Y2x1ZGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgaWYgKG9Tb3VyY2VFbGVtZW50RGF0YS5uQ2F0ZWdvcnkgPT09XG4gICAgICAgICAgICAgICBFU291cmNlRWxlbWVudENhdGVnb3JpZXMuTl9PVEhFUikge1xuICAgICAgICAgICAgIG9Tb3VyY2VFbGVtZW50RGF0YS5uQ2F0ZWdvcnkgPVxuICAgICAgICAgICAgICAgICBFU291cmNlRWxlbWVudENhdGVnb3JpZXMuTl9FWENMVURBQkxFO1xuICAgICAgICAgICB9XG4gICAgICAgICB9LFxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBBZGRzIGFuIGlkZW50aWZpZXIgdG8gdGhlIGxpc3Qgb2YgaWRlbnRpZmllciBuYW1lcyBmb3VuZC5cbiAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzSWRlbnRpZmllciBUaGUgaWRlbnRpZmllciB0byBiZSBhZGRlZC5cbiAgICAgICAgICAqL1xuICAgICAgICAgZkFkZElkZW50aWZpZXIgPSBmdW5jdGlvbihzSWRlbnRpZmllcikge1xuICAgICAgICAgICBpZiAoLTEgPT09IG9Tb3VyY2VFbGVtZW50RGF0YS5hSWRlbnRpZmllcnMuaW5kZXhPZihzSWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgICBvU291cmNlRWxlbWVudERhdGEuYUlkZW50aWZpZXJzLnB1c2goc0lkZW50aWZpZXIpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9LFxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBBZGRzIHRoZSBpZGVudGlmaWVyIG9mIGEgdmFyaWFibGUgdG8gdGhlIGxpc3Qgb2YgaWRlbnRpZmllciBuYW1lc1xuICAgICAgICAgICogZm91bmQuXG4gICAgICAgICAgKiBAcGFyYW0geyFBcnJheX0gYVZhcmlhYmxlRGVjbGFyYXRpb24gQSB2YXJpYWJsZSBkZWNsYXJhdGlvbi5cbiAgICAgICAgICAqL1xuICAgICAgICAgZkFkZFZhcmlhYmxlID0gZnVuY3Rpb24oYVZhcmlhYmxlRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgZkFkZElkZW50aWZpZXIoLyoqIEB0eXBlIHtzdHJpbmd9ICovIGFWYXJpYWJsZURlY2xhcmF0aW9uWzBdKTtcbiAgICAgICAgIH0sXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIEluY3JlbWVudHMgdGhlIGNvdW50IG9mIHRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgb2YgdGhlIHByZWZpeGVkXG4gICAgICAgICAgKiBTdHJpbmcgcmVwcmVzZW50YXRpb24gYXR0cmlidXRlZCB0byB0aGUgcHJpbWFyeSBleHByZXNzaW9uLlxuICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5DYXRlZ29yeSBUaGUgY2F0ZWdvcnkgb2YgdGhlIHByaW1hcnkgZXhwcmVzc2lvbi5cbiAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzTmFtZSBUaGUgcHJlZml4ZWQgU3RyaW5nIHJlcHJlc2VudGF0aW9uIGF0dHJpYnV0ZWRcbiAgICAgICAgICAqICAgICB0byB0aGUgcHJpbWFyeSBleHByZXNzaW9uLlxuICAgICAgICAgICovXG4gICAgICAgICBmQ291bnRQcmltYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKG5DYXRlZ29yeSwgc05hbWUpIHtcbiAgICAgICAgICAgaWYgKCFvU291cmNlRWxlbWVudERhdGEuYUNvdW50W25DYXRlZ29yeV0uaGFzT3duUHJvcGVydHkoc05hbWUpKSB7XG4gICAgICAgICAgICAgb1NvdXJjZUVsZW1lbnREYXRhLmFDb3VudFtuQ2F0ZWdvcnldW3NOYW1lXSA9IDA7XG4gICAgICAgICAgICAgaWYgKC0xID09PSBvU291cmNlRWxlbWVudERhdGEuYVByaW1pdGl2ZVZhbHVlcy5pbmRleE9mKHNOYW1lKSkge1xuICAgICAgICAgICAgICAgb1NvdXJjZUVsZW1lbnREYXRhLmFQcmltaXRpdmVWYWx1ZXMucHVzaChzTmFtZSk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgICAgICAgIG9Tb3VyY2VFbGVtZW50RGF0YS5hQ291bnRbbkNhdGVnb3J5XVtzTmFtZV0gKz0gMTtcbiAgICAgICAgIH0sXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIENvbnNvbGlkYXRlcyBhbGwgd29ydGh3aGlsZSBwcmltaXRpdmUgdmFsdWVzIGluIGEgcmFuZ2Ugb2Ygc291cmNlXG4gICAgICAgICAgKiAgICAgZWxlbWVudHMuXG4gICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbkZyb20gVGhlIGluZGV4IChpbiB0aGUgc291cmNlIHRleHQgb3JkZXIpIG9mIHRoZVxuICAgICAgICAgICogICAgIHNvdXJjZSBlbGVtZW50IHRoYXQgaXMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIHJhbmdlLlxuICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5UbyBUaGUgaW5kZXggKGluIHRoZSBzb3VyY2UgdGV4dCBvcmRlcikgb2YgdGhlXG4gICAgICAgICAgKiAgICAgc291cmNlIGVsZW1lbnQgdGhhdCBpcyB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSByYW5nZS5cbiAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYkVuY2xvc2UgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHJhbmdlIHNob3VsZCBiZVxuICAgICAgICAgICogICAgIGVuY2xvc2VkIHdpdGhpbiBhIGZ1bmN0aW9uIGNhbGwgd2l0aCBubyBhcmd1bWVudCB2YWx1ZXMgdG8gYVxuICAgICAgICAgICogICAgIGZ1bmN0aW9uIHdpdGggYW4gZW1wdHkgcGFyYW1ldGVyIGxpc3QgaWYgYW55IHByaW1pdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAqICAgICBhcmUgY29uc29saWRhdGVkLlxuICAgICAgICAgICogQHNlZSBUUHJpbWl0aXZlVmFsdWUjblNhdmluZ1xuICAgICAgICAgICovXG4gICAgICAgICBmRXhhbWluZVNvdXJjZUVsZW1lbnRzID0gZnVuY3Rpb24obkZyb20sIG5UbywgYkVuY2xvc2UpIHtcbiAgICAgICAgICAgdmFyIF8sXG4gICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAqIFRoZSBpbmRleCBvZiB0aGUgbGFzdCBtYW5nbGVkIG5hbWUuXG4gICAgICAgICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICBuSW5kZXggPSBvU2NvcGUuY25hbWUsXG4gICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAqIFRoZSBpbmRleCBvZiB0aGUgc291cmNlIGVsZW1lbnQgdGhhdCBpcyBjdXJyZW50bHkgYmVpbmdcbiAgICAgICAgICAgICAgICAqIGNvbnNpZGVyZWQuXG4gICAgICAgICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICBuUG9zaXRpb24sXG4gICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAqIEEgY29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgdXNlZCBkdXJpbmcgdGhlIGNvbnNvbGlkYXRpb24gb2ZcbiAgICAgICAgICAgICAgICAqIHByaW1pdGl2ZSB2YWx1ZXMgYW5kIGlkZW50aWZpZXIgbmFtZXMgdXNlZCBhcyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICogYWNjZXNzb3JzLlxuICAgICAgICAgICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICAgICAgICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgZnVuY3Rpb24oLi4uWypdKT59XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgIG9XYWxrZXJzVHJhbnNmb3JtZXJzID0ge1xuICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICogSWYgdGhlIFN0cmluZyB2YWx1ZSB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gdGhlIHNlcXVlbmNlIG9mXG4gICAgICAgICAgICAgICAgICAqIHRlcm1pbmFsIHN5bWJvbHMgdGhhdCBjb25zdGl0dXRlIHRoZSBlbmNvdW50ZXJlZCBpZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAqIG5hbWUgaXMgd29ydGh3aGlsZSwgYSBzeW50YWN0aWMgY29udmVyc2lvbiBmcm9tIHRoZSBkb3RcbiAgICAgICAgICAgICAgICAgICogbm90YXRpb24gdG8gdGhlIGJyYWNrZXQgbm90YXRpb24gZW5zdWVzIHdpdGggdGhhdCBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgKiBiZWluZyBzdWJzdGl0dXRlZCBieSBhbiBpZGVudGlmaWVyIG5hbWUgdG8gd2hpY2ggdGhlIHZhbHVlXG4gICAgICAgICAgICAgICAgICAqIGlzIGFzc2lnbmVkLlxuICAgICAgICAgICAgICAgICAgKiBBcHBsaWVzIHRvIHByb3BlcnR5IGFjY2Vzc29ycyB0aGF0IHVzZSB0aGUgZG90IG5vdGF0aW9uLlxuICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyFUU3ludGFjdGljQ29kZVVuaXR9IG9FeHByZXNzaW9uIFRoZSBub250ZXJtaW5hbFxuICAgICAgICAgICAgICAgICAgKiAgICAgTWVtYmVyRXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNJZGVudGlmaWVyTmFtZSBUaGUgaWRlbnRpZmllciBuYW1lIHVzZWQgYXNcbiAgICAgICAgICAgICAgICAgICogICAgIHRoZSBwcm9wZXJ0eSBhY2Nlc3Nvci5cbiAgICAgICAgICAgICAgICAgICogQHJldHVybiB7IUFycmF5fSBBIHN5bnRhY3RpYyBjb2RlIHVuaXQgdGhhdCBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgICAgICAgICAgICAqICAgICB0aGUgb25lIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgICAgICAgKiBAc2VlIFRQcmltaXRpdmVWYWx1ZSNuU2F2aW5nXG4gICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAnZG90JzogZnVuY3Rpb24ob0V4cHJlc3Npb24sIHNJZGVudGlmaWVyTmFtZSkge1xuICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAqIFRoZSBwcmVmaXhlZCBTdHJpbmcgdmFsdWUgdGhhdCBpcyBlcXVpdmFsZW50IHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAqIHNlcXVlbmNlIG9mIHRlcm1pbmFsIHN5bWJvbHMgdGhhdCBjb25zdGl0dXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAqIGVuY291bnRlcmVkIGlkZW50aWZpZXIgbmFtZS5cbiAgICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgIHZhciBzUHJlZml4ZWQgPSBFVmFsdWVQcmVmaXhlcy5TX1NUUklORyArIHNJZGVudGlmaWVyTmFtZTtcblxuICAgICAgICAgICAgICAgICAgIHJldHVybiBvU29sdXRpb25CZXN0Lm9QcmltaXRpdmVWYWx1ZXMuaGFzT3duUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgIHNQcmVmaXhlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgb1NvbHV0aW9uQmVzdC5vUHJpbWl0aXZlVmFsdWVzW3NQcmVmaXhlZF0ublNhdmluZyA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICBbJ3N1YicsXG4gICAgICAgICAgICAgICAgICAgICAgICBvV2Fsa2VyLndhbGsob0V4cHJlc3Npb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgWyduYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBvU29sdXRpb25CZXN0Lm9QcmltaXRpdmVWYWx1ZXNbc1ByZWZpeGVkXS5zTmFtZV1dIDpcbiAgICAgICAgICAgICAgICAgICAgICAgWydkb3QnLCBvV2Fsa2VyLndhbGsob0V4cHJlc3Npb24pLCBzSWRlbnRpZmllck5hbWVdO1xuICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICogSWYgdGhlIGVuY291bnRlcmVkIGlkZW50aWZpZXIgaXMgYSBudWxsIG9yIEJvb2xlYW4gbGl0ZXJhbFxuICAgICAgICAgICAgICAgICAgKiBhbmQgaXRzIHZhbHVlIGlzIHdvcnRod2hpbGUsIHRoZSBpZGVudGlmaWVyIGlzIHN1YnN0aXR1dGVkXG4gICAgICAgICAgICAgICAgICAqIGJ5IGFuIGlkZW50aWZpZXIgbmFtZSB0byB3aGljaCB0aGF0IHZhbHVlIGlzIGFzc2lnbmVkLlxuICAgICAgICAgICAgICAgICAgKiBBcHBsaWVzIHRvIGlkZW50aWZpZXIgbmFtZXMuXG4gICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzSWRlbnRpZmllciBUaGUgaWRlbnRpZmllciBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgICAgICAgICogQHJldHVybiB7IUFycmF5fSBBIHN5bnRhY3RpYyBjb2RlIHVuaXQgdGhhdCBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgICAgICAgICAgICAqICAgICB0aGUgb25lIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgICAgICAgKiBAc2VlIFRQcmltaXRpdmVWYWx1ZSNuU2F2aW5nXG4gICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAnbmFtZSc6IGZ1bmN0aW9uKHNJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICogVGhlIHByZWZpeGVkIHJlcHJlc2VudGF0aW9uIFN0cmluZyBvZiB0aGUgaWRlbnRpZmllci5cbiAgICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgIHZhciBzUHJlZml4ZWQgPSBFVmFsdWVQcmVmaXhlcy5TX1NZTUJPTElDICsgc0lkZW50aWZpZXI7XG5cbiAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgJ25hbWUnLFxuICAgICAgICAgICAgICAgICAgICAgb1NvbHV0aW9uQmVzdC5vUHJpbWl0aXZlVmFsdWVzLmhhc093blByb3BlcnR5KHNQcmVmaXhlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIG9Tb2x1dGlvbkJlc3Qub1ByaW1pdGl2ZVZhbHVlc1tzUHJlZml4ZWRdLm5TYXZpbmcgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIG9Tb2x1dGlvbkJlc3Qub1ByaW1pdGl2ZVZhbHVlc1tzUHJlZml4ZWRdLnNOYW1lIDpcbiAgICAgICAgICAgICAgICAgICAgIHNJZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAqIElmIHRoZSBlbmNvdW50ZXJlZCBTdHJpbmcgdmFsdWUgaXMgd29ydGh3aGlsZSwgaXQgaXNcbiAgICAgICAgICAgICAgICAgICogc3Vic3RpdHV0ZWQgYnkgYW4gaWRlbnRpZmllciBuYW1lIHRvIHdoaWNoIHRoYXQgdmFsdWUgaXNcbiAgICAgICAgICAgICAgICAgICogYXNzaWduZWQuXG4gICAgICAgICAgICAgICAgICAqIEFwcGxpZXMgdG8gU3RyaW5nIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNTdHJpbmdWYWx1ZSBUaGUgU3RyaW5nIHZhbHVlIG9mIHRoZSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICogICAgIGxpdGVyYWwgZW5jb3VudGVyZWQuXG4gICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFBcnJheX0gQSBzeW50YWN0aWMgY29kZSB1bml0IHRoYXQgaXMgZXF1aXZhbGVudCB0b1xuICAgICAgICAgICAgICAgICAgKiAgICAgdGhlIG9uZSBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgICAgICAgICogQHNlZSBUUHJpbWl0aXZlVmFsdWUjblNhdmluZ1xuICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgJ3N0cmluZyc6IGZ1bmN0aW9uKHNTdHJpbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAqIFRoZSBwcmVmaXhlZCByZXByZXNlbnRhdGlvbiBTdHJpbmcgb2YgdGhlIHByaW1pdGl2ZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAqIG9mIHRoZSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgdmFyIHNQcmVmaXhlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgIEVWYWx1ZVByZWZpeGVzLlNfU1RSSU5HICsgc1N0cmluZ1ZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIG9Tb2x1dGlvbkJlc3Qub1ByaW1pdGl2ZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgICAgc1ByZWZpeGVkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICBvU29sdXRpb25CZXN0Lm9QcmltaXRpdmVWYWx1ZXNbc1ByZWZpeGVkXS5uU2F2aW5nID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIFsnbmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBvU29sdXRpb25CZXN0Lm9QcmltaXRpdmVWYWx1ZXNbc1ByZWZpeGVkXS5zTmFtZV0gOlxuICAgICAgICAgICAgICAgICAgICAgICBbJ3N0cmluZycsIHNTdHJpbmdWYWx1ZV07XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAqIFN1Y2ggZGF0YSBvbiB3aGF0IHRvIGNvbnNvbGlkYXRlIHdpdGhpbiB0aGUgcmFuZ2Ugb2Ygc291cmNlXG4gICAgICAgICAgICAgICAgKiBlbGVtZW50cyB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBjb25zaWRlcmVkIHRoYXQgbGVhZCB0byB0aGVcbiAgICAgICAgICAgICAgICAqIGdyZWF0ZXN0IGtub3duIHJlZHVjdGlvbiBvZiB0aGUgbnVtYmVyIG9mIHRoZSB0ZXJtaW5hbCBzeW1ib2xzXG4gICAgICAgICAgICAgICAgKiBpbiBjb21wYXJpc29uIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGV4dC5cbiAgICAgICAgICAgICAgICAqIEB0eXBlIHshVFNvbHV0aW9ufVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICBvU29sdXRpb25CZXN0ID0gbmV3IFRTb2x1dGlvbigpLFxuICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBEYXRhIHJlcHJlc2VudGluZyBhbiBvbmdvaW5nIGF0dGVtcHQgdG8gZmluZCBhIGJldHRlclxuICAgICAgICAgICAgICAgICogcmVkdWN0aW9uIG9mIHRoZSBudW1iZXIgb2YgdGhlIHRlcm1pbmFsIHN5bWJvbHMgaW4gY29tcGFyaXNvblxuICAgICAgICAgICAgICAgICogdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSB0ZXh0IHRoYW4gdGhlIGJlc3Qgb25lIHRoYXQgaXNcbiAgICAgICAgICAgICAgICAqIGN1cnJlbnRseSBrbm93bi5cbiAgICAgICAgICAgICAgICAqIEB0eXBlIHshVFNvbHV0aW9ufVxuICAgICAgICAgICAgICAgICogQHNlZSBvU29sdXRpb25CZXN0XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgIG9Tb2x1dGlvbkNhbmRpZGF0ZSA9IG5ldyBUU29sdXRpb24oKSxcbiAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICogQSByZWNvcmQgY29uc2lzdGluZyBvZiBkYXRhIGFib3V0IHRoZSByYW5nZSBvZiBzb3VyY2UgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAqIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIGV4YW1pbmVkLlxuICAgICAgICAgICAgICAgICogQHR5cGUgeyFUU291cmNlRWxlbWVudHNEYXRhfVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICBvU291cmNlRWxlbWVudHNEYXRhID0gbmV3IFRTb3VyY2VFbGVtZW50c0RhdGEoKSxcbiAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICogVmFyaWFibGUgZGVjbGFyYXRpb25zIGZvciBlYWNoIHByaW1pdGl2ZSB2YWx1ZSB0aGF0IGlzIHRvIGJlXG4gICAgICAgICAgICAgICAgKiBjb25zb2xpZGF0ZWQgd2l0aGluIHRoZSBlbGVtZW50cy5cbiAgICAgICAgICAgICAgICAqIEB0eXBlIHshQXJyYXkuPCFBcnJheT59XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgIGFWYXJpYWJsZURlY2xhcmF0aW9ucyA9IFtdLFxuICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBBdWdtZW50cyBhIGxpc3Qgd2l0aCBhIHByZWZpeGVkIHJlcHJlc2VudGF0aW9uIFN0cmluZy5cbiAgICAgICAgICAgICAgICAqIEBwYXJhbSB7IUFycmF5LjxzdHJpbmc+fSBhTGlzdCBBIGxpc3QgdGhhdCBpcyB0byBiZSBhdWdtZW50ZWQuXG4gICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbihzdHJpbmcpfSBBIGZ1bmN0aW9uIHRoYXQgYXVnbWVudHMgYSBsaXN0XG4gICAgICAgICAgICAgICAgKiAgICAgd2l0aCBhIHByZWZpeGVkIHJlcHJlc2VudGF0aW9uIFN0cmluZy5cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgY0F1Z21lbnRMaXN0ID0gZnVuY3Rpb24oYUxpc3QpIHtcbiAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzUHJlZml4ZWQgUHJlZml4ZWQgcmVwcmVzZW50YXRpb24gU3RyaW5nIG9mXG4gICAgICAgICAgICAgICAgICAqICAgICBhIHByaW1pdGl2ZSB2YWx1ZSB0aGF0IGNvdWxkIGJlIGNvbnNvbGlkYXRlZCB3aXRoaW4gdGhlXG4gICAgICAgICAgICAgICAgICAqICAgICBlbGVtZW50cy5cbiAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgIHZhciBmTGFtYmRhID0gZnVuY3Rpb24oc1ByZWZpeGVkKSB7XG4gICAgICAgICAgICAgICAgICAgaWYgKC0xID09PSBhTGlzdC5pbmRleE9mKHNQcmVmaXhlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgIGFMaXN0LnB1c2goc1ByZWZpeGVkKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgcmV0dXJuIGZMYW1iZGE7XG4gICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBBZGRzIHRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgb2YgYSBwcmltaXRpdmUgdmFsdWUgb2YgYSBnaXZlblxuICAgICAgICAgICAgICAgICogY2F0ZWdvcnkgdGhhdCBjb3VsZCBiZSBjb25zb2xpZGF0ZWQgaW4gdGhlIHNvdXJjZSBlbGVtZW50IHdpdGhcbiAgICAgICAgICAgICAgICAqIGEgZ2l2ZW4gaW5kZXggdG8gdGhlIGNvdW50IG9mIG9jY3VycmVuY2VzIG9mIHRoYXQgcHJpbWl0aXZlXG4gICAgICAgICAgICAgICAgKiB2YWx1ZSB3aXRoaW4gdGhlIHJhbmdlIG9mIHNvdXJjZSBlbGVtZW50cyB0aGF0IGlzIGN1cnJlbnRseVxuICAgICAgICAgICAgICAgICogYmVpbmcgY29uc2lkZXJlZC5cbiAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuUG9zaXRpb24gVGhlIGluZGV4IChpbiB0aGUgc291cmNlIHRleHQgb3JkZXIpXG4gICAgICAgICAgICAgICAgKiAgICAgb2YgYSBzb3VyY2UgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuQ2F0ZWdvcnkgVGhlIGNhdGVnb3J5IG9mIHRoZSBwcmltYXJ5XG4gICAgICAgICAgICAgICAgKiAgICAgZXhwcmVzc2lvbiBmcm9tIHdoaWNoIHRoZSBwcmltaXRpdmUgdmFsdWUgaXMgZGVyaXZlZC5cbiAgICAgICAgICAgICAgICAqIEByZXR1cm4ge2Z1bmN0aW9uKHN0cmluZyl9IEEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyB0aGVcbiAgICAgICAgICAgICAgICAqICAgICBhZGRpdGlvbi5cbiAgICAgICAgICAgICAgICAqIEBzZWUgY0FkZE9jY3VycmVuY2VzSW5DYXRlZ29yeVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICBjQWRkT2NjdXJyZW5jZXMgPSBmdW5jdGlvbihuUG9zaXRpb24sIG5DYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNQcmVmaXhlZCBUaGUgcHJlZml4ZWQgcmVwcmVzZW50YXRpb24gU3RyaW5nXG4gICAgICAgICAgICAgICAgICAqICAgICBvZiBhIHByaW1pdGl2ZSB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgIHZhciBmTGFtYmRhID0gZnVuY3Rpb24oc1ByZWZpeGVkKSB7XG4gICAgICAgICAgICAgICAgICAgaWYgKCFvU291cmNlRWxlbWVudHNEYXRhLmFDb3VudFtuQ2F0ZWdvcnldLmhhc093blByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc1ByZWZpeGVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgb1NvdXJjZUVsZW1lbnRzRGF0YS5hQ291bnRbbkNhdGVnb3J5XVtzUHJlZml4ZWRdID0gMDtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgb1NvdXJjZUVsZW1lbnRzRGF0YS5hQ291bnRbbkNhdGVnb3J5XVtzUHJlZml4ZWRdICs9XG4gICAgICAgICAgICAgICAgICAgICAgIGFTb3VyY2VFbGVtZW50c0RhdGFbblBvc2l0aW9uXS5hQ291bnRbbkNhdGVnb3J5XVtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHNQcmVmaXhlZF07XG4gICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgcmV0dXJuIGZMYW1iZGE7XG4gICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBBZGRzIHRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgb2YgZWFjaCBwcmltaXRpdmUgdmFsdWUgb2YgYVxuICAgICAgICAgICAgICAgICogZ2l2ZW4gY2F0ZWdvcnkgdGhhdCBjb3VsZCBiZSBjb25zb2xpZGF0ZWQgaW4gdGhlIHNvdXJjZVxuICAgICAgICAgICAgICAgICogZWxlbWVudCB3aXRoIGEgZ2l2ZW4gaW5kZXggdG8gdGhlIGNvdW50IG9mIG9jY3VycmVuY2VzIG9mIHRoYXRcbiAgICAgICAgICAgICAgICAqIHByaW1pdGl2ZSB2YWx1ZXMgd2l0aGluIHRoZSByYW5nZSBvZiBzb3VyY2UgZWxlbWVudHMgdGhhdCBpc1xuICAgICAgICAgICAgICAgICogY3VycmVudGx5IGJlaW5nIGNvbnNpZGVyZWQuXG4gICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gblBvc2l0aW9uIFRoZSBpbmRleCAoaW4gdGhlIHNvdXJjZSB0ZXh0IG9yZGVyKVxuICAgICAgICAgICAgICAgICogICAgIG9mIGEgc291cmNlIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbihudW1iZXIpfSBBIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgdGhlXG4gICAgICAgICAgICAgICAgKiAgICAgYWRkaXRpb24uXG4gICAgICAgICAgICAgICAgKiBAc2VlIGZBZGRPY2N1cnJlbmNlc1xuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICBjQWRkT2NjdXJyZW5jZXNJbkNhdGVnb3J5ID0gZnVuY3Rpb24oblBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbkNhdGVnb3J5IFRoZSBjYXRlZ29yeSBvZiB0aGUgcHJpbWFyeVxuICAgICAgICAgICAgICAgICAgKiAgICAgZXhwcmVzc2lvbiBmcm9tIHdoaWNoIHRoZSBwcmltaXRpdmUgdmFsdWUgaXMgZGVyaXZlZC5cbiAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgIHZhciBmTGFtYmRhID0gZnVuY3Rpb24obkNhdGVnb3J5KSB7XG4gICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoXG4gICAgICAgICAgICAgICAgICAgICAgIGFTb3VyY2VFbGVtZW50c0RhdGFbblBvc2l0aW9uXS5hQ291bnRbbkNhdGVnb3J5XVxuICAgICAgICAgICAgICAgICAgICkuZm9yRWFjaChjQWRkT2NjdXJyZW5jZXMoblBvc2l0aW9uLCBuQ2F0ZWdvcnkpKTtcbiAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICByZXR1cm4gZkxhbWJkYTtcbiAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAqIEFkZHMgdGhlIG51bWJlciBvZiBvY2N1cnJlbmNlcyBvZiBlYWNoIHByaW1pdGl2ZSB2YWx1ZSB0aGF0XG4gICAgICAgICAgICAgICAgKiBjb3VsZCBiZSBjb25zb2xpZGF0ZWQgaW4gdGhlIHNvdXJjZSBlbGVtZW50IHdpdGggYSBnaXZlbiBpbmRleFxuICAgICAgICAgICAgICAgICogdG8gdGhlIGNvdW50IG9mIG9jY3VycmVuY2VzIG9mIHRoYXQgcHJpbWl0aXZlIHZhbHVlcyB3aXRoaW5cbiAgICAgICAgICAgICAgICAqIHRoZSByYW5nZSBvZiBzb3VyY2UgZWxlbWVudHMgdGhhdCBpcyBjdXJyZW50bHkgYmVpbmdcbiAgICAgICAgICAgICAgICAqIGNvbnNpZGVyZWQuXG4gICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gblBvc2l0aW9uIFRoZSBpbmRleCAoaW4gdGhlIHNvdXJjZSB0ZXh0IG9yZGVyKVxuICAgICAgICAgICAgICAgICogICAgIG9mIGEgc291cmNlIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgIGZBZGRPY2N1cnJlbmNlcyA9IGZ1bmN0aW9uKG5Qb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhU291cmNlRWxlbWVudHNEYXRhW25Qb3NpdGlvbl0uYUNvdW50KS5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICAgICAgY0FkZE9jY3VycmVuY2VzSW5DYXRlZ29yeShuUG9zaXRpb24pKTtcbiAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAqIENyZWF0ZXMgYSB2YXJpYWJsZSBkZWNsYXJhdGlvbiBmb3IgYSBwcmltaXRpdmUgdmFsdWUgaWYgdGhhdFxuICAgICAgICAgICAgICAgICogcHJpbWl0aXZlIHZhbHVlIGlzIHRvIGJlIGNvbnNvbGlkYXRlZCB3aXRoaW4gdGhlIGVsZW1lbnRzLlxuICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNQcmVmaXhlZCBQcmVmaXhlZCByZXByZXNlbnRhdGlvbiBTdHJpbmcgb2YgYVxuICAgICAgICAgICAgICAgICogICAgIHByaW1pdGl2ZSB2YWx1ZSB0aGF0IGNvdWxkIGJlIGNvbnNvbGlkYXRlZCB3aXRoaW4gdGhlXG4gICAgICAgICAgICAgICAgKiAgICAgZWxlbWVudHMuXG4gICAgICAgICAgICAgICAgKiBAc2VlIGFWYXJpYWJsZURlY2xhcmF0aW9uc1xuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICBjQXVnbWVudFZhcmlhYmxlRGVjbGFyYXRpb25zID0gZnVuY3Rpb24oc1ByZWZpeGVkKSB7XG4gICAgICAgICAgICAgICAgIGlmIChvU29sdXRpb25CZXN0Lm9QcmltaXRpdmVWYWx1ZXNbc1ByZWZpeGVkXS5uU2F2aW5nID4gMCkge1xuICAgICAgICAgICAgICAgICAgIGFWYXJpYWJsZURlY2xhcmF0aW9ucy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgIG9Tb2x1dGlvbkJlc3Qub1ByaW1pdGl2ZVZhbHVlc1tzUHJlZml4ZWRdLnNOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgWzAgPT09IHNQcmVmaXhlZC5pbmRleE9mKEVWYWx1ZVByZWZpeGVzLlNfU1lNQk9MSUMpID9cbiAgICAgICAgICAgICAgICAgICAgICAnbmFtZScgOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICBzUHJlZml4ZWQuc3Vic3RyaW5nKEVWYWx1ZVByZWZpeGVzLlNfU1lNQk9MSUMubGVuZ3RoKV1cbiAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICogU29ydHMgcHJpbWl0aXZlIHZhbHVlcyB3aXRoIHJlZ2FyZCB0byB0aGUgZGlmZmVyZW5jZSBpbiB0aGVcbiAgICAgICAgICAgICAgICAqIG51bWJlciBvZiB0ZXJtaW5hbCBzeW1ib2xzIGJldHdlZW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0ZXh0XG4gICAgICAgICAgICAgICAgKiBhbmQgdGhlIG9uZSB3aXRoIHRob3NlIHByaW1pdGl2ZSB2YWx1ZXMgY29uc29saWRhdGVkLlxuICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNQcmVmaXhlZDAgVGhlIHByZWZpeGVkIHJlcHJlc2VudGF0aW9uIFN0cmluZ1xuICAgICAgICAgICAgICAgICogICAgIG9mIHRoZSBmaXJzdCBvZiB0aGUgdHdvIHByaW1pdGl2ZSB2YWx1ZXMgdGhhdCBhcmUgYmVpbmdcbiAgICAgICAgICAgICAgICAqICAgICBjb21wYXJlZC5cbiAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzUHJlZml4ZWQxIFRoZSBwcmVmaXhlZCByZXByZXNlbnRhdGlvbiBTdHJpbmdcbiAgICAgICAgICAgICAgICAqICAgICBvZiB0aGUgc2Vjb25kIG9mIHRoZSB0d28gcHJpbWl0aXZlIHZhbHVlcyB0aGF0IGFyZSBiZWluZ1xuICAgICAgICAgICAgICAgICogICAgIGNvbXBhcmVkLlxuICAgICAgICAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgICAgICAgICogICAgIDxkbD5cbiAgICAgICAgICAgICAgICAqICAgICAgICAgPGR0Pi0xPC9kdD5cbiAgICAgICAgICAgICAgICAqICAgICAgICAgPGRkPmlmIHRoZSBmaXJzdCBwcmltaXRpdmUgdmFsdWUgbXVzdCBiZSBwbGFjZWQgYmVmb3JlXG4gICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgdGhlIG90aGVyIG9uZSw8L2RkPlxuICAgICAgICAgICAgICAgICogICAgICAgICA8ZHQ+MDwvZHQ+XG4gICAgICAgICAgICAgICAgKiAgICAgICAgIDxkZD5pZiB0aGUgZmlyc3QgcHJpbWl0aXZlIHZhbHVlIG1heSBiZSBwbGFjZWQgYmVmb3JlXG4gICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgdGhlIG90aGVyIG9uZSw8L2RkPlxuICAgICAgICAgICAgICAgICogICAgICAgICA8ZHQ+MTwvZHQ+XG4gICAgICAgICAgICAgICAgKiAgICAgICAgIDxkZD5pZiB0aGUgZmlyc3QgcHJpbWl0aXZlIHZhbHVlIG11c3Qgbm90IGJlIHBsYWNlZFxuICAgICAgICAgICAgICAgICogICAgICAgICAgICAgIGJlZm9yZSB0aGUgb3RoZXIgb25lLjwvZGQ+XG4gICAgICAgICAgICAgICAgKiAgICAgPC9kbD5cbiAgICAgICAgICAgICAgICAqIEBzZWUgVFNvbHV0aW9uLm9QcmltaXRpdmVWYWx1ZXNcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgY1NvcnRQcmltaXRpdmVWYWx1ZXMgPSBmdW5jdGlvbihzUHJlZml4ZWQwLCBzUHJlZml4ZWQxKSB7XG4gICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgKiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuOlxuICAgICAgICAgICAgICAgICAgKiA8b2w+XG4gICAgICAgICAgICAgICAgICAqIDxsaT50aGUgZGlmZmVyZW5jZSBpbiB0aGUgbnVtYmVyIG9mIHRlcm1pbmFsIHN5bWJvbHNcbiAgICAgICAgICAgICAgICAgICogICAgIGJldHdlZW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0ZXh0IGFuZCB0aGUgb25lIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgICAqICAgICBmaXJzdCBwcmltaXRpdmUgdmFsdWUgY29uc29saWRhdGVkLCBhbmQ8L2xpPlxuICAgICAgICAgICAgICAgICAgKiA8bGk+dGhlIGRpZmZlcmVuY2UgaW4gdGhlIG51bWJlciBvZiB0ZXJtaW5hbCBzeW1ib2xzXG4gICAgICAgICAgICAgICAgICAqICAgICBiZXR3ZWVuIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGV4dCBhbmQgdGhlIG9uZSB3aXRoIHRoZVxuICAgICAgICAgICAgICAgICAgKiAgICAgc2Vjb25kIHByaW1pdGl2ZSB2YWx1ZSBjb25zb2xpZGF0ZWQuPC9saT5cbiAgICAgICAgICAgICAgICAgICogPC9vbD5cbiAgICAgICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgIHZhciBuRGlmZmVyZW5jZSA9XG4gICAgICAgICAgICAgICAgICAgICBvU29sdXRpb25DYW5kaWRhdGUub1ByaW1pdGl2ZVZhbHVlc1tzUHJlZml4ZWQwXS5uU2F2aW5nIC1cbiAgICAgICAgICAgICAgICAgICAgIG9Tb2x1dGlvbkNhbmRpZGF0ZS5vUHJpbWl0aXZlVmFsdWVzW3NQcmVmaXhlZDFdLm5TYXZpbmc7XG5cbiAgICAgICAgICAgICAgICAgcmV0dXJuIG5EaWZmZXJlbmNlID4gMCA/IC0xIDogbkRpZmZlcmVuY2UgPCAwID8gMSA6IDA7XG4gICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBBc3NpZ25zIGFuIGlkZW50aWZpZXIgbmFtZSB0byBhIHByaW1pdGl2ZSB2YWx1ZSBhbmQgY2FsY3VsYXRlc1xuICAgICAgICAgICAgICAgICogd2hldGhlciBpbnN0YW5jZXMgb2YgdGhhdCBwcmltaXRpdmUgdmFsdWUgYXJlIHdvcnRoXG4gICAgICAgICAgICAgICAgKiBjb25zb2xpZGF0aW5nLlxuICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNQcmVmaXhlZCBUaGUgcHJlZml4ZWQgcmVwcmVzZW50YXRpb24gU3RyaW5nXG4gICAgICAgICAgICAgICAgKiAgICAgb2YgYSBwcmltaXRpdmUgdmFsdWUgdGhhdCBpcyBiZWluZyBldmFsdWF0ZWQuXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgIGZFdmFsdWF0ZVByaW1pdGl2ZVZhbHVlID0gZnVuY3Rpb24oc1ByZWZpeGVkKSB7XG4gICAgICAgICAgICAgICAgIHZhciBfLFxuICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGxhc3QgbWFuZ2xlZCBuYW1lLlxuICAgICAgICAgICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgbkluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgKiBUaGUgcmVwcmVzZW50YXRpb24gU3RyaW5nIG9mIHRoZSBwcmltaXRpdmUgdmFsdWUgdGhhdCBpc1xuICAgICAgICAgICAgICAgICAgICAgICogYmVpbmcgZXZhbHVhdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgc05hbWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgIHNQcmVmaXhlZC5zdWJzdHJpbmcoRVZhbHVlUHJlZml4ZXMuU19TWU1CT0xJQy5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHNvdXJjZSBjaGFyYWN0ZXJzIHRha2VuIHVwIGJ5IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICogcmVwcmVzZW50YXRpb24gU3RyaW5nIG9mIHRoZSBwcmltaXRpdmUgdmFsdWUgdGhhdCBpc1xuICAgICAgICAgICAgICAgICAgICAgICogYmVpbmcgZXZhbHVhdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgbkxlbmd0aE9yaWdpbmFsID0gc05hbWUubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHNvdXJjZSBjaGFyYWN0ZXJzIHRha2VuIHVwIGJ5IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICogaWRlbnRpZmllciBuYW1lIHRoYXQgY291bGQgc3Vic3RpdHV0ZSB0aGUgcHJpbWl0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgKiB2YWx1ZSB0aGF0IGlzIGJlaW5nIGV2YWx1YXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAqIHN1YnN0aXR1dGVkLlxuICAgICAgICAgICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgbkxlbmd0aFN1YnN0aXR1dGlvbixcbiAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICogVGhlIG51bWJlciBvZiBzb3VyY2UgY2hhcmFjdGVycyB0YWtlbiB1cCBieSBieSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAqIHJlcHJlc2VudGF0aW9uIFN0cmluZyBvZiB0aGUgcHJpbWl0aXZlIHZhbHVlIHRoYXQgaXNcbiAgICAgICAgICAgICAgICAgICAgICAqIGJlaW5nIGV2YWx1YXRlZCB3aGVuIGl0IGlzIHJlcHJlc2VudGVkIGJ5IGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgKiBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgbkxlbmd0aFN0cmluZyA9IG9Qcm9jZXNzb3IubWFrZV9zdHJpbmcoc05hbWUpLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICBvU29sdXRpb25DYW5kaWRhdGUub1ByaW1pdGl2ZVZhbHVlc1tzUHJlZml4ZWRdID1cbiAgICAgICAgICAgICAgICAgICAgIG5ldyBUUHJpbWl0aXZlVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgZG8geyAgLy8gRmluZCBhbiBpZGVudGlmaWVyIHVudXNlZCBpbiB0aGlzIG9yIGFueSBuZXN0ZWQgc2NvcGUuXG4gICAgICAgICAgICAgICAgICAgbkluZGV4ID0gb1Njb3BlLmNuYW1lO1xuICAgICAgICAgICAgICAgICAgIG9Tb2x1dGlvbkNhbmRpZGF0ZS5vUHJpbWl0aXZlVmFsdWVzW3NQcmVmaXhlZF0uc05hbWUgPVxuICAgICAgICAgICAgICAgICAgICAgICBvU2NvcGUubmV4dF9tYW5nbGVkKCk7XG4gICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0xICE9PSBvU291cmNlRWxlbWVudHNEYXRhLmFJZGVudGlmaWVycy5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgICAgb1NvbHV0aW9uQ2FuZGlkYXRlLm9QcmltaXRpdmVWYWx1ZXNbc1ByZWZpeGVkXS5zTmFtZSkpO1xuICAgICAgICAgICAgICAgICBuTGVuZ3RoU3Vic3RpdHV0aW9uID0gb1NvbHV0aW9uQ2FuZGlkYXRlLm9QcmltaXRpdmVWYWx1ZXNbXG4gICAgICAgICAgICAgICAgICAgICBzUHJlZml4ZWRdLnNOYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgaWYgKDAgPT09IHNQcmVmaXhlZC5pbmRleE9mKEVWYWx1ZVByZWZpeGVzLlNfU1lNQk9MSUMpKSB7XG4gICAgICAgICAgICAgICAgICAgLy8gZm9vOm51bGwsIG9yIGZvbzpudWxsO1xuICAgICAgICAgICAgICAgICAgIG9Tb2x1dGlvbkNhbmRpZGF0ZS5vUHJpbWl0aXZlVmFsdWVzW3NQcmVmaXhlZF0ublNhdmluZyAtPVxuICAgICAgICAgICAgICAgICAgICAgICBuTGVuZ3RoU3Vic3RpdHV0aW9uICsgbkxlbmd0aE9yaWdpbmFsICtcbiAgICAgICAgICAgICAgICAgICAgICAgb1dlaWdodHMuTl9WQVJJQUJMRV9ERUNMQVJBVElPTjtcbiAgICAgICAgICAgICAgICAgICAvLyBudWxsIHZzIGZvb1xuICAgICAgICAgICAgICAgICAgIG9Tb2x1dGlvbkNhbmRpZGF0ZS5vUHJpbWl0aXZlVmFsdWVzW3NQcmVmaXhlZF0ublNhdmluZyArPVxuICAgICAgICAgICAgICAgICAgICAgICBvU291cmNlRWxlbWVudHNEYXRhLmFDb3VudFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEVQcmltYXJ5RXhwcmVzc2lvbkNhdGVnb3JpZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTl9OVUxMX0FORF9CT09MRUFOX0xJVEVSQUxTXVtzUHJlZml4ZWRdICpcbiAgICAgICAgICAgICAgICAgICAgICAgKG5MZW5ndGhPcmlnaW5hbCAtIG5MZW5ndGhTdWJzdGl0dXRpb24pO1xuICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgIC8vIGZvbzonZnJvbUNoYXJDb2RlJztcbiAgICAgICAgICAgICAgICAgICBvU29sdXRpb25DYW5kaWRhdGUub1ByaW1pdGl2ZVZhbHVlc1tzUHJlZml4ZWRdLm5TYXZpbmcgLT1cbiAgICAgICAgICAgICAgICAgICAgICAgbkxlbmd0aFN1YnN0aXR1dGlvbiArIG5MZW5ndGhTdHJpbmcgK1xuICAgICAgICAgICAgICAgICAgICAgICBvV2VpZ2h0cy5OX1ZBUklBQkxFX0RFQ0xBUkFUSU9OO1xuICAgICAgICAgICAgICAgICAgIC8vIC5mcm9tQ2hhckNvZGUgdnMgW2Zvb11cbiAgICAgICAgICAgICAgICAgICBpZiAob1NvdXJjZUVsZW1lbnRzRGF0YS5hQ291bnRbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBFUHJpbWFyeUV4cHJlc3Npb25DYXRlZ29yaWVzLk5fSURFTlRJRklFUl9OQU1FU1xuICAgICAgICAgICAgICAgICAgICAgICBdLmhhc093blByb3BlcnR5KHNQcmVmaXhlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgIG9Tb2x1dGlvbkNhbmRpZGF0ZS5vUHJpbWl0aXZlVmFsdWVzW3NQcmVmaXhlZF0ublNhdmluZyArPVxuICAgICAgICAgICAgICAgICAgICAgICAgIG9Tb3VyY2VFbGVtZW50c0RhdGEuYUNvdW50W1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFUHJpbWFyeUV4cHJlc3Npb25DYXRlZ29yaWVzLk5fSURFTlRJRklFUl9OQU1FU1xuICAgICAgICAgICAgICAgICAgICAgICAgIF1bc1ByZWZpeGVkXSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKG5MZW5ndGhPcmlnaW5hbCAtIG5MZW5ndGhTdWJzdGl0dXRpb24gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICBvV2VpZ2h0cy5OX1BST1BFUlRZX0FDQ0VTU09SKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgLy8gJ2Zyb21DaGFyQ29kZScgdnMgZm9vXG4gICAgICAgICAgICAgICAgICAgaWYgKG9Tb3VyY2VFbGVtZW50c0RhdGEuYUNvdW50W1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgRVByaW1hcnlFeHByZXNzaW9uQ2F0ZWdvcmllcy5OX1NUUklOR19MSVRFUkFMU1xuICAgICAgICAgICAgICAgICAgICAgICBdLmhhc093blByb3BlcnR5KHNQcmVmaXhlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgIG9Tb2x1dGlvbkNhbmRpZGF0ZS5vUHJpbWl0aXZlVmFsdWVzW3NQcmVmaXhlZF0ublNhdmluZyArPVxuICAgICAgICAgICAgICAgICAgICAgICAgIG9Tb3VyY2VFbGVtZW50c0RhdGEuYUNvdW50W1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFUHJpbWFyeUV4cHJlc3Npb25DYXRlZ29yaWVzLk5fU1RSSU5HX0xJVEVSQUxTXG4gICAgICAgICAgICAgICAgICAgICAgICAgXVtzUHJlZml4ZWRdICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAobkxlbmd0aFN0cmluZyAtIG5MZW5ndGhTdWJzdGl0dXRpb24pO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICBpZiAob1NvbHV0aW9uQ2FuZGlkYXRlLm9QcmltaXRpdmVWYWx1ZXNbc1ByZWZpeGVkXS5uU2F2aW5nID5cbiAgICAgICAgICAgICAgICAgICAgIDApIHtcbiAgICAgICAgICAgICAgICAgICBvU29sdXRpb25DYW5kaWRhdGUublNhdmluZ3MgKz1cbiAgICAgICAgICAgICAgICAgICAgICAgb1NvbHV0aW9uQ2FuZGlkYXRlLm9QcmltaXRpdmVWYWx1ZXNbc1ByZWZpeGVkXS5uU2F2aW5nO1xuICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgIG9TY29wZS5jbmFtZSA9IG5JbmRleDsgLy8gRnJlZSB0aGUgaWRlbnRpZmllciBuYW1lLlxuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBBZGRzIGEgdmFyaWFibGUgZGVjbGFyYXRpb24gdG8gYW4gZXhpc3RpbmcgdmFyaWFibGUgc3RhdGVtZW50LlxuICAgICAgICAgICAgICAgICogQHBhcmFtIHshQXJyYXl9IGFWYXJpYWJsZURlY2xhcmF0aW9uIEEgdmFyaWFibGUgZGVjbGFyYXRpb25cbiAgICAgICAgICAgICAgICAqICAgICB3aXRoIGFuIGluaXRpYWxpc2VyLlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICBjQWRkVmFyaWFibGVEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKGFWYXJpYWJsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICgvKiogQHR5cGUgeyFBcnJheX0gKi8gb1NvdXJjZUVsZW1lbnRzW25Gcm9tXVsxXSkudW5zaGlmdChcbiAgICAgICAgICAgICAgICAgICAgIGFWYXJpYWJsZURlY2xhcmF0aW9uKTtcbiAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgaWYgKG5Gcm9tID4gblRvKSB7XG4gICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIC8vIElmIHRoZSByYW5nZSBpcyBhIGNsb3N1cmUsIHJldXNlIHRoZSBjbG9zdXJlLlxuICAgICAgICAgICBpZiAobkZyb20gPT09IG5UbyAmJlxuICAgICAgICAgICAgICAgJ3N0YXQnID09PSBvU291cmNlRWxlbWVudHNbbkZyb21dWzBdICYmXG4gICAgICAgICAgICAgICAnY2FsbCcgPT09IG9Tb3VyY2VFbGVtZW50c1tuRnJvbV1bMV1bMF0gJiZcbiAgICAgICAgICAgICAgICdmdW5jdGlvbicgPT09IG9Tb3VyY2VFbGVtZW50c1tuRnJvbV1bMV1bMV1bMF0pIHtcbiAgICAgICAgICAgICBmRXhhbWluZVN5bnRhY3RpY0NvZGVVbml0KG9Tb3VyY2VFbGVtZW50c1tuRnJvbV1bMV1bMV0pO1xuICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgfVxuICAgICAgICAgICAvLyBDcmVhdGUgYSBsaXN0IG9mIGFsbCBkZXJpdmVkIHByaW1pdGl2ZSB2YWx1ZXMgd2l0aGluIHRoZSByYW5nZS5cbiAgICAgICAgICAgZm9yIChuUG9zaXRpb24gPSBuRnJvbTsgblBvc2l0aW9uIDw9IG5UbzsgblBvc2l0aW9uICs9IDEpIHtcbiAgICAgICAgICAgICBhU291cmNlRWxlbWVudHNEYXRhW25Qb3NpdGlvbl0uYVByaW1pdGl2ZVZhbHVlcy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICBjQXVnbWVudExpc3Qob1NvdXJjZUVsZW1lbnRzRGF0YS5hUHJpbWl0aXZlVmFsdWVzKSk7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgaWYgKDAgPT09IG9Tb3VyY2VFbGVtZW50c0RhdGEuYVByaW1pdGl2ZVZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgZm9yIChuUG9zaXRpb24gPSBuRnJvbTsgblBvc2l0aW9uIDw9IG5UbzsgblBvc2l0aW9uICs9IDEpIHtcbiAgICAgICAgICAgICAvLyBBZGQgdGhlIG51bWJlciBvZiBvY2N1cnJlbmNlcyB0byB0aGUgdG90YWwgY291bnQuXG4gICAgICAgICAgICAgZkFkZE9jY3VycmVuY2VzKG5Qb3NpdGlvbik7XG4gICAgICAgICAgICAgLy8gQWRkIGlkZW50aWZpZXJzIG9mIHRoaXMgb3IgYW55IG5lc3RlZCBzY29wZSB0byB0aGUgbGlzdC5cbiAgICAgICAgICAgICBhU291cmNlRWxlbWVudHNEYXRhW25Qb3NpdGlvbl0uYUlkZW50aWZpZXJzLmZvckVhY2goXG4gICAgICAgICAgICAgICAgIGNBdWdtZW50TGlzdChvU291cmNlRWxlbWVudHNEYXRhLmFJZGVudGlmaWVycykpO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIC8vIERpc3RyaWJ1dGUgaWRlbnRpZmllciBuYW1lcyBhbW9uZyBkZXJpdmVkIHByaW1pdGl2ZSB2YWx1ZXMuXG4gICAgICAgICAgIGRvIHsgIC8vIElmIHRoZXJlIHdhcyBhbnkgcHJvZ3Jlc3MsIGZpbmQgYSBiZXR0ZXIgZGlzdHJpYnV0aW9uLlxuICAgICAgICAgICAgIG9Tb2x1dGlvbkJlc3QgPSBvU29sdXRpb25DYW5kaWRhdGU7XG4gICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9Tb2x1dGlvbkNhbmRpZGF0ZS5vUHJpbWl0aXZlVmFsdWVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAvLyBTb3J0IHByaW1pdGl2ZSB2YWx1ZXMgZGVzY2VuZGluZyBieSB0aGVpciB3b3J0aHdoaWxlbmVzcy5cbiAgICAgICAgICAgICAgIG9Tb3VyY2VFbGVtZW50c0RhdGEuYVByaW1pdGl2ZVZhbHVlcy5zb3J0KGNTb3J0UHJpbWl0aXZlVmFsdWVzKTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgb1NvbHV0aW9uQ2FuZGlkYXRlID0gbmV3IFRTb2x1dGlvbigpO1xuICAgICAgICAgICAgIG9Tb3VyY2VFbGVtZW50c0RhdGEuYVByaW1pdGl2ZVZhbHVlcy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICBmRXZhbHVhdGVQcmltaXRpdmVWYWx1ZSk7XG4gICAgICAgICAgICAgb1Njb3BlLmNuYW1lID0gbkluZGV4O1xuICAgICAgICAgICB9IHdoaWxlIChvU29sdXRpb25DYW5kaWRhdGUublNhdmluZ3MgPiBvU29sdXRpb25CZXN0Lm5TYXZpbmdzKTtcbiAgICAgICAgICAgLy8gVGFrZSB0aGUgbmVjZXNzaXR5IG9mIGFkZGluZyBhIHZhcmlhYmxlIHN0YXRlbWVudCBpbnRvIGFjY291bnQuXG4gICAgICAgICAgIGlmICgndmFyJyAhPT0gb1NvdXJjZUVsZW1lbnRzW25Gcm9tXVswXSkge1xuICAgICAgICAgICAgIG9Tb2x1dGlvbkJlc3QublNhdmluZ3MgLT0gb1dlaWdodHMuTl9WQVJJQUJMRV9TVEFURU1FTlRfQUZGSVhBVElPTjtcbiAgICAgICAgICAgfVxuICAgICAgICAgICBpZiAoYkVuY2xvc2UpIHtcbiAgICAgICAgICAgICAvLyBUYWtlIHRoZSBuZWNlc3NpdHkgb2YgZm9ybWluZyBhIGNsb3N1cmUgaW50byBhY2NvdW50LlxuICAgICAgICAgICAgIG9Tb2x1dGlvbkJlc3QublNhdmluZ3MgLT0gb1dlaWdodHMuTl9DTE9TVVJFO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIGlmIChvU29sdXRpb25CZXN0Lm5TYXZpbmdzID4gMCkge1xuICAgICAgICAgICAgIC8vIENyZWF0ZSB2YXJpYWJsZSBkZWNsYXJhdGlvbnMgc3VpdGFibGUgZm9yIFVnbGlmeUpTLlxuICAgICAgICAgICAgIE9iamVjdC5rZXlzKG9Tb2x1dGlvbkJlc3Qub1ByaW1pdGl2ZVZhbHVlcykuZm9yRWFjaChcbiAgICAgICAgICAgICAgICAgY0F1Z21lbnRWYXJpYWJsZURlY2xhcmF0aW9ucyk7XG4gICAgICAgICAgICAgLy8gUmV3cml0ZSBleHByZXNzaW9ucyB0aGF0IGNvbnRhaW4gd29ydGh3aGlsZSBwcmltaXRpdmUgdmFsdWVzLlxuICAgICAgICAgICAgIGZvciAoblBvc2l0aW9uID0gbkZyb207IG5Qb3NpdGlvbiA8PSBuVG87IG5Qb3NpdGlvbiArPSAxKSB7XG4gICAgICAgICAgICAgICBvV2Fsa2VyID0gb1Byb2Nlc3Nvci5hc3Rfd2Fsa2VyKCk7XG4gICAgICAgICAgICAgICBvU291cmNlRWxlbWVudHNbblBvc2l0aW9uXSA9XG4gICAgICAgICAgICAgICAgICAgb1dhbGtlci53aXRoX3dhbGtlcnMoXG4gICAgICAgICAgICAgICAgICAgICAgIG9XYWxrZXJzVHJhbnNmb3JtZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICBjQ29udGV4dChvV2Fsa2VyLCBvU291cmNlRWxlbWVudHNbblBvc2l0aW9uXSkpO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICBpZiAoJ3ZhcicgPT09IG9Tb3VyY2VFbGVtZW50c1tuRnJvbV1bMF0pIHsgIC8vIFJldXNlIHRoZSBzdGF0ZW1lbnQuXG4gICAgICAgICAgICAgICAoLyoqIEB0eXBlIHshQXJyYXkuPCFBcnJheT59ICovIGFWYXJpYWJsZURlY2xhcmF0aW9ucy5yZXZlcnNlKFxuICAgICAgICAgICAgICAgICAgICkpLmZvckVhY2goY0FkZFZhcmlhYmxlRGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgIH0gZWxzZSB7ICAvLyBBZGQgYSB2YXJpYWJsZSBzdGF0ZW1lbnQuXG4gICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgb1NvdXJjZUVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgIG5Gcm9tLFxuICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgWyd2YXInLCBhVmFyaWFibGVEZWNsYXJhdGlvbnNdKTtcbiAgICAgICAgICAgICAgIG5UbyArPSAxO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICBpZiAoYkVuY2xvc2UpIHtcbiAgICAgICAgICAgICAgIC8vIEFkZCBhIGNsb3N1cmUuXG4gICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgb1NvdXJjZUVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgIG5Gcm9tLFxuICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgWydzdGF0JywgWydjYWxsJywgWydmdW5jdGlvbicsIG51bGwsIFtdLCBbXV0sIFtdXV0pO1xuICAgICAgICAgICAgICAgLy8gQ29weSBzb3VyY2UgZWxlbWVudHMgaW50byB0aGUgY2xvc3VyZS5cbiAgICAgICAgICAgICAgIGZvciAoblBvc2l0aW9uID0gblRvICsgMTsgblBvc2l0aW9uID4gbkZyb207IG5Qb3NpdGlvbiAtPSAxKSB7XG4gICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICBvU291cmNlRWxlbWVudHNbbkZyb21dWzFdWzFdWzNdLFxuICAgICAgICAgICAgICAgICAgICAgb1NvdXJjZUVsZW1lbnRzW25Qb3NpdGlvbl0pO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHNvdXJjZSBlbGVtZW50cyBvdXRzaWRlIHRoZSBjbG9zdXJlLlxuICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKFxuICAgICAgICAgICAgICAgICAgIG9Tb3VyY2VFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICBuRnJvbSArIDEsXG4gICAgICAgICAgICAgICAgICAgblRvIC0gbkZyb20gKyAxKTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgaWYgKGJFbmNsb3NlKSB7XG4gICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgYXZhaWxhYmlsaXR5IG9mIGlkZW50aWZpZXIgbmFtZXMuXG4gICAgICAgICAgICAgb1Njb3BlLmNuYW1lID0gbkluZGV4O1xuICAgICAgICAgICB9XG4gICAgICAgICB9O1xuXG4gICAgIG9Tb3VyY2VFbGVtZW50cyA9ICgvKiogQHR5cGUgeyFUU3ludGFjdGljQ29kZVVuaXR9ICovXG4gICAgICAgICBvU3ludGFjdGljQ29kZVVuaXRbYklzR2xvYmFsID8gMSA6IDNdKTtcbiAgICAgaWYgKDAgPT09IG9Tb3VyY2VFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICByZXR1cm47XG4gICAgIH1cbiAgICAgb1Njb3BlID0gYklzR2xvYmFsID8gb1N5bnRhY3RpY0NvZGVVbml0LnNjb3BlIDogb1NvdXJjZUVsZW1lbnRzLnNjb3BlO1xuICAgICAvLyBTa2lwIGEgRGlyZWN0aXZlIFByb2xvZ3VlLlxuICAgICB3aGlsZSAobkFmdGVyRGlyZWN0aXZlUHJvbG9ndWUgPCBvU291cmNlRWxlbWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgICAnZGlyZWN0aXZlJyA9PT0gb1NvdXJjZUVsZW1lbnRzW25BZnRlckRpcmVjdGl2ZVByb2xvZ3VlXVswXSkge1xuICAgICAgIG5BZnRlckRpcmVjdGl2ZVByb2xvZ3VlICs9IDE7XG4gICAgICAgYVNvdXJjZUVsZW1lbnRzRGF0YS5wdXNoKG51bGwpO1xuICAgICB9XG4gICAgIGlmIChvU291cmNlRWxlbWVudHMubGVuZ3RoID09PSBuQWZ0ZXJEaXJlY3RpdmVQcm9sb2d1ZSkge1xuICAgICAgIHJldHVybjtcbiAgICAgfVxuICAgICBmb3IgKG5Qb3NpdGlvbiA9IG5BZnRlckRpcmVjdGl2ZVByb2xvZ3VlO1xuICAgICAgICAgIG5Qb3NpdGlvbiA8IG9Tb3VyY2VFbGVtZW50cy5sZW5ndGg7XG4gICAgICAgICAgblBvc2l0aW9uICs9IDEpIHtcbiAgICAgICBvU291cmNlRWxlbWVudERhdGEgPSBuZXcgVFNvdXJjZUVsZW1lbnRzRGF0YSgpO1xuICAgICAgIG9XYWxrZXIgPSBvUHJvY2Vzc29yLmFzdF93YWxrZXIoKTtcbiAgICAgICAvLyBDbGFzc2lmeSBhIHNvdXJjZSBlbGVtZW50LlxuICAgICAgIC8vIEZpbmQgaXRzIGRlcml2ZWQgcHJpbWl0aXZlIHZhbHVlcyBhbmQgY291bnQgdGhlaXIgb2NjdXJyZW5jZXMuXG4gICAgICAgLy8gRmluZCBhbGwgaWRlbnRpZmllcnMgdXNlZCAoaW5jbHVkaW5nIG5lc3RlZCBzY29wZXMpLlxuICAgICAgIG9XYWxrZXIud2l0aF93YWxrZXJzKFxuICAgICAgICAgICBvV2Fsa2Vycy5vU3VydmV5U291cmNlRWxlbWVudCxcbiAgICAgICAgICAgY0NvbnRleHQob1dhbGtlciwgb1NvdXJjZUVsZW1lbnRzW25Qb3NpdGlvbl0pKTtcbiAgICAgICAvLyBFc3RhYmxpc2ggd2hldGhlciB0aGUgc2NvcGUgaXMgc3RpbGwgd2hvbGx5IGV4YW1pbmFibGUuXG4gICAgICAgYklzV2hvbGx5RXhhbWluYWJsZSA9IGJJc1dob2xseUV4YW1pbmFibGUgJiZcbiAgICAgICAgICAgRVNvdXJjZUVsZW1lbnRDYXRlZ29yaWVzLk5fV0lUSCAhPT0gb1NvdXJjZUVsZW1lbnREYXRhLm5DYXRlZ29yeSAmJlxuICAgICAgICAgICBFU291cmNlRWxlbWVudENhdGVnb3JpZXMuTl9FVkFMICE9PSBvU291cmNlRWxlbWVudERhdGEubkNhdGVnb3J5O1xuICAgICAgIGFTb3VyY2VFbGVtZW50c0RhdGEucHVzaChvU291cmNlRWxlbWVudERhdGEpO1xuICAgICB9XG4gICAgIGlmIChiSXNXaG9sbHlFeGFtaW5hYmxlKSB7ICAvLyBFeGFtaW5lIHRoZSB3aG9sZSBzY29wZS5cbiAgICAgICBmRXhhbWluZVNvdXJjZUVsZW1lbnRzKFxuICAgICAgICAgICBuQWZ0ZXJEaXJlY3RpdmVQcm9sb2d1ZSxcbiAgICAgICAgICAgb1NvdXJjZUVsZW1lbnRzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgIGZhbHNlKTtcbiAgICAgfSBlbHNlIHsgIC8vIEV4YW1pbmUgdW5leGNsdWRlZCByYW5nZXMgb2Ygc291cmNlIGVsZW1lbnRzLlxuICAgICAgIGZvciAoblBvc2l0aW9uID0gb1NvdXJjZUVsZW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBuUG9zaXRpb24gPj0gbkFmdGVyRGlyZWN0aXZlUHJvbG9ndWU7XG4gICAgICAgICAgICBuUG9zaXRpb24gLT0gMSkge1xuICAgICAgICAgb1NvdXJjZUVsZW1lbnREYXRhID0gKC8qKiBAdHlwZSB7IVRTb3VyY2VFbGVtZW50c0RhdGF9ICovXG4gICAgICAgICAgICAgYVNvdXJjZUVsZW1lbnRzRGF0YVtuUG9zaXRpb25dKTtcbiAgICAgICAgIGlmIChFU291cmNlRWxlbWVudENhdGVnb3JpZXMuTl9PVEhFUiA9PT1cbiAgICAgICAgICAgICBvU291cmNlRWxlbWVudERhdGEubkNhdGVnb3J5KSB7XG4gICAgICAgICAgIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIG5Ubykge1xuICAgICAgICAgICAgIG5UbyA9IG5Qb3NpdGlvbjsgIC8vIEluZGljYXRlIHRoZSBlbmQgb2YgYSByYW5nZS5cbiAgICAgICAgICAgfVxuICAgICAgICAgICAvLyBFeGFtaW5lIHRoZSByYW5nZSBpZiBpdCBpbW1lZGlhdGVseSBmb2xsb3dzIGEgRGlyZWN0aXZlIFByb2xvZ3VlLlxuICAgICAgICAgICBpZiAoblBvc2l0aW9uID09PSBuQWZ0ZXJEaXJlY3RpdmVQcm9sb2d1ZSkge1xuICAgICAgICAgICAgIGZFeGFtaW5lU291cmNlRWxlbWVudHMoblBvc2l0aW9uLCBuVG8sIHRydWUpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBuVG8pIHtcbiAgICAgICAgICAgICAvLyBFeGFtaW5lIHRoZSByYW5nZSB0aGF0IGltbWVkaWF0ZWx5IGZvbGxvd3MgdGhpcyBzb3VyY2UgZWxlbWVudC5cbiAgICAgICAgICAgICBmRXhhbWluZVNvdXJjZUVsZW1lbnRzKG5Qb3NpdGlvbiArIDEsIG5UbywgdHJ1ZSk7XG4gICAgICAgICAgICAgblRvID0gdm9pZCAwOyAgLy8gT2JsaXRlcmF0ZSB0aGUgcmFuZ2UuXG4gICAgICAgICAgIH1cbiAgICAgICAgICAgLy8gRXhhbWluZSBuZXN0ZWQgZnVuY3Rpb25zLlxuICAgICAgICAgICBvV2Fsa2VyID0gb1Byb2Nlc3Nvci5hc3Rfd2Fsa2VyKCk7XG4gICAgICAgICAgIG9XYWxrZXIud2l0aF93YWxrZXJzKFxuICAgICAgICAgICAgICAgb1dhbGtlcnMub0V4YW1pbmVGdW5jdGlvbnMsXG4gICAgICAgICAgICAgICBjQ29udGV4dChvV2Fsa2VyLCBvU291cmNlRWxlbWVudHNbblBvc2l0aW9uXSkpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfVxuICAgfShvQWJzdHJhY3RTeW50YXhUcmVlID0gb1Byb2Nlc3Nvci5hc3RfYWRkX3Njb3BlKG9BYnN0cmFjdFN5bnRheFRyZWUpKSk7XG4gIHJldHVybiBvQWJzdHJhY3RTeW50YXhUcmVlO1xufTtcbi8qanNoaW50IHN1YjpmYWxzZSAqL1xuXG4vKiBMb2NhbCBWYXJpYWJsZXM6ICAgICAgKi9cbi8qIG1vZGU6IGpzICAgICAgICAgICAgICAqL1xuLyogY29kaW5nOiB1dGYtOCAgICAgICAgICovXG4vKiBpbmRlbnQtdGFicy1tb2RlOiBuaWwgKi9cbi8qIHRhYi13aWR0aDogMiAgICAgICAgICAqL1xuLyogRW5kOiAgICAgICAgICAgICAgICAgICovXG4vKiB2aW06IHNldCBmdD1qYXZhc2NyaXB0IGZlbmM9dXRmLTggZXQgdHM9MiBzdHM9MiBzdz0yOiAqL1xuLyogOm1vZGU9amF2YXNjcmlwdDpub1RhYnM9dHJ1ZTp0YWJTaXplPTI6aW5kZW50U2l6ZT0yOmRlZXBJbmRlbnQ9dHJ1ZTogKi9cblxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuXG4gIFRoaXMgdmVyc2lvbiBpcyBzdWl0YWJsZSBmb3IgTm9kZS5qcy4gIFdpdGggbWluaW1hbCBjaGFuZ2VzICh0aGVcbiAgZXhwb3J0cyBzdHVmZikgaXQgc2hvdWxkIHdvcmsgb24gYW55IEpTIHBsYXRmb3JtLlxuXG4gIFRoaXMgZmlsZSBjb250YWlucyB0aGUgdG9rZW5pemVyL3BhcnNlci4gIEl0IGlzIGEgcG9ydCB0byBKYXZhU2NyaXB0XG4gIG9mIHBhcnNlLWpzIFsxXSwgYSBKYXZhU2NyaXB0IHBhcnNlciBsaWJyYXJ5IHdyaXR0ZW4gaW4gQ29tbW9uIExpc3BcbiAgYnkgTWFyaWpuIEhhdmVyYmVrZS4gIFRoYW5rIHlvdSBNYXJpam4hXG5cbiAgWzFdIGh0dHA6Ly9tYXJpam4uaGF2ZXJiZWtlLm5sL3BhcnNlLWpzL1xuXG4gIEV4cG9ydGVkIGZ1bmN0aW9uczpcblxuICAgIC0gdG9rZW5pemVyKGNvZGUpIC0tIHJldHVybnMgYSBmdW5jdGlvbi4gIENhbGwgdGhlIHJldHVybmVkXG4gICAgICBmdW5jdGlvbiB0byBmZXRjaCB0aGUgbmV4dCB0b2tlbi5cblxuICAgIC0gcGFyc2UoY29kZSkgLS0gcmV0dXJucyBhbiBBU1Qgb2YgdGhlIGdpdmVuIEphdmFTY3JpcHQgY29kZS5cblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMCAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICBCYXNlZCBvbiBwYXJzZS1qcyAoaHR0cDovL21hcmlqbi5oYXZlcmJla2UubmwvcGFyc2UtanMvKS5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogLS0tLS1bIFRva2VuaXplciAoY29uc3RhbnRzKSBdLS0tLS0gKi9cblxudmFyIEtFWVdPUkRTID0gYXJyYXlfdG9faGFzaChbXG4gICAgICAgIFwiYnJlYWtcIixcbiAgICAgICAgXCJjYXNlXCIsXG4gICAgICAgIFwiY2F0Y2hcIixcbiAgICAgICAgXCJjb25zdFwiLFxuICAgICAgICBcImNvbnRpbnVlXCIsXG4gICAgICAgIFwiZGVidWdnZXJcIixcbiAgICAgICAgXCJkZWZhdWx0XCIsXG4gICAgICAgIFwiZGVsZXRlXCIsXG4gICAgICAgIFwiZG9cIixcbiAgICAgICAgXCJlbHNlXCIsXG4gICAgICAgIFwiZmluYWxseVwiLFxuICAgICAgICBcImZvclwiLFxuICAgICAgICBcImZ1bmN0aW9uXCIsXG4gICAgICAgIFwiaWZcIixcbiAgICAgICAgXCJpblwiLFxuICAgICAgICBcImluc3RhbmNlb2ZcIixcbiAgICAgICAgXCJuZXdcIixcbiAgICAgICAgXCJyZXR1cm5cIixcbiAgICAgICAgXCJzd2l0Y2hcIixcbiAgICAgICAgXCJ0aHJvd1wiLFxuICAgICAgICBcInRyeVwiLFxuICAgICAgICBcInR5cGVvZlwiLFxuICAgICAgICBcInZhclwiLFxuICAgICAgICBcInZvaWRcIixcbiAgICAgICAgXCJ3aGlsZVwiLFxuICAgICAgICBcIndpdGhcIlxuXSk7XG5cbnZhciBSRVNFUlZFRF9XT1JEUyA9IGFycmF5X3RvX2hhc2goW1xuICAgICAgICBcImFic3RyYWN0XCIsXG4gICAgICAgIFwiYm9vbGVhblwiLFxuICAgICAgICBcImJ5dGVcIixcbiAgICAgICAgXCJjaGFyXCIsXG4gICAgICAgIFwiY2xhc3NcIixcbiAgICAgICAgXCJkb3VibGVcIixcbiAgICAgICAgXCJlbnVtXCIsXG4gICAgICAgIFwiZXhwb3J0XCIsXG4gICAgICAgIFwiZXh0ZW5kc1wiLFxuICAgICAgICBcImZpbmFsXCIsXG4gICAgICAgIFwiZmxvYXRcIixcbiAgICAgICAgXCJnb3RvXCIsXG4gICAgICAgIFwiaW1wbGVtZW50c1wiLFxuICAgICAgICBcImltcG9ydFwiLFxuICAgICAgICBcImludFwiLFxuICAgICAgICBcImludGVyZmFjZVwiLFxuICAgICAgICBcImxvbmdcIixcbiAgICAgICAgXCJuYXRpdmVcIixcbiAgICAgICAgXCJwYWNrYWdlXCIsXG4gICAgICAgIFwicHJpdmF0ZVwiLFxuICAgICAgICBcInByb3RlY3RlZFwiLFxuICAgICAgICBcInB1YmxpY1wiLFxuICAgICAgICBcInNob3J0XCIsXG4gICAgICAgIFwic3RhdGljXCIsXG4gICAgICAgIFwic3VwZXJcIixcbiAgICAgICAgXCJzeW5jaHJvbml6ZWRcIixcbiAgICAgICAgXCJ0aHJvd3NcIixcbiAgICAgICAgXCJ0cmFuc2llbnRcIixcbiAgICAgICAgXCJ2b2xhdGlsZVwiXG5dKTtcblxudmFyIEtFWVdPUkRTX0JFRk9SRV9FWFBSRVNTSU9OID0gYXJyYXlfdG9faGFzaChbXG4gICAgICAgIFwicmV0dXJuXCIsXG4gICAgICAgIFwibmV3XCIsXG4gICAgICAgIFwiZGVsZXRlXCIsXG4gICAgICAgIFwidGhyb3dcIixcbiAgICAgICAgXCJlbHNlXCIsXG4gICAgICAgIFwiY2FzZVwiXG5dKTtcblxudmFyIEtFWVdPUkRTX0FUT00gPSBhcnJheV90b19oYXNoKFtcbiAgICAgICAgXCJmYWxzZVwiLFxuICAgICAgICBcIm51bGxcIixcbiAgICAgICAgXCJ0cnVlXCIsXG4gICAgICAgIFwidW5kZWZpbmVkXCJcbl0pO1xuXG52YXIgT1BFUkFUT1JfQ0hBUlMgPSBhcnJheV90b19oYXNoKGNoYXJhY3RlcnMoXCIrLSomJT08PiE/fH5eXCIpKTtcblxudmFyIFJFX0hFWF9OVU1CRVIgPSAvXjB4WzAtOWEtZl0rJC9pO1xudmFyIFJFX09DVF9OVU1CRVIgPSAvXjBbMC03XSskLztcbnZhciBSRV9ERUNfTlVNQkVSID0gL15cXGQqXFwuP1xcZCooPzplWystXT9cXGQqKD86XFxkXFwuP3xcXC4/XFxkKVxcZCopPyQvaTtcblxudmFyIE9QRVJBVE9SUyA9IGFycmF5X3RvX2hhc2goW1xuICAgICAgICBcImluXCIsXG4gICAgICAgIFwiaW5zdGFuY2VvZlwiLFxuICAgICAgICBcInR5cGVvZlwiLFxuICAgICAgICBcIm5ld1wiLFxuICAgICAgICBcInZvaWRcIixcbiAgICAgICAgXCJkZWxldGVcIixcbiAgICAgICAgXCIrK1wiLFxuICAgICAgICBcIi0tXCIsXG4gICAgICAgIFwiK1wiLFxuICAgICAgICBcIi1cIixcbiAgICAgICAgXCIhXCIsXG4gICAgICAgIFwiflwiLFxuICAgICAgICBcIiZcIixcbiAgICAgICAgXCJ8XCIsXG4gICAgICAgIFwiXlwiLFxuICAgICAgICBcIipcIixcbiAgICAgICAgXCIvXCIsXG4gICAgICAgIFwiJVwiLFxuICAgICAgICBcIj4+XCIsXG4gICAgICAgIFwiPDxcIixcbiAgICAgICAgXCI+Pj5cIixcbiAgICAgICAgXCI8XCIsXG4gICAgICAgIFwiPlwiLFxuICAgICAgICBcIjw9XCIsXG4gICAgICAgIFwiPj1cIixcbiAgICAgICAgXCI9PVwiLFxuICAgICAgICBcIj09PVwiLFxuICAgICAgICBcIiE9XCIsXG4gICAgICAgIFwiIT09XCIsXG4gICAgICAgIFwiP1wiLFxuICAgICAgICBcIj1cIixcbiAgICAgICAgXCIrPVwiLFxuICAgICAgICBcIi09XCIsXG4gICAgICAgIFwiLz1cIixcbiAgICAgICAgXCIqPVwiLFxuICAgICAgICBcIiU9XCIsXG4gICAgICAgIFwiPj49XCIsXG4gICAgICAgIFwiPDw9XCIsXG4gICAgICAgIFwiPj4+PVwiLFxuICAgICAgICBcInw9XCIsXG4gICAgICAgIFwiXj1cIixcbiAgICAgICAgXCImPVwiLFxuICAgICAgICBcIiYmXCIsXG4gICAgICAgIFwifHxcIlxuXSk7XG5cbnZhciBXSElURVNQQUNFX0NIQVJTID0gYXJyYXlfdG9faGFzaChjaGFyYWN0ZXJzKFwiIFxcdTAwYTBcXG5cXHJcXHRcXGZcXHUwMDBiXFx1MjAwYlxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFwiKSk7XG5cbnZhciBQVU5DX0JFRk9SRV9FWFBSRVNTSU9OID0gYXJyYXlfdG9faGFzaChjaGFyYWN0ZXJzKFwiW3soLC47OlwiKSk7XG5cbnZhciBQVU5DX0NIQVJTID0gYXJyYXlfdG9faGFzaChjaGFyYWN0ZXJzKFwiW117fSgpLDs6XCIpKTtcblxudmFyIFJFR0VYUF9NT0RJRklFUlMgPSBhcnJheV90b19oYXNoKGNoYXJhY3RlcnMoXCJnbXNpeVwiKSk7XG5cbi8qIC0tLS0tWyBUb2tlbml6ZXIgXS0tLS0tICovXG5cbnZhciBVTklDT0RFID0geyAgLy8gVW5pY29kZSA2LjFcbiAgICAgICAgbGV0dGVyOiBuZXcgUmVnRXhwKFwiW1xcXFx1MDA0MS1cXFxcdTAwNUFcXFxcdTAwNjEtXFxcXHUwMDdBXFxcXHUwMEFBXFxcXHUwMEI1XFxcXHUwMEJBXFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkMxXFxcXHUwMkM2LVxcXFx1MDJEMVxcXFx1MDJFMC1cXFxcdTAyRTRcXFxcdTAyRUNcXFxcdTAyRUVcXFxcdTAzNzAtXFxcXHUwMzc0XFxcXHUwMzc2XFxcXHUwMzc3XFxcXHUwMzdBLVxcXFx1MDM3RFxcXFx1MDM4NlxcXFx1MDM4OC1cXFxcdTAzOEFcXFxcdTAzOENcXFxcdTAzOEUtXFxcXHUwM0ExXFxcXHUwM0EzLVxcXFx1MDNGNVxcXFx1MDNGNy1cXFxcdTA0ODFcXFxcdTA0OEEtXFxcXHUwNTI3XFxcXHUwNTMxLVxcXFx1MDU1NlxcXFx1MDU1OVxcXFx1MDU2MS1cXFxcdTA1ODdcXFxcdTA1RDAtXFxcXHUwNUVBXFxcXHUwNUYwLVxcXFx1MDVGMlxcXFx1MDYyMC1cXFxcdTA2NEFcXFxcdTA2NkVcXFxcdTA2NkZcXFxcdTA2NzEtXFxcXHUwNkQzXFxcXHUwNkQ1XFxcXHUwNkU1XFxcXHUwNkU2XFxcXHUwNkVFXFxcXHUwNkVGXFxcXHUwNkZBLVxcXFx1MDZGQ1xcXFx1MDZGRlxcXFx1MDcxMFxcXFx1MDcxMi1cXFxcdTA3MkZcXFxcdTA3NEQtXFxcXHUwN0E1XFxcXHUwN0IxXFxcXHUwN0NBLVxcXFx1MDdFQVxcXFx1MDdGNFxcXFx1MDdGNVxcXFx1MDdGQVxcXFx1MDgwMC1cXFxcdTA4MTVcXFxcdTA4MUFcXFxcdTA4MjRcXFxcdTA4MjhcXFxcdTA4NDAtXFxcXHUwODU4XFxcXHUwOEEwXFxcXHUwOEEyLVxcXFx1MDhBQ1xcXFx1MDkwNC1cXFxcdTA5MzlcXFxcdTA5M0RcXFxcdTA5NTBcXFxcdTA5NTgtXFxcXHUwOTYxXFxcXHUwOTcxLVxcXFx1MDk3N1xcXFx1MDk3OS1cXFxcdTA5N0ZcXFxcdTA5ODUtXFxcXHUwOThDXFxcXHUwOThGXFxcXHUwOTkwXFxcXHUwOTkzLVxcXFx1MDlBOFxcXFx1MDlBQS1cXFxcdTA5QjBcXFxcdTA5QjJcXFxcdTA5QjYtXFxcXHUwOUI5XFxcXHUwOUJEXFxcXHUwOUNFXFxcXHUwOURDXFxcXHUwOUREXFxcXHUwOURGLVxcXFx1MDlFMVxcXFx1MDlGMFxcXFx1MDlGMVxcXFx1MEEwNS1cXFxcdTBBMEFcXFxcdTBBMEZcXFxcdTBBMTBcXFxcdTBBMTMtXFxcXHUwQTI4XFxcXHUwQTJBLVxcXFx1MEEzMFxcXFx1MEEzMlxcXFx1MEEzM1xcXFx1MEEzNVxcXFx1MEEzNlxcXFx1MEEzOFxcXFx1MEEzOVxcXFx1MEE1OS1cXFxcdTBBNUNcXFxcdTBBNUVcXFxcdTBBNzItXFxcXHUwQTc0XFxcXHUwQTg1LVxcXFx1MEE4RFxcXFx1MEE4Ri1cXFxcdTBBOTFcXFxcdTBBOTMtXFxcXHUwQUE4XFxcXHUwQUFBLVxcXFx1MEFCMFxcXFx1MEFCMlxcXFx1MEFCM1xcXFx1MEFCNS1cXFxcdTBBQjlcXFxcdTBBQkRcXFxcdTBBRDBcXFxcdTBBRTBcXFxcdTBBRTFcXFxcdTBCMDUtXFxcXHUwQjBDXFxcXHUwQjBGXFxcXHUwQjEwXFxcXHUwQjEzLVxcXFx1MEIyOFxcXFx1MEIyQS1cXFxcdTBCMzBcXFxcdTBCMzJcXFxcdTBCMzNcXFxcdTBCMzUtXFxcXHUwQjM5XFxcXHUwQjNEXFxcXHUwQjVDXFxcXHUwQjVEXFxcXHUwQjVGLVxcXFx1MEI2MVxcXFx1MEI3MVxcXFx1MEI4M1xcXFx1MEI4NS1cXFxcdTBCOEFcXFxcdTBCOEUtXFxcXHUwQjkwXFxcXHUwQjkyLVxcXFx1MEI5NVxcXFx1MEI5OVxcXFx1MEI5QVxcXFx1MEI5Q1xcXFx1MEI5RVxcXFx1MEI5RlxcXFx1MEJBM1xcXFx1MEJBNFxcXFx1MEJBOC1cXFxcdTBCQUFcXFxcdTBCQUUtXFxcXHUwQkI5XFxcXHUwQkQwXFxcXHUwQzA1LVxcXFx1MEMwQ1xcXFx1MEMwRS1cXFxcdTBDMTBcXFxcdTBDMTItXFxcXHUwQzI4XFxcXHUwQzJBLVxcXFx1MEMzM1xcXFx1MEMzNS1cXFxcdTBDMzlcXFxcdTBDM0RcXFxcdTBDNThcXFxcdTBDNTlcXFxcdTBDNjBcXFxcdTBDNjFcXFxcdTBDODUtXFxcXHUwQzhDXFxcXHUwQzhFLVxcXFx1MEM5MFxcXFx1MEM5Mi1cXFxcdTBDQThcXFxcdTBDQUEtXFxcXHUwQ0IzXFxcXHUwQ0I1LVxcXFx1MENCOVxcXFx1MENCRFxcXFx1MENERVxcXFx1MENFMFxcXFx1MENFMVxcXFx1MENGMVxcXFx1MENGMlxcXFx1MEQwNS1cXFxcdTBEMENcXFxcdTBEMEUtXFxcXHUwRDEwXFxcXHUwRDEyLVxcXFx1MEQzQVxcXFx1MEQzRFxcXFx1MEQ0RVxcXFx1MEQ2MFxcXFx1MEQ2MVxcXFx1MEQ3QS1cXFxcdTBEN0ZcXFxcdTBEODUtXFxcXHUwRDk2XFxcXHUwRDlBLVxcXFx1MERCMVxcXFx1MERCMy1cXFxcdTBEQkJcXFxcdTBEQkRcXFxcdTBEQzAtXFxcXHUwREM2XFxcXHUwRTAxLVxcXFx1MEUzMFxcXFx1MEUzMlxcXFx1MEUzM1xcXFx1MEU0MC1cXFxcdTBFNDZcXFxcdTBFODFcXFxcdTBFODJcXFxcdTBFODRcXFxcdTBFODdcXFxcdTBFODhcXFxcdTBFOEFcXFxcdTBFOERcXFxcdTBFOTQtXFxcXHUwRTk3XFxcXHUwRTk5LVxcXFx1MEU5RlxcXFx1MEVBMS1cXFxcdTBFQTNcXFxcdTBFQTVcXFxcdTBFQTdcXFxcdTBFQUFcXFxcdTBFQUJcXFxcdTBFQUQtXFxcXHUwRUIwXFxcXHUwRUIyXFxcXHUwRUIzXFxcXHUwRUJEXFxcXHUwRUMwLVxcXFx1MEVDNFxcXFx1MEVDNlxcXFx1MEVEQy1cXFxcdTBFREZcXFxcdTBGMDBcXFxcdTBGNDAtXFxcXHUwRjQ3XFxcXHUwRjQ5LVxcXFx1MEY2Q1xcXFx1MEY4OC1cXFxcdTBGOENcXFxcdTEwMDAtXFxcXHUxMDJBXFxcXHUxMDNGXFxcXHUxMDUwLVxcXFx1MTA1NVxcXFx1MTA1QS1cXFxcdTEwNURcXFxcdTEwNjFcXFxcdTEwNjVcXFxcdTEwNjZcXFxcdTEwNkUtXFxcXHUxMDcwXFxcXHUxMDc1LVxcXFx1MTA4MVxcXFx1MTA4RVxcXFx1MTBBMC1cXFxcdTEwQzVcXFxcdTEwQzdcXFxcdTEwQ0RcXFxcdTEwRDAtXFxcXHUxMEZBXFxcXHUxMEZDLVxcXFx1MTI0OFxcXFx1MTI0QS1cXFxcdTEyNERcXFxcdTEyNTAtXFxcXHUxMjU2XFxcXHUxMjU4XFxcXHUxMjVBLVxcXFx1MTI1RFxcXFx1MTI2MC1cXFxcdTEyODhcXFxcdTEyOEEtXFxcXHUxMjhEXFxcXHUxMjkwLVxcXFx1MTJCMFxcXFx1MTJCMi1cXFxcdTEyQjVcXFxcdTEyQjgtXFxcXHUxMkJFXFxcXHUxMkMwXFxcXHUxMkMyLVxcXFx1MTJDNVxcXFx1MTJDOC1cXFxcdTEyRDZcXFxcdTEyRDgtXFxcXHUxMzEwXFxcXHUxMzEyLVxcXFx1MTMxNVxcXFx1MTMxOC1cXFxcdTEzNUFcXFxcdTEzODAtXFxcXHUxMzhGXFxcXHUxM0EwLVxcXFx1MTNGNFxcXFx1MTQwMS1cXFxcdTE2NkNcXFxcdTE2NkYtXFxcXHUxNjdGXFxcXHUxNjgxLVxcXFx1MTY5QVxcXFx1MTZBMC1cXFxcdTE2RUFcXFxcdTE2RUUtXFxcXHUxNkYwXFxcXHUxNzAwLVxcXFx1MTcwQ1xcXFx1MTcwRS1cXFxcdTE3MTFcXFxcdTE3MjAtXFxcXHUxNzMxXFxcXHUxNzQwLVxcXFx1MTc1MVxcXFx1MTc2MC1cXFxcdTE3NkNcXFxcdTE3NkUtXFxcXHUxNzcwXFxcXHUxNzgwLVxcXFx1MTdCM1xcXFx1MTdEN1xcXFx1MTdEQ1xcXFx1MTgyMC1cXFxcdTE4NzdcXFxcdTE4ODAtXFxcXHUxOEE4XFxcXHUxOEFBXFxcXHUxOEIwLVxcXFx1MThGNVxcXFx1MTkwMC1cXFxcdTE5MUNcXFxcdTE5NTAtXFxcXHUxOTZEXFxcXHUxOTcwLVxcXFx1MTk3NFxcXFx1MTk4MC1cXFxcdTE5QUJcXFxcdTE5QzEtXFxcXHUxOUM3XFxcXHUxQTAwLVxcXFx1MUExNlxcXFx1MUEyMC1cXFxcdTFBNTRcXFxcdTFBQTdcXFxcdTFCMDUtXFxcXHUxQjMzXFxcXHUxQjQ1LVxcXFx1MUI0QlxcXFx1MUI4My1cXFxcdTFCQTBcXFxcdTFCQUVcXFxcdTFCQUZcXFxcdTFCQkEtXFxcXHUxQkU1XFxcXHUxQzAwLVxcXFx1MUMyM1xcXFx1MUM0RC1cXFxcdTFDNEZcXFxcdTFDNUEtXFxcXHUxQzdEXFxcXHUxQ0U5LVxcXFx1MUNFQ1xcXFx1MUNFRS1cXFxcdTFDRjFcXFxcdTFDRjVcXFxcdTFDRjZcXFxcdTFEMDAtXFxcXHUxREJGXFxcXHUxRTAwLVxcXFx1MUYxNVxcXFx1MUYxOC1cXFxcdTFGMURcXFxcdTFGMjAtXFxcXHUxRjQ1XFxcXHUxRjQ4LVxcXFx1MUY0RFxcXFx1MUY1MC1cXFxcdTFGNTdcXFxcdTFGNTlcXFxcdTFGNUJcXFxcdTFGNURcXFxcdTFGNUYtXFxcXHUxRjdEXFxcXHUxRjgwLVxcXFx1MUZCNFxcXFx1MUZCNi1cXFxcdTFGQkNcXFxcdTFGQkVcXFxcdTFGQzItXFxcXHUxRkM0XFxcXHUxRkM2LVxcXFx1MUZDQ1xcXFx1MUZEMC1cXFxcdTFGRDNcXFxcdTFGRDYtXFxcXHUxRkRCXFxcXHUxRkUwLVxcXFx1MUZFQ1xcXFx1MUZGMi1cXFxcdTFGRjRcXFxcdTFGRjYtXFxcXHUxRkZDXFxcXHUyMDcxXFxcXHUyMDdGXFxcXHUyMDkwLVxcXFx1MjA5Q1xcXFx1MjEwMlxcXFx1MjEwN1xcXFx1MjEwQS1cXFxcdTIxMTNcXFxcdTIxMTVcXFxcdTIxMTktXFxcXHUyMTFEXFxcXHUyMTI0XFxcXHUyMTI2XFxcXHUyMTI4XFxcXHUyMTJBLVxcXFx1MjEyRFxcXFx1MjEyRi1cXFxcdTIxMzlcXFxcdTIxM0MtXFxcXHUyMTNGXFxcXHUyMTQ1LVxcXFx1MjE0OVxcXFx1MjE0RVxcXFx1MjE2MC1cXFxcdTIxODhcXFxcdTJDMDAtXFxcXHUyQzJFXFxcXHUyQzMwLVxcXFx1MkM1RVxcXFx1MkM2MC1cXFxcdTJDRTRcXFxcdTJDRUItXFxcXHUyQ0VFXFxcXHUyQ0YyXFxcXHUyQ0YzXFxcXHUyRDAwLVxcXFx1MkQyNVxcXFx1MkQyN1xcXFx1MkQyRFxcXFx1MkQzMC1cXFxcdTJENjdcXFxcdTJENkZcXFxcdTJEODAtXFxcXHUyRDk2XFxcXHUyREEwLVxcXFx1MkRBNlxcXFx1MkRBOC1cXFxcdTJEQUVcXFxcdTJEQjAtXFxcXHUyREI2XFxcXHUyREI4LVxcXFx1MkRCRVxcXFx1MkRDMC1cXFxcdTJEQzZcXFxcdTJEQzgtXFxcXHUyRENFXFxcXHUyREQwLVxcXFx1MkRENlxcXFx1MkREOC1cXFxcdTJEREVcXFxcdTJFMkZcXFxcdTMwMDUtXFxcXHUzMDA3XFxcXHUzMDIxLVxcXFx1MzAyOVxcXFx1MzAzMS1cXFxcdTMwMzVcXFxcdTMwMzgtXFxcXHUzMDNDXFxcXHUzMDQxLVxcXFx1MzA5NlxcXFx1MzA5RC1cXFxcdTMwOUZcXFxcdTMwQTEtXFxcXHUzMEZBXFxcXHUzMEZDLVxcXFx1MzBGRlxcXFx1MzEwNS1cXFxcdTMxMkRcXFxcdTMxMzEtXFxcXHUzMThFXFxcXHUzMUEwLVxcXFx1MzFCQVxcXFx1MzFGMC1cXFxcdTMxRkZcXFxcdTM0MDAtXFxcXHU0REI1XFxcXHU0RTAwLVxcXFx1OUZDQ1xcXFx1QTAwMC1cXFxcdUE0OENcXFxcdUE0RDAtXFxcXHVBNEZEXFxcXHVBNTAwLVxcXFx1QTYwQ1xcXFx1QTYxMC1cXFxcdUE2MUZcXFxcdUE2MkFcXFxcdUE2MkJcXFxcdUE2NDAtXFxcXHVBNjZFXFxcXHVBNjdGLVxcXFx1QTY5N1xcXFx1QTZBMC1cXFxcdUE2RUZcXFxcdUE3MTctXFxcXHVBNzFGXFxcXHVBNzIyLVxcXFx1QTc4OFxcXFx1QTc4Qi1cXFxcdUE3OEVcXFxcdUE3OTAtXFxcXHVBNzkzXFxcXHVBN0EwLVxcXFx1QTdBQVxcXFx1QTdGOC1cXFxcdUE4MDFcXFxcdUE4MDMtXFxcXHVBODA1XFxcXHVBODA3LVxcXFx1QTgwQVxcXFx1QTgwQy1cXFxcdUE4MjJcXFxcdUE4NDAtXFxcXHVBODczXFxcXHVBODgyLVxcXFx1QThCM1xcXFx1QThGMi1cXFxcdUE4RjdcXFxcdUE4RkJcXFxcdUE5MEEtXFxcXHVBOTI1XFxcXHVBOTMwLVxcXFx1QTk0NlxcXFx1QTk2MC1cXFxcdUE5N0NcXFxcdUE5ODQtXFxcXHVBOUIyXFxcXHVBOUNGXFxcXHVBQTAwLVxcXFx1QUEyOFxcXFx1QUE0MC1cXFxcdUFBNDJcXFxcdUFBNDQtXFxcXHVBQTRCXFxcXHVBQTYwLVxcXFx1QUE3NlxcXFx1QUE3QVxcXFx1QUE4MC1cXFxcdUFBQUZcXFxcdUFBQjFcXFxcdUFBQjVcXFxcdUFBQjZcXFxcdUFBQjktXFxcXHVBQUJEXFxcXHVBQUMwXFxcXHVBQUMyXFxcXHVBQURCLVxcXFx1QUFERFxcXFx1QUFFMC1cXFxcdUFBRUFcXFxcdUFBRjItXFxcXHVBQUY0XFxcXHVBQjAxLVxcXFx1QUIwNlxcXFx1QUIwOS1cXFxcdUFCMEVcXFxcdUFCMTEtXFxcXHVBQjE2XFxcXHVBQjIwLVxcXFx1QUIyNlxcXFx1QUIyOC1cXFxcdUFCMkVcXFxcdUFCQzAtXFxcXHVBQkUyXFxcXHVBQzAwLVxcXFx1RDdBM1xcXFx1RDdCMC1cXFxcdUQ3QzZcXFxcdUQ3Q0ItXFxcXHVEN0ZCXFxcXHVGOTAwLVxcXFx1RkE2RFxcXFx1RkE3MC1cXFxcdUZBRDlcXFxcdUZCMDAtXFxcXHVGQjA2XFxcXHVGQjEzLVxcXFx1RkIxN1xcXFx1RkIxRFxcXFx1RkIxRi1cXFxcdUZCMjhcXFxcdUZCMkEtXFxcXHVGQjM2XFxcXHVGQjM4LVxcXFx1RkIzQ1xcXFx1RkIzRVxcXFx1RkI0MFxcXFx1RkI0MVxcXFx1RkI0M1xcXFx1RkI0NFxcXFx1RkI0Ni1cXFxcdUZCQjFcXFxcdUZCRDMtXFxcXHVGRDNEXFxcXHVGRDUwLVxcXFx1RkQ4RlxcXFx1RkQ5Mi1cXFxcdUZEQzdcXFxcdUZERjAtXFxcXHVGREZCXFxcXHVGRTcwLVxcXFx1RkU3NFxcXFx1RkU3Ni1cXFxcdUZFRkNcXFxcdUZGMjEtXFxcXHVGRjNBXFxcXHVGRjQxLVxcXFx1RkY1QVxcXFx1RkY2Ni1cXFxcdUZGQkVcXFxcdUZGQzItXFxcXHVGRkM3XFxcXHVGRkNBLVxcXFx1RkZDRlxcXFx1RkZEMi1cXFxcdUZGRDdcXFxcdUZGREEtXFxcXHVGRkRDXVwiKSxcbiAgICAgICAgY29tYmluaW5nX21hcms6IG5ldyBSZWdFeHAoXCJbXFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MDQ4My1cXFxcdTA0ODdcXFxcdTA1OTEtXFxcXHUwNUJEXFxcXHUwNUJGXFxcXHUwNUMxXFxcXHUwNUMyXFxcXHUwNUM0XFxcXHUwNUM1XFxcXHUwNUM3XFxcXHUwNjEwLVxcXFx1MDYxQVxcXFx1MDY0Qi1cXFxcdTA2NUZcXFxcdTA2NzBcXFxcdTA2RDYtXFxcXHUwNkRDXFxcXHUwNkRGLVxcXFx1MDZFNFxcXFx1MDZFN1xcXFx1MDZFOFxcXFx1MDZFQS1cXFxcdTA2RURcXFxcdTA3MTFcXFxcdTA3MzAtXFxcXHUwNzRBXFxcXHUwN0E2LVxcXFx1MDdCMFxcXFx1MDdFQi1cXFxcdTA3RjNcXFxcdTA4MTYtXFxcXHUwODE5XFxcXHUwODFCLVxcXFx1MDgyM1xcXFx1MDgyNS1cXFxcdTA4MjdcXFxcdTA4MjktXFxcXHUwODJEXFxcXHUwODU5LVxcXFx1MDg1QlxcXFx1MDhFNC1cXFxcdTA4RkVcXFxcdTA5MDAtXFxcXHUwOTAzXFxcXHUwOTNBLVxcXFx1MDkzQ1xcXFx1MDkzRS1cXFxcdTA5NEZcXFxcdTA5NTEtXFxcXHUwOTU3XFxcXHUwOTYyXFxcXHUwOTYzXFxcXHUwOTgxLVxcXFx1MDk4M1xcXFx1MDlCQ1xcXFx1MDlCRS1cXFxcdTA5QzRcXFxcdTA5QzdcXFxcdTA5QzhcXFxcdTA5Q0ItXFxcXHUwOUNEXFxcXHUwOUQ3XFxcXHUwOUUyXFxcXHUwOUUzXFxcXHUwQTAxLVxcXFx1MEEwM1xcXFx1MEEzQ1xcXFx1MEEzRS1cXFxcdTBBNDJcXFxcdTBBNDdcXFxcdTBBNDhcXFxcdTBBNEItXFxcXHUwQTREXFxcXHUwQTUxXFxcXHUwQTcwXFxcXHUwQTcxXFxcXHUwQTc1XFxcXHUwQTgxLVxcXFx1MEE4M1xcXFx1MEFCQ1xcXFx1MEFCRS1cXFxcdTBBQzVcXFxcdTBBQzctXFxcXHUwQUM5XFxcXHUwQUNCLVxcXFx1MEFDRFxcXFx1MEFFMlxcXFx1MEFFM1xcXFx1MEIwMS1cXFxcdTBCMDNcXFxcdTBCM0NcXFxcdTBCM0UtXFxcXHUwQjQ0XFxcXHUwQjQ3XFxcXHUwQjQ4XFxcXHUwQjRCLVxcXFx1MEI0RFxcXFx1MEI1NlxcXFx1MEI1N1xcXFx1MEI2MlxcXFx1MEI2M1xcXFx1MEI4MlxcXFx1MEJCRS1cXFxcdTBCQzJcXFxcdTBCQzYtXFxcXHUwQkM4XFxcXHUwQkNBLVxcXFx1MEJDRFxcXFx1MEJEN1xcXFx1MEMwMS1cXFxcdTBDMDNcXFxcdTBDM0UtXFxcXHUwQzQ0XFxcXHUwQzQ2LVxcXFx1MEM0OFxcXFx1MEM0QS1cXFxcdTBDNERcXFxcdTBDNTVcXFxcdTBDNTZcXFxcdTBDNjJcXFxcdTBDNjNcXFxcdTBDODJcXFxcdTBDODNcXFxcdTBDQkNcXFxcdTBDQkUtXFxcXHUwQ0M0XFxcXHUwQ0M2LVxcXFx1MENDOFxcXFx1MENDQS1cXFxcdTBDQ0RcXFxcdTBDRDVcXFxcdTBDRDZcXFxcdTBDRTJcXFxcdTBDRTNcXFxcdTBEMDJcXFxcdTBEMDNcXFxcdTBEM0UtXFxcXHUwRDQ0XFxcXHUwRDQ2LVxcXFx1MEQ0OFxcXFx1MEQ0QS1cXFxcdTBENERcXFxcdTBENTdcXFxcdTBENjJcXFxcdTBENjNcXFxcdTBEODJcXFxcdTBEODNcXFxcdTBEQ0FcXFxcdTBEQ0YtXFxcXHUwREQ0XFxcXHUwREQ2XFxcXHUwREQ4LVxcXFx1MERERlxcXFx1MERGMlxcXFx1MERGM1xcXFx1MEUzMVxcXFx1MEUzNC1cXFxcdTBFM0FcXFxcdTBFNDctXFxcXHUwRTRFXFxcXHUwRUIxXFxcXHUwRUI0LVxcXFx1MEVCOVxcXFx1MEVCQlxcXFx1MEVCQ1xcXFx1MEVDOC1cXFxcdTBFQ0RcXFxcdTBGMThcXFxcdTBGMTlcXFxcdTBGMzVcXFxcdTBGMzdcXFxcdTBGMzlcXFxcdTBGM0VcXFxcdTBGM0ZcXFxcdTBGNzEtXFxcXHUwRjg0XFxcXHUwRjg2XFxcXHUwRjg3XFxcXHUwRjhELVxcXFx1MEY5N1xcXFx1MEY5OS1cXFxcdTBGQkNcXFxcdTBGQzZcXFxcdTEwMkItXFxcXHUxMDNFXFxcXHUxMDU2LVxcXFx1MTA1OVxcXFx1MTA1RS1cXFxcdTEwNjBcXFxcdTEwNjItXFxcXHUxMDY0XFxcXHUxMDY3LVxcXFx1MTA2RFxcXFx1MTA3MS1cXFxcdTEwNzRcXFxcdTEwODItXFxcXHUxMDhEXFxcXHUxMDhGXFxcXHUxMDlBLVxcXFx1MTA5RFxcXFx1MTM1RC1cXFxcdTEzNUZcXFxcdTE3MTItXFxcXHUxNzE0XFxcXHUxNzMyLVxcXFx1MTczNFxcXFx1MTc1MlxcXFx1MTc1M1xcXFx1MTc3MlxcXFx1MTc3M1xcXFx1MTdCNC1cXFxcdTE3RDNcXFxcdTE3RERcXFxcdTE4MEItXFxcXHUxODBEXFxcXHUxOEE5XFxcXHUxOTIwLVxcXFx1MTkyQlxcXFx1MTkzMC1cXFxcdTE5M0JcXFxcdTE5QjAtXFxcXHUxOUMwXFxcXHUxOUM4XFxcXHUxOUM5XFxcXHUxQTE3LVxcXFx1MUExQlxcXFx1MUE1NS1cXFxcdTFBNUVcXFxcdTFBNjAtXFxcXHUxQTdDXFxcXHUxQTdGXFxcXHUxQjAwLVxcXFx1MUIwNFxcXFx1MUIzNC1cXFxcdTFCNDRcXFxcdTFCNkItXFxcXHUxQjczXFxcXHUxQjgwLVxcXFx1MUI4MlxcXFx1MUJBMS1cXFxcdTFCQURcXFxcdTFCRTYtXFxcXHUxQkYzXFxcXHUxQzI0LVxcXFx1MUMzN1xcXFx1MUNEMC1cXFxcdTFDRDJcXFxcdTFDRDQtXFxcXHUxQ0U4XFxcXHUxQ0VEXFxcXHUxQ0YyLVxcXFx1MUNGNFxcXFx1MURDMC1cXFxcdTFERTZcXFxcdTFERkMtXFxcXHUxREZGXFxcXHUyMEQwLVxcXFx1MjBEQ1xcXFx1MjBFMVxcXFx1MjBFNS1cXFxcdTIwRjBcXFxcdTJDRUYtXFxcXHUyQ0YxXFxcXHUyRDdGXFxcXHUyREUwLVxcXFx1MkRGRlxcXFx1MzAyQS1cXFxcdTMwMkZcXFxcdTMwOTlcXFxcdTMwOUFcXFxcdUE2NkZcXFxcdUE2NzQtXFxcXHVBNjdEXFxcXHVBNjlGXFxcXHVBNkYwXFxcXHVBNkYxXFxcXHVBODAyXFxcXHVBODA2XFxcXHVBODBCXFxcXHVBODIzLVxcXFx1QTgyN1xcXFx1QTg4MFxcXFx1QTg4MVxcXFx1QThCNC1cXFxcdUE4QzRcXFxcdUE4RTAtXFxcXHVBOEYxXFxcXHVBOTI2LVxcXFx1QTkyRFxcXFx1QTk0Ny1cXFxcdUE5NTNcXFxcdUE5ODAtXFxcXHVBOTgzXFxcXHVBOUIzLVxcXFx1QTlDMFxcXFx1QUEyOS1cXFxcdUFBMzZcXFxcdUFBNDNcXFxcdUFBNENcXFxcdUFBNERcXFxcdUFBN0JcXFxcdUFBQjBcXFxcdUFBQjItXFxcXHVBQUI0XFxcXHVBQUI3XFxcXHVBQUI4XFxcXHVBQUJFXFxcXHVBQUJGXFxcXHVBQUMxXFxcXHVBQUVCLVxcXFx1QUFFRlxcXFx1QUFGNVxcXFx1QUFGNlxcXFx1QUJFMy1cXFxcdUFCRUFcXFxcdUFCRUNcXFxcdUFCRURcXFxcdUZCMUVcXFxcdUZFMDAtXFxcXHVGRTBGXFxcXHVGRTIwLVxcXFx1RkUyNl1cIiksXG4gICAgICAgIGNvbm5lY3Rvcl9wdW5jdHVhdGlvbjogbmV3IFJlZ0V4cChcIltcXFxcdTAwNUZcXFxcdTIwM0ZcXFxcdTIwNDBcXFxcdTIwNTRcXFxcdUZFMzNcXFxcdUZFMzRcXFxcdUZFNEQtXFxcXHVGRTRGXFxcXHVGRjNGXVwiKSxcbiAgICAgICAgZGlnaXQ6IG5ldyBSZWdFeHAoXCJbXFxcXHUwMDMwLVxcXFx1MDAzOVxcXFx1MDY2MC1cXFxcdTA2NjlcXFxcdTA2RjAtXFxcXHUwNkY5XFxcXHUwN0MwLVxcXFx1MDdDOVxcXFx1MDk2Ni1cXFxcdTA5NkZcXFxcdTA5RTYtXFxcXHUwOUVGXFxcXHUwQTY2LVxcXFx1MEE2RlxcXFx1MEFFNi1cXFxcdTBBRUZcXFxcdTBCNjYtXFxcXHUwQjZGXFxcXHUwQkU2LVxcXFx1MEJFRlxcXFx1MEM2Ni1cXFxcdTBDNkZcXFxcdTBDRTYtXFxcXHUwQ0VGXFxcXHUwRDY2LVxcXFx1MEQ2RlxcXFx1MEU1MC1cXFxcdTBFNTlcXFxcdTBFRDAtXFxcXHUwRUQ5XFxcXHUwRjIwLVxcXFx1MEYyOVxcXFx1MTA0MC1cXFxcdTEwNDlcXFxcdTEwOTAtXFxcXHUxMDk5XFxcXHUxN0UwLVxcXFx1MTdFOVxcXFx1MTgxMC1cXFxcdTE4MTlcXFxcdTE5NDYtXFxcXHUxOTRGXFxcXHUxOUQwLVxcXFx1MTlEOVxcXFx1MUE4MC1cXFxcdTFBODlcXFxcdTFBOTAtXFxcXHUxQTk5XFxcXHUxQjUwLVxcXFx1MUI1OVxcXFx1MUJCMC1cXFxcdTFCQjlcXFxcdTFDNDAtXFxcXHUxQzQ5XFxcXHUxQzUwLVxcXFx1MUM1OVxcXFx1QTYyMC1cXFxcdUE2MjlcXFxcdUE4RDAtXFxcXHVBOEQ5XFxcXHVBOTAwLVxcXFx1QTkwOVxcXFx1QTlEMC1cXFxcdUE5RDlcXFxcdUFBNTAtXFxcXHVBQTU5XFxcXHVBQkYwLVxcXFx1QUJGOVxcXFx1RkYxMC1cXFxcdUZGMTldXCIpXG59O1xuXG5mdW5jdGlvbiBpc19sZXR0ZXIoY2gpIHtcbiAgICAgICAgcmV0dXJuIFVOSUNPREUubGV0dGVyLnRlc3QoY2gpO1xufTtcblxuZnVuY3Rpb24gaXNfZGlnaXQoY2gpIHtcbiAgICAgICAgY2ggPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICByZXR1cm4gY2ggPj0gNDggJiYgY2ggPD0gNTc7XG59O1xuXG5mdW5jdGlvbiBpc191bmljb2RlX2RpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiBVTklDT0RFLmRpZ2l0LnRlc3QoY2gpO1xufVxuXG5mdW5jdGlvbiBpc19hbHBoYW51bWVyaWNfY2hhcihjaCkge1xuICAgICAgICByZXR1cm4gaXNfZGlnaXQoY2gpIHx8IGlzX2xldHRlcihjaCk7XG59O1xuXG5mdW5jdGlvbiBpc191bmljb2RlX2NvbWJpbmluZ19tYXJrKGNoKSB7XG4gICAgICAgIHJldHVybiBVTklDT0RFLmNvbWJpbmluZ19tYXJrLnRlc3QoY2gpO1xufTtcblxuZnVuY3Rpb24gaXNfdW5pY29kZV9jb25uZWN0b3JfcHVuY3R1YXRpb24oY2gpIHtcbiAgICAgICAgcmV0dXJuIFVOSUNPREUuY29ubmVjdG9yX3B1bmN0dWF0aW9uLnRlc3QoY2gpO1xufTtcblxuZnVuY3Rpb24gaXNfaWRlbnRpZmllcl9zdGFydChjaCkge1xuICAgICAgICByZXR1cm4gY2ggPT0gXCIkXCIgfHwgY2ggPT0gXCJfXCIgfHwgaXNfbGV0dGVyKGNoKTtcbn07XG5cbmZ1bmN0aW9uIGlzX2lkZW50aWZpZXJfY2hhcihjaCkge1xuICAgICAgICByZXR1cm4gaXNfaWRlbnRpZmllcl9zdGFydChjaClcbiAgICAgICAgICAgICAgICB8fCBpc191bmljb2RlX2NvbWJpbmluZ19tYXJrKGNoKVxuICAgICAgICAgICAgICAgIHx8IGlzX3VuaWNvZGVfZGlnaXQoY2gpXG4gICAgICAgICAgICAgICAgfHwgaXNfdW5pY29kZV9jb25uZWN0b3JfcHVuY3R1YXRpb24oY2gpXG4gICAgICAgICAgICAgICAgfHwgY2ggPT0gXCJcXHUyMDBjXCIgLy8gemVyby13aWR0aCBub24tam9pbmVyIDxaV05KPlxuICAgICAgICAgICAgICAgIHx8IGNoID09IFwiXFx1MjAwZFwiIC8vIHplcm8td2lkdGggam9pbmVyIDxaV0o+IChpbiBteSBFQ01BLTI2MiBQREYsIHRoaXMgaXMgYWxzbyAyMDBjKVxuICAgICAgICA7XG59O1xuXG5mdW5jdGlvbiBwYXJzZV9qc19udW1iZXIobnVtKSB7XG4gICAgICAgIGlmIChSRV9IRVhfTlVNQkVSLnRlc3QobnVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChudW0uc3Vic3RyKDIpLCAxNik7XG4gICAgICAgIH0gZWxzZSBpZiAoUkVfT0NUX05VTUJFUi50ZXN0KG51bSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtLnN1YnN0cigxKSwgOCk7XG4gICAgICAgIH0gZWxzZSBpZiAoUkVfREVDX05VTUJFUi50ZXN0KG51bSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChudW0pO1xuICAgICAgICB9XG59O1xuXG5mdW5jdGlvbiBKU19QYXJzZV9FcnJvcihtZXNzYWdlLCBsaW5lLCBjb2wsIHBvcykge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lICsgMTtcbiAgICAgICAgdGhpcy5jb2wgPSBjb2wgKyAxO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcyArIDE7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbn07XG5cbkpTX1BhcnNlX0Vycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlICsgXCIgKGxpbmU6IFwiICsgdGhpcy5saW5lICsgXCIsIGNvbDogXCIgKyB0aGlzLmNvbCArIFwiLCBwb3M6IFwiICsgdGhpcy5wb3MgKyBcIilcIiArIFwiXFxuXFxuXCIgKyB0aGlzLnN0YWNrO1xufTtcblxuZnVuY3Rpb24ganNfZXJyb3IobWVzc2FnZSwgbGluZSwgY29sLCBwb3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpTX1BhcnNlX0Vycm9yKG1lc3NhZ2UsIGxpbmUsIGNvbCwgcG9zKTtcbn07XG5cbmZ1bmN0aW9uIGlzX3Rva2VuKHRva2VuLCB0eXBlLCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRva2VuLnR5cGUgPT0gdHlwZSAmJiAodmFsID09IG51bGwgfHwgdG9rZW4udmFsdWUgPT0gdmFsKTtcbn07XG5cbnZhciBFWF9FT0YgPSB7fTtcblxuZnVuY3Rpb24gdG9rZW5pemVyKCRURVhUKSB7XG5cbiAgICAgICAgdmFyIFMgPSB7XG4gICAgICAgICAgICAgICAgdGV4dCAgICAgICAgICAgIDogJFRFWFQucmVwbGFjZSgvXFxyXFxuP3xbXFxuXFx1MjAyOFxcdTIwMjldL2csIFwiXFxuXCIpLnJlcGxhY2UoL15cXHVGRUZGLywgJycpLFxuICAgICAgICAgICAgICAgIHBvcyAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgdG9rcG9zICAgICAgICAgIDogMCxcbiAgICAgICAgICAgICAgICBsaW5lICAgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgICAgIHRva2xpbmUgICAgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgY29sICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgICAgICB0b2tjb2wgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgICAgIG5ld2xpbmVfYmVmb3JlICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlZ2V4X2FsbG93ZWQgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbW1lbnRzX2JlZm9yZSA6IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcGVlaygpIHsgcmV0dXJuIFMudGV4dC5jaGFyQXQoUy5wb3MpOyB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG5leHQoc2lnbmFsX2VvZiwgaW5fc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoID0gUy50ZXh0LmNoYXJBdChTLnBvcysrKTtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmFsX2VvZiAmJiAhY2gpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFWF9FT0Y7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMubmV3bGluZV9iZWZvcmUgPSBTLm5ld2xpbmVfYmVmb3JlIHx8ICFpbl9zdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICArK1MubGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMuY29sID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytTLmNvbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGVvZigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIVMucGVlaygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGZpbmQod2hhdCwgc2lnbmFsX2VvZikge1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBTLnRleHQuaW5kZXhPZih3aGF0LCBTLnBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25hbF9lb2YgJiYgcG9zID09IC0xKSB0aHJvdyBFWF9FT0Y7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBzdGFydF90b2tlbigpIHtcbiAgICAgICAgICAgICAgICBTLnRva2xpbmUgPSBTLmxpbmU7XG4gICAgICAgICAgICAgICAgUy50b2tjb2wgPSBTLmNvbDtcbiAgICAgICAgICAgICAgICBTLnRva3BvcyA9IFMucG9zO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHRva2VuKHR5cGUsIHZhbHVlLCBpc19jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgUy5yZWdleF9hbGxvd2VkID0gKCh0eXBlID09IFwib3BlcmF0b3JcIiAmJiAhSE9QKFVOQVJZX1BPU1RGSVgsIHZhbHVlKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGUgPT0gXCJrZXl3b3JkXCIgJiYgSE9QKEtFWVdPUkRTX0JFRk9SRV9FWFBSRVNTSU9OLCB2YWx1ZSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlID09IFwicHVuY1wiICYmIEhPUChQVU5DX0JFRk9SRV9FWFBSRVNTSU9OLCB2YWx1ZSkpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAgIDogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICA6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSAgIDogUy50b2tsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sICAgIDogUy50b2tjb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgICAgOiBTLnRva3BvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvcyA6IFMucG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmxiICAgIDogUy5uZXdsaW5lX2JlZm9yZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKCFpc19jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQuY29tbWVudHNfYmVmb3JlID0gUy5jb21tZW50c19iZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBTLmNvbW1lbnRzX2JlZm9yZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBub3RlIG9mIGFueSBuZXdsaW5lcyBpbiB0aGUgY29tbWVudHMgdGhhdCBjYW1lIGJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJldC5jb21tZW50c19iZWZvcmUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0Lm5sYiA9IHJldC5ubGIgfHwgcmV0LmNvbW1lbnRzX2JlZm9yZVtpXS5ubGI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFMubmV3bGluZV9iZWZvcmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHNraXBfd2hpdGVzcGFjZSgpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoSE9QKFdISVRFU1BBQ0VfQ0hBUlMsIHBlZWsoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZF93aGlsZShwcmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IFwiXCIsIGNoID0gcGVlaygpLCBpID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY2ggJiYgcHJlZChjaCwgaSsrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ICs9IG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gcGVlaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlX2Vycm9yKGVycikge1xuICAgICAgICAgICAgICAgIGpzX2Vycm9yKGVyciwgUy50b2tsaW5lLCBTLnRva2NvbCwgUy50b2twb3MpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRfbnVtKHByZWZpeCkge1xuICAgICAgICAgICAgICAgIHZhciBoYXNfZSA9IGZhbHNlLCBhZnRlcl9lID0gZmFsc2UsIGhhc194ID0gZmFsc2UsIGhhc19kb3QgPSBwcmVmaXggPT0gXCIuXCI7XG4gICAgICAgICAgICAgICAgdmFyIG51bSA9IHJlYWRfd2hpbGUoZnVuY3Rpb24oY2gsIGkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09IFwieFwiIHx8IGNoID09IFwiWFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNfeCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzX3ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNfeCAmJiAoY2ggPT0gXCJFXCIgfHwgY2ggPT0gXCJlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNfZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzX2UgPSBhZnRlcl9lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PSBcIi1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWZ0ZXJfZSB8fCAoaSA9PSAwICYmICFwcmVmaXgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09IFwiK1wiKSByZXR1cm4gYWZ0ZXJfZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyX2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PSBcIi5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc19kb3QgJiYgIWhhc194ICYmICFoYXNfZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzX2RvdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc19hbHBoYW51bWVyaWNfY2hhcihjaCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHByZWZpeClcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHByZWZpeCArIG51bTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsaWQgPSBwYXJzZV9qc19udW1iZXIobnVtKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHZhbGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuKFwibnVtXCIsIHZhbGlkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VfZXJyb3IoXCJJbnZhbGlkIHN5bnRheDogXCIgKyBudW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiByZWFkX2VzY2FwZWRfY2hhcihpbl9zdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2ggPSBuZXh0KHRydWUsIGluX3N0cmluZyk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiblwiIDogcmV0dXJuIFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyXCIgOiByZXR1cm4gXCJcXHJcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRcIiA6IHJldHVybiBcIlxcdFwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYlwiIDogcmV0dXJuIFwiXFxiXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2XCIgOiByZXR1cm4gXCJcXHUwMDBiXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmXCIgOiByZXR1cm4gXCJcXGZcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIjBcIiA6IHJldHVybiBcIlxcMFwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwieFwiIDogcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoaGV4X2J5dGVzKDIpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInVcIiA6IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGhleF9ieXRlcyg0KSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJcXG5cIjogcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgIDogcmV0dXJuIGNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBoZXhfYnl0ZXMobikge1xuICAgICAgICAgICAgICAgIHZhciBudW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoOyBuID4gMDsgLS1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlnaXQgPSBwYXJzZUludChuZXh0KHRydWUpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oZGlnaXQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZV9lcnJvcihcIkludmFsaWQgaGV4LWNoYXJhY3RlciBwYXR0ZXJuIGluIHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IChudW0gPDwgNCkgfCBkaWdpdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiByZWFkX3N0cmluZygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aF9lb2ZfZXJyb3IoXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcXVvdGUgPSBuZXh0KCksIHJldCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaCA9IG5leHQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlYWQgT2N0YWxFc2NhcGVTZXF1ZW5jZSAoWFhYOiBkZXByZWNhdGVkIGlmIFwic3RyaWN0IG1vZGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTL2lzc3Vlcy8xNzhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2N0YWxfbGVuID0gMCwgZmlyc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gcmVhZF93aGlsZShmdW5jdGlvbihjaCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPj0gXCIwXCIgJiYgY2ggPD0gXCI3XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICsrb2N0YWxfbGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpcnN0IDw9IFwiM1wiICYmIG9jdGFsX2xlbiA8PSAyKSByZXR1cm4gKytvY3RhbF9sZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpcnN0ID49IFwiNFwiICYmIG9jdGFsX2xlbiA8PSAxKSByZXR1cm4gKytvY3RhbF9sZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9jdGFsX2xlbiA+IDApIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChjaCwgOCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgY2ggPSByZWFkX2VzY2FwZWRfY2hhcih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PSBxdW90ZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbihcInN0cmluZ1wiLCByZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRfbGluZV9jb21tZW50KCkge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGZpbmQoXCJcXG5cIiksIHJldDtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gUy50ZXh0LnN1YnN0cihTLnBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBTLnBvcyA9IFMudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IFMudGV4dC5zdWJzdHJpbmcoUy5wb3MsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgUy5wb3MgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4oXCJjb21tZW50MVwiLCByZXQsIHRydWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRfbXVsdGlsaW5lX2NvbW1lbnQoKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB3aXRoX2VvZl9lcnJvcihcIlVudGVybWluYXRlZCBtdWx0aWxpbmUgY29tbWVudFwiLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBmaW5kKFwiKi9cIiwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IFMudGV4dC5zdWJzdHJpbmcoUy5wb3MsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgUy5wb3MgPSBpICsgMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMubGluZSArPSB0ZXh0LnNwbGl0KFwiXFxuXCIpLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBTLm5ld2xpbmVfYmVmb3JlID0gUy5uZXdsaW5lX2JlZm9yZSB8fCB0ZXh0LmluZGV4T2YoXCJcXG5cIikgPj0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUy9pc3N1ZXMvI2lzc3VlLzEwMFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9eQGNjX29uL2kudGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuKFwiV0FSTklORzogYXQgbGluZSBcIiArIFMubGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oXCIqKiogRm91bmQgXFxcImNvbmRpdGlvbmFsIGNvbW1lbnRcXFwiOiBcIiArIHRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuKFwiKioqIFVnbGlmeUpTIERJU0NBUkRTIEFMTCBDT01NRU5UUy4gIFRoaXMgbWVhbnMgeW91ciBjb2RlIG1pZ2h0IG5vIGxvbmdlciB3b3JrIHByb3Blcmx5IGluIEludGVybmV0IEV4cGxvcmVyLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuKFwiY29tbWVudDJcIiwgdGV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZF9uYW1lKCkge1xuICAgICAgICAgICAgICAgIHZhciBiYWNrc2xhc2ggPSBmYWxzZSwgbmFtZSA9IFwiXCIsIGNoLCBlc2NhcGVkID0gZmFsc2UsIGhleDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGNoID0gcGVlaygpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJhY2tzbGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT0gXCJcXFxcXCIpIGVzY2FwZWQgPSBiYWNrc2xhc2ggPSB0cnVlLCBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzX2lkZW50aWZpZXJfY2hhcihjaCkpIG5hbWUgKz0gbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCAhPSBcInVcIikgcGFyc2VfZXJyb3IoXCJFeHBlY3RpbmcgVW5pY29kZUVzY2FwZVNlcXVlbmNlIC0tIHVYWFhYXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHJlYWRfZXNjYXBlZF9jaGFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNfaWRlbnRpZmllcl9jaGFyKGNoKSkgcGFyc2VfZXJyb3IoXCJVbmljb2RlIGNoYXI6IFwiICsgY2guY2hhckNvZGVBdCgwKSArIFwiIGlzIG5vdCB2YWxpZCBpbiBpZGVudGlmaWVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrc2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEhPUChLRVlXT1JEUywgbmFtZSkgJiYgZXNjYXBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gbmFtZS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwiXFxcXHVcIiArIFwiMDAwMFwiLnN1YnN0cihoZXgubGVuZ3RoKSArIGhleCArIG5hbWUuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRfcmVnZXhwKHJlZ2V4cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aXRoX2VvZl9lcnJvcihcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2X2JhY2tzbGFzaCA9IGZhbHNlLCBjaCwgaW5fY2xhc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY2ggPSBuZXh0KHRydWUpKSkgaWYgKHByZXZfYmFja3NsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4cCArPSBcIlxcXFxcIiArIGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2X2JhY2tzbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIltcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbl9jbGFzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4cCArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCJdXCIgJiYgaW5fY2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5fY2xhc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhwICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIi9cIiAmJiAhaW5fY2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZfYmFja3NsYXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4cCArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RzID0gcmVhZF9uYW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4oXCJyZWdleHBcIiwgWyByZWdleHAsIG1vZHMgXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZF9vcGVyYXRvcihwcmVmaXgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBncm93KG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBlZWsoKSkgcmV0dXJuIG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJpZ2dlciA9IG9wICsgcGVlaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEhPUChPUEVSQVRPUlMsIGJpZ2dlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ3JvdyhiaWdnZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuKFwib3BlcmF0b3JcIiwgZ3JvdyhwcmVmaXggfHwgbmV4dCgpKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlX3NsYXNoKCkge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVnZXhfYWxsb3dlZCA9IFMucmVnZXhfYWxsb3dlZDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBlZWsoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgUy5jb21tZW50c19iZWZvcmUucHVzaChyZWFkX2xpbmVfY29tbWVudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMucmVnZXhfYWxsb3dlZCA9IHJlZ2V4X2FsbG93ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dF90b2tlbigpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgUy5jb21tZW50c19iZWZvcmUucHVzaChyZWFkX211bHRpbGluZV9jb21tZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgUy5yZWdleF9hbGxvd2VkID0gcmVnZXhfYWxsb3dlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0X3Rva2VuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBTLnJlZ2V4X2FsbG93ZWQgPyByZWFkX3JlZ2V4cChcIlwiKSA6IHJlYWRfb3BlcmF0b3IoXCIvXCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZV9kb3QoKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc19kaWdpdChwZWVrKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlYWRfbnVtKFwiLlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0b2tlbihcInB1bmNcIiwgXCIuXCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRfd29yZCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgd29yZCA9IHJlYWRfbmFtZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhSE9QKEtFWVdPUkRTLCB3b3JkKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0b2tlbihcIm5hbWVcIiwgd29yZClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogSE9QKE9QRVJBVE9SUywgd29yZClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdG9rZW4oXCJvcGVyYXRvclwiLCB3b3JkKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBIT1AoS0VZV09SRFNfQVRPTSwgd29yZClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdG9rZW4oXCJhdG9tXCIsIHdvcmQpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRva2VuKFwia2V5d29yZFwiLCB3b3JkKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiB3aXRoX2VvZl9lcnJvcihlb2ZfZXJyb3IsIGNvbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnQoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXggPT09IEVYX0VPRikgcGFyc2VfZXJyb3IoZW9mX2Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG5leHRfdG9rZW4oZm9yY2VfcmVnZXhwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmNlX3JlZ2V4cCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRfcmVnZXhwKGZvcmNlX3JlZ2V4cCk7XG4gICAgICAgICAgICAgICAgc2tpcF93aGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgc3RhcnRfdG9rZW4oKTtcbiAgICAgICAgICAgICAgICB2YXIgY2ggPSBwZWVrKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFjaCkgcmV0dXJuIHRva2VuKFwiZW9mXCIpO1xuICAgICAgICAgICAgICAgIGlmIChpc19kaWdpdChjaCkpIHJldHVybiByZWFkX251bSgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PSAnXCInIHx8IGNoID09IFwiJ1wiKSByZXR1cm4gcmVhZF9zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAoSE9QKFBVTkNfQ0hBUlMsIGNoKSkgcmV0dXJuIHRva2VuKFwicHVuY1wiLCBuZXh0KCkpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PSBcIi5cIikgcmV0dXJuIGhhbmRsZV9kb3QoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT0gXCIvXCIpIHJldHVybiBoYW5kbGVfc2xhc2goKTtcbiAgICAgICAgICAgICAgICBpZiAoSE9QKE9QRVJBVE9SX0NIQVJTLCBjaCkpIHJldHVybiByZWFkX29wZXJhdG9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09IFwiXFxcXFwiIHx8IGlzX2lkZW50aWZpZXJfc3RhcnQoY2gpKSByZXR1cm4gcmVhZF93b3JkKCk7XG4gICAgICAgICAgICAgICAgcGFyc2VfZXJyb3IoXCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnXCIgKyBjaCArIFwiJ1wiKTtcbiAgICAgICAgfTtcblxuICAgICAgICBuZXh0X3Rva2VuLmNvbnRleHQgPSBmdW5jdGlvbihuYykge1xuICAgICAgICAgICAgICAgIGlmIChuYykgUyA9IG5jO1xuICAgICAgICAgICAgICAgIHJldHVybiBTO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0X3Rva2VuO1xuXG59O1xuXG4vKiAtLS0tLVsgUGFyc2VyIChjb25zdGFudHMpIF0tLS0tLSAqL1xuXG52YXIgVU5BUllfUFJFRklYID0gYXJyYXlfdG9faGFzaChbXG4gICAgICAgIFwidHlwZW9mXCIsXG4gICAgICAgIFwidm9pZFwiLFxuICAgICAgICBcImRlbGV0ZVwiLFxuICAgICAgICBcIi0tXCIsXG4gICAgICAgIFwiKytcIixcbiAgICAgICAgXCIhXCIsXG4gICAgICAgIFwiflwiLFxuICAgICAgICBcIi1cIixcbiAgICAgICAgXCIrXCJcbl0pO1xuXG52YXIgVU5BUllfUE9TVEZJWCA9IGFycmF5X3RvX2hhc2goWyBcIi0tXCIsIFwiKytcIiBdKTtcblxudmFyIEFTU0lHTk1FTlQgPSAoZnVuY3Rpb24oYSwgcmV0LCBpKXtcbiAgICAgICAgd2hpbGUgKGkgPCBhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldFthW2ldXSA9IGFbaV0uc3Vic3RyKDAsIGFbaV0ubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG59KShcbiAgICAgICAgW1wiKz1cIiwgXCItPVwiLCBcIi89XCIsIFwiKj1cIiwgXCIlPVwiLCBcIj4+PVwiLCBcIjw8PVwiLCBcIj4+Pj1cIiwgXCJ8PVwiLCBcIl49XCIsIFwiJj1cIl0sXG4gICAgICAgIHsgXCI9XCI6IHRydWUgfSxcbiAgICAgICAgMFxuKTtcblxudmFyIFBSRUNFREVOQ0UgPSAoZnVuY3Rpb24oYSwgcmV0KXtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSAxOyBpIDwgYS5sZW5ndGg7ICsraSwgKytuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBhW2ldO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYi5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0W2Jbal1dID0gbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbn0pKFxuICAgICAgICBbXG4gICAgICAgICAgICAgICAgW1wifHxcIl0sXG4gICAgICAgICAgICAgICAgW1wiJiZcIl0sXG4gICAgICAgICAgICAgICAgW1wifFwiXSxcbiAgICAgICAgICAgICAgICBbXCJeXCJdLFxuICAgICAgICAgICAgICAgIFtcIiZcIl0sXG4gICAgICAgICAgICAgICAgW1wiPT1cIiwgXCI9PT1cIiwgXCIhPVwiLCBcIiE9PVwiXSxcbiAgICAgICAgICAgICAgICBbXCI8XCIsIFwiPlwiLCBcIjw9XCIsIFwiPj1cIiwgXCJpblwiLCBcImluc3RhbmNlb2ZcIl0sXG4gICAgICAgICAgICAgICAgW1wiPj5cIiwgXCI8PFwiLCBcIj4+PlwiXSxcbiAgICAgICAgICAgICAgICBbXCIrXCIsIFwiLVwiXSxcbiAgICAgICAgICAgICAgICBbXCIqXCIsIFwiL1wiLCBcIiVcIl1cbiAgICAgICAgXSxcbiAgICAgICAge31cbik7XG5cbnZhciBTVEFURU1FTlRTX1dJVEhfTEFCRUxTID0gYXJyYXlfdG9faGFzaChbIFwiZm9yXCIsIFwiZG9cIiwgXCJ3aGlsZVwiLCBcInN3aXRjaFwiIF0pO1xuXG52YXIgQVRPTUlDX1NUQVJUX1RPS0VOID0gYXJyYXlfdG9faGFzaChbIFwiYXRvbVwiLCBcIm51bVwiLCBcInN0cmluZ1wiLCBcInJlZ2V4cFwiLCBcIm5hbWVcIiBdKTtcblxuLyogLS0tLS1bIFBhcnNlciBdLS0tLS0gKi9cblxuZnVuY3Rpb24gTm9kZVdpdGhUb2tlbihzdHIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gc3RyO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xufTtcblxuTm9kZVdpdGhUb2tlbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubmFtZTsgfTtcblxuZnVuY3Rpb24gcGFyc2UoJFRFWFQsIGV4aWdlbnRfbW9kZSwgZW1iZWRfdG9rZW5zKSB7XG5cbiAgICAgICAgdmFyIFMgPSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgICAgICAgICA6IHR5cGVvZiAkVEVYVCA9PSBcInN0cmluZ1wiID8gdG9rZW5pemVyKCRURVhULCB0cnVlKSA6ICRURVhULFxuICAgICAgICAgICAgICAgIHRva2VuICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIHByZXYgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIHBlZWtlZCAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIGluX2Z1bmN0aW9uICAgOiAwLFxuICAgICAgICAgICAgICAgIGluX2RpcmVjdGl2ZXMgOiB0cnVlLFxuICAgICAgICAgICAgICAgIGluX2xvb3AgICAgICAgOiAwLFxuICAgICAgICAgICAgICAgIGxhYmVscyAgICAgICAgOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIFMudG9rZW4gPSBuZXh0KCk7XG5cbiAgICAgICAgZnVuY3Rpb24gaXModHlwZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNfdG9rZW4oUy50b2tlbiwgdHlwZSwgdmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHBlZWsoKSB7IHJldHVybiBTLnBlZWtlZCB8fCAoUy5wZWVrZWQgPSBTLmlucHV0KCkpOyB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgUy5wcmV2ID0gUy50b2tlbjtcbiAgICAgICAgICAgICAgICBpZiAoUy5wZWVrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMudG9rZW4gPSBTLnBlZWtlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMucGVla2VkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgUy50b2tlbiA9IFMuaW5wdXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUy5pbl9kaXJlY3RpdmVzID0gUy5pbl9kaXJlY3RpdmVzICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIFMudG9rZW4udHlwZSA9PSBcInN0cmluZ1wiIHx8IGlzKFwicHVuY1wiLCBcIjtcIilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiBTLnRva2VuO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHByZXYoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFMucHJldjtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBjcm9hayhtc2csIGxpbmUsIGNvbCwgcG9zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IFMuaW5wdXQuY29udGV4dCgpO1xuICAgICAgICAgICAgICAgIGpzX2Vycm9yKG1zZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lICE9IG51bGwgPyBsaW5lIDogY3R4LnRva2xpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgY29sICE9IG51bGwgPyBjb2wgOiBjdHgudG9rY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyAhPSBudWxsID8gcG9zIDogY3R4LnRva3Bvcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gdG9rZW5fZXJyb3IodG9rZW4sIG1zZykge1xuICAgICAgICAgICAgICAgIGNyb2FrKG1zZywgdG9rZW4ubGluZSwgdG9rZW4uY29sKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiB1bmV4cGVjdGVkKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IFMudG9rZW47XG4gICAgICAgICAgICAgICAgdG9rZW5fZXJyb3IodG9rZW4sIFwiVW5leHBlY3RlZCB0b2tlbjogXCIgKyB0b2tlbi50eXBlICsgXCIgKFwiICsgdG9rZW4udmFsdWUgKyBcIilcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZXhwZWN0X3Rva2VuKHR5cGUsIHZhbCkge1xuICAgICAgICAgICAgICAgIGlmIChpcyh0eXBlLCB2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b2tlbl9lcnJvcihTLnRva2VuLCBcIlVuZXhwZWN0ZWQgdG9rZW4gXCIgKyBTLnRva2VuLnR5cGUgKyBcIiwgZXhwZWN0ZWQgXCIgKyB0eXBlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBleHBlY3QocHVuYykgeyByZXR1cm4gZXhwZWN0X3Rva2VuKFwicHVuY1wiLCBwdW5jKTsgfTtcblxuICAgICAgICBmdW5jdGlvbiBjYW5faW5zZXJ0X3NlbWljb2xvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWV4aWdlbnRfbW9kZSAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBTLnRva2VuLm5sYiB8fCBpcyhcImVvZlwiKSB8fCBpcyhcInB1bmNcIiwgXCJ9XCIpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBzZW1pY29sb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIjtcIikpIG5leHQoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY2FuX2luc2VydF9zZW1pY29sb24oKSkgdW5leHBlY3RlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGFzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzbGljZShhcmd1bWVudHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHBhcmVudGhlc2lzZWQoKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFwiKFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgZXggPSBleHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFwiKVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXg7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkX3Rva2VucyhzdHIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyIGluc3RhbmNlb2YgTm9kZVdpdGhUb2tlbiA/IHN0ciA6IG5ldyBOb2RlV2l0aFRva2VuKHN0ciwgc3RhcnQsIGVuZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbWF5YmVfZW1iZWRfdG9rZW5zKHBhcnNlcikge1xuICAgICAgICAgICAgICAgIGlmIChlbWJlZF90b2tlbnMpIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXN0ID0gcGFyc2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3RbMF0gPSBhZGRfdG9rZW5zKGFzdFswXSwgc3RhcnQsIHByZXYoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gcGFyc2VyO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzdGF0ZW1lbnQgPSBtYXliZV9lbWJlZF90b2tlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCIvXCIpIHx8IGlzKFwib3BlcmF0b3JcIiwgXCIvPVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUy5wZWVrZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgUy50b2tlbiA9IFMuaW5wdXQoUy50b2tlbi52YWx1ZS5zdWJzdHIoMSkpOyAvLyBmb3JjZSByZWdleHBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChTLnRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpciA9IFMuaW5fZGlyZWN0aXZlcywgc3RhdCA9IHNpbXBsZV9zdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXIgJiYgc3RhdFsxXVswXSA9PSBcInN0cmluZ1wiICYmICFpcyhcInB1bmNcIiwgXCIsXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcyhcImRpcmVjdGl2ZVwiLCBzdGF0WzFdWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibnVtXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWdleHBcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm9wZXJhdG9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhdG9tXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxlX3N0YXRlbWVudCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNfdG9rZW4ocGVlaygpLCBcInB1bmNcIiwgXCI6XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbGFiZWxlZF9zdGF0ZW1lbnQocHJvZzEoUy50b2tlbi52YWx1ZSwgbmV4dCwgbmV4dCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc2ltcGxlX3N0YXRlbWVudCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwdW5jXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKFMudG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwie1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJibG9ja1wiLCBibG9ja18oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxlX3N0YXRlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI7XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwiYmxvY2tcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJrZXl3b3JkXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb2cxKFMudG9rZW4udmFsdWUsIG5leHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJyZWFrXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBicmVha19jb250KFwiYnJlYWtcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY29udGludWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJyZWFrX2NvbnQoXCJjb250aW51ZVwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z2dlclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwiZGVidWdnZXJcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZG9cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbihib2R5KXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RfdG9rZW4oXCJrZXl3b3JkXCIsIFwid2hpbGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwiZG9cIiwgcHJvZzEocGFyZW50aGVzaXNlZCwgc2VtaWNvbG9uKSwgYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKGluX2xvb3Aoc3RhdGVtZW50KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZm9yXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JfKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uXyh0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpZlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWZfKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmV0dXJuXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTLmluX2Z1bmN0aW9uID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJyZXR1cm5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzKFwicHVuY1wiLCBcIjtcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKG5leHQoKSwgbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY2FuX2luc2VydF9zZW1pY29sb24oKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHByb2cxKGV4cHJlc3Npb24sIHNlbWljb2xvbikpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN3aXRjaFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJzd2l0Y2hcIiwgcGFyZW50aGVzaXNlZCgpLCBzd2l0Y2hfYmxvY2tfKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRocm93XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTLnRva2VuLm5sYilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcm9hayhcIklsbGVnYWwgbmV3bGluZSBhZnRlciAndGhyb3cnXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJ0aHJvd1wiLCBwcm9nMShleHByZXNzaW9uLCBzZW1pY29sb24pKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0cnlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeV8oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2YXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2cxKHZhcl8sIHNlbWljb2xvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY29uc3RcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2cxKGNvbnN0Xywgc2VtaWNvbG9uKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ3aGlsZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJ3aGlsZVwiLCBwYXJlbnRoZXNpc2VkKCksIGluX2xvb3Aoc3RhdGVtZW50KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwid2l0aFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJ3aXRoXCIsIHBhcmVudGhlc2lzZWQoKSwgc3RhdGVtZW50KCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gbGFiZWxlZF9zdGF0ZW1lbnQobGFiZWwpIHtcbiAgICAgICAgICAgICAgICBTLmxhYmVscy5wdXNoKGxhYmVsKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuLCBzdGF0ID0gc3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aWdlbnRfbW9kZSAmJiAhSE9QKFNUQVRFTUVOVFNfV0lUSF9MQUJFTFMsIHN0YXRbMF0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5leHBlY3RlZChzdGFydCk7XG4gICAgICAgICAgICAgICAgUy5sYWJlbHMucG9wKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwibGFiZWxcIiwgbGFiZWwsIHN0YXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHNpbXBsZV9zdGF0ZW1lbnQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwic3RhdFwiLCBwcm9nMShleHByZXNzaW9uLCBzZW1pY29sb24pKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBicmVha19jb250KHR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbl9pbnNlcnRfc2VtaWNvbG9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBpcyhcIm5hbWVcIikgPyBTLnRva2VuLnZhbHVlIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZW1iZXIobmFtZSwgUy5sYWJlbHMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcm9hayhcIkxhYmVsIFwiICsgbmFtZSArIFwiIHdpdGhvdXQgbWF0Y2hpbmcgbG9vcCBvciBzdGF0ZW1lbnRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFMuaW5fbG9vcCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgY3JvYWsodHlwZSArIFwiIG5vdCBpbnNpZGUgYSBsb29wIG9yIHN3aXRjaFwiKTtcbiAgICAgICAgICAgICAgICBzZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXModHlwZSwgbmFtZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZm9yXygpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoXCIoXCIpO1xuICAgICAgICAgICAgICAgIHZhciBpbml0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIWlzKFwicHVuY1wiLCBcIjtcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSBpcyhcImtleXdvcmRcIiwgXCJ2YXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAobmV4dCgpLCB2YXJfKHRydWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGV4cHJlc3Npb24odHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiLCBcImluXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbml0WzBdID09IFwidmFyXCIgJiYgaW5pdFsxXS5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiT25seSBvbmUgdmFyaWFibGUgZGVjbGFyYXRpb24gYWxsb3dlZCBpbiBmb3IuLmluIGxvb3BcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JfaW4oaW5pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWd1bGFyX2Zvcihpbml0KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiByZWd1bGFyX2Zvcihpbml0KSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFwiO1wiKTtcbiAgICAgICAgICAgICAgICB2YXIgdGVzdCA9IGlzKFwicHVuY1wiLCBcIjtcIikgPyBudWxsIDogZXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChcIjtcIik7XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXAgPSBpcyhcInB1bmNcIiwgXCIpXCIpID8gbnVsbCA6IGV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoXCIpXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcyhcImZvclwiLCBpbml0LCB0ZXN0LCBzdGVwLCBpbl9sb29wKHN0YXRlbWVudCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGZvcl9pbihpbml0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxocyA9IGluaXRbMF0gPT0gXCJ2YXJcIiA/IGFzKFwibmFtZVwiLCBpbml0WzFdWzBdKSA6IGluaXQ7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSBleHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFwiKVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJmb3ItaW5cIiwgaW5pdCwgbGhzLCBvYmosIGluX2xvb3Aoc3RhdGVtZW50KSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGZ1bmN0aW9uXyA9IGZ1bmN0aW9uKGluX3N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gaXMoXCJuYW1lXCIpID8gcHJvZzEoUy50b2tlbi52YWx1ZSwgbmV4dCkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChpbl9zdGF0ZW1lbnQgJiYgIW5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFwiKFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXMoaW5fc3RhdGVtZW50ID8gXCJkZWZ1blwiIDogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKGZpcnN0LCBhKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIWlzKFwicHVuY1wiLCBcIilcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdCkgZmlyc3QgPSBmYWxzZTsgZWxzZSBleHBlY3QoXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpcyhcIm5hbWVcIikpIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChTLnRva2VuLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9KSh0cnVlLCBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvZHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKytTLmluX2Z1bmN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb29wID0gUy5pbl9sb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFMuaW5fZGlyZWN0aXZlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUy5pbl9sb29wID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGJsb2NrXygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tUy5pbl9mdW5jdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTLmluX2xvb3AgPSBsb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBpZl8oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmQgPSBwYXJlbnRoZXNpc2VkKCksIGJvZHkgPSBzdGF0ZW1lbnQoKSwgYmVsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGlzKFwia2V5d29yZFwiLCBcImVsc2VcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlbHNlID0gc3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhcyhcImlmXCIsIGNvbmQsIGJvZHksIGJlbHNlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBibG9ja18oKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFwie1wiKTtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgICAgICAgIHdoaWxlICghaXMoXCJwdW5jXCIsIFwifVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKFwiZW9mXCIpKSB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goc3RhdGVtZW50KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHN3aXRjaF9ibG9ja18gPSBjdXJyeShpbl9sb29wLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGV4cGVjdChcIntcIik7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBbXSwgY3VyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWlzKFwicHVuY1wiLCBcIn1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyhcImVvZlwiKSkgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKFwia2V5d29yZFwiLCBcImNhc2VcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKFsgZXhwcmVzc2lvbigpLCBjdXIgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChcIjpcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpcyhcImtleXdvcmRcIiwgXCJkZWZhdWx0XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KFwiOlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChbIG51bGwsIGN1ciBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cikgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIucHVzaChzdGF0ZW1lbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gdHJ5XygpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9IGJsb2NrXygpLCBiY2F0Y2gsIGJmaW5hbGx5O1xuICAgICAgICAgICAgICAgIGlmIChpcyhcImtleXdvcmRcIiwgXCJjYXRjaFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KFwiKFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXMoXCJuYW1lXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcm9hayhcIk5hbWUgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IFMudG9rZW4udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QoXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmNhdGNoID0gWyBuYW1lLCBibG9ja18oKSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiZmluYWxseVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmZpbmFsbHkgPSBibG9ja18oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFiY2F0Y2ggJiYgIWJmaW5hbGx5KVxuICAgICAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJNaXNzaW5nIGNhdGNoL2ZpbmFsbHkgYmxvY2tzXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcyhcInRyeVwiLCBib2R5LCBiY2F0Y2gsIGJmaW5hbGx5KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiB2YXJkZWZzKG5vX2luKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzKFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBTLnRva2VuLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCI9XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKFsgbmFtZSwgZXhwcmVzc2lvbihmYWxzZSwgbm9faW4pIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKFsgbmFtZSBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXMoXCJwdW5jXCIsIFwiLFwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHZhcl8obm9faW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJ2YXJcIiwgdmFyZGVmcyhub19pbikpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvbnN0XygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJjb25zdFwiLCB2YXJkZWZzKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG5ld18oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld2V4cCA9IGV4cHJfYXRvbShmYWxzZSksIGFyZ3M7XG4gICAgICAgICAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIihcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBleHByX2xpc3QoXCIpXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKGFzKFwibmV3XCIsIG5ld2V4cCwgYXJncyksIHRydWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBleHByX2F0b20gPSBtYXliZV9lbWJlZF90b2tlbnMoZnVuY3Rpb24oYWxsb3dfY2FsbHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiLCBcIm5ld1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld18oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzKFwicHVuY1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChTLnRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIihcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhwcm9nMShleHByZXNzaW9uLCBjdXJyeShleHBlY3QsIFwiKVwiKSksIGFsbG93X2NhbGxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiW1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKGFycmF5XygpLCBhbGxvd19jYWxscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIntcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhvYmplY3RfKCksIGFsbG93X2NhbGxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzKFwia2V5d29yZFwiLCBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhmdW5jdGlvbl8oZmFsc2UpLCBhbGxvd19jYWxscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChIT1AoQVRPTUlDX1NUQVJUX1RPS0VOLCBTLnRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXRvbSA9IFMudG9rZW4udHlwZSA9PSBcInJlZ2V4cFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYXMoXCJyZWdleHBcIiwgUy50b2tlbi52YWx1ZVswXSwgUy50b2tlbi52YWx1ZVsxXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhcyhTLnRva2VuLnR5cGUsIFMudG9rZW4udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMocHJvZzEoYXRvbSwgbmV4dCksIGFsbG93X2NhbGxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBleHByX2xpc3QoY2xvc2luZywgYWxsb3dfdHJhaWxpbmdfY29tbWEsIGFsbG93X2VtcHR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gdHJ1ZSwgYSA9IFtdO1xuICAgICAgICAgICAgICAgIHdoaWxlICghaXMoXCJwdW5jXCIsIGNsb3NpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIGZpcnN0ID0gZmFsc2U7IGVsc2UgZXhwZWN0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGxvd190cmFpbGluZ19jb21tYSAmJiBpcyhcInB1bmNcIiwgY2xvc2luZykpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIixcIikgJiYgYWxsb3dfZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKFsgXCJhdG9tXCIsIFwidW5kZWZpbmVkXCIgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goZXhwcmVzc2lvbihmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gYXJyYXlfKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcyhcImFycmF5XCIsIGV4cHJfbGlzdChcIl1cIiwgIWV4aWdlbnRfbW9kZSwgdHJ1ZSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG9iamVjdF8oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gdHJ1ZSwgYSA9IFtdO1xuICAgICAgICAgICAgICAgIHdoaWxlICghaXMoXCJwdW5jXCIsIFwifVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KSBmaXJzdCA9IGZhbHNlOyBlbHNlIGV4cGVjdChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aWdlbnRfbW9kZSAmJiBpcyhcInB1bmNcIiwgXCJ9XCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyB0cmFpbGluZyBjb21tYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gUy50b2tlbi50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBhc19wcm9wZXJ0eV9uYW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBcIm5hbWVcIiAmJiAobmFtZSA9PSBcImdldFwiIHx8IG5hbWUgPT0gXCJzZXRcIikgJiYgIWlzKFwicHVuY1wiLCBcIjpcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKFsgYXNfbmFtZSgpLCBmdW5jdGlvbl8oZmFsc2UpLCBuYW1lIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KFwiOlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKFsgbmFtZSwgZXhwcmVzc2lvbihmYWxzZSkgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJvYmplY3RcIiwgYSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gYXNfcHJvcGVydHlfbmFtZSgpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKFMudG9rZW4udHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibnVtXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9nMShTLnRva2VuLnZhbHVlLCBuZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzX25hbWUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBhc19uYW1lKCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoUy50b2tlbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvcGVyYXRvclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwia2V5d29yZFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXRvbVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2cxKFMudG9rZW4udmFsdWUsIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBzdWJzY3JpcHRzKGV4cHIsIGFsbG93X2NhbGxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIi5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKGFzKFwiZG90XCIsIGV4cHIsIGFzX25hbWUoKSksIGFsbG93X2NhbGxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIltcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKGFzKFwic3ViXCIsIGV4cHIsIHByb2cxKGV4cHJlc3Npb24sIGN1cnJ5KGV4cGVjdCwgXCJdXCIpKSksIGFsbG93X2NhbGxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93X2NhbGxzICYmIGlzKFwicHVuY1wiLCBcIihcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKGFzKFwiY2FsbFwiLCBleHByLCBleHByX2xpc3QoXCIpXCIpKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG1heWJlX3VuYXJ5KGFsbG93X2NhbGxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIikgJiYgSE9QKFVOQVJZX1BSRUZJWCwgUy50b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX3VuYXJ5KFwidW5hcnktcHJlZml4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9nMShTLnRva2VuLnZhbHVlLCBuZXh0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlX3VuYXJ5KGFsbG93X2NhbGxzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBleHByX2F0b20oYWxsb3dfY2FsbHMpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpcyhcIm9wZXJhdG9yXCIpICYmIEhPUChVTkFSWV9QT1NURklYLCBTLnRva2VuLnZhbHVlKSAmJiAhUy50b2tlbi5ubGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG1ha2VfdW5hcnkoXCJ1bmFyeS1wb3N0Zml4XCIsIFMudG9rZW4udmFsdWUsIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZV91bmFyeSh0YWcsIG9wLCBleHByKSB7XG4gICAgICAgICAgICAgICAgaWYgKChvcCA9PSBcIisrXCIgfHwgb3AgPT0gXCItLVwiKSAmJiAhaXNfYXNzaWduYWJsZShleHByKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiSW52YWxpZCB1c2Ugb2YgXCIgKyBvcCArIFwiIG9wZXJhdG9yXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcyh0YWcsIG9wLCBleHByKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBleHByX29wKGxlZnQsIG1pbl9wcmVjLCBub19pbikge1xuICAgICAgICAgICAgICAgIHZhciBvcCA9IGlzKFwib3BlcmF0b3JcIikgPyBTLnRva2VuLnZhbHVlIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAob3AgJiYgb3AgPT0gXCJpblwiICYmIG5vX2luKSBvcCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIHByZWMgPSBvcCAhPSBudWxsID8gUFJFQ0VERU5DRVtvcF0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChwcmVjICE9IG51bGwgJiYgcHJlYyA+IG1pbl9wcmVjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBleHByX29wKG1heWJlX3VuYXJ5KHRydWUpLCBwcmVjLCBub19pbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwcl9vcChhcyhcImJpbmFyeVwiLCBvcCwgbGVmdCwgcmlnaHQpLCBtaW5fcHJlYywgbm9faW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBleHByX29wcyhub19pbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHByX29wKG1heWJlX3VuYXJ5KHRydWUpLCAwLCBub19pbik7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbWF5YmVfY29uZGl0aW9uYWwobm9faW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhwciA9IGV4cHJfb3BzKG5vX2luKTtcbiAgICAgICAgICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiLCBcIj9cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ZXMgPSBleHByZXNzaW9uKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChcIjpcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJjb25kaXRpb25hbFwiLCBleHByLCB5ZXMsIGV4cHJlc3Npb24oZmFsc2UsIG5vX2luKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGlzX2Fzc2lnbmFibGUoZXhwcikge1xuICAgICAgICAgICAgICAgIGlmICghZXhpZ2VudF9tb2RlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4cHJbMF0rXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZG90XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdWJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5ld1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2FsbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwclsxXSAhPSBcInRoaXNcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbWF5YmVfYXNzaWduKG5vX2luKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBtYXliZV9jb25kaXRpb25hbChub19pbiksIHZhbCA9IFMudG9rZW4udmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIikgJiYgSE9QKEFTU0lHTk1FTlQsIHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc19hc3NpZ25hYmxlKGxlZnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwiYXNzaWduXCIsIEFTU0lHTk1FTlRbdmFsXSwgbGVmdCwgbWF5YmVfYXNzaWduKG5vX2luKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9hayhcIkludmFsaWQgYXNzaWdubWVudFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBtYXliZV9lbWJlZF90b2tlbnMoZnVuY3Rpb24oY29tbWFzLCBub19pbikge1xuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBleHByID0gbWF5YmVfYXNzaWduKG5vX2luKTtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWFzICYmIGlzKFwicHVuY1wiLCBcIixcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcyhcInNlcVwiLCBleHByLCBleHByZXNzaW9uKHRydWUsIG5vX2luKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBpbl9sb29wKGNvbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytTLmluX2xvb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udCgpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAtLVMuaW5fbG9vcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGFzKFwidG9wbGV2ZWxcIiwgKGZ1bmN0aW9uKGEpe1xuICAgICAgICAgICAgICAgIHdoaWxlICghaXMoXCJlb2ZcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goc3RhdGVtZW50KCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9KShbXSkpO1xuXG59O1xuXG4vKiAtLS0tLVsgVXRpbGl0aWVzIF0tLS0tLSAqL1xuXG5mdW5jdGlvbiBjdXJyeShmKSB7XG4gICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmdzLmNvbmNhdChzbGljZShhcmd1bWVudHMpKSk7IH07XG59O1xuXG5mdW5jdGlvbiBwcm9nMShyZXQpIHtcbiAgICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgICAgICAgICAgICAgIHJldCA9IHJldCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IC0tbiA+IDA7ICsraSlcbiAgICAgICAgICAgICAgICBhcmd1bWVudHNbaV0oKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGFycmF5X3RvX2hhc2goYSkge1xuICAgICAgICB2YXIgcmV0ID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICByZXRbYVtpXV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gc2xpY2UoYSwgc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEsIHN0YXJ0IHx8IDApO1xufTtcblxuZnVuY3Rpb24gY2hhcmFjdGVycyhzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5zcGxpdChcIlwiKTtcbn07XG5cbmZ1bmN0aW9uIG1lbWJlcihuYW1lLCBhcnJheSkge1xuICAgICAgICBmb3IgKHZhciBpID0gYXJyYXkubGVuZ3RoOyAtLWkgPj0gMDspXG4gICAgICAgICAgICAgICAgaWYgKGFycmF5W2ldID09IG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gSE9QKG9iaiwgcHJvcCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59O1xuXG52YXIgd2FybiA9IGZ1bmN0aW9uKCkge307XG5cbi8qIC0tLS0tWyBFeHBvcnRzIF0tLS0tLSAqL1xuXG5leHBvcnRzLnRva2VuaXplciA9IHRva2VuaXplcjtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMuc2xpY2UgPSBzbGljZTtcbmV4cG9ydHMuY3VycnkgPSBjdXJyeTtcbmV4cG9ydHMubWVtYmVyID0gbWVtYmVyO1xuZXhwb3J0cy5hcnJheV90b19oYXNoID0gYXJyYXlfdG9faGFzaDtcbmV4cG9ydHMuUFJFQ0VERU5DRSA9IFBSRUNFREVOQ0U7XG5leHBvcnRzLktFWVdPUkRTX0FUT00gPSBLRVlXT1JEU19BVE9NO1xuZXhwb3J0cy5SRVNFUlZFRF9XT1JEUyA9IFJFU0VSVkVEX1dPUkRTO1xuZXhwb3J0cy5LRVlXT1JEUyA9IEtFWVdPUkRTO1xuZXhwb3J0cy5BVE9NSUNfU1RBUlRfVE9LRU4gPSBBVE9NSUNfU1RBUlRfVE9LRU47XG5leHBvcnRzLk9QRVJBVE9SUyA9IE9QRVJBVE9SUztcbmV4cG9ydHMuaXNfYWxwaGFudW1lcmljX2NoYXIgPSBpc19hbHBoYW51bWVyaWNfY2hhcjtcbmV4cG9ydHMuaXNfaWRlbnRpZmllcl9zdGFydCA9IGlzX2lkZW50aWZpZXJfc3RhcnQ7XG5leHBvcnRzLmlzX2lkZW50aWZpZXJfY2hhciA9IGlzX2lkZW50aWZpZXJfY2hhcjtcbmV4cG9ydHMuc2V0X2xvZ2dlciA9IGZ1bmN0aW9uKGxvZ2dlcikge1xuICAgICAgICB3YXJuID0gbG9nZ2VyO1xufTtcblxuLy8gTG9jYWwgdmFyaWFibGVzOlxuLy8ganMtaW5kZW50LWxldmVsOiA4XG4vLyBFbmQ6XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG5cbiAgVGhpcyB2ZXJzaW9uIGlzIHN1aXRhYmxlIGZvciBOb2RlLmpzLiAgV2l0aCBtaW5pbWFsIGNoYW5nZXMgKHRoZVxuICBleHBvcnRzIHN0dWZmKSBpdCBzaG91bGQgd29yayBvbiBhbnkgSlMgcGxhdGZvcm0uXG5cbiAgVGhpcyBmaWxlIGltcGxlbWVudHMgc29tZSBBU1QgcHJvY2Vzc29ycy4gIFRoZXkgd29yayBvbiBkYXRhIGJ1aWx0XG4gIGJ5IHBhcnNlLWpzLlxuXG4gIEV4cG9ydGVkIGZ1bmN0aW9uczpcblxuICAgIC0gYXN0X21hbmdsZShhc3QsIG9wdGlvbnMpIC0tIG1hbmdsZXMgdGhlIHZhcmlhYmxlL2Z1bmN0aW9uIG5hbWVzXG4gICAgICBpbiB0aGUgQVNULiAgUmV0dXJucyBhbiBBU1QuXG5cbiAgICAtIGFzdF9zcXVlZXplKGFzdCkgLS0gZW1wbG95cyB2YXJpb3VzIG9wdGltaXphdGlvbnMgdG8gbWFrZSB0aGVcbiAgICAgIGZpbmFsIGdlbmVyYXRlZCBjb2RlIGV2ZW4gc21hbGxlci4gIFJldHVybnMgYW4gQVNULlxuXG4gICAgLSBnZW5fY29kZShhc3QsIG9wdGlvbnMpIC0tIGdlbmVyYXRlcyBKUyBjb2RlIGZyb20gdGhlIEFTVC4gIFBhc3NcbiAgICAgIHRydWUgKG9yIGFuIG9iamVjdCwgc2VlIHRoZSBjb2RlIGZvciBzb21lIG9wdGlvbnMpIGFzIHNlY29uZFxuICAgICAgYXJndW1lbnQgdG8gZ2V0IFwicHJldHR5XCIgKGluZGVudGVkKSBjb2RlLlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEwIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIuXG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcbiAgICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gICAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAgICBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAgICBTVUNIIERBTUFHRS5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIganNwID0gcmVxdWlyZShcIi4vcGFyc2UtanNcIiksXG4gICAgY3VycnkgPSBqc3AuY3VycnksXG4gICAgc2xpY2UgPSBqc3Auc2xpY2UsXG4gICAgbWVtYmVyID0ganNwLm1lbWJlcixcbiAgICBpc19pZGVudGlmaWVyX2NoYXIgPSBqc3AuaXNfaWRlbnRpZmllcl9jaGFyLFxuICAgIFBSRUNFREVOQ0UgPSBqc3AuUFJFQ0VERU5DRSxcbiAgICBPUEVSQVRPUlMgPSBqc3AuT1BFUkFUT1JTO1xuXG4vKiAtLS0tLVsgaGVscGVyIGZvciBBU1QgdHJhdmVyc2FsIF0tLS0tLSAqL1xuXG5mdW5jdGlvbiBhc3Rfd2Fsa2VyKCkge1xuICAgICAgICBmdW5jdGlvbiBfdmFyZGVmcyhkZWZzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgTUFQKGRlZnMsIGZ1bmN0aW9uKGRlZil7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IFsgZGVmWzBdIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbMV0gPSB3YWxrKGRlZlsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgICB9KSBdO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBfYmxvY2soc3RhdGVtZW50cykge1xuICAgICAgICAgICAgICAgIHZhciBvdXQgPSBbIHRoaXNbMF0gXTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVtZW50cyAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goTUFQKHN0YXRlbWVudHMsIHdhbGspKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgd2Fsa2VycyA9IHtcbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHN0ciBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJudW1cIjogZnVuY3Rpb24obnVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBudW0gXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBuYW1lIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInRvcGxldmVsXCI6IGZ1bmN0aW9uKHN0YXRlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIE1BUChzdGF0ZW1lbnRzLCB3YWxrKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJibG9ja1wiOiBfYmxvY2ssXG4gICAgICAgICAgICAgICAgXCJzcGxpY2VcIjogX2Jsb2NrLFxuICAgICAgICAgICAgICAgIFwidmFyXCI6IF92YXJkZWZzLFxuICAgICAgICAgICAgICAgIFwiY29uc3RcIjogX3ZhcmRlZnMsXG4gICAgICAgICAgICAgICAgXCJ0cnlcIjogZnVuY3Rpb24odCwgYywgZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTUFQKHQsIHdhbGspLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjICE9IG51bGwgPyBbIGNbMF0sIE1BUChjWzFdLCB3YWxrKSBdIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiAhPSBudWxsID8gTUFQKGYsIHdhbGspIDogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwidGhyb3dcIjogZnVuY3Rpb24oZXhwcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgd2FsayhleHByKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJuZXdcIjogZnVuY3Rpb24oY3RvciwgYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgd2FsayhjdG9yKSwgTUFQKGFyZ3MsIHdhbGspIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInN3aXRjaFwiOiBmdW5jdGlvbihleHByLCBib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCB3YWxrKGV4cHIpLCBNQVAoYm9keSwgZnVuY3Rpb24oYnJhbmNoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgYnJhbmNoWzBdID8gd2FsayhicmFuY2hbMF0pIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTUFQKGJyYW5jaFsxXSwgd2FsaykgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImJyZWFrXCI6IGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBsYWJlbCBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJjb250aW51ZVwiOiBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgbGFiZWwgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiY29uZGl0aW9uYWxcIjogZnVuY3Rpb24oY29uZCwgdCwgZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgd2Fsayhjb25kKSwgd2Fsayh0KSwgd2FsayhlKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhc3NpZ25cIjogZnVuY3Rpb24ob3AsIGx2YWx1ZSwgcnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBvcCwgd2FsayhsdmFsdWUpLCB3YWxrKHJ2YWx1ZSkgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZG90XCI6IGZ1bmN0aW9uKGV4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHdhbGsoZXhwcikgXS5jb25jYXQoc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImNhbGxcIjogZnVuY3Rpb24oZXhwciwgYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgd2FsayhleHByKSwgTUFQKGFyZ3MsIHdhbGspIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCI6IGZ1bmN0aW9uKG5hbWUsIGFyZ3MsIGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIG5hbWUsIGFyZ3Muc2xpY2UoKSwgTUFQKGJvZHksIHdhbGspIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImRlYnVnZ2VyXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJkZWZ1blwiOiBmdW5jdGlvbihuYW1lLCBhcmdzLCBib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBuYW1lLCBhcmdzLnNsaWNlKCksIE1BUChib2R5LCB3YWxrKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJpZlwiOiBmdW5jdGlvbihjb25kaXRpb25hbCwgdCwgZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgd2Fsayhjb25kaXRpb25hbCksIHdhbGsodCksIHdhbGsoZSkgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZm9yXCI6IGZ1bmN0aW9uKGluaXQsIGNvbmQsIHN0ZXAsIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCB3YWxrKGluaXQpLCB3YWxrKGNvbmQpLCB3YWxrKHN0ZXApLCB3YWxrKGJsb2NrKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJmb3ItaW5cIjogZnVuY3Rpb24odnZhciwga2V5LCBoYXNoLCBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgd2Fsayh2dmFyKSwgd2FsayhrZXkpLCB3YWxrKGhhc2gpLCB3YWxrKGJsb2NrKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ3aGlsZVwiOiBmdW5jdGlvbihjb25kLCBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgd2Fsayhjb25kKSwgd2FsayhibG9jaykgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZG9cIjogZnVuY3Rpb24oY29uZCwgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHdhbGsoY29uZCksIHdhbGsoYmxvY2spIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInJldHVyblwiOiBmdW5jdGlvbihleHByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCB3YWxrKGV4cHIpIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImJpbmFyeVwiOiBmdW5jdGlvbihvcCwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIG9wLCB3YWxrKGxlZnQpLCB3YWxrKHJpZ2h0KSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ1bmFyeS1wcmVmaXhcIjogZnVuY3Rpb24ob3AsIGV4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIG9wLCB3YWxrKGV4cHIpIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInVuYXJ5LXBvc3RmaXhcIjogZnVuY3Rpb24ob3AsIGV4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIG9wLCB3YWxrKGV4cHIpIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInN1YlwiOiBmdW5jdGlvbihleHByLCBzdWJzY3JpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHdhbGsoZXhwciksIHdhbGsoc3Vic2NyaXB0KSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIjogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIE1BUChwcm9wcywgZnVuY3Rpb24ocCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwLmxlbmd0aCA9PSAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbIHBbMF0sIHdhbGsocFsxXSkgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogWyBwWzBdLCB3YWxrKHBbMV0pLCBwWzJdIF07IC8vIGdldC9zZXQtdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJyZWdleHBcIjogZnVuY3Rpb24ocngsIG1vZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHJ4LCBtb2RzIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBNQVAoZWxlbWVudHMsIHdhbGspIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInN0YXRcIjogZnVuY3Rpb24oc3RhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgd2FsayhzdGF0KSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJzZXFcIjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdIF0uY29uY2F0KE1BUChzbGljZShhcmd1bWVudHMpLCB3YWxrKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImxhYmVsXCI6IGZ1bmN0aW9uKG5hbWUsIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBuYW1lLCB3YWxrKGJsb2NrKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ3aXRoXCI6IGZ1bmN0aW9uKGV4cHIsIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCB3YWxrKGV4cHIpLCB3YWxrKGJsb2NrKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhdG9tXCI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIG5hbWUgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZGlyZWN0aXZlXCI6IGZ1bmN0aW9uKGRpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgZGlyIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB1c2VyID0ge307XG4gICAgICAgIHZhciBzdGFjayA9IFtdO1xuICAgICAgICBmdW5jdGlvbiB3YWxrKGFzdCkge1xuICAgICAgICAgICAgICAgIGlmIChhc3QgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGFzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGFzdFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZW4gPSB1c2VyW3R5cGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gZ2VuLmFwcGx5KGFzdCwgYXN0LnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4gPSB3YWxrZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlbi5hcHBseShhc3QsIGFzdC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBkaXZlKGFzdCkge1xuICAgICAgICAgICAgICAgIGlmIChhc3QgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGFzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2Fsa2Vyc1thc3RbMF1dLmFwcGx5KGFzdCwgYXN0LnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHdpdGhfd2Fsa2Vycyh3YWxrZXJzLCBjb250KXtcbiAgICAgICAgICAgICAgICB2YXIgc2F2ZSA9IHt9LCBpO1xuICAgICAgICAgICAgICAgIGZvciAoaSBpbiB3YWxrZXJzKSBpZiAoSE9QKHdhbGtlcnMsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlW2ldID0gdXNlcltpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJbaV0gPSB3YWxrZXJzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gY29udCgpO1xuICAgICAgICAgICAgICAgIGZvciAoaSBpbiBzYXZlKSBpZiAoSE9QKHNhdmUsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNhdmVbaV0pIGRlbGV0ZSB1c2VyW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB1c2VyW2ldID0gc2F2ZVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdhbGs6IHdhbGssXG4gICAgICAgICAgICAgICAgZGl2ZTogZGl2ZSxcbiAgICAgICAgICAgICAgICB3aXRoX3dhbGtlcnM6IHdpdGhfd2Fsa2VycyxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdOyAvLyBsYXN0IG9uZSBpcyBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0YWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH07XG59O1xuXG4vKiAtLS0tLVsgU2NvcGUgYW5kIG1hbmdsaW5nIF0tLS0tLSAqL1xuXG5mdW5jdGlvbiBTY29wZShwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5uYW1lcyA9IHt9OyAgICAgICAgLy8gbmFtZXMgZGVmaW5lZCBpbiB0aGlzIHNjb3BlXG4gICAgICAgIHRoaXMubWFuZ2xlZCA9IHt9OyAgICAgIC8vIG1hbmdsZWQgbmFtZXMgKG9yaWcubmFtZSA9PiBtYW5nbGVkKVxuICAgICAgICB0aGlzLnJldl9tYW5nbGVkID0ge307ICAvLyByZXZlcnNlIGxvb2t1cCAobWFuZ2xlZCA9PiBvcmlnLm5hbWUpXG4gICAgICAgIHRoaXMuY25hbWUgPSAtMTsgICAgICAgIC8vIGN1cnJlbnQgbWFuZ2xlZCBuYW1lXG4gICAgICAgIHRoaXMucmVmcyA9IHt9OyAgICAgICAgIC8vIG5hbWVzIHJlZmVyZW5jZWQgZnJvbSB0aGlzIHNjb3BlXG4gICAgICAgIHRoaXMudXNlc193aXRoID0gZmFsc2U7IC8vIHdpbGwgYmVjb21lIFRSVUUgaWYgd2l0aCgpIGlzIGRldGVjdGVkIGluIHRoaXMgb3IgYW55IHN1YnNjb3Blc1xuICAgICAgICB0aGlzLnVzZXNfZXZhbCA9IGZhbHNlOyAvLyB3aWxsIGJlY29tZSBUUlVFIGlmIGV2YWwoKSBpcyBkZXRlY3RlZCBpbiB0aGlzIG9yIGFueSBzdWJzY29wZXNcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gW107ICAgLy8gZGlyZWN0aXZlcyBhY3RpdmF0ZWQgZnJvbSB0aGlzIHNjb3BlXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50OyAgIC8vIHBhcmVudCBzY29wZVxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107ICAgICAvLyBzdWItc2NvcGVzXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxldmVsID0gcGFyZW50LmxldmVsICsgMTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxldmVsID0gMDtcbiAgICAgICAgfVxufTtcblxuZnVuY3Rpb24gYmFzZTU0X2RpZ2l0cygpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBESUdJVFNfT1ZFUlJJREVfRk9SX1RFU1RJTkcgIT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gRElHSVRTX09WRVJSSURFX0ZPUl9URVNUSU5HO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZXRucmlzb3VhZmxjaHBkdm1neWJ3RVN4VE5Da0xBT01fRFBIQmpGSXFSVXpXWFYkSktRR1laMDUxNjM3Mjk4NFwiO1xufVxuXG52YXIgYmFzZTU0ID0gKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBESUdJVFMgPSBiYXNlNTRfZGlnaXRzKCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihudW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gXCJcIiwgYmFzZSA9IDU0O1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCArPSBESUdJVFMuY2hhckF0KG51bSAlIGJhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBiYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UgPSA2NDtcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChudW0gPiAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xufSkoKTtcblxuU2NvcGUucHJvdG90eXBlID0ge1xuICAgICAgICBoYXM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gdGhpczsgczsgcyA9IHMucGFyZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEhPUChzLm5hbWVzLCBuYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0sXG4gICAgICAgIGhhc19tYW5nbGVkOiBmdW5jdGlvbihtbmFtZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSB0aGlzOyBzOyBzID0gcy5wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoSE9QKHMucmV2X21hbmdsZWQsIG1uYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0sXG4gICAgICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzOiB0aGlzLm5hbWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlc19ldmFsOiB0aGlzLnVzZXNfZXZhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXNfd2l0aDogdGhpcy51c2VzX3dpdGhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIG5leHRfbWFuZ2xlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgbXVzdCBiZSBjYXJlZnVsIHRoYXQgdGhlIG5ldyBtYW5nbGVkIG5hbWU6XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAxLiBkb2Vzbid0IHNoYWRvdyBhIG1hbmdsZWQgbmFtZSBmcm9tIGEgcGFyZW50XG4gICAgICAgICAgICAgICAgLy8gICAgc2NvcGUsIHVubGVzcyB3ZSBkb24ndCByZWZlcmVuY2UgdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgLy8gICAgbmFtZSBmcm9tIHRoaXMgc2NvcGUgT1IgZnJvbSBhbnkgc3ViLXNjb3BlcyFcbiAgICAgICAgICAgICAgICAvLyAgICBUaGlzIHdpbGwgZ2V0IHNsb3cuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAyLiBkb2Vzbid0IHNoYWRvdyBhbiBvcmlnaW5hbCBuYW1lIGZyb20gYSBwYXJlbnRcbiAgICAgICAgICAgICAgICAvLyAgICBzY29wZSwgaW4gdGhlIGV2ZW50IHRoYXQgdGhlIG5hbWUgaXMgbm90IG1hbmdsZWRcbiAgICAgICAgICAgICAgICAvLyAgICBpbiB0aGUgcGFyZW50IHNjb3BlIGFuZCB3ZSByZWZlcmVuY2UgdGhhdCBuYW1lXG4gICAgICAgICAgICAgICAgLy8gICAgaGVyZSBPUiBJTiBBTlkgU1VCU0NPUEVTIVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gMy4gZG9lc24ndCBzaGFkb3cgYSBuYW1lIHRoYXQgaXMgcmVmZXJlbmNlZCBidXQgbm90XG4gICAgICAgICAgICAgICAgLy8gICAgZGVmaW5lZCAocG9zc2libHkgZ2xvYmFsIGRlZmluZWQgZWxzZXdoZXJlKS5cbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IGJhc2U1NCgrK3RoaXMuY25hbWUpLCBwcmlvcjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAxLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3IgPSB0aGlzLmhhc19tYW5nbGVkKG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByaW9yICYmIHRoaXMucmVmc1twcmlvci5yZXZfbWFuZ2xlZFttXV0gPT09IHByaW9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAyLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3IgPSB0aGlzLmhhcyhtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmlvciAmJiBwcmlvciAhPT0gdGhpcyAmJiB0aGlzLnJlZnNbbV0gPT09IHByaW9yICYmICFwcmlvci5oYXNfbWFuZ2xlZChtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgMy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChIT1AodGhpcy5yZWZzLCBtKSAmJiB0aGlzLnJlZnNbbV0gPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEkgZ290IFwiZG9cIiBvbmNlLiA6LS9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNfaWRlbnRpZmllcihtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0X21hbmdsZTogZnVuY3Rpb24obmFtZSwgbSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmV2X21hbmdsZWRbbV0gPSBuYW1lO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbmdsZWRbbmFtZV0gPSBtO1xuICAgICAgICB9LFxuICAgICAgICBnZXRfbWFuZ2xlZDogZnVuY3Rpb24obmFtZSwgbmV3TWFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudXNlc19ldmFsIHx8IHRoaXMudXNlc193aXRoKSByZXR1cm4gbmFtZTsgLy8gbm8gbWFuZ2xlIGlmIGV2YWwgb3Igd2l0aCBpcyBpbiB1c2VcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMuaGFzKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghcykgcmV0dXJuIG5hbWU7IC8vIG5vdCBpbiB2aXNpYmxlIHNjb3BlLCBubyBtYW5nbGVcbiAgICAgICAgICAgICAgICBpZiAoSE9QKHMubWFuZ2xlZCwgbmFtZSkpIHJldHVybiBzLm1hbmdsZWRbbmFtZV07IC8vIGFscmVhZHkgbWFuZ2xlZCBpbiB0aGlzIHNjb3BlXG4gICAgICAgICAgICAgICAgaWYgKCFuZXdNYW5nbGUpIHJldHVybiBuYW1lOyAgICAgICAgICAgICAgICAgICAgICAvLyBub3QgZm91bmQgYW5kIG5vIG1hbmdsaW5nIHJlcXVlc3RlZFxuICAgICAgICAgICAgICAgIHJldHVybiBzLnNldF9tYW5nbGUobmFtZSwgcy5uZXh0X21hbmdsZWQoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZmVyZW5jZXM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZSAmJiAhdGhpcy5wYXJlbnQgfHwgdGhpcy51c2VzX3dpdGggfHwgdGhpcy51c2VzX2V2YWwgfHwgdGhpcy5yZWZzW25hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBkZWZpbmU6IGZ1bmN0aW9uKG5hbWUsIHR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBcInZhclwiIHx8ICFIT1AodGhpcy5uYW1lcywgbmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZXNbbmFtZV0gPSB0eXBlIHx8IFwidmFyXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFjdGl2ZV9kaXJlY3RpdmU6IGZ1bmN0aW9uKGRpcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZW1iZXIoZGlyLCB0aGlzLmRpcmVjdGl2ZXMpIHx8IHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmFjdGl2ZV9kaXJlY3RpdmUoZGlyKTtcbiAgICAgICAgfVxufTtcblxuZnVuY3Rpb24gYXN0X2FkZF9zY29wZShhc3QpIHtcblxuICAgICAgICB2YXIgY3VycmVudF9zY29wZSA9IG51bGw7XG4gICAgICAgIHZhciB3ID0gYXN0X3dhbGtlcigpLCB3YWxrID0gdy53YWxrO1xuICAgICAgICB2YXIgaGF2aW5nX2V2YWwgPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiB3aXRoX25ld19zY29wZShjb250KSB7XG4gICAgICAgICAgICAgICAgY3VycmVudF9zY29wZSA9IG5ldyBTY29wZShjdXJyZW50X3Njb3BlKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50X3Njb3BlLmxhYmVscyA9IG5ldyBTY29wZSgpO1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBjdXJyZW50X3Njb3BlLmJvZHkgPSBjb250KCk7XG4gICAgICAgICAgICAgICAgcmV0LnNjb3BlID0gY3VycmVudF9zY29wZTtcbiAgICAgICAgICAgICAgICBjdXJyZW50X3Njb3BlID0gY3VycmVudF9zY29wZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBkZWZpbmUobmFtZSwgdHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50X3Njb3BlLmRlZmluZShuYW1lLCB0eXBlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiByZWZlcmVuY2UobmFtZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfc2NvcGUucmVmc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gX2xhbWJkYShuYW1lLCBhcmdzLCBib2R5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzX2RlZnVuID0gdGhpc1swXSA9PSBcImRlZnVuXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgaXNfZGVmdW4gPyBkZWZpbmUobmFtZSwgXCJkZWZ1blwiKSA6IG5hbWUsIGFyZ3MsIHdpdGhfbmV3X3Njb3BlKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzX2RlZnVuKSBkZWZpbmUobmFtZSwgXCJsYW1iZGFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBNQVAoYXJncywgZnVuY3Rpb24obmFtZSl7IGRlZmluZShuYW1lLCBcImFyZ1wiKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNQVAoYm9keSwgd2Fsayk7XG4gICAgICAgICAgICAgICAgfSldO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIF92YXJkZWZzKHR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGVmcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgTUFQKGRlZnMsIGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmUoZFswXSwgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkWzFdKSByZWZlcmVuY2UoZFswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIF9icmVhY29udChsYWJlbCkge1xuICAgICAgICAgICAgICAgIGlmIChsYWJlbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfc2NvcGUubGFiZWxzLnJlZnNbbGFiZWxdID0gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gd2l0aF9uZXdfc2NvcGUoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIEFTVFxuICAgICAgICAgICAgICAgIHZhciByZXQgPSB3LndpdGhfd2Fsa2Vycyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCI6IF9sYW1iZGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImRlZnVuXCI6IF9sYW1iZGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxhYmVsXCI6IGZ1bmN0aW9uKG5hbWUsIHN0YXQpIHsgY3VycmVudF9zY29wZS5sYWJlbHMuZGVmaW5lKG5hbWUpIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImJyZWFrXCI6IF9icmVhY29udCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY29udGludWVcIjogX2JyZWFjb250LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aXRoXCI6IGZ1bmN0aW9uKGV4cHIsIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSBjdXJyZW50X3Njb3BlOyBzOyBzID0gcy5wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy51c2VzX3dpdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidmFyXCI6IF92YXJkZWZzKFwidmFyXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjb25zdFwiOiBfdmFyZGVmcyhcImNvbnN0XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0cnlcIjogZnVuY3Rpb24odCwgYywgZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyAhPSBudWxsKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTUFQKHQsIHdhbGspLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgZGVmaW5lKGNbMF0sIFwiY2F0Y2hcIiksIE1BUChjWzFdLCB3YWxrKSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgIT0gbnVsbCA/IE1BUChmLCB3YWxrKSA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBcImV2YWxcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXZpbmdfZXZhbC5wdXNoKGN1cnJlbnRfc2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2UobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3YWxrKGFzdCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyB0aGUgcmVhc29uIHdoeSB3ZSBuZWVkIGFuIGFkZGl0aW9uYWwgcGFzcyBoZXJlIGlzXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBuYW1lcyBjYW4gYmUgdXNlZCBwcmlvciB0byB0aGVpciBkZWZpbml0aW9uLlxuXG4gICAgICAgICAgICAgICAgLy8gc2NvcGVzIHdoZXJlIGV2YWwgd2FzIGRldGVjdGVkIGFuZCB0aGVpciBwYXJlbnRzXG4gICAgICAgICAgICAgICAgLy8gYXJlIG1hcmtlZCB3aXRoIHVzZXNfZXZhbCwgdW5sZXNzIHRoZXkgZGVmaW5lIHRoZVxuICAgICAgICAgICAgICAgIC8vIFwiZXZhbFwiIG5hbWUuXG4gICAgICAgICAgICAgICAgTUFQKGhhdmluZ19ldmFsLCBmdW5jdGlvbihzY29wZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNjb3BlLmhhcyhcImV2YWxcIikpIHdoaWxlIChzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS51c2VzX2V2YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZSA9IHNjb3BlLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGZvciByZWZlcmVuY2VkIG5hbWVzIGl0IG1pZ2h0IGJlIHVzZWZ1bCB0byBrbm93XG4gICAgICAgICAgICAgICAgLy8gdGhlaXIgb3JpZ2luIHNjb3BlLiAgY3VycmVudF9zY29wZSBoZXJlIGlzIHRoZVxuICAgICAgICAgICAgICAgIC8vIHRvcGxldmVsIG9uZS5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmaXhyZWZzKHNjb3BlLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBjaGlsZHJlbiBmaXJzdDsgb3JkZXIgc2hvdWxkbid0IG1hdHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gc2NvcGUuY2hpbGRyZW4ubGVuZ3RoOyAtLWkgPj0gMDspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpeHJlZnMoc2NvcGUuY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpIGluIHNjb3BlLnJlZnMpIGlmIChIT1Aoc2NvcGUucmVmcywgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBvcmlnaW4gc2NvcGUgYW5kIHByb3BhZ2F0ZSB0aGUgcmVmZXJlbmNlIHRvIG9yaWdpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBvcmlnaW4gPSBzY29wZS5oYXMoaSksIHMgPSBzY29wZTsgczsgcyA9IHMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5yZWZzW2ldID0gb3JpZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzID09PSBvcmlnaW4pIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmaXhyZWZzKGN1cnJlbnRfc2NvcGUpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSk7XG5cbn07XG5cbi8qIC0tLS0tWyBtYW5nbGUgbmFtZXMgXS0tLS0tICovXG5cbmZ1bmN0aW9uIGFzdF9tYW5nbGUoYXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB3ID0gYXN0X3dhbGtlcigpLCB3YWxrID0gdy53YWxrLCBzY29wZTtcbiAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBtYW5nbGUgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRvcGxldmVsICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRlZmluZXMgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgZXhjZXB0ICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBub19mdW5jdGlvbnMgOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRfbWFuZ2xlZChuYW1lLCBuZXdNYW5nbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMubWFuZ2xlKSByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMudG9wbGV2ZWwgJiYgIXNjb3BlLnBhcmVudCkgcmV0dXJuIG5hbWU7IC8vIGRvbid0IG1hbmdsZSB0b3BsZXZlbFxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmV4Y2VwdCAmJiBtZW1iZXIobmFtZSwgb3B0aW9ucy5leGNlcHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubm9fZnVuY3Rpb25zICYmIEhPUChzY29wZS5uYW1lcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNjb3BlLm5hbWVzW25hbWVdID09ICdkZWZ1bicgfHwgc2NvcGUubmFtZXNbbmFtZV0gPT0gJ2xhbWJkYScpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLmdldF9tYW5nbGVkKG5hbWUsIG5ld01hbmdsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0X2RlZmluZShuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgYWx3YXlzIGxvb2t1cCBhIGRlZmluZWQgc3ltYm9sIGZvciB0aGUgY3VycmVudCBzY29wZSBGSVJTVCwgc28gZGVjbGFyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhcnMgdHJ1bXAgYSBERUZJTkUgc3ltYm9sLCBidXQgaWYgbm8gc3VjaCB2YXIgaXMgZm91bmQsIHRoZW4gbWF0Y2ggYSBERUZJTkUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2NvcGUuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChIT1Aob3B0aW9ucy5kZWZpbmVzLCBuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRlZmluZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBfbGFtYmRhKG5hbWUsIGFyZ3MsIGJvZHkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMubm9fZnVuY3Rpb25zICYmIG9wdGlvbnMubWFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNfZGVmdW4gPSB0aGlzWzBdID09IFwiZGVmdW5cIiwgZXh0cmE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZGVmdW4pIG5hbWUgPSBnZXRfbWFuZ2xlZChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYm9keS5zY29wZS5yZWZlcmVuY2VzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzY29wZS51c2VzX2V2YWwgfHwgc2NvcGUudXNlc193aXRoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBleHRyYVtuYW1lXSA9IHNjb3BlLm5leHRfbWFuZ2xlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhW25hbWVdID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIG5hbWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBib2R5ID0gd2l0aF9zY29wZShib2R5LnNjb3BlLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IE1BUChhcmdzLCBmdW5jdGlvbihuYW1lKXsgcmV0dXJuIGdldF9tYW5nbGVkKG5hbWUpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1BUChib2R5LCB3YWxrKTtcbiAgICAgICAgICAgICAgICB9LCBleHRyYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgbmFtZSwgYXJncywgYm9keSBdO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHdpdGhfc2NvcGUocywgY29udCwgZXh0cmEpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3Njb3BlID0gc2NvcGU7XG4gICAgICAgICAgICAgICAgc2NvcGUgPSBzO1xuICAgICAgICAgICAgICAgIGlmIChleHRyYSkgZm9yICh2YXIgaSBpbiBleHRyYSkgaWYgKEhPUChleHRyYSwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuc2V0X21hbmdsZShpLCBleHRyYVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gcy5uYW1lcykgaWYgKEhPUChzLm5hbWVzLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0X21hbmdsZWQoaSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXQgPSBjb250KCk7XG4gICAgICAgICAgICAgICAgcmV0LnNjb3BlID0gcztcbiAgICAgICAgICAgICAgICBzY29wZSA9IF9zY29wZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIF92YXJkZWZzKGRlZnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBNQVAoZGVmcywgZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBnZXRfbWFuZ2xlZChkWzBdKSwgd2FsayhkWzFdKSBdO1xuICAgICAgICAgICAgICAgIH0pIF07XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gX2JyZWFjb250KGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsKSByZXR1cm4gWyB0aGlzWzBdLCBzY29wZS5sYWJlbHMuZ2V0X21hbmdsZWQobGFiZWwpIF07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHcud2l0aF93YWxrZXJzKHtcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCI6IF9sYW1iZGEsXG4gICAgICAgICAgICAgICAgXCJkZWZ1blwiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgZnVuY3Rpb24gZGVjbGFyYXRpb25zIHRvIHRoZSB0b3Agd2hlblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhleSBhcmUgbm90IGluIHNvbWUgYmxvY2suXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXN0ID0gX2xhbWJkYS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh3LnBhcmVudCgpWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvcGxldmVsXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRlZnVuXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNQVAuYXRfdG9wKGFzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJsYWJlbFwiOiBmdW5jdGlvbihsYWJlbCwgc3RhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlLmxhYmVscy5yZWZzW2xhYmVsXSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUubGFiZWxzLmdldF9tYW5nbGVkKGxhYmVsLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FsayhzdGF0KVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3YWxrKHN0YXQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJicmVha1wiOiBfYnJlYWNvbnQsXG4gICAgICAgICAgICAgICAgXCJjb250aW51ZVwiOiBfYnJlYWNvbnQsXG4gICAgICAgICAgICAgICAgXCJ2YXJcIjogX3ZhcmRlZnMsXG4gICAgICAgICAgICAgICAgXCJjb25zdFwiOiBfdmFyZGVmcyxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldF9kZWZpbmUobmFtZSkgfHwgWyB0aGlzWzBdLCBnZXRfbWFuZ2xlZChuYW1lKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ0cnlcIjogZnVuY3Rpb24odCwgYywgZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1BUCh0LCB3YWxrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgIT0gbnVsbCA/IFsgZ2V0X21hbmdsZWQoY1swXSksIE1BUChjWzFdLCB3YWxrKSBdIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgIT0gbnVsbCA/IE1BUChmLCB3YWxrKSA6IG51bGwgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwidG9wbGV2ZWxcIjogZnVuY3Rpb24oYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpdGhfc2NvcGUoc2VsZi5zY29wZSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgc2VsZlswXSwgTUFQKGJvZHksIHdhbGspIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZGlyZWN0aXZlXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1BUC5hdF90b3AodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2Fsayhhc3RfYWRkX3Njb3BlKGFzdCkpO1xuICAgICAgICB9KTtcbn07XG5cbi8qIC0tLS0tW1xuICAgLSBjb21wcmVzcyBmb29bXCJiYXJcIl0gaW50byBmb28uYmFyLFxuICAgLSByZW1vdmUgYmxvY2sgYnJhY2tldHMge30gd2hlcmUgcG9zc2libGVcbiAgIC0gam9pbiBjb25zZWN1dGl2ZSB2YXIgZGVjbGFyYXRpb25zXG4gICAtIHZhcmlvdXMgb3B0aW1pemF0aW9ucyBmb3IgSUZzOlxuICAgICAtIGlmIChjb25kKSBmb28oKTsgZWxzZSBiYXIoKTsgID09PiAgY29uZD9mb28oKTpiYXIoKTtcbiAgICAgLSBpZiAoY29uZCkgZm9vKCk7ICA9PT4gIGNvbmQmJmZvbygpO1xuICAgICAtIGlmIChmb28pIHJldHVybiBiYXIoKTsgZWxzZSByZXR1cm4gYmF6KCk7ICA9PT4gcmV0dXJuIGZvbz9iYXIoKTpiYXooKTsgLy8gYWxzbyBmb3IgdGhyb3dcbiAgICAgLSBpZiAoZm9vKSByZXR1cm4gYmFyKCk7IGVsc2Ugc29tZXRoaW5nKCk7ICA9PT4ge2lmKGZvbylyZXR1cm4gYmFyKCk7c29tZXRoaW5nKCl9XG4gICBdLS0tLS0gKi9cblxudmFyIHdhcm4gPSBmdW5jdGlvbigpe307XG5cbmZ1bmN0aW9uIGJlc3Rfb2YoYXN0MSwgYXN0Mikge1xuICAgICAgICByZXR1cm4gZ2VuX2NvZGUoYXN0MSkubGVuZ3RoID4gZ2VuX2NvZGUoYXN0MlswXSA9PSBcInN0YXRcIiA/IGFzdDJbMV0gOiBhc3QyKS5sZW5ndGggPyBhc3QyIDogYXN0MTtcbn07XG5cbmZ1bmN0aW9uIGxhc3Rfc3RhdChiKSB7XG4gICAgICAgIGlmIChiWzBdID09IFwiYmxvY2tcIiAmJiBiWzFdICYmIGJbMV0ubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gYlsxXVtiWzFdLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gYjtcbn1cblxuZnVuY3Rpb24gYWJvcnRzKHQpIHtcbiAgICAgICAgaWYgKHQpIHN3aXRjaCAobGFzdF9zdGF0KHQpWzBdKSB7XG4gICAgICAgICAgICBjYXNlIFwicmV0dXJuXCI6XG4gICAgICAgICAgICBjYXNlIFwiYnJlYWtcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjb250aW51ZVwiOlxuICAgICAgICAgICAgY2FzZSBcInRocm93XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbn07XG5cbmZ1bmN0aW9uIGJvb2xlYW5fZXhwcihleHByKSB7XG4gICAgICAgIHJldHVybiAoIChleHByWzBdID09IFwidW5hcnktcHJlZml4XCJcbiAgICAgICAgICAgICAgICAgICYmIG1lbWJlcihleHByWzFdLCBbIFwiIVwiLCBcImRlbGV0ZVwiIF0pKSB8fFxuXG4gICAgICAgICAgICAgICAgIChleHByWzBdID09IFwiYmluYXJ5XCJcbiAgICAgICAgICAgICAgICAgICYmIG1lbWJlcihleHByWzFdLCBbIFwiaW5cIiwgXCJpbnN0YW5jZW9mXCIsIFwiPT1cIiwgXCIhPVwiLCBcIj09PVwiLCBcIiE9PVwiLCBcIjxcIiwgXCI8PVwiLCBcIj49XCIsIFwiPlwiIF0pKSB8fFxuXG4gICAgICAgICAgICAgICAgIChleHByWzBdID09IFwiYmluYXJ5XCJcbiAgICAgICAgICAgICAgICAgICYmIG1lbWJlcihleHByWzFdLCBbIFwiJiZcIiwgXCJ8fFwiIF0pXG4gICAgICAgICAgICAgICAgICAmJiBib29sZWFuX2V4cHIoZXhwclsyXSlcbiAgICAgICAgICAgICAgICAgICYmIGJvb2xlYW5fZXhwcihleHByWzNdKSkgfHxcblxuICAgICAgICAgICAgICAgICAoZXhwclswXSA9PSBcImNvbmRpdGlvbmFsXCJcbiAgICAgICAgICAgICAgICAgICYmIGJvb2xlYW5fZXhwcihleHByWzJdKVxuICAgICAgICAgICAgICAgICAgJiYgYm9vbGVhbl9leHByKGV4cHJbM10pKSB8fFxuXG4gICAgICAgICAgICAgICAgIChleHByWzBdID09IFwiYXNzaWduXCJcbiAgICAgICAgICAgICAgICAgICYmIGV4cHJbMV0gPT09IHRydWVcbiAgICAgICAgICAgICAgICAgICYmIGJvb2xlYW5fZXhwcihleHByWzNdKSkgfHxcblxuICAgICAgICAgICAgICAgICAoZXhwclswXSA9PSBcInNlcVwiXG4gICAgICAgICAgICAgICAgICAmJiBib29sZWFuX2V4cHIoZXhwcltleHByLmxlbmd0aCAtIDFdKSlcbiAgICAgICAgICAgICAgICk7XG59O1xuXG5mdW5jdGlvbiBlbXB0eShiKSB7XG4gICAgICAgIHJldHVybiAhYiB8fCAoYlswXSA9PSBcImJsb2NrXCIgJiYgKCFiWzFdIHx8IGJbMV0ubGVuZ3RoID09IDApKTtcbn07XG5cbmZ1bmN0aW9uIGlzX3N0cmluZyhub2RlKSB7XG4gICAgICAgIHJldHVybiAobm9kZVswXSA9PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICAgICAgbm9kZVswXSA9PSBcInVuYXJ5LXByZWZpeFwiICYmIG5vZGVbMV0gPT0gXCJ0eXBlb2ZcIiB8fFxuICAgICAgICAgICAgICAgIG5vZGVbMF0gPT0gXCJiaW5hcnlcIiAmJiBub2RlWzFdID09IFwiK1wiICYmXG4gICAgICAgICAgICAgICAgKGlzX3N0cmluZyhub2RlWzJdKSB8fCBpc19zdHJpbmcobm9kZVszXSkpKTtcbn07XG5cbnZhciB3aGVuX2NvbnN0YW50ID0gKGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgdmFyICROT1RfQ09OU1RBTlQgPSB7fTtcblxuICAgICAgICAvLyB0aGlzIGNhbiBvbmx5IGV2YWx1YXRlIGNvbnN0YW50IGV4cHJlc3Npb25zLiAgSWYgaXQgZmluZHMgYW55dGhpbmdcbiAgICAgICAgLy8gbm90IGNvbnN0YW50LCBpdCB0aHJvd3MgJE5PVF9DT05TVEFOVC5cbiAgICAgICAgZnVuY3Rpb24gZXZhbHVhdGUoZXhwcikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXhwclswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHByWzFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXRvbVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChleHByWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRydWVcIjogcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZhbHNlXCI6IHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibnVsbFwiOiByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidW5hcnktcHJlZml4XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4cHJbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIVwiOiByZXR1cm4gIWV2YWx1YXRlKGV4cHJbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0eXBlb2ZcIjogcmV0dXJuIHR5cGVvZiBldmFsdWF0ZShleHByWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiflwiOiByZXR1cm4gfmV2YWx1YXRlKGV4cHJbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCItXCI6IHJldHVybiAtZXZhbHVhdGUoZXhwclsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIitcIjogcmV0dXJuICtldmFsdWF0ZShleHByWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYmluYXJ5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IGV4cHJbMl0sIHJpZ2h0ID0gZXhwclszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXhwclsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCImJlwiICAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgJiYgICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInx8XCIgICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSB8fCAgICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwifFwiICAgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpIHwgICAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCImXCIgICAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgJiAgICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIl5cIiAgICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSBeICAgICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiK1wiICAgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpICsgICAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIqXCIgICAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgKiAgICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIi9cIiAgICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSAvICAgICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiJVwiICAgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpICUgICAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCItXCIgICAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgLSAgICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIjw8XCIgICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSA8PCAgICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPj5cIiAgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpID4+ICAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI+Pj5cIiAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgPj4+ICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj09XCIgICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSA9PSAgICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPT09XCIgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpID09PSAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhPVwiICAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgIT0gICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiE9PVwiICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSAhPT0gICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPFwiICAgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpIDwgICAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI8PVwiICAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgPD0gICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj5cIiAgICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSA+ICAgICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPj1cIiAgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpID49ICAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpblwiICAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgaW4gICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluc3RhbmNlb2ZcIiA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSBpbnN0YW5jZW9mIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgJE5PVF9DT05TVEFOVDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXhwciwgeWVzLCBubykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gZXZhbHVhdGUoZXhwciksIGFzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjogYXN0ID0gIFsgXCJzdHJpbmdcIiwgdmFsIF07IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjogYXN0ID0gIFsgXCJudW1cIiwgdmFsIF07IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6IGFzdCA9ICBbIFwibmFtZVwiLCBTdHJpbmcodmFsKSBdOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsID09PSBudWxsKSB7IGFzdCA9IFsgXCJhdG9tXCIsIFwibnVsbFwiIF07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGhhbmRsZSBjb25zdGFudCBvZiB0eXBlOiBcIiArICh0eXBlb2YgdmFsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWVzLmNhbGwoZXhwciwgYXN0LCB2YWwpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleCA9PT0gJE5PVF9DT05TVEFOVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwclswXSA9PSBcImJpbmFyeVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoZXhwclsxXSA9PSBcIj09PVwiIHx8IGV4cHJbMV0gPT0gXCIhPT1cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICgoaXNfc3RyaW5nKGV4cHJbMl0pICYmIGlzX3N0cmluZyhleHByWzNdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAoYm9vbGVhbl9leHByKGV4cHJbMl0pICYmIGJvb2xlYW5fZXhwcihleHByWzNdKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwclsxXSA9IGV4cHJbMV0uc3Vic3RyKDAsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vICYmIGV4cHJbMF0gPT0gXCJiaW5hcnlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoZXhwclsxXSA9PSBcInx8XCIgfHwgZXhwclsxXSA9PSBcIiYmXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgd2hvbGUgZXhwcmVzc2lvbiBpcyBub3QgY29uc3RhbnQgYnV0IHRoZSBsdmFsIG1heSBiZS4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbHZhbCA9IGV2YWx1YXRlKGV4cHJbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSAoKGV4cHJbMV0gPT0gXCImJlwiICYmIChsdmFsID8gZXhwclszXSA6IGx2YWwpKSAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGV4cHJbMV0gPT0gXCJ8fFwiICYmIChsdmFsID8gbHZhbCAgICA6IGV4cHJbM10pKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGV4Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElHTk9SRS4uLiBsdmFsIGlzIG5vdCBjb25zdGFudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBubyA/IG5vLmNhbGwoZXhwciwgZXhwcikgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbn0pKCk7XG5cbmZ1bmN0aW9uIHdhcm5fdW5yZWFjaGFibGUoYXN0KSB7XG4gICAgICAgIGlmICghZW1wdHkoYXN0KSlcbiAgICAgICAgICAgICAgICB3YXJuKFwiRHJvcHBpbmcgdW5yZWFjaGFibGUgY29kZTogXCIgKyBnZW5fY29kZShhc3QsIHRydWUpKTtcbn07XG5cbmZ1bmN0aW9uIHByZXBhcmVfaWZzKGFzdCkge1xuICAgICAgICB2YXIgdyA9IGFzdF93YWxrZXIoKSwgd2FsayA9IHcud2FsaztcbiAgICAgICAgLy8gSW4gdGhpcyBmaXJzdCBwYXNzLCB3ZSByZXdyaXRlIGlmcyB3aGljaCBhYm9ydCB3aXRoIG5vIGVsc2Ugd2l0aCBhblxuICAgICAgICAvLyBpZi1lbHNlLiAgRm9yIGV4YW1wbGU6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGlmICh4KSB7XG4gICAgICAgIC8vICAgICBibGFoKCk7XG4gICAgICAgIC8vICAgICByZXR1cm4geTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBmb29iYXIoKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gaXMgcmV3cml0dGVuIGludG86XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGlmICh4KSB7XG4gICAgICAgIC8vICAgICBibGFoKCk7XG4gICAgICAgIC8vICAgICByZXR1cm4geTtcbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gICAgIGZvb2JhcigpO1xuICAgICAgICAvLyB9XG4gICAgICAgIGZ1bmN0aW9uIHJlZG9faWYoc3RhdGVtZW50cykge1xuICAgICAgICAgICAgICAgIHN0YXRlbWVudHMgPSBNQVAoc3RhdGVtZW50cywgd2Fsayk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaSA9IHN0YXRlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlbMF0gIT0gXCJpZlwiKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpWzNdKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBmaVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWJvcnRzKHQpKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmRpdGlvbmFsID0gd2FsayhmaVsxXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlX2JvZHkgPSByZWRvX2lmKHN0YXRlbWVudHMuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gZV9ib2R5Lmxlbmd0aCA9PSAxID8gZV9ib2R5WzBdIDogWyBcImJsb2NrXCIsIGVfYm9keSBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVtZW50cy5zbGljZSgwLCBpKS5jb25jYXQoWyBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpWzBdLCAgICAgICAgICAvLyBcImlmXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uYWwsICAgIC8vIGNvbmRpdGlvbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQsICAgICAgICAgICAgICAvLyB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgICAgICAgICAgICAgICAvLyBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBdIF0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnRzO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlZG9faWZfbGFtYmRhKG5hbWUsIGFyZ3MsIGJvZHkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gcmVkb19pZihib2R5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBuYW1lLCBhcmdzLCBib2R5IF07XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcmVkb19pZl9ibG9jayhzdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgc3RhdGVtZW50cyAhPSBudWxsID8gcmVkb19pZihzdGF0ZW1lbnRzKSA6IG51bGwgXTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdy53aXRoX3dhbGtlcnMoe1xuICAgICAgICAgICAgICAgIFwiZGVmdW5cIjogcmVkb19pZl9sYW1iZGEsXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiOiByZWRvX2lmX2xhbWJkYSxcbiAgICAgICAgICAgICAgICBcImJsb2NrXCI6IHJlZG9faWZfYmxvY2ssXG4gICAgICAgICAgICAgICAgXCJzcGxpY2VcIjogcmVkb19pZl9ibG9jayxcbiAgICAgICAgICAgICAgICBcInRvcGxldmVsXCI6IGZ1bmN0aW9uKHN0YXRlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHJlZG9faWYoc3RhdGVtZW50cykgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwidHJ5XCI6IGZ1bmN0aW9uKHQsIGMsIGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZG9faWYodCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgIT0gbnVsbCA/IFsgY1swXSwgcmVkb19pZihjWzFdKSBdIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiAhPSBudWxsID8gcmVkb19pZihmKSA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2Fsayhhc3QpO1xuICAgICAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGZvcl9zaWRlX2VmZmVjdHMoYXN0LCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciB3ID0gYXN0X3dhbGtlcigpLCB3YWxrID0gdy53YWxrO1xuICAgICAgICB2YXIgJHN0b3AgPSB7fSwgJHJlc3RhcnQgPSB7fTtcbiAgICAgICAgZnVuY3Rpb24gc3RvcCgpIHsgdGhyb3cgJHN0b3AgfTtcbiAgICAgICAgZnVuY3Rpb24gcmVzdGFydCgpIHsgdGhyb3cgJHJlc3RhcnQgfTtcbiAgICAgICAgZnVuY3Rpb24gZm91bmQoKXsgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCB0aGlzLCB3LCBzdG9wLCByZXN0YXJ0KSB9O1xuICAgICAgICBmdW5jdGlvbiB1bmFyeShvcCkge1xuICAgICAgICAgICAgICAgIGlmIChvcCA9PSBcIisrXCIgfHwgb3AgPT0gXCItLVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGJpbmFyeShvcCkge1xuICAgICAgICAgICAgICAgIGlmIChvcCA9PSBcIiYmXCIgfHwgb3AgPT0gXCJ8fFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB3LndpdGhfd2Fsa2Vycyh7XG4gICAgICAgICAgICAgICAgXCJ0cnlcIjogZm91bmQsXG4gICAgICAgICAgICAgICAgXCJ0aHJvd1wiOiBmb3VuZCxcbiAgICAgICAgICAgICAgICBcInJldHVyblwiOiBmb3VuZCxcbiAgICAgICAgICAgICAgICBcIm5ld1wiOiBmb3VuZCxcbiAgICAgICAgICAgICAgICBcInN3aXRjaFwiOiBmb3VuZCxcbiAgICAgICAgICAgICAgICBcImJyZWFrXCI6IGZvdW5kLFxuICAgICAgICAgICAgICAgIFwiY29udGludWVcIjogZm91bmQsXG4gICAgICAgICAgICAgICAgXCJhc3NpZ25cIjogZm91bmQsXG4gICAgICAgICAgICAgICAgXCJjYWxsXCI6IGZvdW5kLFxuICAgICAgICAgICAgICAgIFwiaWZcIjogZm91bmQsXG4gICAgICAgICAgICAgICAgXCJmb3JcIjogZm91bmQsXG4gICAgICAgICAgICAgICAgXCJmb3ItaW5cIjogZm91bmQsXG4gICAgICAgICAgICAgICAgXCJ3aGlsZVwiOiBmb3VuZCxcbiAgICAgICAgICAgICAgICBcImRvXCI6IGZvdW5kLFxuICAgICAgICAgICAgICAgIFwicmV0dXJuXCI6IGZvdW5kLFxuICAgICAgICAgICAgICAgIFwidW5hcnktcHJlZml4XCI6IHVuYXJ5LFxuICAgICAgICAgICAgICAgIFwidW5hcnktcG9zdGZpeFwiOiB1bmFyeSxcbiAgICAgICAgICAgICAgICBcImNvbmRpdGlvbmFsXCI6IGZvdW5kLFxuICAgICAgICAgICAgICAgIFwiYmluYXJ5XCI6IGJpbmFyeSxcbiAgICAgICAgICAgICAgICBcImRlZnVuXCI6IGZvdW5kXG4gICAgICAgIH0sIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxrKGFzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXggPT09ICRzdG9wKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleCA9PT0gJHJlc3RhcnQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGFzdF9saWZ0X3ZhcmlhYmxlcyhhc3QpIHtcbiAgICAgICAgdmFyIHcgPSBhc3Rfd2Fsa2VyKCksIHdhbGsgPSB3LndhbGssIHNjb3BlO1xuICAgICAgICBmdW5jdGlvbiBkb19ib2R5KGJvZHksIGVudikge1xuICAgICAgICAgICAgICAgIHZhciBfc2NvcGUgPSBzY29wZTtcbiAgICAgICAgICAgICAgICBzY29wZSA9IGVudjtcbiAgICAgICAgICAgICAgICBib2R5ID0gTUFQKGJvZHksIHdhbGspO1xuICAgICAgICAgICAgICAgIHZhciBoYXNoID0ge30sIG5hbWVzID0gTUFQKGVudi5uYW1lcywgZnVuY3Rpb24odHlwZSwgbmFtZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPSBcInZhclwiKSByZXR1cm4gTUFQLnNraXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVudi5yZWZlcmVuY2VzKG5hbWUpKSByZXR1cm4gTUFQLnNraXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIG5hbWUgXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9va2luZyBmb3IgYXNzaWdubWVudHMgdG8gYW55IG9mIHRoZXNlIHZhcmlhYmxlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBzYXZlIGNvbnNpZGVyYWJsZSBzcGFjZSBieSBtb3ZpbmcgdGhlIGRlZmluaXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgdmFyIGRlY2xhcmF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yX3NpZGVfZWZmZWN0cyhbIFwiYmxvY2tcIiwgYm9keSBdLCBmdW5jdGlvbihhc3QsIHdhbGtlciwgc3RvcCwgcmVzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXN0WzBdID09IFwiYXNzaWduXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGFzdFsxXSA9PT0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgYXN0WzJdWzBdID09IFwibmFtZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBIT1AoaGFzaCwgYXN0WzJdWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2VydCB0aGUgZGVmaW5pdGlvbiBpbnRvIHRoZSB2YXIgZGVjbGFyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbmFtZXMubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lc1tpXVswXSA9PSBhc3RbMl1bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVzW2ldWzFdKSAvLyB0aGlzIG5hbWUgYWxyZWFkeSBkZWZpbmVkLCB3ZSBtdXN0IHN0b3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzW2ldWzFdID0gYXN0WzNdOyAvLyBkZWZpbml0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzLnB1c2gobmFtZXMuc3BsaWNlKGksIDEpWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGlzIGFzc2lnbm1lbnQgZnJvbSB0aGUgQVNULlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gd2Fsa2VyLnBhcmVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwWzBdID09IFwic2VxXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gcFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEudW5zaGlmdCgwLCBwLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLnNwbGljZS5hcHBseShwLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocFswXSA9PSBcInN0YXRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5zcGxpY2UoMCwgcC5sZW5ndGgsIFwiYmxvY2tcIik7IC8vIGVtcHR5IHN0YXRlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS51bnNoaWZ0KFsgXCJ2YXJcIiwgbmFtZXMgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNjb3BlID0gX3Njb3BlO1xuICAgICAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBfdmFyZGVmcyhkZWZzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRlZnMubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gZGVmc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZFsxXSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gWyBcImFzc2lnblwiLCB0cnVlLCBbIFwibmFtZVwiLCBkWzBdIF0sIGRbMV0gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgPT0gbnVsbCkgcmV0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgcmV0ID0gWyBcInNlcVwiLCBkLCByZXQgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJldCA9PSBudWxsICYmIHcucGFyZW50KClbMF0gIT0gXCJmb3JcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHcucGFyZW50KClbMF0gPT0gXCJmb3ItaW5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgXCJuYW1lXCIsIGRlZnNbMF1bMF0gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNQVAuc2tpcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgXCJzdGF0XCIsIHJldCBdO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBfdG9wbGV2ZWwoYm9keSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIGRvX2JvZHkoYm9keSwgdGhpcy5zY29wZSkgXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHcud2l0aF93YWxrZXJzKHtcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCI6IGZ1bmN0aW9uKG5hbWUsIGFyZ3MsIGJvZHkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGFyZ3MubGVuZ3RoOyAtLWkgPj0gMCAmJiAhYm9keS5zY29wZS5yZWZlcmVuY2VzKGFyZ3NbaV0pOylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYm9keS5zY29wZS5yZWZlcmVuY2VzKG5hbWUpKSBuYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIG5hbWUsIGFyZ3MsIGRvX2JvZHkoYm9keSwgYm9keS5zY29wZSkgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZGVmdW5cIjogZnVuY3Rpb24obmFtZSwgYXJncywgYm9keSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNjb3BlLnJlZmVyZW5jZXMobmFtZSkpIHJldHVybiBNQVAuc2tpcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBhcmdzLmxlbmd0aDsgLS1pID49IDAgJiYgIWJvZHkuc2NvcGUucmVmZXJlbmNlcyhhcmdzW2ldKTspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBuYW1lLCBhcmdzLCBkb19ib2R5KGJvZHksIGJvZHkuc2NvcGUpIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInZhclwiOiBfdmFyZGVmcyxcbiAgICAgICAgICAgICAgICBcInRvcGxldmVsXCI6IF90b3BsZXZlbFxuICAgICAgICB9LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHJldHVybiB3YWxrKGFzdF9hZGRfc2NvcGUoYXN0KSk7XG4gICAgICAgIH0pO1xufTtcblxuZnVuY3Rpb24gYXN0X3NxdWVlemUoYXN0LCBvcHRpb25zKSB7XG4gICAgICAgIGFzdCA9IHNxdWVlemVfMShhc3QsIG9wdGlvbnMpO1xuICAgICAgICBhc3QgPSBzcXVlZXplXzIoYXN0LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbn07XG5cbmZ1bmN0aW9uIHNxdWVlemVfMShhc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBtYWtlX3NlcXMgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgZGVhZF9jb2RlICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgIG5vX3dhcm5pbmdzIDogZmFsc2UsXG4gICAgICAgICAgICAgICAga2VlcF9jb21wcyAgOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVuc2FmZSAgICAgIDogZmFsc2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHcgPSBhc3Rfd2Fsa2VyKCksIHdhbGsgPSB3LndhbGssIHNjb3BlO1xuXG4gICAgICAgIGZ1bmN0aW9uIG5lZ2F0ZShjKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vdF9jID0gWyBcInVuYXJ5LXByZWZpeFwiLCBcIiFcIiwgYyBdO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY1swXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidW5hcnktcHJlZml4XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY1sxXSA9PSBcIiFcIiAmJiBib29sZWFuX2V4cHIoY1syXSkgPyBjWzJdIDogbm90X2M7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzZXFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBzbGljZShjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNbYy5sZW5ndGggLSAxXSA9IG5lZ2F0ZShjW2MubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjb25kaXRpb25hbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3Rfb2Yobm90X2MsIFsgXCJjb25kaXRpb25hbFwiLCBjWzFdLCBuZWdhdGUoY1syXSksIG5lZ2F0ZShjWzNdKSBdKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJpbmFyeVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wID0gY1sxXSwgbGVmdCA9IGNbMl0sIHJpZ2h0ID0gY1szXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5rZWVwX2NvbXBzKSBzd2l0Y2ggKG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIjw9XCIgIDogcmV0dXJuIFsgXCJiaW5hcnlcIiwgXCI+XCIsIGxlZnQsIHJpZ2h0IF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIjxcIiAgIDogcmV0dXJuIFsgXCJiaW5hcnlcIiwgXCI+PVwiLCBsZWZ0LCByaWdodCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI+PVwiICA6IHJldHVybiBbIFwiYmluYXJ5XCIsIFwiPFwiLCBsZWZ0LCByaWdodCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI+XCIgICA6IHJldHVybiBbIFwiYmluYXJ5XCIsIFwiPD1cIiwgbGVmdCwgcmlnaHQgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPT1cIiAgOiByZXR1cm4gWyBcImJpbmFyeVwiLCBcIiE9XCIsIGxlZnQsIHJpZ2h0IF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiE9XCIgIDogcmV0dXJuIFsgXCJiaW5hcnlcIiwgXCI9PVwiLCBsZWZ0LCByaWdodCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI9PT1cIiA6IHJldHVybiBbIFwiYmluYXJ5XCIsIFwiIT09XCIsIGxlZnQsIHJpZ2h0IF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiE9PVwiIDogcmV0dXJuIFsgXCJiaW5hcnlcIiwgXCI9PT1cIiwgbGVmdCwgcmlnaHQgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiJiZcIiAgOiByZXR1cm4gYmVzdF9vZihub3RfYywgWyBcImJpbmFyeVwiLCBcInx8XCIsIG5lZ2F0ZShsZWZ0KSwgbmVnYXRlKHJpZ2h0KSBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwifHxcIiAgOiByZXR1cm4gYmVzdF9vZihub3RfYywgWyBcImJpbmFyeVwiLCBcIiYmXCIsIG5lZ2F0ZShsZWZ0KSwgbmVnYXRlKHJpZ2h0KSBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm90X2M7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZV9jb25kaXRpb25hbChjLCB0LCBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1ha2VfcmVhbF9jb25kaXRpb25hbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNbMF0gPT0gXCJ1bmFyeS1wcmVmaXhcIiAmJiBjWzFdID09IFwiIVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlID8gWyBcImNvbmRpdGlvbmFsXCIsIGNbMl0sIGUsIHQgXSA6IFsgXCJiaW5hcnlcIiwgXCJ8fFwiLCBjWzJdLCB0IF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSA/IGJlc3Rfb2YoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBcImNvbmRpdGlvbmFsXCIsIGMsIHQsIGUgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIFwiY29uZGl0aW9uYWxcIiwgbmVnYXRlKGMpLCBlLCB0IF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSA6IFsgXCJiaW5hcnlcIiwgXCImJlwiLCBjLCB0IF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBzaG9ydGN1dCB0aGUgY29uZGl0aW9uYWwgaWYgdGhlIGV4cHJlc3Npb24gaGFzIGEgY29uc3RhbnQgdmFsdWVcbiAgICAgICAgICAgICAgICByZXR1cm4gd2hlbl9jb25zdGFudChjLCBmdW5jdGlvbihhc3QsIHZhbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuX3VucmVhY2hhYmxlKHZhbCA/IGUgOiB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAgICAgICAgICAodmFsID8gdCA6IGUpO1xuICAgICAgICAgICAgICAgIH0sIG1ha2VfcmVhbF9jb25kaXRpb25hbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcm1ibG9jayhibG9jaykge1xuICAgICAgICAgICAgICAgIGlmIChibG9jayAhPSBudWxsICYmIGJsb2NrWzBdID09IFwiYmxvY2tcIiAmJiBibG9ja1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrWzFdLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jayA9IGJsb2NrWzFdWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYmxvY2tbMV0ubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gWyBcImJsb2NrXCIgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIF9sYW1iZGEobmFtZSwgYXJncywgYm9keSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIG5hbWUsIGFyZ3MsIHRpZ2h0ZW4oYm9keSwgXCJsYW1iZGFcIikgXTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIGRvZXMgYSBmZXcgdGhpbmdzOlxuICAgICAgICAvLyAxLiBkaXNjYXJkIHVzZWxlc3MgYmxvY2tzXG4gICAgICAgIC8vIDIuIGpvaW4gY29uc2VjdXRpdmUgdmFyIGRlY2xhcmF0aW9uc1xuICAgICAgICAvLyAzLiByZW1vdmUgb2J2aW91c2x5IGRlYWQgY29kZVxuICAgICAgICAvLyA0LiB0cmFuc2Zvcm0gY29uc2VjdXRpdmUgc3RhdGVtZW50cyB1c2luZyB0aGUgY29tbWEgb3BlcmF0b3JcbiAgICAgICAgLy8gNS4gaWYgYmxvY2tfdHlwZSA9PSBcImxhbWJkYVwiIGFuZCBpdCBkZXRlY3RzIGNvbnN0cnVjdHMgbGlrZSBpZihmb28pIHJldHVybiAuLi4gLSByZXdyaXRlIGxpa2UgaWYgKCFmb28pIHsgLi4uIH1cbiAgICAgICAgZnVuY3Rpb24gdGlnaHRlbihzdGF0ZW1lbnRzLCBibG9ja190eXBlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVtZW50cyA9IE1BUChzdGF0ZW1lbnRzLCB3YWxrKTtcblxuICAgICAgICAgICAgICAgIHN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzLnJlZHVjZShmdW5jdGlvbihhLCBzdGF0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0WzBdID09IFwiYmxvY2tcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdFsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaC5hcHBseShhLCBzdGF0WzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgfSwgW10pO1xuXG4gICAgICAgICAgICAgICAgc3RhdGVtZW50cyA9IChmdW5jdGlvbihhLCBwcmV2KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudHMuZm9yRWFjaChmdW5jdGlvbihjdXIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldiAmJiAoKGN1clswXSA9PSBcInZhclwiICYmIHByZXZbMF0gPT0gXCJ2YXJcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjdXJbMF0gPT0gXCJjb25zdFwiICYmIHByZXZbMF0gPT0gXCJjb25zdFwiKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2WzFdID0gcHJldlsxXS5jb25jYXQoY3VyWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goY3VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gY3VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICAgIH0pKFtdKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlYWRfY29kZSkgc3RhdGVtZW50cyA9IChmdW5jdGlvbihhLCBoYXNfcXVpdCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oc3Qpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzX3F1aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RbMF0gPT0gXCJmdW5jdGlvblwiIHx8IHN0WzBdID09IFwiZGVmdW5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RbMF0gPT0gXCJ2YXJcIiB8fCBzdFswXSA9PSBcImNvbnN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5ub193YXJuaW5ncylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybihcIlZhcmlhYmxlcyBkZWNsYXJlZCBpbiB1bnJlYWNoYWJsZSBjb2RlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RbMV0gPSBNQVAoc3RbMV0sIGZ1bmN0aW9uKGRlZil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZbMV0gJiYgIW9wdGlvbnMubm9fd2FybmluZ3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Fybl91bnJlYWNoYWJsZShbIFwiYXNzaWduXCIsIHRydWUsIFsgXCJuYW1lXCIsIGRlZlswXSBdLCBkZWZbMV0gXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIGRlZlswXSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghb3B0aW9ucy5ub193YXJuaW5ncylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5fdW5yZWFjaGFibGUoc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlcihzdFswXSwgWyBcInJldHVyblwiLCBcInRocm93XCIsIFwiYnJlYWtcIiwgXCJjb250aW51ZVwiIF0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzX3F1aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICAgIH0pKFtdKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1ha2Vfc2Vxcykgc3RhdGVtZW50cyA9IChmdW5jdGlvbihhLCBwcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oY3VyKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldlswXSA9PSBcInN0YXRcIiAmJiBjdXJbMF0gPT0gXCJzdGF0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2WzFdID0gWyBcInNlcVwiLCBwcmV2WzFdLCBjdXJbMV0gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goY3VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gY3VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhLmxlbmd0aCA+PSAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgYVthLmxlbmd0aC0yXVswXSA9PSBcInN0YXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChhW2EubGVuZ3RoLTFdWzBdID09IFwicmV0dXJuXCIgfHwgYVthLmxlbmd0aC0xXVswXSA9PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgYVthLmxlbmd0aC0xXVsxXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5zcGxpY2UoYS5sZW5ndGggLSAyLCAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIGFbYS5sZW5ndGgtMV1bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBcInNlcVwiLCBhW2EubGVuZ3RoLTJdWzFdLCBhW2EubGVuZ3RoLTFdWzFdIF1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICAgIH0pKFtdKTtcblxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaW5jcmVhc2VzIGpRdWVyeSBieSAxSy4gIFByb2JhYmx5IG5vdCBzdWNoIGEgZ29vZCBpZGVhIGFmdGVyIGFsbC4uXG4gICAgICAgICAgICAgICAgLy8gcGFydCBvZiB0aGlzIGlzIGRvbmUgaW4gcHJlcGFyZV9pZnMgYW55d2F5LlxuICAgICAgICAgICAgICAgIC8vIGlmIChibG9ja190eXBlID09IFwibGFtYmRhXCIpIHN0YXRlbWVudHMgPSAoZnVuY3Rpb24oaSwgYSwgc3RhdCl7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICB3aGlsZSAoaSA8IHN0YXRlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgIHN0YXQgPSBzdGF0ZW1lbnRzW2krK107XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgIGlmIChzdGF0WzBdID09IFwiaWZcIiAmJiAhc3RhdFszXSkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0WzJdWzBdID09IFwicmV0dXJuXCIgJiYgc3RhdFsyXVsxXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2gobWFrZV9pZihuZWdhdGUoc3RhdFsxXSksIFsgXCJibG9ja1wiLCBzdGF0ZW1lbnRzLnNsaWNlKGkpIF0pKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IGxhc3Rfc3RhdChzdGF0WzJdKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFswXSA9PSBcInJldHVyblwiICYmIGxhc3RbMV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKG1ha2VfaWYoc3RhdFsxXSwgWyBcImJsb2NrXCIsIHN0YXRbMl1bMV0uc2xpY2UoMCwgLTEpIF0sIFsgXCJibG9ja1wiLCBzdGF0ZW1lbnRzLnNsaWNlKGkpIF0pKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICBhLnB1c2goc3RhdCk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgICAvLyB9KSgwLCBbXSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVtZW50cztcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBtYWtlX2lmKGMsIHQsIGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2hlbl9jb25zdGFudChjLCBmdW5jdGlvbihhc3QsIHZhbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSB3YWxrKHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuX3VucmVhY2hhYmxlKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCB8fCBbIFwiYmxvY2tcIiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHdhbGsoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5fdW5yZWFjaGFibGUodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlIHx8IFsgXCJibG9ja1wiIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9yZWFsX2lmKGMsIHQsIGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGFib3J0X2Vsc2UoYywgdCwgZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBbIFsgXCJpZlwiLCBuZWdhdGUoYyksIGUgXSBdO1xuICAgICAgICAgICAgICAgIGlmICh0WzBdID09IFwiYmxvY2tcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRbMV0pIHJldCA9IHJldC5jb25jYXQodFsxXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gd2FsayhbIFwiYmxvY2tcIiwgcmV0IF0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VfcmVhbF9pZihjLCB0LCBlKSB7XG4gICAgICAgICAgICAgICAgYyA9IHdhbGsoYyk7XG4gICAgICAgICAgICAgICAgdCA9IHdhbGsodCk7XG4gICAgICAgICAgICAgICAgZSA9IHdhbGsoZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZW1wdHkoZSkgJiYgZW1wdHkodCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBcInN0YXRcIiwgYyBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVtcHR5KHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gbmVnYXRlKGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVtcHR5KGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBib3RoIGVsc2UgYW5kIHRoZW4sIG1heWJlIGl0IG1ha2VzIHNlbnNlIHRvIHN3aXRjaCB0aGVtP1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gZ2VuX2NvZGUoYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gbmVnYXRlKGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGdlbl9jb2RlKG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYi5sZW5ndGggPCBhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB0bXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXQgPSBbIFwiaWZcIiwgYywgdCwgZSBdO1xuICAgICAgICAgICAgICAgIGlmICh0WzBdID09IFwiaWZcIiAmJiBlbXB0eSh0WzNdKSAmJiBlbXB0eShlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gYmVzdF9vZihyZXQsIHdhbGsoWyBcImlmXCIsIFsgXCJiaW5hcnlcIiwgXCImJlwiLCBjLCB0WzFdIF0sIHRbMl0gXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0WzBdID09IFwic3RhdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZVswXSA9PSBcInN0YXRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBiZXN0X29mKHJldCwgWyBcInN0YXRcIiwgbWFrZV9jb25kaXRpb25hbChjLCB0WzFdLCBlWzFdKSBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYWJvcnRzKGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IGFib3J0X2Vsc2UoYywgdCwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gYmVzdF9vZihyZXQsIFsgXCJzdGF0XCIsIG1ha2VfY29uZGl0aW9uYWwoYywgdFsxXSkgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUgJiYgdFswXSA9PSBlWzBdICYmICh0WzBdID09IFwicmV0dXJuXCIgfHwgdFswXSA9PSBcInRocm93XCIpICYmIHRbMV0gJiYgZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gYmVzdF9vZihyZXQsIFsgdFswXSwgbWFrZV9jb25kaXRpb25hbChjLCB0WzFdLCBlWzFdICkgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUgJiYgYWJvcnRzKHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBbIFsgXCJpZlwiLCBjLCB0IF0gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlWzBdID09IFwiYmxvY2tcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZVsxXSkgcmV0ID0gcmV0LmNvbmNhdChlWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHdhbGsoWyBcImJsb2NrXCIsIHJldCBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodCAmJiBhYm9ydHMoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IGFib3J0X2Vsc2UoYywgdCwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gX2RvX3doaWxlKGNvbmQsIGJvZHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2hlbl9jb25zdGFudChjb25kLCBmdW5jdGlvbihjb25kLCB2YWwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Fybl91bnJlYWNoYWJsZShib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgXCJibG9ja1wiIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBcImZvclwiLCBudWxsLCBudWxsLCBudWxsLCB3YWxrKGJvZHkpIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHcud2l0aF93YWxrZXJzKHtcbiAgICAgICAgICAgICAgICBcInN1YlwiOiBmdW5jdGlvbihleHByLCBzdWJzY3JpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRbMF0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHN1YnNjcmlwdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2lkZW50aWZpZXIobmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgXCJkb3RcIiwgd2FsayhleHByKSwgbmFtZSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvXlsxLTldWzAtOV0qJC8udGVzdChuYW1lKSB8fCBuYW1lID09PSBcIjBcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBcInN1YlwiLCB3YWxrKGV4cHIpLCBbIFwibnVtXCIsIHBhcnNlSW50KG5hbWUsIDEwKSBdIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImlmXCI6IG1ha2VfaWYsXG4gICAgICAgICAgICAgICAgXCJ0b3BsZXZlbFwiOiBmdW5jdGlvbihib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBcInRvcGxldmVsXCIsIHRpZ2h0ZW4oYm9keSkgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwic3dpdGNoXCI6IGZ1bmN0aW9uKGV4cHIsIGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gYm9keS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgXCJzd2l0Y2hcIiwgd2FsayhleHByKSwgTUFQKGJvZHksIGZ1bmN0aW9uKGJyYW5jaCwgaSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibG9jayA9IHRpZ2h0ZW4oYnJhbmNoWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gbGFzdCAmJiBibG9jay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBibG9ja1tibG9jay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVswXSA9PSBcImJyZWFrXCIgJiYgIW5vZGVbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBicmFuY2hbMF0gPyB3YWxrKGJyYW5jaFswXSkgOiBudWxsLCBibG9jayBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIjogX2xhbWJkYSxcbiAgICAgICAgICAgICAgICBcImRlZnVuXCI6IF9sYW1iZGEsXG4gICAgICAgICAgICAgICAgXCJibG9ja1wiOiBmdW5jdGlvbihib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keSkgcmV0dXJuIHJtYmxvY2soWyBcImJsb2NrXCIsIHRpZ2h0ZW4oYm9keSkgXSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImJpbmFyeVwiOiBmdW5jdGlvbihvcCwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aGVuX2NvbnN0YW50KFsgXCJiaW5hcnlcIiwgb3AsIHdhbGsobGVmdCksIHdhbGsocmlnaHQpIF0sIGZ1bmN0aW9uIHllcyhjKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3Rfb2Yod2FsayhjKSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiBubygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYob3AgIT0gXCI9PVwiICYmIG9wICE9IFwiIT1cIikgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gd2FsayhsZWZ0KSwgciA9IHdhbGsocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGwgJiYgbFswXSA9PSBcInVuYXJ5LXByZWZpeFwiICYmIGxbMV0gPT0gXCIhXCIgJiYgbFsyXVswXSA9PSBcIm51bVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IFsnbnVtJywgKyFsWzJdWzFdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyICYmIHJbMF0gPT0gXCJ1bmFyeS1wcmVmaXhcIiAmJiByWzFdID09IFwiIVwiICYmIHJbMl1bMF0gPT0gXCJudW1cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gWydudW0nLCArIXJbMl1bMV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJiaW5hcnlcIiwgb3AsIGxlZnQsIHJpZ2h0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSgpIHx8IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiY29uZGl0aW9uYWxcIjogZnVuY3Rpb24oYywgdCwgZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VfY29uZGl0aW9uYWwod2FsayhjKSwgd2Fsayh0KSwgd2FsayhlKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInRyeVwiOiBmdW5jdGlvbih0LCBjLCBmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRyeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWdodGVuKHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjICE9IG51bGwgPyBbIGNbMF0sIHRpZ2h0ZW4oY1sxXSkgXSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgIT0gbnVsbCA/IHRpZ2h0ZW4oZikgOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ1bmFyeS1wcmVmaXhcIjogZnVuY3Rpb24ob3AsIGV4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB3YWxrKGV4cHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IFsgXCJ1bmFyeS1wcmVmaXhcIiwgb3AsIGV4cHIgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCA9PSBcIiFcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gYmVzdF9vZihyZXQsIG5lZ2F0ZShleHByKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2hlbl9jb25zdGFudChyZXQsIGZ1bmN0aW9uKGFzdCwgdmFsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGsoYXN0KTsgLy8gaXQncyBlaXRoZXIgdHJ1ZSBvciBmYWxzZSwgc28gbWluaWZpZXMgdG8gITAgb3IgITFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmV0IH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0cnVlXCI6IHJldHVybiBbIFwidW5hcnktcHJlZml4XCIsIFwiIVwiLCBbIFwibnVtXCIsIDAgXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZhbHNlXCI6IHJldHVybiBbIFwidW5hcnktcHJlZml4XCIsIFwiIVwiLCBbIFwibnVtXCIsIDEgXV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIndoaWxlXCI6IF9kb193aGlsZSxcbiAgICAgICAgICAgICAgICBcImFzc2lnblwiOiBmdW5jdGlvbihvcCwgbHZhbHVlLCBydmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGx2YWx1ZSA9IHdhbGsobHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ2YWx1ZSA9IHdhbGsocnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBva09wcyA9IFsgJysnLCAnLScsICcvJywgJyonLCAnJScsICc+PicsICc8PCcsICc+Pj4nLCAnfCcsICdeJywgJyYnIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AgPT09IHRydWUgJiYgbHZhbHVlWzBdID09PSBcIm5hbWVcIiAmJiBydmFsdWVbMF0gPT09IFwiYmluYXJ5XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB+b2tPcHMuaW5kZXhPZihydmFsdWVbMV0pICYmIHJ2YWx1ZVsyXVswXSA9PT0gXCJuYW1lXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydmFsdWVbMl1bMV0gPT09IGx2YWx1ZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBydmFsdWVbMV0sIGx2YWx1ZSwgcnZhbHVlWzNdIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIG9wLCBsdmFsdWUsIHJ2YWx1ZSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJjYWxsXCI6IGZ1bmN0aW9uKGV4cHIsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB3YWxrKGV4cHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudW5zYWZlICYmIGV4cHJbMF0gPT0gXCJkb3RcIiAmJiBleHByWzFdWzBdID09IFwic3RyaW5nXCIgJiYgZXhwclsyXSA9PSBcInRvU3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cHJbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBleHByLCAgTUFQKGFyZ3MsIHdhbGspIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIm51bVwiOiBmdW5jdGlvbiAobnVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKG51bSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIFwiYmluYXJ5XCIsIFwiL1wiLCBudW0gPT09IDEgLyAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gWyBcIm51bVwiLCAxIF0gOiBudW0gPT09IC0xIC8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFsgXCJ1bmFyeS1wcmVmaXhcIiwgXCItXCIsIFsgXCJudW1cIiwgMSBdIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbIFwibnVtXCIsIDAgXSwgWyBcIm51bVwiLCAwIF0gXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgbnVtIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2FsayhwcmVwYXJlX2lmcyh3YWxrKHByZXBhcmVfaWZzKGFzdCkpKSk7XG4gICAgICAgIH0pO1xufTtcblxuZnVuY3Rpb24gc3F1ZWV6ZV8yKGFzdCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdyA9IGFzdF93YWxrZXIoKSwgd2FsayA9IHcud2Fsaywgc2NvcGU7XG4gICAgICAgIGZ1bmN0aW9uIHdpdGhfc2NvcGUocywgY29udCkge1xuICAgICAgICAgICAgICAgIHZhciBzYXZlID0gc2NvcGUsIHJldDtcbiAgICAgICAgICAgICAgICBzY29wZSA9IHM7XG4gICAgICAgICAgICAgICAgcmV0ID0gY29udCgpO1xuICAgICAgICAgICAgICAgIHNjb3BlID0gc2F2ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBsYW1iZGEobmFtZSwgYXJncywgYm9keSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIG5hbWUsIGFyZ3MsIHdpdGhfc2NvcGUoYm9keS5zY29wZSwgY3VycnkoTUFQLCBib2R5LCB3YWxrKSkgXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHcud2l0aF93YWxrZXJzKHtcbiAgICAgICAgICAgICAgICBcImRpcmVjdGl2ZVwiOiBmdW5jdGlvbihkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY29wZS5hY3RpdmVfZGlyZWN0aXZlKGRpcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIFwiYmxvY2tcIiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuZGlyZWN0aXZlcy5wdXNoKGRpcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInRvcGxldmVsXCI6IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHdpdGhfc2NvcGUodGhpcy5zY29wZSwgY3VycnkoTUFQLCBib2R5LCB3YWxrKSkgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIjogbGFtYmRhLFxuICAgICAgICAgICAgICAgIFwiZGVmdW5cIjogbGFtYmRhXG4gICAgICAgIH0sIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhbGsoYXN0X2FkZF9zY29wZShhc3QpKTtcbiAgICAgICAgfSk7XG59O1xuXG4vKiAtLS0tLVsgcmUtZ2VuZXJhdGUgY29kZSBmcm9tIHRoZSBBU1QgXS0tLS0tICovXG5cbnZhciBET1RfQ0FMTF9OT19QQVJFTlMgPSBqc3AuYXJyYXlfdG9faGFzaChbXG4gICAgICAgIFwibmFtZVwiLFxuICAgICAgICBcImFycmF5XCIsXG4gICAgICAgIFwib2JqZWN0XCIsXG4gICAgICAgIFwic3RyaW5nXCIsXG4gICAgICAgIFwiZG90XCIsXG4gICAgICAgIFwic3ViXCIsXG4gICAgICAgIFwiY2FsbFwiLFxuICAgICAgICBcInJlZ2V4cFwiLFxuICAgICAgICBcImRlZnVuXCJcbl0pO1xuXG5mdW5jdGlvbiBtYWtlX3N0cmluZyhzdHIsIGFzY2lpX29ubHkpIHtcbiAgICAgICAgdmFyIGRxID0gMCwgc3EgPSAwO1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvW1xcXFxcXGJcXGZcXG5cXHJcXHRcXHgyMlxceDI3XFx1MjAyOFxcdTIwMjlcXDBdL2csIGZ1bmN0aW9uKHMpe1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXFxcXFwiOiByZXR1cm4gXCJcXFxcXFxcXFwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXFxiXCI6IHJldHVybiBcIlxcXFxiXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJcXGZcIjogcmV0dXJuIFwiXFxcXGZcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlxcblwiOiByZXR1cm4gXCJcXFxcblwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXFxyXCI6IHJldHVybiBcIlxcXFxyXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI4XCI6IHJldHVybiBcIlxcXFx1MjAyOFwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXFx1MjAyOVwiOiByZXR1cm4gXCJcXFxcdTIwMjlcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXCInOiArK2RxOyByZXR1cm4gJ1wiJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIidcIjogKytzcTsgcmV0dXJuIFwiJ1wiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXFwwXCI6IHJldHVybiBcIlxcXFwwXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFzY2lpX29ubHkpIHN0ciA9IHRvX2FzY2lpKHN0cik7XG4gICAgICAgIGlmIChkcSA+IHNxKSByZXR1cm4gXCInXCIgKyBzdHIucmVwbGFjZSgvXFx4MjcvZywgXCJcXFxcJ1wiKSArIFwiJ1wiO1xuICAgICAgICBlbHNlIHJldHVybiAnXCInICsgc3RyLnJlcGxhY2UoL1xceDIyL2csICdcXFxcXCInKSArICdcIic7XG59O1xuXG5mdW5jdGlvbiB0b19hc2NpaShzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFx1MDA4MC1cXHVmZmZmXS9nLCBmdW5jdGlvbihjaCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvZGUubGVuZ3RoIDwgNCkgY29kZSA9IFwiMFwiICsgY29kZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdVwiICsgY29kZTtcbiAgICAgICAgfSk7XG59O1xuXG52YXIgU1BMSUNFX05FRURTX0JSQUNLRVRTID0ganNwLmFycmF5X3RvX2hhc2goWyBcImlmXCIsIFwid2hpbGVcIiwgXCJkb1wiLCBcImZvclwiLCBcImZvci1pblwiLCBcIndpdGhcIiBdKTtcblxuZnVuY3Rpb24gZ2VuX2NvZGUoYXN0LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgaW5kZW50X3N0YXJ0IDogMCxcbiAgICAgICAgICAgICAgICBpbmRlbnRfbGV2ZWwgOiA0LFxuICAgICAgICAgICAgICAgIHF1b3RlX2tleXMgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNwYWNlX2NvbG9uICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGJlYXV0aWZ5ICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFzY2lpX29ubHkgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlubGluZV9zY3JpcHQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYmVhdXRpZnkgPSAhIW9wdGlvbnMuYmVhdXRpZnk7XG4gICAgICAgIHZhciBpbmRlbnRhdGlvbiA9IDAsXG4gICAgICAgICAgICBuZXdsaW5lID0gYmVhdXRpZnkgPyBcIlxcblwiIDogXCJcIixcbiAgICAgICAgICAgIHNwYWNlID0gYmVhdXRpZnkgPyBcIiBcIiA6IFwiXCI7XG5cbiAgICAgICAgZnVuY3Rpb24gZW5jb2RlX3N0cmluZyhzdHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbWFrZV9zdHJpbmcoc3RyLCBvcHRpb25zLmFzY2lpX29ubHkpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmlubGluZV9zY3JpcHQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSByZXQucmVwbGFjZSgvPFxceDJmc2NyaXB0KFs+XFwvXFx0XFxuXFxmXFxyIF0pL2dpLCBcIjxcXFxcL3NjcmlwdCQxXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZV9uYW1lKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFzY2lpX29ubHkpXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gdG9fYXNjaWkobmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gaW5kZW50KGxpbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKGJlYXV0aWZ5KVxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9IHJlcGVhdF9zdHJpbmcoXCIgXCIsIG9wdGlvbnMuaW5kZW50X3N0YXJ0ICsgaW5kZW50YXRpb24gKiBvcHRpb25zLmluZGVudF9sZXZlbCkgKyBsaW5lO1xuICAgICAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHdpdGhfaW5kZW50KGNvbnQsIGluY3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5jciA9PSBudWxsKSBpbmNyID0gMTtcbiAgICAgICAgICAgICAgICBpbmRlbnRhdGlvbiArPSBpbmNyO1xuICAgICAgICAgICAgICAgIHRyeSB7IHJldHVybiBjb250LmFwcGx5KG51bGwsIHNsaWNlKGFyZ3VtZW50cywgMSkpOyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGluZGVudGF0aW9uIC09IGluY3I7IH1cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBsYXN0X2NoYXIoc3RyKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGZpcnN0X2NoYXIoc3RyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0ci50b1N0cmluZygpLmNoYXJBdCgwKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBhZGRfc3BhY2VzKGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmVhdXRpZnkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5qb2luKFwiIFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBhW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaChhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChpc19pZGVudGlmaWVyX2NoYXIobGFzdF9jaGFyKGFbaV0pKSAmJiAoaXNfaWRlbnRpZmllcl9jaGFyKGZpcnN0X2NoYXIobmV4dCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgZmlyc3RfY2hhcihuZXh0KSA9PSBcIlxcXFxcIikpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgvW1xcK1xcLV0kLy50ZXN0KGFbaV0udG9TdHJpbmcoKSkgJiYgL15bXFwrXFwtXS8udGVzdChuZXh0LnRvU3RyaW5nKCkpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5wdXNoKFwiIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGIuam9pbihcIlwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBhZGRfY29tbWFzKGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5qb2luKFwiLFwiICsgc3BhY2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHBhcmVudGhlc2l6ZShleHByKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdlbiA9IG1ha2UoZXhwcik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZWwgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBlbChleHByKSkgfHwgZXhwclswXSA9PSBlbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiKFwiICsgZ2VuICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBnZW47XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gYmVzdF9vZihhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGEubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYS5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBhWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGFbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggPD0gYi5sZW5ndGggPyBhIDogYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlc3Rfb2YoWyBhWzBdLCBiZXN0X29mKGEuc2xpY2UoMSkpIF0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG5lZWRzX3BhcmVucyhleHByKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHJbMF0gPT0gXCJmdW5jdGlvblwiIHx8IGV4cHJbMF0gPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG90L2NhbGwgb24gYSBsaXRlcmFsIGZ1bmN0aW9uIHJlcXVpcmVzIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnVuY3Rpb24gbGl0ZXJhbCBpdHNlbGYgdG8gYmUgcGFyZW50aGVzaXplZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBpZiBpdCdzIHRoZSBmaXJzdCBcInRoaW5nXCIgaW4gYVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhdGVtZW50LiAgVGhpcyBtZWFucyB0aGF0IHRoZSBwYXJlbnQgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwic3RhdFwiLCBidXQgaXQgY291bGQgYWxzbyBiZSBhIFwic2VxXCIgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSB0aGUgZmlyc3QgaW4gdGhpcyBcInNlcVwiIGFuZCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcmVudCBpcyBcInN0YXRcIiwgYW5kIHNvIG9uLiAgTWVzc3kgc3R1ZmYsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgaXQgd29ydGhzIHRoZSB0cm91YmxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBzbGljZSh3LnN0YWNrKCkpLCBzZWxmID0gYS5wb3AoKSwgcCA9IGEucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocFswXSA9PSBcInN0YXRcIikgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKHBbMF0gPT0gXCJzZXFcIiB8fCBwWzBdID09IFwiY2FsbFwiIHx8IHBbMF0gPT0gXCJkb3RcIiB8fCBwWzBdID09IFwic3ViXCIgfHwgcFswXSA9PSBcImNvbmRpdGlvbmFsXCIpICYmIHBbMV0gPT09IHNlbGYpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHBbMF0gPT0gXCJiaW5hcnlcIiB8fCBwWzBdID09IFwiYXNzaWduXCIgfHwgcFswXSA9PSBcInVuYXJ5LXBvc3RmaXhcIikgJiYgcFsyXSA9PT0gc2VsZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gYS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICFIT1AoRE9UX0NBTExfTk9fUEFSRU5TLCBleHByWzBdKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBtYWtlX251bShudW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RyID0gbnVtLnRvU3RyaW5nKDEwKSwgYSA9IFsgc3RyLnJlcGxhY2UoL14wXFwuLywgXCIuXCIpLnJlcGxhY2UoJ2UrJywgJ2UnKSBdLCBtO1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmZsb29yKG51bSkgPT09IG51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChcIjB4XCIgKyBudW0udG9TdHJpbmcoMTYpLnRvTG93ZXJDYXNlKCksIC8vIHByb2JhYmx5IHBvaW50bGVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIwXCIgKyBudW0udG9TdHJpbmcoOCkpOyAvLyBzYW1lLlxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKFwiLTB4XCIgKyAoLW51bSkudG9TdHJpbmcoMTYpLnRvTG93ZXJDYXNlKCksIC8vIHByb2JhYmx5IHBvaW50bGVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCItMFwiICsgKC1udW0pLnRvU3RyaW5nKDgpKTsgLy8gc2FtZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobSA9IC9eKC4qPykoMCspJC8uZXhlYyhudW0pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2gobVsxXSArIFwiZVwiICsgbVsyXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKG0gPSAvXjA/XFwuKDArKSguKikkLy5leGVjKG51bSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2gobVsyXSArIFwiZS1cIiArIChtWzFdLmxlbmd0aCArIG1bMl0ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIuc3Vic3RyKHN0ci5pbmRleE9mKFwiLlwiKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmVzdF9vZihhKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdyA9IGFzdF93YWxrZXIoKTtcbiAgICAgICAgdmFyIG1ha2UgPSB3LndhbGs7XG4gICAgICAgIHJldHVybiB3LndpdGhfd2Fsa2Vycyh7XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIjogZW5jb2RlX3N0cmluZyxcbiAgICAgICAgICAgICAgICBcIm51bVwiOiBtYWtlX251bSxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogbWFrZV9uYW1lLFxuICAgICAgICAgICAgICAgIFwiZGVidWdnZXJcIjogZnVuY3Rpb24oKXsgcmV0dXJuIFwiZGVidWdnZXI7XCIgfSxcbiAgICAgICAgICAgICAgICBcInRvcGxldmVsXCI6IGZ1bmN0aW9uKHN0YXRlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX2Jsb2NrX3N0YXRlbWVudHMoc3RhdGVtZW50cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4obmV3bGluZSArIG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJzcGxpY2VcIjogZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHcucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoSE9QKFNQTElDRV9ORUVEU19CUkFDS0VUUywgcGFyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIGJsb2NrIGJyYWNrZXRzIGluIHRoaXMgY2FzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ibG9jay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1BUChtYWtlX2Jsb2NrX3N0YXRlbWVudHMoc3RhdGVtZW50cywgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24obGluZSwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZpcnN0IGxpbmUgaXMgYWxyZWFkeSBpbmRlbnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgPiAwID8gaW5kZW50KGxpbmUpIDogbGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5qb2luKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJibG9ja1wiOiBtYWtlX2Jsb2NrLFxuICAgICAgICAgICAgICAgIFwidmFyXCI6IGZ1bmN0aW9uKGRlZnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInZhciBcIiArIGFkZF9jb21tYXMoTUFQKGRlZnMsIG1ha2VfMXZhcmRlZikpICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImNvbnN0XCI6IGZ1bmN0aW9uKGRlZnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnN0IFwiICsgYWRkX2NvbW1hcyhNQVAoZGVmcywgbWFrZV8xdmFyZGVmKSkgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwidHJ5XCI6IGZ1bmN0aW9uKHRyLCBjYSwgZmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXQgPSBbIFwidHJ5XCIsIG1ha2VfYmxvY2sodHIpIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2EpIG91dC5wdXNoKFwiY2F0Y2hcIiwgXCIoXCIgKyBjYVswXSArIFwiKVwiLCBtYWtlX2Jsb2NrKGNhWzFdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmkpIG91dC5wdXNoKFwiZmluYWxseVwiLCBtYWtlX2Jsb2NrKGZpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkX3NwYWNlcyhvdXQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ0aHJvd1wiOiBmdW5jdGlvbihleHByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkX3NwYWNlcyhbIFwidGhyb3dcIiwgbWFrZShleHByKSBdKSArIFwiO1wiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJuZXdcIjogZnVuY3Rpb24oY3RvciwgYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3MubGVuZ3RoID4gMCA/IFwiKFwiICsgYWRkX2NvbW1hcyhNQVAoYXJncywgZnVuY3Rpb24oZXhwcil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUoZXhwciwgXCJzZXFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkgKyBcIilcIiA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkX3NwYWNlcyhbIFwibmV3XCIsIHBhcmVudGhlc2l6ZShjdG9yLCBcInNlcVwiLCBcImJpbmFyeVwiLCBcImNvbmRpdGlvbmFsXCIsIFwiYXNzaWduXCIsIGZ1bmN0aW9uKGV4cHIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IGFzdF93YWxrZXIoKSwgaGFzX2NhbGwgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3LndpdGhfd2Fsa2Vycyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNhbGxcIjogZnVuY3Rpb24oKSB7IHRocm93IGhhc19jYWxsIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcud2FsayhleHByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleCA9PT0gaGFzX2NhbGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkgKyBhcmdzIF0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJzd2l0Y2hcIjogZnVuY3Rpb24oZXhwciwgYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZF9zcGFjZXMoWyBcInN3aXRjaFwiLCBcIihcIiArIG1ha2UoZXhwcikgKyBcIilcIiwgbWFrZV9zd2l0Y2hfYmxvY2soYm9keSkgXSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImJyZWFrXCI6IGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0gXCJicmVha1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSBcIiBcIiArIG1ha2VfbmFtZShsYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0ICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImNvbnRpbnVlXCI6IGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSBcIiBcIiArIG1ha2VfbmFtZShsYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0ICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImNvbmRpdGlvbmFsXCI6IGZ1bmN0aW9uKGNvLCB0aCwgZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRfc3BhY2VzKFsgcGFyZW50aGVzaXplKGNvLCBcImFzc2lnblwiLCBcInNlcVwiLCBcImNvbmRpdGlvbmFsXCIpLCBcIj9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50aGVzaXplKHRoLCBcInNlcVwiKSwgXCI6XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudGhlc2l6ZShlbCwgXCJzZXFcIikgXSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImFzc2lnblwiOiBmdW5jdGlvbihvcCwgbHZhbHVlLCBydmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCAmJiBvcCAhPT0gdHJ1ZSkgb3AgKz0gXCI9XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIG9wID0gXCI9XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkX3NwYWNlcyhbIG1ha2UobHZhbHVlKSwgb3AsIHBhcmVudGhlc2l6ZShydmFsdWUsIFwic2VxXCIpIF0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJkb3RcIjogZnVuY3Rpb24oZXhwcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9IG1ha2UoZXhwciksIGkgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJbMF0gPT0gXCJudW1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIS9bYS1mLl0vaS50ZXN0KG91dCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleHByWzBdICE9IFwiZnVuY3Rpb25cIiAmJiBuZWVkc19wYXJlbnMoZXhwcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dCA9IFwiKFwiICsgb3V0ICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSBcIi5cIiArIG1ha2VfbmFtZShhcmd1bWVudHNbaSsrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJjYWxsXCI6IGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gbWFrZShmdW5jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmLmNoYXJBdCgwKSAhPSBcIihcIiAmJiBuZWVkc19wYXJlbnMoZnVuYykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBcIihcIiArIGYgKyBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmICsgXCIoXCIgKyBhZGRfY29tbWFzKE1BUChhcmdzLCBmdW5jdGlvbihleHByKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShleHByLCBcInNlcVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSArIFwiKVwiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiOiBtYWtlX2Z1bmN0aW9uLFxuICAgICAgICAgICAgICAgIFwiZGVmdW5cIjogbWFrZV9mdW5jdGlvbixcbiAgICAgICAgICAgICAgICBcImlmXCI6IGZ1bmN0aW9uKGNvLCB0aCwgZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXQgPSBbIFwiaWZcIiwgXCIoXCIgKyBtYWtlKGNvKSArIFwiKVwiLCBlbCA/IG1ha2VfdGhlbih0aCkgOiBtYWtlKHRoKSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKFwiZWxzZVwiLCBtYWtlKGVsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkX3NwYWNlcyhvdXQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJmb3JcIjogZnVuY3Rpb24oaW5pdCwgY29uZCwgc3RlcCwgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXQgPSBbIFwiZm9yXCIgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSAoaW5pdCAhPSBudWxsID8gbWFrZShpbml0KSA6IFwiXCIpLnJlcGxhY2UoLzsqXFxzKiQvLCBcIjtcIiArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmQgPSAoY29uZCAhPSBudWxsID8gbWFrZShjb25kKSA6IFwiXCIpLnJlcGxhY2UoLzsqXFxzKiQvLCBcIjtcIiArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXAgPSAoc3RlcCAhPSBudWxsID8gbWFrZShzdGVwKSA6IFwiXCIpLnJlcGxhY2UoLzsqXFxzKiQvLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gaW5pdCArIGNvbmQgKyBzdGVwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MgPT0gXCI7IDsgXCIpIGFyZ3MgPSBcIjs7XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChcIihcIiArIGFyZ3MgKyBcIilcIiwgbWFrZShibG9jaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZF9zcGFjZXMob3V0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZm9yLWluXCI6IGZ1bmN0aW9uKHZ2YXIsIGtleSwgaGFzaCwgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRfc3BhY2VzKFsgXCJmb3JcIiwgXCIoXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodnZhciA/IG1ha2UodnZhcikucmVwbGFjZSgvOyskLywgXCJcIikgOiBtYWtlKGtleSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImluXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ha2UoaGFzaCkgKyBcIilcIiwgbWFrZShibG9jaykgXSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIndoaWxlXCI6IGZ1bmN0aW9uKGNvbmRpdGlvbiwgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRfc3BhY2VzKFsgXCJ3aGlsZVwiLCBcIihcIiArIG1ha2UoY29uZGl0aW9uKSArIFwiKVwiLCBtYWtlKGJsb2NrKSBdKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZG9cIjogZnVuY3Rpb24oY29uZGl0aW9uLCBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZF9zcGFjZXMoWyBcImRvXCIsIG1ha2UoYmxvY2spLCBcIndoaWxlXCIsIFwiKFwiICsgbWFrZShjb25kaXRpb24pICsgXCIpXCIgXSkgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwicmV0dXJuXCI6IGZ1bmN0aW9uKGV4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXQgPSBbIFwicmV0dXJuXCIgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByICE9IG51bGwpIG91dC5wdXNoKG1ha2UoZXhwcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZF9zcGFjZXMob3V0KSArIFwiO1wiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJiaW5hcnlcIjogZnVuY3Rpb24ob3BlcmF0b3IsIGx2YWx1ZSwgcnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IG1ha2UobHZhbHVlKSwgcmlnaHQgPSBtYWtlKHJ2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBYWFg6IEknbSBwcmV0dHkgc3VyZSBvdGhlciBjYXNlcyB3aWxsIGJpdGUgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgd2UgbmVlZCB0byBiZSBzbWFydGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICBhZGRpbmcgcGFyZW5zIGFsbCB0aGUgdGltZSBpcyB0aGUgc2FmZXN0IGJldC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXIobHZhbHVlWzBdLCBbIFwiYXNzaWduXCIsIFwiY29uZGl0aW9uYWxcIiwgXCJzZXFcIiBdKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGx2YWx1ZVswXSA9PSBcImJpbmFyeVwiICYmIFBSRUNFREVOQ0Vbb3BlcmF0b3JdID4gUFJFQ0VERU5DRVtsdmFsdWVbMV1dIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbHZhbHVlWzBdID09IFwiZnVuY3Rpb25cIiAmJiBuZWVkc19wYXJlbnModGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IFwiKFwiICsgbGVmdCArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlcihydmFsdWVbMF0sIFsgXCJhc3NpZ25cIiwgXCJjb25kaXRpb25hbFwiLCBcInNlcVwiIF0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnZhbHVlWzBdID09IFwiYmluYXJ5XCIgJiYgUFJFQ0VERU5DRVtvcGVyYXRvcl0gPj0gUFJFQ0VERU5DRVtydmFsdWVbMV1dICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIShydmFsdWVbMV0gPT0gb3BlcmF0b3IgJiYgbWVtYmVyKG9wZXJhdG9yLCBbIFwiJiZcIiwgXCJ8fFwiLCBcIipcIiBdKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBcIihcIiArIHJpZ2h0ICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYmVhdXRpZnkgJiYgb3B0aW9ucy5pbmxpbmVfc2NyaXB0ICYmIChvcGVyYXRvciA9PSBcIjxcIiB8fCBvcGVyYXRvciA9PSBcIjw8XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBydmFsdWVbMF0gPT0gXCJyZWdleHBcIiAmJiAvXnNjcmlwdC9pLnRlc3QocnZhbHVlWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IFwiIFwiICsgcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkX3NwYWNlcyhbIGxlZnQsIG9wZXJhdG9yLCByaWdodCBdKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwidW5hcnktcHJlZml4XCI6IGZ1bmN0aW9uKG9wZXJhdG9yLCBleHByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gbWFrZShleHByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGV4cHJbMF0gPT0gXCJudW1cIiB8fCAoZXhwclswXSA9PSBcInVuYXJ5LXByZWZpeFwiICYmICFIT1AoT1BFUkFUT1JTLCBvcGVyYXRvciArIGV4cHJbMV0pKSB8fCAhbmVlZHNfcGFyZW5zKGV4cHIpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gXCIoXCIgKyB2YWwgKyBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciArIChqc3AuaXNfYWxwaGFudW1lcmljX2NoYXIob3BlcmF0b3IuY2hhckF0KDApKSA/IFwiIFwiIDogXCJcIikgKyB2YWw7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInVuYXJ5LXBvc3RmaXhcIjogZnVuY3Rpb24ob3BlcmF0b3IsIGV4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBtYWtlKGV4cHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZXhwclswXSA9PSBcIm51bVwiIHx8IChleHByWzBdID09IFwidW5hcnktcG9zdGZpeFwiICYmICFIT1AoT1BFUkFUT1JTLCBvcGVyYXRvciArIGV4cHJbMV0pKSB8fCAhbmVlZHNfcGFyZW5zKGV4cHIpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gXCIoXCIgKyB2YWwgKyBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwgKyBvcGVyYXRvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwic3ViXCI6IGZ1bmN0aW9uKGV4cHIsIHN1YnNjcmlwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2ggPSBtYWtlKGV4cHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRzX3BhcmVucyhleHByKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaCA9IFwiKFwiICsgaGFzaCArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc2ggKyBcIltcIiArIG1ha2Uoc3Vic2NyaXB0KSArIFwiXVwiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIjogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmpfbmVlZHNfcGFyZW5zID0gbmVlZHNfcGFyZW5zKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqX25lZWRzX3BhcmVucyA/IFwiKHt9KVwiIDogXCJ7fVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9IFwie1wiICsgbmV3bGluZSArIHdpdGhfaW5kZW50KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNQVAocHJvcHMsIGZ1bmN0aW9uKHApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXR0ZXIvc2V0dGVyLiAgVGhlIG5hbWUgaXMgaW4gcFswXSwgdGhlIGFyZy5saXN0IGluIHBbMV1bMl0sIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYm9keSBpbiBwWzFdWzNdIGFuZCB0eXBlIChcImdldFwiIC8gXCJzZXRcIikgaW4gcFsyXS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRlbnQobWFrZV9mdW5jdGlvbihwWzBdLCBwWzFdWzJdLCBwWzFdWzNdLCBwWzJdLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBwWzBdLCB2YWwgPSBwYXJlbnRoZXNpemUocFsxXSwgXCJzZXFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucXVvdGVfa2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gZW5jb2RlX3N0cmluZyhrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBrZXkgPT0gXCJudW1iZXJcIiB8fCAhYmVhdXRpZnkgJiYgK2tleSArIFwiXCIgPT0ga2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgcGFyc2VGbG9hdChrZXkpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IG1ha2VfbnVtKCtrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzX2lkZW50aWZpZXIoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gZW5jb2RlX3N0cmluZyhrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZW50KGFkZF9zcGFjZXMoYmVhdXRpZnkgJiYgb3B0aW9ucy5zcGFjZV9jb2xvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFsga2V5LCBcIjpcIiwgdmFsIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbIGtleSArIFwiOlwiLCB2YWwgXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5qb2luKFwiLFwiICsgbmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSArIG5ld2xpbmUgKyBpbmRlbnQoXCJ9XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ial9uZWVkc19wYXJlbnMgPyBcIihcIiArIG91dCArIFwiKVwiIDogb3V0O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJyZWdleHBcIjogZnVuY3Rpb24ocngsIG1vZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFzY2lpX29ubHkpIHJ4ID0gdG9fYXNjaWkocngpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiL1wiICsgcnggKyBcIi9cIiArIG1vZHM7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09IDApIHJldHVybiBcIltdXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkX3NwYWNlcyhbIFwiW1wiLCBhZGRfY29tbWFzKE1BUChlbGVtZW50cywgZnVuY3Rpb24oZWwsIGkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJlYXV0aWZ5ICYmIGVsWzBdID09IFwiYXRvbVwiICYmIGVsWzFdID09IFwidW5kZWZpbmVkXCIpIHJldHVybiBpID09PSBlbGVtZW50cy5sZW5ndGggLSAxID8gXCIsXCIgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKGVsLCBcInNlcVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgXCJdXCIgXSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInN0YXRcIjogZnVuY3Rpb24oc3RtdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0bXQgIT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG1ha2Uoc3RtdCkucmVwbGFjZSgvOypcXHMqJC8sIFwiO1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiO1wiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJzZXFcIjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkX2NvbW1hcyhNQVAoc2xpY2UoYXJndW1lbnRzKSwgbWFrZSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJsYWJlbFwiOiBmdW5jdGlvbihuYW1lLCBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZF9zcGFjZXMoWyBtYWtlX25hbWUobmFtZSksIFwiOlwiLCBtYWtlKGJsb2NrKSBdKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwid2l0aFwiOiBmdW5jdGlvbihleHByLCBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZF9zcGFjZXMoWyBcIndpdGhcIiwgXCIoXCIgKyBtYWtlKGV4cHIpICsgXCIpXCIsIG1ha2UoYmxvY2spIF0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhdG9tXCI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25hbWUobmFtZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImRpcmVjdGl2ZVwiOiBmdW5jdGlvbihkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX3N0cmluZyhkaXIpICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbigpeyByZXR1cm4gbWFrZShhc3QpIH0pO1xuXG4gICAgICAgIC8vIFRoZSBzcXVlZXplciByZXBsYWNlcyBcImJsb2NrXCItcyB0aGF0IGNvbnRhaW4gb25seSBhIHNpbmdsZVxuICAgICAgICAvLyBzdGF0ZW1lbnQgd2l0aCB0aGUgc3RhdGVtZW50IGl0c2VsZjsgdGVjaG5pY2FsbHksIHRoZSBBU1RcbiAgICAgICAgLy8gaXMgY29ycmVjdCwgYnV0IHRoaXMgY2FuIGNyZWF0ZSBwcm9ibGVtcyB3aGVuIHdlIG91dHB1dCBhblxuICAgICAgICAvLyBJRiBoYXZpbmcgYW4gRUxTRSBjbGF1c2Ugd2hlcmUgdGhlIFRIRU4gY2xhdXNlIGVuZHMgaW4gYW5cbiAgICAgICAgLy8gSUYgKndpdGhvdXQqIGFuIEVMU0UgYmxvY2sgKHRoZW4gdGhlIG91dGVyIEVMU0Ugd291bGQgcmVmZXJcbiAgICAgICAgLy8gdG8gdGhlIGlubmVyIElGKS4gIFRoaXMgZnVuY3Rpb24gY2hlY2tzIGZvciB0aGlzIGNhc2UgYW5kXG4gICAgICAgIC8vIGFkZHMgdGhlIGJsb2NrIGJyYWNrZXRzIGlmIG5lZWRlZC5cbiAgICAgICAgZnVuY3Rpb24gbWFrZV90aGVuKHRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoID09IG51bGwpIHJldHVybiBcIjtcIjtcbiAgICAgICAgICAgICAgICBpZiAodGhbMF0gPT0gXCJkb1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTL2lzc3Vlcy8jaXNzdWUvNTdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFIGNyb2FrcyB3aXRoIFwic3ludGF4IGVycm9yXCIgb24gY29kZSBsaWtlIHRoaXM6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgaWYgKGZvbykgZG8gLi4uIHdoaWxlKGNvbmQpOyBlbHNlIC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCBibG9jayBicmFja2V0cyBhcm91bmQgZG8vd2hpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX2Jsb2NrKFsgdGggXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBiID0gdGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gYlswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09IFwiaWZcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJbM10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gZWxzZSwgd2UgbXVzdCBhZGQgdGhlIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2UoWyBcImJsb2NrXCIsIFsgdGggXV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gYlszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJ3aGlsZVwiIHx8IHR5cGUgPT0gXCJkb1wiKSBiID0gYlsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJmb3JcIiB8fCB0eXBlID09IFwiZm9yLWluXCIpIGIgPSBiWzRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2UodGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VfZnVuY3Rpb24obmFtZSwgYXJncywgYm9keSwga2V5d29yZCwgbm9fcGFyZW5zKSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dCA9IGtleXdvcmQgfHwgXCJmdW5jdGlvblwiO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCIgXCIgKyBtYWtlX25hbWUobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dCArPSBcIihcIiArIGFkZF9jb21tYXMoTUFQKGFyZ3MsIG1ha2VfbmFtZSkpICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgb3V0ID0gYWRkX3NwYWNlcyhbIG91dCwgbWFrZV9ibG9jayhib2R5KSBdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCFub19wYXJlbnMgJiYgbmVlZHNfcGFyZW5zKHRoaXMpKSA/IFwiKFwiICsgb3V0ICsgXCIpXCIgOiBvdXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbXVzdF9oYXNfc2VtaWNvbG9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG5vZGVbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIndpdGhcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIndoaWxlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHkobm9kZVsyXSkgfHwgbXVzdF9oYXNfc2VtaWNvbG9uKG5vZGVbMl0pO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3ItaW5cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eShub2RlWzRdKSB8fCBtdXN0X2hhc19zZW1pY29sb24obm9kZVs0XSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpZlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVtcHR5KG5vZGVbMl0pICYmICFub2RlWzNdKSByZXR1cm4gdHJ1ZTsgLy8gYGlmJyB3aXRoIGVtcHR5IGB0aGVuJyBhbmQgbm8gYGVsc2UnXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVszXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW1wdHkobm9kZVszXSkpIHJldHVybiB0cnVlOyAvLyBgZWxzZScgcHJlc2VudCBidXQgZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG11c3RfaGFzX3NlbWljb2xvbihub2RlWzNdKTsgLy8gZGl2ZSBpbnRvIHRoZSBgZWxzZScgYnJhbmNoXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXVzdF9oYXNfc2VtaWNvbG9uKG5vZGVbMl0pOyAvLyBkaXZlIGludG8gdGhlIGB0aGVuJyBicmFuY2hcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRpcmVjdGl2ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VfYmxvY2tfc3RhdGVtZW50cyhzdGF0ZW1lbnRzLCBub2luZGVudCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGEgPSBbXSwgbGFzdCA9IHN0YXRlbWVudHMubGVuZ3RoIC0gMSwgaSA9IDA7IGkgPD0gbGFzdDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdCA9IHN0YXRlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29kZSA9IG1ha2Uoc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSAhPSBcIjtcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJlYXV0aWZ5ICYmIGkgPT0gbGFzdCAmJiAhbXVzdF9oYXNfc2VtaWNvbG9uKHN0YXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZSgvOytcXHMqJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vaW5kZW50ID8gYSA6IE1BUChhLCBpbmRlbnQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG1ha2Vfc3dpdGNoX2Jsb2NrKGJvZHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGJvZHkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChuID09IDApIHJldHVybiBcInt9XCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwie1wiICsgbmV3bGluZSArIE1BUChib2R5LCBmdW5jdGlvbihicmFuY2gsIGkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc19ib2R5ID0gYnJhbmNoWzFdLmxlbmd0aCA+IDAsIGNvZGUgPSB3aXRoX2luZGVudChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZW50KGJyYW5jaFswXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYWRkX3NwYWNlcyhbIFwiY2FzZVwiLCBtYWtlKGJyYW5jaFswXSkgKyBcIjpcIiBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJkZWZhdWx0OlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDAuNSkgKyAoaGFzX2JvZHkgPyBuZXdsaW5lICsgd2l0aF9pbmRlbnQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VfYmxvY2tfc3RhdGVtZW50cyhicmFuY2hbMV0pLmpvaW4obmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSA6IFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiZWF1dGlmeSAmJiBoYXNfYm9keSAmJiBpIDwgbiAtIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgKz0gXCI7XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZTtcbiAgICAgICAgICAgICAgICB9KS5qb2luKG5ld2xpbmUpICsgbmV3bGluZSArIGluZGVudChcIn1cIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZV9ibG9jayhzdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZW1lbnRzKSByZXR1cm4gXCI7XCI7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlbWVudHMubGVuZ3RoID09IDApIHJldHVybiBcInt9XCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwie1wiICsgbmV3bGluZSArIHdpdGhfaW5kZW50KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ibG9ja19zdGF0ZW1lbnRzKHN0YXRlbWVudHMpLmpvaW4obmV3bGluZSk7XG4gICAgICAgICAgICAgICAgfSkgKyBuZXdsaW5lICsgaW5kZW50KFwifVwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBtYWtlXzF2YXJkZWYoZGVmKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBkZWZbMF0sIHZhbCA9IGRlZlsxXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gYWRkX3NwYWNlcyhbIG1ha2VfbmFtZShuYW1lKSwgXCI9XCIsIHBhcmVudGhlc2l6ZSh2YWwsIFwic2VxXCIpIF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9O1xuXG59O1xuXG5mdW5jdGlvbiBzcGxpdF9saW5lcyhjb2RlLCBtYXhfbGluZV9sZW5ndGgpIHtcbiAgICAgICAgdmFyIHNwbGl0cyA9IFsgMCBdO1xuICAgICAgICBqc3AucGFyc2UoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dF90b2tlbiA9IGpzcC50b2tlbml6ZXIoY29kZSk7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3Rfc3BsaXQgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2X3Rva2VuO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGN1cnJlbnRfbGVuZ3RoKHRvaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvay5wb3MgLSBsYXN0X3NwbGl0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc3BsaXRfaGVyZSh0b2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3Rfc3BsaXQgPSB0b2sucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRzLnB1c2gobGFzdF9zcGxpdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjdXN0b20oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b2sgPSBuZXh0X3Rva2VuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldl90b2tlbi50eXBlID09IFwia2V5d29yZFwiKSBicmVhayBvdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRfbGVuZ3RoKHRvaykgPiBtYXhfbGluZV9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRvay50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJrZXl3b3JkXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhdG9tXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwdW5jXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGxpdF9oZXJlKHRvayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBvdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2X3Rva2VuID0gdG9rO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvaztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGN1c3RvbS5jb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dF90b2tlbi5jb250ZXh0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgICAgICB9KCkpO1xuICAgICAgICByZXR1cm4gc3BsaXRzLm1hcChmdW5jdGlvbihwb3MsIGkpe1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlLnN1YnN0cmluZyhwb3MsIHNwbGl0c1tpICsgMV0gfHwgY29kZS5sZW5ndGgpO1xuICAgICAgICB9KS5qb2luKFwiXFxuXCIpO1xufTtcblxuLyogLS0tLS1bIFV0aWxpdGllcyBdLS0tLS0gKi9cblxuZnVuY3Rpb24gcmVwZWF0X3N0cmluZyhzdHIsIGkpIHtcbiAgICAgICAgaWYgKGkgPD0gMCkgcmV0dXJuIFwiXCI7XG4gICAgICAgIGlmIChpID09IDEpIHJldHVybiBzdHI7XG4gICAgICAgIHZhciBkID0gcmVwZWF0X3N0cmluZyhzdHIsIGkgPj4gMSk7XG4gICAgICAgIGQgKz0gZDtcbiAgICAgICAgaWYgKGkgJiAxKSBkICs9IHN0cjtcbiAgICAgICAgcmV0dXJuIGQ7XG59O1xuXG5mdW5jdGlvbiBkZWZhdWx0cyhhcmdzLCBkZWZzKSB7XG4gICAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgICAgaWYgKGFyZ3MgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgYXJncyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpIGluIGRlZnMpIGlmIChIT1AoZGVmcywgaSkpIHtcbiAgICAgICAgICAgICAgICByZXRbaV0gPSAoYXJncyAmJiBIT1AoYXJncywgaSkpID8gYXJnc1tpXSA6IGRlZnNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGlzX2lkZW50aWZpZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gL15bYS16XyRdW2EtejAtOV8kXSokL2kudGVzdChuYW1lKVxuICAgICAgICAgICAgICAgICYmIG5hbWUgIT0gXCJ0aGlzXCJcbiAgICAgICAgICAgICAgICAmJiAhSE9QKGpzcC5LRVlXT1JEU19BVE9NLCBuYW1lKVxuICAgICAgICAgICAgICAgICYmICFIT1AoanNwLlJFU0VSVkVEX1dPUkRTLCBuYW1lKVxuICAgICAgICAgICAgICAgICYmICFIT1AoanNwLktFWVdPUkRTLCBuYW1lKTtcbn07XG5cbmZ1bmN0aW9uIEhPUChvYmosIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufTtcblxuLy8gc29tZSB1dGlsaXRpZXNcblxudmFyIE1BUDtcblxuKGZ1bmN0aW9uKCl7XG4gICAgICAgIE1BUCA9IGZ1bmN0aW9uKGEsIGYsIG8pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gW10sIHRvcCA9IFtdLCBpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRvaXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gZi5jYWxsKG8sIGFbaV0sIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEF0VG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbC52O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgU3BsaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wLnB1c2guYXBwbHkodG9wLCB2YWwudik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsICE9IHNraXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFNwbGljZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoLmFwcGx5KHJldCwgdmFsLnYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChhIGluc3RhbmNlb2YgQXJyYXkpIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSBkb2l0KCk7XG4gICAgICAgICAgICAgICAgZWxzZSBmb3IgKGkgaW4gYSkgaWYgKEhPUChhLCBpKSkgZG9pdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b3AuY29uY2F0KHJldCk7XG4gICAgICAgIH07XG4gICAgICAgIE1BUC5hdF90b3AgPSBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIG5ldyBBdFRvcCh2YWwpIH07XG4gICAgICAgIE1BUC5zcGxpY2UgPSBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIG5ldyBTcGxpY2UodmFsKSB9O1xuICAgICAgICB2YXIgc2tpcCA9IE1BUC5za2lwID0ge307XG4gICAgICAgIGZ1bmN0aW9uIEF0VG9wKHZhbCkgeyB0aGlzLnYgPSB2YWwgfTtcbiAgICAgICAgZnVuY3Rpb24gU3BsaWNlKHZhbCkgeyB0aGlzLnYgPSB2YWwgfTtcbn0pKCk7XG5cbi8qIC0tLS0tWyBFeHBvcnRzIF0tLS0tLSAqL1xuXG5leHBvcnRzLmFzdF93YWxrZXIgPSBhc3Rfd2Fsa2VyO1xuZXhwb3J0cy5hc3RfbWFuZ2xlID0gYXN0X21hbmdsZTtcbmV4cG9ydHMuYXN0X3NxdWVlemUgPSBhc3Rfc3F1ZWV6ZTtcbmV4cG9ydHMuYXN0X2xpZnRfdmFyaWFibGVzID0gYXN0X2xpZnRfdmFyaWFibGVzO1xuZXhwb3J0cy5nZW5fY29kZSA9IGdlbl9jb2RlO1xuZXhwb3J0cy5hc3RfYWRkX3Njb3BlID0gYXN0X2FkZF9zY29wZTtcbmV4cG9ydHMuc2V0X2xvZ2dlciA9IGZ1bmN0aW9uKGxvZ2dlcikgeyB3YXJuID0gbG9nZ2VyIH07XG5leHBvcnRzLm1ha2Vfc3RyaW5nID0gbWFrZV9zdHJpbmc7XG5leHBvcnRzLnNwbGl0X2xpbmVzID0gc3BsaXRfbGluZXM7XG5leHBvcnRzLk1BUCA9IE1BUDtcblxuLy8ga2VlcCB0aGlzIGxhc3QhXG5leHBvcnRzLmFzdF9zcXVlZXplX21vcmUgPSByZXF1aXJlKFwiLi9zcXVlZXplLW1vcmVcIikuYXN0X3NxdWVlemVfbW9yZTtcblxuLy8gTG9jYWwgdmFyaWFibGVzOlxuLy8ganMtaW5kZW50LWxldmVsOiA4XG4vLyBFbmQ6XG4iLCJ2YXIganNwID0gcmVxdWlyZShcIi4vcGFyc2UtanNcIiksXG4gICAgcHJvID0gcmVxdWlyZShcIi4vcHJvY2Vzc1wiKSxcbiAgICBzbGljZSA9IGpzcC5zbGljZSxcbiAgICBtZW1iZXIgPSBqc3AubWVtYmVyLFxuICAgIGN1cnJ5ID0ganNwLmN1cnJ5LFxuICAgIE1BUCA9IHByby5NQVAsXG4gICAgUFJFQ0VERU5DRSA9IGpzcC5QUkVDRURFTkNFLFxuICAgIE9QRVJBVE9SUyA9IGpzcC5PUEVSQVRPUlM7XG5cbmZ1bmN0aW9uIGFzdF9zcXVlZXplX21vcmUoYXN0KSB7XG4gICAgICAgIHZhciB3ID0gcHJvLmFzdF93YWxrZXIoKSwgd2FsayA9IHcud2Fsaywgc2NvcGU7XG4gICAgICAgIGZ1bmN0aW9uIHdpdGhfc2NvcGUocywgY29udCkge1xuICAgICAgICAgICAgICAgIHZhciBzYXZlID0gc2NvcGUsIHJldDtcbiAgICAgICAgICAgICAgICBzY29wZSA9IHM7XG4gICAgICAgICAgICAgICAgcmV0ID0gY29udCgpO1xuICAgICAgICAgICAgICAgIHNjb3BlID0gc2F2ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBfbGFtYmRhKG5hbWUsIGFyZ3MsIGJvZHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBuYW1lLCBhcmdzLCB3aXRoX3Njb3BlKGJvZHkuc2NvcGUsIGN1cnJ5KE1BUCwgYm9keSwgd2FsaykpIF07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB3LndpdGhfd2Fsa2Vycyh7XG4gICAgICAgICAgICAgICAgXCJ0b3BsZXZlbFwiOiBmdW5jdGlvbihib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCB3aXRoX3Njb3BlKHRoaXMuc2NvcGUsIGN1cnJ5KE1BUCwgYm9keSwgd2FsaykpIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCI6IF9sYW1iZGEsXG4gICAgICAgICAgICAgICAgXCJkZWZ1blwiOiBfbGFtYmRhLFxuICAgICAgICAgICAgICAgIFwibmV3XCI6IGZ1bmN0aW9uKGN0b3IsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdG9yWzBdID09IFwibmFtZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdG9yWzFdID09IFwiQXJyYXlcIiAmJiAhc2NvcGUuaGFzKFwiQXJyYXlcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggIT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgXCJhcnJheVwiLCBhcmdzIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3YWxrKFsgXCJjYWxsXCIsIFsgXCJuYW1lXCIsIFwiQXJyYXlcIiBdLCBhcmdzIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdG9yWzFdID09IFwiT2JqZWN0XCIgJiYgIXNjb3BlLmhhcyhcIk9iamVjdFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIFwib2JqZWN0XCIsIFtdIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3YWxrKFsgXCJjYWxsXCIsIFsgXCJuYW1lXCIsIFwiT2JqZWN0XCIgXSwgYXJncyBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGN0b3JbMV0gPT0gXCJSZWdFeHBcIiB8fCBjdG9yWzFdID09IFwiRnVuY3Rpb25cIiB8fCBjdG9yWzFdID09IFwiRXJyb3JcIikgJiYgIXNjb3BlLmhhcyhjdG9yWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3YWxrKFsgXCJjYWxsXCIsIFsgXCJuYW1lXCIsIGN0b3JbMV0gXSwgYXJnc10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImNhbGxcIjogZnVuY3Rpb24oZXhwciwgYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJbMF0gPT0gXCJkb3RcIiAmJiBleHByWzFdWzBdID09IFwic3RyaW5nXCIgJiYgYXJncy5sZW5ndGggPT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChhcmdzWzBdWzFdID4gMCAmJiBleHByWzJdID09IFwic3Vic3RyaW5nXCIgfHwgZXhwclsyXSA9PSBcInN1YnN0clwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBcImNhbGxcIiwgWyBcImRvdFwiLCBleHByWzFdLCBcInNsaWNlXCJdLCBhcmdzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByWzBdID09IFwiZG90XCIgJiYgZXhwclsyXSA9PSBcInRvU3RyaW5nXCIgJiYgYXJncy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb28udG9TdHJpbmcoKSAgPT0+ICBmb28rXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwclsxXVswXSA9PSBcInN0cmluZ1wiKSByZXR1cm4gZXhwclsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgXCJiaW5hcnlcIiwgXCIrXCIsIGV4cHJbMV0sIFsgXCJzdHJpbmdcIiwgXCJcIiBdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByWzBdID09IFwibmFtZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByWzFdID09IFwiQXJyYXlcIiAmJiBhcmdzLmxlbmd0aCAhPSAxICYmICFzY29wZS5oYXMoXCJBcnJheVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIFwiYXJyYXlcIiwgYXJncyBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByWzFdID09IFwiT2JqZWN0XCIgJiYgIWFyZ3MubGVuZ3RoICYmICFzY29wZS5oYXMoXCJPYmplY3RcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBcIm9iamVjdFwiLCBbXSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByWzFdID09IFwiU3RyaW5nXCIgJiYgIXNjb3BlLmhhcyhcIlN0cmluZ1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIFwiYmluYXJ5XCIsIFwiK1wiLCBhcmdzWzBdLCBbIFwic3RyaW5nXCIsIFwiXCIgXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3YWxrKHByby5hc3RfYWRkX3Njb3BlKGFzdCkpO1xuICAgICAgICB9KTtcbn07XG5cbmV4cG9ydHMuYXN0X3NxdWVlemVfbW9yZSA9IGFzdF9zcXVlZXplX21vcmU7XG5cbi8vIExvY2FsIHZhcmlhYmxlczpcbi8vIGpzLWluZGVudC1sZXZlbDogOFxuLy8gRW5kOlxuIiwiLy9jb252aWVuZW5jZSBmdW5jdGlvbihzcmMsIFtvcHRpb25zXSk7XG5mdW5jdGlvbiB1Z2xpZnkob3JpZ19jb2RlLCBvcHRpb25zKXtcbiAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgdmFyIGpzcCA9IHVnbGlmeS5wYXJzZXI7XG4gIHZhciBwcm8gPSB1Z2xpZnkudWdsaWZ5O1xuXG4gIHZhciBhc3QgPSBqc3AucGFyc2Uob3JpZ19jb2RlLCBvcHRpb25zLnN0cmljdF9zZW1pY29sb25zKTsgLy8gcGFyc2UgY29kZSBhbmQgZ2V0IHRoZSBpbml0aWFsIEFTVFxuICBhc3QgPSBwcm8uYXN0X21hbmdsZShhc3QsIG9wdGlvbnMubWFuZ2xlX29wdGlvbnMpOyAvLyBnZXQgYSBuZXcgQVNUIHdpdGggbWFuZ2xlZCBuYW1lc1xuICBhc3QgPSBwcm8uYXN0X3NxdWVlemUoYXN0LCBvcHRpb25zLnNxdWVlemVfb3B0aW9ucyk7IC8vIGdldCBhbiBBU1Qgd2l0aCBjb21wcmVzc2lvbiBvcHRpbWl6YXRpb25zXG4gIHZhciBmaW5hbF9jb2RlID0gcHJvLmdlbl9jb2RlKGFzdCwgb3B0aW9ucy5nZW5fb3B0aW9ucyk7IC8vIGNvbXByZXNzZWQgY29kZSBoZXJlXG4gIHJldHVybiBmaW5hbF9jb2RlO1xufTtcblxudWdsaWZ5LnBhcnNlciA9IHJlcXVpcmUoXCIuL2xpYi9wYXJzZS1qc1wiKTtcbnVnbGlmeS51Z2xpZnkgPSByZXF1aXJlKFwiLi9saWIvcHJvY2Vzc1wiKTtcbnVnbGlmeS5jb25zb2xpZGF0b3IgPSByZXF1aXJlKFwiLi9saWIvY29uc29saWRhdG9yXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVnbGlmeVxuIiwiLy8gICAgIFVuZGVyc2NvcmUuanMgMS4zLjNcbi8vICAgICAoYykgMjAwOS0yMDEyIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBJbmMuXG4vLyAgICAgVW5kZXJzY29yZSBpcyBmcmVlbHkgZGlzdHJpYnV0YWJsZSB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vLyAgICAgUG9ydGlvbnMgb2YgVW5kZXJzY29yZSBhcmUgaW5zcGlyZWQgb3IgYm9ycm93ZWQgZnJvbSBQcm90b3R5cGUsXG4vLyAgICAgT2xpdmVyIFN0ZWVsZSdzIEZ1bmN0aW9uYWwsIGFuZCBKb2huIFJlc2lnJ3MgTWljcm8tVGVtcGxhdGluZy5cbi8vICAgICBGb3IgYWxsIGRldGFpbHMgYW5kIGRvY3VtZW50YXRpb246XG4vLyAgICAgaHR0cDovL2RvY3VtZW50Y2xvdWQuZ2l0aHViLmNvbS91bmRlcnNjb3JlXG5cbihmdW5jdGlvbigpIHtcblxuICAvLyBCYXNlbGluZSBzZXR1cFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZ2xvYmFsYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBFc3RhYmxpc2ggdGhlIG9iamVjdCB0aGF0IGdldHMgcmV0dXJuZWQgdG8gYnJlYWsgb3V0IG9mIGEgbG9vcCBpdGVyYXRpb24uXG4gIHZhciBicmVha2VyID0ge307XG5cbiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZSwgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxuICB2YXIgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgICB1bnNoaWZ0ICAgICAgICAgID0gQXJyYXlQcm90by51bnNoaWZ0LFxuICAgICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgICAgaGFzT3duUHJvcGVydHkgICA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuICAvLyBhcmUgZGVjbGFyZWQgaGVyZS5cbiAgdmFyXG4gICAgbmF0aXZlRm9yRWFjaCAgICAgID0gQXJyYXlQcm90by5mb3JFYWNoLFxuICAgIG5hdGl2ZU1hcCAgICAgICAgICA9IEFycmF5UHJvdG8ubWFwLFxuICAgIG5hdGl2ZVJlZHVjZSAgICAgICA9IEFycmF5UHJvdG8ucmVkdWNlLFxuICAgIG5hdGl2ZVJlZHVjZVJpZ2h0ICA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHQsXG4gICAgbmF0aXZlRmlsdGVyICAgICAgID0gQXJyYXlQcm90by5maWx0ZXIsXG4gICAgbmF0aXZlRXZlcnkgICAgICAgID0gQXJyYXlQcm90by5ldmVyeSxcbiAgICBuYXRpdmVTb21lICAgICAgICAgPSBBcnJheVByb3RvLnNvbWUsXG4gICAgbmF0aXZlSW5kZXhPZiAgICAgID0gQXJyYXlQcm90by5pbmRleE9mLFxuICAgIG5hdGl2ZUxhc3RJbmRleE9mICA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2YsXG4gICAgbmF0aXZlSXNBcnJheSAgICAgID0gQXJyYXkuaXNBcnJheSxcbiAgICBuYXRpdmVLZXlzICAgICAgICAgPSBPYmplY3Qua2V5cyxcbiAgICBuYXRpdmVCaW5kICAgICAgICAgPSBGdW5jUHJvdG8uYmluZDtcblxuICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cbiAgdmFyIF8gPSBmdW5jdGlvbihvYmopIHsgcmV0dXJuIG5ldyB3cmFwcGVyKG9iaik7IH07XG5cbiAgLy8gRXhwb3J0IHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgYHJlcXVpcmUoKWAgQVBJLiBJZiB3ZSdyZSBpblxuICAvLyB0aGUgYnJvd3NlciwgYWRkIGBfYCBhcyBhIGdsb2JhbCBvYmplY3QgdmlhIGEgc3RyaW5nIGlkZW50aWZpZXIsXG4gIC8vIGZvciBDbG9zdXJlIENvbXBpbGVyIFwiYWR2YW5jZWRcIiBtb2RlLlxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xuICAgIH1cbiAgICBleHBvcnRzLl8gPSBfO1xuICB9IGVsc2Uge1xuICAgIHJvb3RbJ18nXSA9IF87XG4gIH1cblxuICAvLyBDdXJyZW50IHZlcnNpb24uXG4gIF8uVkVSU0lPTiA9ICcxLjMuMyc7XG5cbiAgLy8gQ29sbGVjdGlvbiBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBUaGUgY29ybmVyc3RvbmUsIGFuIGBlYWNoYCBpbXBsZW1lbnRhdGlvbiwgYWthIGBmb3JFYWNoYC5cbiAgLy8gSGFuZGxlcyBvYmplY3RzIHdpdGggdGhlIGJ1aWx0LWluIGBmb3JFYWNoYCwgYXJyYXlzLCBhbmQgcmF3IG9iamVjdHMuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBmb3JFYWNoYCBpZiBhdmFpbGFibGUuXG4gIHZhciBlYWNoID0gXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuO1xuICAgIGlmIChuYXRpdmVGb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBuYXRpdmVGb3JFYWNoKSB7XG4gICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChpIGluIG9iaiAmJiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSA9PT0gYnJlYWtlcikgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChfLmhhcyhvYmosIGtleSkpIHtcbiAgICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5LCBvYmopID09PSBicmVha2VyKSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRvciB0byBlYWNoIGVsZW1lbnQuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBtYXBgIGlmIGF2YWlsYWJsZS5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHRzO1xuICAgIGlmIChuYXRpdmVNYXAgJiYgb2JqLm1hcCA9PT0gbmF0aXZlTWFwKSByZXR1cm4gb2JqLm1hcChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgfSk7XG4gICAgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSByZXN1bHRzLmxlbmd0aCA9IG9iai5sZW5ndGg7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gKipSZWR1Y2UqKiBidWlsZHMgdXAgYSBzaW5nbGUgcmVzdWx0IGZyb20gYSBsaXN0IG9mIHZhbHVlcywgYWthIGBpbmplY3RgLFxuICAvLyBvciBgZm9sZGxgLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgcmVkdWNlYCBpZiBhdmFpbGFibGUuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgbWVtbywgY29udGV4dCkge1xuICAgIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgaWYgKG9iaiA9PSBudWxsKSBvYmogPSBbXTtcbiAgICBpZiAobmF0aXZlUmVkdWNlICYmIG9iai5yZWR1Y2UgPT09IG5hdGl2ZVJlZHVjZSkge1xuICAgICAgaWYgKGNvbnRleHQpIGl0ZXJhdG9yID0gXy5iaW5kKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBpbml0aWFsID8gb2JqLnJlZHVjZShpdGVyYXRvciwgbWVtbykgOiBvYmoucmVkdWNlKGl0ZXJhdG9yKTtcbiAgICB9XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgIG1lbW8gPSB2YWx1ZTtcbiAgICAgICAgaW5pdGlhbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZW1vID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBtZW1vLCB2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghaW5pdGlhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgIHJldHVybiBtZW1vO1xuICB9O1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgcmVkdWNlUmlnaHRgIGlmIGF2YWlsYWJsZS5cbiAgXy5yZWR1Y2VSaWdodCA9IF8uZm9sZHIgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgdmFyIGluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICBpZiAob2JqID09IG51bGwpIG9iaiA9IFtdO1xuICAgIGlmIChuYXRpdmVSZWR1Y2VSaWdodCAmJiBvYmoucmVkdWNlUmlnaHQgPT09IG5hdGl2ZVJlZHVjZVJpZ2h0KSB7XG4gICAgICBpZiAoY29udGV4dCkgaXRlcmF0b3IgPSBfLmJpbmQoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIGluaXRpYWwgPyBvYmoucmVkdWNlUmlnaHQoaXRlcmF0b3IsIG1lbW8pIDogb2JqLnJlZHVjZVJpZ2h0KGl0ZXJhdG9yKTtcbiAgICB9XG4gICAgdmFyIHJldmVyc2VkID0gXy50b0FycmF5KG9iaikucmV2ZXJzZSgpO1xuICAgIGlmIChjb250ZXh0ICYmICFpbml0aWFsKSBpdGVyYXRvciA9IF8uYmluZChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgcmV0dXJuIGluaXRpYWwgPyBfLnJlZHVjZShyZXZlcnNlZCwgaXRlcmF0b3IsIG1lbW8sIGNvbnRleHQpIDogXy5yZWR1Y2UocmV2ZXJzZWQsIGl0ZXJhdG9yKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuIEFsaWFzZWQgYXMgYGRldGVjdGAuXG4gIF8uZmluZCA9IF8uZGV0ZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgYW55KG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSB7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBmaWx0ZXJgIGlmIGF2YWlsYWJsZS5cbiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cbiAgXy5maWx0ZXIgPSBfLnNlbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdHM7XG4gICAgaWYgKG5hdGl2ZUZpbHRlciAmJiBvYmouZmlsdGVyID09PSBuYXRpdmVGaWx0ZXIpIHJldHVybiBvYmouZmlsdGVyKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gIF8ucmVqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0cztcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAoIWl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgd2hldGhlciBhbGwgb2YgdGhlIGVsZW1lbnRzIG1hdGNoIGEgdHJ1dGggdGVzdC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGV2ZXJ5YCBpZiBhdmFpbGFibGUuXG4gIC8vIEFsaWFzZWQgYXMgYGFsbGAuXG4gIF8uZXZlcnkgPSBfLmFsbCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKG5hdGl2ZUV2ZXJ5ICYmIG9iai5ldmVyeSA9PT0gbmF0aXZlRXZlcnkpIHJldHVybiBvYmouZXZlcnkoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmICghKHJlc3VsdCA9IHJlc3VsdCAmJiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpKSByZXR1cm4gYnJlYWtlcjtcbiAgICB9KTtcbiAgICByZXR1cm4gISFyZXN1bHQ7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBvYmplY3QgbWF0Y2hlcyBhIHRydXRoIHRlc3QuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBzb21lYCBpZiBhdmFpbGFibGUuXG4gIC8vIEFsaWFzZWQgYXMgYGFueWAuXG4gIHZhciBhbnkgPSBfLnNvbWUgPSBfLmFueSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRvciB8fCAoaXRlcmF0b3IgPSBfLmlkZW50aXR5KTtcbiAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChuYXRpdmVTb21lICYmIG9iai5zb21lID09PSBuYXRpdmVTb21lKSByZXR1cm4gb2JqLnNvbWUoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChyZXN1bHQgfHwgKHJlc3VsdCA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkpIHJldHVybiBicmVha2VyO1xuICAgIH0pO1xuICAgIHJldHVybiAhIXJlc3VsdDtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYSBnaXZlbiB2YWx1ZSBpcyBpbmNsdWRlZCBpbiB0aGUgYXJyYXkgb3Igb2JqZWN0IHVzaW5nIGA9PT1gLlxuICAvLyBBbGlhc2VkIGFzIGBjb250YWluc2AuXG4gIF8uaW5jbHVkZSA9IF8uY29udGFpbnMgPSBmdW5jdGlvbihvYmosIHRhcmdldCkge1xuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIGZvdW5kO1xuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIG9iai5pbmRleE9mID09PSBuYXRpdmVJbmRleE9mKSByZXR1cm4gb2JqLmluZGV4T2YodGFyZ2V0KSAhPSAtMTtcbiAgICBmb3VuZCA9IGFueShvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRhcmdldDtcbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG4gIH07XG5cbiAgLy8gSW52b2tlIGEgbWV0aG9kICh3aXRoIGFyZ3VtZW50cykgb24gZXZlcnkgaXRlbSBpbiBhIGNvbGxlY3Rpb24uXG4gIF8uaW52b2tlID0gZnVuY3Rpb24ob2JqLCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIChfLmlzRnVuY3Rpb24obWV0aG9kKSA/IG1ldGhvZCB8fCB2YWx1ZSA6IHZhbHVlW21ldGhvZF0pLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSl7IHJldHVybiB2YWx1ZVtrZXldOyB9KTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCBvciAoZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0FycmF5KG9iaikgJiYgb2JqWzBdID09PSArb2JqWzBdKSByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgb2JqKTtcbiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNFbXB0eShvYmopKSByZXR1cm4gLUluZmluaXR5O1xuICAgIHZhciByZXN1bHQgPSB7Y29tcHV0ZWQgOiAtSW5maW5pdHl9O1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IGl0ZXJhdG9yID8gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpIDogdmFsdWU7XG4gICAgICBjb21wdXRlZCA+PSByZXN1bHQuY29tcHV0ZWQgJiYgKHJlc3VsdCA9IHt2YWx1ZSA6IHZhbHVlLCBjb21wdXRlZCA6IGNvbXB1dGVkfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0FycmF5KG9iaikgJiYgb2JqWzBdID09PSArb2JqWzBdKSByZXR1cm4gTWF0aC5taW4uYXBwbHkoTWF0aCwgb2JqKTtcbiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNFbXB0eShvYmopKSByZXR1cm4gSW5maW5pdHk7XG4gICAgdmFyIHJlc3VsdCA9IHtjb21wdXRlZCA6IEluZmluaXR5fTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBpdGVyYXRvciA/IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSA6IHZhbHVlO1xuICAgICAgY29tcHV0ZWQgPCByZXN1bHQuY29tcHV0ZWQgJiYgKHJlc3VsdCA9IHt2YWx1ZSA6IHZhbHVlLCBjb21wdXRlZCA6IGNvbXB1dGVkfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgfTtcblxuICAvLyBTaHVmZmxlIGFuIGFycmF5LlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2h1ZmZsZWQgPSBbXSwgcmFuZDtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByYW5kID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGluZGV4ICsgMSkpO1xuICAgICAgc2h1ZmZsZWRbaW5kZXhdID0gc2h1ZmZsZWRbcmFuZF07XG4gICAgICBzaHVmZmxlZFtyYW5kXSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBzaHVmZmxlZDtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0b3IuXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCB2YWwsIGNvbnRleHQpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSBfLmlzRnVuY3Rpb24odmFsKSA/IHZhbCA6IGZ1bmN0aW9uKG9iaikgeyByZXR1cm4gb2JqW3ZhbF07IH07XG4gICAgcmV0dXJuIF8ucGx1Y2soXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlIDogdmFsdWUsXG4gICAgICAgIGNyaXRlcmlhIDogaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYSwgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgaWYgKGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XG4gICAgICBpZiAoYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG4gICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG4gICAgfSksICd2YWx1ZScpO1xuICB9O1xuXG4gIC8vIEdyb3VwcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLiBQYXNzIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGVcbiAgLy8gdG8gZ3JvdXAgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjcml0ZXJpb24uXG4gIF8uZ3JvdXBCeSA9IGZ1bmN0aW9uKG9iaiwgdmFsKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBpdGVyYXRvciA9IF8uaXNGdW5jdGlvbih2YWwpID8gdmFsIDogZnVuY3Rpb24ob2JqKSB7IHJldHVybiBvYmpbdmFsXTsgfTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICB2YXIga2V5ID0gaXRlcmF0b3IodmFsdWUsIGluZGV4KTtcbiAgICAgIChyZXN1bHRba2V5XSB8fCAocmVzdWx0W2tleV0gPSBbXSkpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IGF0IHdoYXQgaW5kZXggYW4gb2JqZWN0IHNob3VsZFxuICAvLyBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0b3IpIHtcbiAgICBpdGVyYXRvciB8fCAoaXRlcmF0b3IgPSBfLmlkZW50aXR5KTtcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xuICAgICAgaXRlcmF0b3IoYXJyYXlbbWlkXSkgPCBpdGVyYXRvcihvYmopID8gbG93ID0gbWlkICsgMSA6IGhpZ2ggPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH07XG5cbiAgLy8gU2FmZWx5IGNvbnZlcnQgYW55dGhpbmcgaXRlcmFibGUgaW50byBhIHJlYWwsIGxpdmUgYXJyYXkuXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghb2JqKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgaWYgKF8uaXNBcnJheShvYmopKSAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzbGljZS5jYWxsKG9iaik7XG4gICAgaWYgKF8uaXNBcmd1bWVudHMob2JqKSkgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzbGljZS5jYWxsKG9iaik7XG4gICAgaWYgKG9iai50b0FycmF5ICYmIF8uaXNGdW5jdGlvbihvYmoudG9BcnJheSkpIHJldHVybiBvYmoudG9BcnJheSgpO1xuICAgIHJldHVybiBfLnZhbHVlcyhvYmopO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIG9iamVjdC5cbiAgXy5zaXplID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBBcnJheSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcbiAgLy8gYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIChuICE9IG51bGwpICYmICFndWFyZCA/IHNsaWNlLmNhbGwoYXJyYXksIDAsIG4pIDogYXJyYXlbMF07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgbGFzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEVzcGVjY2lhbHkgdXNlZnVsIG9uXG4gIC8vIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIGFsbCB0aGUgdmFsdWVzIGluXG4gIC8vIHRoZSBhcnJheSwgZXhjbHVkaW5nIHRoZSBsYXN0IE4uIFRoZSAqKmd1YXJkKiogY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aFxuICAvLyBgXy5tYXBgLlxuICBfLmluaXRpYWwgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgYXJyYXkubGVuZ3RoIC0gKChuID09IG51bGwpIHx8IGd1YXJkID8gMSA6IG4pKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIFRoZSAqKmd1YXJkKiogY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmxhc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoKG4gIT0gbnVsbCkgJiYgIWd1YXJkKSB7XG4gICAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgTWF0aC5tYXgoYXJyYXkubGVuZ3RoIC0gbiwgMCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGZpcnN0IGVudHJ5IG9mIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgdGFpbGAuXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqaW5kZXgqKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBvZiB0aGUgdmFsdWVzIGluIHRoZSBhcnJheSBmcm9tIHRoYXQgaW5kZXggb253YXJkLiBUaGUgKipndWFyZCoqXG4gIC8vIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5yZXN0ID0gXy50YWlsID0gZnVuY3Rpb24oYXJyYXksIGluZGV4LCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAoaW5kZXggPT0gbnVsbCkgfHwgZ3VhcmQgPyAxIDogaW5kZXgpO1xuICB9O1xuXG4gIC8vIFRyaW0gb3V0IGFsbCBmYWxzeSB2YWx1ZXMgZnJvbSBhbiBhcnJheS5cbiAgXy5jb21wYWN0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXsgcmV0dXJuICEhdmFsdWU7IH0pO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvbXBsZXRlbHkgZmxhdHRlbmVkIHZlcnNpb24gb2YgYW4gYXJyYXkuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIF8ucmVkdWNlKGFycmF5LCBmdW5jdGlvbihtZW1vLCB2YWx1ZSkge1xuICAgICAgaWYgKF8uaXNBcnJheSh2YWx1ZSkpIHJldHVybiBtZW1vLmNvbmNhdChzaGFsbG93ID8gdmFsdWUgOiBfLmZsYXR0ZW4odmFsdWUpKTtcbiAgICAgIG1lbW9bbWVtby5sZW5ndGhdID0gdmFsdWU7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9LCBbXSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgYXJyYXkgdGhhdCBkb2VzIG5vdCBjb250YWluIHRoZSBzcGVjaWZpZWQgdmFsdWUocykuXG4gIF8ud2l0aG91dCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZGlmZmVyZW5jZShhcnJheSwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBoYXMgYWxyZWFkeVxuICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXG4gIC8vIEFsaWFzZWQgYXMgYHVuaXF1ZWAuXG4gIF8udW5pcSA9IF8udW5pcXVlID0gZnVuY3Rpb24oYXJyYXksIGlzU29ydGVkLCBpdGVyYXRvcikge1xuICAgIHZhciBpbml0aWFsID0gaXRlcmF0b3IgPyBfLm1hcChhcnJheSwgaXRlcmF0b3IpIDogYXJyYXk7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAvLyBUaGUgYGlzU29ydGVkYCBmbGFnIGlzIGlycmVsZXZhbnQgaWYgdGhlIGFycmF5IG9ubHkgY29udGFpbnMgdHdvIGVsZW1lbnRzLlxuICAgIGlmIChhcnJheS5sZW5ndGggPCAzKSBpc1NvcnRlZCA9IHRydWU7XG4gICAgXy5yZWR1Y2UoaW5pdGlhbCwgZnVuY3Rpb24gKG1lbW8sIHZhbHVlLCBpbmRleCkge1xuICAgICAgaWYgKGlzU29ydGVkID8gXy5sYXN0KG1lbW8pICE9PSB2YWx1ZSB8fCAhbWVtby5sZW5ndGggOiAhXy5pbmNsdWRlKG1lbW8sIHZhbHVlKSkge1xuICAgICAgICBtZW1vLnB1c2godmFsdWUpO1xuICAgICAgICByZXN1bHRzLnB1c2goYXJyYXlbaW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHVuaW9uOiBlYWNoIGRpc3RpbmN0IGVsZW1lbnQgZnJvbSBhbGwgb2ZcbiAgLy8gdGhlIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8udW5pb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy51bmlxKF8uZmxhdHRlbihhcmd1bWVudHMsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuIChBbGlhc2VkIGFzIFwiaW50ZXJzZWN0XCIgZm9yIGJhY2stY29tcGF0LilcbiAgXy5pbnRlcnNlY3Rpb24gPSBfLmludGVyc2VjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKF8udW5pcShhcnJheSksIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiBfLmV2ZXJ5KHJlc3QsIGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBfLmluZGV4T2Yob3RoZXIsIGl0ZW0pID49IDA7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBfLmZsYXR0ZW4oc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCB0cnVlKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXsgcmV0dXJuICFfLmluY2x1ZGUocmVzdCwgdmFsdWUpOyB9KTtcbiAgfTtcblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICBfLnppcCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBsZW5ndGggPSBfLm1heChfLnBsdWNrKGFyZ3MsICdsZW5ndGgnKSk7XG4gICAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSByZXN1bHRzW2ldID0gXy5wbHVjayhhcmdzLCBcIlwiICsgaSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gSWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwbHkgdXMgd2l0aCBpbmRleE9mIChJJ20gbG9va2luZyBhdCB5b3UsICoqTVNJRSoqKSxcbiAgLy8gd2UgbmVlZCB0aGlzIGZ1bmN0aW9uLiBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuXG4gIC8vIGl0ZW0gaW4gYW4gYXJyYXksIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBpbmRleE9mYCBpZiBhdmFpbGFibGUuXG4gIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxuICAvLyBmb3IgKippc1NvcnRlZCoqIHRvIHVzZSBiaW5hcnkgc2VhcmNoLlxuICBfLmluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgaXNTb3J0ZWQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIC0xO1xuICAgIHZhciBpLCBsO1xuICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgaSA9IF8uc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0pO1xuICAgICAgcmV0dXJuIGFycmF5W2ldID09PSBpdGVtID8gaSA6IC0xO1xuICAgIH1cbiAgICBpZiAobmF0aXZlSW5kZXhPZiAmJiBhcnJheS5pbmRleE9mID09PSBuYXRpdmVJbmRleE9mKSByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSBpZiAoaSBpbiBhcnJheSAmJiBhcnJheVtpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBsYXN0SW5kZXhPZmAgaWYgYXZhaWxhYmxlLlxuICBfLmxhc3RJbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0pIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIC0xO1xuICAgIGlmIChuYXRpdmVMYXN0SW5kZXhPZiAmJiBhcnJheS5sYXN0SW5kZXhPZiA9PT0gbmF0aXZlTGFzdEluZGV4T2YpIHJldHVybiBhcnJheS5sYXN0SW5kZXhPZihpdGVtKTtcbiAgICB2YXIgaSA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSBpZiAoaSBpbiBhcnJheSAmJiBhcnJheVtpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBhcmd1bWVudHNbMl0gfHwgMTtcblxuICAgIHZhciBsZW4gPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIHJhbmdlID0gbmV3IEFycmF5KGxlbik7XG5cbiAgICB3aGlsZShpZHggPCBsZW4pIHtcbiAgICAgIHJhbmdlW2lkeCsrXSA9IHN0YXJ0O1xuICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSZXVzYWJsZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgcHJvdG90eXBlIHNldHRpbmcuXG4gIHZhciBjdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gQmluZGluZyB3aXRoIGFyZ3VtZW50cyBpcyBhbHNvIGtub3duIGFzIGBjdXJyeWAuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBGdW5jdGlvbi5iaW5kYCBpZiBhdmFpbGFibGUuXG4gIC8vIFdlIGNoZWNrIGZvciBgZnVuYy5iaW5kYCBmaXJzdCwgdG8gZmFpbCBmYXN0IHdoZW4gYGZ1bmNgIGlzIHVuZGVmaW5lZC5cbiAgXy5iaW5kID0gZnVuY3Rpb24gYmluZChmdW5jLCBjb250ZXh0KSB7XG4gICAgdmFyIGJvdW5kLCBhcmdzO1xuICAgIGlmIChmdW5jLmJpbmQgPT09IG5hdGl2ZUJpbmQgJiYgbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSkgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IGZ1bmMucHJvdG90eXBlO1xuICAgICAgdmFyIHNlbGYgPSBuZXcgY3RvcjtcbiAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHNlbGYsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEJpbmQgYWxsIG9mIGFuIG9iamVjdCdzIG1ldGhvZHMgdG8gdGhhdCBvYmplY3QuIFVzZWZ1bCBmb3IgZW5zdXJpbmcgdGhhdFxuICAvLyBhbGwgY2FsbGJhY2tzIGRlZmluZWQgb24gYW4gb2JqZWN0IGJlbG9uZyB0byBpdC5cbiAgXy5iaW5kQWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGZ1bmNzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGlmIChmdW5jcy5sZW5ndGggPT0gMCkgZnVuY3MgPSBfLmZ1bmN0aW9ucyhvYmopO1xuICAgIGVhY2goZnVuY3MsIGZ1bmN0aW9uKGYpIHsgb2JqW2ZdID0gXy5iaW5kKG9ialtmXSwgb2JqKTsgfSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtbyA9IHt9O1xuICAgIGhhc2hlciB8fCAoaGFzaGVyID0gXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGtleSA9IGhhc2hlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF8uaGFzKG1lbW8sIGtleSkgPyBtZW1vW2tleV0gOiAobWVtb1trZXldID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpOyB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICByZXR1cm4gXy5kZWxheS5hcHBseShfLCBbZnVuYywgMV0uY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS5cbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgY29udGV4dCwgYXJncywgdGltZW91dCwgdGhyb3R0bGluZywgbW9yZSwgcmVzdWx0O1xuICAgIHZhciB3aGVuRG9uZSA9IF8uZGVib3VuY2UoZnVuY3Rpb24oKXsgbW9yZSA9IHRocm90dGxpbmcgPSBmYWxzZTsgfSwgd2FpdCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY29udGV4dCA9IHRoaXM7IGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmIChtb3JlKSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICB3aGVuRG9uZSgpO1xuICAgICAgfTtcbiAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgaWYgKHRocm90dGxpbmcpIHtcbiAgICAgICAgbW9yZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgd2hlbkRvbmUoKTtcbiAgICAgIHRocm90dGxpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICB9O1xuICAgICAgaWYgKGltbWVkaWF0ZSAmJiAhdGltZW91dCkgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAvLyBvZnRlbiB5b3UgY2FsbCBpdC4gVXNlZnVsIGZvciBsYXp5IGluaXRpYWxpemF0aW9uLlxuICBfLm9uY2UgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIHJhbiA9IGZhbHNlLCBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChyYW4pIHJldHVybiBtZW1vO1xuICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgIHJldHVybiBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gW2Z1bmNdLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuICAgICAgcmV0dXJuIHdyYXBwZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxuICAvLyBjb25zdW1pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICBfLmNvbXBvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZnVuY3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBmb3IgKHZhciBpID0gZnVuY3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYXJncyA9IFtmdW5jc1tpXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJnc1swXTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBhZnRlciBiZWluZyBjYWxsZWQgTiB0aW1lcy5cbiAgXy5hZnRlciA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgaWYgKHRpbWVzIDw9IDApIHJldHVybiBmdW5jKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPCAxKSB7IHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgXG4gIF8ua2V5cyA9IG5hdGl2ZUtleXMgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiAhPT0gT2JqZWN0KG9iaikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgb2JqZWN0Jyk7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzW2tleXMubGVuZ3RoXSA9IGtleTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYFxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH07XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIF8uZXh0ZW5kID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgZWFjaChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9ubHkgY29udGFpbmluZyB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5waWNrID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGVhY2goXy5mbGF0dGVuKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSksIGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKGtleSBpbiBvYmopIHJlc3VsdFtrZXldID0gb2JqW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBGaWxsIGluIGEgZ2l2ZW4gb2JqZWN0IHdpdGggZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICBfLmRlZmF1bHRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgZWFjaChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKG9ialtwcm9wXSA9PSBudWxsKSBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSAoc2hhbGxvdy1jbG9uZWQpIGR1cGxpY2F0ZSBvZiBhbiBvYmplY3QuXG4gIF8uY2xvbmUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF8uZXh0ZW5kKHt9LCBvYmopO1xuICB9O1xuXG4gIC8vIEludm9rZXMgaW50ZXJjZXB0b3Igd2l0aCB0aGUgb2JqLCBhbmQgdGhlbiByZXR1cm5zIG9iai5cbiAgLy8gVGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4sIGluXG4gIC8vIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW4gdGhlIGNoYWluLlxuICBfLnRhcCA9IGZ1bmN0aW9uKG9iaiwgaW50ZXJjZXB0b3IpIHtcbiAgICBpbnRlcmNlcHRvcihvYmopO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24uXG4gIGZ1bmN0aW9uIGVxKGEsIGIsIHN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgSGFybW9ueSBgZWdhbGAgcHJvcG9zYWw6IGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbC5cbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYS5fY2hhaW4pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiLl9jaGFpbikgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gSW52b2tlIGEgY3VzdG9tIGBpc0VxdWFsYCBtZXRob2QgaWYgb25lIGlzIHByb3ZpZGVkLlxuICAgIGlmIChhLmlzRXF1YWwgJiYgXy5pc0Z1bmN0aW9uKGEuaXNFcXVhbCkpIHJldHVybiBhLmlzRXF1YWwoYik7XG4gICAgaWYgKGIuaXNFcXVhbCAmJiBfLmlzRnVuY3Rpb24oYi5pc0VxdWFsKSkgcmV0dXJuIGIuaXNFcXVhbChhKTtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT0gdG9TdHJpbmcuY2FsbChiKSkgcmV0dXJuIGZhbHNlO1xuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuIGEgPT0gU3RyaW5nKGIpO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS4gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvclxuICAgICAgICAvLyBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuIGEgIT0gK2EgPyBiICE9ICtiIDogKGEgPT0gMCA/IDEgLyBhID09IDEgLyBiIDogYSA9PSArYik7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT0gK2I7XG4gICAgICAvLyBSZWdFeHBzIGFyZSBjb21wYXJlZCBieSB0aGVpciBzb3VyY2UgcGF0dGVybnMgYW5kIGZsYWdzLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgICAgcmV0dXJuIGEuc291cmNlID09IGIuc291cmNlICYmXG4gICAgICAgICAgICAgICBhLmdsb2JhbCA9PSBiLmdsb2JhbCAmJlxuICAgICAgICAgICAgICAgYS5tdWx0aWxpbmUgPT0gYi5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgICAgIGEuaWdub3JlQ2FzZSA9PSBiLmlnbm9yZUNhc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cbiAgICB2YXIgbGVuZ3RoID0gc3RhY2subGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PSBhKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIHN0YWNrLnB1c2goYSk7XG4gICAgdmFyIHNpemUgPSAwLCByZXN1bHQgPSB0cnVlO1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChjbGFzc05hbWUgPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXG4gICAgICBzaXplID0gYS5sZW5ndGg7XG4gICAgICByZXN1bHQgPSBzaXplID09IGIubGVuZ3RoO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgICB3aGlsZSAoc2l6ZS0tKSB7XG4gICAgICAgICAgLy8gRW5zdXJlIGNvbW11dGF0aXZlIGVxdWFsaXR5IGZvciBzcGFyc2UgYXJyYXlzLlxuICAgICAgICAgIGlmICghKHJlc3VsdCA9IHNpemUgaW4gYSA9PSBzaXplIGluIGIgJiYgZXEoYVtzaXplXSwgYltzaXplXSwgc3RhY2spKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgaWYgKCdjb25zdHJ1Y3RvcicgaW4gYSAhPSAnY29uc3RydWN0b3InIGluIGIgfHwgYS5jb25zdHJ1Y3RvciAhPSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICAgIGZvciAodmFyIGtleSBpbiBhKSB7XG4gICAgICAgIGlmIChfLmhhcyhhLCBrZXkpKSB7XG4gICAgICAgICAgLy8gQ291bnQgdGhlIGV4cGVjdGVkIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxuICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXIuXG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgc3RhY2spKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBmb3IgKGtleSBpbiBiKSB7XG4gICAgICAgICAgaWYgKF8uaGFzKGIsIGtleSkgJiYgIShzaXplLS0pKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSAhc2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgc3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIsIFtdKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIGFycmF5LCBzdHJpbmcsIG9yIG9iamVjdCBlbXB0eT9cbiAgLy8gQW4gXCJlbXB0eVwiIG9iamVjdCBoYXMgbm8gZW51bWVyYWJsZSBvd24tcHJvcGVydGllcy5cbiAgXy5pc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoXy5pc0FycmF5KG9iaikgfHwgXy5pc1N0cmluZyhvYmopKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50P1xuICBfLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0P1xuICBfLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBhcmd1bWVudHMgb2JqZWN0P1xuICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbiAgfTtcbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gISEob2JqICYmIF8uaGFzKG9iaiwgJ2NhbGxlZScpKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGZ1bmN0aW9uP1xuICBfLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIHN0cmluZz9cbiAgXy5pc1N0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgU3RyaW5nXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIG51bWJlcj9cbiAgXy5pc051bWJlciA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyP1xuICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBpc0Zpbml0ZShvYmopO1xuICB9O1xuXG4gIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD9cbiAgXy5pc05hTiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIC8vIGBOYU5gIGlzIHRoZSBvbmx5IHZhbHVlIGZvciB3aGljaCBgPT09YCBpcyBub3QgcmVmbGV4aXZlLlxuICAgIHJldHVybiBvYmogIT09IG9iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgZGF0ZT9cbiAgXy5pc0RhdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IERhdGVdJztcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYSByZWd1bGFyIGV4cHJlc3Npb24/XG4gIF8uaXNSZWdFeHAgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IFJlZ0V4cF0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgZXF1YWwgdG8gbnVsbD9cbiAgXy5pc051bGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgdW5kZWZpbmVkP1xuICBfLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xuICB9O1xuXG4gIC8vIEhhcyBvd24gcHJvcGVydHk/XG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRvcnMuXG4gIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uIChuLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIGkpO1xuICB9O1xuXG4gIC8vIEVzY2FwZSBhIHN0cmluZyBmb3IgSFRNTCBpbnRlcnBvbGF0aW9uLlxuICBfLmVzY2FwZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHJldHVybiAoJycrc3RyaW5nKS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7JykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpLnJlcGxhY2UoLycvZywgJyYjeDI3OycpLnJlcGxhY2UoL1xcLy9nLCcmI3gyRjsnKTtcbiAgfTtcblxuICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIHByb3BlcnR5IGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQ7XG4gIC8vIG90aGVyd2lzZSwgcmV0dXJuIGl0LlxuICBfLnJlc3VsdCA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiBudWxsO1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgcmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QsIGVuc3VyaW5nIHRoYXRcbiAgLy8gdGhleSdyZSBjb3JyZWN0bHkgYWRkZWQgdG8gdGhlIE9PUCB3cmFwcGVyIGFzIHdlbGwuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBlYWNoKF8uZnVuY3Rpb25zKG9iaiksIGZ1bmN0aW9uKG5hbWUpe1xuICAgICAgYWRkVG9XcmFwcGVyKG5hbWUsIF9bbmFtZV0gPSBvYmpbbmFtZV0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGludGVnZXIgaWQgKHVuaXF1ZSB3aXRoaW4gdGhlIGVudGlyZSBjbGllbnQgc2Vzc2lvbikuXG4gIC8vIFVzZWZ1bCBmb3IgdGVtcG9yYXJ5IERPTSBpZHMuXG4gIHZhciBpZENvdW50ZXIgPSAwO1xuICBfLnVuaXF1ZUlkID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIGlkID0gaWRDb3VudGVyKys7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZSA6IC88JT0oW1xcc1xcU10rPyklPi9nLFxuICAgIGVzY2FwZSAgICAgIDogLzwlLShbXFxzXFxTXSs/KSU+L2dcbiAgfTtcblxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLy5eLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgXCInXCI6IFwiJ1wiLFxuICAgICdyJzogJ1xccicsXG4gICAgJ24nOiAnXFxuJyxcbiAgICAndCc6ICdcXHQnLFxuICAgICd1MjAyOCc6ICdcXHUyMDI4JyxcbiAgICAndTIwMjknOiAnXFx1MjAyOSdcbiAgfTtcblxuICBmb3IgKHZhciBwIGluIGVzY2FwZXMpIGVzY2FwZXNbZXNjYXBlc1twXV0gPSBwO1xuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHR8XFx1MjAyOHxcXHUyMDI5L2c7XG4gIHZhciB1bmVzY2FwZXIgPSAvXFxcXChcXFxcfCd8cnxufHR8dTIwMjh8dTIwMjkpL2c7XG5cbiAgLy8gV2l0aGluIGFuIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24sIG9yIGVzY2FwaW5nLCByZW1vdmUgSFRNTCBlc2NhcGluZ1xuICAvLyB0aGF0IGhhZCBiZWVuIHByZXZpb3VzbHkgYWRkZWQuXG4gIHZhciB1bmVzY2FwZSA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZS5yZXBsYWNlKHVuZXNjYXBlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSkge1xuICAgICAgcmV0dXJuIGVzY2FwZXNbZXNjYXBlXTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxuICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXG4gIC8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgZGF0YSwgc2V0dGluZ3MpIHtcbiAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoc2V0dGluZ3MgfHwge30sIF8udGVtcGxhdGVTZXR0aW5ncyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIHRha2luZyBjYXJlIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIHRoYXRcbiAgICAvLyBjYW5ub3QgYmUgaW5jbHVkZWQgaW4gYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlbiB1bmVzY2FwZSB0aGVtIGluIGNvZGVcbiAgICAvLyBibG9ja3MuXG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCIgKyB0ZXh0XG4gICAgICAucmVwbGFjZShlc2NhcGVyLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XG4gICAgICB9KVxuICAgICAgLnJlcGxhY2Uoc2V0dGluZ3MuZXNjYXBlIHx8IG5vTWF0Y2gsIGZ1bmN0aW9uKG1hdGNoLCBjb2RlKSB7XG4gICAgICAgIHJldHVybiBcIicrXFxuXy5lc2NhcGUoXCIgKyB1bmVzY2FwZShjb2RlKSArIFwiKStcXG4nXCI7XG4gICAgICB9KVxuICAgICAgLnJlcGxhY2Uoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCwgZnVuY3Rpb24obWF0Y2gsIGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIFwiJytcXG4oXCIgKyB1bmVzY2FwZShjb2RlKSArIFwiKStcXG4nXCI7XG4gICAgICB9KVxuICAgICAgLnJlcGxhY2Uoc2V0dGluZ3MuZXZhbHVhdGUgfHwgbm9NYXRjaCwgZnVuY3Rpb24obWF0Y2gsIGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIFwiJztcXG5cIiArIHVuZXNjYXBlKGNvZGUpICsgXCJcXG47X19wKz0nXCI7XG4gICAgICB9KSArIFwiJztcXG5cIjtcblxuICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXG4gICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcblxuICAgIHNvdXJjZSA9IFwidmFyIF9fcD0nJztcIiArXG4gICAgICBcInZhciBwcmludD1mdW5jdGlvbigpe19fcCs9QXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsICcnKX07XFxuXCIgK1xuICAgICAgc291cmNlICsgXCJyZXR1cm4gX19wO1xcblwiO1xuXG4gICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIGlmIChkYXRhKSByZXR1cm4gcmVuZGVyKGRhdGEsIF8pO1xuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICB9O1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24gc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIGJ1aWxkIHRpbWVcbiAgICAvLyBwcmVjb21waWxhdGlvbi5cbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIChzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJykgKyAnKXtcXG4nICtcbiAgICAgIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24sIHdoaWNoIHdpbGwgZGVsZWdhdGUgdG8gdGhlIHdyYXBwZXIuXG4gIF8uY2hhaW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXyhvYmopLmNoYWluKCk7XG4gIH07XG5cbiAgLy8gVGhlIE9PUCBXcmFwcGVyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG4gIHZhciB3cmFwcGVyID0gZnVuY3Rpb24ob2JqKSB7IHRoaXMuX3dyYXBwZWQgPSBvYmo7IH07XG5cbiAgLy8gRXhwb3NlIGB3cmFwcGVyLnByb3RvdHlwZWAgYXMgYF8ucHJvdG90eXBlYFxuICBfLnByb3RvdHlwZSA9IHdyYXBwZXIucHJvdG90eXBlO1xuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb250aW51ZSBjaGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uKG9iaiwgY2hhaW4pIHtcbiAgICByZXR1cm4gY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBIG1ldGhvZCB0byBlYXNpbHkgYWRkIGZ1bmN0aW9ucyB0byB0aGUgT09QIHdyYXBwZXIuXG4gIHZhciBhZGRUb1dyYXBwZXIgPSBmdW5jdGlvbihuYW1lLCBmdW5jKSB7XG4gICAgd3JhcHBlci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgdW5zaGlmdC5jYWxsKGFyZ3MsIHRoaXMuX3dyYXBwZWQpO1xuICAgICAgcmV0dXJuIHJlc3VsdChmdW5jLmFwcGx5KF8sIGFyZ3MpLCB0aGlzLl9jaGFpbik7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIF8ubWl4aW4oXyk7XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgd3JhcHBlci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB3cmFwcGVkID0gdGhpcy5fd3JhcHBlZDtcbiAgICAgIG1ldGhvZC5hcHBseSh3cmFwcGVkLCBhcmd1bWVudHMpO1xuICAgICAgdmFyIGxlbmd0aCA9IHdyYXBwZWQubGVuZ3RoO1xuICAgICAgaWYgKChuYW1lID09ICdzaGlmdCcgfHwgbmFtZSA9PSAnc3BsaWNlJykgJiYgbGVuZ3RoID09PSAwKSBkZWxldGUgd3JhcHBlZFswXTtcbiAgICAgIHJldHVybiByZXN1bHQod3JhcHBlZCwgdGhpcy5fY2hhaW4pO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFkZCBhbGwgYWNjZXNzb3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBlYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIHdyYXBwZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpLCB0aGlzLl9jaGFpbik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuICB3cmFwcGVyLnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NoYWluID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgd3JhcHBlci5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgIC8vIGV4cG9zZSB1bmljb2RlUmVnRXhwIGFzXG4gICAgLy8gLSBhbiBBTUQgbW9kdWxlIChyZXF1aXJlKVxuICAgIC8vIC0gYSBub2RlIG1vZHVsZVxuXG4gICAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZmFjdG9yeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC51bmljb2RlUmVnRXhwID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKHhyZWdleHApIHtcbiAgICB2YXIgdW5pY29kZVJlZ0V4cCA9IHt9O1xuXG4gICAgLy8gVGhlc2UgYXJlIHRha2VuIGZyb20gdGhlIFhSZWdFeHAgbGlicmFyeSAoc2VlIC4uL2V4dHJhY3RSZWdFeHBzRnJvbVhSZWdFeHAuanMpOlxuICAgIHVuaWNvZGVSZWdFeHAubGV0dGVyID0gL1tBLVphLXrCqsK1wrrDgC3DlsOYLcO2w7gty4HLhi3LkcugLcuky6zLrs2wLc20zbbNt826Lc29zobOiC3Ois6Mzo4tzqHOoy3Ptc+3LdKB0oot1KfUsS3VltWZ1aEt1ofXkC3XqtewLdey2KAt2YrZrtmv2bEt25Pbldul26bbrtuv27ot27zbv9yQ3JIt3K/djS3epd6x34ot36rftN+137rgoIAt4KCV4KCa4KCk4KCo4KGALeChmOCioOCioi3goqzgpIQt4KS54KS94KWQ4KWYLeCloeClsS3gpbfgpbkt4KW/4KaFLeCmjOCmj+CmkOCmky3gpqjgpqot4Kaw4Kay4Ka2LeCmueCmveCnjuCnnOCnneCnny3gp6Hgp7Dgp7HgqIUt4KiK4KiP4KiQ4KiTLeCoqOCoqi3gqLDgqLLgqLPgqLXgqLbgqLjgqLngqZkt4Kmc4Kme4KmyLeCptOCqhS3gqo3gqo8t4KqR4KqTLeCqqOCqqi3gqrDgqrLgqrPgqrUt4Kq54Kq94KuQ4Kug4Kuh4KyFLeCsjOCsj+CskOCsky3grKjgrKot4Kyw4Kyy4Kyz4Ky1LeCsueCsveCtnOCtneCtny3graHgrbHgroPgroUt4K6K4K6OLeCukOCuki3grpXgrpngrprgrpzgrp7grp/grqPgrqTgrqgt4K6q4K6uLeCuueCvkOCwhS3gsIzgsI4t4LCQ4LCSLeCwqOCwqi3gsLPgsLUt4LC54LC94LGY4LGZ4LGg4LGh4LKFLeCyjOCyji3gspDgspIt4LKo4LKqLeCys+CytS3gsrngsr3gs57gs6Dgs6Hgs7Hgs7LgtIUt4LSM4LSOLeC0kOC0ki3gtLrgtL3gtY7gtaDgtaHgtbot4LW/4LaFLeC2luC2mi3gtrHgtrMt4La74La94LeALeC3huC4gS3guLDguLLguLPguYAt4LmG4LqB4LqC4LqE4LqH4LqI4LqK4LqN4LqULeC6l+C6mS3gup/guqEt4Lqj4Lql4Lqn4Lqq4Lqr4LqtLeC6sOC6suC6s+C6veC7gC3gu4Tgu4bgu5wt4Luf4LyA4L2ALeC9h+C9iS3gvazgvogt4L6M4YCALeGAquGAv+GBkC3hgZXhgZot4YGd4YGh4YGl4YGm4YGuLeGBsOGBtS3hgoHhgo7hgqAt4YOF4YOH4YON4YOQLeGDuuGDvC3hiYjhiYot4YmN4YmQLeGJluGJmOGJmi3hiZ3hiaAt4YqI4YqKLeGKjeGKkC3hirDhirIt4Yq14Yq4LeGKvuGLgOGLgi3hi4Xhi4gt4YuW4YuYLeGMkOGMki3hjJXhjJgt4Y2a4Y6ALeGOj+GOoC3hj7ThkIEt4Zms4ZmvLeGZv+GagS3hmprhmqAt4Zuq4ZyALeGcjOGcji3hnJHhnKAt4Zyx4Z2ALeGdkeGdoC3hnazhna4t4Z2w4Z6ALeGes+Gfl+GfnOGgoC3hobfhooAt4aKo4aKq4aKwLeGjteGkgC3hpJzhpZAt4aWt4aWwLeGltOGmgC3hpqvhp4Et4aeH4aiALeGoluGooC3hqZThqqfhrIUt4ayz4a2FLeGti+Gugy3hrqDhrq7hrq/hrrot4a+l4bCALeGwo+GxjS3hsY/hsZot4bG94bOpLeGzrOGzri3hs7Hhs7Xhs7bhtIAt4ba/4biALeG8leG8mC3hvJ3hvKAt4b2F4b2ILeG9jeG9kC3hvZfhvZnhvZvhvZ3hvZ8t4b294b6ALeG+tOG+ti3hvrzhvr7hv4It4b+E4b+GLeG/jOG/kC3hv5Phv5Yt4b+b4b+gLeG/rOG/si3hv7Thv7Yt4b+84oGx4oG/4oKQLeKCnOKEguKEh+KEii3ihJPihJXihJkt4oSd4oSk4oSm4oSo4oSqLeKEreKEry3ihLnihLwt4oS/4oWFLeKFieKFjuKGg+KGhOKwgC3isK7isLAt4rGe4rGgLeKzpOKzqy3is67is7Lis7PitIAt4rSl4rSn4rSt4rSwLeK1p+K1r+K2gC3itpbitqAt4ram4raoLeK2ruK2sC3itrbitrgt4ra+4reALeK3huK3iC3it47it5At4reW4reYLeK3nuK4r+OAheOAhuOAsS3jgLXjgLvjgLzjgYEt44KW44KdLeOCn+OCoS3jg7rjg7wt44O/44SFLeOEreOEsS3jho7jhqAt44a644ewLeOHv+OQgC3ktrXkuIAt6b+M6oCALeqSjOqTkC3qk73qlIAt6piM6piQLeqYn+qYquqYq+qZgC3qma7qmb8t6pqX6pqgLeqbpeqcly3qnJ/qnKIt6p6I6p6LLeqejuqekC3qnpPqnqAt6p6q6p+4Leqggeqggy3qoIXqoIct6qCK6qCMLeqgouqhgC3qobPqooIt6qKz6qOyLeqjt+qju+qkii3qpKXqpLAt6qWG6qWgLeqlvOqmhC3qprLqp4/qqIAt6qio6qmALeqpguqphC3qqYvqqaAt6qm26qm66qqALeqqr+qqseqqteqqtuqquS3qqr3qq4Dqq4Lqq5st6qud6qugLeqrquqrsi3qq7TqrIEt6qyG6qyJLeqsjuqskS3qrJbqrKAt6qym6qyoLeqsruqvgC3qr6LqsIAt7Z6j7Z6wLe2fhu2fiy3tn7vvpIAt76mt76mwLe+rme+sgC3vrIbvrJMt76yX76yd76yfLe+sqO+sqi3vrLbvrLgt76y876y+762A762B762D762E762GLe+use+vky3vtL3vtZAt77aP77aSLe+3h++3sC3vt7vvubAt77m077m2Le+7vO+8oS3vvLrvvYEt772a772mLe++vu+/gi3vv4fvv4ot77+P77+SLe+/l++/mi3vv5xdLztcbiAgICB1bmljb2RlUmVnRXhwLm1hcmsgPSAvW1xcdTAzMDAtXFx1MDM2RlxcdTA0ODMtXFx1MDQ4OVxcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA2MTAtXFx1MDYxQVxcdTA2NEItXFx1MDY1RlxcdTA2NzBcXHUwNkQ2LVxcdTA2RENcXHUwNkRGLVxcdTA2RTRcXHUwNkU3XFx1MDZFOFxcdTA2RUEtXFx1MDZFRFxcdTA3MTFcXHUwNzMwLVxcdTA3NEFcXHUwN0E2LVxcdTA3QjBcXHUwN0VCLVxcdTA3RjNcXHUwODE2LVxcdTA4MTlcXHUwODFCLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MkRcXHUwODU5LVxcdTA4NUJcXHUwOEU0LVxcdTA4RkVcXHUwOTAwLVxcdTA5MDNcXHUwOTNBLVxcdTA5M0NcXHUwOTNFLVxcdTA5NEZcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5ODEtXFx1MDk4M1xcdTA5QkNcXHUwOUJFLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRFxcdTA5RDdcXHUwOUUyXFx1MDlFM1xcdTBBMDEtXFx1MEEwM1xcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTcwXFx1MEE3MVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQUJDXFx1MEFCRS1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFFMlxcdTBBRTNcXHUwQjAxLVxcdTBCMDNcXHUwQjNDXFx1MEIzRS1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNjJcXHUwQjYzXFx1MEI4MlxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDdcXHUwQzAxLVxcdTBDMDNcXHUwQzNFLVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNjJcXHUwQzYzXFx1MEM4MlxcdTBDODNcXHUwQ0JDXFx1MENCRS1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0UyXFx1MENFM1xcdTBEMDJcXHUwRDAzXFx1MEQzRS1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDREXFx1MEQ1N1xcdTBENjJcXHUwRDYzXFx1MEQ4MlxcdTBEODNcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERjJcXHUwREYzXFx1MEUzMVxcdTBFMzQtXFx1MEUzQVxcdTBFNDctXFx1MEU0RVxcdTBFQjFcXHUwRUI0LVxcdTBFQjlcXHUwRUJCXFx1MEVCQ1xcdTBFQzgtXFx1MEVDRFxcdTBGMThcXHUwRjE5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEYzRVxcdTBGM0ZcXHUwRjcxLVxcdTBGODRcXHUwRjg2XFx1MEY4N1xcdTBGOEQtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDJCLVxcdTEwM0VcXHUxMDU2LVxcdTEwNTlcXHUxMDVFLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNkRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOERcXHUxMDhGXFx1MTA5QS1cXHUxMDlEXFx1MTM1RC1cXHUxMzVGXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3QjQtXFx1MTdEM1xcdTE3RERcXHUxODBCLVxcdTE4MERcXHUxOEE5XFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTlCMC1cXHUxOUMwXFx1MTlDOFxcdTE5QzlcXHUxQTE3LVxcdTFBMUJcXHUxQTU1LVxcdTFBNUVcXHUxQTYwLVxcdTFBN0NcXHUxQTdGXFx1MUIwMC1cXHUxQjA0XFx1MUIzNC1cXHUxQjQ0XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQjgyXFx1MUJBMS1cXHUxQkFEXFx1MUJFNi1cXHUxQkYzXFx1MUMyNC1cXHUxQzM3XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0U4XFx1MUNFRFxcdTFDRjItXFx1MUNGNFxcdTFEQzAtXFx1MURFNlxcdTFERkMtXFx1MURGRlxcdTIwRDAtXFx1MjBGMFxcdTJDRUYtXFx1MkNGMVxcdTJEN0ZcXHUyREUwLVxcdTJERkZcXHUzMDJBLVxcdTMwMkZcXHUzMDk5XFx1MzA5QVxcdUE2NkYtXFx1QTY3MlxcdUE2NzQtXFx1QTY3RFxcdUE2OUZcXHVBNkYwXFx1QTZGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjMtXFx1QTgyN1xcdUE4ODBcXHVBODgxXFx1QThCNC1cXHVBOEM0XFx1QThFMC1cXHVBOEYxXFx1QTkyNi1cXHVBOTJEXFx1QTk0Ny1cXHVBOTUzXFx1QTk4MC1cXHVBOTgzXFx1QTlCMy1cXHVBOUMwXFx1QUEyOS1cXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTREXFx1QUE3QlxcdUFBQjBcXHVBQUIyLVxcdUFBQjRcXHVBQUI3XFx1QUFCOFxcdUFBQkVcXHVBQUJGXFx1QUFDMVxcdUFBRUItXFx1QUFFRlxcdUFBRjVcXHVBQUY2XFx1QUJFMy1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVGQjFFXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTI2XS87XG4gICAgdW5pY29kZVJlZ0V4cC5udW1iZXIgPSAvWzAtOcKywrPCucK8LcK+2aAt2anbsC3bud+ALd+J4KWmLeClr+Cnpi3gp6/gp7Qt4Ke54KmmLeCpr+Crpi3gq6/graYt4K2v4K2yLeCtt+Cvpi3gr7LgsaYt4LGv4LG4LeCxvuCzpi3gs6/gtaYt4LW14LmQLeC5meC7kC3gu5ngvKAt4Lyz4YGALeGBieGCkC3hgpnhjakt4Y284ZuuLeGbsOGfoC3hn6nhn7At4Z+54aCQLeGgmeGlhi3hpY/hp5At4aea4aqALeGqieGqkC3hqpnhrZAt4a2Z4a6wLeGuueGxgC3hsYnhsZAt4bGZ4oGw4oG0LeKBueKCgC3igonihZAt4oaC4oaFLeKGieKRoC3ikpvik6ot4pO/4p22LeKek+KzveOAh+OAoS3jgKnjgLgt44C644aSLeOGleOIoC3jiKnjiYgt44mP44mRLeOJn+OKgC3jionjirEt44q/6pigLeqYqeqbpi3qm6/qoLAt6qC16qOQLeqjmeqkgC3qpInqp5At6qeZ6qmQLeqpmeqvsC3qr7nvvJAt77yZXS87XG4gICAgdW5pY29kZVJlZ0V4cC5wdW5jdHVhdGlvbiA9IC9bXFx1MDAyMS1cXHUwMDIzXFx1MDAyNS1cXHUwMDJBXFx1MDAyQy1cXHUwMDJGXFx1MDAzQVxcdTAwM0JcXHUwMDNGXFx1MDA0MFxcdTAwNUItXFx1MDA1RFxcdTAwNUZcXHUwMDdCXFx1MDA3RFxcdTAwQTFcXHUwMEE3XFx1MDBBQlxcdTAwQjZcXHUwMEI3XFx1MDBCQlxcdTAwQkZcXHUwMzdFXFx1MDM4N1xcdTA1NUEtXFx1MDU1RlxcdTA1ODlcXHUwNThBXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RjNcXHUwNUY0XFx1MDYwOVxcdTA2MEFcXHUwNjBDXFx1MDYwRFxcdTA2MUJcXHUwNjFFXFx1MDYxRlxcdTA2NkEtXFx1MDY2RFxcdTA2RDRcXHUwNzAwLVxcdTA3MERcXHUwN0Y3LVxcdTA3RjlcXHUwODMwLVxcdTA4M0VcXHUwODVFXFx1MDk2NFxcdTA5NjVcXHUwOTcwXFx1MEFGMFxcdTBERjRcXHUwRTRGXFx1MEU1QVxcdTBFNUJcXHUwRjA0LVxcdTBGMTJcXHUwRjE0XFx1MEYzQS1cXHUwRjNEXFx1MEY4NVxcdTBGRDAtXFx1MEZENFxcdTBGRDlcXHUwRkRBXFx1MTA0QS1cXHUxMDRGXFx1MTBGQlxcdTEzNjAtXFx1MTM2OFxcdTE0MDBcXHUxNjZEXFx1MTY2RVxcdTE2OUJcXHUxNjlDXFx1MTZFQi1cXHUxNkVEXFx1MTczNVxcdTE3MzZcXHUxN0Q0LVxcdTE3RDZcXHUxN0Q4LVxcdTE3REFcXHUxODAwLVxcdTE4MEFcXHUxOTQ0XFx1MTk0NVxcdTFBMUVcXHUxQTFGXFx1MUFBMC1cXHUxQUE2XFx1MUFBOC1cXHUxQUFEXFx1MUI1QS1cXHUxQjYwXFx1MUJGQy1cXHUxQkZGXFx1MUMzQi1cXHUxQzNGXFx1MUM3RVxcdTFDN0ZcXHUxQ0MwLVxcdTFDQzdcXHUxQ0QzXFx1MjAxMC1cXHUyMDI3XFx1MjAzMC1cXHUyMDQzXFx1MjA0NS1cXHUyMDUxXFx1MjA1My1cXHUyMDVFXFx1MjA3RFxcdTIwN0VcXHUyMDhEXFx1MjA4RVxcdTIzMjlcXHUyMzJBXFx1Mjc2OC1cXHUyNzc1XFx1MjdDNVxcdTI3QzZcXHUyN0U2LVxcdTI3RUZcXHUyOTgzLVxcdTI5OThcXHUyOUQ4LVxcdTI5REJcXHUyOUZDXFx1MjlGRFxcdTJDRjktXFx1MkNGQ1xcdTJDRkVcXHUyQ0ZGXFx1MkQ3MFxcdTJFMDAtXFx1MkUyRVxcdTJFMzAtXFx1MkUzQlxcdTMwMDEtXFx1MzAwM1xcdTMwMDgtXFx1MzAxMVxcdTMwMTQtXFx1MzAxRlxcdTMwMzBcXHUzMDNEXFx1MzBBMFxcdTMwRkJcXHVBNEZFXFx1QTRGRlxcdUE2MEQtXFx1QTYwRlxcdUE2NzNcXHVBNjdFXFx1QTZGMi1cXHVBNkY3XFx1QTg3NC1cXHVBODc3XFx1QThDRVxcdUE4Q0ZcXHVBOEY4LVxcdUE4RkFcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkQzRVxcdUZEM0ZcXHVGRTEwLVxcdUZFMTlcXHVGRTMwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNjFcXHVGRTYzXFx1RkU2OFxcdUZFNkFcXHVGRTZCXFx1RkYwMS1cXHVGRjAzXFx1RkYwNS1cXHVGRjBBXFx1RkYwQy1cXHVGRjBGXFx1RkYxQVxcdUZGMUJcXHVGRjFGXFx1RkYyMFxcdUZGM0ItXFx1RkYzRFxcdUZGM0ZcXHVGRjVCXFx1RkY1RFxcdUZGNUYtXFx1RkY2NV0vO1xuICAgIHVuaWNvZGVSZWdFeHAuc3ltYm9sID0gL1tcXHUwMDI0KzwtPlxcdTAwNUVgXFx1MDA3Q37Coi3CpsKowqnCrMKuLcKxwrTCuMOXw7fLgi3LhcuSLcufy6Uty6vLrcuvLcu/zbXOhM6Fz7bSgtaP2IYt2IjYi9iO2I/bntup273bvt+24Key4Kez4Ke64Ke74Kux4K2w4K+zLeCvuuCxv+C1ueC4v+C8gS3gvIPgvJPgvJUt4LyX4LyaLeC8n+C8tOC8tuC8uOC+vi3gv4Xgv4ct4L+M4L+O4L+P4L+VLeC/mOGCnuGCn+GOkC3hjpnhn5vhpYDhp54t4ae/4a2hLeGtquGttC3hrbzhvr3hvr8t4b+B4b+NLeG/j+G/nS3hv5/hv60t4b+v4b+94b++4oGE4oGS4oG6LeKBvOKCii3igozigqAt4oK54oSA4oSB4oSDLeKEhuKEiOKEieKElOKEli3ihJjihJ4t4oSj4oSl4oSn4oSp4oSu4oS64oS74oWALeKFhOKFii3ihY3ihY/ihpAt4oyo4oyrLeKPs+KQgC3ikKbikYAt4pGK4pKcLeKTqeKUgC3im7/inIEt4p2n4p6ULeKfhOKfhy3in6Xin7At4qaC4qaZLeKnl+KnnC3ip7vip74t4q2M4q2QLeKtmeKzpS3is6riuoAt4rqZ4rqbLeK7s+K8gC3iv5Xiv7At4r+744CE44CS44CT44Cg44C244C344C+44C/44Kb44Kc44aQ44aR44aWLeOGn+OHgC3jh6PjiIAt44ie44iqLeOJh+OJkOOJoC3jib/jioot44qw44uALeOLvuOMgC3jj7/kt4At5Le/6pKQLeqThuqcgC3qnJbqnKDqnKHqnonqnorqoKgt6qCr6qC2Leqgueqpty3qqbnvrKnvrrIt76+B77e877e977mi77mkLe+5pu+5qe+8hO+8i++8nC3vvJ7vvL7vvYDvvZzvvZ7vv6At77+m77+oLe+/ru+/vO+/vV0vO1xuICAgIHVuaWNvZGVSZWdFeHAuc2VwYXJhdG9yID0gL1tcXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUxODBFXFx1MjAwMC1cXHUyMDBBXFx1MjAyOFxcdTIwMjlcXHUyMDJGXFx1MjA1RlxcdTMwMDBdLztcbiAgICB1bmljb2RlUmVnRXhwLm90aGVyID0gL1tcXHUwMDAwLVxcdTAwMUZcXHUwMDdGLVxcdTAwOUZcXHUwMEFEXFx1MDM3OFxcdTAzNzlcXHUwMzdGLVxcdTAzODNcXHUwMzhCXFx1MDM4RFxcdTAzQTJcXHUwNTI4LVxcdTA1MzBcXHUwNTU3XFx1MDU1OFxcdTA1NjBcXHUwNTg4XFx1MDU4Qi1cXHUwNThFXFx1MDU5MFxcdTA1QzgtXFx1MDVDRlxcdTA1RUItXFx1MDVFRlxcdTA1RjUtXFx1MDYwNVxcdTA2MUNcXHUwNjFEXFx1MDZERFxcdTA3MEVcXHUwNzBGXFx1MDc0QlxcdTA3NENcXHUwN0IyLVxcdTA3QkZcXHUwN0ZCLVxcdTA3RkZcXHUwODJFXFx1MDgyRlxcdTA4M0ZcXHUwODVDXFx1MDg1RFxcdTA4NUYtXFx1MDg5RlxcdTA4QTFcXHUwOEFELVxcdTA4RTNcXHUwOEZGXFx1MDk3OFxcdTA5ODBcXHUwOTg0XFx1MDk4RFxcdTA5OEVcXHUwOTkxXFx1MDk5MlxcdTA5QTlcXHUwOUIxXFx1MDlCMy1cXHUwOUI1XFx1MDlCQVxcdTA5QkJcXHUwOUM1XFx1MDlDNlxcdTA5QzlcXHUwOUNBXFx1MDlDRi1cXHUwOUQ2XFx1MDlEOC1cXHUwOURCXFx1MDlERVxcdTA5RTRcXHUwOUU1XFx1MDlGQy1cXHUwQTAwXFx1MEEwNFxcdTBBMEItXFx1MEEwRVxcdTBBMTFcXHUwQTEyXFx1MEEyOVxcdTBBMzFcXHUwQTM0XFx1MEEzN1xcdTBBM0FcXHUwQTNCXFx1MEEzRFxcdTBBNDMtXFx1MEE0NlxcdTBBNDlcXHUwQTRBXFx1MEE0RS1cXHUwQTUwXFx1MEE1Mi1cXHUwQTU4XFx1MEE1RFxcdTBBNUYtXFx1MEE2NVxcdTBBNzYtXFx1MEE4MFxcdTBBODRcXHUwQThFXFx1MEE5MlxcdTBBQTlcXHUwQUIxXFx1MEFCNFxcdTBBQkFcXHUwQUJCXFx1MEFDNlxcdTBBQ0FcXHUwQUNFXFx1MEFDRlxcdTBBRDEtXFx1MEFERlxcdTBBRTRcXHUwQUU1XFx1MEFGMi1cXHUwQjAwXFx1MEIwNFxcdTBCMERcXHUwQjBFXFx1MEIxMVxcdTBCMTJcXHUwQjI5XFx1MEIzMVxcdTBCMzRcXHUwQjNBXFx1MEIzQlxcdTBCNDVcXHUwQjQ2XFx1MEI0OVxcdTBCNEFcXHUwQjRFLVxcdTBCNTVcXHUwQjU4LVxcdTBCNUJcXHUwQjVFXFx1MEI2NFxcdTBCNjVcXHUwQjc4LVxcdTBCODFcXHUwQjg0XFx1MEI4Qi1cXHUwQjhEXFx1MEI5MVxcdTBCOTYtXFx1MEI5OFxcdTBCOUJcXHUwQjlEXFx1MEJBMC1cXHUwQkEyXFx1MEJBNS1cXHUwQkE3XFx1MEJBQi1cXHUwQkFEXFx1MEJCQS1cXHUwQkJEXFx1MEJDMy1cXHUwQkM1XFx1MEJDOVxcdTBCQ0VcXHUwQkNGXFx1MEJEMS1cXHUwQkQ2XFx1MEJEOC1cXHUwQkU1XFx1MEJGQi1cXHUwQzAwXFx1MEMwNFxcdTBDMERcXHUwQzExXFx1MEMyOVxcdTBDMzRcXHUwQzNBLVxcdTBDM0NcXHUwQzQ1XFx1MEM0OVxcdTBDNEUtXFx1MEM1NFxcdTBDNTdcXHUwQzVBLVxcdTBDNUZcXHUwQzY0XFx1MEM2NVxcdTBDNzAtXFx1MEM3N1xcdTBDODBcXHUwQzgxXFx1MEM4NFxcdTBDOERcXHUwQzkxXFx1MENBOVxcdTBDQjRcXHUwQ0JBXFx1MENCQlxcdTBDQzVcXHUwQ0M5XFx1MENDRS1cXHUwQ0Q0XFx1MENENy1cXHUwQ0REXFx1MENERlxcdTBDRTRcXHUwQ0U1XFx1MENGMFxcdTBDRjMtXFx1MEQwMVxcdTBEMDRcXHUwRDBEXFx1MEQxMVxcdTBEM0JcXHUwRDNDXFx1MEQ0NVxcdTBENDlcXHUwRDRGLVxcdTBENTZcXHUwRDU4LVxcdTBENUZcXHUwRDY0XFx1MEQ2NVxcdTBENzYtXFx1MEQ3OFxcdTBEODBcXHUwRDgxXFx1MEQ4NFxcdTBEOTctXFx1MEQ5OVxcdTBEQjJcXHUwREJDXFx1MERCRVxcdTBEQkZcXHUwREM3LVxcdTBEQzlcXHUwRENCLVxcdTBEQ0VcXHUwREQ1XFx1MEREN1xcdTBERTAtXFx1MERGMVxcdTBERjUtXFx1MEUwMFxcdTBFM0ItXFx1MEUzRVxcdTBFNUMtXFx1MEU4MFxcdTBFODNcXHUwRTg1XFx1MEU4NlxcdTBFODlcXHUwRThCXFx1MEU4Q1xcdTBFOEUtXFx1MEU5M1xcdTBFOThcXHUwRUEwXFx1MEVBNFxcdTBFQTZcXHUwRUE4XFx1MEVBOVxcdTBFQUNcXHUwRUJBXFx1MEVCRVxcdTBFQkZcXHUwRUM1XFx1MEVDN1xcdTBFQ0VcXHUwRUNGXFx1MEVEQVxcdTBFREJcXHUwRUUwLVxcdTBFRkZcXHUwRjQ4XFx1MEY2RC1cXHUwRjcwXFx1MEY5OFxcdTBGQkRcXHUwRkNEXFx1MEZEQi1cXHUwRkZGXFx1MTBDNlxcdTEwQzgtXFx1MTBDQ1xcdTEwQ0VcXHUxMENGXFx1MTI0OVxcdTEyNEVcXHUxMjRGXFx1MTI1N1xcdTEyNTlcXHUxMjVFXFx1MTI1RlxcdTEyODlcXHUxMjhFXFx1MTI4RlxcdTEyQjFcXHUxMkI2XFx1MTJCN1xcdTEyQkZcXHUxMkMxXFx1MTJDNlxcdTEyQzdcXHUxMkQ3XFx1MTMxMVxcdTEzMTZcXHUxMzE3XFx1MTM1QlxcdTEzNUNcXHUxMzdELVxcdTEzN0ZcXHUxMzlBLVxcdTEzOUZcXHUxM0Y1LVxcdTEzRkZcXHUxNjlELVxcdTE2OUZcXHUxNkYxLVxcdTE2RkZcXHUxNzBEXFx1MTcxNS1cXHUxNzFGXFx1MTczNy1cXHUxNzNGXFx1MTc1NC1cXHUxNzVGXFx1MTc2RFxcdTE3NzFcXHUxNzc0LVxcdTE3N0ZcXHUxN0RFXFx1MTdERlxcdTE3RUEtXFx1MTdFRlxcdTE3RkEtXFx1MTdGRlxcdTE4MEZcXHUxODFBLVxcdTE4MUZcXHUxODc4LVxcdTE4N0ZcXHUxOEFCLVxcdTE4QUZcXHUxOEY2LVxcdTE4RkZcXHUxOTFELVxcdTE5MUZcXHUxOTJDLVxcdTE5MkZcXHUxOTNDLVxcdTE5M0ZcXHUxOTQxLVxcdTE5NDNcXHUxOTZFXFx1MTk2RlxcdTE5NzUtXFx1MTk3RlxcdTE5QUMtXFx1MTlBRlxcdTE5Q0EtXFx1MTlDRlxcdTE5REItXFx1MTlERFxcdTFBMUNcXHUxQTFEXFx1MUE1RlxcdTFBN0RcXHUxQTdFXFx1MUE4QS1cXHUxQThGXFx1MUE5QS1cXHUxQTlGXFx1MUFBRS1cXHUxQUZGXFx1MUI0Qy1cXHUxQjRGXFx1MUI3RC1cXHUxQjdGXFx1MUJGNC1cXHUxQkZCXFx1MUMzOC1cXHUxQzNBXFx1MUM0QS1cXHUxQzRDXFx1MUM4MC1cXHUxQ0JGXFx1MUNDOC1cXHUxQ0NGXFx1MUNGNy1cXHUxQ0ZGXFx1MURFNy1cXHUxREZCXFx1MUYxNlxcdTFGMTdcXHUxRjFFXFx1MUYxRlxcdTFGNDZcXHUxRjQ3XFx1MUY0RVxcdTFGNEZcXHUxRjU4XFx1MUY1QVxcdTFGNUNcXHUxRjVFXFx1MUY3RVxcdTFGN0ZcXHUxRkI1XFx1MUZDNVxcdTFGRDRcXHUxRkQ1XFx1MUZEQ1xcdTFGRjBcXHUxRkYxXFx1MUZGNVxcdTFGRkZcXHUyMDBCLVxcdTIwMEZcXHUyMDJBLVxcdTIwMkVcXHUyMDYwLVxcdTIwNkZcXHUyMDcyXFx1MjA3M1xcdTIwOEZcXHUyMDlELVxcdTIwOUZcXHUyMEJBLVxcdTIwQ0ZcXHUyMEYxLVxcdTIwRkZcXHUyMThBLVxcdTIxOEZcXHUyM0Y0LVxcdTIzRkZcXHUyNDI3LVxcdTI0M0ZcXHUyNDRCLVxcdTI0NUZcXHUyNzAwXFx1MkI0RC1cXHUyQjRGXFx1MkI1QS1cXHUyQkZGXFx1MkMyRlxcdTJDNUZcXHUyQ0Y0LVxcdTJDRjhcXHUyRDI2XFx1MkQyOC1cXHUyRDJDXFx1MkQyRVxcdTJEMkZcXHUyRDY4LVxcdTJENkVcXHUyRDcxLVxcdTJEN0VcXHUyRDk3LVxcdTJEOUZcXHUyREE3XFx1MkRBRlxcdTJEQjdcXHUyREJGXFx1MkRDN1xcdTJEQ0ZcXHUyREQ3XFx1MkRERlxcdTJFM0MtXFx1MkU3RlxcdTJFOUFcXHUyRUY0LVxcdTJFRkZcXHUyRkQ2LVxcdTJGRUZcXHUyRkZDLVxcdTJGRkZcXHUzMDQwXFx1MzA5N1xcdTMwOThcXHUzMTAwLVxcdTMxMDRcXHUzMTJFLVxcdTMxMzBcXHUzMThGXFx1MzFCQi1cXHUzMUJGXFx1MzFFNC1cXHUzMUVGXFx1MzIxRlxcdTMyRkZcXHU0REI2LVxcdTREQkZcXHU5RkNELVxcdTlGRkZcXHVBNDhELVxcdUE0OEZcXHVBNEM3LVxcdUE0Q0ZcXHVBNjJDLVxcdUE2M0ZcXHVBNjk4LVxcdUE2OUVcXHVBNkY4LVxcdUE2RkZcXHVBNzhGXFx1QTc5NC1cXHVBNzlGXFx1QTdBQi1cXHVBN0Y3XFx1QTgyQy1cXHVBODJGXFx1QTgzQS1cXHVBODNGXFx1QTg3OC1cXHVBODdGXFx1QThDNS1cXHVBOENEXFx1QThEQS1cXHVBOERGXFx1QThGQy1cXHVBOEZGXFx1QTk1NC1cXHVBOTVFXFx1QTk3RC1cXHVBOTdGXFx1QTlDRVxcdUE5REEtXFx1QTlERFxcdUE5RTAtXFx1QTlGRlxcdUFBMzctXFx1QUEzRlxcdUFBNEVcXHVBQTRGXFx1QUE1QVxcdUFBNUJcXHVBQTdDLVxcdUFBN0ZcXHVBQUMzLVxcdUFBREFcXHVBQUY3LVxcdUFCMDBcXHVBQjA3XFx1QUIwOFxcdUFCMEZcXHVBQjEwXFx1QUIxNy1cXHVBQjFGXFx1QUIyN1xcdUFCMkYtXFx1QUJCRlxcdUFCRUVcXHVBQkVGXFx1QUJGQS1cXHVBQkZGXFx1RDdBNC1cXHVEN0FGXFx1RDdDNy1cXHVEN0NBXFx1RDdGQy1cXHVGOEZGXFx1RkE2RVxcdUZBNkZcXHVGQURBLVxcdUZBRkZcXHVGQjA3LVxcdUZCMTJcXHVGQjE4LVxcdUZCMUNcXHVGQjM3XFx1RkIzRFxcdUZCM0ZcXHVGQjQyXFx1RkI0NVxcdUZCQzItXFx1RkJEMlxcdUZENDAtXFx1RkQ0RlxcdUZEOTBcXHVGRDkxXFx1RkRDOC1cXHVGREVGXFx1RkRGRVxcdUZERkZcXHVGRTFBLVxcdUZFMUZcXHVGRTI3LVxcdUZFMkZcXHVGRTUzXFx1RkU2N1xcdUZFNkMtXFx1RkU2RlxcdUZFNzVcXHVGRUZELVxcdUZGMDBcXHVGRkJGLVxcdUZGQzFcXHVGRkM4XFx1RkZDOVxcdUZGRDBcXHVGRkQxXFx1RkZEOFxcdUZGRDlcXHVGRkRELVxcdUZGREZcXHVGRkU3XFx1RkZFRi1cXHVGRkZCXFx1RkZGRVxcdUZGRkZdLzsgLy8gT3RoZXIgKGNvbnRyb2wsIGZvcm1hdCwgcHJpdmF0ZSB1c2UsIHN1cnJvZ2F0ZSwgYW5kIHVuYXNzaWduZWQgY29kZXMpXG5cbiAgICB2YXIgdW5pY29kZVBhY2thZ2VOYW1lc01hcHBpbmcgPSB7XG4gICAgICAgIEw6IHVuaWNvZGVSZWdFeHAubGV0dGVyLFxuICAgICAgICBNOiB1bmljb2RlUmVnRXhwLm1hcmssXG4gICAgICAgIE46IHVuaWNvZGVSZWdFeHAubnVtYmVyLFxuICAgICAgICBQOiB1bmljb2RlUmVnRXhwLnB1bmN0dWF0aW9uLFxuICAgICAgICBTOiB1bmljb2RlUmVnRXhwLnN5bWJvbCxcbiAgICAgICAgWjogdW5pY29kZVJlZ0V4cC5zZXBhcmF0b3IsXG4gICAgICAgIEM6IHVuaWNvZGVSZWdFeHAub3RoZXIsXG4gICAgICAgIGxldHRlcjogdW5pY29kZVJlZ0V4cC5sZXR0ZXIsXG4gICAgICAgIG1hcms6IHVuaWNvZGVSZWdFeHAubWFyayxcbiAgICAgICAgbnVtYmVyOiB1bmljb2RlUmVnRXhwLm51bWJlcixcbiAgICAgICAgZGlnaXQ6IHVuaWNvZGVSZWdFeHAubnVtYmVyLFxuICAgICAgICBwdW5jdHVhdGlvbjogdW5pY29kZVJlZ0V4cC5wdW5jdHVhdGlvbixcbiAgICAgICAgc3ltYm9sOiB1bmljb2RlUmVnRXhwLnN5bWJvbCxcbiAgICAgICAgc2VwYXJhdG9yOiB1bmljb2RlUmVnRXhwLnNlcGFyYXRvcixcbiAgICAgICAgb3RoZXI6IHVuaWNvZGVSZWdFeHAub3RoZXJcbiAgICB9O1xuXG4gICAgdW5pY29kZVJlZ0V4cC51bmljb2RlUGFja2FnZU5hbWVSZWdFeHAgPSBuZXcgUmVnRXhwKCdeXFxcXFtcXFxcOihcXFxcXik/KCcgKyBPYmplY3Qua2V5cyh1bmljb2RlUGFja2FnZU5hbWVzTWFwcGluZykuam9pbignfCcpICsgJylcXFxcOlxcXFxdJCcpO1xuXG4gICAgdW5pY29kZVJlZ0V4cC5leHBhbmRDbGRyVW5pY29kZVNldElkVG9DaGFyYWN0ZXJDbGFzcyA9IGZ1bmN0aW9uICh1bmljb2RlU2V0SWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5pY29kZVNldElkLnJlcGxhY2UodW5pY29kZVJlZ0V4cC51bmljb2RlUGFja2FnZU5hbWVSZWdFeHAsIGZ1bmN0aW9uICgkMCwgbmVnYXRlZCwgcGFja2FnZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBjaGFyYWN0ZXJzID0gdW5pY29kZVBhY2thZ2VOYW1lc01hcHBpbmdbcGFja2FnZU5hbWVdLnNvdXJjZS5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICAgICAgcmV0dXJuICdbJyArIChuZWdhdGVkID8gJ14nICsgY2hhcmFjdGVycyA6IGNoYXJhY3RlcnMpICsgJ10nO1xuICAgICAgICB9KSk7XG4gICAgfTtcblxuICAgIHVuaWNvZGVSZWdFeHAuc3BsaWNlQ2hhcmFjdGVyQ2xhc3NSZWdFeHBzID0gZnVuY3Rpb24gKCkgeyAvLyAuLi5cbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKCdbJyArIGFyZ3MubWFwKGZ1bmN0aW9uIChyZWdFeHApIHtcbiAgICAgICAgICAgIHJldHVybiByZWdFeHAuc291cmNlLnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgICAgIH0pLmpvaW4oXCJcIikgKyAnXScpO1xuICAgIH07XG5cbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGNvbWJpbmVkLCBleGNlcHQgJ3NlcGFyYXRvcicsIGFuZCAnb3RoZXInOlxuICAgIHVuaWNvZGVSZWdFeHAudmlzaWJsZSA9IHVuaWNvZGVSZWdFeHAuc3BsaWNlQ2hhcmFjdGVyQ2xhc3NSZWdFeHBzKFxuICAgICAgICB1bmljb2RlUmVnRXhwLmxldHRlcixcbiAgICAgICAgdW5pY29kZVJlZ0V4cC5tYXJrLFxuICAgICAgICB1bmljb2RlUmVnRXhwLm51bWJlcixcbiAgICAgICAgdW5pY29kZVJlZ0V4cC5wdW5jdHVhdGlvbixcbiAgICAgICAgdW5pY29kZVJlZ0V4cC5zeW1ib2xcbiAgICApO1xuXG4gICAgLy8gVGhlIHNldCBvZiBwcmludGFibGUgY2hhcmFjdGVycyBhbHNvIGluY2x1ZGVzIHNwYWNlOlxuICAgIHVuaWNvZGVSZWdFeHAucHJpbnRhYmxlID0gdW5pY29kZVJlZ0V4cC5zcGxpY2VDaGFyYWN0ZXJDbGFzc1JlZ0V4cHMoXG4gICAgICAgIHVuaWNvZGVSZWdFeHAudmlzaWJsZSxcbiAgICAgICAgdW5pY29kZVJlZ0V4cC5zZXBhcmF0b3JcbiAgICApO1xuXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIGZvciByZW1vdmluZyBhIGNoYXIgZnJvbSBhIGNoYXJhY3RlciBjbGFzcyByZWd1bGFyIGV4cHJlc3Npb246XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNoYXJDb2RlKHU0LCB4MiwgbGl0ZXJhbCkge1xuICAgICAgICBpZiAodTQgfHwgeDIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh1NCB8fCB4MiwgMTYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWwuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoYXJDb2RlVG9SZWdFeHBUb2tlbihjaGFyQ29kZSkge1xuICAgICAgICBpZiAoY2hhckNvZGUgPj0gMHgyMCAmJiBjaGFyQ29kZSA8IDB4N2YpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBoZXhTdHIgPSBjaGFyQ29kZS50b1N0cmluZygxNik7XG4gICAgICAgICAgICByZXR1cm4gXCJcXFxcdVwiICsgXCIwMDAwXCIuc2xpY2UoaGV4U3RyLmxlbmd0aCkgKyBoZXhTdHI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhcmFjdGVyQ2xhc3NUb2tlbiA9IC8oPzpcXFxcdShbMC05YS1mXXs0fSl8XFxcXHgoWzAtOWEtZl17Mn0pfChbXlxcLV0pKSg/Oi0oPzpcXFxcdShbMC05YS1mXXs0fSl8XFxcXHgoWzAtOWEtZl17Mn0pfChbXlxcLV0pKSk/L2dpO1xuXG4gICAgdW5pY29kZVJlZ0V4cC5yZW1vdmVDaGFyYWN0ZXJGcm9tQ2hhcmFjdGVyQ2xhc3NSZWdFeHAgPSBmdW5jdGlvbiAocmVnRXhwLCBjaCkge1xuICAgICAgICB2YXIgY2hhckNvZGUgPSBjaC5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKCdbJyArIHJlZ0V4cC5zb3VyY2UucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKS5yZXBsYWNlKGNoYXJhY3RlckNsYXNzVG9rZW4sIGZ1bmN0aW9uICgkMCwgZnJvbVU0LCBmcm9tWDIsIGZyb21MaXRlcmFsLCB0b1U0LCB0b1gyLCB0b0xpdGVyYWwpIHtcbiAgICAgICAgICAgIHZhciBmcm9tQ2hhckNvZGUgPSBwYXJzZUNoYXJDb2RlKGZyb21VNCwgZnJvbVgyLCBmcm9tTGl0ZXJhbCk7XG4gICAgICAgICAgICBpZiAodG9VNCB8fCB0b1gyIHx8IHRvTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIHZhciB0b0NoYXJDb2RlID0gcGFyc2VDaGFyQ29kZSh0b1U0LCB0b1gyLCB0b0xpdGVyYWwpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PT0gZnJvbUNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSArIDEgPCB0b0NoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhckNvZGVUb1JlZ0V4cFRva2VuKGNoYXJDb2RlICsgMSkgKyAnLScgKyBjaGFyQ29kZVRvUmVnRXhwVG9rZW4odG9DaGFyQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhckNvZGVUb1JlZ0V4cFRva2VuKHRvQ2hhckNvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PT0gdG9DaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbUNoYXJDb2RlIDwgY2hhckNvZGUgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhckNvZGVUb1JlZ0V4cFRva2VuKGZyb21DaGFyQ29kZSkgKyAnLScgKyBjaGFyQ29kZVRvUmVnRXhwVG9rZW4oY2hhckNvZGUgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZyb21DaGFyQ29kZSA9PT0gdG9DaGFyQ29kZSAtIDEsIHJld3JpdGUgdG8gc2luZ2xlIGNoYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFyQ29kZVRvUmVnRXhwVG9rZW4oZnJvbUNoYXJDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPiBmcm9tQ2hhckNvZGUgJiYgY2hhckNvZGUgPCB0b0NoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFyQ29kZVRvUmVnRXhwVG9rZW4oZnJvbUNoYXJDb2RlKSArIChjaGFyQ29kZSA+IGZyb21DaGFyQ29kZSArIDEgPyAnLScgKyBjaGFyQ29kZVRvUmVnRXhwVG9rZW4oY2hhckNvZGUgLSAxKSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2hhckNvZGUgKyAxIDwgdG9DaGFyQ29kZSA/IGNoYXJDb2RlVG9SZWdFeHBUb2tlbihjaGFyQ29kZSArIDEpICsgJy0nIDogJycpICsgY2hhckNvZGVUb1JlZ0V4cFRva2VuKHRvQ2hhckNvZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PT0gZnJvbUNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFyQ29kZVRvUmVnRXhwVG9rZW4oZnJvbUNoYXJDb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pICsgJ10nKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHVuaWNvZGVSZWdFeHA7XG59KSk7XG4iLCJmdW5jdGlvbiBET01QYXJzZXIob3B0aW9ucyl7XHJcblx0dGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fHtsb2NhdG9yOnt9fTtcclxuXHRcclxufVxyXG5ET01QYXJzZXIucHJvdG90eXBlLnBhcnNlRnJvbVN0cmluZyA9IGZ1bmN0aW9uKHNvdXJjZSxtaW1lVHlwZSl7XHRcclxuXHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHR2YXIgc2F4ID0gIG5ldyBYTUxSZWFkZXIoKTtcclxuXHR2YXIgZG9tQnVpbGRlciA9IG9wdGlvbnMuZG9tQnVpbGRlciB8fCBuZXcgRE9NSGFuZGxlcigpOy8vY29udGVudEhhbmRsZXIgYW5kIExleGljYWxIYW5kbGVyXHJcblx0dmFyIGVycm9ySGFuZGxlciA9IG9wdGlvbnMuZXJyb3JIYW5kbGVyO1xyXG5cdHZhciBsb2NhdG9yID0gb3B0aW9ucy5sb2NhdG9yO1xyXG5cdHZhciBkZWZhdWx0TlNNYXAgPSBvcHRpb25zLnhtbG5zfHx7fTtcclxuXHR2YXIgZW50aXR5TWFwID0geydsdCc6JzwnLCdndCc6Jz4nLCdhbXAnOicmJywncXVvdCc6J1wiJywnYXBvcyc6XCInXCJ9XHJcblx0aWYobG9jYXRvcil7XHJcblx0XHRkb21CdWlsZGVyLnNldERvY3VtZW50TG9jYXRvcihsb2NhdG9yKVxyXG5cdH1cclxuXHRcclxuXHRzYXguZXJyb3JIYW5kbGVyID0gYnVpbGRFcnJvckhhbmRsZXIoZXJyb3JIYW5kbGVyLGRvbUJ1aWxkZXIsbG9jYXRvcik7XHJcblx0c2F4LmRvbUJ1aWxkZXIgPSBvcHRpb25zLmRvbUJ1aWxkZXIgfHwgZG9tQnVpbGRlcjtcclxuXHRpZigvXFwveD9odG1sPyQvLnRlc3QobWltZVR5cGUpKXtcclxuXHRcdGVudGl0eU1hcC5uYnNwID0gJ1xceGEwJztcclxuXHRcdGVudGl0eU1hcC5jb3B5ID0gJ1xceGE5JztcclxuXHRcdGRlZmF1bHROU01hcFsnJ109ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcclxuXHR9XHJcblx0aWYoc291cmNlKXtcclxuXHRcdHNheC5wYXJzZShzb3VyY2UsZGVmYXVsdE5TTWFwLGVudGl0eU1hcCk7XHJcblx0fWVsc2V7XHJcblx0XHRzYXguZXJyb3JIYW5kbGVyLmVycm9yKFwiaW52YWxpZCBkb2N1bWVudCBzb3VyY2VcIik7XHJcblx0fVxyXG5cdHJldHVybiBkb21CdWlsZGVyLmRvY3VtZW50O1xyXG59XHJcbmZ1bmN0aW9uIGJ1aWxkRXJyb3JIYW5kbGVyKGVycm9ySW1wbCxkb21CdWlsZGVyLGxvY2F0b3Ipe1xyXG5cdGlmKCFlcnJvckltcGwpe1xyXG5cdFx0aWYoZG9tQnVpbGRlciBpbnN0YW5jZW9mIERPTUhhbmRsZXIpe1xyXG5cdFx0XHRyZXR1cm4gZG9tQnVpbGRlcjtcclxuXHRcdH1cclxuXHRcdGVycm9ySW1wbCA9IGRvbUJ1aWxkZXIgO1xyXG5cdH1cclxuXHR2YXIgZXJyb3JIYW5kbGVyID0ge31cclxuXHR2YXIgaXNDYWxsYmFjayA9IGVycm9ySW1wbCBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xyXG5cdGxvY2F0b3IgPSBsb2NhdG9yfHx7fVxyXG5cdGZ1bmN0aW9uIGJ1aWxkKGtleSl7XHJcblx0XHR2YXIgZm4gPSBlcnJvckltcGxba2V5XTtcclxuXHRcdGlmKCFmbil7XHJcblx0XHRcdGlmKGlzQ2FsbGJhY2spe1xyXG5cdFx0XHRcdGZuID0gZXJyb3JJbXBsLmxlbmd0aCA9PSAyP2Z1bmN0aW9uKG1zZyl7ZXJyb3JJbXBsKGtleSxtc2cpfTplcnJvckltcGw7XHJcblx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdHZhciBpPWFyZ3VtZW50cy5sZW5ndGg7XHJcblx0XHRcdFx0d2hpbGUoLS1pKXtcclxuXHRcdFx0XHRcdGlmKGZuID0gZXJyb3JJbXBsW2FyZ3VtZW50c1tpXV0pe1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGVycm9ySGFuZGxlcltrZXldID0gZm4gJiYgZnVuY3Rpb24obXNnKXtcclxuXHRcdFx0Zm4obXNnK19sb2NhdG9yKGxvY2F0b3IpKTtcclxuXHRcdH18fGZ1bmN0aW9uKCl7fTtcclxuXHR9XHJcblx0YnVpbGQoJ3dhcm5pbmcnLCd3YXJuJyk7XHJcblx0YnVpbGQoJ2Vycm9yJywnd2FybicsJ3dhcm5pbmcnKTtcclxuXHRidWlsZCgnZmF0YWxFcnJvcicsJ3dhcm4nLCd3YXJuaW5nJywnZXJyb3InKTtcclxuXHRyZXR1cm4gZXJyb3JIYW5kbGVyO1xyXG59XHJcbi8qKlxyXG4gKiArQ29udGVudEhhbmRsZXIrRXJyb3JIYW5kbGVyXHJcbiAqICtMZXhpY2FsSGFuZGxlcitFbnRpdHlSZXNvbHZlcjJcclxuICogLURlY2xIYW5kbGVyLURUREhhbmRsZXIgXHJcbiAqIFxyXG4gKiBEZWZhdWx0SGFuZGxlcjpFbnRpdHlSZXNvbHZlciwgRFRESGFuZGxlciwgQ29udGVudEhhbmRsZXIsIEVycm9ySGFuZGxlclxyXG4gKiBEZWZhdWx0SGFuZGxlcjI6RGVmYXVsdEhhbmRsZXIsTGV4aWNhbEhhbmRsZXIsIERlY2xIYW5kbGVyLCBFbnRpdHlSZXNvbHZlcjJcclxuICogQGxpbmsgaHR0cDovL3d3dy5zYXhwcm9qZWN0Lm9yZy9hcGlkb2Mvb3JnL3htbC9zYXgvaGVscGVycy9EZWZhdWx0SGFuZGxlci5odG1sXHJcbiAqL1xyXG5mdW5jdGlvbiBET01IYW5kbGVyKCkge1xyXG4gICAgdGhpcy5jZGF0YSA9IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIHBvc2l0aW9uKGxvY2F0b3Isbm9kZSl7XHJcblx0bm9kZS5saW5lTnVtYmVyID0gbG9jYXRvci5saW5lTnVtYmVyO1xyXG5cdG5vZGUuY29sdW1uTnVtYmVyID0gbG9jYXRvci5jb2x1bW5OdW1iZXI7XHJcbn1cclxuLyoqXHJcbiAqIEBzZWUgb3JnLnhtbC5zYXguQ29udGVudEhhbmRsZXIjc3RhcnREb2N1bWVudFxyXG4gKiBAbGluayBodHRwOi8vd3d3LnNheHByb2plY3Qub3JnL2FwaWRvYy9vcmcveG1sL3NheC9Db250ZW50SGFuZGxlci5odG1sXHJcbiAqLyBcclxuRE9NSGFuZGxlci5wcm90b3R5cGUgPSB7XHJcblx0c3RhcnREb2N1bWVudCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgXHR0aGlzLmRvY3VtZW50ID0gbmV3IERPTUltcGxlbWVudGF0aW9uKCkuY3JlYXRlRG9jdW1lbnQobnVsbCwgbnVsbCwgbnVsbCk7XHJcbiAgICBcdGlmICh0aGlzLmxvY2F0b3IpIHtcclxuICAgICAgICBcdHRoaXMuZG9jdW1lbnQuZG9jdW1lbnRVUkkgPSB0aGlzLmxvY2F0b3Iuc3lzdGVtSWQ7XHJcbiAgICBcdH1cclxuXHR9LFxyXG5cdHN0YXJ0RWxlbWVudDpmdW5jdGlvbihuYW1lc3BhY2VVUkksIGxvY2FsTmFtZSwgcU5hbWUsIGF0dHJzKSB7XHJcblx0XHR2YXIgZG9jID0gdGhpcy5kb2N1bWVudDtcclxuXHQgICAgdmFyIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHFOYW1lfHxsb2NhbE5hbWUpO1xyXG5cdCAgICB2YXIgbGVuID0gYXR0cnMubGVuZ3RoO1xyXG5cdCAgICBhcHBlbmRFbGVtZW50KHRoaXMsIGVsKTtcclxuXHQgICAgdGhpcy5jdXJyZW50RWxlbWVudCA9IGVsO1xyXG5cdCAgICBcclxuXHRcdHRoaXMubG9jYXRvciAmJiBwb3NpdGlvbih0aGlzLmxvY2F0b3IsZWwpXHJcblx0ICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0ICAgICAgICB2YXIgbmFtZXNwYWNlVVJJID0gYXR0cnMuZ2V0VVJJKGkpO1xyXG5cdCAgICAgICAgdmFyIHZhbHVlID0gYXR0cnMuZ2V0VmFsdWUoaSk7XHJcblx0ICAgICAgICB2YXIgcU5hbWUgPSBhdHRycy5nZXRRTmFtZShpKTtcclxuXHRcdFx0dmFyIGF0dHIgPSBkb2MuY3JlYXRlQXR0cmlidXRlTlMobmFtZXNwYWNlVVJJLCBxTmFtZSk7XHJcblx0XHRcdGlmKCBhdHRyLmdldE9mZnNldCl7XHJcblx0XHRcdFx0cG9zaXRpb24oYXR0ci5nZXRPZmZzZXQoMSksYXR0cilcclxuXHRcdFx0fVxyXG5cdFx0XHRhdHRyLnZhbHVlID0gYXR0ci5ub2RlVmFsdWUgPSB2YWx1ZTtcclxuXHRcdFx0ZWwuc2V0QXR0cmlidXRlTm9kZShhdHRyKVxyXG5cdCAgICB9XHJcblx0fSxcclxuXHRlbmRFbGVtZW50OmZ1bmN0aW9uKG5hbWVzcGFjZVVSSSwgbG9jYWxOYW1lLCBxTmFtZSkge1xyXG5cdFx0dmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnRFbGVtZW50XHJcblx0ICAgIHZhciB0YWdOYW1lID0gY3VycmVudC50YWdOYW1lO1xyXG5cdCAgICB0aGlzLmN1cnJlbnRFbGVtZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xyXG5cdH0sXHJcblx0c3RhcnRQcmVmaXhNYXBwaW5nOmZ1bmN0aW9uKHByZWZpeCwgdXJpKSB7XHJcblx0fSxcclxuXHRlbmRQcmVmaXhNYXBwaW5nOmZ1bmN0aW9uKHByZWZpeCkge1xyXG5cdH0sXHJcblx0cHJvY2Vzc2luZ0luc3RydWN0aW9uOmZ1bmN0aW9uKHRhcmdldCwgZGF0YSkge1xyXG5cdCAgICB2YXIgaW5zID0gdGhpcy5kb2N1bWVudC5jcmVhdGVQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24odGFyZ2V0LCBkYXRhKTtcclxuXHQgICAgdGhpcy5sb2NhdG9yICYmIHBvc2l0aW9uKHRoaXMubG9jYXRvcixpbnMpXHJcblx0ICAgIGFwcGVuZEVsZW1lbnQodGhpcywgaW5zKTtcclxuXHR9LFxyXG5cdGlnbm9yYWJsZVdoaXRlc3BhY2U6ZnVuY3Rpb24oY2gsIHN0YXJ0LCBsZW5ndGgpIHtcclxuXHR9LFxyXG5cdGNoYXJhY3RlcnM6ZnVuY3Rpb24oY2hhcnMsIHN0YXJ0LCBsZW5ndGgpIHtcclxuXHRcdGNoYXJzID0gX3RvU3RyaW5nLmFwcGx5KHRoaXMsYXJndW1lbnRzKVxyXG5cdFx0Ly9jb25zb2xlLmxvZyhjaGFycylcclxuXHRcdGlmKHRoaXMuY3VycmVudEVsZW1lbnQgJiYgY2hhcnMpe1xyXG5cdFx0XHRpZiAodGhpcy5jZGF0YSkge1xyXG5cdFx0XHRcdHZhciBjaGFyTm9kZSA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlQ0RBVEFTZWN0aW9uKGNoYXJzKTtcclxuXHRcdFx0XHR0aGlzLmN1cnJlbnRFbGVtZW50LmFwcGVuZENoaWxkKGNoYXJOb2RlKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgY2hhck5vZGUgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoYXJzKTtcclxuXHRcdFx0XHR0aGlzLmN1cnJlbnRFbGVtZW50LmFwcGVuZENoaWxkKGNoYXJOb2RlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLmxvY2F0b3IgJiYgcG9zaXRpb24odGhpcy5sb2NhdG9yLGNoYXJOb2RlKVxyXG5cdFx0fVxyXG5cdH0sXHJcblx0c2tpcHBlZEVudGl0eTpmdW5jdGlvbihuYW1lKSB7XHJcblx0fSxcclxuXHRlbmREb2N1bWVudDpmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMuZG9jdW1lbnQubm9ybWFsaXplKCk7XHJcblx0fSxcclxuXHRzZXREb2N1bWVudExvY2F0b3I6ZnVuY3Rpb24gKGxvY2F0b3IpIHtcclxuXHQgICAgaWYodGhpcy5sb2NhdG9yID0gbG9jYXRvcil7Ly8gJiYgISgnbGluZU51bWJlcicgaW4gbG9jYXRvcikpe1xyXG5cdCAgICBcdGxvY2F0b3IubGluZU51bWJlciA9IDA7XHJcblx0ICAgIH1cclxuXHR9LFxyXG5cdC8vTGV4aWNhbEhhbmRsZXJcclxuXHRjb21tZW50OmZ1bmN0aW9uKGNoYXJzLCBzdGFydCwgbGVuZ3RoKSB7XHJcblx0XHRjaGFycyA9IF90b1N0cmluZy5hcHBseSh0aGlzLGFyZ3VtZW50cylcclxuXHQgICAgdmFyIGNvbW0gPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY2hhcnMpO1xyXG5cdCAgICB0aGlzLmxvY2F0b3IgJiYgcG9zaXRpb24odGhpcy5sb2NhdG9yLGNvbW0pXHJcblx0ICAgIGFwcGVuZEVsZW1lbnQodGhpcywgY29tbSk7XHJcblx0fSxcclxuXHRcclxuXHRzdGFydENEQVRBOmZ1bmN0aW9uKCkge1xyXG5cdCAgICAvL3VzZWQgaW4gY2hhcmFjdGVycygpIG1ldGhvZHNcclxuXHQgICAgdGhpcy5jZGF0YSA9IHRydWU7XHJcblx0fSxcclxuXHRlbmRDREFUQTpmdW5jdGlvbigpIHtcclxuXHQgICAgdGhpcy5jZGF0YSA9IGZhbHNlO1xyXG5cdH0sXHJcblx0XHJcblx0c3RhcnREVEQ6ZnVuY3Rpb24obmFtZSwgcHVibGljSWQsIHN5c3RlbUlkKSB7XHJcblx0XHR2YXIgaW1wbCA9IHRoaXMuZG9jdW1lbnQuaW1wbGVtZW50YXRpb247XHJcblx0ICAgIGlmIChpbXBsICYmIGltcGwuY3JlYXRlRG9jdW1lbnRUeXBlKSB7XHJcblx0ICAgICAgICB2YXIgZHQgPSBpbXBsLmNyZWF0ZURvY3VtZW50VHlwZShuYW1lLCBwdWJsaWNJZCwgc3lzdGVtSWQpO1xyXG5cdCAgICAgICAgdGhpcy5sb2NhdG9yICYmIHBvc2l0aW9uKHRoaXMubG9jYXRvcixkdClcclxuXHQgICAgICAgIGFwcGVuZEVsZW1lbnQodGhpcywgZHQpO1xyXG5cdCAgICB9XHJcblx0fSxcclxuXHQvKipcclxuXHQgKiBAc2VlIG9yZy54bWwuc2F4LkVycm9ySGFuZGxlclxyXG5cdCAqIEBsaW5rIGh0dHA6Ly93d3cuc2F4cHJvamVjdC5vcmcvYXBpZG9jL29yZy94bWwvc2F4L0Vycm9ySGFuZGxlci5odG1sXHJcblx0ICovXHJcblx0d2FybmluZzpmdW5jdGlvbihlcnJvcikge1xyXG5cdFx0Y29uc29sZS53YXJuKGVycm9yLF9sb2NhdG9yKHRoaXMubG9jYXRvcikpO1xyXG5cdH0sXHJcblx0ZXJyb3I6ZnVuY3Rpb24oZXJyb3IpIHtcclxuXHRcdGNvbnNvbGUuZXJyb3IoZXJyb3IsX2xvY2F0b3IodGhpcy5sb2NhdG9yKSk7XHJcblx0fSxcclxuXHRmYXRhbEVycm9yOmZ1bmN0aW9uKGVycm9yKSB7XHJcblx0XHRjb25zb2xlLmVycm9yKGVycm9yLF9sb2NhdG9yKHRoaXMubG9jYXRvcikpO1xyXG5cdCAgICB0aHJvdyBlcnJvcjtcclxuXHR9XHJcbn1cclxuZnVuY3Rpb24gX2xvY2F0b3IobCl7XHJcblx0aWYobCl7XHJcblx0XHRyZXR1cm4gJ1xcbkAnKyhsLnN5c3RlbUlkIHx8JycpKycjW2xpbmU6JytsLmxpbmVOdW1iZXIrJyxjb2w6JytsLmNvbHVtbk51bWJlcisnXSdcclxuXHR9XHJcbn1cclxuZnVuY3Rpb24gX3RvU3RyaW5nKGNoYXJzLHN0YXJ0LGxlbmd0aCl7XHJcblx0aWYodHlwZW9mIGNoYXJzID09ICdzdHJpbmcnKXtcclxuXHRcdHJldHVybiBjaGFycy5zdWJzdHIoc3RhcnQsbGVuZ3RoKVxyXG5cdH1lbHNley8vamF2YSBzYXggY29ubmVjdCB3aWR0aCB4bWxkb20gb24gcmhpbm8od2hhdCBhYm91dDogXCI/ICYmICEoY2hhcnMgaW5zdGFuY2VvZiBTdHJpbmcpXCIpXHJcblx0XHRpZihjaGFycy5sZW5ndGggPj0gc3RhcnQrbGVuZ3RoIHx8IHN0YXJ0KXtcclxuXHRcdFx0cmV0dXJuIG5ldyBqYXZhLmxhbmcuU3RyaW5nKGNoYXJzLHN0YXJ0LGxlbmd0aCkrJyc7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY2hhcnM7XHJcblx0fVxyXG59XHJcblxyXG4vKlxyXG4gKiBAbGluayBodHRwOi8vd3d3LnNheHByb2plY3Qub3JnL2FwaWRvYy9vcmcveG1sL3NheC9leHQvTGV4aWNhbEhhbmRsZXIuaHRtbFxyXG4gKiB1c2VkIG1ldGhvZCBvZiBvcmcueG1sLnNheC5leHQuTGV4aWNhbEhhbmRsZXI6XHJcbiAqICAjY29tbWVudChjaGFycywgc3RhcnQsIGxlbmd0aClcclxuICogICNzdGFydENEQVRBKClcclxuICogICNlbmRDREFUQSgpXHJcbiAqICAjc3RhcnREVEQobmFtZSwgcHVibGljSWQsIHN5c3RlbUlkKVxyXG4gKlxyXG4gKlxyXG4gKiBJR05PUkVEIG1ldGhvZCBvZiBvcmcueG1sLnNheC5leHQuTGV4aWNhbEhhbmRsZXI6XHJcbiAqICAjZW5kRFREKClcclxuICogICNzdGFydEVudGl0eShuYW1lKVxyXG4gKiAgI2VuZEVudGl0eShuYW1lKVxyXG4gKlxyXG4gKlxyXG4gKiBAbGluayBodHRwOi8vd3d3LnNheHByb2plY3Qub3JnL2FwaWRvYy9vcmcveG1sL3NheC9leHQvRGVjbEhhbmRsZXIuaHRtbFxyXG4gKiBJR05PUkVEIG1ldGhvZCBvZiBvcmcueG1sLnNheC5leHQuRGVjbEhhbmRsZXJcclxuICogXHQjYXR0cmlidXRlRGVjbChlTmFtZSwgYU5hbWUsIHR5cGUsIG1vZGUsIHZhbHVlKVxyXG4gKiAgI2VsZW1lbnREZWNsKG5hbWUsIG1vZGVsKVxyXG4gKiAgI2V4dGVybmFsRW50aXR5RGVjbChuYW1lLCBwdWJsaWNJZCwgc3lzdGVtSWQpXHJcbiAqICAjaW50ZXJuYWxFbnRpdHlEZWNsKG5hbWUsIHZhbHVlKVxyXG4gKiBAbGluayBodHRwOi8vd3d3LnNheHByb2plY3Qub3JnL2FwaWRvYy9vcmcveG1sL3NheC9leHQvRW50aXR5UmVzb2x2ZXIyLmh0bWxcclxuICogSUdOT1JFRCBtZXRob2Qgb2Ygb3JnLnhtbC5zYXguRW50aXR5UmVzb2x2ZXIyXHJcbiAqICAjcmVzb2x2ZUVudGl0eShTdHJpbmcgbmFtZSxTdHJpbmcgcHVibGljSWQsU3RyaW5nIGJhc2VVUkksU3RyaW5nIHN5c3RlbUlkKVxyXG4gKiAgI3Jlc29sdmVFbnRpdHkocHVibGljSWQsIHN5c3RlbUlkKVxyXG4gKiAgI2dldEV4dGVybmFsU3Vic2V0KG5hbWUsIGJhc2VVUkkpXHJcbiAqIEBsaW5rIGh0dHA6Ly93d3cuc2F4cHJvamVjdC5vcmcvYXBpZG9jL29yZy94bWwvc2F4L0RUREhhbmRsZXIuaHRtbFxyXG4gKiBJR05PUkVEIG1ldGhvZCBvZiBvcmcueG1sLnNheC5EVERIYW5kbGVyXHJcbiAqICAjbm90YXRpb25EZWNsKG5hbWUsIHB1YmxpY0lkLCBzeXN0ZW1JZCkge307XHJcbiAqICAjdW5wYXJzZWRFbnRpdHlEZWNsKG5hbWUsIHB1YmxpY0lkLCBzeXN0ZW1JZCwgbm90YXRpb25OYW1lKSB7fTtcclxuICovXHJcblwiZW5kRFRELHN0YXJ0RW50aXR5LGVuZEVudGl0eSxhdHRyaWJ1dGVEZWNsLGVsZW1lbnREZWNsLGV4dGVybmFsRW50aXR5RGVjbCxpbnRlcm5hbEVudGl0eURlY2wscmVzb2x2ZUVudGl0eSxnZXRFeHRlcm5hbFN1YnNldCxub3RhdGlvbkRlY2wsdW5wYXJzZWRFbnRpdHlEZWNsXCIucmVwbGFjZSgvXFx3Ky9nLGZ1bmN0aW9uKGtleSl7XHJcblx0RE9NSGFuZGxlci5wcm90b3R5cGVba2V5XSA9IGZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9XHJcbn0pXHJcblxyXG4vKiBQcml2YXRlIHN0YXRpYyBoZWxwZXJzIHRyZWF0ZWQgYmVsb3cgYXMgcHJpdmF0ZSBpbnN0YW5jZSBtZXRob2RzLCBzbyBkb24ndCBuZWVkIHRvIGFkZCB0aGVzZSB0byB0aGUgcHVibGljIEFQSTsgd2UgbWlnaHQgdXNlIGEgUmVsYXRvciB0byBhbHNvIGdldCByaWQgb2Ygbm9uLXN0YW5kYXJkIHB1YmxpYyBwcm9wZXJ0aWVzICovXHJcbmZ1bmN0aW9uIGFwcGVuZEVsZW1lbnQgKGhhbmRlcixub2RlKSB7XHJcbiAgICBpZiAoIWhhbmRlci5jdXJyZW50RWxlbWVudCkge1xyXG4gICAgICAgIGhhbmRlci5kb2N1bWVudC5hcHBlbmRDaGlsZChub2RlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaGFuZGVyLmN1cnJlbnRFbGVtZW50LmFwcGVuZENoaWxkKG5vZGUpO1xyXG4gICAgfVxyXG59Ly9hcHBlbmRDaGlsZCBhbmQgc2V0QXR0cmlidXRlTlMgYXJlIHByZWZvcm1hbmNlIGtleVxyXG5cclxuaWYodHlwZW9mIHJlcXVpcmUgPT0gJ2Z1bmN0aW9uJyl7XHJcblx0dmFyIFhNTFJlYWRlciA9IHJlcXVpcmUoJy4vc2F4JykuWE1MUmVhZGVyO1xyXG5cdHZhciBET01JbXBsZW1lbnRhdGlvbiA9IGV4cG9ydHMuRE9NSW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2RvbScpLkRPTUltcGxlbWVudGF0aW9uO1xyXG5cdGV4cG9ydHMuWE1MU2VyaWFsaXplciA9IHJlcXVpcmUoJy4vZG9tJykuWE1MU2VyaWFsaXplciA7XHJcblx0ZXhwb3J0cy5ET01QYXJzZXIgPSBET01QYXJzZXI7XHJcbn1cclxuIiwiLypcbiAqIERPTSBMZXZlbCAyXG4gKiBPYmplY3QgRE9NRXhjZXB0aW9uXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy1ET00tTGV2ZWwtMS9lY21hLXNjcmlwdC1sYW5ndWFnZS1iaW5kaW5nLmh0bWxcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMC9SRUMtRE9NLUxldmVsLTItQ29yZS0yMDAwMTExMy9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbiAqL1xuXG5mdW5jdGlvbiBjb3B5KHNyYyxkZXN0KXtcblx0Zm9yKHZhciBwIGluIHNyYyl7XG5cdFx0ZGVzdFtwXSA9IHNyY1twXTtcblx0fVxufVxuLyoqXG5eXFx3K1xcLnByb3RvdHlwZVxcLihbX1xcd10rKVxccyo9XFxzKigoPzouKlxce1xccyo/W1xcclxcbl1bXFxzXFxTXSo/Xn0pfFxcUy4qPyg/PVs7XFxyXFxuXSkpOz9cbl5cXHcrXFwucHJvdG90eXBlXFwuKFtfXFx3XSspXFxzKj1cXHMqKFxcUy4qPyg/PVs7XFxyXFxuXSkpOz9cbiAqL1xuZnVuY3Rpb24gX2V4dGVuZHMoQ2xhc3MsU3VwZXIpe1xuXHR2YXIgcHQgPSBDbGFzcy5wcm90b3R5cGU7XG5cdGlmKE9iamVjdC5jcmVhdGUpe1xuXHRcdHZhciBwcHQgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSlcblx0XHRwdC5fX3Byb3RvX18gPSBwcHQ7XG5cdH1cblx0aWYoIShwdCBpbnN0YW5jZW9mIFN1cGVyKSl7XG5cdFx0ZnVuY3Rpb24gdCgpe307XG5cdFx0dC5wcm90b3R5cGUgPSBTdXBlci5wcm90b3R5cGU7XG5cdFx0dCA9IG5ldyB0KCk7XG5cdFx0Y29weShwdCx0KTtcblx0XHRDbGFzcy5wcm90b3R5cGUgPSBwdCA9IHQ7XG5cdH1cblx0aWYocHQuY29uc3RydWN0b3IgIT0gQ2xhc3Mpe1xuXHRcdGlmKHR5cGVvZiBDbGFzcyAhPSAnZnVuY3Rpb24nKXtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJ1bmtub3cgQ2xhc3M6XCIrQ2xhc3MpXG5cdFx0fVxuXHRcdHB0LmNvbnN0cnVjdG9yID0gQ2xhc3Ncblx0fVxufVxudmFyIGh0bWxucyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyA7XG4vLyBOb2RlIFR5cGVzXG52YXIgTm9kZVR5cGUgPSB7fVxudmFyIEVMRU1FTlRfTk9ERSAgICAgICAgICAgICAgICA9IE5vZGVUeXBlLkVMRU1FTlRfTk9ERSAgICAgICAgICAgICAgICA9IDE7XG52YXIgQVRUUklCVVRFX05PREUgICAgICAgICAgICAgID0gTm9kZVR5cGUuQVRUUklCVVRFX05PREUgICAgICAgICAgICAgID0gMjtcbnZhciBURVhUX05PREUgICAgICAgICAgICAgICAgICAgPSBOb2RlVHlwZS5URVhUX05PREUgICAgICAgICAgICAgICAgICAgPSAzO1xudmFyIENEQVRBX1NFQ1RJT05fTk9ERSAgICAgICAgICA9IE5vZGVUeXBlLkNEQVRBX1NFQ1RJT05fTk9ERSAgICAgICAgICA9IDQ7XG52YXIgRU5USVRZX1JFRkVSRU5DRV9OT0RFICAgICAgID0gTm9kZVR5cGUuRU5USVRZX1JFRkVSRU5DRV9OT0RFICAgICAgID0gNTtcbnZhciBFTlRJVFlfTk9ERSAgICAgICAgICAgICAgICAgPSBOb2RlVHlwZS5FTlRJVFlfTk9ERSAgICAgICAgICAgICAgICAgPSA2O1xudmFyIFBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERSA9IE5vZGVUeXBlLlBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERSA9IDc7XG52YXIgQ09NTUVOVF9OT0RFICAgICAgICAgICAgICAgID0gTm9kZVR5cGUuQ09NTUVOVF9OT0RFICAgICAgICAgICAgICAgID0gODtcbnZhciBET0NVTUVOVF9OT0RFICAgICAgICAgICAgICAgPSBOb2RlVHlwZS5ET0NVTUVOVF9OT0RFICAgICAgICAgICAgICAgPSA5O1xudmFyIERPQ1VNRU5UX1RZUEVfTk9ERSAgICAgICAgICA9IE5vZGVUeXBlLkRPQ1VNRU5UX1RZUEVfTk9ERSAgICAgICAgICA9IDEwO1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgICAgICA9IE5vZGVUeXBlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgICAgICA9IDExO1xudmFyIE5PVEFUSU9OX05PREUgICAgICAgICAgICAgICA9IE5vZGVUeXBlLk5PVEFUSU9OX05PREUgICAgICAgICAgICAgICA9IDEyO1xuXG4vLyBFeGNlcHRpb25Db2RlXG52YXIgRXhjZXB0aW9uQ29kZSA9IHt9XG52YXIgRXhjZXB0aW9uTWVzc2FnZSA9IHt9O1xudmFyIElOREVYX1NJWkVfRVJSICAgICAgICAgICAgICA9IEV4Y2VwdGlvbkNvZGUuSU5ERVhfU0laRV9FUlIgICAgICAgICAgICAgID0gKChFeGNlcHRpb25NZXNzYWdlWzFdPVwiSW5kZXggc2l6ZSBlcnJvclwiKSwxKTtcbnZhciBET01TVFJJTkdfU0laRV9FUlIgICAgICAgICAgPSBFeGNlcHRpb25Db2RlLkRPTVNUUklOR19TSVpFX0VSUiAgICAgICAgICA9ICgoRXhjZXB0aW9uTWVzc2FnZVsyXT1cIkRPTVN0cmluZyBzaXplIGVycm9yXCIpLDIpO1xudmFyIEhJRVJBUkNIWV9SRVFVRVNUX0VSUiAgICAgICA9IEV4Y2VwdGlvbkNvZGUuSElFUkFSQ0hZX1JFUVVFU1RfRVJSICAgICAgID0gKChFeGNlcHRpb25NZXNzYWdlWzNdPVwiSGllcmFyY2h5IHJlcXVlc3QgZXJyb3JcIiksMyk7XG52YXIgV1JPTkdfRE9DVU1FTlRfRVJSICAgICAgICAgID0gRXhjZXB0aW9uQ29kZS5XUk9OR19ET0NVTUVOVF9FUlIgICAgICAgICAgPSAoKEV4Y2VwdGlvbk1lc3NhZ2VbNF09XCJXcm9uZyBkb2N1bWVudFwiKSw0KTtcbnZhciBJTlZBTElEX0NIQVJBQ1RFUl9FUlIgICAgICAgPSBFeGNlcHRpb25Db2RlLklOVkFMSURfQ0hBUkFDVEVSX0VSUiAgICAgICA9ICgoRXhjZXB0aW9uTWVzc2FnZVs1XT1cIkludmFsaWQgY2hhcmFjdGVyXCIpLDUpO1xudmFyIE5PX0RBVEFfQUxMT1dFRF9FUlIgICAgICAgICA9IEV4Y2VwdGlvbkNvZGUuTk9fREFUQV9BTExPV0VEX0VSUiAgICAgICAgID0gKChFeGNlcHRpb25NZXNzYWdlWzZdPVwiTm8gZGF0YSBhbGxvd2VkXCIpLDYpO1xudmFyIE5PX01PRElGSUNBVElPTl9BTExPV0VEX0VSUiA9IEV4Y2VwdGlvbkNvZGUuTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSID0gKChFeGNlcHRpb25NZXNzYWdlWzddPVwiTm8gbW9kaWZpY2F0aW9uIGFsbG93ZWRcIiksNyk7XG52YXIgTk9UX0ZPVU5EX0VSUiAgICAgICAgICAgICAgID0gRXhjZXB0aW9uQ29kZS5OT1RfRk9VTkRfRVJSICAgICAgICAgICAgICAgPSAoKEV4Y2VwdGlvbk1lc3NhZ2VbOF09XCJOb3QgZm91bmRcIiksOCk7XG52YXIgTk9UX1NVUFBPUlRFRF9FUlIgICAgICAgICAgID0gRXhjZXB0aW9uQ29kZS5OT1RfU1VQUE9SVEVEX0VSUiAgICAgICAgICAgPSAoKEV4Y2VwdGlvbk1lc3NhZ2VbOV09XCJOb3Qgc3VwcG9ydGVkXCIpLDkpO1xudmFyIElOVVNFX0FUVFJJQlVURV9FUlIgICAgICAgICA9IEV4Y2VwdGlvbkNvZGUuSU5VU0VfQVRUUklCVVRFX0VSUiAgICAgICAgID0gKChFeGNlcHRpb25NZXNzYWdlWzEwXT1cIkF0dHJpYnV0ZSBpbiB1c2VcIiksMTApO1xuLy9sZXZlbDJcbnZhciBJTlZBTElEX1NUQVRFX0VSUiAgICAgICAgXHQ9IEV4Y2VwdGlvbkNvZGUuSU5WQUxJRF9TVEFURV9FUlIgICAgICAgIFx0PSAoKEV4Y2VwdGlvbk1lc3NhZ2VbMTFdPVwiSW52YWxpZCBzdGF0ZVwiKSwxMSk7XG52YXIgU1lOVEFYX0VSUiAgICAgICAgICAgICAgIFx0PSBFeGNlcHRpb25Db2RlLlNZTlRBWF9FUlIgICAgICAgICAgICAgICBcdD0gKChFeGNlcHRpb25NZXNzYWdlWzEyXT1cIlN5bnRheCBlcnJvclwiKSwxMik7XG52YXIgSU5WQUxJRF9NT0RJRklDQVRJT05fRVJSIFx0PSBFeGNlcHRpb25Db2RlLklOVkFMSURfTU9ESUZJQ0FUSU9OX0VSUiBcdD0gKChFeGNlcHRpb25NZXNzYWdlWzEzXT1cIkludmFsaWQgbW9kaWZpY2F0aW9uXCIpLDEzKTtcbnZhciBOQU1FU1BBQ0VfRVJSICAgICAgICAgICAgXHQ9IEV4Y2VwdGlvbkNvZGUuTkFNRVNQQUNFX0VSUiAgICAgICAgICAgXHQ9ICgoRXhjZXB0aW9uTWVzc2FnZVsxNF09XCJJbnZhbGlkIG5hbWVzcGFjZVwiKSwxNCk7XG52YXIgSU5WQUxJRF9BQ0NFU1NfRVJSICAgICAgIFx0PSBFeGNlcHRpb25Db2RlLklOVkFMSURfQUNDRVNTX0VSUiAgICAgIFx0PSAoKEV4Y2VwdGlvbk1lc3NhZ2VbMTVdPVwiSW52YWxpZCBhY2Nlc3NcIiksMTUpO1xuXG5cbmZ1bmN0aW9uIERPTUV4Y2VwdGlvbihjb2RlLCBtZXNzYWdlKSB7XG5cdGlmKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcil7XG5cdFx0dmFyIGVycm9yID0gbWVzc2FnZTtcblx0fWVsc2V7XG5cdFx0ZXJyb3IgPSB0aGlzO1xuXHRcdEVycm9yLmNhbGwodGhpcywgRXhjZXB0aW9uTWVzc2FnZVtjb2RlXSk7XG5cdFx0dGhpcy5tZXNzYWdlID0gRXhjZXB0aW9uTWVzc2FnZVtjb2RlXTtcblx0XHRpZihFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgRE9NRXhjZXB0aW9uKTtcblx0fVxuXHRlcnJvci5jb2RlID0gY29kZTtcblx0aWYobWVzc2FnZSkgdGhpcy5tZXNzYWdlID0gdGhpcy5tZXNzYWdlICsgXCI6IFwiICsgbWVzc2FnZTtcblx0cmV0dXJuIGVycm9yO1xufTtcbkRPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5jb3B5KEV4Y2VwdGlvbkNvZGUsRE9NRXhjZXB0aW9uKVxuLyoqXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDAvUkVDLURPTS1MZXZlbC0yLUNvcmUtMjAwMDExMTMvY29yZS5odG1sI0lELTUzNjI5NzE3N1xuICogVGhlIE5vZGVMaXN0IGludGVyZmFjZSBwcm92aWRlcyB0aGUgYWJzdHJhY3Rpb24gb2YgYW4gb3JkZXJlZCBjb2xsZWN0aW9uIG9mIG5vZGVzLCB3aXRob3V0IGRlZmluaW5nIG9yIGNvbnN0cmFpbmluZyBob3cgdGhpcyBjb2xsZWN0aW9uIGlzIGltcGxlbWVudGVkLiBOb2RlTGlzdCBvYmplY3RzIGluIHRoZSBET00gYXJlIGxpdmUuXG4gKiBUaGUgaXRlbXMgaW4gdGhlIE5vZGVMaXN0IGFyZSBhY2Nlc3NpYmxlIHZpYSBhbiBpbnRlZ3JhbCBpbmRleCwgc3RhcnRpbmcgZnJvbSAwLlxuICovXG5mdW5jdGlvbiBOb2RlTGlzdCgpIHtcbn07XG5Ob2RlTGlzdC5wcm90b3R5cGUgPSB7XG5cdC8qKlxuXHQgKiBUaGUgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSBsaXN0LiBUaGUgcmFuZ2Ugb2YgdmFsaWQgY2hpbGQgbm9kZSBpbmRpY2VzIGlzIDAgdG8gbGVuZ3RoLTEgaW5jbHVzaXZlLlxuXHQgKiBAc3RhbmRhcmQgbGV2ZWwxXG5cdCAqL1xuXHRsZW5ndGg6MCwgXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBpbmRleHRoIGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb24uIElmIGluZGV4IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSBsaXN0LCB0aGlzIHJldHVybnMgbnVsbC5cblx0ICogQHN0YW5kYXJkIGxldmVsMVxuXHQgKiBAcGFyYW0gaW5kZXggIHVuc2lnbmVkIGxvbmcgXG5cdCAqICAgSW5kZXggaW50byB0aGUgY29sbGVjdGlvbi5cblx0ICogQHJldHVybiBOb2RlXG5cdCAqIFx0VGhlIG5vZGUgYXQgdGhlIGluZGV4dGggcG9zaXRpb24gaW4gdGhlIE5vZGVMaXN0LCBvciBudWxsIGlmIHRoYXQgaXMgbm90IGEgdmFsaWQgaW5kZXguIFxuXHQgKi9cblx0aXRlbTogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpc1tpbmRleF0gfHwgbnVsbDtcblx0fVxufTtcbmZ1bmN0aW9uIExpdmVOb2RlTGlzdChub2RlLHJlZnJlc2gpe1xuXHR0aGlzLl9ub2RlID0gbm9kZTtcblx0dGhpcy5fcmVmcmVzaCA9IHJlZnJlc2hcblx0X3VwZGF0ZUxpdmVMaXN0KHRoaXMpO1xufVxuZnVuY3Rpb24gX3VwZGF0ZUxpdmVMaXN0KGxpc3Qpe1xuXHR2YXIgaW5jID0gbGlzdC5fbm9kZS5faW5jIHx8IGxpc3QuX25vZGUub3duZXJEb2N1bWVudC5faW5jO1xuXHRpZihsaXN0Ll9pbmMgIT0gaW5jKXtcblx0XHR2YXIgbHMgPSBsaXN0Ll9yZWZyZXNoKGxpc3QuX25vZGUpO1xuXHRcdC8vY29uc29sZS5sb2cobHMubGVuZ3RoKVxuXHRcdF9fc2V0X18obGlzdCwnbGVuZ3RoJyxscy5sZW5ndGgpO1xuXHRcdGNvcHkobHMsbGlzdCk7XG5cdFx0bGlzdC5faW5jID0gaW5jO1xuXHR9XG59XG5MaXZlTm9kZUxpc3QucHJvdG90eXBlLml0ZW0gPSBmdW5jdGlvbihpKXtcblx0X3VwZGF0ZUxpdmVMaXN0KHRoaXMpO1xuXHRyZXR1cm4gdGhpc1tpXTtcbn1cblxuX2V4dGVuZHMoTGl2ZU5vZGVMaXN0LE5vZGVMaXN0KTtcbi8qKlxuICogXG4gKiBPYmplY3RzIGltcGxlbWVudGluZyB0aGUgTmFtZWROb2RlTWFwIGludGVyZmFjZSBhcmUgdXNlZCB0byByZXByZXNlbnQgY29sbGVjdGlvbnMgb2Ygbm9kZXMgdGhhdCBjYW4gYmUgYWNjZXNzZWQgYnkgbmFtZS4gTm90ZSB0aGF0IE5hbWVkTm9kZU1hcCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTm9kZUxpc3Q7IE5hbWVkTm9kZU1hcHMgYXJlIG5vdCBtYWludGFpbmVkIGluIGFueSBwYXJ0aWN1bGFyIG9yZGVyLiBPYmplY3RzIGNvbnRhaW5lZCBpbiBhbiBvYmplY3QgaW1wbGVtZW50aW5nIE5hbWVkTm9kZU1hcCBtYXkgYWxzbyBiZSBhY2Nlc3NlZCBieSBhbiBvcmRpbmFsIGluZGV4LCBidXQgdGhpcyBpcyBzaW1wbHkgdG8gYWxsb3cgY29udmVuaWVudCBlbnVtZXJhdGlvbiBvZiB0aGUgY29udGVudHMgb2YgYSBOYW1lZE5vZGVNYXAsIGFuZCBkb2VzIG5vdCBpbXBseSB0aGF0IHRoZSBET00gc3BlY2lmaWVzIGFuIG9yZGVyIHRvIHRoZXNlIE5vZGVzLlxuICogTmFtZWROb2RlTWFwIG9iamVjdHMgaW4gdGhlIERPTSBhcmUgbGl2ZS5cbiAqIHVzZWQgZm9yIGF0dHJpYnV0ZXMgb3IgRG9jdW1lbnRUeXBlIGVudGl0aWVzIFxuICovXG5mdW5jdGlvbiBOYW1lZE5vZGVNYXAoKSB7XG59O1xuXG5mdW5jdGlvbiBfZmluZE5vZGVJbmRleChsaXN0LG5vZGUpe1xuXHR2YXIgaSA9IGxpc3QubGVuZ3RoO1xuXHR3aGlsZShpLS0pe1xuXHRcdGlmKGxpc3RbaV0gPT09IG5vZGUpe3JldHVybiBpfVxuXHR9XG59XG5cbmZ1bmN0aW9uIF9hZGROYW1lZE5vZGUoZWwsbGlzdCxuZXdBdHRyLG9sZEF0dHIpe1xuXHRpZihvbGRBdHRyKXtcblx0XHRsaXN0W19maW5kTm9kZUluZGV4KGxpc3Qsb2xkQXR0cildID0gbmV3QXR0cjtcblx0fWVsc2V7XG5cdFx0bGlzdFtsaXN0Lmxlbmd0aCsrXSA9IG5ld0F0dHI7XG5cdH1cblx0aWYoZWwpe1xuXHRcdG5ld0F0dHIub3duZXJFbGVtZW50ID0gZWw7XG5cdFx0dmFyIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQ7XG5cdFx0aWYoZG9jKXtcblx0XHRcdG9sZEF0dHIgJiYgX29uUmVtb3ZlQXR0cmlidXRlKGRvYyxlbCxvbGRBdHRyKTtcblx0XHRcdF9vbkFkZEF0dHJpYnV0ZShkb2MsZWwsbmV3QXR0cik7XG5cdFx0fVxuXHR9XG59XG5mdW5jdGlvbiBfcmVtb3ZlTmFtZWROb2RlKGVsLGxpc3QsYXR0cil7XG5cdHZhciBpID0gX2ZpbmROb2RlSW5kZXgobGlzdCxhdHRyKTtcblx0aWYoaT49MCl7XG5cdFx0dmFyIGxhc3RJbmRleCA9IGxpc3QubGVuZ3RoLTFcblx0XHR3aGlsZShpPGxhc3RJbmRleCl7XG5cdFx0XHRsaXN0W2ldID0gbGlzdFsrK2ldXG5cdFx0fVxuXHRcdGxpc3QubGVuZ3RoID0gbGFzdEluZGV4O1xuXHRcdGlmKGVsKXtcblx0XHRcdHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50O1xuXHRcdFx0aWYoZG9jKXtcblx0XHRcdFx0X29uUmVtb3ZlQXR0cmlidXRlKGRvYyxlbCxhdHRyKTtcblx0XHRcdFx0YXR0ci5vd25lckVsZW1lbnQgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0fWVsc2V7XG5cdFx0dGhyb3cgRE9NRXhjZXB0aW9uKE5PVF9GT1VORF9FUlIsbmV3IEVycm9yKCkpXG5cdH1cbn1cbk5hbWVkTm9kZU1hcC5wcm90b3R5cGUgPSB7XG5cdGxlbmd0aDowLFxuXHRpdGVtOk5vZGVMaXN0LnByb3RvdHlwZS5pdGVtLFxuXHRnZXROYW1lZEl0ZW06IGZ1bmN0aW9uKGtleSkge1xuLy9cdFx0aWYoa2V5LmluZGV4T2YoJzonKT4wIHx8IGtleSA9PSAneG1sbnMnKXtcbi8vXHRcdFx0cmV0dXJuIG51bGw7XG4vL1x0XHR9XG5cdFx0dmFyIGkgPSB0aGlzLmxlbmd0aDtcblx0XHR3aGlsZShpLS0pe1xuXHRcdFx0dmFyIGF0dHIgPSB0aGlzW2ldO1xuXHRcdFx0aWYoYXR0ci5ub2RlTmFtZSA9PSBrZXkpe1xuXHRcdFx0XHRyZXR1cm4gYXR0cjtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdHNldE5hbWVkSXRlbTogZnVuY3Rpb24oYXR0cikge1xuXHRcdHZhciBlbCA9IGF0dHIub3duZXJFbGVtZW50O1xuXHRcdGlmKGVsICYmIGVsIT10aGlzLl9vd25lckVsZW1lbnQpe1xuXHRcdFx0dGhyb3cgbmV3IERPTUV4Y2VwdGlvbihJTlVTRV9BVFRSSUJVVEVfRVJSKTtcblx0XHR9XG5cdFx0dmFyIG9sZEF0dHIgPSB0aGlzLmdldE5hbWVkSXRlbShhdHRyLm5vZGVOYW1lKTtcblx0XHRfYWRkTmFtZWROb2RlKHRoaXMuX293bmVyRWxlbWVudCx0aGlzLGF0dHIsb2xkQXR0cik7XG5cdFx0cmV0dXJuIG9sZEF0dHI7XG5cdH0sXG5cdC8qIHJldHVybnMgTm9kZSAqL1xuXHRzZXROYW1lZEl0ZW1OUzogZnVuY3Rpb24oYXR0cikgey8vIHJhaXNlczogV1JPTkdfRE9DVU1FTlRfRVJSLE5PX01PRElGSUNBVElPTl9BTExPV0VEX0VSUixJTlVTRV9BVFRSSUJVVEVfRVJSXG5cdFx0dmFyIGVsID0gYXR0ci5vd25lckVsZW1lbnQsIG9sZEF0dHI7XG5cdFx0aWYoZWwgJiYgZWwhPXRoaXMuX293bmVyRWxlbWVudCl7XG5cdFx0XHR0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKElOVVNFX0FUVFJJQlVURV9FUlIpO1xuXHRcdH1cblx0XHRvbGRBdHRyID0gdGhpcy5nZXROYW1lZEl0ZW1OUyhhdHRyLm5hbWVzcGFjZVVSSSxhdHRyLmxvY2FsTmFtZSk7XG5cdFx0X2FkZE5hbWVkTm9kZSh0aGlzLl9vd25lckVsZW1lbnQsdGhpcyxhdHRyLG9sZEF0dHIpO1xuXHRcdHJldHVybiBvbGRBdHRyO1xuXHR9LFxuXG5cdC8qIHJldHVybnMgTm9kZSAqL1xuXHRyZW1vdmVOYW1lZEl0ZW06IGZ1bmN0aW9uKGtleSkge1xuXHRcdHZhciBhdHRyID0gdGhpcy5nZXROYW1lZEl0ZW0oa2V5KTtcblx0XHRfcmVtb3ZlTmFtZWROb2RlKHRoaXMuX293bmVyRWxlbWVudCx0aGlzLGF0dHIpO1xuXHRcdHJldHVybiBhdHRyO1xuXHRcdFxuXHRcdFxuXHR9LC8vIHJhaXNlczogTk9UX0ZPVU5EX0VSUixOT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlJcblx0XG5cdC8vZm9yIGxldmVsMlxuXHRyZW1vdmVOYW1lZEl0ZW1OUzpmdW5jdGlvbihuYW1lc3BhY2VVUkksbG9jYWxOYW1lKXtcblx0XHR2YXIgYXR0ciA9IHRoaXMuZ2V0TmFtZWRJdGVtTlMobmFtZXNwYWNlVVJJLGxvY2FsTmFtZSk7XG5cdFx0X3JlbW92ZU5hbWVkTm9kZSh0aGlzLl9vd25lckVsZW1lbnQsdGhpcyxhdHRyKTtcblx0XHRyZXR1cm4gYXR0cjtcblx0fSxcblx0Z2V0TmFtZWRJdGVtTlM6IGZ1bmN0aW9uKG5hbWVzcGFjZVVSSSwgbG9jYWxOYW1lKSB7XG5cdFx0dmFyIGkgPSB0aGlzLmxlbmd0aDtcblx0XHR3aGlsZShpLS0pe1xuXHRcdFx0dmFyIG5vZGUgPSB0aGlzW2ldO1xuXHRcdFx0aWYobm9kZS5sb2NhbE5hbWUgPT0gbG9jYWxOYW1lICYmIG5vZGUubmFtZXNwYWNlVVJJID09IG5hbWVzcGFjZVVSSSl7XG5cdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufTtcbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMtRE9NLUxldmVsLTEvbGV2ZWwtb25lLWNvcmUuaHRtbCNJRC0xMDIxNjE0OTBcbiAqL1xuZnVuY3Rpb24gRE9NSW1wbGVtZW50YXRpb24oLyogT2JqZWN0ICovIGZlYXR1cmVzKSB7XG5cdHRoaXMuX2ZlYXR1cmVzID0ge307XG5cdGlmIChmZWF0dXJlcykge1xuXHRcdGZvciAodmFyIGZlYXR1cmUgaW4gZmVhdHVyZXMpIHtcblx0XHRcdCB0aGlzLl9mZWF0dXJlcyA9IGZlYXR1cmVzW2ZlYXR1cmVdO1xuXHRcdH1cblx0fVxufTtcblxuRE9NSW1wbGVtZW50YXRpb24ucHJvdG90eXBlID0ge1xuXHRoYXNGZWF0dXJlOiBmdW5jdGlvbigvKiBzdHJpbmcgKi8gZmVhdHVyZSwgLyogc3RyaW5nICovIHZlcnNpb24pIHtcblx0XHR2YXIgdmVyc2lvbnMgPSB0aGlzLl9mZWF0dXJlc1tmZWF0dXJlLnRvTG93ZXJDYXNlKCldO1xuXHRcdGlmICh2ZXJzaW9ucyAmJiAoIXZlcnNpb24gfHwgdmVyc2lvbiBpbiB2ZXJzaW9ucykpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXHQvLyBJbnRyb2R1Y2VkIGluIERPTSBMZXZlbCAyOlxuXHRjcmVhdGVEb2N1bWVudDpmdW5jdGlvbihuYW1lc3BhY2VVUkksICBxdWFsaWZpZWROYW1lLCBkb2N0eXBlKXsvLyByYWlzZXM6SU5WQUxJRF9DSEFSQUNURVJfRVJSLE5BTUVTUEFDRV9FUlIsV1JPTkdfRE9DVU1FTlRfRVJSXG5cdFx0dmFyIGRvYyA9IG5ldyBEb2N1bWVudCgpO1xuXHRcdGRvYy5kb2N0eXBlID0gZG9jdHlwZTtcblx0XHRpZihkb2N0eXBlKXtcblx0XHRcdGRvYy5hcHBlbmRDaGlsZChkb2N0eXBlKTtcblx0XHR9XG5cdFx0ZG9jLmltcGxlbWVudGF0aW9uID0gdGhpcztcblx0XHRkb2MuY2hpbGROb2RlcyA9IG5ldyBOb2RlTGlzdCgpO1xuXHRcdGlmKHF1YWxpZmllZE5hbWUpe1xuXHRcdFx0dmFyIHJvb3QgPSBkb2MuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSxxdWFsaWZpZWROYW1lKTtcblx0XHRcdGRvYy5hcHBlbmRDaGlsZChyb290KTtcblx0XHR9XG5cdFx0cmV0dXJuIGRvYztcblx0fSxcblx0Ly8gSW50cm9kdWNlZCBpbiBET00gTGV2ZWwgMjpcblx0Y3JlYXRlRG9jdW1lbnRUeXBlOmZ1bmN0aW9uKHF1YWxpZmllZE5hbWUsIHB1YmxpY0lkLCBzeXN0ZW1JZCl7Ly8gcmFpc2VzOklOVkFMSURfQ0hBUkFDVEVSX0VSUixOQU1FU1BBQ0VfRVJSXG5cdFx0dmFyIG5vZGUgPSBuZXcgRG9jdW1lbnRUeXBlKCk7XG5cdFx0bm9kZS5uYW1lID0gcXVhbGlmaWVkTmFtZTtcblx0XHRub2RlLm5vZGVOYW1lID0gcXVhbGlmaWVkTmFtZTtcblx0XHRub2RlLnB1YmxpY0lkID0gcHVibGljSWQ7XG5cdFx0bm9kZS5zeXN0ZW1JZCA9IHN5c3RlbUlkO1xuXHRcdC8vIEludHJvZHVjZWQgaW4gRE9NIExldmVsIDI6XG5cdFx0Ly9yZWFkb25seSBhdHRyaWJ1dGUgRE9NU3RyaW5nICAgICAgICBpbnRlcm5hbFN1YnNldDtcblx0XHRcblx0XHQvL1RPRE86Li5cblx0XHQvLyAgcmVhZG9ubHkgYXR0cmlidXRlIE5hbWVkTm9kZU1hcCAgICAgZW50aXRpZXM7XG5cdFx0Ly8gIHJlYWRvbmx5IGF0dHJpYnV0ZSBOYW1lZE5vZGVNYXAgICAgIG5vdGF0aW9ucztcblx0XHRyZXR1cm4gbm9kZTtcblx0fVxufTtcblxuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMC9SRUMtRE9NLUxldmVsLTItQ29yZS0yMDAwMTExMy9jb3JlLmh0bWwjSUQtMTk1MDY0MTI0N1xuICovXG5cbmZ1bmN0aW9uIE5vZGUoKSB7XG59O1xuXG5Ob2RlLnByb3RvdHlwZSA9IHtcblx0Zmlyc3RDaGlsZCA6IG51bGwsXG5cdGxhc3RDaGlsZCA6IG51bGwsXG5cdHByZXZpb3VzU2libGluZyA6IG51bGwsXG5cdG5leHRTaWJsaW5nIDogbnVsbCxcblx0YXR0cmlidXRlcyA6IG51bGwsXG5cdHBhcmVudE5vZGUgOiBudWxsLFxuXHRjaGlsZE5vZGVzIDogbnVsbCxcblx0b3duZXJEb2N1bWVudCA6IG51bGwsXG5cdG5vZGVWYWx1ZSA6IG51bGwsXG5cdG5hbWVzcGFjZVVSSSA6IG51bGwsXG5cdHByZWZpeCA6IG51bGwsXG5cdGxvY2FsTmFtZSA6IG51bGwsXG5cdC8vIE1vZGlmaWVkIGluIERPTSBMZXZlbCAyOlxuXHRpbnNlcnRCZWZvcmU6ZnVuY3Rpb24obmV3Q2hpbGQsIHJlZkNoaWxkKXsvL3JhaXNlcyBcblx0XHRyZXR1cm4gX2luc2VydEJlZm9yZSh0aGlzLG5ld0NoaWxkLHJlZkNoaWxkKTtcblx0fSxcblx0cmVwbGFjZUNoaWxkOmZ1bmN0aW9uKG5ld0NoaWxkLCBvbGRDaGlsZCl7Ly9yYWlzZXMgXG5cdFx0dGhpcy5pbnNlcnRCZWZvcmUobmV3Q2hpbGQsb2xkQ2hpbGQpO1xuXHRcdGlmKG9sZENoaWxkKXtcblx0XHRcdHRoaXMucmVtb3ZlQ2hpbGQob2xkQ2hpbGQpO1xuXHRcdH1cblx0fSxcblx0cmVtb3ZlQ2hpbGQ6ZnVuY3Rpb24ob2xkQ2hpbGQpe1xuXHRcdHJldHVybiBfcmVtb3ZlQ2hpbGQodGhpcyxvbGRDaGlsZCk7XG5cdH0sXG5cdGFwcGVuZENoaWxkOmZ1bmN0aW9uKG5ld0NoaWxkKXtcblx0XHRyZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUobmV3Q2hpbGQsbnVsbCk7XG5cdH0sXG5cdGhhc0NoaWxkTm9kZXM6ZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gdGhpcy5maXJzdENoaWxkICE9IG51bGw7XG5cdH0sXG5cdGNsb25lTm9kZTpmdW5jdGlvbihkZWVwKXtcblx0XHRyZXR1cm4gY2xvbmVOb2RlKHRoaXMub3duZXJEb2N1bWVudHx8dGhpcyx0aGlzLGRlZXApO1xuXHR9LFxuXHQvLyBNb2RpZmllZCBpbiBET00gTGV2ZWwgMjpcblx0bm9ybWFsaXplOmZ1bmN0aW9uKCl7XG5cdFx0dmFyIGNoaWxkID0gdGhpcy5maXJzdENoaWxkO1xuXHRcdHdoaWxlKGNoaWxkKXtcblx0XHRcdHZhciBuZXh0ID0gY2hpbGQubmV4dFNpYmxpbmc7XG5cdFx0XHRpZihuZXh0ICYmIG5leHQubm9kZVR5cGUgPT0gVEVYVF9OT0RFICYmIGNoaWxkLm5vZGVUeXBlID09IFRFWFRfTk9ERSl7XG5cdFx0XHRcdHRoaXMucmVtb3ZlQ2hpbGQobmV4dCk7XG5cdFx0XHRcdGNoaWxkLmFwcGVuZERhdGEobmV4dC5kYXRhKTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRjaGlsZC5ub3JtYWxpemUoKTtcblx0XHRcdFx0Y2hpbGQgPSBuZXh0O1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcbiAgXHQvLyBJbnRyb2R1Y2VkIGluIERPTSBMZXZlbCAyOlxuXHRpc1N1cHBvcnRlZDpmdW5jdGlvbihmZWF0dXJlLCB2ZXJzaW9uKXtcblx0XHRyZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoZmVhdHVyZSx2ZXJzaW9uKTtcblx0fSxcbiAgICAvLyBJbnRyb2R1Y2VkIGluIERPTSBMZXZlbCAyOlxuICAgIGhhc0F0dHJpYnV0ZXM6ZnVuY3Rpb24oKXtcbiAgICBcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoPjA7XG4gICAgfSxcbiAgICBsb29rdXBQcmVmaXg6ZnVuY3Rpb24obmFtZXNwYWNlVVJJKXtcbiAgICBcdHZhciBlbCA9IHRoaXM7XG4gICAgXHR3aGlsZShlbCl7XG4gICAgXHRcdHZhciBtYXAgPSBlbC5fbnNNYXA7XG4gICAgXHRcdC8vY29uc29sZS5kaXIobWFwKVxuICAgIFx0XHRpZihtYXApe1xuICAgIFx0XHRcdGZvcih2YXIgbiBpbiBtYXApe1xuICAgIFx0XHRcdFx0aWYobWFwW25dID09IG5hbWVzcGFjZVVSSSl7XG4gICAgXHRcdFx0XHRcdHJldHVybiBuO1xuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdH1cbiAgICBcdFx0fVxuICAgIFx0XHRlbCA9IGVsLm5vZGVUeXBlID09IDI/ZWwub3duZXJEb2N1bWVudCA6IGVsLnBhcmVudE5vZGU7XG4gICAgXHR9XG4gICAgXHRyZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIC8vIEludHJvZHVjZWQgaW4gRE9NIExldmVsIDM6XG4gICAgbG9va3VwTmFtZXNwYWNlVVJJOmZ1bmN0aW9uKHByZWZpeCl7XG4gICAgXHR2YXIgZWwgPSB0aGlzO1xuICAgIFx0d2hpbGUoZWwpe1xuICAgIFx0XHR2YXIgbWFwID0gZWwuX25zTWFwO1xuICAgIFx0XHQvL2NvbnNvbGUuZGlyKG1hcClcbiAgICBcdFx0aWYobWFwKXtcbiAgICBcdFx0XHRpZihwcmVmaXggaW4gbWFwKXtcbiAgICBcdFx0XHRcdHJldHVybiBtYXBbcHJlZml4XSA7XG4gICAgXHRcdFx0fVxuICAgIFx0XHR9XG4gICAgXHRcdGVsID0gZWwubm9kZVR5cGUgPT0gMj9lbC5vd25lckRvY3VtZW50IDogZWwucGFyZW50Tm9kZTtcbiAgICBcdH1cbiAgICBcdHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgLy8gSW50cm9kdWNlZCBpbiBET00gTGV2ZWwgMzpcbiAgICBpc0RlZmF1bHROYW1lc3BhY2U6ZnVuY3Rpb24obmFtZXNwYWNlVVJJKXtcbiAgICBcdHZhciBwcmVmaXggPSB0aGlzLmxvb2t1cFByZWZpeChuYW1lc3BhY2VVUkkpO1xuICAgIFx0cmV0dXJuIHByZWZpeCA9PSBudWxsO1xuICAgIH1cbn07XG5cblxuZnVuY3Rpb24gX3htbEVuY29kZXIoYyl7XG5cdHJldHVybiBjID09ICc8JyAmJiAnJmx0OycgfHxcbiAgICAgICAgIGMgPT0gJz4nICYmICcmZ3Q7JyB8fFxuICAgICAgICAgYyA9PSAnJicgJiYgJyZhbXA7JyB8fFxuICAgICAgICAgYyA9PSAnXCInICYmICcmcXVvdDsnIHx8XG4gICAgICAgICAnJiMnK2MuY2hhckNvZGVBdCgpKyc7J1xufVxuXG5cbmNvcHkoTm9kZVR5cGUsTm9kZSk7XG5jb3B5KE5vZGVUeXBlLE5vZGUucHJvdG90eXBlKTtcblxuLyoqXG4gKiBAcGFyYW0gY2FsbGJhY2sgcmV0dXJuIHRydWUgZm9yIGNvbnRpbnVlLGZhbHNlIGZvciBicmVha1xuICogQHJldHVybiBib29sZWFuIHRydWU6IGJyZWFrIHZpc2l0O1xuICovXG5mdW5jdGlvbiBfdmlzaXROb2RlKG5vZGUsY2FsbGJhY2spe1xuXHRpZihjYWxsYmFjayhub2RlKSl7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYobm9kZSA9IG5vZGUuZmlyc3RDaGlsZCl7XG5cdFx0ZG97XG5cdFx0XHRpZihfdmlzaXROb2RlKG5vZGUsY2FsbGJhY2spKXtyZXR1cm4gdHJ1ZX1cbiAgICAgICAgfXdoaWxlKG5vZGU9bm9kZS5uZXh0U2libGluZylcbiAgICB9XG59XG5cblxuXG5mdW5jdGlvbiBEb2N1bWVudCgpe1xufVxuZnVuY3Rpb24gX29uQWRkQXR0cmlidXRlKGRvYyxlbCxuZXdBdHRyKXtcblx0ZG9jICYmIGRvYy5faW5jKys7XG5cdHZhciBucyA9IG5ld0F0dHIubmFtZXNwYWNlVVJJIDtcblx0aWYobnMgPT0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJyl7XG5cdFx0Ly91cGRhdGUgbmFtZXNwYWNlXG5cdFx0ZWwuX25zTWFwW25ld0F0dHIucHJlZml4P25ld0F0dHIubG9jYWxOYW1lOicnXSA9IG5ld0F0dHIudmFsdWVcblx0fVxufVxuZnVuY3Rpb24gX29uUmVtb3ZlQXR0cmlidXRlKGRvYyxlbCxuZXdBdHRyLHJlbW92ZSl7XG5cdGRvYyAmJiBkb2MuX2luYysrO1xuXHR2YXIgbnMgPSBuZXdBdHRyLm5hbWVzcGFjZVVSSSA7XG5cdGlmKG5zID09ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLycpe1xuXHRcdC8vdXBkYXRlIG5hbWVzcGFjZVxuXHRcdGRlbGV0ZSBlbC5fbnNNYXBbbmV3QXR0ci5wcmVmaXg/bmV3QXR0ci5sb2NhbE5hbWU6JyddXG5cdH1cbn1cbmZ1bmN0aW9uIF9vblVwZGF0ZUNoaWxkKGRvYyxlbCxuZXdDaGlsZCl7XG5cdGlmKGRvYyAmJiBkb2MuX2luYyl7XG5cdFx0ZG9jLl9pbmMrKztcblx0XHQvL3VwZGF0ZSBjaGlsZE5vZGVzXG5cdFx0dmFyIGNzID0gZWwuY2hpbGROb2Rlcztcblx0XHRpZihuZXdDaGlsZCl7XG5cdFx0XHRjc1tjcy5sZW5ndGgrK10gPSBuZXdDaGlsZDtcblx0XHR9ZWxzZXtcblx0XHRcdC8vY29uc29sZS5sb2coMSlcblx0XHRcdHZhciBjaGlsZCA9IGVsLmZpcnN0Q2hpbGQ7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHR3aGlsZShjaGlsZCl7XG5cdFx0XHRcdGNzW2krK10gPSBjaGlsZDtcblx0XHRcdFx0Y2hpbGQgPWNoaWxkLm5leHRTaWJsaW5nO1xuXHRcdFx0fVxuXHRcdFx0Y3MubGVuZ3RoID0gaTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBhdHRyaWJ1dGVzO1xuICogY2hpbGRyZW47XG4gKiBcbiAqIHdyaXRlYWJsZSBwcm9wZXJ0aWVzOlxuICogbm9kZVZhbHVlLEF0dHI6dmFsdWUsQ2hhcmFjdGVyRGF0YTpkYXRhXG4gKiBwcmVmaXhcbiAqL1xuZnVuY3Rpb24gX3JlbW92ZUNoaWxkKHBhcmVudE5vZGUsY2hpbGQpe1xuXHR2YXIgcHJldmlvdXMgPSBjaGlsZC5wcmV2aW91c1NpYmxpbmc7XG5cdHZhciBuZXh0ID0gY2hpbGQubmV4dFNpYmxpbmc7XG5cdGlmKHByZXZpb3VzKXtcblx0XHRwcmV2aW91cy5uZXh0U2libGluZyA9IG5leHQ7XG5cdH1lbHNle1xuXHRcdHBhcmVudE5vZGUuZmlyc3RDaGlsZCA9IG5leHRcblx0fVxuXHRpZihuZXh0KXtcblx0XHRuZXh0LnByZXZpb3VzU2libGluZyA9IHByZXZpb3VzO1xuXHR9ZWxzZXtcblx0XHRwYXJlbnROb2RlLmxhc3RDaGlsZCA9IHByZXZpb3VzO1xuXHR9XG5cdF9vblVwZGF0ZUNoaWxkKHBhcmVudE5vZGUub3duZXJEb2N1bWVudCxwYXJlbnROb2RlKTtcblx0cmV0dXJuIGNoaWxkO1xufVxuLyoqXG4gKiBwcmVmb3JtYW5jZSBrZXkocmVmQ2hpbGQgPT0gbnVsbClcbiAqL1xuZnVuY3Rpb24gX2luc2VydEJlZm9yZShwYXJlbnROb2RlLG5ld0NoaWxkLG5leHRDaGlsZCl7XG5cdHZhciBjcCA9IG5ld0NoaWxkLnBhcmVudE5vZGU7XG5cdGlmKGNwKXtcblx0XHRjcC5yZW1vdmVDaGlsZChuZXdDaGlsZCk7Ly9yZW1vdmUgYW5kIHVwZGF0ZVxuXHR9XG5cdGlmKG5ld0NoaWxkLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFKXtcblx0XHR2YXIgbmV3Rmlyc3QgPSBuZXdDaGlsZC5maXJzdENoaWxkO1xuXHRcdGlmIChuZXdGaXJzdCA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbmV3Q2hpbGQ7XG5cdFx0fVxuXHRcdHZhciBuZXdMYXN0ID0gbmV3Q2hpbGQubGFzdENoaWxkO1xuXHR9ZWxzZXtcblx0XHRuZXdGaXJzdCA9IG5ld0xhc3QgPSBuZXdDaGlsZDtcblx0fVxuXHR2YXIgcHJlID0gbmV4dENoaWxkID8gbmV4dENoaWxkLnByZXZpb3VzU2libGluZyA6IHBhcmVudE5vZGUubGFzdENoaWxkO1xuXG5cdG5ld0ZpcnN0LnByZXZpb3VzU2libGluZyA9IHByZTtcblx0bmV3TGFzdC5uZXh0U2libGluZyA9IG5leHRDaGlsZDtcblx0XG5cdFxuXHRpZihwcmUpe1xuXHRcdHByZS5uZXh0U2libGluZyA9IG5ld0ZpcnN0O1xuXHR9ZWxzZXtcblx0XHRwYXJlbnROb2RlLmZpcnN0Q2hpbGQgPSBuZXdGaXJzdDtcblx0fVxuXHRpZihuZXh0Q2hpbGQgPT0gbnVsbCl7XG5cdFx0cGFyZW50Tm9kZS5sYXN0Q2hpbGQgPSBuZXdMYXN0O1xuXHR9ZWxzZXtcblx0XHRuZXh0Q2hpbGQucHJldmlvdXNTaWJsaW5nID0gbmV3TGFzdDtcblx0fVxuXHRkb3tcblx0XHRuZXdGaXJzdC5wYXJlbnROb2RlID0gcGFyZW50Tm9kZTtcblx0fXdoaWxlKG5ld0ZpcnN0ICE9PSBuZXdMYXN0ICYmIChuZXdGaXJzdD0gbmV3Rmlyc3QubmV4dFNpYmxpbmcpKVxuXHRfb25VcGRhdGVDaGlsZChwYXJlbnROb2RlLm93bmVyRG9jdW1lbnR8fHBhcmVudE5vZGUscGFyZW50Tm9kZSk7XG5cdC8vY29uc29sZS5sb2cocGFyZW50Tm9kZS5sYXN0Q2hpbGQubmV4dFNpYmxpbmcgPT0gbnVsbClcblx0aWYgKG5ld0NoaWxkLm5vZGVUeXBlID09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcblx0XHRuZXdDaGlsZC5maXJzdENoaWxkID0gbmV3Q2hpbGQubGFzdENoaWxkID0gbnVsbDtcblx0fVxuXHRyZXR1cm4gbmV3Q2hpbGQ7XG59XG5mdW5jdGlvbiBfYXBwZW5kU2luZ2xlQ2hpbGQocGFyZW50Tm9kZSxuZXdDaGlsZCl7XG5cdHZhciBjcCA9IG5ld0NoaWxkLnBhcmVudE5vZGU7XG5cdGlmKGNwKXtcblx0XHR2YXIgcHJlID0gcGFyZW50Tm9kZS5sYXN0Q2hpbGQ7XG5cdFx0Y3AucmVtb3ZlQ2hpbGQobmV3Q2hpbGQpOy8vcmVtb3ZlIGFuZCB1cGRhdGVcblx0XHR2YXIgcHJlID0gcGFyZW50Tm9kZS5sYXN0Q2hpbGQ7XG5cdH1cblx0dmFyIHByZSA9IHBhcmVudE5vZGUubGFzdENoaWxkO1xuXHRuZXdDaGlsZC5wYXJlbnROb2RlID0gcGFyZW50Tm9kZTtcblx0bmV3Q2hpbGQucHJldmlvdXNTaWJsaW5nID0gcHJlO1xuXHRuZXdDaGlsZC5uZXh0U2libGluZyA9IG51bGw7XG5cdGlmKHByZSl7XG5cdFx0cHJlLm5leHRTaWJsaW5nID0gbmV3Q2hpbGQ7XG5cdH1lbHNle1xuXHRcdHBhcmVudE5vZGUuZmlyc3RDaGlsZCA9IG5ld0NoaWxkO1xuXHR9XG5cdHBhcmVudE5vZGUubGFzdENoaWxkID0gbmV3Q2hpbGQ7XG5cdF9vblVwZGF0ZUNoaWxkKHBhcmVudE5vZGUub3duZXJEb2N1bWVudCxwYXJlbnROb2RlLG5ld0NoaWxkKTtcblx0cmV0dXJuIG5ld0NoaWxkO1xuXHQvL2NvbnNvbGUubG9nKFwiX19hYVwiLHBhcmVudE5vZGUubGFzdENoaWxkLm5leHRTaWJsaW5nID09IG51bGwpXG59XG5Eb2N1bWVudC5wcm90b3R5cGUgPSB7XG5cdC8vaW1wbGVtZW50YXRpb24gOiBudWxsLFxuXHRub2RlTmFtZSA6ICAnI2RvY3VtZW50Jyxcblx0bm9kZVR5cGUgOiAgRE9DVU1FTlRfTk9ERSxcblx0ZG9jdHlwZSA6ICBudWxsLFxuXHRkb2N1bWVudEVsZW1lbnQgOiAgbnVsbCxcblx0X2luYyA6IDEsXG5cdFxuXHRpbnNlcnRCZWZvcmUgOiAgZnVuY3Rpb24obmV3Q2hpbGQsIHJlZkNoaWxkKXsvL3JhaXNlcyBcblx0XHRpZihuZXdDaGlsZC5ub2RlVHlwZSA9PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFKXtcblx0XHRcdHZhciBjaGlsZCA9IG5ld0NoaWxkLmZpcnN0Q2hpbGQ7XG5cdFx0XHR3aGlsZShjaGlsZCl7XG5cdFx0XHRcdHZhciBuZXh0ID0gY2hpbGQubmV4dFNpYmxpbmc7XG5cdFx0XHRcdHRoaXMuaW5zZXJ0QmVmb3JlKGNoaWxkLHJlZkNoaWxkKTtcblx0XHRcdFx0Y2hpbGQgPSBuZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ld0NoaWxkO1xuXHRcdH1cblx0XHRpZih0aGlzLmRvY3VtZW50RWxlbWVudCA9PSBudWxsICYmIG5ld0NoaWxkLm5vZGVUeXBlID09IDEpe1xuXHRcdFx0dGhpcy5kb2N1bWVudEVsZW1lbnQgPSBuZXdDaGlsZDtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIF9pbnNlcnRCZWZvcmUodGhpcyxuZXdDaGlsZCxyZWZDaGlsZCksKG5ld0NoaWxkLm93bmVyRG9jdW1lbnQgPSB0aGlzKSxuZXdDaGlsZDtcblx0fSxcblx0cmVtb3ZlQ2hpbGQgOiAgZnVuY3Rpb24ob2xkQ2hpbGQpe1xuXHRcdGlmKHRoaXMuZG9jdW1lbnRFbGVtZW50ID09IG9sZENoaWxkKXtcblx0XHRcdHRoaXMuZG9jdW1lbnRFbGVtZW50ID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIF9yZW1vdmVDaGlsZCh0aGlzLG9sZENoaWxkKTtcblx0fSxcblx0Ly8gSW50cm9kdWNlZCBpbiBET00gTGV2ZWwgMjpcblx0aW1wb3J0Tm9kZSA6IGZ1bmN0aW9uKGltcG9ydGVkTm9kZSxkZWVwKXtcblx0XHRyZXR1cm4gaW1wb3J0Tm9kZSh0aGlzLGltcG9ydGVkTm9kZSxkZWVwKTtcblx0fSxcblx0Ly8gSW50cm9kdWNlZCBpbiBET00gTGV2ZWwgMjpcblx0Z2V0RWxlbWVudEJ5SWQgOlx0ZnVuY3Rpb24oaWQpe1xuXHRcdHZhciBydHYgPSBudWxsO1xuXHRcdF92aXNpdE5vZGUodGhpcy5kb2N1bWVudEVsZW1lbnQsZnVuY3Rpb24obm9kZSl7XG5cdFx0XHRpZihub2RlLm5vZGVUeXBlID09IDEpe1xuXHRcdFx0XHRpZihub2RlLmdldEF0dHJpYnV0ZSgnaWQnKSA9PSBpZCl7XG5cdFx0XHRcdFx0cnR2ID0gbm9kZTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pXG5cdFx0cmV0dXJuIHJ0djtcblx0fSxcblx0XG5cdC8vZG9jdW1lbnQgZmFjdG9yeSBtZXRob2Q6XG5cdGNyZWF0ZUVsZW1lbnQgOlx0ZnVuY3Rpb24odGFnTmFtZSl7XG5cdFx0dmFyIG5vZGUgPSBuZXcgRWxlbWVudCgpO1xuXHRcdG5vZGUub3duZXJEb2N1bWVudCA9IHRoaXM7XG5cdFx0bm9kZS5ub2RlTmFtZSA9IHRhZ05hbWU7XG5cdFx0bm9kZS50YWdOYW1lID0gdGFnTmFtZTtcblx0XHRub2RlLmNoaWxkTm9kZXMgPSBuZXcgTm9kZUxpc3QoKTtcblx0XHR2YXIgYXR0cnNcdD0gbm9kZS5hdHRyaWJ1dGVzID0gbmV3IE5hbWVkTm9kZU1hcCgpO1xuXHRcdGF0dHJzLl9vd25lckVsZW1lbnQgPSBub2RlO1xuXHRcdHJldHVybiBub2RlO1xuXHR9LFxuXHRjcmVhdGVEb2N1bWVudEZyYWdtZW50IDpcdGZ1bmN0aW9uKCl7XG5cdFx0dmFyIG5vZGUgPSBuZXcgRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdG5vZGUub3duZXJEb2N1bWVudCA9IHRoaXM7XG5cdFx0bm9kZS5jaGlsZE5vZGVzID0gbmV3IE5vZGVMaXN0KCk7XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH0sXG5cdGNyZWF0ZVRleHROb2RlIDpcdGZ1bmN0aW9uKGRhdGEpe1xuXHRcdHZhciBub2RlID0gbmV3IFRleHQoKTtcblx0XHRub2RlLm93bmVyRG9jdW1lbnQgPSB0aGlzO1xuXHRcdG5vZGUuYXBwZW5kRGF0YShkYXRhKVxuXHRcdHJldHVybiBub2RlO1xuXHR9LFxuXHRjcmVhdGVDb21tZW50IDpcdGZ1bmN0aW9uKGRhdGEpe1xuXHRcdHZhciBub2RlID0gbmV3IENvbW1lbnQoKTtcblx0XHRub2RlLm93bmVyRG9jdW1lbnQgPSB0aGlzO1xuXHRcdG5vZGUuYXBwZW5kRGF0YShkYXRhKVxuXHRcdHJldHVybiBub2RlO1xuXHR9LFxuXHRjcmVhdGVDREFUQVNlY3Rpb24gOlx0ZnVuY3Rpb24oZGF0YSl7XG5cdFx0dmFyIG5vZGUgPSBuZXcgQ0RBVEFTZWN0aW9uKCk7XG5cdFx0bm9kZS5vd25lckRvY3VtZW50ID0gdGhpcztcblx0XHRub2RlLmFwcGVuZERhdGEoZGF0YSlcblx0XHRyZXR1cm4gbm9kZTtcblx0fSxcblx0Y3JlYXRlUHJvY2Vzc2luZ0luc3RydWN0aW9uIDpcdGZ1bmN0aW9uKHRhcmdldCxkYXRhKXtcblx0XHR2YXIgbm9kZSA9IG5ldyBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oKTtcblx0XHRub2RlLm93bmVyRG9jdW1lbnQgPSB0aGlzO1xuXHRcdG5vZGUudGFnTmFtZSA9IG5vZGUudGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdG5vZGUubm9kZVZhbHVlPSBub2RlLmRhdGEgPSBkYXRhO1xuXHRcdHJldHVybiBub2RlO1xuXHR9LFxuXHRjcmVhdGVBdHRyaWJ1dGUgOlx0ZnVuY3Rpb24obmFtZSl7XG5cdFx0dmFyIG5vZGUgPSBuZXcgQXR0cigpO1xuXHRcdG5vZGUub3duZXJEb2N1bWVudFx0PSB0aGlzO1xuXHRcdG5vZGUubmFtZSA9IG5hbWU7XG5cdFx0bm9kZS5ub2RlTmFtZVx0PSBuYW1lO1xuXHRcdG5vZGUubG9jYWxOYW1lID0gbmFtZTtcblx0XHRub2RlLnNwZWNpZmllZCA9IHRydWU7XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH0sXG5cdGNyZWF0ZUVudGl0eVJlZmVyZW5jZSA6XHRmdW5jdGlvbihuYW1lKXtcblx0XHR2YXIgbm9kZSA9IG5ldyBFbnRpdHlSZWZlcmVuY2UoKTtcblx0XHRub2RlLm93bmVyRG9jdW1lbnRcdD0gdGhpcztcblx0XHRub2RlLm5vZGVOYW1lXHQ9IG5hbWU7XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH0sXG5cdC8vIEludHJvZHVjZWQgaW4gRE9NIExldmVsIDI6XG5cdGNyZWF0ZUVsZW1lbnROUyA6XHRmdW5jdGlvbihuYW1lc3BhY2VVUkkscXVhbGlmaWVkTmFtZSl7XG5cdFx0dmFyIG5vZGUgPSBuZXcgRWxlbWVudCgpO1xuXHRcdHZhciBwbCA9IHF1YWxpZmllZE5hbWUuc3BsaXQoJzonKTtcblx0XHR2YXIgYXR0cnNcdD0gbm9kZS5hdHRyaWJ1dGVzID0gbmV3IE5hbWVkTm9kZU1hcCgpO1xuXHRcdG5vZGUuY2hpbGROb2RlcyA9IG5ldyBOb2RlTGlzdCgpO1xuXHRcdG5vZGUub3duZXJEb2N1bWVudCA9IHRoaXM7XG5cdFx0bm9kZS5ub2RlTmFtZSA9IHF1YWxpZmllZE5hbWU7XG5cdFx0bm9kZS50YWdOYW1lID0gcXVhbGlmaWVkTmFtZTtcblx0XHRub2RlLm5hbWVzcGFjZVVSSSA9IG5hbWVzcGFjZVVSSTtcblx0XHRpZihwbC5sZW5ndGggPT0gMil7XG5cdFx0XHRub2RlLnByZWZpeCA9IHBsWzBdO1xuXHRcdFx0bm9kZS5sb2NhbE5hbWUgPSBwbFsxXTtcblx0XHR9ZWxzZXtcblx0XHRcdC8vZWwucHJlZml4ID0gbnVsbDtcblx0XHRcdG5vZGUubG9jYWxOYW1lID0gcXVhbGlmaWVkTmFtZTtcblx0XHR9XG5cdFx0YXR0cnMuX293bmVyRWxlbWVudCA9IG5vZGU7XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH0sXG5cdC8vIEludHJvZHVjZWQgaW4gRE9NIExldmVsIDI6XG5cdGNyZWF0ZUF0dHJpYnV0ZU5TIDpcdGZ1bmN0aW9uKG5hbWVzcGFjZVVSSSxxdWFsaWZpZWROYW1lKXtcblx0XHR2YXIgbm9kZSA9IG5ldyBBdHRyKCk7XG5cdFx0dmFyIHBsID0gcXVhbGlmaWVkTmFtZS5zcGxpdCgnOicpO1xuXHRcdG5vZGUub3duZXJEb2N1bWVudCA9IHRoaXM7XG5cdFx0bm9kZS5ub2RlTmFtZSA9IHF1YWxpZmllZE5hbWU7XG5cdFx0bm9kZS5uYW1lID0gcXVhbGlmaWVkTmFtZTtcblx0XHRub2RlLm5hbWVzcGFjZVVSSSA9IG5hbWVzcGFjZVVSSTtcblx0XHRub2RlLnNwZWNpZmllZCA9IHRydWU7XG5cdFx0aWYocGwubGVuZ3RoID09IDIpe1xuXHRcdFx0bm9kZS5wcmVmaXggPSBwbFswXTtcblx0XHRcdG5vZGUubG9jYWxOYW1lID0gcGxbMV07XG5cdFx0fWVsc2V7XG5cdFx0XHQvL2VsLnByZWZpeCA9IG51bGw7XG5cdFx0XHRub2RlLmxvY2FsTmFtZSA9IHF1YWxpZmllZE5hbWU7XG5cdFx0fVxuXHRcdHJldHVybiBub2RlO1xuXHR9XG59O1xuX2V4dGVuZHMoRG9jdW1lbnQsTm9kZSk7XG5cblxuZnVuY3Rpb24gRWxlbWVudCgpIHtcblx0dGhpcy5fbnNNYXAgPSB7fTtcbn07XG5FbGVtZW50LnByb3RvdHlwZSA9IHtcblx0bm9kZVR5cGUgOiBFTEVNRU5UX05PREUsXG5cdGhhc0F0dHJpYnV0ZSA6IGZ1bmN0aW9uKG5hbWUpe1xuXHRcdHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkhPW51bGw7XG5cdH0sXG5cdGdldEF0dHJpYnV0ZSA6IGZ1bmN0aW9uKG5hbWUpe1xuXHRcdHZhciBhdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpO1xuXHRcdHJldHVybiBhdHRyICYmIGF0dHIudmFsdWUgfHwgJyc7XG5cdH0sXG5cdGdldEF0dHJpYnV0ZU5vZGUgOiBmdW5jdGlvbihuYW1lKXtcblx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmdldE5hbWVkSXRlbShuYW1lKTtcblx0fSxcblx0c2V0QXR0cmlidXRlIDogZnVuY3Rpb24obmFtZSwgdmFsdWUpe1xuXHRcdHZhciBhdHRyID0gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUF0dHJpYnV0ZShuYW1lKTtcblx0XHRhdHRyLnZhbHVlID0gYXR0ci5ub2RlVmFsdWUgPSBcIlwiICsgdmFsdWU7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGVOb2RlKGF0dHIpXG5cdH0sXG5cdHJlbW92ZUF0dHJpYnV0ZSA6IGZ1bmN0aW9uKG5hbWUpe1xuXHRcdHZhciBhdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpXG5cdFx0YXR0ciAmJiB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5vZGUoYXR0cik7XG5cdH0sXG5cdFxuXHQvL2ZvdXIgcmVhbCBvcGVhcnRpb24gbWV0aG9kXG5cdGFwcGVuZENoaWxkOmZ1bmN0aW9uKG5ld0NoaWxkKXtcblx0XHRpZihuZXdDaGlsZC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSl7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUobmV3Q2hpbGQsbnVsbCk7XG5cdFx0fWVsc2V7XG5cdFx0XHRyZXR1cm4gX2FwcGVuZFNpbmdsZUNoaWxkKHRoaXMsbmV3Q2hpbGQpO1xuXHRcdH1cblx0fSxcblx0c2V0QXR0cmlidXRlTm9kZSA6IGZ1bmN0aW9uKG5ld0F0dHIpe1xuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuc2V0TmFtZWRJdGVtKG5ld0F0dHIpO1xuXHR9LFxuXHRzZXRBdHRyaWJ1dGVOb2RlTlMgOiBmdW5jdGlvbihuZXdBdHRyKXtcblx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnNldE5hbWVkSXRlbU5TKG5ld0F0dHIpO1xuXHR9LFxuXHRyZW1vdmVBdHRyaWJ1dGVOb2RlIDogZnVuY3Rpb24ob2xkQXR0cil7XG5cdFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5yZW1vdmVOYW1lZEl0ZW0ob2xkQXR0ci5ub2RlTmFtZSk7XG5cdH0sXG5cdC8vZ2V0IHJlYWwgYXR0cmlidXRlIG5hbWUsYW5kIHJlbW92ZSBpdCBieSByZW1vdmVBdHRyaWJ1dGVOb2RlXG5cdHJlbW92ZUF0dHJpYnV0ZU5TIDogZnVuY3Rpb24obmFtZXNwYWNlVVJJLCBsb2NhbE5hbWUpe1xuXHRcdHZhciBvbGQgPSB0aGlzLmdldEF0dHJpYnV0ZU5vZGVOUyhuYW1lc3BhY2VVUkksIGxvY2FsTmFtZSk7XG5cdFx0b2xkICYmIHRoaXMucmVtb3ZlQXR0cmlidXRlTm9kZShvbGQpO1xuXHR9LFxuXHRcblx0aGFzQXR0cmlidXRlTlMgOiBmdW5jdGlvbihuYW1lc3BhY2VVUkksIGxvY2FsTmFtZSl7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlTm9kZU5TKG5hbWVzcGFjZVVSSSwgbG9jYWxOYW1lKSE9bnVsbDtcblx0fSxcblx0Z2V0QXR0cmlidXRlTlMgOiBmdW5jdGlvbihuYW1lc3BhY2VVUkksIGxvY2FsTmFtZSl7XG5cdFx0dmFyIGF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZU5vZGVOUyhuYW1lc3BhY2VVUkksIGxvY2FsTmFtZSk7XG5cdFx0cmV0dXJuIGF0dHIgJiYgYXR0ci52YWx1ZSB8fCAnJztcblx0fSxcblx0c2V0QXR0cmlidXRlTlMgOiBmdW5jdGlvbihuYW1lc3BhY2VVUkksIHF1YWxpZmllZE5hbWUsIHZhbHVlKXtcblx0XHR2YXIgYXR0ciA9IHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVBdHRyaWJ1dGVOUyhuYW1lc3BhY2VVUkksIHF1YWxpZmllZE5hbWUpO1xuXHRcdGF0dHIudmFsdWUgPSBhdHRyLm5vZGVWYWx1ZSA9IHZhbHVlO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlTm9kZShhdHRyKVxuXHR9LFxuXHRnZXRBdHRyaWJ1dGVOb2RlTlMgOiBmdW5jdGlvbihuYW1lc3BhY2VVUkksIGxvY2FsTmFtZSl7XG5cdFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5nZXROYW1lZEl0ZW1OUyhuYW1lc3BhY2VVUkksIGxvY2FsTmFtZSk7XG5cdH0sXG5cdFxuXHRnZXRFbGVtZW50c0J5VGFnTmFtZSA6IGZ1bmN0aW9uKHRhZ05hbWUpe1xuXHRcdHJldHVybiBuZXcgTGl2ZU5vZGVMaXN0KHRoaXMsZnVuY3Rpb24oYmFzZSl7XG5cdFx0XHR2YXIgbHMgPSBbXTtcblx0XHRcdF92aXNpdE5vZGUoYmFzZSxmdW5jdGlvbihub2RlKXtcblx0XHRcdFx0aWYobm9kZSAhPT0gYmFzZSAmJiBub2RlLm5vZGVUeXBlID09IEVMRU1FTlRfTk9ERSAmJiAodGFnTmFtZSA9PT0gJyonIHx8IG5vZGUudGFnTmFtZSA9PSB0YWdOYW1lKSl7XG5cdFx0XHRcdFx0bHMucHVzaChub2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gbHM7XG5cdFx0fSk7XG5cdH0sXG5cdGdldEVsZW1lbnRzQnlUYWdOYW1lTlMgOiBmdW5jdGlvbihuYW1lc3BhY2VVUkksIGxvY2FsTmFtZSl7XG5cdFx0cmV0dXJuIG5ldyBMaXZlTm9kZUxpc3QodGhpcyxmdW5jdGlvbihiYXNlKXtcblx0XHRcdHZhciBscyA9IFtdO1xuXHRcdFx0X3Zpc2l0Tm9kZShiYXNlLGZ1bmN0aW9uKG5vZGUpe1xuXHRcdFx0XHRpZihub2RlICE9PSBiYXNlICYmIG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiBub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlVVJJICYmIChsb2NhbE5hbWUgPT09ICcqJyB8fCBub2RlLmxvY2FsTmFtZSA9PSBsb2NhbE5hbWUpKXtcblx0XHRcdFx0XHRscy5wdXNoKG5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBscztcblx0XHR9KTtcblx0fVxufTtcbkRvY3VtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IEVsZW1lbnQucHJvdG90eXBlLmdldEVsZW1lbnRzQnlUYWdOYW1lO1xuRG9jdW1lbnQucHJvdG90eXBlLmdldEVsZW1lbnRzQnlUYWdOYW1lTlMgPSBFbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZU5TO1xuXG5cbl9leHRlbmRzKEVsZW1lbnQsTm9kZSk7XG5mdW5jdGlvbiBBdHRyKCkge1xufTtcbkF0dHIucHJvdG90eXBlLm5vZGVUeXBlID0gQVRUUklCVVRFX05PREU7XG5fZXh0ZW5kcyhBdHRyLE5vZGUpO1xuXG5cbmZ1bmN0aW9uIENoYXJhY3RlckRhdGEoKSB7XG59O1xuQ2hhcmFjdGVyRGF0YS5wcm90b3R5cGUgPSB7XG5cdGRhdGEgOiAnJyxcblx0c3Vic3RyaW5nRGF0YSA6IGZ1bmN0aW9uKG9mZnNldCwgY291bnQpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCtjb3VudCk7XG5cdH0sXG5cdGFwcGVuZERhdGE6IGZ1bmN0aW9uKHRleHQpIHtcblx0XHR0ZXh0ID0gdGhpcy5kYXRhK3RleHQ7XG5cdFx0dGhpcy5ub2RlVmFsdWUgPSB0aGlzLmRhdGEgPSB0ZXh0O1xuXHRcdHRoaXMubGVuZ3RoID0gdGV4dC5sZW5ndGg7XG5cdH0sXG5cdGluc2VydERhdGE6IGZ1bmN0aW9uKG9mZnNldCx0ZXh0KSB7XG5cdFx0dGhpcy5yZXBsYWNlRGF0YShvZmZzZXQsMCx0ZXh0KTtcblx0XG5cdH0sXG5cdGFwcGVuZENoaWxkOmZ1bmN0aW9uKG5ld0NoaWxkKXtcblx0XHQvL2lmKCEobmV3Q2hpbGQgaW5zdGFuY2VvZiBDaGFyYWN0ZXJEYXRhKSl7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoRXhjZXB0aW9uTWVzc2FnZVszXSlcblx0XHQvL31cblx0XHRyZXR1cm4gTm9kZS5wcm90b3R5cGUuYXBwZW5kQ2hpbGQuYXBwbHkodGhpcyxhcmd1bWVudHMpXG5cdH0sXG5cdGRlbGV0ZURhdGE6IGZ1bmN0aW9uKG9mZnNldCwgY291bnQpIHtcblx0XHR0aGlzLnJlcGxhY2VEYXRhKG9mZnNldCxjb3VudCxcIlwiKTtcblx0fSxcblx0cmVwbGFjZURhdGE6IGZ1bmN0aW9uKG9mZnNldCwgY291bnQsIHRleHQpIHtcblx0XHR2YXIgc3RhcnQgPSB0aGlzLmRhdGEuc3Vic3RyaW5nKDAsb2Zmc2V0KTtcblx0XHR2YXIgZW5kID0gdGhpcy5kYXRhLnN1YnN0cmluZyhvZmZzZXQrY291bnQpO1xuXHRcdHRleHQgPSBzdGFydCArIHRleHQgKyBlbmQ7XG5cdFx0dGhpcy5ub2RlVmFsdWUgPSB0aGlzLmRhdGEgPSB0ZXh0O1xuXHRcdHRoaXMubGVuZ3RoID0gdGV4dC5sZW5ndGg7XG5cdH1cbn1cbl9leHRlbmRzKENoYXJhY3RlckRhdGEsTm9kZSk7XG5mdW5jdGlvbiBUZXh0KCkge1xufTtcblRleHQucHJvdG90eXBlID0ge1xuXHRub2RlTmFtZSA6IFwiI3RleHRcIixcblx0bm9kZVR5cGUgOiBURVhUX05PREUsXG5cdHNwbGl0VGV4dCA6IGZ1bmN0aW9uKG9mZnNldCkge1xuXHRcdHZhciB0ZXh0ID0gdGhpcy5kYXRhO1xuXHRcdHZhciBuZXdUZXh0ID0gdGV4dC5zdWJzdHJpbmcob2Zmc2V0KTtcblx0XHR0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgb2Zmc2V0KTtcblx0XHR0aGlzLmRhdGEgPSB0aGlzLm5vZGVWYWx1ZSA9IHRleHQ7XG5cdFx0dGhpcy5sZW5ndGggPSB0ZXh0Lmxlbmd0aDtcblx0XHR2YXIgbmV3Tm9kZSA9IHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuZXdUZXh0KTtcblx0XHRpZih0aGlzLnBhcmVudE5vZGUpe1xuXHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCB0aGlzLm5leHRTaWJsaW5nKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5ld05vZGU7XG5cdH1cbn1cbl9leHRlbmRzKFRleHQsQ2hhcmFjdGVyRGF0YSk7XG5mdW5jdGlvbiBDb21tZW50KCkge1xufTtcbkNvbW1lbnQucHJvdG90eXBlID0ge1xuXHRub2RlTmFtZSA6IFwiI2NvbW1lbnRcIixcblx0bm9kZVR5cGUgOiBDT01NRU5UX05PREVcbn1cbl9leHRlbmRzKENvbW1lbnQsQ2hhcmFjdGVyRGF0YSk7XG5cbmZ1bmN0aW9uIENEQVRBU2VjdGlvbigpIHtcbn07XG5DREFUQVNlY3Rpb24ucHJvdG90eXBlID0ge1xuXHRub2RlTmFtZSA6IFwiI2NkYXRhLXNlY3Rpb25cIixcblx0bm9kZVR5cGUgOiBDREFUQV9TRUNUSU9OX05PREVcbn1cbl9leHRlbmRzKENEQVRBU2VjdGlvbixDaGFyYWN0ZXJEYXRhKTtcblxuXG5mdW5jdGlvbiBEb2N1bWVudFR5cGUoKSB7XG59O1xuRG9jdW1lbnRUeXBlLnByb3RvdHlwZS5ub2RlVHlwZSA9IERPQ1VNRU5UX1RZUEVfTk9ERTtcbl9leHRlbmRzKERvY3VtZW50VHlwZSxOb2RlKTtcblxuZnVuY3Rpb24gTm90YXRpb24oKSB7XG59O1xuTm90YXRpb24ucHJvdG90eXBlLm5vZGVUeXBlID0gTk9UQVRJT05fTk9ERTtcbl9leHRlbmRzKE5vdGF0aW9uLE5vZGUpO1xuXG5mdW5jdGlvbiBFbnRpdHkoKSB7XG59O1xuRW50aXR5LnByb3RvdHlwZS5ub2RlVHlwZSA9IEVOVElUWV9OT0RFO1xuX2V4dGVuZHMoRW50aXR5LE5vZGUpO1xuXG5mdW5jdGlvbiBFbnRpdHlSZWZlcmVuY2UoKSB7XG59O1xuRW50aXR5UmVmZXJlbmNlLnByb3RvdHlwZS5ub2RlVHlwZSA9IEVOVElUWV9SRUZFUkVOQ0VfTk9ERTtcbl9leHRlbmRzKEVudGl0eVJlZmVyZW5jZSxOb2RlKTtcblxuZnVuY3Rpb24gRG9jdW1lbnRGcmFnbWVudCgpIHtcbn07XG5Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS5ub2RlTmFtZSA9XHRcIiNkb2N1bWVudC1mcmFnbWVudFwiO1xuRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUubm9kZVR5cGUgPVx0RE9DVU1FTlRfRlJBR01FTlRfTk9ERTtcbl9leHRlbmRzKERvY3VtZW50RnJhZ21lbnQsTm9kZSk7XG5cblxuZnVuY3Rpb24gUHJvY2Vzc2luZ0luc3RydWN0aW9uKCkge1xufVxuUHJvY2Vzc2luZ0luc3RydWN0aW9uLnByb3RvdHlwZS5ub2RlVHlwZSA9IFBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERTtcbl9leHRlbmRzKFByb2Nlc3NpbmdJbnN0cnVjdGlvbixOb2RlKTtcbmZ1bmN0aW9uIFhNTFNlcmlhbGl6ZXIoKXt9XG5YTUxTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVUb1N0cmluZyA9IGZ1bmN0aW9uKG5vZGUpe1xuXHR2YXIgYnVmID0gW107XG5cdHNlcmlhbGl6ZVRvU3RyaW5nKG5vZGUsYnVmKTtcblx0cmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn1cbk5vZGUucHJvdG90eXBlLnRvU3RyaW5nID1mdW5jdGlvbigpe1xuXHRyZXR1cm4gWE1MU2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplVG9TdHJpbmcodGhpcyk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVUb1N0cmluZyhub2RlLGJ1Zil7XG5cdHN3aXRjaChub2RlLm5vZGVUeXBlKXtcblx0Y2FzZSBFTEVNRU5UX05PREU6XG5cdFx0dmFyIGF0dHJzID0gbm9kZS5hdHRyaWJ1dGVzO1xuXHRcdHZhciBsZW4gPSBhdHRycy5sZW5ndGg7XG5cdFx0dmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXHRcdHZhciBub2RlTmFtZSA9IG5vZGUudGFnTmFtZTtcblx0XHR2YXIgaXNIVE1MID0gaHRtbG5zID09PSBub2RlLm5hbWVzcGFjZVVSSVxuXHRcdGJ1Zi5wdXNoKCc8Jyxub2RlTmFtZSk7XG5cdFx0Zm9yKHZhciBpPTA7aTxsZW47aSsrKXtcblx0XHRcdHNlcmlhbGl6ZVRvU3RyaW5nKGF0dHJzLml0ZW0oaSksYnVmLGlzSFRNTCk7XG5cdFx0fVxuXHRcdGlmKGNoaWxkIHx8IGlzSFRNTCAmJiAhL14oPzptZXRhfGxpbmt8aW1nfGJyfGhyfGlucHV0KSQvaS50ZXN0KG5vZGVOYW1lKSl7XG5cdFx0XHRidWYucHVzaCgnPicpO1xuXHRcdFx0Ly9pZiBpcyBjZGF0YSBjaGlsZCBub2RlXG5cdFx0XHRpZihpc0hUTUwgJiYgL15zY3JpcHQkL2kudGVzdChub2RlTmFtZSkpe1xuXHRcdFx0XHRpZihjaGlsZCl7XG5cdFx0XHRcdFx0YnVmLnB1c2goY2hpbGQuZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH1lbHNle1xuXHRcdFx0XHR3aGlsZShjaGlsZCl7XG5cdFx0XHRcdFx0c2VyaWFsaXplVG9TdHJpbmcoY2hpbGQsYnVmKTtcblx0XHRcdFx0XHRjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRidWYucHVzaCgnPC8nLG5vZGVOYW1lLCc+Jyk7XG5cdFx0fWVsc2V7XG5cdFx0XHRidWYucHVzaCgnLz4nKTtcblx0XHR9XG5cdFx0cmV0dXJuO1xuXHRjYXNlIERPQ1VNRU5UX05PREU6XG5cdGNhc2UgRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcblx0XHR2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG5cdFx0d2hpbGUoY2hpbGQpe1xuXHRcdFx0c2VyaWFsaXplVG9TdHJpbmcoY2hpbGQsYnVmKTtcblx0XHRcdGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0Y2FzZSBBVFRSSUJVVEVfTk9ERTpcblx0XHRyZXR1cm4gYnVmLnB1c2goJyAnLG5vZGUubmFtZSwnPVwiJyxub2RlLnZhbHVlLnJlcGxhY2UoL1s8JlwiXS9nLF94bWxFbmNvZGVyKSwnXCInKTtcblx0Y2FzZSBURVhUX05PREU6XG5cdFx0cmV0dXJuIGJ1Zi5wdXNoKG5vZGUuZGF0YS5yZXBsYWNlKC9bPCZdL2csX3htbEVuY29kZXIpKTtcblx0Y2FzZSBDREFUQV9TRUNUSU9OX05PREU6XG5cdFx0cmV0dXJuIGJ1Zi5wdXNoKCAnPCFbQ0RBVEFbJyxub2RlLmRhdGEsJ11dPicpO1xuXHRjYXNlIENPTU1FTlRfTk9ERTpcblx0XHRyZXR1cm4gYnVmLnB1c2goIFwiPCEtLVwiLG5vZGUuZGF0YSxcIi0tPlwiKTtcblx0Y2FzZSBET0NVTUVOVF9UWVBFX05PREU6XG5cdFx0dmFyIHB1YmlkID0gbm9kZS5wdWJsaWNJZDtcblx0XHR2YXIgc3lzaWQgPSBub2RlLnN5c3RlbUlkO1xuXHRcdGJ1Zi5wdXNoKCc8IURPQ1RZUEUgJyxub2RlLm5hbWUpO1xuXHRcdGlmKHB1YmlkKXtcblx0XHRcdGJ1Zi5wdXNoKCcgUFVCTElDIFwiJyxwdWJpZCk7XG5cdFx0XHRpZiAoc3lzaWQgJiYgc3lzaWQhPScuJykge1xuXHRcdFx0XHRidWYucHVzaCggJ1wiIFwiJyxzeXNpZCk7XG5cdFx0XHR9XG5cdFx0XHRidWYucHVzaCgnXCI+Jyk7XG5cdFx0fWVsc2UgaWYoc3lzaWQgJiYgc3lzaWQhPScuJyl7XG5cdFx0XHRidWYucHVzaCgnIFNZU1RFTSBcIicsc3lzaWQsJ1wiPicpO1xuXHRcdH1lbHNle1xuXHRcdFx0dmFyIHN1YiA9IG5vZGUuaW50ZXJuYWxTdWJzZXQ7XG5cdFx0XHRpZihzdWIpe1xuXHRcdFx0XHRidWYucHVzaChcIiBbXCIsc3ViLFwiXVwiKTtcblx0XHRcdH1cblx0XHRcdGJ1Zi5wdXNoKFwiPlwiKTtcblx0XHR9XG5cdFx0cmV0dXJuO1xuXHRjYXNlIFBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERTpcblx0XHRyZXR1cm4gYnVmLnB1c2goIFwiPD9cIixub2RlLnRhcmdldCxcIiBcIixub2RlLmRhdGEsXCI/PlwiKTtcblx0Y2FzZSBFTlRJVFlfUkVGRVJFTkNFX05PREU6XG5cdFx0cmV0dXJuIGJ1Zi5wdXNoKCAnJicsbm9kZS5ub2RlTmFtZSwnOycpO1xuXHQvL2Nhc2UgRU5USVRZX05PREU6XG5cdC8vY2FzZSBOT1RBVElPTl9OT0RFOlxuXHRkZWZhdWx0OlxuXHRcdGJ1Zi5wdXNoKCc/Pycsbm9kZS5ub2RlTmFtZSk7XG5cdH1cbn1cbmZ1bmN0aW9uIGltcG9ydE5vZGUoZG9jLG5vZGUsZGVlcCl7XG5cdHZhciBub2RlMjtcblx0c3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG5cdGNhc2UgRUxFTUVOVF9OT0RFOlxuXHRcdG5vZGUyID0gbm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuXHRcdG5vZGUyLm93bmVyRG9jdW1lbnQgPSBkb2M7XG5cdFx0Ly92YXIgYXR0cnMgPSBub2RlMi5hdHRyaWJ1dGVzO1xuXHRcdC8vdmFyIGxlbiA9IGF0dHJzLmxlbmd0aDtcblx0XHQvL2Zvcih2YXIgaT0wO2k8bGVuO2krKyl7XG5cdFx0XHQvL25vZGUyLnNldEF0dHJpYnV0ZU5vZGVOUyhpbXBvcnROb2RlKGRvYyxhdHRycy5pdGVtKGkpLGRlZXApKTtcblx0XHQvL31cblx0Y2FzZSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuXHRcdGJyZWFrO1xuXHRjYXNlIEFUVFJJQlVURV9OT0RFOlxuXHRcdGRlZXAgPSB0cnVlO1xuXHRcdGJyZWFrO1xuXHQvL2Nhc2UgRU5USVRZX1JFRkVSRU5DRV9OT0RFOlxuXHQvL2Nhc2UgUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFOlxuXHQvLy8vY2FzZSBURVhUX05PREU6XG5cdC8vY2FzZSBDREFUQV9TRUNUSU9OX05PREU6XG5cdC8vY2FzZSBDT01NRU5UX05PREU6XG5cdC8vXHRkZWVwID0gZmFsc2U7XG5cdC8vXHRicmVhaztcblx0Ly9jYXNlIERPQ1VNRU5UX05PREU6XG5cdC8vY2FzZSBET0NVTUVOVF9UWVBFX05PREU6XG5cdC8vY2Fubm90IGJlIGltcG9ydGVkLlxuXHQvL2Nhc2UgRU5USVRZX05PREU6XG5cdC8vY2FzZSBOT1RBVElPTl9OT0RF77yaXG5cdC8vY2FuIG5vdCBoaXQgaW4gbGV2ZWwzXG5cdC8vZGVmYXVsdDp0aHJvdyBlO1xuXHR9XG5cdGlmKCFub2RlMil7XG5cdFx0bm9kZTIgPSBub2RlLmNsb25lTm9kZShmYWxzZSk7Ly9mYWxzZVxuXHR9XG5cdG5vZGUyLm93bmVyRG9jdW1lbnQgPSBkb2M7XG5cdG5vZGUyLnBhcmVudE5vZGUgPSBudWxsO1xuXHRpZihkZWVwKXtcblx0XHR2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG5cdFx0d2hpbGUoY2hpbGQpe1xuXHRcdFx0bm9kZTIuYXBwZW5kQ2hpbGQoaW1wb3J0Tm9kZShkb2MsY2hpbGQsZGVlcCkpO1xuXHRcdFx0Y2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcblx0XHR9XG5cdH1cblx0cmV0dXJuIG5vZGUyO1xufVxuLy9cbi8vdmFyIF9yZWxhdGlvbk1hcCA9IHtmaXJzdENoaWxkOjEsbGFzdENoaWxkOjEscHJldmlvdXNTaWJsaW5nOjEsbmV4dFNpYmxpbmc6MSxcbi8vXHRcdFx0XHRcdGF0dHJpYnV0ZXM6MSxjaGlsZE5vZGVzOjEscGFyZW50Tm9kZToxLGRvY3VtZW50RWxlbWVudDoxLGRvY3R5cGUsfTtcbmZ1bmN0aW9uIGNsb25lTm9kZShkb2Msbm9kZSxkZWVwKXtcblx0dmFyIG5vZGUyID0gbmV3IG5vZGUuY29uc3RydWN0b3IoKTtcblx0Zm9yKHZhciBuIGluIG5vZGUpe1xuXHRcdHZhciB2ID0gbm9kZVtuXTtcblx0XHRpZih0eXBlb2YgdiAhPSAnb2JqZWN0JyApe1xuXHRcdFx0aWYodiAhPSBub2RlMltuXSl7XG5cdFx0XHRcdG5vZGUyW25dID0gdjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0aWYobm9kZS5jaGlsZE5vZGVzKXtcblx0XHRub2RlMi5jaGlsZE5vZGVzID0gbmV3IE5vZGVMaXN0KCk7XG5cdH1cblx0bm9kZTIub3duZXJEb2N1bWVudCA9IGRvYztcblx0c3dpdGNoIChub2RlMi5ub2RlVHlwZSkge1xuXHRjYXNlIEVMRU1FTlRfTk9ERTpcblx0XHR2YXIgYXR0cnNcdD0gbm9kZS5hdHRyaWJ1dGVzO1xuXHRcdHZhciBhdHRyczJcdD0gbm9kZTIuYXR0cmlidXRlcyA9IG5ldyBOYW1lZE5vZGVNYXAoKTtcblx0XHR2YXIgbGVuID0gYXR0cnMubGVuZ3RoXG5cdFx0YXR0cnMyLl9vd25lckVsZW1lbnQgPSBub2RlMjtcblx0XHRmb3IodmFyIGk9MDtpPGxlbjtpKyspe1xuXHRcdFx0bm9kZTIuc2V0QXR0cmlidXRlTm9kZShjbG9uZU5vZGUoZG9jLGF0dHJzLml0ZW0oaSksdHJ1ZSkpO1xuXHRcdH1cblx0XHRicmVhazs7XG5cdGNhc2UgQVRUUklCVVRFX05PREU6XG5cdFx0ZGVlcCA9IHRydWU7XG5cdH1cblx0aWYoZGVlcCl7XG5cdFx0dmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXHRcdHdoaWxlKGNoaWxkKXtcblx0XHRcdG5vZGUyLmFwcGVuZENoaWxkKGNsb25lTm9kZShkb2MsY2hpbGQsZGVlcCkpO1xuXHRcdFx0Y2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcblx0XHR9XG5cdH1cblx0cmV0dXJuIG5vZGUyO1xufVxuXG5mdW5jdGlvbiBfX3NldF9fKG9iamVjdCxrZXksdmFsdWUpe1xuXHRvYmplY3Rba2V5XSA9IHZhbHVlXG59XG4vL2RvIGR5bmFtaWNcbnRyeXtcblx0aWYoT2JqZWN0LmRlZmluZVByb3BlcnR5KXtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoTGl2ZU5vZGVMaXN0LnByb3RvdHlwZSwnbGVuZ3RoJyx7XG5cdFx0XHRnZXQ6ZnVuY3Rpb24oKXtcblx0XHRcdFx0X3VwZGF0ZUxpdmVMaXN0KHRoaXMpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy4kJGxlbmd0aDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsJ3RleHRDb250ZW50Jyx7XG5cdFx0XHRnZXQ6ZnVuY3Rpb24oKXtcblx0XHRcdFx0cmV0dXJuIGdldFRleHRDb250ZW50KHRoaXMpO1xuXHRcdFx0fSxcblx0XHRcdHNldDpmdW5jdGlvbihkYXRhKXtcblx0XHRcdFx0c3dpdGNoKHRoaXMubm9kZVR5cGUpe1xuXHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdGNhc2UgMTE6XG5cdFx0XHRcdFx0d2hpbGUodGhpcy5maXJzdENoaWxkKXtcblx0XHRcdFx0XHRcdHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoZGF0YSB8fCBTdHJpbmcoZGF0YSkpe1xuXHRcdFx0XHRcdFx0dGhpcy5hcHBlbmRDaGlsZCh0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHQvL1RPRE86XG5cdFx0XHRcdFx0dGhpcy5kYXRhID0gZGF0YTtcblx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0dGhpcy5ub2RlVmFsdWUgPSBkYXRhO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSlcblx0XHRcblx0XHRmdW5jdGlvbiBnZXRUZXh0Q29udGVudChub2RlKXtcblx0XHRcdHN3aXRjaChub2RlLm5vZGVUeXBlKXtcblx0XHRcdGNhc2UgMTpcblx0XHRcdGNhc2UgMTE6XG5cdFx0XHRcdHZhciBidWYgPSBbXTtcblx0XHRcdFx0bm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcblx0XHRcdFx0d2hpbGUobm9kZSl7XG5cdFx0XHRcdFx0aWYobm9kZS5ub2RlVHlwZSE9PTcgJiYgbm9kZS5ub2RlVHlwZSAhPT04KXtcblx0XHRcdFx0XHRcdGJ1Zi5wdXNoKGdldFRleHRDb250ZW50KG5vZGUpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGJ1Zi5qb2luKCcnKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBub2RlLm5vZGVWYWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0X19zZXRfXyA9IGZ1bmN0aW9uKG9iamVjdCxrZXksdmFsdWUpe1xuXHRcdFx0Ly9jb25zb2xlLmxvZyh2YWx1ZSlcblx0XHRcdG9iamVjdFsnJCQnK2tleV0gPSB2YWx1ZVxuXHRcdH1cblx0fVxufWNhdGNoKGUpey8vaWU4XG59XG5cbmlmKHR5cGVvZiByZXF1aXJlID09ICdmdW5jdGlvbicpe1xuXHRleHBvcnRzLkRPTUltcGxlbWVudGF0aW9uID0gRE9NSW1wbGVtZW50YXRpb247XG5cdGV4cG9ydHMuWE1MU2VyaWFsaXplciA9IFhNTFNlcmlhbGl6ZXI7XG59XG4iLCIvL1s0XSAgIFx0TmFtZVN0YXJ0Q2hhclx0ICAgOjo9ICAgXHRcIjpcIiB8IFtBLVpdIHwgXCJfXCIgfCBbYS16XSB8IFsjeEMwLSN4RDZdIHwgWyN4RDgtI3hGNl0gfCBbI3hGOC0jeDJGRl0gfCBbI3gzNzAtI3gzN0RdIHwgWyN4MzdGLSN4MUZGRl0gfCBbI3gyMDBDLSN4MjAwRF0gfCBbI3gyMDcwLSN4MjE4Rl0gfCBbI3gyQzAwLSN4MkZFRl0gfCBbI3gzMDAxLSN4RDdGRl0gfCBbI3hGOTAwLSN4RkRDRl0gfCBbI3hGREYwLSN4RkZGRF0gfCBbI3gxMDAwMC0jeEVGRkZGXVxyXG4vL1s0YV0gICBcdE5hbWVDaGFyXHQgICA6Oj0gICBcdE5hbWVTdGFydENoYXIgfCBcIi1cIiB8IFwiLlwiIHwgWzAtOV0gfCAjeEI3IHwgWyN4MDMwMC0jeDAzNkZdIHwgWyN4MjAzRi0jeDIwNDBdXHJcbi8vWzVdICAgXHROYW1lXHQgICA6Oj0gICBcdE5hbWVTdGFydENoYXIgKE5hbWVDaGFyKSpcclxudmFyIG5hbWVTdGFydENoYXIgPSAvW0EtWl9hLXpcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXS8vL1xcdTEwMDAwLVxcdUVGRkZGXHJcbnZhciBuYW1lQ2hhciA9IG5ldyBSZWdFeHAoXCJbXFxcXC1cXFxcLjAtOVwiK25hbWVTdGFydENoYXIuc291cmNlLnNsaWNlKDEsLTEpK1wiXFx1MDBCN1xcdTAzMDAtXFx1MDM2RlxcXFx1eDIwM0YtXFx1MjA0MF1cIik7XHJcbnZhciB0YWdOYW1lUGF0dGVybiA9IG5ldyBSZWdFeHAoJ14nK25hbWVTdGFydENoYXIuc291cmNlK25hbWVDaGFyLnNvdXJjZSsnKig/OlxcOicrbmFtZVN0YXJ0Q2hhci5zb3VyY2UrbmFtZUNoYXIuc291cmNlKycqKT8kJyk7XHJcbi8vdmFyIHRhZ05hbWVQYXR0ZXJuID0gL15bYS16QS1aX11bXFx3XFwtXFwuXSooPzpcXDpbYS16QS1aX11bXFx3XFwtXFwuXSopPyQvXHJcbi8vdmFyIGhhbmRsZXJzID0gJ3Jlc29sdmVFbnRpdHksZ2V0RXh0ZXJuYWxTdWJzZXQsY2hhcmFjdGVycyxlbmREb2N1bWVudCxlbmRFbGVtZW50LGVuZFByZWZpeE1hcHBpbmcsaWdub3JhYmxlV2hpdGVzcGFjZSxwcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sc2V0RG9jdW1lbnRMb2NhdG9yLHNraXBwZWRFbnRpdHksc3RhcnREb2N1bWVudCxzdGFydEVsZW1lbnQsc3RhcnRQcmVmaXhNYXBwaW5nLG5vdGF0aW9uRGVjbCx1bnBhcnNlZEVudGl0eURlY2wsZXJyb3IsZmF0YWxFcnJvcix3YXJuaW5nLGF0dHJpYnV0ZURlY2wsZWxlbWVudERlY2wsZXh0ZXJuYWxFbnRpdHlEZWNsLGludGVybmFsRW50aXR5RGVjbCxjb21tZW50LGVuZENEQVRBLGVuZERURCxlbmRFbnRpdHksc3RhcnRDREFUQSxzdGFydERURCxzdGFydEVudGl0eScuc3BsaXQoJywnKVxyXG5cclxuLy9TX1RBRyxcdFNfQVRUUixcdFNfRVEsXHRTX1ZcclxuLy9TX0FUVFJfUyxcdFNfRSxcdFNfUyxcdFNfQ1xyXG52YXIgU19UQUcgPSAwOy8vdGFnIG5hbWUgb2ZmZXJyaW5nXHJcbnZhciBTX0FUVFIgPSAxOy8vYXR0ciBuYW1lIG9mZmVycmluZyBcclxudmFyIFNfQVRUUl9TPTI7Ly9hdHRyIG5hbWUgZW5kIGFuZCBzcGFjZSBvZmZlclxyXG52YXIgU19FUSA9IDM7Ly89c3BhY2U/XHJcbnZhciBTX1YgPSA0Oy8vYXR0ciB2YWx1ZShubyBxdW90IHZhbHVlIG9ubHkpXHJcbnZhciBTX0UgPSA1Oy8vYXR0ciB2YWx1ZSBlbmQgYW5kIG5vIHNwYWNlKHF1b3QgZW5kKVxyXG52YXIgU19TID0gNjsvLyhhdHRyIHZhbHVlIGVuZCB8fCB0YWcgZW5kICkgJiYgKHNwYWNlIG9mZmVyKVxyXG52YXIgU19DID0gNzsvL2Nsb3NlZCBlbDxlbCAvPlxyXG5cclxuZnVuY3Rpb24gWE1MUmVhZGVyKCl7XHJcblx0XHJcbn1cclxuXHJcblhNTFJlYWRlci5wcm90b3R5cGUgPSB7XHJcblx0cGFyc2U6ZnVuY3Rpb24oc291cmNlLGRlZmF1bHROU01hcCxlbnRpdHlNYXApe1xyXG5cdFx0dmFyIGRvbUJ1aWxkZXIgPSB0aGlzLmRvbUJ1aWxkZXI7XHJcblx0XHRkb21CdWlsZGVyLnN0YXJ0RG9jdW1lbnQoKTtcclxuXHRcdF9jb3B5KGRlZmF1bHROU01hcCAsZGVmYXVsdE5TTWFwID0ge30pXHJcblx0XHRwYXJzZShzb3VyY2UsZGVmYXVsdE5TTWFwLGVudGl0eU1hcCxcclxuXHRcdFx0XHRkb21CdWlsZGVyLHRoaXMuZXJyb3JIYW5kbGVyKTtcclxuXHRcdGRvbUJ1aWxkZXIuZW5kRG9jdW1lbnQoKTtcclxuXHR9XHJcbn1cclxuZnVuY3Rpb24gcGFyc2Uoc291cmNlLGRlZmF1bHROU01hcENvcHksZW50aXR5TWFwLGRvbUJ1aWxkZXIsZXJyb3JIYW5kbGVyKXtcclxuICBmdW5jdGlvbiBmaXhlZEZyb21DaGFyQ29kZShjb2RlKSB7XHJcblx0XHQvLyBTdHJpbmcucHJvdG90eXBlLmZyb21DaGFyQ29kZSBkb2VzIG5vdCBzdXBwb3J0c1xyXG5cdFx0Ly8gPiAyIGJ5dGVzIHVuaWNvZGUgY2hhcnMgZGlyZWN0bHlcclxuXHRcdGlmIChjb2RlID4gMHhmZmZmKSB7XHJcblx0XHRcdGNvZGUgLT0gMHgxMDAwMDtcclxuXHRcdFx0dmFyIHN1cnJvZ2F0ZTEgPSAweGQ4MDAgKyAoY29kZSA+PiAxMClcclxuXHRcdFx0XHQsIHN1cnJvZ2F0ZTIgPSAweGRjMDAgKyAoY29kZSAmIDB4M2ZmKTtcclxuXHJcblx0XHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHN1cnJvZ2F0ZTEsIHN1cnJvZ2F0ZTIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGVudGl0eVJlcGxhY2VyKGEpe1xyXG5cdFx0dmFyIGsgPSBhLnNsaWNlKDEsLTEpO1xyXG5cdFx0aWYoayBpbiBlbnRpdHlNYXApe1xyXG5cdFx0XHRyZXR1cm4gZW50aXR5TWFwW2tdOyBcclxuXHRcdH1lbHNlIGlmKGsuY2hhckF0KDApID09PSAnIycpe1xyXG5cdFx0XHRyZXR1cm4gZml4ZWRGcm9tQ2hhckNvZGUocGFyc2VJbnQoay5zdWJzdHIoMSkucmVwbGFjZSgneCcsJzB4JykpKVxyXG5cdFx0fWVsc2V7XHJcblx0XHRcdGVycm9ySGFuZGxlci5lcnJvcignZW50aXR5IG5vdCBmb3VuZDonK2EpO1xyXG5cdFx0XHRyZXR1cm4gYTtcclxuXHRcdH1cclxuXHR9XHJcblx0ZnVuY3Rpb24gYXBwZW5kVGV4dChlbmQpey8vaGFzIHNvbWUgYnVnc1xyXG5cdFx0dmFyIHh0ID0gc291cmNlLnN1YnN0cmluZyhzdGFydCxlbmQpLnJlcGxhY2UoLyYjP1xcdys7L2csZW50aXR5UmVwbGFjZXIpO1xyXG5cdFx0bG9jYXRvciYmcG9zaXRpb24oc3RhcnQpO1xyXG5cdFx0ZG9tQnVpbGRlci5jaGFyYWN0ZXJzKHh0LDAsZW5kLXN0YXJ0KTtcclxuXHRcdHN0YXJ0ID0gZW5kXHJcblx0fVxyXG5cdGZ1bmN0aW9uIHBvc2l0aW9uKHN0YXJ0LG0pe1xyXG5cdFx0d2hpbGUoc3RhcnQ+PWVuZFBvcyAmJiAobSA9IGxpbmVQYXR0ZXJuLmV4ZWMoc291cmNlKSkpe1xyXG5cdFx0XHRzdGFydFBvcyA9IG0uaW5kZXg7XHJcblx0XHRcdGVuZFBvcyA9IHN0YXJ0UG9zICsgbVswXS5sZW5ndGg7XHJcblx0XHRcdGxvY2F0b3IubGluZU51bWJlcisrO1xyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCdsaW5lKys6Jyxsb2NhdG9yLHN0YXJ0UG9zLGVuZFBvcylcclxuXHRcdH1cclxuXHRcdGxvY2F0b3IuY29sdW1uTnVtYmVyID0gc3RhcnQtc3RhcnRQb3MrMTtcclxuXHR9XHJcblx0dmFyIHN0YXJ0UG9zID0gMDtcclxuXHR2YXIgZW5kUG9zID0gMDtcclxuXHR2YXIgbGluZVBhdHRlcm4gPSAvLisoPzpcXHJcXG4/fFxcbil8LiokL2dcclxuXHR2YXIgbG9jYXRvciA9IGRvbUJ1aWxkZXIubG9jYXRvcjtcclxuXHRcclxuXHR2YXIgcGFyc2VTdGFjayA9IFt7Y3VycmVudE5TTWFwOmRlZmF1bHROU01hcENvcHl9XVxyXG5cdHZhciBjbG9zZU1hcCA9IHt9O1xyXG5cdHZhciBzdGFydCA9IDA7XHJcblx0d2hpbGUodHJ1ZSl7XHJcblx0XHR2YXIgaSA9IHNvdXJjZS5pbmRleE9mKCc8JyxzdGFydCk7XHJcblx0XHRpZihpPDApe1xyXG5cdFx0XHRpZighc291cmNlLnN1YnN0cihzdGFydCkubWF0Y2goL15cXHMqJC8pKXtcclxuXHRcdFx0XHR2YXIgZG9jID0gZG9tQnVpbGRlci5kb2N1bWVudDtcclxuICAgIFx0XHRcdHZhciB0ZXh0ID0gZG9jLmNyZWF0ZVRleHROb2RlKHNvdXJjZS5zdWJzdHIoc3RhcnQpKTtcclxuICAgIFx0XHRcdGRvYy5hcHBlbmRDaGlsZCh0ZXh0KTtcclxuICAgIFx0XHRcdGRvbUJ1aWxkZXIuY3VycmVudEVsZW1lbnQgPSB0ZXh0O1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGlmKGk+c3RhcnQpe1xyXG5cdFx0XHRhcHBlbmRUZXh0KGkpO1xyXG5cdFx0fVxyXG5cdFx0c3dpdGNoKHNvdXJjZS5jaGFyQXQoaSsxKSl7XHJcblx0XHRjYXNlICcvJzpcclxuXHRcdFx0dmFyIGVuZCA9IHNvdXJjZS5pbmRleE9mKCc+JyxpKzMpO1xyXG5cdFx0XHR2YXIgdGFnTmFtZSA9IHNvdXJjZS5zdWJzdHJpbmcoaSsyLGVuZCk7XHJcblx0XHRcdHZhciBjb25maWcgPSBwYXJzZVN0YWNrLnBvcCgpO1xyXG5cdFx0XHR2YXIgbG9jYWxOU01hcCA9IGNvbmZpZy5sb2NhbE5TTWFwO1xyXG5cdFx0XHRcclxuXHQgICAgICAgIGlmKGNvbmZpZy50YWdOYW1lICE9IHRhZ05hbWUpe1xyXG5cdCAgICAgICAgICAgIGVycm9ySGFuZGxlci5mYXRhbEVycm9yKFwiZW5kIHRhZyBuYW1lOiBcIit0YWdOYW1lKycgaXMgbm90IG1hdGNoIHRoZSBjdXJyZW50IHN0YXJ0IHRhZ05hbWU6Jytjb25maWcudGFnTmFtZSApO1xyXG5cdCAgICAgICAgfVxyXG5cdFx0XHRkb21CdWlsZGVyLmVuZEVsZW1lbnQoY29uZmlnLnVyaSxjb25maWcubG9jYWxOYW1lLHRhZ05hbWUpO1xyXG5cdFx0XHRpZihsb2NhbE5TTWFwKXtcclxuXHRcdFx0XHRmb3IodmFyIHByZWZpeCBpbiBsb2NhbE5TTWFwKXtcclxuXHRcdFx0XHRcdGRvbUJ1aWxkZXIuZW5kUHJlZml4TWFwcGluZyhwcmVmaXgpIDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZW5kKys7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0XHQvLyBlbmQgZWxtZW50XHJcblx0XHRjYXNlICc/JzovLyA8Py4uLj8+XHJcblx0XHRcdGxvY2F0b3ImJnBvc2l0aW9uKGkpO1xyXG5cdFx0XHRlbmQgPSBwYXJzZUluc3RydWN0aW9uKHNvdXJjZSxpLGRvbUJ1aWxkZXIpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJyEnOi8vIDwhZG9jdHlwZSw8IVtDREFUQSw8IS0tXHJcblx0XHRcdGxvY2F0b3ImJnBvc2l0aW9uKGkpO1xyXG5cdFx0XHRlbmQgPSBwYXJzZURDQyhzb3VyY2UsaSxkb21CdWlsZGVyLGVycm9ySGFuZGxlcik7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0dHJ5e1xyXG5cdFx0XHRcdGxvY2F0b3ImJnBvc2l0aW9uKGkpO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdHZhciBlbCA9IG5ldyBFbGVtZW50QXR0cmlidXRlcygpO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vZWxTdGFydEVuZFxyXG5cdFx0XHRcdHZhciBlbmQgPSBwYXJzZUVsZW1lbnRTdGFydFBhcnQoc291cmNlLGksZWwsZW50aXR5UmVwbGFjZXIsZXJyb3JIYW5kbGVyKTtcclxuXHRcdFx0XHR2YXIgbGVuID0gZWwubGVuZ3RoO1xyXG5cdFx0XHRcdC8vcG9zaXRpb24gZml4ZWRcclxuXHRcdFx0XHRpZihsZW4gJiYgbG9jYXRvcil7XHJcblx0XHRcdFx0XHR2YXIgYmFja3VwID0gY29weUxvY2F0b3IobG9jYXRvcix7fSk7XHJcblx0XHRcdFx0XHRmb3IodmFyIGkgPSAwO2k8bGVuO2krKyl7XHJcblx0XHRcdFx0XHRcdHZhciBhID0gZWxbaV07XHJcblx0XHRcdFx0XHRcdHBvc2l0aW9uKGEub2Zmc2V0KTtcclxuXHRcdFx0XHRcdFx0YS5vZmZzZXQgPSBjb3B5TG9jYXRvcihsb2NhdG9yLHt9KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGNvcHlMb2NhdG9yKGJhY2t1cCxsb2NhdG9yKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoIWVsLmNsb3NlZCAmJiBmaXhTZWxmQ2xvc2VkKHNvdXJjZSxlbmQsZWwudGFnTmFtZSxjbG9zZU1hcCkpe1xyXG5cdFx0XHRcdFx0ZWwuY2xvc2VkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGlmKCFlbnRpdHlNYXAubmJzcCl7XHJcblx0XHRcdFx0XHRcdGVycm9ySGFuZGxlci53YXJuaW5nKCd1bmNsb3NlZCB4bWwgYXR0cmlidXRlJyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGFwcGVuZEVsZW1lbnQoZWwsZG9tQnVpbGRlcixwYXJzZVN0YWNrKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRpZihlbC51cmkgPT09ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyAmJiAhZWwuY2xvc2VkKXtcclxuXHRcdFx0XHRcdGVuZCA9IHBhcnNlSHRtbFNwZWNpYWxDb250ZW50KHNvdXJjZSxlbmQsZWwudGFnTmFtZSxlbnRpdHlSZXBsYWNlcixkb21CdWlsZGVyKVxyXG5cdFx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdFx0ZW5kKys7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9Y2F0Y2goZSl7XHJcblx0XHRcdFx0ZXJyb3JIYW5kbGVyLmVycm9yKCdlbGVtZW50IHBhcnNlIGVycm9yOiAnK2UpO1xyXG5cdFx0XHRcdGVuZCA9IC0xO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cdFx0aWYoZW5kPDApe1xyXG5cdFx0XHQvL1RPRE86IOi/memHjOacieWPr+iDvXNheOWbnumAgO+8jOacieS9jee9rumUmeivr+mjjumZqVxyXG5cdFx0XHRhcHBlbmRUZXh0KGkrMSk7XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0c3RhcnQgPSBlbmQ7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbmZ1bmN0aW9uIGNvcHlMb2NhdG9yKGYsdCl7XHJcblx0dC5saW5lTnVtYmVyID0gZi5saW5lTnVtYmVyO1xyXG5cdHQuY29sdW1uTnVtYmVyID0gZi5jb2x1bW5OdW1iZXI7XHJcblx0cmV0dXJuIHQ7XHJcblx0XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAc2VlICNhcHBlbmRFbGVtZW50KHNvdXJjZSxlbFN0YXJ0RW5kLGVsLHNlbGZDbG9zZWQsZW50aXR5UmVwbGFjZXIsZG9tQnVpbGRlcixwYXJzZVN0YWNrKTtcclxuICogQHJldHVybiBlbmQgb2YgdGhlIGVsZW1lbnRTdGFydFBhcnQoZW5kIG9mIGVsZW1lbnRFbmRQYXJ0IGZvciBzZWxmQ2xvc2VkIGVsKVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VFbGVtZW50U3RhcnRQYXJ0KHNvdXJjZSxzdGFydCxlbCxlbnRpdHlSZXBsYWNlcixlcnJvckhhbmRsZXIpe1xyXG5cdHZhciBhdHRyTmFtZTtcclxuXHR2YXIgdmFsdWU7XHJcblx0dmFyIHAgPSArK3N0YXJ0O1xyXG5cdHZhciBzID0gU19UQUc7Ly9zdGF0dXNcclxuXHR3aGlsZSh0cnVlKXtcclxuXHRcdHZhciBjID0gc291cmNlLmNoYXJBdChwKTtcclxuXHRcdHN3aXRjaChjKXtcclxuXHRcdGNhc2UgJz0nOlxyXG5cdFx0XHRpZihzID09PSBTX0FUVFIpey8vYXR0ck5hbWVcclxuXHRcdFx0XHRhdHRyTmFtZSA9IHNvdXJjZS5zbGljZShzdGFydCxwKTtcclxuXHRcdFx0XHRzID0gU19FUTtcclxuXHRcdFx0fWVsc2UgaWYocyA9PT0gU19BVFRSX1Mpe1xyXG5cdFx0XHRcdHMgPSBTX0VRO1xyXG5cdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHQvL2ZhdGFsRXJyb3I6IGVxdWFsIG11c3QgYWZ0ZXIgYXR0ck5hbWUgb3Igc3BhY2UgYWZ0ZXIgYXR0ck5hbWVcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2F0dHJpYnV0ZSBlcXVhbCBtdXN0IGFmdGVyIGF0dHJOYW1lJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlICdcXCcnOlxyXG5cdFx0Y2FzZSAnXCInOlxyXG5cdFx0XHRpZihzID09PSBTX0VRKXsvL2VxdWFsXHJcblx0XHRcdFx0c3RhcnQgPSBwKzE7XHJcblx0XHRcdFx0cCA9IHNvdXJjZS5pbmRleE9mKGMsc3RhcnQpXHJcblx0XHRcdFx0aWYocD4wKXtcclxuXHRcdFx0XHRcdHZhbHVlID0gc291cmNlLnNsaWNlKHN0YXJ0LHApLnJlcGxhY2UoLyYjP1xcdys7L2csZW50aXR5UmVwbGFjZXIpO1xyXG5cdFx0XHRcdFx0ZWwuYWRkKGF0dHJOYW1lLHZhbHVlLHN0YXJ0LTEpO1xyXG5cdFx0XHRcdFx0cyA9IFNfRTtcclxuXHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdC8vZmF0YWxFcnJvcjogbm8gZW5kIHF1b3QgbWF0Y2hcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignYXR0cmlidXRlIHZhbHVlIG5vIGVuZCBcXCcnK2MrJ1xcJyBtYXRjaCcpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fWVsc2UgaWYocyA9PSBTX1Ype1xyXG5cdFx0XHRcdHZhbHVlID0gc291cmNlLnNsaWNlKHN0YXJ0LHApLnJlcGxhY2UoLyYjP1xcdys7L2csZW50aXR5UmVwbGFjZXIpO1xyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coYXR0ck5hbWUsdmFsdWUsc3RhcnQscClcclxuXHRcdFx0XHRlbC5hZGQoYXR0ck5hbWUsdmFsdWUsc3RhcnQpO1xyXG5cdFx0XHRcdC8vY29uc29sZS5kaXIoZWwpXHJcblx0XHRcdFx0ZXJyb3JIYW5kbGVyLndhcm5pbmcoJ2F0dHJpYnV0ZSBcIicrYXR0ck5hbWUrJ1wiIG1pc3NlZCBzdGFydCBxdW90KCcrYysnKSEhJyk7XHJcblx0XHRcdFx0c3RhcnQgPSBwKzE7XHJcblx0XHRcdFx0cyA9IFNfRVxyXG5cdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHQvL2ZhdGFsRXJyb3I6IG5vIGVxdWFsIGJlZm9yZVxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignYXR0cmlidXRlIHZhbHVlIG11c3QgYWZ0ZXIgXCI9XCInKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJy8nOlxyXG5cdFx0XHRzd2l0Y2gocyl7XHJcblx0XHRcdGNhc2UgU19UQUc6XHJcblx0XHRcdFx0ZWwuc2V0VGFnTmFtZShzb3VyY2Uuc2xpY2Uoc3RhcnQscCkpO1xyXG5cdFx0XHRjYXNlIFNfRTpcclxuXHRcdFx0Y2FzZSBTX1M6XHJcblx0XHRcdGNhc2UgU19DOlxyXG5cdFx0XHRcdHMgPSBTX0M7XHJcblx0XHRcdFx0ZWwuY2xvc2VkID0gdHJ1ZTtcclxuXHRcdFx0Y2FzZSBTX1Y6XHJcblx0XHRcdGNhc2UgU19BVFRSOlxyXG5cdFx0XHRjYXNlIFNfQVRUUl9TOlxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHQvL2Nhc2UgU19FUTpcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJhdHRyaWJ1dGUgaW52YWxpZCBjbG9zZSBjaGFyKCcvJylcIilcclxuXHRcdFx0fVxyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJyc6Ly9lbmQgZG9jdW1lbnRcclxuXHRcdFx0Ly90aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0JylcclxuXHRcdFx0ZXJyb3JIYW5kbGVyLmVycm9yKCd1bmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xyXG5cdFx0Y2FzZSAnPic6XHJcblx0XHRcdHN3aXRjaChzKXtcclxuXHRcdFx0Y2FzZSBTX1RBRzpcclxuXHRcdFx0XHRlbC5zZXRUYWdOYW1lKHNvdXJjZS5zbGljZShzdGFydCxwKSk7XHJcblx0XHRcdGNhc2UgU19FOlxyXG5cdFx0XHRjYXNlIFNfUzpcclxuXHRcdFx0Y2FzZSBTX0M6XHJcblx0XHRcdFx0YnJlYWs7Ly9ub3JtYWxcclxuXHRcdFx0Y2FzZSBTX1Y6Ly9Db21wYXRpYmxlIHN0YXRlXHJcblx0XHRcdGNhc2UgU19BVFRSOlxyXG5cdFx0XHRcdHZhbHVlID0gc291cmNlLnNsaWNlKHN0YXJ0LHApO1xyXG5cdFx0XHRcdGlmKHZhbHVlLnNsaWNlKC0xKSA9PT0gJy8nKXtcclxuXHRcdFx0XHRcdGVsLmNsb3NlZCAgPSB0cnVlO1xyXG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5zbGljZSgwLC0xKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0Y2FzZSBTX0FUVFJfUzpcclxuXHRcdFx0XHRpZihzID09PSBTX0FUVFJfUyl7XHJcblx0XHRcdFx0XHR2YWx1ZSA9IGF0dHJOYW1lO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihzID09IFNfVil7XHJcblx0XHRcdFx0XHRlcnJvckhhbmRsZXIud2FybmluZygnYXR0cmlidXRlIFwiJyt2YWx1ZSsnXCIgbWlzc2VkIHF1b3QoXCIpISEnKTtcclxuXHRcdFx0XHRcdGVsLmFkZChhdHRyTmFtZSx2YWx1ZS5yZXBsYWNlKC8mIz9cXHcrOy9nLGVudGl0eVJlcGxhY2VyKSxzdGFydClcclxuXHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdGVycm9ySGFuZGxlci53YXJuaW5nKCdhdHRyaWJ1dGUgXCInK3ZhbHVlKydcIiBtaXNzZWQgdmFsdWUhISBcIicrdmFsdWUrJ1wiIGluc3RlYWQhIScpXHJcblx0XHRcdFx0XHRlbC5hZGQodmFsdWUsdmFsdWUsc3RhcnQpXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFNfRVE6XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdhdHRyaWJ1dGUgdmFsdWUgbWlzc2VkISEnKTtcclxuXHRcdFx0fVxyXG4vL1x0XHRcdGNvbnNvbGUubG9nKHRhZ05hbWUsdGFnTmFtZVBhdHRlcm4sdGFnTmFtZVBhdHRlcm4udGVzdCh0YWdOYW1lKSlcclxuXHRcdFx0cmV0dXJuIHA7XHJcblx0XHQvKnhtbCBzcGFjZSAnXFx4MjAnIHwgI3g5IHwgI3hEIHwgI3hBOyAqL1xyXG5cdFx0Y2FzZSAnXFx1MDA4MCc6XHJcblx0XHRcdGMgPSAnICc7XHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHRpZihjPD0gJyAnKXsvL3NwYWNlXHJcblx0XHRcdFx0c3dpdGNoKHMpe1xyXG5cdFx0XHRcdGNhc2UgU19UQUc6XHJcblx0XHRcdFx0XHRlbC5zZXRUYWdOYW1lKHNvdXJjZS5zbGljZShzdGFydCxwKSk7Ly90YWdOYW1lXHJcblx0XHRcdFx0XHRzID0gU19TO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBTX0FUVFI6XHJcblx0XHRcdFx0XHRhdHRyTmFtZSA9IHNvdXJjZS5zbGljZShzdGFydCxwKVxyXG5cdFx0XHRcdFx0cyA9IFNfQVRUUl9TO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBTX1Y6XHJcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQscCkucmVwbGFjZSgvJiM/XFx3KzsvZyxlbnRpdHlSZXBsYWNlcik7XHJcblx0XHRcdFx0XHRlcnJvckhhbmRsZXIud2FybmluZygnYXR0cmlidXRlIFwiJyt2YWx1ZSsnXCIgbWlzc2VkIHF1b3QoXCIpISEnKTtcclxuXHRcdFx0XHRcdGVsLmFkZChhdHRyTmFtZSx2YWx1ZSxzdGFydClcclxuXHRcdFx0XHRjYXNlIFNfRTpcclxuXHRcdFx0XHRcdHMgPSBTX1M7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHQvL2Nhc2UgU19TOlxyXG5cdFx0XHRcdC8vY2FzZSBTX0VROlxyXG5cdFx0XHRcdC8vY2FzZSBTX0FUVFJfUzpcclxuXHRcdFx0XHQvL1x0dm9pZCgpO2JyZWFrO1xyXG5cdFx0XHRcdC8vY2FzZSBTX0M6XHJcblx0XHRcdFx0XHQvL2lnbm9yZSB3YXJuaW5nXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9ZWxzZXsvL25vdCBzcGFjZVxyXG4vL1NfVEFHLFx0U19BVFRSLFx0U19FUSxcdFNfVlxyXG4vL1NfQVRUUl9TLFx0U19FLFx0U19TLFx0U19DXHJcblx0XHRcdFx0c3dpdGNoKHMpe1xyXG5cdFx0XHRcdC8vY2FzZSBTX1RBRzp2b2lkKCk7YnJlYWs7XHJcblx0XHRcdFx0Ly9jYXNlIFNfQVRUUjp2b2lkKCk7YnJlYWs7XHJcblx0XHRcdFx0Ly9jYXNlIFNfVjp2b2lkKCk7YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBTX0FUVFJfUzpcclxuXHRcdFx0XHRcdGVycm9ySGFuZGxlci53YXJuaW5nKCdhdHRyaWJ1dGUgXCInK2F0dHJOYW1lKydcIiBtaXNzZWQgdmFsdWUhISBcIicrYXR0ck5hbWUrJ1wiIGluc3RlYWQhIScpXHJcblx0XHRcdFx0XHRlbC5hZGQoYXR0ck5hbWUsYXR0ck5hbWUsc3RhcnQpO1xyXG5cdFx0XHRcdFx0c3RhcnQgPSBwO1xyXG5cdFx0XHRcdFx0cyA9IFNfQVRUUjtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgU19FOlxyXG5cdFx0XHRcdFx0ZXJyb3JIYW5kbGVyLndhcm5pbmcoJ2F0dHJpYnV0ZSBzcGFjZSBpcyByZXF1aXJlZFwiJythdHRyTmFtZSsnXCIhIScpXHJcblx0XHRcdFx0Y2FzZSBTX1M6XHJcblx0XHRcdFx0XHRzID0gU19BVFRSO1xyXG5cdFx0XHRcdFx0c3RhcnQgPSBwO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBTX0VROlxyXG5cdFx0XHRcdFx0cyA9IFNfVjtcclxuXHRcdFx0XHRcdHN0YXJ0ID0gcDtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgU19DOlxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZWxlbWVudHMgY2xvc2VkIGNoYXJhY3RlciAnLycgYW5kICc+JyBtdXN0IGJlIGNvbm5lY3RlZCB0b1wiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHArKztcclxuXHR9XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm4gZW5kIG9mIHRoZSBlbGVtZW50U3RhcnRQYXJ0KGVuZCBvZiBlbGVtZW50RW5kUGFydCBmb3Igc2VsZkNsb3NlZCBlbClcclxuICovXHJcbmZ1bmN0aW9uIGFwcGVuZEVsZW1lbnQoZWwsZG9tQnVpbGRlcixwYXJzZVN0YWNrKXtcclxuXHR2YXIgdGFnTmFtZSA9IGVsLnRhZ05hbWU7XHJcblx0dmFyIGxvY2FsTlNNYXAgPSBudWxsO1xyXG5cdHZhciBjdXJyZW50TlNNYXAgPSBwYXJzZVN0YWNrW3BhcnNlU3RhY2subGVuZ3RoLTFdLmN1cnJlbnROU01hcDtcclxuXHR2YXIgaSA9IGVsLmxlbmd0aDtcclxuXHR3aGlsZShpLS0pe1xyXG5cdFx0dmFyIGEgPSBlbFtpXTtcclxuXHRcdHZhciBxTmFtZSA9IGEucU5hbWU7XHJcblx0XHR2YXIgdmFsdWUgPSBhLnZhbHVlO1xyXG5cdFx0dmFyIG5zcCA9IHFOYW1lLmluZGV4T2YoJzonKTtcclxuXHRcdGlmKG5zcD4wKXtcclxuXHRcdFx0dmFyIHByZWZpeCA9IGEucHJlZml4ID0gcU5hbWUuc2xpY2UoMCxuc3ApO1xyXG5cdFx0XHR2YXIgbG9jYWxOYW1lID0gcU5hbWUuc2xpY2UobnNwKzEpO1xyXG5cdFx0XHR2YXIgbnNQcmVmaXggPSBwcmVmaXggPT09ICd4bWxucycgJiYgbG9jYWxOYW1lXHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0bG9jYWxOYW1lID0gcU5hbWU7XHJcblx0XHRcdHByZWZpeCA9IG51bGxcclxuXHRcdFx0bnNQcmVmaXggPSBxTmFtZSA9PT0gJ3htbG5zJyAmJiAnJ1xyXG5cdFx0fVxyXG5cdFx0Ly9jYW4gbm90IHNldCBwcmVmaXgsYmVjYXVzZSBwcmVmaXggIT09ICcnXHJcblx0XHRhLmxvY2FsTmFtZSA9IGxvY2FsTmFtZSA7XHJcblx0XHQvL3ByZWZpeCA9PSBudWxsIGZvciBubyBucyBwcmVmaXggYXR0cmlidXRlIFxyXG5cdFx0aWYobnNQcmVmaXggIT09IGZhbHNlKXsvL2hhY2shIVxyXG5cdFx0XHRpZihsb2NhbE5TTWFwID09IG51bGwpe1xyXG5cdFx0XHRcdGxvY2FsTlNNYXAgPSB7fVxyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coY3VycmVudE5TTWFwLDApXHJcblx0XHRcdFx0X2NvcHkoY3VycmVudE5TTWFwLGN1cnJlbnROU01hcD17fSlcclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKGN1cnJlbnROU01hcCwxKVxyXG5cdFx0XHR9XHJcblx0XHRcdGN1cnJlbnROU01hcFtuc1ByZWZpeF0gPSBsb2NhbE5TTWFwW25zUHJlZml4XSA9IHZhbHVlO1xyXG5cdFx0XHRhLnVyaSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLydcclxuXHRcdFx0ZG9tQnVpbGRlci5zdGFydFByZWZpeE1hcHBpbmcobnNQcmVmaXgsIHZhbHVlKSBcclxuXHRcdH1cclxuXHR9XHJcblx0dmFyIGkgPSBlbC5sZW5ndGg7XHJcblx0d2hpbGUoaS0tKXtcclxuXHRcdGEgPSBlbFtpXTtcclxuXHRcdHZhciBwcmVmaXggPSBhLnByZWZpeDtcclxuXHRcdGlmKHByZWZpeCl7Ly9ubyBwcmVmaXggYXR0cmlidXRlIGhhcyBubyBuYW1lc3BhY2VcclxuXHRcdFx0aWYocHJlZml4ID09PSAneG1sJyl7XHJcblx0XHRcdFx0YS51cmkgPSAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJztcclxuXHRcdFx0fWlmKHByZWZpeCAhPT0gJ3htbG5zJyl7XHJcblx0XHRcdFx0YS51cmkgPSBjdXJyZW50TlNNYXBbcHJlZml4XVxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8ve2NvbnNvbGUubG9nKCcjIyMnK2EucU5hbWUsZG9tQnVpbGRlci5sb2NhdG9yLnN5c3RlbUlkKycnLGN1cnJlbnROU01hcCxhLnVyaSl9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0dmFyIG5zcCA9IHRhZ05hbWUuaW5kZXhPZignOicpO1xyXG5cdGlmKG5zcD4wKXtcclxuXHRcdHByZWZpeCA9IGVsLnByZWZpeCA9IHRhZ05hbWUuc2xpY2UoMCxuc3ApO1xyXG5cdFx0bG9jYWxOYW1lID0gZWwubG9jYWxOYW1lID0gdGFnTmFtZS5zbGljZShuc3ArMSk7XHJcblx0fWVsc2V7XHJcblx0XHRwcmVmaXggPSBudWxsOy8vaW1wb3J0YW50ISFcclxuXHRcdGxvY2FsTmFtZSA9IGVsLmxvY2FsTmFtZSA9IHRhZ05hbWU7XHJcblx0fVxyXG5cdC8vbm8gcHJlZml4IGVsZW1lbnQgaGFzIGRlZmF1bHQgbmFtZXNwYWNlXHJcblx0dmFyIG5zID0gZWwudXJpID0gY3VycmVudE5TTWFwW3ByZWZpeCB8fCAnJ107XHJcblx0ZG9tQnVpbGRlci5zdGFydEVsZW1lbnQobnMsbG9jYWxOYW1lLHRhZ05hbWUsZWwpO1xyXG5cdC8vZW5kUHJlZml4TWFwcGluZyBhbmQgc3RhcnRQcmVmaXhNYXBwaW5nIGhhdmUgbm90IGFueSBoZWxwIGZvciBkb20gYnVpbGRlclxyXG5cdC8vbG9jYWxOU01hcCA9IG51bGxcclxuXHRpZihlbC5jbG9zZWQpe1xyXG5cdFx0ZG9tQnVpbGRlci5lbmRFbGVtZW50KG5zLGxvY2FsTmFtZSx0YWdOYW1lKTtcclxuXHRcdGlmKGxvY2FsTlNNYXApe1xyXG5cdFx0XHRmb3IocHJlZml4IGluIGxvY2FsTlNNYXApe1xyXG5cdFx0XHRcdGRvbUJ1aWxkZXIuZW5kUHJlZml4TWFwcGluZyhwcmVmaXgpIFxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fWVsc2V7XHJcblx0XHRlbC5jdXJyZW50TlNNYXAgPSBjdXJyZW50TlNNYXA7XHJcblx0XHRlbC5sb2NhbE5TTWFwID0gbG9jYWxOU01hcDtcclxuXHRcdHBhcnNlU3RhY2sucHVzaChlbCk7XHJcblx0fVxyXG59XHJcbmZ1bmN0aW9uIHBhcnNlSHRtbFNwZWNpYWxDb250ZW50KHNvdXJjZSxlbFN0YXJ0RW5kLHRhZ05hbWUsZW50aXR5UmVwbGFjZXIsZG9tQnVpbGRlcil7XHJcblx0aWYoL14oPzpzY3JpcHR8dGV4dGFyZWEpJC9pLnRlc3QodGFnTmFtZSkpe1xyXG5cdFx0dmFyIGVsRW5kU3RhcnQgPSAgc291cmNlLmluZGV4T2YoJzwvJyt0YWdOYW1lKyc+JyxlbFN0YXJ0RW5kKTtcclxuXHRcdHZhciB0ZXh0ID0gc291cmNlLnN1YnN0cmluZyhlbFN0YXJ0RW5kKzEsZWxFbmRTdGFydCk7XHJcblx0XHRpZigvWyY8XS8udGVzdCh0ZXh0KSl7XHJcblx0XHRcdGlmKC9ec2NyaXB0JC9pLnRlc3QodGFnTmFtZSkpe1xyXG5cdFx0XHRcdC8vaWYoIS9cXF1cXF0+Ly50ZXN0KHRleHQpKXtcclxuXHRcdFx0XHRcdC8vbGV4SGFuZGxlci5zdGFydENEQVRBKCk7XHJcblx0XHRcdFx0XHRkb21CdWlsZGVyLmNoYXJhY3RlcnModGV4dCwwLHRleHQubGVuZ3RoKTtcclxuXHRcdFx0XHRcdC8vbGV4SGFuZGxlci5lbmRDREFUQSgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGVsRW5kU3RhcnQ7XHJcblx0XHRcdFx0Ly99XHJcblx0XHRcdH0vL31lbHNley8vdGV4dCBhcmVhXHJcblx0XHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvJiM/XFx3KzsvZyxlbnRpdHlSZXBsYWNlcik7XHJcblx0XHRcdFx0ZG9tQnVpbGRlci5jaGFyYWN0ZXJzKHRleHQsMCx0ZXh0Lmxlbmd0aCk7XHJcblx0XHRcdFx0cmV0dXJuIGVsRW5kU3RhcnQ7XHJcblx0XHRcdC8vfVxyXG5cdFx0XHRcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGVsU3RhcnRFbmQrMTtcclxufVxyXG5mdW5jdGlvbiBmaXhTZWxmQ2xvc2VkKHNvdXJjZSxlbFN0YXJ0RW5kLHRhZ05hbWUsY2xvc2VNYXApe1xyXG5cdC8vaWYodGFnTmFtZSBpbiBjbG9zZU1hcCl7XHJcblx0dmFyIHBvcyA9IGNsb3NlTWFwW3RhZ05hbWVdO1xyXG5cdGlmKHBvcyA9PSBudWxsKXtcclxuXHRcdC8vY29uc29sZS5sb2codGFnTmFtZSlcclxuXHRcdHBvcyA9IGNsb3NlTWFwW3RhZ05hbWVdID0gc291cmNlLmxhc3RJbmRleE9mKCc8LycrdGFnTmFtZSsnPicpXHJcblx0fVxyXG5cdHJldHVybiBwb3M8ZWxTdGFydEVuZDtcclxuXHQvL30gXHJcbn1cclxuZnVuY3Rpb24gX2NvcHkoc291cmNlLHRhcmdldCl7XHJcblx0Zm9yKHZhciBuIGluIHNvdXJjZSl7dGFyZ2V0W25dID0gc291cmNlW25dfVxyXG59XHJcbmZ1bmN0aW9uIHBhcnNlRENDKHNvdXJjZSxzdGFydCxkb21CdWlsZGVyLGVycm9ySGFuZGxlcil7Ly9zdXJlIHN0YXJ0IHdpdGggJzwhJ1xyXG5cdHZhciBuZXh0PSBzb3VyY2UuY2hhckF0KHN0YXJ0KzIpXHJcblx0c3dpdGNoKG5leHQpe1xyXG5cdGNhc2UgJy0nOlxyXG5cdFx0aWYoc291cmNlLmNoYXJBdChzdGFydCArIDMpID09PSAnLScpe1xyXG5cdFx0XHR2YXIgZW5kID0gc291cmNlLmluZGV4T2YoJy0tPicsc3RhcnQrNCk7XHJcblx0XHRcdC8vYXBwZW5kIGNvbW1lbnQgc291cmNlLnN1YnN0cmluZyg0LGVuZCkvLzwhLS1cclxuXHRcdFx0aWYoZW5kPnN0YXJ0KXtcclxuXHRcdFx0XHRkb21CdWlsZGVyLmNvbW1lbnQoc291cmNlLHN0YXJ0KzQsZW5kLXN0YXJ0LTQpO1xyXG5cdFx0XHRcdHJldHVybiBlbmQrMztcclxuXHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0ZXJyb3JIYW5kbGVyLmVycm9yKFwiVW5jbG9zZWQgY29tbWVudFwiKTtcclxuXHRcdFx0XHRyZXR1cm4gLTE7XHJcblx0XHRcdH1cclxuXHRcdH1lbHNle1xyXG5cdFx0XHQvL2Vycm9yXHJcblx0XHRcdHJldHVybiAtMTtcclxuXHRcdH1cclxuXHRkZWZhdWx0OlxyXG5cdFx0aWYoc291cmNlLnN1YnN0cihzdGFydCszLDYpID09ICdDREFUQVsnKXtcclxuXHRcdFx0dmFyIGVuZCA9IHNvdXJjZS5pbmRleE9mKCddXT4nLHN0YXJ0KzkpO1xyXG5cdFx0XHRkb21CdWlsZGVyLnN0YXJ0Q0RBVEEoKTtcclxuXHRcdFx0ZG9tQnVpbGRlci5jaGFyYWN0ZXJzKHNvdXJjZSxzdGFydCs5LGVuZC1zdGFydC05KTtcclxuXHRcdFx0ZG9tQnVpbGRlci5lbmRDREFUQSgpIFxyXG5cdFx0XHRyZXR1cm4gZW5kKzM7XHJcblx0XHR9XHJcblx0XHQvLzwhRE9DVFlQRVxyXG5cdFx0Ly9zdGFydERURChqYXZhLmxhbmcuU3RyaW5nIG5hbWUsIGphdmEubGFuZy5TdHJpbmcgcHVibGljSWQsIGphdmEubGFuZy5TdHJpbmcgc3lzdGVtSWQpIFxyXG5cdFx0dmFyIG1hdGNocyA9IHNwbGl0KHNvdXJjZSxzdGFydCk7XHJcblx0XHR2YXIgbGVuID0gbWF0Y2hzLmxlbmd0aDtcclxuXHRcdGlmKGxlbj4xICYmIC8hZG9jdHlwZS9pLnRlc3QobWF0Y2hzWzBdWzBdKSl7XHJcblx0XHRcdHZhciBuYW1lID0gbWF0Y2hzWzFdWzBdO1xyXG5cdFx0XHR2YXIgcHViaWQgPSBsZW4+MyAmJiAvXnB1YmxpYyQvaS50ZXN0KG1hdGNoc1syXVswXSkgJiYgbWF0Y2hzWzNdWzBdXHJcblx0XHRcdHZhciBzeXNpZCA9IGxlbj40ICYmIG1hdGNoc1s0XVswXTtcclxuXHRcdFx0dmFyIGxhc3RNYXRjaCA9IG1hdGNoc1tsZW4tMV1cclxuXHRcdFx0ZG9tQnVpbGRlci5zdGFydERURChuYW1lLHB1YmlkICYmIHB1YmlkLnJlcGxhY2UoL14oWydcIl0pKC4qPylcXDEkLywnJDInKSxcclxuXHRcdFx0XHRcdHN5c2lkICYmIHN5c2lkLnJlcGxhY2UoL14oWydcIl0pKC4qPylcXDEkLywnJDInKSk7XHJcblx0XHRcdGRvbUJ1aWxkZXIuZW5kRFREKCk7XHJcblx0XHRcdFxyXG5cdFx0XHRyZXR1cm4gbGFzdE1hdGNoLmluZGV4K2xhc3RNYXRjaFswXS5sZW5ndGhcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIC0xO1xyXG59XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIHBhcnNlSW5zdHJ1Y3Rpb24oc291cmNlLHN0YXJ0LGRvbUJ1aWxkZXIpe1xyXG5cdHZhciBlbmQgPSBzb3VyY2UuaW5kZXhPZignPz4nLHN0YXJ0KTtcclxuXHRpZihlbmQpe1xyXG5cdFx0dmFyIG1hdGNoID0gc291cmNlLnN1YnN0cmluZyhzdGFydCxlbmQpLm1hdGNoKC9ePFxcPyhcXFMqKVxccyooW1xcc1xcU10qPylcXHMqJC8pO1xyXG5cdFx0aWYobWF0Y2gpe1xyXG5cdFx0XHR2YXIgbGVuID0gbWF0Y2hbMF0ubGVuZ3RoO1xyXG5cdFx0XHRkb21CdWlsZGVyLnByb2Nlc3NpbmdJbnN0cnVjdGlvbihtYXRjaFsxXSwgbWF0Y2hbMl0pIDtcclxuXHRcdFx0cmV0dXJuIGVuZCsyO1xyXG5cdFx0fWVsc2V7Ly9lcnJvclxyXG5cdFx0XHRyZXR1cm4gLTE7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiAtMTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSBzb3VyY2VcclxuICovXHJcbmZ1bmN0aW9uIEVsZW1lbnRBdHRyaWJ1dGVzKHNvdXJjZSl7XHJcblx0XHJcbn1cclxuRWxlbWVudEF0dHJpYnV0ZXMucHJvdG90eXBlID0ge1xyXG5cdHNldFRhZ05hbWU6ZnVuY3Rpb24odGFnTmFtZSl7XHJcblx0XHRpZighdGFnTmFtZVBhdHRlcm4udGVzdCh0YWdOYW1lKSl7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0YWdOYW1lOicrdGFnTmFtZSlcclxuXHRcdH1cclxuXHRcdHRoaXMudGFnTmFtZSA9IHRhZ05hbWVcclxuXHR9LFxyXG5cdGFkZDpmdW5jdGlvbihxTmFtZSx2YWx1ZSxvZmZzZXQpe1xyXG5cdFx0aWYoIXRhZ05hbWVQYXR0ZXJuLnRlc3QocU5hbWUpKXtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGF0dHJpYnV0ZTonK3FOYW1lKVxyXG5cdFx0fVxyXG5cdFx0dGhpc1t0aGlzLmxlbmd0aCsrXSA9IHtxTmFtZTpxTmFtZSx2YWx1ZTp2YWx1ZSxvZmZzZXQ6b2Zmc2V0fVxyXG5cdH0sXHJcblx0bGVuZ3RoOjAsXHJcblx0Z2V0TG9jYWxOYW1lOmZ1bmN0aW9uKGkpe3JldHVybiB0aGlzW2ldLmxvY2FsTmFtZX0sXHJcblx0Z2V0T2Zmc2V0OmZ1bmN0aW9uKGkpe3JldHVybiB0aGlzW2ldLm9mZnNldH0sXHJcblx0Z2V0UU5hbWU6ZnVuY3Rpb24oaSl7cmV0dXJuIHRoaXNbaV0ucU5hbWV9LFxyXG5cdGdldFVSSTpmdW5jdGlvbihpKXtyZXR1cm4gdGhpc1tpXS51cml9LFxyXG5cdGdldFZhbHVlOmZ1bmN0aW9uKGkpe3JldHVybiB0aGlzW2ldLnZhbHVlfVxyXG4vL1x0LGdldEluZGV4OmZ1bmN0aW9uKHVyaSwgbG9jYWxOYW1lKSl7XHJcbi8vXHRcdGlmKGxvY2FsTmFtZSl7XHJcbi8vXHRcdFx0XHJcbi8vXHRcdH1lbHNle1xyXG4vL1x0XHRcdHZhciBxTmFtZSA9IHVyaVxyXG4vL1x0XHR9XHJcbi8vXHR9LFxyXG4vL1x0Z2V0VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRWYWx1ZSh0aGlzLmdldEluZGV4LmFwcGx5KHRoaXMsYXJndW1lbnRzKSl9LFxyXG4vL1x0Z2V0VHlwZTpmdW5jdGlvbih1cmksbG9jYWxOYW1lKXt9XHJcbi8vXHRnZXRUeXBlOmZ1bmN0aW9uKGkpe30sXHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIF9zZXRfcHJvdG9fKHRoaXoscGFyZW50KXtcclxuXHR0aGl6Ll9fcHJvdG9fXyA9IHBhcmVudDtcclxuXHRyZXR1cm4gdGhpejtcclxufVxyXG5pZighKF9zZXRfcHJvdG9fKHt9LF9zZXRfcHJvdG9fLnByb3RvdHlwZSkgaW5zdGFuY2VvZiBfc2V0X3Byb3RvXykpe1xyXG5cdF9zZXRfcHJvdG9fID0gZnVuY3Rpb24odGhpeixwYXJlbnQpe1xyXG5cdFx0ZnVuY3Rpb24gcCgpe307XHJcblx0XHRwLnByb3RvdHlwZSA9IHBhcmVudDtcclxuXHRcdHAgPSBuZXcgcCgpO1xyXG5cdFx0Zm9yKHBhcmVudCBpbiB0aGl6KXtcclxuXHRcdFx0cFtwYXJlbnRdID0gdGhpeltwYXJlbnRdO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHA7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBzcGxpdChzb3VyY2Usc3RhcnQpe1xyXG5cdHZhciBtYXRjaDtcclxuXHR2YXIgYnVmID0gW107XHJcblx0dmFyIHJlZyA9IC8nW14nXSsnfFwiW15cIl0rXCJ8W15cXHM8PlxcLz1dKz0/fChcXC8/XFxzKj58PCkvZztcclxuXHRyZWcubGFzdEluZGV4ID0gc3RhcnQ7XHJcblx0cmVnLmV4ZWMoc291cmNlKTsvL3NraXAgPFxyXG5cdHdoaWxlKG1hdGNoID0gcmVnLmV4ZWMoc291cmNlKSl7XHJcblx0XHRidWYucHVzaChtYXRjaCk7XHJcblx0XHRpZihtYXRjaFsxXSlyZXR1cm4gYnVmO1xyXG5cdH1cclxufVxyXG5cclxuaWYodHlwZW9mIHJlcXVpcmUgPT0gJ2Z1bmN0aW9uJyl7XHJcblx0ZXhwb3J0cy5YTUxSZWFkZXIgPSBYTUxSZWFkZXI7XHJcbn1cclxuXHJcbiIsIi8qXHJcbiAqIHhwYXRoLmpzXHJcbiAqXHJcbiAqIEFuIFhQYXRoIDEuMCBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0LlxyXG4gKlxyXG4gKiBDYW1lcm9uIE1jQ29ybWFjayA8Y2FtIChhdCkgbWNjLmlkLmF1PlxyXG4gKlxyXG4gKiBUaGlzIHdvcmsgaXMgbGljZW5zZWQgdW5kZXIgdGhlIENyZWF0aXZlIENvbW1vbnMgQXR0cmlidXRpb24tU2hhcmVBbGlrZVxyXG4gKiBMaWNlbnNlLiBUbyB2aWV3IGEgY29weSBvZiB0aGlzIGxpY2Vuc2UsIHZpc2l0XHJcbiAqXHJcbiAqICAgaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktc2EvMi4wL1xyXG4gKlxyXG4gKiBvciBzZW5kIGEgbGV0dGVyIHRvIENyZWF0aXZlIENvbW1vbnMsIDU1OSBOYXRoYW4gQWJib3R0IFdheSwgU3RhbmZvcmQsXHJcbiAqIENhbGlmb3JuaWEgOTQzMDUsIFVTQS5cclxuICpcclxuICogUmV2aXNpb24gMjA6IEFwcmlsIDI2LCAyMDExXHJcbiAqICAgRml4ZWQgYSB0eXBvIHJlc3VsdGluZyBpbiBGSVJTVF9PUkRFUkVEX05PREVfVFlQRSByZXN1bHRzIGJlaW5nIHdyb25nLFxyXG4gKiAgIHRoYW5rcyB0byA8c2hpX2EwMDkgKGF0KSBob3RtYWlsLmNvbT4uXHJcbiAqXHJcbiAqIFJldmlzaW9uIDE5OiBOb3ZlbWJlciAyOSwgMjAwNVxyXG4gKiAgIE5vZGVzZXRzIG5vdyBzdG9yZSB0aGVpciBub2RlcyBpbiBhIGhlaWdodCBiYWxhbmNlZCB0cmVlLCBpbmNyZWFzaW5nXHJcbiAqICAgcGVyZm9ybWFuY2UgZm9yIHRoZSBjb21tb24gY2FzZSBvZiBzZWxlY3Rpbmcgbm9kZXMgaW4gZG9jdW1lbnQgb3JkZXIsXHJcbiAqICAgdGhhbmtzIHRvIFPplo5hc3RpZW4gQ3JhbWF0dGUgPGNvbnRhY3QgKGF0KSB6ZW5pbnRlcmFjdGlmLmNvbT4uXHJcbiAqICAgQVZMIHRyZWUgY29kZSBhZGFwdGVkIGZyb20gUmFpbXVuZCBOZXVtYW5uIDxybm92YSAoYXQpIGdteC5uZXQ+LlxyXG4gKlxyXG4gKiBSZXZpc2lvbiAxODogT2N0b2JlciAyNywgMjAwNVxyXG4gKiAgIERPTSAzIFhQYXRoIHN1cHBvcnQuICBDYXZlYXRzOlxyXG4gKiAgICAgLSBuYW1lc3BhY2UgcHJlZml4ZXMgYXJlbid0IHJlc29sdmVkIGluIFhQYXRoRXZhbHVhdG9yLmNyZWF0ZUV4cHJlc3Npb24sXHJcbiAqICAgICAgIGJ1dCBpbiBYUGF0aEV4cHJlc3Npb24uZXZhbHVhdGUuXHJcbiAqICAgICAtIFhQYXRoUmVzdWx0LmludmFsaWRJdGVyYXRvclN0YXRlIGlzIG5vdCBpbXBsZW1lbnRlZC5cclxuICpcclxuICogUmV2aXNpb24gMTc6IE9jdG9iZXIgMjUsIDIwMDVcclxuICogICBTb21lIGNvcmUgWFBhdGggZnVuY3Rpb24gZml4ZXMgYW5kIGEgcGF0Y2ggdG8gYXZvaWQgY3Jhc2hpbmcgY2VydGFpblxyXG4gKiAgIHZlcnNpb25zIG9mIE1TWE1MIGluIFBhdGhFeHByLnByb3RvdHlwZS5nZXRPd25lckVsZW1lbnQsIHRoYW5rcyB0b1xyXG4gKiAgIFPplo5hc3RpZW4gQ3JhbWF0dGUgPGNvbnRhY3QgKGF0KSB6ZW5pbnRlcmFjdGlmLmNvbT4uXHJcbiAqXHJcbiAqIFJldmlzaW9uIDE2OiBTZXB0ZW1iZXIgMjIsIDIwMDVcclxuICogICBXb3JrYXJvdW5kcyBmb3Igc29tZSBJRSA1LjUgZGVmaWNpZW5jaWVzLlxyXG4gKiAgIEZpeGVkIHByb2JsZW0gd2l0aCBwcmVmaXggbm9kZSB0ZXN0cyBvbiBhdHRyaWJ1dGUgbm9kZXMuXHJcbiAqXHJcbiAqIFJldmlzaW9uIDE1OiBNYXkgMjEsIDIwMDVcclxuICogICBGaXhlZCBwcm9ibGVtIHdpdGggUU5hbWUgbm9kZSB0ZXN0cyBvbiBlbGVtZW50cyB3aXRoIGFuIHhtbG5zPVwiLi4uXCIuXHJcbiAqXHJcbiAqIFJldmlzaW9uIDE0OiBNYXkgMTksIDIwMDVcclxuICogICBGaXhlZCBRTmFtZSBub2RlIHRlc3RzIG9uIGF0dHJpYnV0ZSBub2RlIHJlZ3Jlc3Npb24uXHJcbiAqXHJcbiAqIFJldmlzaW9uIDEzOiBNYXkgMywgMjAwNVxyXG4gKiAgIE5vZGUgdGVzdHMgYXJlIGNhc2UgaW5zZW5zaXRpdmUgbm93IGlmIHdvcmtpbmcgaW4gYW4gSFRNTCBET00uXHJcbiAqXHJcbiAqIFJldmlzaW9uIDEyOiBBcHJpbCAyNiwgMjAwNVxyXG4gKiAgIFVwZGF0ZWQgbGljZW5jZS4gIFNsaWdodCBjb2RlIGNoYW5nZXMgdG8gZW5hYmxlIHVzZSBvZiBEZWFuXHJcbiAqICAgRWR3YXJkcycgc2NyaXB0IGNvbXByZXNzaW9uLCBodHRwOi8vZGVhbi5lZHdhcmRzLm5hbWUvcGFja2VyLyAuXHJcbiAqXHJcbiAqIFJldmlzaW9uIDExOiBBcHJpbCAyMywgMjAwNVxyXG4gKiAgIEZpeGVkIGJ1ZyB3aXRoICdhbmQnIGFuZCAnb3InIG9wZXJhdG9ycywgZml4IHRoYW5rcyB0b1xyXG4gKiAgIFNhbmR5IE1jQXJ0aHVyIDxzYW5keSAoYXQpIG1jYXJ0aHVyLm9yZz4uXHJcbiAqXHJcbiAqIFJldmlzaW9uIDEwOiBBcHJpbCAxNSwgMjAwNVxyXG4gKiAgIEFkZGVkIHN1cHBvcnQgZm9yIGEgdmlydHVhbCByb290IG5vZGUsIHN1cHBvc2VkbHkgaGVscGZ1bCBmb3JcclxuICogICBpbXBsZW1lbnRpbmcgWEZvcm1zLiAgRml4ZWQgcHJvYmxlbSB3aXRoIFFOYW1lIG5vZGUgdGVzdHMgYW5kXHJcbiAqICAgdGhlIHBhcmVudCBheGlzLlxyXG4gKlxyXG4gKiBSZXZpc2lvbiA5OiBNYXJjaCAxNywgMjAwNVxyXG4gKiAgIE5hbWVzcGFjZSByZXNvbHZlciB0d2Vha2VkIHNvIHVzaW5nIHRoZSBkb2N1bWVudCBub2RlIGFzIHRoZSBjb250ZXh0XHJcbiAqICAgZm9yIG5hbWVzcGFjZSBsb29rdXBzIGlzIGVxdWl2YWxlbnQgdG8gdXNpbmcgdGhlIGRvY3VtZW50IGVsZW1lbnQuXHJcbiAqXHJcbiAqIFJldmlzaW9uIDg6IEZlYnJ1YXJ5IDEzLCAyMDA1XHJcbiAqICAgSGFuZGxlIGltcGxpY2l0IGRlY2xhcmF0aW9uIG9mICd4bWxucycgbmFtZXNwYWNlIHByZWZpeC5cclxuICogICBGaXhlZCBidWcgd2hlbiBjb21wYXJpbmcgbm9kZXNldHMuXHJcbiAqICAgSW5zdGFuY2UgZGF0YSBjYW4gbm93IGJlIGFzc29jaWF0ZWQgd2l0aCBhIEZ1bmN0aW9uUmVzb2x2ZXIsIGFuZFxyXG4gKiAgICAgd29ya2Fyb3VuZCBmb3IgTVNYTUwgbm90IHN1cHBvcnRpbmcgJ2xvY2FsTmFtZScgYW5kICdnZXRFbGVtZW50QnlJZCcsXHJcbiAqICAgICB0aGFua3MgdG8gR3JhbnQgR29uZ2F3YXJlLlxyXG4gKiAgIEZpeCBhIGZldyBwcm9ibGVtcyB3aGVuIHRoZSBjb250ZXh0IG5vZGUgaXMgdGhlIHJvb3Qgbm9kZS5cclxuICpcclxuICogUmV2aXNpb24gNzogRmVicnVhcnkgMTEsIDIwMDVcclxuICogICBEZWZhdWx0IG5hbWVzcGFjZSByZXNvbHZlciBmaXggZnJvbSBHcmFudCBHb25nYXdhcmVcclxuICogICA8Z3JhbnQgKGF0KSBnb25nYXdhcmUuY29tPi5cclxuICpcclxuICogUmV2aXNpb24gNjogRmVicnVhcnkgMTAsIDIwMDVcclxuICogICBGaXhlZCBidWcgaW4gJ251bWJlcicgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIFJldmlzaW9uIDU6IEZlYnJ1YXJ5IDksIDIwMDVcclxuICogICBGaXhlZCBidWcgd2hlcmUgdGV4dCBub2RlcyBub3QgZ2V0dGluZyBjb252ZXJ0ZWQgdG8gc3RyaW5nIHZhbHVlcy5cclxuICpcclxuICogUmV2aXNpb24gNDogSmFudWFyeSAyMSwgMjAwNVxyXG4gKiAgIEJ1ZyBpbiAnbmFtZScgZnVuY3Rpb24sIGZpeCB0aGFua3MgdG8gQmlsbCBFZG5leS5cclxuICogICBGaXhlZCBpbmNvcnJlY3QgcHJvY2Vzc2luZyBvZiBuYW1lc3BhY2Ugbm9kZXMuXHJcbiAqICAgRml4ZWQgTmFtZXNwYWNlUmVzb2x2ZXIgdG8gcmVzb2x2ZSAneG1sJyBuYW1lc3BhY2UuXHJcbiAqICAgSW1wbGVtZW50ZWQgdW5pb24gJ3wnIG9wZXJhdG9yLlxyXG4gKlxyXG4gKiBSZXZpc2lvbiAzOiBKYW51YXJ5IDE0LCAyMDA1XHJcbiAqICAgRml4ZWQgYnVnIHdpdGggbm9kZXNldCBjb21wYXJpc29ucywgYnVnIGxleGluZyA8IGFuZCA+LlxyXG4gKlxyXG4gKiBSZXZpc2lvbiAyOiBPY3RvYmVyIDI2LCAyMDA0XHJcbiAqICAgUU5hbWUgbm9kZSB0ZXN0IG5hbWVzcGFjZSBoYW5kbGluZyBmaXhlZC4gIEZldyBvdGhlciBidWcgZml4ZXMuXHJcbiAqXHJcbiAqIFJldmlzaW9uIDE6IEF1Z3VzdCAxMywgMjAwNFxyXG4gKiAgIEJ1ZyBmaXhlcyBmcm9tIFdpbGxpYW0gSi4gRWRuZXkgPGJlZG5leSAoYXQpIHRlY2huaWNhbHB1cnN1aXQuY29tPi5cclxuICogICBBZGRlZCBtaW5pbWFsIGxpY2VuY2UuXHJcbiAqXHJcbiAqIEluaXRpYWwgdmVyc2lvbjogSnVuZSAxNCwgMjAwNFxyXG4gKi9cclxuXHJcbi8vIG5vbi1ub2RlIHdyYXBwZXJcclxuaWYodHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnICkge1xyXG5cdHhwYXRoID0ge307XHJcbn1cclxuKGZ1bmN0aW9uKGV4cG9ydHMpIHtcclxuXHRcclxuLy8gWFBhdGhQYXJzZXIgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5YUGF0aFBhcnNlci5wcm90b3R5cGUgPSBuZXcgT2JqZWN0KCk7XHJcblhQYXRoUGFyc2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhQYXRoUGFyc2VyO1xyXG5YUGF0aFBhcnNlci5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFhQYXRoUGFyc2VyKCkge1xyXG5cdHRoaXMuaW5pdCgpO1xyXG59XHJcblxyXG5YUGF0aFBhcnNlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMucmVkdWNlQWN0aW9ucyA9IFtdO1xyXG5cclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbM10gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgT3JPcGVyYXRpb24ocmhzWzBdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzVdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IEFuZE9wZXJhdGlvbihyaHNbMF0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbN10gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgRXF1YWxzT3BlcmF0aW9uKHJoc1swXSwgcmhzWzJdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s4XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBOb3RFcXVhbE9wZXJhdGlvbihyaHNbMF0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMTBdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IExlc3NUaGFuT3BlcmF0aW9uKHJoc1swXSwgcmhzWzJdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1sxMV0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgR3JlYXRlclRoYW5PcGVyYXRpb24ocmhzWzBdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzEyXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBMZXNzVGhhbk9yRXF1YWxPcGVyYXRpb24ocmhzWzBdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzEzXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBHcmVhdGVyVGhhbk9yRXF1YWxPcGVyYXRpb24ocmhzWzBdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzE1XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBQbHVzT3BlcmF0aW9uKHJoc1swXSwgcmhzWzJdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1sxNl0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgTWludXNPcGVyYXRpb24ocmhzWzBdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzE4XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBNdWx0aXBseU9wZXJhdGlvbihyaHNbMF0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMTldID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IERpdk9wZXJhdGlvbihyaHNbMF0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMjBdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IE1vZE9wZXJhdGlvbihyaHNbMF0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMjJdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IFVuYXJ5TWludXNPcGVyYXRpb24ocmhzWzFdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1syNF0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgQmFyT3BlcmF0aW9uKHJoc1swXSwgcmhzWzJdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1syNV0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgUGF0aEV4cHIodW5kZWZpbmVkLCB1bmRlZmluZWQsIHJoc1swXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMjddID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyaHNbMF0ubG9jYXRpb25QYXRoID0gcmhzWzJdO1xyXG5cdFx0cmV0dXJuIHJoc1swXTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1syOF0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJoc1swXS5sb2NhdGlvblBhdGggPSByaHNbMl07XHJcblx0XHRyaHNbMF0ubG9jYXRpb25QYXRoLnN0ZXBzLnVuc2hpZnQobmV3IFN0ZXAoU3RlcC5ERVNDRU5EQU5UT1JTRUxGLCBuZXcgTm9kZVRlc3QoTm9kZVRlc3QuTk9ERSwgdW5kZWZpbmVkKSwgW10pKTtcclxuXHRcdHJldHVybiByaHNbMF07XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMjldID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBhdGhFeHByKHJoc1swXSwgW10sIHVuZGVmaW5lZCk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMzBdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHJoc1swXSwgUGF0aEV4cHIpKSB7XHJcblx0XHRcdGlmIChyaHNbMF0uZmlsdGVyUHJlZGljYXRlcyA9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRyaHNbMF0uZmlsdGVyUHJlZGljYXRlcyA9IFtdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJoc1swXS5maWx0ZXJQcmVkaWNhdGVzLnB1c2gocmhzWzFdKTtcclxuXHRcdFx0cmV0dXJuIHJoc1swXTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBuZXcgUGF0aEV4cHIocmhzWzBdLCBbcmhzWzFdXSwgdW5kZWZpbmVkKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1szMl0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiByaHNbMV07XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMzNdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IFhTdHJpbmcocmhzWzBdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1szNF0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgWE51bWJlcihyaHNbMF0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzM2XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBGdW5jdGlvbkNhbGwocmhzWzBdLCBbXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMzddID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IEZ1bmN0aW9uQ2FsbChyaHNbMF0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMzhdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gWyByaHNbMF0gXTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1szOV0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJoc1syXS51bnNoaWZ0KHJoc1swXSk7XHJcblx0XHRyZXR1cm4gcmhzWzJdO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzQzXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBMb2NhdGlvblBhdGgodHJ1ZSwgW10pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzQ0XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmhzWzFdLmFic29sdXRlID0gdHJ1ZTtcclxuXHRcdHJldHVybiByaHNbMV07XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNDZdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IExvY2F0aW9uUGF0aChmYWxzZSwgWyByaHNbMF0gXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNDddID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyaHNbMF0uc3RlcHMucHVzaChyaHNbMl0pO1xyXG5cdFx0cmV0dXJuIHJoc1swXTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s0OV0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgU3RlcChyaHNbMF0sIHJoc1sxXSwgW10pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzUwXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBTdGVwKFN0ZXAuQ0hJTEQsIHJoc1swXSwgW10pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzUxXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBTdGVwKHJoc1swXSwgcmhzWzFdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzUyXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBTdGVwKFN0ZXAuQ0hJTEQsIHJoc1swXSwgcmhzWzFdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s1NF0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBbIHJoc1swXSBdO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzU1XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmhzWzFdLnVuc2hpZnQocmhzWzBdKTtcclxuXHRcdHJldHVybiByaHNbMV07XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNTZdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRpZiAocmhzWzBdID09IFwiYW5jZXN0b3JcIikge1xyXG5cdFx0XHRyZXR1cm4gU3RlcC5BTkNFU1RPUjtcclxuXHRcdH0gZWxzZSBpZiAocmhzWzBdID09IFwiYW5jZXN0b3Itb3Itc2VsZlwiKSB7XHJcblx0XHRcdHJldHVybiBTdGVwLkFOQ0VTVE9ST1JTRUxGO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJhdHRyaWJ1dGVcIikge1xyXG5cdFx0XHRyZXR1cm4gU3RlcC5BVFRSSUJVVEU7XHJcblx0XHR9IGVsc2UgaWYgKHJoc1swXSA9PSBcImNoaWxkXCIpIHtcclxuXHRcdFx0cmV0dXJuIFN0ZXAuQ0hJTEQ7XHJcblx0XHR9IGVsc2UgaWYgKHJoc1swXSA9PSBcImRlc2NlbmRhbnRcIikge1xyXG5cdFx0XHRyZXR1cm4gU3RlcC5ERVNDRU5EQU5UO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJkZXNjZW5kYW50LW9yLXNlbGZcIikge1xyXG5cdFx0XHRyZXR1cm4gU3RlcC5ERVNDRU5EQU5UT1JTRUxGO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJmb2xsb3dpbmdcIikge1xyXG5cdFx0XHRyZXR1cm4gU3RlcC5GT0xMT1dJTkc7XHJcblx0XHR9IGVsc2UgaWYgKHJoc1swXSA9PSBcImZvbGxvd2luZy1zaWJsaW5nXCIpIHtcclxuXHRcdFx0cmV0dXJuIFN0ZXAuRk9MTE9XSU5HU0lCTElORztcclxuXHRcdH0gZWxzZSBpZiAocmhzWzBdID09IFwibmFtZXNwYWNlXCIpIHtcclxuXHRcdFx0cmV0dXJuIFN0ZXAuTkFNRVNQQUNFO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJwYXJlbnRcIikge1xyXG5cdFx0XHRyZXR1cm4gU3RlcC5QQVJFTlQ7XHJcblx0XHR9IGVsc2UgaWYgKHJoc1swXSA9PSBcInByZWNlZGluZ1wiKSB7XHJcblx0XHRcdHJldHVybiBTdGVwLlBSRUNFRElORztcclxuXHRcdH0gZWxzZSBpZiAocmhzWzBdID09IFwicHJlY2VkaW5nLXNpYmxpbmdcIikge1xyXG5cdFx0XHRyZXR1cm4gU3RlcC5QUkVDRURJTkdTSUJMSU5HO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJzZWxmXCIpIHtcclxuXHRcdFx0cmV0dXJuIFN0ZXAuU0VMRjtcclxuXHRcdH1cclxuXHRcdHJldHVybiAtMTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s1N10gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBTdGVwLkFUVFJJQlVURTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s1OV0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdGlmIChyaHNbMF0gPT0gXCJjb21tZW50XCIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBOb2RlVGVzdChOb2RlVGVzdC5DT01NRU5ULCB1bmRlZmluZWQpO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJ0ZXh0XCIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBOb2RlVGVzdChOb2RlVGVzdC5URVhULCB1bmRlZmluZWQpO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJwcm9jZXNzaW5nLWluc3RydWN0aW9uXCIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBOb2RlVGVzdChOb2RlVGVzdC5QSSwgdW5kZWZpbmVkKTtcclxuXHRcdH0gZWxzZSBpZiAocmhzWzBdID09IFwibm9kZVwiKSB7XHJcblx0XHRcdHJldHVybiBuZXcgTm9kZVRlc3QoTm9kZVRlc3QuTk9ERSwgdW5kZWZpbmVkKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgTm9kZVRlc3QoLTEsIHVuZGVmaW5lZCk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNjBdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IE5vZGVUZXN0KE5vZGVUZXN0LlBJLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzYxXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIHJoc1sxXTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s2M10gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJoc1sxXS5hYnNvbHV0ZSA9IHRydWU7XHJcblx0XHRyaHNbMV0uc3RlcHMudW5zaGlmdChuZXcgU3RlcChTdGVwLkRFU0NFTkRBTlRPUlNFTEYsIG5ldyBOb2RlVGVzdChOb2RlVGVzdC5OT0RFLCB1bmRlZmluZWQpLCBbXSkpO1xyXG5cdFx0cmV0dXJuIHJoc1sxXTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s2NF0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJoc1swXS5zdGVwcy5wdXNoKG5ldyBTdGVwKFN0ZXAuREVTQ0VOREFOVE9SU0VMRiwgbmV3IE5vZGVUZXN0KE5vZGVUZXN0Lk5PREUsIHVuZGVmaW5lZCksIFtdKSk7XHJcblx0XHRyaHNbMF0uc3RlcHMucHVzaChyaHNbMl0pO1xyXG5cdFx0cmV0dXJuIHJoc1swXTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s2NV0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgU3RlcChTdGVwLlNFTEYsIG5ldyBOb2RlVGVzdChOb2RlVGVzdC5OT0RFLCB1bmRlZmluZWQpLCBbXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNjZdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IFN0ZXAoU3RlcC5QQVJFTlQsIG5ldyBOb2RlVGVzdChOb2RlVGVzdC5OT0RFLCB1bmRlZmluZWQpLCBbXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNjddID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IFZhcmlhYmxlUmVmZXJlbmNlKHJoc1sxXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNjhdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IE5vZGVUZXN0KE5vZGVUZXN0Lk5BTUVURVNUQU5ZLCB1bmRlZmluZWQpO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzY5XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0dmFyIHByZWZpeCA9IHJoc1swXS5zdWJzdHJpbmcoMCwgcmhzWzBdLmluZGV4T2YoXCI6XCIpKTtcclxuXHRcdHJldHVybiBuZXcgTm9kZVRlc3QoTm9kZVRlc3QuTkFNRVRFU1RQUkVGSVhBTlksIHByZWZpeCk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNzBdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IE5vZGVUZXN0KE5vZGVUZXN0Lk5BTUVURVNUUU5BTUUsIHJoc1swXSk7XHJcblx0fTtcclxufTtcclxuXHJcblhQYXRoUGFyc2VyLmFjdGlvblRhYmxlID0gW1xyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgIHMgICAgICAgICAgICAgICAgICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgIHIgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgIHJycnJyICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcInJzICBycnJycnJyciBzICBzc3Nzc3JycnJyciAgcnJzIHJzIFwiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICAgICAgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciByciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciByciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcIiAgcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgICAgICAgXCIsXHJcblx0XCIgcyAgICAgICAgICAgcyAgc3Nzc3MgICAgICAgICAgcyAgcyBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgIHIgIFwiLFxyXG5cdFwiYSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCJyICAgICAgIHMgICAgICAgICAgICAgICAgICAgIHJyICByICBcIixcclxuXHRcInIgICAgICBzciAgICAgICAgICAgICAgICAgICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHMgIHJyICAgICAgICAgICAgcyAgICAgICByciAgciAgXCIsXHJcblx0XCJyICAgcnNzcnIgICAgICAgICAgICByc3MgICAgIHJyICByICBcIixcclxuXHRcInIgICBycnJyciAgICAgICAgICAgIHJycnNzICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJyc3NzICAgICAgICAgcnJycnIgICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnJycnIgICAgICAgICBycnJyciAgIHJyICByICBcIixcclxuXHRcInIgICBycnJycnJyciAgICAgICAgIHJycnJycyAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJycnJyICAgICAgICAgcnJycnJyICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnJycnIgICAgICAgICBycnJycnIgIHJyICByICBcIixcclxuXHRcInIgIHNycnJycnJyciAgICAgICAgIHJycnJycnMgcnIgc3IgIFwiLFxyXG5cdFwiciAgc3JycnJycnJyICAgICAgICAgcnJycnJycyByciAgciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciByciAgXCIsXHJcblx0XCJyICAgcnJycnJycnIgICAgICAgICBycnJycnIgIHJyICByICBcIixcclxuXHRcInIgICBycnJycnJyciAgICAgICAgIHJycnJyciAgcnIgIHIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciAgciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyICByICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICBzc3NzcyAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciBzciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyICByICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciByciAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgICAgICBcIixcclxuXHRcInIgIHNycnJycnJyciAgICAgICAgIHJycnJycnMgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJycnJyICAgICAgICAgcnJycnIgICByciAgciAgXCIsXHJcblx0XCIgICAgICAgICAgICAgIHMgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgIHJycnJyICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzc3MgcyAgc3NcIixcclxuXHRcInIgIHNycnJycnJyciAgICAgICAgIHJycnJycnMgcnIgIHIgIFwiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgICBzcyAgcyAgc3NcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiIHMgICAgICAgICAgIHMgIHNzc3NzICAgICAgICAgIHMgIHMgXCIsXHJcblx0XCIgcyAgICAgICAgICAgcyAgc3Nzc3MgICAgICAgICAgcyAgcyBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiIHMgICAgICAgICAgIHMgIHNzc3NzICAgICAgICAgIHMgIHMgXCIsXHJcblx0XCIgcyAgICAgICAgICAgcyAgc3Nzc3MgICAgICAgICAgcyAgcyBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgc3IgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciBzciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyICByICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICAgICAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICByciAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnMgICAgIFwiLFxyXG5cdFwiciAgICAgIHNyICAgICAgICAgICAgICAgICAgICByciAgciAgXCIsXHJcblx0XCJyICAgcyAgcnIgICAgICAgICAgICBzICAgICAgIHJyICByICBcIixcclxuXHRcInIgICByc3NyciAgICAgICAgICAgIHJzcyAgICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJzc3JyICAgICAgICAgICAgcnNzICAgICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnIgICAgICAgICAgICBycnJzcyAgIHJyICByICBcIixcclxuXHRcInIgICBycnJyciAgICAgICAgICAgIHJycnNzICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJyICAgICAgICAgICAgcnJyc3MgICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnIgICAgICAgICAgICBycnJzcyAgIHJyICByICBcIixcclxuXHRcInIgICBycnJycnNzcyAgICAgICAgIHJycnJyICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJyc3NzICAgICAgICAgcnJycnIgICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnJycnIgICAgICAgICBycnJyciAgIHJyICByICBcIixcclxuXHRcInIgICBycnJycnJyciAgICAgICAgIHJycnJyICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJycnJyICAgICAgICAgcnJycnIgICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnJycnIgICAgICAgICBycnJycnIgIHJyICByICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyAgXCIsXHJcblx0XCJyICBzcnJycnJycnIgICAgICAgICBycnJycnJzIHJyICByICBcIixcclxuXHRcInIgIHNycnJycnJyciAgICAgICAgIHJycnJycnMgcnIgIHIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciAgciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyICByICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgIHIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciAgciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciAgICAgIFwiXHJcbl07XHJcblxyXG5YUGF0aFBhcnNlci5hY3Rpb25UYWJsZU51bWJlciA9IFtcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICBKICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCJhICBhYWFhYWFhYWEgICAgICAgICBhYWFhYWFhIGFhICBhICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICBZWVlZWSAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCJLMSAgS0tLS0tLS0sgLiAgKyopKCdLS0tLS0sgIEtLIyBLXFxcIiBcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgIE4gICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyAgICAgICBcIixcclxuXHRcImUgIGVlZWVlZWVlZSAgICAgICAgIGVlZWVlZWUgZWUgZWUgIFwiLFxyXG5cdFwiZiAgZmZmZmZmZmZmICAgICAgICAgZmZmZmZmZiBmZiBmZiAgXCIsXHJcblx0XCJkICBkZGRkZGRkZGQgICAgICAgICBkZGRkZGRkIGRkIGRkICBcIixcclxuXHRcIkIgIEJCQkJCQkJCQiAgICAgICAgIEJCQkJCQkIgQkIgQkIgIFwiLFxyXG5cdFwiQSAgQUFBQUFBQUFBICAgICAgICAgQUFBQUFBQSBBQSBBQSAgXCIsXHJcblx0XCIgIFAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICBRICAgICAgIFwiLFxyXG5cdFwiIDEgICAgICAgICAgIC4gICsqKSgnICAgICAgICAgICMgIFxcXCIgXCIsXHJcblx0XCJiICBiYmJiYmJiYmIgICAgICAgICBiYmJiYmJiIGJiICBiICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiISAgICAgICBTICAgICAgICAgICAgICAgICAgICAhISAgISAgXCIsXHJcblx0XCJcXFwiICAgICAgVFxcXCIgICAgICAgICAgICAgICAgICAgIFxcXCJcXFwiICBcXFwiICBcIixcclxuXHRcIiQgICBWICAkJCAgICAgICAgICAgIFUgICAgICAgJCQgICQgIFwiLFxyXG5cdFwiJiAgICZaWSYmICAgICAgICAgICAgJlhXICAgICAmJiAgJiAgXCIsXHJcblx0XCIpICAgKSkpKSkgICAgICAgICAgICApKSlcXFxcWyAgICkpICApICBcIixcclxuXHRcIi4gICAuLi4uLl9eXSAgICAgICAgIC4uLi4uICAgLi4gIC4gIFwiLFxyXG5cdFwiMSAgIDExMTExMTExICAgICAgICAgMTExMTEgICAxMSAgMSAgXCIsXHJcblx0XCI1ICAgNTU1NTU1NTUgICAgICAgICA1NTU1NWAgIDU1ICA1ICBcIixcclxuXHRcIjcgICA3Nzc3Nzc3NyAgICAgICAgIDc3Nzc3NyAgNzcgIDcgIFwiLFxyXG5cdFwiOSAgIDk5OTk5OTk5ICAgICAgICAgOTk5OTk5ICA5OSAgOSAgXCIsXHJcblx0XCI6ICBjOjo6Ojo6OjogICAgICAgICA6Ojo6OjpiIDo6IGE6ICBcIixcclxuXHRcIkkgIGZJSUlJSUlJSSAgICAgICAgIElJSUlJSWUgSUkgIEkgIFwiLFxyXG5cdFwiPSAgPT09PT09PT09ICAgICAgICAgPT09PT09PSA9PSA9PSAgXCIsXHJcblx0XCI/ICA/Pz8/Pz8/Pz8gICAgICAgICA/Pz8/Pz8/ID8/ID8/ICBcIixcclxuXHRcIkMgIENDQ0NDQ0NDQyAgICAgICAgIENDQ0NDQ0MgQ0MgQ0MgIFwiLFxyXG5cdFwiSiAgIEpKSkpKSkpKICAgICAgICAgSkpKSkpKICBKSiAgSiAgXCIsXHJcblx0XCJNICAgTU1NTU1NTU0gICAgICAgICBNTU1NTU0gIE1NICBNICBcIixcclxuXHRcIk4gIE5OTk5OTk5OTiAgICAgICAgIE5OTk5OTk4gTk4gIE4gIFwiLFxyXG5cdFwiUCAgUFBQUFBQUFBQICAgICAgICAgUFBQUFBQUCBQUCAgUCAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgKyopKCcgICAgICAgICAgICAgICBcIixcclxuXHRcIlIgIFJSUlJSUlJSUiAgICAgICAgIFJSUlJSUlIgUlIgYVIgIFwiLFxyXG5cdFwiVSAgVVVVVVVVVVVVICAgICAgICAgVVVVVVVVVSBVVSAgVSAgXCIsXHJcblx0XCJaICBaWlpaWlpaWlogICAgICAgICBaWlpaWlpaIFpaIFpaICBcIixcclxuXHRcImMgIGNjY2NjY2NjYyAgICAgICAgIGNjY2NjY2MgY2MgY2MgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqICAgICAgXCIsXHJcblx0XCJMICBmTExMTExMTEwgICAgICAgICBMTExMTExlIExMICBMICBcIixcclxuXHRcIjYgICA2NjY2NjY2NiAgICAgICAgIDY2NjY2ICAgNjYgIDYgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICBrICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICBYWFhYWCAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSRtICMgIFxcXCIhXCIsXHJcblx0XCJfICBmX19fX19fX18gICAgICAgICBfX19fX19lIF9fICBfICBcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICAgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAxICAgICAgICAgICAuICArKikoJyAgICAgICAgICAjICBcXFwiIFwiLFxyXG5cdFwiIDEgICAgICAgICAgIC4gICsqKSgnICAgICAgICAgICMgIFxcXCIgXCIsXHJcblx0XCI+ICA+Pj4+Pj4+Pj4gICAgICAgICA+Pj4+Pj4+ID4+ID4+ICBcIixcclxuXHRcIiAxICAgICAgICAgICAuICArKikoJyAgICAgICAgICAjICBcXFwiIFwiLFxyXG5cdFwiIDEgICAgICAgICAgIC4gICsqKSgnICAgICAgICAgICMgIFxcXCIgXCIsXHJcblx0XCJRICBRUVFRUVFRUVEgICAgICAgICBRUVFRUVFRIFFRIGFRICBcIixcclxuXHRcIlYgIFZWVlZWVlZWViAgICAgICAgIFZWVlZWVlYgVlYgYVYgIFwiLFxyXG5cdFwiVCAgVFRUVFRUVFRUICAgICAgICAgVFRUVFRUVCBUVCAgVCAgXCIsXHJcblx0XCJAICBAQEBAQEBAQEAgICAgICAgICBAQEBAQEBAIEBAIEBAICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFx4ODcgICAgICBcIixcclxuXHRcIlsgIFtbW1tbW1tbWyAgICAgICAgIFtbW1tbW1sgW1sgW1sgIFwiLFxyXG5cdFwiRCAgREREREREREREICAgICAgICAgRERERERERCBERCBERCAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhIICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFx4ODggICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRlxceDg5ICAgICBcIixcclxuXHRcIiMgICAgICBUIyAgICAgICAgICAgICAgICAgICAgIyMgICMgIFwiLFxyXG5cdFwiJSAgIFYgICUlICAgICAgICAgICAgVSAgICAgICAlJSAgJSAgXCIsXHJcblx0XCInICAgJ1pZJycgICAgICAgICAgICAnWFcgICAgICcnICAnICBcIixcclxuXHRcIiggICAoWlkoKCAgICAgICAgICAgIChYVyAgICAgKCggICggIFwiLFxyXG5cdFwiKyAgICsrKysrICAgICAgICAgICAgKysrXFxcXFsgICArKyAgKyAgXCIsXHJcblx0XCIqICAgKioqKiogICAgICAgICAgICAqKipcXFxcWyAgICoqICAqICBcIixcclxuXHRcIi0gICAtLS0tLSAgICAgICAgICAgIC0tLVxcXFxbICAgLS0gIC0gIFwiLFxyXG5cdFwiLCAgICwsLCwsICAgICAgICAgICAgLCwsXFxcXFsgICAsLCAgLCAgXCIsXHJcblx0XCIwICAgMDAwMDBfXl0gICAgICAgICAwMDAwMCAgIDAwICAwICBcIixcclxuXHRcIi8gICAvLy8vL19eXSAgICAgICAgIC8vLy8vICAgLy8gIC8gIFwiLFxyXG5cdFwiMiAgIDIyMjIyMjIyICAgICAgICAgMjIyMjIgICAyMiAgMiAgXCIsXHJcblx0XCIzICAgMzMzMzMzMzMgICAgICAgICAzMzMzMyAgIDMzICAzICBcIixcclxuXHRcIjQgICA0NDQ0NDQ0NCAgICAgICAgIDQ0NDQ0ICAgNDQgIDQgIFwiLFxyXG5cdFwiOCAgIDg4ODg4ODg4ICAgICAgICAgODg4ODg4ICA4OCAgOCAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxceDhhICBcIixcclxuXHRcIjsgIGY7Ozs7Ozs7OyAgICAgICAgIDs7Ozs7O2UgOzsgIDsgIFwiLFxyXG5cdFwiPCAgZjw8PDw8PDw8ICAgICAgICAgPDw8PDw8ZSA8PCAgPCAgXCIsXHJcblx0XCJPICBPT09PT09PT08gICAgICAgICBPT09PT09PIE9PICBPICBcIixcclxuXHRcImAgIGBgYGBgYGBgYCAgICAgICAgIGBgYGBgYGAgYGAgIGAgIFwiLFxyXG5cdFwiUyAgU1NTU1NTU1NTICAgICAgICAgU1NTU1NTUyBTUyAgUyAgXCIsXHJcblx0XCJXICBXV1dXV1dXV1cgICAgICAgICBXV1dXV1dXIFdXICBXICBcIixcclxuXHRcIlxcXFwgIFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCAgICAgICAgIFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwgXFxcXFxcXFwgXFxcXFxcXFwgIFwiLFxyXG5cdFwiRSAgRUVFRUVFRUVFICAgICAgICAgRUVFRUVFRSBFRSBFRSAgXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIl0gIF1dXV1dXV1dXSAgICAgICAgIF1dXV1dXV0gXV0gXV0gIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHICAgICAgXCJcclxuXTtcclxuXHJcblhQYXRoUGFyc2VyLmdvdG9UYWJsZSA9IFtcclxuXHRcIjM0NTY3ODk6Ozw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCJMNDU2Nzg5Ojs8PT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgICAgICAgTSAgICAgICAgRUZHSCBJSiBcIixcclxuXHRcIiAgICAgICBOOzw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICBTICAgICAgICBFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICBlICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgaCAgSiBcIixcclxuXHRcIiAgICAgICAgICAgICAgaSAgICAgICAgICBqICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCJvNDU2Nzg5Ojs8PT4/QCBBQnBxQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgcjY3ODk6Ozw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICBzNzg5Ojs8PT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgIHQ4OTo7PD0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIiAgICB1ODk6Ozw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICAgIHY5Ojs8PT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgICB3OTo7PD0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIiAgICAgeDk6Ozw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICAgIHk5Ojs8PT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgejo7PD0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIiAgICAgIHs6Ozw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICAgICAgfDs8PT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgIH07PD0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIiAgICAgICB+Ozw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICAgICAgICBcXHg3Zj0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIlxceDgwNDU2Nzg5Ojs8PT4/QCBBQiAgQ0RFRkdIIElKXFx4ODFcIixcclxuXHRcIiAgICAgICAgICAgIFxceDgyICAgICAgICBFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgICAgICAgXFx4ODMgICAgICAgIEVGR0ggSUogXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgXFx4ODQgR0ggSUogXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICBcXHg4NSBHSCBJSiBcIixcclxuXHRcIiAgICAgICAgICAgICAgaSAgICAgICAgICBcXHg4NiAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICBpICAgICAgICAgIFxceDg3ICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIm80NTY3ODk6Ozw9Pj9AIEFCXFx4OGNxQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcclxuXTtcclxuXHJcblhQYXRoUGFyc2VyLnByb2R1Y3Rpb25zID0gW1xyXG5cdFsxLCAxLCAyXSxcclxuXHRbMiwgMSwgM10sXHJcblx0WzMsIDEsIDRdLFxyXG5cdFszLCAzLCAzLCAtOSwgNF0sXHJcblx0WzQsIDEsIDVdLFxyXG5cdFs0LCAzLCA0LCAtOCwgNV0sXHJcblx0WzUsIDEsIDZdLFxyXG5cdFs1LCAzLCA1LCAtMjIsIDZdLFxyXG5cdFs1LCAzLCA1LCAtNSwgNl0sXHJcblx0WzYsIDEsIDddLFxyXG5cdFs2LCAzLCA2LCAtMjMsIDddLFxyXG5cdFs2LCAzLCA2LCAtMjQsIDddLFxyXG5cdFs2LCAzLCA2LCAtNiwgN10sXHJcblx0WzYsIDMsIDYsIC03LCA3XSxcclxuXHRbNywgMSwgOF0sXHJcblx0WzcsIDMsIDcsIC0yNSwgOF0sXHJcblx0WzcsIDMsIDcsIC0yNiwgOF0sXHJcblx0WzgsIDEsIDldLFxyXG5cdFs4LCAzLCA4LCAtMTIsIDldLFxyXG5cdFs4LCAzLCA4LCAtMTEsIDldLFxyXG5cdFs4LCAzLCA4LCAtMTAsIDldLFxyXG5cdFs5LCAxLCAxMF0sXHJcblx0WzksIDIsIC0yNiwgOV0sXHJcblx0WzEwLCAxLCAxMV0sXHJcblx0WzEwLCAzLCAxMCwgLTI3LCAxMV0sXHJcblx0WzExLCAxLCAxMl0sXHJcblx0WzExLCAxLCAxM10sXHJcblx0WzExLCAzLCAxMywgLTI4LCAxNF0sXHJcblx0WzExLCAzLCAxMywgLTQsIDE0XSxcclxuXHRbMTMsIDEsIDE1XSxcclxuXHRbMTMsIDIsIDEzLCAxNl0sXHJcblx0WzE1LCAxLCAxN10sXHJcblx0WzE1LCAzLCAtMjksIDIsIC0zMF0sXHJcblx0WzE1LCAxLCAtMTVdLFxyXG5cdFsxNSwgMSwgLTE2XSxcclxuXHRbMTUsIDEsIDE4XSxcclxuXHRbMTgsIDMsIC0xMywgLTI5LCAtMzBdLFxyXG5cdFsxOCwgNCwgLTEzLCAtMjksIDE5LCAtMzBdLFxyXG5cdFsxOSwgMSwgMjBdLFxyXG5cdFsxOSwgMywgMjAsIC0zMSwgMTldLFxyXG5cdFsyMCwgMSwgMl0sXHJcblx0WzEyLCAxLCAxNF0sXHJcblx0WzEyLCAxLCAyMV0sXHJcblx0WzIxLCAxLCAtMjhdLFxyXG5cdFsyMSwgMiwgLTI4LCAxNF0sXHJcblx0WzIxLCAxLCAyMl0sXHJcblx0WzE0LCAxLCAyM10sXHJcblx0WzE0LCAzLCAxNCwgLTI4LCAyM10sXHJcblx0WzE0LCAxLCAyNF0sXHJcblx0WzIzLCAyLCAyNSwgMjZdLFxyXG5cdFsyMywgMSwgMjZdLFxyXG5cdFsyMywgMywgMjUsIDI2LCAyN10sXHJcblx0WzIzLCAyLCAyNiwgMjddLFxyXG5cdFsyMywgMSwgMjhdLFxyXG5cdFsyNywgMSwgMTZdLFxyXG5cdFsyNywgMiwgMTYsIDI3XSxcclxuXHRbMjUsIDIsIC0xNCwgLTNdLFxyXG5cdFsyNSwgMSwgLTMyXSxcclxuXHRbMjYsIDEsIDI5XSxcclxuXHRbMjYsIDMsIC0yMCwgLTI5LCAtMzBdLFxyXG5cdFsyNiwgNCwgLTIxLCAtMjksIC0xNSwgLTMwXSxcclxuXHRbMTYsIDMsIC0zMywgMzAsIC0zNF0sXHJcblx0WzMwLCAxLCAyXSxcclxuXHRbMjIsIDIsIC00LCAxNF0sXHJcblx0WzI0LCAzLCAxNCwgLTQsIDIzXSxcclxuXHRbMjgsIDEsIC0zNV0sXHJcblx0WzI4LCAxLCAtMl0sXHJcblx0WzE3LCAyLCAtMzYsIC0xOF0sXHJcblx0WzI5LCAxLCAtMTddLFxyXG5cdFsyOSwgMSwgLTE5XSxcclxuXHRbMjksIDEsIC0xOF1cclxuXTtcclxuXHJcblhQYXRoUGFyc2VyLkRPVUJMRURPVCA9IDI7XHJcblhQYXRoUGFyc2VyLkRPVUJMRUNPTE9OID0gMztcclxuWFBhdGhQYXJzZXIuRE9VQkxFU0xBU0ggPSA0O1xyXG5YUGF0aFBhcnNlci5OT1RFUVVBTCA9IDU7XHJcblhQYXRoUGFyc2VyLkxFU1NUSEFOT1JFUVVBTCA9IDY7XHJcblhQYXRoUGFyc2VyLkdSRUFURVJUSEFOT1JFUVVBTCA9IDc7XHJcblhQYXRoUGFyc2VyLkFORCA9IDg7XHJcblhQYXRoUGFyc2VyLk9SID0gOTtcclxuWFBhdGhQYXJzZXIuTU9EID0gMTA7XHJcblhQYXRoUGFyc2VyLkRJViA9IDExO1xyXG5YUGF0aFBhcnNlci5NVUxUSVBMWU9QRVJBVE9SID0gMTI7XHJcblhQYXRoUGFyc2VyLkZVTkNUSU9OTkFNRSA9IDEzO1xyXG5YUGF0aFBhcnNlci5BWElTTkFNRSA9IDE0O1xyXG5YUGF0aFBhcnNlci5MSVRFUkFMID0gMTU7XHJcblhQYXRoUGFyc2VyLk5VTUJFUiA9IDE2O1xyXG5YUGF0aFBhcnNlci5BU1RFUklTS05BTUVURVNUID0gMTc7XHJcblhQYXRoUGFyc2VyLlFOQU1FID0gMTg7XHJcblhQYXRoUGFyc2VyLk5DTkFNRUNPTE9OQVNURVJJU0sgPSAxOTtcclxuWFBhdGhQYXJzZXIuTk9ERVRZUEUgPSAyMDtcclxuWFBhdGhQYXJzZXIuUFJPQ0VTU0lOR0lOU1RSVUNUSU9OV0lUSExJVEVSQUwgPSAyMTtcclxuWFBhdGhQYXJzZXIuRVFVQUxTID0gMjI7XHJcblhQYXRoUGFyc2VyLkxFU1NUSEFOID0gMjM7XHJcblhQYXRoUGFyc2VyLkdSRUFURVJUSEFOID0gMjQ7XHJcblhQYXRoUGFyc2VyLlBMVVMgPSAyNTtcclxuWFBhdGhQYXJzZXIuTUlOVVMgPSAyNjtcclxuWFBhdGhQYXJzZXIuQkFSID0gMjc7XHJcblhQYXRoUGFyc2VyLlNMQVNIID0gMjg7XHJcblhQYXRoUGFyc2VyLkxFRlRQQVJFTlRIRVNJUyA9IDI5O1xyXG5YUGF0aFBhcnNlci5SSUdIVFBBUkVOVEhFU0lTID0gMzA7XHJcblhQYXRoUGFyc2VyLkNPTU1BID0gMzE7XHJcblhQYXRoUGFyc2VyLkFUID0gMzI7XHJcblhQYXRoUGFyc2VyLkxFRlRCUkFDS0VUID0gMzM7XHJcblhQYXRoUGFyc2VyLlJJR0hUQlJBQ0tFVCA9IDM0O1xyXG5YUGF0aFBhcnNlci5ET1QgPSAzNTtcclxuWFBhdGhQYXJzZXIuRE9MTEFSID0gMzY7XHJcblxyXG5YUGF0aFBhcnNlci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbihzMSkge1xyXG5cdHZhciB0eXBlcyA9IFtdO1xyXG5cdHZhciB2YWx1ZXMgPSBbXTtcclxuXHR2YXIgcyA9IHMxICsgJ1xcMCc7XHJcblxyXG5cdHZhciBwb3MgPSAwO1xyXG5cdHZhciBjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdHdoaWxlICgxKSB7XHJcblx0XHR3aGlsZSAoYyA9PSAnICcgfHwgYyA9PSAnXFx0JyB8fCBjID09ICdcXHInIHx8IGMgPT0gJ1xcbicpIHtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdH1cclxuXHRcdGlmIChjID09ICdcXDAnIHx8IHBvcyA+PSBzLmxlbmd0aCkge1xyXG5cdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYyA9PSAnKCcpIHtcclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5MRUZUUEFSRU5USEVTSVMpO1xyXG5cdFx0XHR2YWx1ZXMucHVzaChjKTtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblx0XHRpZiAoYyA9PSAnKScpIHtcclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5SSUdIVFBBUkVOVEhFU0lTKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goYyk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGMgPT0gJ1snKSB7XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuTEVGVEJSQUNLRVQpO1xyXG5cdFx0XHR2YWx1ZXMucHVzaChjKTtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblx0XHRpZiAoYyA9PSAnXScpIHtcclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5SSUdIVEJSQUNLRVQpO1xyXG5cdFx0XHR2YWx1ZXMucHVzaChjKTtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblx0XHRpZiAoYyA9PSAnQCcpIHtcclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5BVCk7XHJcblx0XHRcdHZhbHVlcy5wdXNoKGMpO1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHRcdGlmIChjID09ICcsJykge1xyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkNPTU1BKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goYyk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGMgPT0gJ3wnKSB7XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuQkFSKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goYyk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGMgPT0gJysnKSB7XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuUExVUyk7XHJcblx0XHRcdHZhbHVlcy5wdXNoKGMpO1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHRcdGlmIChjID09ICctJykge1xyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLk1JTlVTKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goYyk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGMgPT0gJz0nKSB7XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuRVFVQUxTKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goYyk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGMgPT0gJyQnKSB7XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuRE9MTEFSKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goYyk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjID09ICcuJykge1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRpZiAoYyA9PSAnLicpIHtcclxuXHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkRPVUJMRURPVCk7XHJcblx0XHRcdFx0dmFsdWVzLnB1c2goXCIuLlwiKTtcclxuXHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChjID49ICcwJyAmJiBjIDw9ICc5Jykge1xyXG5cdFx0XHRcdHZhciBudW1iZXIgPSBcIi5cIiArIGM7XHJcblx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHR3aGlsZSAoYyA+PSAnMCcgJiYgYyA8PSAnOScpIHtcclxuXHRcdFx0XHRcdG51bWJlciArPSBjO1xyXG5cdFx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5OVU1CRVIpO1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKG51bWJlcik7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5ET1QpO1xyXG5cdFx0XHR2YWx1ZXMucHVzaCgnLicpO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYyA9PSAnXFwnJyB8fCBjID09ICdcIicpIHtcclxuXHRcdFx0dmFyIGRlbGltaXRlciA9IGM7XHJcblx0XHRcdHZhciBsaXRlcmFsID0gXCJcIjtcclxuXHRcdFx0d2hpbGUgKChjID0gcy5jaGFyQXQocG9zKyspKSAhPSBkZWxpbWl0ZXIpIHtcclxuXHRcdFx0XHRsaXRlcmFsICs9IGM7XHJcblx0XHRcdH1cclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5MSVRFUkFMKTtcclxuXHRcdFx0dmFsdWVzLnB1c2gobGl0ZXJhbCk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjID49ICcwJyAmJiBjIDw9ICc5Jykge1xyXG5cdFx0XHR2YXIgbnVtYmVyID0gYztcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0d2hpbGUgKGMgPj0gJzAnICYmIGMgPD0gJzknKSB7XHJcblx0XHRcdFx0bnVtYmVyICs9IGM7XHJcblx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoYyA9PSAnLicpIHtcclxuXHRcdFx0XHRpZiAocy5jaGFyQXQocG9zKSA+PSAnMCcgJiYgcy5jaGFyQXQocG9zKSA8PSAnOScpIHtcclxuXHRcdFx0XHRcdG51bWJlciArPSBjO1xyXG5cdFx0XHRcdFx0bnVtYmVyICs9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdFx0XHR3aGlsZSAoYyA+PSAnMCcgJiYgYyA8PSAnOScpIHtcclxuXHRcdFx0XHRcdFx0bnVtYmVyICs9IGM7XHJcblx0XHRcdFx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuTlVNQkVSKTtcclxuXHRcdFx0dmFsdWVzLnB1c2gobnVtYmVyKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGMgPT0gJyonKSB7XHJcblx0XHRcdGlmICh0eXBlcy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0dmFyIGxhc3QgPSB0eXBlc1t0eXBlcy5sZW5ndGggLSAxXTtcclxuXHRcdFx0XHRpZiAobGFzdCAhPSBYUGF0aFBhcnNlci5BVFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkRPVUJMRUNPTE9OXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTEVGVFBBUkVOVEhFU0lTXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTEVGVEJSQUNLRVRcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5BTkRcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5PUlxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLk1PRFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkRJVlxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLk1VTFRJUExZT1BFUkFUT1JcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5TTEFTSFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkRPVUJMRVNMQVNIXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuQkFSXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuUExVU1xyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLk1JTlVTXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuRVFVQUxTXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTk9URVFVQUxcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5MRVNTVEhBTlxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkxFU1NUSEFOT1JFUVVBTFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkdSRUFURVJUSEFOXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuR1JFQVRFUlRIQU5PUkVRVUFMKSB7XHJcblx0XHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLk1VTFRJUExZT1BFUkFUT1IpO1xyXG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goYyk7XHJcblx0XHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuQVNURVJJU0tOQU1FVEVTVCk7XHJcblx0XHRcdHZhbHVlcy5wdXNoKGMpO1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYyA9PSAnOicpIHtcclxuXHRcdFx0aWYgKHMuY2hhckF0KHBvcykgPT0gJzonKSB7XHJcblx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5ET1VCTEVDT0xPTik7XHJcblx0XHRcdFx0dmFsdWVzLnB1c2goXCI6OlwiKTtcclxuXHRcdFx0XHRwb3MrKztcclxuXHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGMgPT0gJy8nKSB7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGlmIChjID09ICcvJykge1xyXG5cdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuRE9VQkxFU0xBU0gpO1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKFwiLy9cIik7XHJcblx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLlNMQVNIKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goJy8nKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGMgPT0gJyEnKSB7XHJcblx0XHRcdGlmIChzLmNoYXJBdChwb3MpID09ICc9Jykge1xyXG5cdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuTk9URVFVQUwpO1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKFwiIT1cIik7XHJcblx0XHRcdFx0cG9zKys7XHJcblx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjID09ICc8Jykge1xyXG5cdFx0XHRpZiAocy5jaGFyQXQocG9zKSA9PSAnPScpIHtcclxuXHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkxFU1NUSEFOT1JFUVVBTCk7XHJcblx0XHRcdFx0dmFsdWVzLnB1c2goXCI8PVwiKTtcclxuXHRcdFx0XHRwb3MrKztcclxuXHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuTEVTU1RIQU4pO1xyXG5cdFx0XHR2YWx1ZXMucHVzaCgnPCcpO1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYyA9PSAnPicpIHtcclxuXHRcdFx0aWYgKHMuY2hhckF0KHBvcykgPT0gJz0nKSB7XHJcblx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5HUkVBVEVSVEhBTk9SRVFVQUwpO1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKFwiPj1cIik7XHJcblx0XHRcdFx0cG9zKys7XHJcblx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkdSRUFURVJUSEFOKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goJz4nKTtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGMgPT0gJ18nIHx8IFV0aWxpdGllcy5pc0xldHRlcihjLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0XHRcdHZhciBuYW1lID0gYztcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0d2hpbGUgKFV0aWxpdGllcy5pc05DTmFtZUNoYXIoYy5jaGFyQ29kZUF0KDApKSkge1xyXG5cdFx0XHRcdG5hbWUgKz0gYztcclxuXHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0eXBlcy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0dmFyIGxhc3QgPSB0eXBlc1t0eXBlcy5sZW5ndGggLSAxXTtcclxuXHRcdFx0XHRpZiAobGFzdCAhPSBYUGF0aFBhcnNlci5BVFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkRPVUJMRUNPTE9OXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTEVGVFBBUkVOVEhFU0lTXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTEVGVEJSQUNLRVRcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5BTkRcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5PUlxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLk1PRFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkRJVlxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLk1VTFRJUExZT1BFUkFUT1JcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5TTEFTSFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkRPVUJMRVNMQVNIXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuQkFSXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuUExVU1xyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLk1JTlVTXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuRVFVQUxTXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTk9URVFVQUxcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5MRVNTVEhBTlxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkxFU1NUSEFOT1JFUVVBTFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkdSRUFURVJUSEFOXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuR1JFQVRFUlRIQU5PUkVRVUFMKSB7XHJcblx0XHRcdFx0XHRpZiAobmFtZSA9PSBcImFuZFwiKSB7XHJcblx0XHRcdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuQU5EKTtcclxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2gobmFtZSk7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKG5hbWUgPT0gXCJvclwiKSB7XHJcblx0XHRcdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuT1IpO1xyXG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaChuYW1lKTtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAobmFtZSA9PSBcIm1vZFwiKSB7XHJcblx0XHRcdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuTU9EKTtcclxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2gobmFtZSk7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKG5hbWUgPT0gXCJkaXZcIikge1xyXG5cdFx0XHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkRJVik7XHJcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKG5hbWUpO1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGMgPT0gJzonKSB7XHJcblx0XHRcdFx0aWYgKHMuY2hhckF0KHBvcykgPT0gJyonKSB7XHJcblx0XHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLk5DTkFNRUNPTE9OQVNURVJJU0spO1xyXG5cdFx0XHRcdFx0dmFsdWVzLnB1c2gobmFtZSArIFwiOipcIik7XHJcblx0XHRcdFx0XHRwb3MrKztcclxuXHRcdFx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHMuY2hhckF0KHBvcykgPT0gJ18nIHx8IFV0aWxpdGllcy5pc0xldHRlcihzLmNoYXJDb2RlQXQocG9zKSkpIHtcclxuXHRcdFx0XHRcdG5hbWUgKz0gJzonO1xyXG5cdFx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHRcdHdoaWxlIChVdGlsaXRpZXMuaXNOQ05hbWVDaGFyKGMuY2hhckNvZGVBdCgwKSkpIHtcclxuXHRcdFx0XHRcdFx0bmFtZSArPSBjO1xyXG5cdFx0XHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKGMgPT0gJygnKSB7XHJcblx0XHRcdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuRlVOQ1RJT05OQU1FKTtcclxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2gobmFtZSk7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5RTkFNRSk7XHJcblx0XHRcdFx0XHR2YWx1ZXMucHVzaChuYW1lKTtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAocy5jaGFyQXQocG9zKSA9PSAnOicpIHtcclxuXHRcdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuQVhJU05BTUUpO1xyXG5cdFx0XHRcdFx0dmFsdWVzLnB1c2gobmFtZSk7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGMgPT0gJygnKSB7XHJcblx0XHRcdFx0aWYgKG5hbWUgPT0gXCJjb21tZW50XCIgfHwgbmFtZSA9PSBcInRleHRcIiB8fCBuYW1lID09IFwibm9kZVwiKSB7XHJcblx0XHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLk5PREVUWVBFKTtcclxuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKG5hbWUpO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChuYW1lID09IFwicHJvY2Vzc2luZy1pbnN0cnVjdGlvblwiKSB7XHJcblx0XHRcdFx0XHRpZiAocy5jaGFyQXQocG9zKSA9PSAnKScpIHtcclxuXHRcdFx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5OT0RFVFlQRSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLlBST0NFU1NJTkdJTlNUUlVDVElPTldJVEhMSVRFUkFMKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKG5hbWUpO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuRlVOQ1RJT05OQU1FKTtcclxuXHRcdFx0XHR2YWx1ZXMucHVzaChuYW1lKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLlFOQU1FKTtcclxuXHRcdFx0dmFsdWVzLnB1c2gobmFtZSk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyIFwiICsgYyk7XHJcblx0fVxyXG5cdHR5cGVzLnB1c2goMSk7XHJcblx0dmFsdWVzLnB1c2goXCJbRU9GXVwiKTtcclxuXHRyZXR1cm4gW3R5cGVzLCB2YWx1ZXNdO1xyXG59O1xyXG5cclxuWFBhdGhQYXJzZXIuU0hJRlQgPSAncyc7XHJcblhQYXRoUGFyc2VyLlJFRFVDRSA9ICdyJztcclxuWFBhdGhQYXJzZXIuQUNDRVBUID0gJ2EnO1xyXG5cclxuWFBhdGhQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24ocykge1xyXG5cdHZhciB0eXBlcztcclxuXHR2YXIgdmFsdWVzO1xyXG5cdHZhciByZXMgPSB0aGlzLnRva2VuaXplKHMpO1xyXG5cdGlmIChyZXMgPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHR0eXBlcyA9IHJlc1swXTtcclxuXHR2YWx1ZXMgPSByZXNbMV07XHJcblx0dmFyIHRva2VuUG9zID0gMDtcclxuXHR2YXIgc3RhdGUgPSBbXTtcclxuXHR2YXIgdG9rZW5UeXBlID0gW107XHJcblx0dmFyIHRva2VuVmFsdWUgPSBbXTtcclxuXHR2YXIgcztcclxuXHR2YXIgYTtcclxuXHR2YXIgdDtcclxuXHJcblx0c3RhdGUucHVzaCgwKTtcclxuXHR0b2tlblR5cGUucHVzaCgxKTtcclxuXHR0b2tlblZhbHVlLnB1c2goXCJfU1wiKTtcclxuXHJcblx0YSA9IHR5cGVzW3Rva2VuUG9zXTtcclxuXHR0ID0gdmFsdWVzW3Rva2VuUG9zKytdO1xyXG5cdHdoaWxlICgxKSB7XHJcblx0XHRzID0gc3RhdGVbc3RhdGUubGVuZ3RoIC0gMV07XHJcblx0XHRzd2l0Y2ggKFhQYXRoUGFyc2VyLmFjdGlvblRhYmxlW3NdLmNoYXJBdChhIC0gMSkpIHtcclxuXHRcdFx0Y2FzZSBYUGF0aFBhcnNlci5TSElGVDpcclxuXHRcdFx0XHR0b2tlblR5cGUucHVzaCgtYSk7XHJcblx0XHRcdFx0dG9rZW5WYWx1ZS5wdXNoKHQpO1xyXG5cdFx0XHRcdHN0YXRlLnB1c2goWFBhdGhQYXJzZXIuYWN0aW9uVGFibGVOdW1iZXJbc10uY2hhckNvZGVBdChhIC0gMSkgLSAzMik7XHJcblx0XHRcdFx0YSA9IHR5cGVzW3Rva2VuUG9zXTtcclxuXHRcdFx0XHR0ID0gdmFsdWVzW3Rva2VuUG9zKytdO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFhQYXRoUGFyc2VyLlJFRFVDRTpcclxuXHRcdFx0XHR2YXIgbnVtID0gWFBhdGhQYXJzZXIucHJvZHVjdGlvbnNbWFBhdGhQYXJzZXIuYWN0aW9uVGFibGVOdW1iZXJbc10uY2hhckNvZGVBdChhIC0gMSkgLSAzMl1bMV07XHJcblx0XHRcdFx0dmFyIHJocyA9IFtdO1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcclxuXHRcdFx0XHRcdHRva2VuVHlwZS5wb3AoKTtcclxuXHRcdFx0XHRcdHJocy51bnNoaWZ0KHRva2VuVmFsdWUucG9wKCkpO1xyXG5cdFx0XHRcdFx0c3RhdGUucG9wKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhciBzXyA9IHN0YXRlW3N0YXRlLmxlbmd0aCAtIDFdO1xyXG5cdFx0XHRcdHRva2VuVHlwZS5wdXNoKFhQYXRoUGFyc2VyLnByb2R1Y3Rpb25zW1hQYXRoUGFyc2VyLmFjdGlvblRhYmxlTnVtYmVyW3NdLmNoYXJDb2RlQXQoYSAtIDEpIC0gMzJdWzBdKTtcclxuXHRcdFx0XHRpZiAodGhpcy5yZWR1Y2VBY3Rpb25zW1hQYXRoUGFyc2VyLmFjdGlvblRhYmxlTnVtYmVyW3NdLmNoYXJDb2RlQXQoYSAtIDEpIC0gMzJdID09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0dG9rZW5WYWx1ZS5wdXNoKHJoc1swXSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRva2VuVmFsdWUucHVzaCh0aGlzLnJlZHVjZUFjdGlvbnNbWFBhdGhQYXJzZXIuYWN0aW9uVGFibGVOdW1iZXJbc10uY2hhckNvZGVBdChhIC0gMSkgLSAzMl0ocmhzKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHN0YXRlLnB1c2goWFBhdGhQYXJzZXIuZ290b1RhYmxlW3NfXS5jaGFyQ29kZUF0KFhQYXRoUGFyc2VyLnByb2R1Y3Rpb25zW1hQYXRoUGFyc2VyLmFjdGlvblRhYmxlTnVtYmVyW3NdLmNoYXJDb2RlQXQoYSAtIDEpIC0gMzJdWzBdIC0gMikgLSAzMyk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgWFBhdGhQYXJzZXIuQUNDRVBUOlxyXG5cdFx0XHRcdHJldHVybiBuZXcgWFBhdGgodG9rZW5WYWx1ZS5wb3AoKSk7XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiWFBhdGggcGFyc2UgZXJyb3JcIik7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuLy8gWFBhdGggLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5YUGF0aC5wcm90b3R5cGUgPSBuZXcgT2JqZWN0KCk7XHJcblhQYXRoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhQYXRoO1xyXG5YUGF0aC5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFhQYXRoKGUpIHtcclxuXHR0aGlzLmV4cHJlc3Npb24gPSBlO1xyXG59XHJcblxyXG5YUGF0aC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5leHByZXNzaW9uLnRvU3RyaW5nKCk7XHJcbn07XHJcblxyXG5YUGF0aC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0Yy5jb250ZXh0Tm9kZSA9IGMuZXhwcmVzc2lvbkNvbnRleHROb2RlO1xyXG5cdGMuY29udGV4dFNpemUgPSAxO1xyXG5cdGMuY29udGV4dFBvc2l0aW9uID0gMTtcclxuXHRjLmNhc2VJbnNlbnNpdGl2ZSA9IGZhbHNlO1xyXG5cdGlmIChjLmNvbnRleHROb2RlICE9IG51bGwpIHtcclxuXHRcdHZhciBkb2MgPSBjLmNvbnRleHROb2RlO1xyXG5cdFx0aWYgKGRvYy5ub2RlVHlwZSAhPSA5IC8qTm9kZS5ET0NVTUVOVF9OT0RFKi8pIHtcclxuXHRcdFx0ZG9jID0gZG9jLm93bmVyRG9jdW1lbnQ7XHJcblx0XHR9XHJcblx0XHR0cnkge1xyXG5cdFx0XHRjLmNhc2VJbnNlbnNpdGl2ZSA9IGRvYy5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKFwiSFRNTFwiLCBcIjIuMFwiKTtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Yy5jYXNlSW5zZW5zaXRpdmUgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKGMpO1xyXG59O1xyXG5cclxuWFBhdGguWE1MX05BTUVTUEFDRV9VUkkgPSBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiO1xyXG5YUGF0aC5YTUxOU19OQU1FU1BBQ0VfVVJJID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiO1xyXG5cclxuLy8gRXhwcmVzc2lvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5FeHByZXNzaW9uLnByb3RvdHlwZSA9IG5ldyBPYmplY3QoKTtcclxuRXhwcmVzc2lvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFeHByZXNzaW9uO1xyXG5FeHByZXNzaW9uLnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gRXhwcmVzc2lvbigpIHtcclxufVxyXG5cclxuRXhwcmVzc2lvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xyXG59O1xyXG5cclxuRXhwcmVzc2lvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCI8RXhwcmVzc2lvbj5cIjtcclxufTtcclxuXHJcbkV4cHJlc3Npb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBldmFsdWF0ZSBleHByZXNzaW9uLlwiKTtcclxufTtcclxuXHJcbi8vIFVuYXJ5T3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuVW5hcnlPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEV4cHJlc3Npb24oKTtcclxuVW5hcnlPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVW5hcnlPcGVyYXRpb247XHJcblVuYXJ5T3BlcmF0aW9uLnN1cGVyY2xhc3MgPSBFeHByZXNzaW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFVuYXJ5T3BlcmF0aW9uKHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5VbmFyeU9wZXJhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHJocykge1xyXG5cdHRoaXMucmhzID0gcmhzO1xyXG59O1xyXG5cclxuLy8gVW5hcnlNaW51c09wZXJhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5VbmFyeU1pbnVzT3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBVbmFyeU9wZXJhdGlvbigpO1xyXG5VbmFyeU1pbnVzT3BlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVuYXJ5TWludXNPcGVyYXRpb247XHJcblVuYXJ5TWludXNPcGVyYXRpb24uc3VwZXJjbGFzcyA9IFVuYXJ5T3BlcmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFVuYXJ5TWludXNPcGVyYXRpb24ocmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQocmhzKTtcclxuXHR9XHJcbn1cclxuXHJcblVuYXJ5TWludXNPcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihyaHMpIHtcclxuXHRVbmFyeU1pbnVzT3BlcmF0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIHJocyk7XHJcbn07XHJcblxyXG5VbmFyeU1pbnVzT3BlcmF0aW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcy5yaHMuZXZhbHVhdGUoYykubnVtYmVyKCkubmVnYXRlKCk7XHJcbn07XHJcblxyXG5VbmFyeU1pbnVzT3BlcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIi1cIiArIHRoaXMucmhzLnRvU3RyaW5nKCk7XHJcbn07XHJcblxyXG4vLyBCaW5hcnlPcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbkJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXhwcmVzc2lvbigpO1xyXG5CaW5hcnlPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmluYXJ5T3BlcmF0aW9uO1xyXG5CaW5hcnlPcGVyYXRpb24uc3VwZXJjbGFzcyA9IEV4cHJlc3Npb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gQmluYXJ5T3BlcmF0aW9uKGxocywgcmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQobGhzLCByaHMpO1xyXG5cdH1cclxufVxyXG5cclxuQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHR0aGlzLmxocyA9IGxocztcclxuXHR0aGlzLnJocyA9IHJocztcclxufTtcclxuXHJcbi8vIE9yT3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuT3JPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEJpbmFyeU9wZXJhdGlvbigpO1xyXG5Pck9wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPck9wZXJhdGlvbjtcclxuT3JPcGVyYXRpb24uc3VwZXJjbGFzcyA9IEJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBPck9wZXJhdGlvbihsaHMsIHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGxocywgcmhzKTtcclxuXHR9XHJcbn1cclxuXHJcbk9yT3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHRPck9wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBsaHMsIHJocyk7XHJcbn07XHJcblxyXG5Pck9wZXJhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCIoXCIgKyB0aGlzLmxocy50b1N0cmluZygpICsgXCIgb3IgXCIgKyB0aGlzLnJocy50b1N0cmluZygpICsgXCIpXCI7XHJcbn07XHJcblxyXG5Pck9wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0dmFyIGIgPSB0aGlzLmxocy5ldmFsdWF0ZShjKS5ib29sKCk7XHJcblx0aWYgKGIuYm9vbGVhblZhbHVlKCkpIHtcclxuXHRcdHJldHVybiBiO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5yaHMuZXZhbHVhdGUoYykuYm9vbCgpO1xyXG59O1xyXG5cclxuLy8gQW5kT3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5BbmRPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEJpbmFyeU9wZXJhdGlvbigpO1xyXG5BbmRPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQW5kT3BlcmF0aW9uO1xyXG5BbmRPcGVyYXRpb24uc3VwZXJjbGFzcyA9IEJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBBbmRPcGVyYXRpb24obGhzLCByaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChsaHMsIHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5BbmRPcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihsaHMsIHJocykge1xyXG5cdEFuZE9wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBsaHMsIHJocyk7XHJcbn07XHJcblxyXG5BbmRPcGVyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiKFwiICsgdGhpcy5saHMudG9TdHJpbmcoKSArIFwiIGFuZCBcIiArIHRoaXMucmhzLnRvU3RyaW5nKCkgKyBcIilcIjtcclxufTtcclxuXHJcbkFuZE9wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0dmFyIGIgPSB0aGlzLmxocy5ldmFsdWF0ZShjKS5ib29sKCk7XHJcblx0aWYgKCFiLmJvb2xlYW5WYWx1ZSgpKSB7XHJcblx0XHRyZXR1cm4gYjtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMucmhzLmV2YWx1YXRlKGMpLmJvb2woKTtcclxufTtcclxuXHJcbi8vIEVxdWFsc09wZXJhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuRXF1YWxzT3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBCaW5hcnlPcGVyYXRpb24oKTtcclxuRXF1YWxzT3BlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVxdWFsc09wZXJhdGlvbjtcclxuRXF1YWxzT3BlcmF0aW9uLnN1cGVyY2xhc3MgPSBCaW5hcnlPcGVyYXRpb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gRXF1YWxzT3BlcmF0aW9uKGxocywgcmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQobGhzLCByaHMpO1xyXG5cdH1cclxufVxyXG5cclxuRXF1YWxzT3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHRFcXVhbHNPcGVyYXRpb24uc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbGhzLCByaHMpO1xyXG59O1xyXG5cclxuRXF1YWxzT3BlcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIihcIiArIHRoaXMubGhzLnRvU3RyaW5nKCkgKyBcIiA9IFwiICsgdGhpcy5yaHMudG9TdHJpbmcoKSArIFwiKVwiO1xyXG59O1xyXG5cclxuRXF1YWxzT3BlcmF0aW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcy5saHMuZXZhbHVhdGUoYykuZXF1YWxzKHRoaXMucmhzLmV2YWx1YXRlKGMpKTtcclxufTtcclxuXHJcbi8vIE5vdEVxdWFsT3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuTm90RXF1YWxPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEJpbmFyeU9wZXJhdGlvbigpO1xyXG5Ob3RFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOb3RFcXVhbE9wZXJhdGlvbjtcclxuTm90RXF1YWxPcGVyYXRpb24uc3VwZXJjbGFzcyA9IEJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBOb3RFcXVhbE9wZXJhdGlvbihsaHMsIHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGxocywgcmhzKTtcclxuXHR9XHJcbn1cclxuXHJcbk5vdEVxdWFsT3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHROb3RFcXVhbE9wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBsaHMsIHJocyk7XHJcbn07XHJcblxyXG5Ob3RFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCIoXCIgKyB0aGlzLmxocy50b1N0cmluZygpICsgXCIgIT0gXCIgKyB0aGlzLnJocy50b1N0cmluZygpICsgXCIpXCI7XHJcbn07XHJcblxyXG5Ob3RFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXMubGhzLmV2YWx1YXRlKGMpLm5vdGVxdWFsKHRoaXMucmhzLmV2YWx1YXRlKGMpKTtcclxufTtcclxuXHJcbi8vIExlc3NUaGFuT3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuTGVzc1RoYW5PcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEJpbmFyeU9wZXJhdGlvbigpO1xyXG5MZXNzVGhhbk9wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMZXNzVGhhbk9wZXJhdGlvbjtcclxuTGVzc1RoYW5PcGVyYXRpb24uc3VwZXJjbGFzcyA9IEJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBMZXNzVGhhbk9wZXJhdGlvbihsaHMsIHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGxocywgcmhzKTtcclxuXHR9XHJcbn1cclxuXHJcbkxlc3NUaGFuT3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHRMZXNzVGhhbk9wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBsaHMsIHJocyk7XHJcbn07XHJcblxyXG5MZXNzVGhhbk9wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXMubGhzLmV2YWx1YXRlKGMpLmxlc3N0aGFuKHRoaXMucmhzLmV2YWx1YXRlKGMpKTtcclxufTtcclxuXHJcbkxlc3NUaGFuT3BlcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIihcIiArIHRoaXMubGhzLnRvU3RyaW5nKCkgKyBcIiA8IFwiICsgdGhpcy5yaHMudG9TdHJpbmcoKSArIFwiKVwiO1xyXG59O1xyXG5cclxuLy8gR3JlYXRlclRoYW5PcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5HcmVhdGVyVGhhbk9wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgQmluYXJ5T3BlcmF0aW9uKCk7XHJcbkdyZWF0ZXJUaGFuT3BlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdyZWF0ZXJUaGFuT3BlcmF0aW9uO1xyXG5HcmVhdGVyVGhhbk9wZXJhdGlvbi5zdXBlcmNsYXNzID0gQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIEdyZWF0ZXJUaGFuT3BlcmF0aW9uKGxocywgcmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQobGhzLCByaHMpO1xyXG5cdH1cclxufVxyXG5cclxuR3JlYXRlclRoYW5PcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihsaHMsIHJocykge1xyXG5cdEdyZWF0ZXJUaGFuT3BlcmF0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIGxocywgcmhzKTtcclxufTtcclxuXHJcbkdyZWF0ZXJUaGFuT3BlcmF0aW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcy5saHMuZXZhbHVhdGUoYykuZ3JlYXRlcnRoYW4odGhpcy5yaHMuZXZhbHVhdGUoYykpO1xyXG59O1xyXG5cclxuR3JlYXRlclRoYW5PcGVyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiKFwiICsgdGhpcy5saHMudG9TdHJpbmcoKSArIFwiID4gXCIgKyB0aGlzLnJocy50b1N0cmluZygpICsgXCIpXCI7XHJcbn07XHJcblxyXG4vLyBMZXNzVGhhbk9yRXF1YWxPcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbkxlc3NUaGFuT3JFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgQmluYXJ5T3BlcmF0aW9uKCk7XHJcbkxlc3NUaGFuT3JFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMZXNzVGhhbk9yRXF1YWxPcGVyYXRpb247XHJcbkxlc3NUaGFuT3JFcXVhbE9wZXJhdGlvbi5zdXBlcmNsYXNzID0gQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIExlc3NUaGFuT3JFcXVhbE9wZXJhdGlvbihsaHMsIHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGxocywgcmhzKTtcclxuXHR9XHJcbn1cclxuXHJcbkxlc3NUaGFuT3JFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XHJcblx0TGVzc1RoYW5PckVxdWFsT3BlcmF0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIGxocywgcmhzKTtcclxufTtcclxuXHJcbkxlc3NUaGFuT3JFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXMubGhzLmV2YWx1YXRlKGMpLmxlc3N0aGFub3JlcXVhbCh0aGlzLnJocy5ldmFsdWF0ZShjKSk7XHJcbn07XHJcblxyXG5MZXNzVGhhbk9yRXF1YWxPcGVyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiKFwiICsgdGhpcy5saHMudG9TdHJpbmcoKSArIFwiIDw9IFwiICsgdGhpcy5yaHMudG9TdHJpbmcoKSArIFwiKVwiO1xyXG59O1xyXG5cclxuLy8gR3JlYXRlclRoYW5PckVxdWFsT3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5HcmVhdGVyVGhhbk9yRXF1YWxPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEJpbmFyeU9wZXJhdGlvbigpO1xyXG5HcmVhdGVyVGhhbk9yRXF1YWxPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR3JlYXRlclRoYW5PckVxdWFsT3BlcmF0aW9uO1xyXG5HcmVhdGVyVGhhbk9yRXF1YWxPcGVyYXRpb24uc3VwZXJjbGFzcyA9IEJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBHcmVhdGVyVGhhbk9yRXF1YWxPcGVyYXRpb24obGhzLCByaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChsaHMsIHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5HcmVhdGVyVGhhbk9yRXF1YWxPcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihsaHMsIHJocykge1xyXG5cdEdyZWF0ZXJUaGFuT3JFcXVhbE9wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBsaHMsIHJocyk7XHJcbn07XHJcblxyXG5HcmVhdGVyVGhhbk9yRXF1YWxPcGVyYXRpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiB0aGlzLmxocy5ldmFsdWF0ZShjKS5ncmVhdGVydGhhbm9yZXF1YWwodGhpcy5yaHMuZXZhbHVhdGUoYykpO1xyXG59O1xyXG5cclxuR3JlYXRlclRoYW5PckVxdWFsT3BlcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIihcIiArIHRoaXMubGhzLnRvU3RyaW5nKCkgKyBcIiA+PSBcIiArIHRoaXMucmhzLnRvU3RyaW5nKCkgKyBcIilcIjtcclxufTtcclxuXHJcbi8vIFBsdXNPcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuUGx1c09wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgQmluYXJ5T3BlcmF0aW9uKCk7XHJcblBsdXNPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGx1c09wZXJhdGlvbjtcclxuUGx1c09wZXJhdGlvbi5zdXBlcmNsYXNzID0gQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFBsdXNPcGVyYXRpb24obGhzLCByaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChsaHMsIHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5QbHVzT3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHRQbHVzT3BlcmF0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIGxocywgcmhzKTtcclxufTtcclxuXHJcblBsdXNPcGVyYXRpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiB0aGlzLmxocy5ldmFsdWF0ZShjKS5udW1iZXIoKS5wbHVzKHRoaXMucmhzLmV2YWx1YXRlKGMpLm51bWJlcigpKTtcclxufTtcclxuXHJcblBsdXNPcGVyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiKFwiICsgdGhpcy5saHMudG9TdHJpbmcoKSArIFwiICsgXCIgKyB0aGlzLnJocy50b1N0cmluZygpICsgXCIpXCI7XHJcbn07XHJcblxyXG4vLyBNaW51c09wZXJhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbk1pbnVzT3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBCaW5hcnlPcGVyYXRpb24oKTtcclxuTWludXNPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWludXNPcGVyYXRpb247XHJcbk1pbnVzT3BlcmF0aW9uLnN1cGVyY2xhc3MgPSBCaW5hcnlPcGVyYXRpb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gTWludXNPcGVyYXRpb24obGhzLCByaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChsaHMsIHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5NaW51c09wZXJhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XHJcblx0TWludXNPcGVyYXRpb24uc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbGhzLCByaHMpO1xyXG59O1xyXG5cclxuTWludXNPcGVyYXRpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiB0aGlzLmxocy5ldmFsdWF0ZShjKS5udW1iZXIoKS5taW51cyh0aGlzLnJocy5ldmFsdWF0ZShjKS5udW1iZXIoKSk7XHJcbn07XHJcblxyXG5NaW51c09wZXJhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCIoXCIgKyB0aGlzLmxocy50b1N0cmluZygpICsgXCIgLSBcIiArIHRoaXMucmhzLnRvU3RyaW5nKCkgKyBcIilcIjtcclxufTtcclxuXHJcbi8vIE11bHRpcGx5T3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuTXVsdGlwbHlPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEJpbmFyeU9wZXJhdGlvbigpO1xyXG5NdWx0aXBseU9wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNdWx0aXBseU9wZXJhdGlvbjtcclxuTXVsdGlwbHlPcGVyYXRpb24uc3VwZXJjbGFzcyA9IEJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBNdWx0aXBseU9wZXJhdGlvbihsaHMsIHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGxocywgcmhzKTtcclxuXHR9XHJcbn1cclxuXHJcbk11bHRpcGx5T3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHRNdWx0aXBseU9wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBsaHMsIHJocyk7XHJcbn07XHJcblxyXG5NdWx0aXBseU9wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXMubGhzLmV2YWx1YXRlKGMpLm51bWJlcigpLm11bHRpcGx5KHRoaXMucmhzLmV2YWx1YXRlKGMpLm51bWJlcigpKTtcclxufTtcclxuXHJcbk11bHRpcGx5T3BlcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIihcIiArIHRoaXMubGhzLnRvU3RyaW5nKCkgKyBcIiAqIFwiICsgdGhpcy5yaHMudG9TdHJpbmcoKSArIFwiKVwiO1xyXG59O1xyXG5cclxuLy8gRGl2T3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5EaXZPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEJpbmFyeU9wZXJhdGlvbigpO1xyXG5EaXZPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGl2T3BlcmF0aW9uO1xyXG5EaXZPcGVyYXRpb24uc3VwZXJjbGFzcyA9IEJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBEaXZPcGVyYXRpb24obGhzLCByaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChsaHMsIHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5EaXZPcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihsaHMsIHJocykge1xyXG5cdERpdk9wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBsaHMsIHJocyk7XHJcbn07XHJcblxyXG5EaXZPcGVyYXRpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiB0aGlzLmxocy5ldmFsdWF0ZShjKS5udW1iZXIoKS5kaXYodGhpcy5yaHMuZXZhbHVhdGUoYykubnVtYmVyKCkpO1xyXG59O1xyXG5cclxuRGl2T3BlcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIihcIiArIHRoaXMubGhzLnRvU3RyaW5nKCkgKyBcIiBkaXYgXCIgKyB0aGlzLnJocy50b1N0cmluZygpICsgXCIpXCI7XHJcbn07XHJcblxyXG4vLyBNb2RPcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbk1vZE9wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgQmluYXJ5T3BlcmF0aW9uKCk7XHJcbk1vZE9wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNb2RPcGVyYXRpb247XHJcbk1vZE9wZXJhdGlvbi5zdXBlcmNsYXNzID0gQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIE1vZE9wZXJhdGlvbihsaHMsIHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGxocywgcmhzKTtcclxuXHR9XHJcbn1cclxuXHJcbk1vZE9wZXJhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XHJcblx0TW9kT3BlcmF0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIGxocywgcmhzKTtcclxufTtcclxuXHJcbk1vZE9wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXMubGhzLmV2YWx1YXRlKGMpLm51bWJlcigpLm1vZCh0aGlzLnJocy5ldmFsdWF0ZShjKS5udW1iZXIoKSk7XHJcbn07XHJcblxyXG5Nb2RPcGVyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiKFwiICsgdGhpcy5saHMudG9TdHJpbmcoKSArIFwiIG1vZCBcIiArIHRoaXMucmhzLnRvU3RyaW5nKCkgKyBcIilcIjtcclxufTtcclxuXHJcbi8vIEJhck9wZXJhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuQmFyT3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBCaW5hcnlPcGVyYXRpb24oKTtcclxuQmFyT3BlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJhck9wZXJhdGlvbjtcclxuQmFyT3BlcmF0aW9uLnN1cGVyY2xhc3MgPSBCaW5hcnlPcGVyYXRpb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gQmFyT3BlcmF0aW9uKGxocywgcmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQobGhzLCByaHMpO1xyXG5cdH1cclxufVxyXG5cclxuQmFyT3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHRCYXJPcGVyYXRpb24uc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbGhzLCByaHMpO1xyXG59O1xyXG5cclxuQmFyT3BlcmF0aW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcy5saHMuZXZhbHVhdGUoYykubm9kZXNldCgpLnVuaW9uKHRoaXMucmhzLmV2YWx1YXRlKGMpLm5vZGVzZXQoKSk7XHJcbn07XHJcblxyXG5CYXJPcGVyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMubGhzLnRvU3RyaW5nKCkgKyBcIiB8IFwiICsgdGhpcy5yaHMudG9TdHJpbmcoKTtcclxufTtcclxuXHJcbi8vIFBhdGhFeHByIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuUGF0aEV4cHIucHJvdG90eXBlID0gbmV3IEV4cHJlc3Npb24oKTtcclxuUGF0aEV4cHIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGF0aEV4cHI7XHJcblBhdGhFeHByLnN1cGVyY2xhc3MgPSBFeHByZXNzaW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFBhdGhFeHByKGZpbHRlciwgZmlsdGVyUHJlZHMsIGxvY3BhdGgpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChmaWx0ZXIsIGZpbHRlclByZWRzLCBsb2NwYXRoKTtcclxuXHR9XHJcbn1cclxuXHJcblBhdGhFeHByLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oZmlsdGVyLCBmaWx0ZXJQcmVkcywgbG9jcGF0aCkge1xyXG5cdFBhdGhFeHByLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMpO1xyXG5cdHRoaXMuZmlsdGVyID0gZmlsdGVyO1xyXG5cdHRoaXMuZmlsdGVyUHJlZGljYXRlcyA9IGZpbHRlclByZWRzO1xyXG5cdHRoaXMubG9jYXRpb25QYXRoID0gbG9jcGF0aDtcclxufTtcclxuXHJcblBhdGhFeHByLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHR2YXIgbm9kZXM7XHJcblx0dmFyIHhwYyA9IG5ldyBYUGF0aENvbnRleHQoKTtcclxuXHR4cGMudmFyaWFibGVSZXNvbHZlciA9IGMudmFyaWFibGVSZXNvbHZlcjtcclxuXHR4cGMuZnVuY3Rpb25SZXNvbHZlciA9IGMuZnVuY3Rpb25SZXNvbHZlcjtcclxuXHR4cGMubmFtZXNwYWNlUmVzb2x2ZXIgPSBjLm5hbWVzcGFjZVJlc29sdmVyO1xyXG5cdHhwYy5leHByZXNzaW9uQ29udGV4dE5vZGUgPSBjLmV4cHJlc3Npb25Db250ZXh0Tm9kZTtcclxuXHR4cGMudmlydHVhbFJvb3QgPSBjLnZpcnR1YWxSb290O1xyXG5cdHhwYy5jYXNlSW5zZW5zaXRpdmUgPSBjLmNhc2VJbnNlbnNpdGl2ZTtcclxuXHRpZiAodGhpcy5maWx0ZXIgPT0gbnVsbCkge1xyXG5cdFx0bm9kZXMgPSBbIGMuY29udGV4dE5vZGUgXTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dmFyIG5zID0gdGhpcy5maWx0ZXIuZXZhbHVhdGUoYyk7XHJcblx0XHRpZiAoIVV0aWxpdGllcy5pbnN0YW5jZV9vZihucywgWE5vZGVTZXQpKSB7XHJcblx0XHRcdGlmICh0aGlzLmZpbHRlclByZWRpY2F0ZXMgIT0gbnVsbCAmJiB0aGlzLmZpbHRlclByZWRpY2F0ZXMubGVuZ3RoID4gMCB8fCB0aGlzLmxvY2F0aW9uUGF0aCAhPSBudWxsKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGF0aCBleHByZXNzaW9uIGZpbHRlciBtdXN0IGV2YWx1YXRlIHRvIGEgbm9kc2V0IGlmIHByZWRpY2F0ZXMgb3IgbG9jYXRpb24gcGF0aCBhcmUgdXNlZFwiKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbnM7XHJcblx0XHR9XHJcblx0XHRub2RlcyA9IG5zLnRvQXJyYXkoKTtcclxuXHRcdGlmICh0aGlzLmZpbHRlclByZWRpY2F0ZXMgIT0gbnVsbCkge1xyXG5cdFx0XHQvLyBhcHBseSBlYWNoIG9mIHRoZSBwcmVkaWNhdGVzIGluIHR1cm5cclxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmZpbHRlclByZWRpY2F0ZXMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHR2YXIgcHJlZCA9IHRoaXMuZmlsdGVyUHJlZGljYXRlc1tqXTtcclxuXHRcdFx0XHR2YXIgbmV3Tm9kZXMgPSBbXTtcclxuXHRcdFx0XHR4cGMuY29udGV4dFNpemUgPSBub2Rlcy5sZW5ndGg7XHJcblx0XHRcdFx0Zm9yICh4cGMuY29udGV4dFBvc2l0aW9uID0gMTsgeHBjLmNvbnRleHRQb3NpdGlvbiA8PSB4cGMuY29udGV4dFNpemU7IHhwYy5jb250ZXh0UG9zaXRpb24rKykge1xyXG5cdFx0XHRcdFx0eHBjLmNvbnRleHROb2RlID0gbm9kZXNbeHBjLmNvbnRleHRQb3NpdGlvbiAtIDFdO1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMucHJlZGljYXRlTWF0Y2hlcyhwcmVkLCB4cGMpKSB7XHJcblx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2goeHBjLmNvbnRleHROb2RlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bm9kZXMgPSBuZXdOb2RlcztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAodGhpcy5sb2NhdGlvblBhdGggIT0gbnVsbCkge1xyXG5cdFx0aWYgKHRoaXMubG9jYXRpb25QYXRoLmFic29sdXRlKSB7XHJcblx0XHRcdGlmIChub2Rlc1swXS5ub2RlVHlwZSAhPSA5IC8qTm9kZS5ET0NVTUVOVF9OT0RFKi8pIHtcclxuXHRcdFx0XHRpZiAoeHBjLnZpcnR1YWxSb290ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdG5vZGVzID0gWyB4cGMudmlydHVhbFJvb3QgXTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKG5vZGVzWzBdLm93bmVyRG9jdW1lbnQgPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHQvLyBJRSA1LjUgZG9lc24ndCBoYXZlIG93bmVyRG9jdW1lbnQ/XHJcblx0XHRcdFx0XHRcdHZhciBuID0gbm9kZXNbMF07XHJcblx0XHRcdFx0XHRcdHdoaWxlIChuLnBhcmVudE5vZGUgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdG4gPSBuLnBhcmVudE5vZGU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0bm9kZXMgPSBbIG4gXTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdG5vZGVzID0gWyBub2Rlc1swXS5vd25lckRvY3VtZW50IF07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG5vZGVzID0gWyBub2Rlc1swXSBdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubG9jYXRpb25QYXRoLnN0ZXBzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBzdGVwID0gdGhpcy5sb2NhdGlvblBhdGguc3RlcHNbaV07XHJcblx0XHRcdHZhciBuZXdOb2RlcyA9IFtdO1xyXG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0eHBjLmNvbnRleHROb2RlID0gbm9kZXNbal07XHJcblx0XHRcdFx0c3dpdGNoIChzdGVwLmF4aXMpIHtcclxuXHRcdFx0XHRcdGNhc2UgU3RlcC5BTkNFU1RPUjpcclxuXHRcdFx0XHRcdFx0Ly8gbG9vayBhdCBhbGwgdGhlIGFuY2VzdG9yIG5vZGVzXHJcblx0XHRcdFx0XHRcdGlmICh4cGMuY29udGV4dE5vZGUgPT09IHhwYy52aXJ0dWFsUm9vdCkge1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHZhciBtO1xyXG5cdFx0XHRcdFx0XHRpZiAoeHBjLmNvbnRleHROb2RlLm5vZGVUeXBlID09IDIgLypOb2RlLkFUVFJJQlVURV9OT0RFKi8pIHtcclxuXHRcdFx0XHRcdFx0XHRtID0gdGhpcy5nZXRPd25lckVsZW1lbnQoeHBjLmNvbnRleHROb2RlKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRtID0geHBjLmNvbnRleHROb2RlLnBhcmVudE5vZGU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0d2hpbGUgKG0gIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChzdGVwLm5vZGVUZXN0Lm1hdGNoZXMobSwgeHBjKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0bmV3Tm9kZXMucHVzaChtKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0aWYgKG0gPT09IHhwYy52aXJ0dWFsUm9vdCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdG0gPSBtLnBhcmVudE5vZGU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBTdGVwLkFOQ0VTVE9ST1JTRUxGOlxyXG5cdFx0XHRcdFx0XHQvLyBsb29rIGF0IGFsbCB0aGUgYW5jZXN0b3Igbm9kZXMgYW5kIHRoZSBjdXJyZW50IG5vZGVcclxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgbSA9IHhwYy5jb250ZXh0Tm9kZTsgbSAhPSBudWxsOyBtID0gbS5ub2RlVHlwZSA9PSAyIC8qTm9kZS5BVFRSSUJVVEVfTk9ERSovID8gdGhpcy5nZXRPd25lckVsZW1lbnQobSkgOiBtLnBhcmVudE5vZGUpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoc3RlcC5ub2RlVGVzdC5tYXRjaGVzKG0sIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2gobSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGlmIChtID09PSB4cGMudmlydHVhbFJvb3QpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFN0ZXAuQVRUUklCVVRFOlxyXG5cdFx0XHRcdFx0XHQvLyBsb29rIGF0IHRoZSBhdHRyaWJ1dGVzXHJcblx0XHRcdFx0XHRcdHZhciBubm0gPSB4cGMuY29udGV4dE5vZGUuYXR0cmlidXRlcztcclxuXHRcdFx0XHRcdFx0aWYgKG5ubSAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBubm0ubGVuZ3RoOyBrKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBtID0gbm5tLml0ZW0oayk7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoc3RlcC5ub2RlVGVzdC5tYXRjaGVzKG0sIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3Tm9kZXMucHVzaChtKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBTdGVwLkNISUxEOlxyXG5cdFx0XHRcdFx0XHQvLyBsb29rIGF0IGFsbCBjaGlsZCBlbGVtZW50c1xyXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBtID0geHBjLmNvbnRleHROb2RlLmZpcnN0Q2hpbGQ7IG0gIT0gbnVsbDsgbSA9IG0ubmV4dFNpYmxpbmcpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoc3RlcC5ub2RlVGVzdC5tYXRjaGVzKG0sIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2gobSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgU3RlcC5ERVNDRU5EQU5UOlxyXG5cdFx0XHRcdFx0XHQvLyBsb29rIGF0IGFsbCBkZXNjZW5kYW50IG5vZGVzXHJcblx0XHRcdFx0XHRcdHZhciBzdCA9IFsgeHBjLmNvbnRleHROb2RlLmZpcnN0Q2hpbGQgXTtcclxuXHRcdFx0XHRcdFx0d2hpbGUgKHN0Lmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBtID0gc3QucG9wKCk7IG0gIT0gbnVsbDsgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoc3RlcC5ub2RlVGVzdC5tYXRjaGVzKG0sIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3Tm9kZXMucHVzaChtKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdGlmIChtLmZpcnN0Q2hpbGQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRzdC5wdXNoKG0ubmV4dFNpYmxpbmcpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRtID0gbS5maXJzdENoaWxkO1xyXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bSA9IG0ubmV4dFNpYmxpbmc7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgU3RlcC5ERVNDRU5EQU5UT1JTRUxGOlxyXG5cdFx0XHRcdFx0XHQvLyBsb29rIGF0IHNlbGZcclxuXHRcdFx0XHRcdFx0aWYgKHN0ZXAubm9kZVRlc3QubWF0Y2hlcyh4cGMuY29udGV4dE5vZGUsIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRuZXdOb2Rlcy5wdXNoKHhwYy5jb250ZXh0Tm9kZSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0Ly8gbG9vayBhdCBhbGwgZGVzY2VuZGFudCBub2Rlc1xyXG5cdFx0XHRcdFx0XHR2YXIgc3QgPSBbIHhwYy5jb250ZXh0Tm9kZS5maXJzdENoaWxkIF07XHJcblx0XHRcdFx0XHRcdHdoaWxlIChzdC5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgbSA9IHN0LnBvcCgpOyBtICE9IG51bGw7ICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHN0ZXAubm9kZVRlc3QubWF0Y2hlcyhtLCB4cGMpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2gobSk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAobS5maXJzdENoaWxkICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0c3QucHVzaChtLm5leHRTaWJsaW5nKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bSA9IG0uZmlyc3RDaGlsZDtcclxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG0gPSBtLm5leHRTaWJsaW5nO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFN0ZXAuRk9MTE9XSU5HOlxyXG5cdFx0XHRcdFx0XHRpZiAoeHBjLmNvbnRleHROb2RlID09PSB4cGMudmlydHVhbFJvb3QpIHtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR2YXIgc3QgPSBbXTtcclxuXHRcdFx0XHRcdFx0aWYgKHhwYy5jb250ZXh0Tm9kZS5maXJzdENoaWxkICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRzdC51bnNoaWZ0KHhwYy5jb250ZXh0Tm9kZS5maXJzdENoaWxkKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRzdC51bnNoaWZ0KHhwYy5jb250ZXh0Tm9kZS5uZXh0U2libGluZyk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgbSA9IHhwYy5jb250ZXh0Tm9kZS5wYXJlbnROb2RlOyBtICE9IG51bGwgJiYgbS5ub2RlVHlwZSAhPSA5IC8qTm9kZS5ET0NVTUVOVF9OT0RFKi8gJiYgbSAhPT0geHBjLnZpcnR1YWxSb290OyBtID0gbS5wYXJlbnROb2RlKSB7XHJcblx0XHRcdFx0XHRcdFx0c3QudW5zaGlmdChtLm5leHRTaWJsaW5nKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRkbyB7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgbSA9IHN0LnBvcCgpOyBtICE9IG51bGw7ICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHN0ZXAubm9kZVRlc3QubWF0Y2hlcyhtLCB4cGMpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2gobSk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAobS5maXJzdENoaWxkICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0c3QucHVzaChtLm5leHRTaWJsaW5nKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bSA9IG0uZmlyc3RDaGlsZDtcclxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG0gPSBtLm5leHRTaWJsaW5nO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSB3aGlsZSAoc3QubGVuZ3RoID4gMCk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgU3RlcC5GT0xMT1dJTkdTSUJMSU5HOlxyXG5cdFx0XHRcdFx0XHRpZiAoeHBjLmNvbnRleHROb2RlID09PSB4cGMudmlydHVhbFJvb3QpIHtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBtID0geHBjLmNvbnRleHROb2RlLm5leHRTaWJsaW5nOyBtICE9IG51bGw7IG0gPSBtLm5leHRTaWJsaW5nKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKHN0ZXAubm9kZVRlc3QubWF0Y2hlcyhtLCB4cGMpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRuZXdOb2Rlcy5wdXNoKG0pO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFN0ZXAuTkFNRVNQQUNFOlxyXG5cdFx0XHRcdFx0XHR2YXIgbiA9IHt9O1xyXG5cdFx0XHRcdFx0XHRpZiAoeHBjLmNvbnRleHROb2RlLm5vZGVUeXBlID09IDEgLypOb2RlLkVMRU1FTlRfTk9ERSovKSB7XHJcblx0XHRcdFx0XHRcdFx0bltcInhtbFwiXSA9IFhQYXRoLlhNTF9OQU1FU1BBQ0VfVVJJO1xyXG5cdFx0XHRcdFx0XHRcdG5bXCJ4bWxuc1wiXSA9IFhQYXRoLlhNTE5TX05BTUVTUEFDRV9VUkk7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgbSA9IHhwYy5jb250ZXh0Tm9kZTsgbSAhPSBudWxsICYmIG0ubm9kZVR5cGUgPT0gMSAvKk5vZGUuRUxFTUVOVF9OT0RFKi87IG0gPSBtLnBhcmVudE5vZGUpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgbS5hdHRyaWJ1dGVzLmxlbmd0aDsgaysrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBhdHRyID0gbS5hdHRyaWJ1dGVzLml0ZW0oayk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBubSA9IFN0cmluZyhhdHRyLm5hbWUpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAobm0gPT0gXCJ4bWxuc1wiKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKG5bXCJcIl0gPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuW1wiXCJdID0gYXR0ci52YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobm0ubGVuZ3RoID4gNiAmJiBubS5zdWJzdHJpbmcoMCwgNikgPT0gXCJ4bWxuczpcIikge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBwcmUgPSBubS5zdWJzdHJpbmcoNiwgbm0ubGVuZ3RoKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAobltwcmVdID09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bltwcmVdID0gYXR0ci52YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgcHJlIGluIG4pIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBuc24gPSBuZXcgTmFtZXNwYWNlTm9kZShwcmUsIG5bcHJlXSwgeHBjLmNvbnRleHROb2RlKTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmIChzdGVwLm5vZGVUZXN0Lm1hdGNoZXMobnNuLCB4cGMpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2gobnNuKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBTdGVwLlBBUkVOVDpcclxuXHRcdFx0XHRcdFx0bSA9IG51bGw7XHJcblx0XHRcdFx0XHRcdGlmICh4cGMuY29udGV4dE5vZGUgIT09IHhwYy52aXJ0dWFsUm9vdCkge1xyXG5cdFx0XHRcdFx0XHRcdGlmICh4cGMuY29udGV4dE5vZGUubm9kZVR5cGUgPT0gMiAvKk5vZGUuQVRUUklCVVRFX05PREUqLykge1xyXG5cdFx0XHRcdFx0XHRcdFx0bSA9IHRoaXMuZ2V0T3duZXJFbGVtZW50KHhwYy5jb250ZXh0Tm9kZSk7XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdG0gPSB4cGMuY29udGV4dE5vZGUucGFyZW50Tm9kZTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYgKG0gIT0gbnVsbCAmJiBzdGVwLm5vZGVUZXN0Lm1hdGNoZXMobSwgeHBjKSkge1xyXG5cdFx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2gobSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBTdGVwLlBSRUNFRElORzpcclxuXHRcdFx0XHRcdFx0dmFyIHN0O1xyXG5cdFx0XHRcdFx0XHRpZiAoeHBjLnZpcnR1YWxSb290ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRzdCA9IFsgeHBjLnZpcnR1YWxSb290IF07XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0c3QgPSB4cGMuY29udGV4dE5vZGUubm9kZVR5cGUgPT0gOSAvKk5vZGUuRE9DVU1FTlRfTk9ERSovXHJcblx0XHRcdFx0XHRcdFx0XHQ/IFsgeHBjLmNvbnRleHROb2RlIF1cclxuXHRcdFx0XHRcdFx0XHRcdDogWyB4cGMuY29udGV4dE5vZGUub3duZXJEb2N1bWVudCBdO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdG91dGVyOiB3aGlsZSAoc3QubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIG0gPSBzdC5wb3AoKTsgbSAhPSBudWxsOyApIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmIChtID09IHhwYy5jb250ZXh0Tm9kZSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhayBvdXRlcjtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdGlmIChzdGVwLm5vZGVUZXN0Lm1hdGNoZXMobSwgeHBjKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdOb2Rlcy51bnNoaWZ0KG0pO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKG0uZmlyc3RDaGlsZCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHN0LnB1c2gobS5uZXh0U2libGluZyk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG0gPSBtLmZpcnN0Q2hpbGQ7XHJcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRtID0gbS5uZXh0U2libGluZztcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBTdGVwLlBSRUNFRElOR1NJQkxJTkc6XHJcblx0XHRcdFx0XHRcdGlmICh4cGMuY29udGV4dE5vZGUgPT09IHhwYy52aXJ0dWFsUm9vdCkge1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGZvciAodmFyIG0gPSB4cGMuY29udGV4dE5vZGUucHJldmlvdXNTaWJsaW5nOyBtICE9IG51bGw7IG0gPSBtLnByZXZpb3VzU2libGluZykge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChzdGVwLm5vZGVUZXN0Lm1hdGNoZXMobSwgeHBjKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0bmV3Tm9kZXMucHVzaChtKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBTdGVwLlNFTEY6XHJcblx0XHRcdFx0XHRcdGlmIChzdGVwLm5vZGVUZXN0Lm1hdGNoZXMoeHBjLmNvbnRleHROb2RlLCB4cGMpKSB7XHJcblx0XHRcdFx0XHRcdFx0bmV3Tm9kZXMucHVzaCh4cGMuY29udGV4dE5vZGUpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdG5vZGVzID0gbmV3Tm9kZXM7XHJcblx0XHRcdC8vIGFwcGx5IGVhY2ggb2YgdGhlIHByZWRpY2F0ZXMgaW4gdHVyblxyXG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHN0ZXAucHJlZGljYXRlcy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHZhciBwcmVkID0gc3RlcC5wcmVkaWNhdGVzW2pdO1xyXG5cdFx0XHRcdHZhciBuZXdOb2RlcyA9IFtdO1xyXG5cdFx0XHRcdHhwYy5jb250ZXh0U2l6ZSA9IG5vZGVzLmxlbmd0aDtcclxuXHRcdFx0XHRmb3IgKHhwYy5jb250ZXh0UG9zaXRpb24gPSAxOyB4cGMuY29udGV4dFBvc2l0aW9uIDw9IHhwYy5jb250ZXh0U2l6ZTsgeHBjLmNvbnRleHRQb3NpdGlvbisrKSB7XHJcblx0XHRcdFx0XHR4cGMuY29udGV4dE5vZGUgPSBub2Rlc1t4cGMuY29udGV4dFBvc2l0aW9uIC0gMV07XHJcblx0XHRcdFx0XHRpZiAodGhpcy5wcmVkaWNhdGVNYXRjaGVzKHByZWQsIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0bmV3Tm9kZXMucHVzaCh4cGMuY29udGV4dE5vZGUpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bm9kZXMgPSBuZXdOb2RlcztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHR2YXIgbnMgPSBuZXcgWE5vZGVTZXQoKTtcclxuXHRucy5hZGRBcnJheShub2Rlcyk7XHJcblx0cmV0dXJuIG5zO1xyXG59O1xyXG5cclxuUGF0aEV4cHIucHJvdG90eXBlLnByZWRpY2F0ZU1hdGNoZXMgPSBmdW5jdGlvbihwcmVkLCBjKSB7XHJcblx0dmFyIHJlcyA9IHByZWQuZXZhbHVhdGUoYyk7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyZXMsIFhOdW1iZXIpKSB7XHJcblx0XHRyZXR1cm4gYy5jb250ZXh0UG9zaXRpb24gPT0gcmVzLm51bWJlclZhbHVlKCk7XHJcblx0fVxyXG5cdHJldHVybiByZXMuYm9vbGVhblZhbHVlKCk7XHJcbn07XHJcblxyXG5QYXRoRXhwci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRpZiAodGhpcy5maWx0ZXIgIT0gdW5kZWZpbmVkKSB7XHJcblx0XHR2YXIgcyA9IHRoaXMuZmlsdGVyLnRvU3RyaW5nKCk7XHJcblx0XHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHRoaXMuZmlsdGVyLCBYU3RyaW5nKSkge1xyXG5cdFx0XHRzID0gXCInXCIgKyBzICsgXCInXCI7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5maWx0ZXJQcmVkaWNhdGVzICE9IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmlsdGVyUHJlZGljYXRlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdHMgPSBzICsgXCJbXCIgKyB0aGlzLmZpbHRlclByZWRpY2F0ZXNbaV0udG9TdHJpbmcoKSArIFwiXVwiO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5sb2NhdGlvblBhdGggIT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGlmICghdGhpcy5sb2NhdGlvblBhdGguYWJzb2x1dGUpIHtcclxuXHRcdFx0XHRzICs9IFwiL1wiO1xyXG5cdFx0XHR9XHJcblx0XHRcdHMgKz0gdGhpcy5sb2NhdGlvblBhdGgudG9TdHJpbmcoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBzO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5sb2NhdGlvblBhdGgudG9TdHJpbmcoKTtcclxufTtcclxuXHJcblBhdGhFeHByLnByb3RvdHlwZS5nZXRPd25lckVsZW1lbnQgPSBmdW5jdGlvbihuKSB7XHJcblx0Ly8gRE9NIDIgaGFzIG93bmVyRWxlbWVudFxyXG5cdGlmIChuLm93bmVyRWxlbWVudCkge1xyXG5cdFx0cmV0dXJuIG4ub3duZXJFbGVtZW50O1xyXG5cdH1cclxuXHQvLyBET00gMSBJbnRlcm5ldCBFeHBsb3JlciBjYW4gdXNlIHNlbGVjdFNpbmdsZU5vZGUgKGlyb25pY2FsbHkpXHJcblx0dHJ5IHtcclxuXHRcdGlmIChuLnNlbGVjdFNpbmdsZU5vZGUpIHtcclxuXHRcdFx0cmV0dXJuIG4uc2VsZWN0U2luZ2xlTm9kZShcIi4uXCIpO1xyXG5cdFx0fVxyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHR9XHJcblx0Ly8gT3RoZXIgRE9NIDEgaW1wbGVtZW50YXRpb25zIG11c3QgdXNlIHRoaXMgZWdyZWdpb3VzIHNlYXJjaFxyXG5cdHZhciBkb2MgPSBuLm5vZGVUeXBlID09IDkgLypOb2RlLkRPQ1VNRU5UX05PREUqL1xyXG5cdFx0XHQ/IG5cclxuXHRcdFx0OiBuLm93bmVyRG9jdW1lbnQ7XHJcblx0dmFyIGVsdHMgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZWx0cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGVsdCA9IGVsdHMuaXRlbShpKTtcclxuXHRcdHZhciBubm0gPSBlbHQuYXR0cmlidXRlcztcclxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgbm5tLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdHZhciBhbiA9IG5ubS5pdGVtKGopO1xyXG5cdFx0XHRpZiAoYW4gPT09IG4pIHtcclxuXHRcdFx0XHRyZXR1cm4gZWx0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuLy8gTG9jYXRpb25QYXRoIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5Mb2NhdGlvblBhdGgucHJvdG90eXBlID0gbmV3IE9iamVjdCgpO1xyXG5Mb2NhdGlvblBhdGgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9jYXRpb25QYXRoO1xyXG5Mb2NhdGlvblBhdGguc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBMb2NhdGlvblBhdGgoYWJzLCBzdGVwcykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGFicywgc3RlcHMpO1xyXG5cdH1cclxufVxyXG5cclxuTG9jYXRpb25QYXRoLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oYWJzLCBzdGVwcykge1xyXG5cdHRoaXMuYWJzb2x1dGUgPSBhYnM7XHJcblx0dGhpcy5zdGVwcyA9IHN0ZXBzO1xyXG59O1xyXG5cclxuTG9jYXRpb25QYXRoLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBzO1xyXG5cdGlmICh0aGlzLmFic29sdXRlKSB7XHJcblx0XHRzID0gXCIvXCI7XHJcblx0fSBlbHNlIHtcclxuXHRcdHMgPSBcIlwiO1xyXG5cdH1cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3RlcHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChpICE9IDApIHtcclxuXHRcdFx0cyArPSBcIi9cIjtcclxuXHRcdH1cclxuXHRcdHMgKz0gdGhpcy5zdGVwc1tpXS50b1N0cmluZygpO1xyXG5cdH1cclxuXHRyZXR1cm4gcztcclxufTtcclxuXHJcbi8vIFN0ZXAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuU3RlcC5wcm90b3R5cGUgPSBuZXcgT2JqZWN0KCk7XHJcblN0ZXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RlcDtcclxuU3RlcC5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFN0ZXAoYXhpcywgbm9kZXRlc3QsIHByZWRzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQoYXhpcywgbm9kZXRlc3QsIHByZWRzKTtcclxuXHR9XHJcbn1cclxuXHJcblN0ZXAucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihheGlzLCBub2RldGVzdCwgcHJlZHMpIHtcclxuXHR0aGlzLmF4aXMgPSBheGlzO1xyXG5cdHRoaXMubm9kZVRlc3QgPSBub2RldGVzdDtcclxuXHR0aGlzLnByZWRpY2F0ZXMgPSBwcmVkcztcclxufTtcclxuXHJcblN0ZXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIHM7XHJcblx0c3dpdGNoICh0aGlzLmF4aXMpIHtcclxuXHRcdGNhc2UgU3RlcC5BTkNFU1RPUjpcclxuXHRcdFx0cyA9IFwiYW5jZXN0b3JcIjtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIFN0ZXAuQU5DRVNUT1JPUlNFTEY6XHJcblx0XHRcdHMgPSBcImFuY2VzdG9yLW9yLXNlbGZcIjtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIFN0ZXAuQVRUUklCVVRFOlxyXG5cdFx0XHRzID0gXCJhdHRyaWJ1dGVcIjtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIFN0ZXAuQ0hJTEQ6XHJcblx0XHRcdHMgPSBcImNoaWxkXCI7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBTdGVwLkRFU0NFTkRBTlQ6XHJcblx0XHRcdHMgPSBcImRlc2NlbmRhbnRcIjtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIFN0ZXAuREVTQ0VOREFOVE9SU0VMRjpcclxuXHRcdFx0cyA9IFwiZGVzY2VuZGFudC1vci1zZWxmXCI7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBTdGVwLkZPTExPV0lORzpcclxuXHRcdFx0cyA9IFwiZm9sbG93aW5nXCI7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBTdGVwLkZPTExPV0lOR1NJQkxJTkc6XHJcblx0XHRcdHMgPSBcImZvbGxvd2luZy1zaWJsaW5nXCI7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBTdGVwLk5BTUVTUEFDRTpcclxuXHRcdFx0cyA9IFwibmFtZXNwYWNlXCI7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBTdGVwLlBBUkVOVDpcclxuXHRcdFx0cyA9IFwicGFyZW50XCI7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBTdGVwLlBSRUNFRElORzpcclxuXHRcdFx0cyA9IFwicHJlY2VkaW5nXCI7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBTdGVwLlBSRUNFRElOR1NJQkxJTkc6XHJcblx0XHRcdHMgPSBcInByZWNlZGluZy1zaWJsaW5nXCI7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBTdGVwLlNFTEY6XHJcblx0XHRcdHMgPSBcInNlbGZcIjtcclxuXHRcdFx0YnJlYWs7XHJcblx0fVxyXG5cdHMgKz0gXCI6OlwiO1xyXG5cdHMgKz0gdGhpcy5ub2RlVGVzdC50b1N0cmluZygpO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wcmVkaWNhdGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRzICs9IFwiW1wiICsgdGhpcy5wcmVkaWNhdGVzW2ldLnRvU3RyaW5nKCkgKyBcIl1cIjtcclxuXHR9XHJcblx0cmV0dXJuIHM7XHJcbn07XHJcblxyXG5TdGVwLkFOQ0VTVE9SID0gMDtcclxuU3RlcC5BTkNFU1RPUk9SU0VMRiA9IDE7XHJcblN0ZXAuQVRUUklCVVRFID0gMjtcclxuU3RlcC5DSElMRCA9IDM7XHJcblN0ZXAuREVTQ0VOREFOVCA9IDQ7XHJcblN0ZXAuREVTQ0VOREFOVE9SU0VMRiA9IDU7XHJcblN0ZXAuRk9MTE9XSU5HID0gNjtcclxuU3RlcC5GT0xMT1dJTkdTSUJMSU5HID0gNztcclxuU3RlcC5OQU1FU1BBQ0UgPSA4O1xyXG5TdGVwLlBBUkVOVCA9IDk7XHJcblN0ZXAuUFJFQ0VESU5HID0gMTA7XHJcblN0ZXAuUFJFQ0VESU5HU0lCTElORyA9IDExO1xyXG5TdGVwLlNFTEYgPSAxMjtcclxuXHJcbi8vIE5vZGVUZXN0IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuTm9kZVRlc3QucHJvdG90eXBlID0gbmV3IE9iamVjdCgpO1xyXG5Ob2RlVGVzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOb2RlVGVzdDtcclxuTm9kZVRlc3Quc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBOb2RlVGVzdCh0eXBlLCB2YWx1ZSkge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KHR5cGUsIHZhbHVlKTtcclxuXHR9XHJcbn1cclxuXHJcbk5vZGVUZXN0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24odHlwZSwgdmFsdWUpIHtcclxuXHR0aGlzLnR5cGUgPSB0eXBlO1xyXG5cdHRoaXMudmFsdWUgPSB2YWx1ZTtcclxufTtcclxuXHJcbk5vZGVUZXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHN3aXRjaCAodGhpcy50eXBlKSB7XHJcblx0XHRjYXNlIE5vZGVUZXN0Lk5BTUVURVNUQU5ZOlxyXG5cdFx0XHRyZXR1cm4gXCIqXCI7XHJcblx0XHRjYXNlIE5vZGVUZXN0Lk5BTUVURVNUUFJFRklYQU5ZOlxyXG5cdFx0XHRyZXR1cm4gdGhpcy52YWx1ZSArIFwiOipcIjtcclxuXHRcdGNhc2UgTm9kZVRlc3QuTkFNRVRFU1RSRVNPTFZFREFOWTpcclxuXHRcdFx0cmV0dXJuIFwie1wiICsgdGhpcy52YWx1ZSArIFwifSpcIjtcclxuXHRcdGNhc2UgTm9kZVRlc3QuTkFNRVRFU1RRTkFNRTpcclxuXHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XHJcblx0XHRjYXNlIE5vZGVUZXN0Lk5BTUVURVNUUkVTT0xWRUROQU1FOlxyXG5cdFx0XHRyZXR1cm4gXCJ7XCIgKyB0aGlzLm5hbWVzcGFjZVVSSSArIFwifVwiICsgdGhpcy52YWx1ZTtcclxuXHRcdGNhc2UgTm9kZVRlc3QuQ09NTUVOVDpcclxuXHRcdFx0cmV0dXJuIFwiY29tbWVudCgpXCI7XHJcblx0XHRjYXNlIE5vZGVUZXN0LlRFWFQ6XHJcblx0XHRcdHJldHVybiBcInRleHQoKVwiO1xyXG5cdFx0Y2FzZSBOb2RlVGVzdC5QSTpcclxuXHRcdFx0aWYgKHRoaXMudmFsdWUgIT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0cmV0dXJuIFwicHJvY2Vzc2luZy1pbnN0cnVjdGlvbihcXFwiXCIgKyB0aGlzLnZhbHVlICsgXCJcXFwiKVwiO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBcInByb2Nlc3NpbmctaW5zdHJ1Y3Rpb24oKVwiO1xyXG5cdFx0Y2FzZSBOb2RlVGVzdC5OT0RFOlxyXG5cdFx0XHRyZXR1cm4gXCJub2RlKClcIjtcclxuXHR9XHJcblx0cmV0dXJuIFwiPHVua25vd24gbm9kZXRlc3QgdHlwZT5cIjtcclxufTtcclxuXHJcbk5vZGVUZXN0LnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24obiwgeHBjKSB7XHJcblx0c3dpdGNoICh0aGlzLnR5cGUpIHtcclxuXHRcdGNhc2UgTm9kZVRlc3QuTkFNRVRFU1RBTlk6XHJcblx0XHRcdGlmIChuLm5vZGVUeXBlID09IDIgLypOb2RlLkFUVFJJQlVURV9OT0RFKi9cclxuXHRcdFx0XHRcdHx8IG4ubm9kZVR5cGUgPT0gMSAvKk5vZGUuRUxFTUVOVF9OT0RFKi9cclxuXHRcdFx0XHRcdHx8IG4ubm9kZVR5cGUgPT0gWFBhdGhOYW1lc3BhY2UuWFBBVEhfTkFNRVNQQUNFX05PREUpIHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRjYXNlIE5vZGVUZXN0Lk5BTUVURVNUUFJFRklYQU5ZOlxyXG5cdFx0XHRpZiAoKG4ubm9kZVR5cGUgPT0gMiAvKk5vZGUuQVRUUklCVVRFX05PREUqLyB8fCBuLm5vZGVUeXBlID09IDEgLypOb2RlLkVMRU1FTlRfTk9ERSovKSkge1xyXG5cdFx0XHRcdHZhciBucyA9IHhwYy5uYW1lc3BhY2VSZXNvbHZlci5nZXROYW1lc3BhY2UodGhpcy52YWx1ZSwgeHBjLmV4cHJlc3Npb25Db250ZXh0Tm9kZSk7XHJcblx0XHRcdFx0aWYgKG5zID09IG51bGwpIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIFFOYW1lIFwiICsgdGhpcy52YWx1ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBucyA9PSAobi5uYW1lc3BhY2VVUkkgfHwgJycpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdGNhc2UgTm9kZVRlc3QuTkFNRVRFU1RRTkFNRTpcclxuXHRcdFx0aWYgKG4ubm9kZVR5cGUgPT0gMiAvKk5vZGUuQVRUUklCVVRFX05PREUqL1xyXG5cdFx0XHRcdFx0fHwgbi5ub2RlVHlwZSA9PSAxIC8qTm9kZS5FTEVNRU5UX05PREUqL1xyXG5cdFx0XHRcdFx0fHwgbi5ub2RlVHlwZSA9PSBYUGF0aE5hbWVzcGFjZS5YUEFUSF9OQU1FU1BBQ0VfTk9ERSkge1xyXG5cdFx0XHRcdHZhciB0ZXN0ID0gVXRpbGl0aWVzLnJlc29sdmVRTmFtZSh0aGlzLnZhbHVlLCB4cGMubmFtZXNwYWNlUmVzb2x2ZXIsIHhwYy5leHByZXNzaW9uQ29udGV4dE5vZGUsIGZhbHNlKTtcclxuXHRcdFx0XHRpZiAodGVzdFswXSA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBRTmFtZSBcIiArIHRoaXMudmFsdWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0ZXN0WzBdID0gU3RyaW5nKHRlc3RbMF0pO1xyXG5cdFx0XHRcdHRlc3RbMV0gPSBTdHJpbmcodGVzdFsxXSk7XHJcblx0XHRcdFx0aWYgKHRlc3RbMF0gPT0gXCJcIikge1xyXG5cdFx0XHRcdFx0dGVzdFswXSA9IG51bGw7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhciBub2RlID0gW24ubmFtZXNwYWNlVVJJIHx8ICcnLCBuLmxvY2FsTmFtZV07XHJcblx0XHRcdFx0bm9kZVswXSA9IFN0cmluZyhub2RlWzBdKTtcclxuXHRcdFx0XHRub2RlWzFdID0gU3RyaW5nKG5vZGVbMV0pO1xyXG5cdFx0XHRcdGlmIChub2RlWzBdID09IFwiXCIpIHtcclxuXHRcdFx0XHRcdG5vZGVbMF0gPSBudWxsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoeHBjLmNhc2VJbnNlbnNpdGl2ZSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRlc3RbMF0gPT0gbm9kZVswXSAmJiBTdHJpbmcodGVzdFsxXSkudG9Mb3dlckNhc2UoKSA9PSBTdHJpbmcobm9kZVsxXSkudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHRlc3RbMF0gPT0gbm9kZVswXSAmJiB0ZXN0WzFdID09IG5vZGVbMV07XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0Y2FzZSBOb2RlVGVzdC5DT01NRU5UOlxyXG5cdFx0XHRyZXR1cm4gbi5ub2RlVHlwZSA9PSA4IC8qTm9kZS5DT01NRU5UX05PREUqLztcclxuXHRcdGNhc2UgTm9kZVRlc3QuVEVYVDpcclxuXHRcdFx0cmV0dXJuIG4ubm9kZVR5cGUgPT0gMyAvKk5vZGUuVEVYVF9OT0RFKi8gfHwgbi5ub2RlVHlwZSA9PSA0IC8qTm9kZS5DREFUQV9TRUNUSU9OX05PREUqLztcclxuXHRcdGNhc2UgTm9kZVRlc3QuUEk6XHJcblx0XHRcdHJldHVybiBuLm5vZGVUeXBlID09IDcgLypOb2RlLlBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERSovXHJcblx0XHRcdFx0JiYgKHRoaXMudmFsdWUgPT0gbnVsbCB8fCBuLm5vZGVOYW1lID09IHRoaXMudmFsdWUpO1xyXG5cdFx0Y2FzZSBOb2RlVGVzdC5OT0RFOlxyXG5cdFx0XHRyZXR1cm4gbi5ub2RlVHlwZSA9PSA5IC8qTm9kZS5ET0NVTUVOVF9OT0RFKi9cclxuXHRcdFx0XHR8fCBuLm5vZGVUeXBlID09IDEgLypOb2RlLkVMRU1FTlRfTk9ERSovXHJcblx0XHRcdFx0fHwgbi5ub2RlVHlwZSA9PSAyIC8qTm9kZS5BVFRSSUJVVEVfTk9ERSovXHJcblx0XHRcdFx0fHwgbi5ub2RlVHlwZSA9PSAzIC8qTm9kZS5URVhUX05PREUqL1xyXG5cdFx0XHRcdHx8IG4ubm9kZVR5cGUgPT0gNCAvKk5vZGUuQ0RBVEFfU0VDVElPTl9OT0RFKi9cclxuXHRcdFx0XHR8fCBuLm5vZGVUeXBlID09IDggLypOb2RlLkNPTU1FTlRfTk9ERSovXHJcblx0XHRcdFx0fHwgbi5ub2RlVHlwZSA9PSA3IC8qTm9kZS5QUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREUqLztcclxuXHR9XHJcblx0cmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuTm9kZVRlc3QuTkFNRVRFU1RBTlkgPSAwO1xyXG5Ob2RlVGVzdC5OQU1FVEVTVFBSRUZJWEFOWSA9IDE7XHJcbk5vZGVUZXN0Lk5BTUVURVNUUU5BTUUgPSAyO1xyXG5Ob2RlVGVzdC5DT01NRU5UID0gMztcclxuTm9kZVRlc3QuVEVYVCA9IDQ7XHJcbk5vZGVUZXN0LlBJID0gNTtcclxuTm9kZVRlc3QuTk9ERSA9IDY7XHJcblxyXG4vLyBWYXJpYWJsZVJlZmVyZW5jZSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblZhcmlhYmxlUmVmZXJlbmNlLnByb3RvdHlwZSA9IG5ldyBFeHByZXNzaW9uKCk7XHJcblZhcmlhYmxlUmVmZXJlbmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFZhcmlhYmxlUmVmZXJlbmNlO1xyXG5WYXJpYWJsZVJlZmVyZW5jZS5zdXBlcmNsYXNzID0gRXhwcmVzc2lvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBWYXJpYWJsZVJlZmVyZW5jZSh2KSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQodik7XHJcblx0fVxyXG59XHJcblxyXG5WYXJpYWJsZVJlZmVyZW5jZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHYpIHtcclxuXHR0aGlzLnZhcmlhYmxlID0gdjtcclxufTtcclxuXHJcblZhcmlhYmxlUmVmZXJlbmNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIiRcIiArIHRoaXMudmFyaWFibGU7XHJcbn07XHJcblxyXG5WYXJpYWJsZVJlZmVyZW5jZS5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIGMudmFyaWFibGVSZXNvbHZlci5nZXRWYXJpYWJsZSh0aGlzLnZhcmlhYmxlLCBjKTtcclxufTtcclxuXHJcbi8vIEZ1bmN0aW9uQ2FsbCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuRnVuY3Rpb25DYWxsLnByb3RvdHlwZSA9IG5ldyBFeHByZXNzaW9uKCk7XHJcbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGdW5jdGlvbkNhbGw7XHJcbkZ1bmN0aW9uQ2FsbC5zdXBlcmNsYXNzID0gRXhwcmVzc2lvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBGdW5jdGlvbkNhbGwoZm4sIGFyZ3MpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChmbiwgYXJncyk7XHJcblx0fVxyXG59XHJcblxyXG5GdW5jdGlvbkNhbGwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihmbiwgYXJncykge1xyXG5cdHRoaXMuZnVuY3Rpb25OYW1lID0gZm47XHJcblx0dGhpcy5hcmd1bWVudHMgPSBhcmdzO1xyXG59O1xyXG5cclxuRnVuY3Rpb25DYWxsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBzID0gdGhpcy5mdW5jdGlvbk5hbWUgKyBcIihcIjtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAoaSA+IDApIHtcclxuXHRcdFx0cyArPSBcIiwgXCI7XHJcblx0XHR9XHJcblx0XHRzICs9IHRoaXMuYXJndW1lbnRzW2ldLnRvU3RyaW5nKCk7XHJcblx0fVxyXG5cdHJldHVybiBzICsgXCIpXCI7XHJcbn07XHJcblxyXG5GdW5jdGlvbkNhbGwucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHZhciBmID0gYy5mdW5jdGlvblJlc29sdmVyLmdldEZ1bmN0aW9uKHRoaXMuZnVuY3Rpb25OYW1lLCBjKTtcclxuXHRpZiAoZiA9PSB1bmRlZmluZWQpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZnVuY3Rpb24gXCIgKyB0aGlzLmZ1bmN0aW9uTmFtZSk7XHJcblx0fVxyXG5cdHZhciBhID0gW2NdLmNvbmNhdCh0aGlzLmFyZ3VtZW50cyk7XHJcblx0cmV0dXJuIGYuYXBwbHkoYy5mdW5jdGlvblJlc29sdmVyLnRoaXNBcmcsIGEpO1xyXG59O1xyXG5cclxuLy8gWFN0cmluZyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZSA9IG5ldyBFeHByZXNzaW9uKCk7XHJcblhTdHJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWFN0cmluZztcclxuWFN0cmluZy5zdXBlcmNsYXNzID0gRXhwcmVzc2lvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBYU3RyaW5nKHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChzKTtcclxuXHR9XHJcbn1cclxuXHJcblhTdHJpbmcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihzKSB7XHJcblx0dGhpcy5zdHIgPSBzO1xyXG59O1xyXG5cclxuWFN0cmluZy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5zdHI7XHJcbn07XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblhTdHJpbmcucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuWFN0cmluZy5wcm90b3R5cGUubnVtYmVyID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBYTnVtYmVyKHRoaXMuc3RyKTtcclxufTtcclxuXHJcblhTdHJpbmcucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHRoaXMuc3RyKTtcclxufTtcclxuXHJcblhTdHJpbmcucHJvdG90eXBlLm5vZGVzZXQgPSBmdW5jdGlvbigpIHtcclxuXHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBzdHJpbmcgdG8gbm9kZXNldFwiKTtcclxufTtcclxuXHJcblhTdHJpbmcucHJvdG90eXBlLnN0cmluZ1ZhbHVlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuc3RyO1xyXG59O1xyXG5cclxuWFN0cmluZy5wcm90b3R5cGUubnVtYmVyVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5udW1iZXIoKS5udW1iZXJWYWx1ZSgpO1xyXG59O1xyXG5cclxuWFN0cmluZy5wcm90b3R5cGUuYm9vbGVhblZhbHVlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuYm9vbCgpLmJvb2xlYW5WYWx1ZSgpO1xyXG59O1xyXG5cclxuWFN0cmluZy5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWEJvb2xlYW4pKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5ib29sKCkuZXF1YWxzKHIpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOdW1iZXIpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5udW1iZXIoKS5lcXVhbHMocik7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aFN0cmluZyh0aGlzLCBPcGVyYXRvcnMuZXF1YWxzKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbih0aGlzLnN0ciA9PSByLnN0cik7XHJcbn07XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5ub3RlcXVhbCA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhCb29sZWFuKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuYm9vbCgpLm5vdGVxdWFsKHIpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOdW1iZXIpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5udW1iZXIoKS5ub3RlcXVhbChyKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTm9kZVNldCkpIHtcclxuXHRcdHJldHVybiByLmNvbXBhcmVXaXRoU3RyaW5nKHRoaXMsIE9wZXJhdG9ycy5ub3RlcXVhbCk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4odGhpcy5zdHIgIT0gci5zdHIpO1xyXG59O1xyXG5cclxuWFN0cmluZy5wcm90b3R5cGUubGVzc3RoYW4gPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTm9kZVNldCkpIHtcclxuXHRcdHJldHVybiByLmNvbXBhcmVXaXRoTnVtYmVyKHRoaXMubnVtYmVyKCksIE9wZXJhdG9ycy5ncmVhdGVydGhhbm9yZXF1YWwpO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5udW1iZXIoKS5sZXNzdGhhbihyLm51bWJlcigpKTtcclxufTtcclxuXHJcblhTdHJpbmcucHJvdG90eXBlLmdyZWF0ZXJ0aGFuID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aE51bWJlcih0aGlzLm51bWJlcigpLCBPcGVyYXRvcnMubGVzc3RoYW5vcmVxdWFsKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMubnVtYmVyKCkuZ3JlYXRlcnRoYW4oci5udW1iZXIoKSk7XHJcbn07XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5sZXNzdGhhbm9yZXF1YWwgPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTm9kZVNldCkpIHtcclxuXHRcdHJldHVybiByLmNvbXBhcmVXaXRoTnVtYmVyKHRoaXMubnVtYmVyKCksIE9wZXJhdG9ycy5ncmVhdGVydGhhbik7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLm51bWJlcigpLmxlc3N0aGFub3JlcXVhbChyLm51bWJlcigpKTtcclxufTtcclxuXHJcblhTdHJpbmcucHJvdG90eXBlLmdyZWF0ZXJ0aGFub3JlcXVhbCA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhOdW1iZXIodGhpcy5udW1iZXIoKSwgT3BlcmF0b3JzLmxlc3N0aGFuKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMubnVtYmVyKCkuZ3JlYXRlcnRoYW5vcmVxdWFsKHIubnVtYmVyKCkpO1xyXG59O1xyXG5cclxuLy8gWE51bWJlciAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZSA9IG5ldyBFeHByZXNzaW9uKCk7XHJcblhOdW1iZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWE51bWJlcjtcclxuWE51bWJlci5zdXBlcmNsYXNzID0gRXhwcmVzc2lvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBYTnVtYmVyKG4pIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChuKTtcclxuXHR9XHJcbn1cclxuXHJcblhOdW1iZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihuKSB7XHJcblx0dGhpcy5udW0gPSBOdW1iZXIobik7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLm51bTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBYU3RyaW5nKHRoaXMubnVtKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLm51bWJlciA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4odGhpcy5udW0pO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUubm9kZXNldCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG51bWJlciB0byBub2Rlc2V0XCIpO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUuc3RyaW5nVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5zdHJpbmcoKS5zdHJpbmdWYWx1ZSgpO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUubnVtYmVyVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5udW07XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5ib29sZWFuVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5ib29sKCkuYm9vbGVhblZhbHVlKCk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIoLXRoaXMubnVtKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhCb29sZWFuKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuYm9vbCgpLmVxdWFscyhyKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYU3RyaW5nKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZXF1YWxzKHIubnVtYmVyKCkpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhOdW1iZXIodGhpcywgT3BlcmF0b3JzLmVxdWFscyk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4odGhpcy5udW0gPT0gci5udW0pO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUubm90ZXF1YWwgPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYQm9vbGVhbikpIHtcclxuXHRcdHJldHVybiB0aGlzLmJvb2woKS5ub3RlcXVhbChyKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYU3RyaW5nKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMubm90ZXF1YWwoci5udW1iZXIoKSk7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aE51bWJlcih0aGlzLCBPcGVyYXRvcnMubm90ZXF1YWwpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHRoaXMubnVtICE9IHIubnVtKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLmxlc3N0aGFuID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aE51bWJlcih0aGlzLCBPcGVyYXRvcnMuZ3JlYXRlcnRoYW5vcmVxdWFsKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYQm9vbGVhbikgfHwgVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhTdHJpbmcpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sZXNzdGhhbihyLm51bWJlcigpKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbih0aGlzLm51bSA8IHIubnVtKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLmdyZWF0ZXJ0aGFuID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aE51bWJlcih0aGlzLCBPcGVyYXRvcnMubGVzc3RoYW5vcmVxdWFsKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYQm9vbGVhbikgfHwgVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhTdHJpbmcpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5ncmVhdGVydGhhbihyLm51bWJlcigpKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbih0aGlzLm51bSA+IHIubnVtKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLmxlc3N0aGFub3JlcXVhbCA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhOdW1iZXIodGhpcywgT3BlcmF0b3JzLmdyZWF0ZXJ0aGFuKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYQm9vbGVhbikgfHwgVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhTdHJpbmcpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sZXNzdGhhbm9yZXF1YWwoci5udW1iZXIoKSk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4odGhpcy5udW0gPD0gci5udW0pO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUuZ3JlYXRlcnRoYW5vcmVxdWFsID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aE51bWJlcih0aGlzLCBPcGVyYXRvcnMubGVzc3RoYW4pO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhCb29sZWFuKSB8fCBVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWFN0cmluZykpIHtcclxuXHRcdHJldHVybiB0aGlzLmdyZWF0ZXJ0aGFub3JlcXVhbChyLm51bWJlcigpKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbih0aGlzLm51bSA+PSByLm51bSk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5wbHVzID0gZnVuY3Rpb24ocikge1xyXG5cdHJldHVybiBuZXcgWE51bWJlcih0aGlzLm51bSArIHIubnVtKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLm1pbnVzID0gZnVuY3Rpb24ocikge1xyXG5cdHJldHVybiBuZXcgWE51bWJlcih0aGlzLm51bSAtIHIubnVtKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24ocikge1xyXG5cdHJldHVybiBuZXcgWE51bWJlcih0aGlzLm51bSAqIHIubnVtKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uKHIpIHtcclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIodGhpcy5udW0gLyByLm51bSk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbihyKSB7XHJcblx0cmV0dXJuIG5ldyBYTnVtYmVyKHRoaXMubnVtICUgci5udW0pO1xyXG59O1xyXG5cclxuLy8gWEJvb2xlYW4gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUgPSBuZXcgRXhwcmVzc2lvbigpO1xyXG5YQm9vbGVhbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBYQm9vbGVhbjtcclxuWEJvb2xlYW4uc3VwZXJjbGFzcyA9IEV4cHJlc3Npb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gWEJvb2xlYW4oYikge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGIpO1xyXG5cdH1cclxufVxyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihiKSB7XHJcblx0dGhpcy5iID0gQm9vbGVhbihiKTtcclxufTtcclxuXHJcblhCb29sZWFuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmIudG9TdHJpbmcoKTtcclxufTtcclxuXHJcblhCb29sZWFuLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblhCb29sZWFuLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFhTdHJpbmcodGhpcy5iKTtcclxufTtcclxuXHJcblhCb29sZWFuLnByb3RvdHlwZS5udW1iZXIgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIodGhpcy5iKTtcclxufTtcclxuXHJcblhCb29sZWFuLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUubm9kZXNldCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IGJvb2xlYW4gdG8gbm9kZXNldFwiKTtcclxufTtcclxuXHJcblhCb29sZWFuLnByb3RvdHlwZS5zdHJpbmdWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLnN0cmluZygpLnN0cmluZ1ZhbHVlKCk7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUubnVtYmVyVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5udW0oKS5udW1iZXJWYWx1ZSgpO1xyXG59O1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLmJvb2xlYW5WYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmI7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUubm90ID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbighdGhpcy5iKTtcclxufTtcclxuXHJcblhCb29sZWFuLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYU3RyaW5nKSB8fCBVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE51bWJlcikpIHtcclxuXHRcdHJldHVybiB0aGlzLmVxdWFscyhyLmJvb2woKSk7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aEJvb2xlYW4odGhpcywgT3BlcmF0b3JzLmVxdWFscyk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4odGhpcy5iID09IHIuYik7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUubm90ZXF1YWwgPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYU3RyaW5nKSB8fCBVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE51bWJlcikpIHtcclxuXHRcdHJldHVybiB0aGlzLm5vdGVxdWFsKHIuYm9vbCgpKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTm9kZVNldCkpIHtcclxuXHRcdHJldHVybiByLmNvbXBhcmVXaXRoQm9vbGVhbih0aGlzLCBPcGVyYXRvcnMubm90ZXF1YWwpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHRoaXMuYiAhPSByLmIpO1xyXG59O1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLmxlc3N0aGFuID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aE51bWJlcih0aGlzLm51bWJlcigpLCBPcGVyYXRvcnMuZ3JlYXRlcnRoYW5vcmVxdWFsKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMubnVtYmVyKCkubGVzc3RoYW4oci5udW1iZXIoKSk7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUuZ3JlYXRlcnRoYW4gPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTm9kZVNldCkpIHtcclxuXHRcdHJldHVybiByLmNvbXBhcmVXaXRoTnVtYmVyKHRoaXMubnVtYmVyKCksIE9wZXJhdG9ycy5sZXNzdGhhbm9yZXF1YWwpO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5udW1iZXIoKS5ncmVhdGVydGhhbihyLm51bWJlcigpKTtcclxufTtcclxuXHJcblhCb29sZWFuLnByb3RvdHlwZS5sZXNzdGhhbm9yZXF1YWwgPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTm9kZVNldCkpIHtcclxuXHRcdHJldHVybiByLmNvbXBhcmVXaXRoTnVtYmVyKHRoaXMubnVtYmVyKCksIE9wZXJhdG9ycy5ncmVhdGVydGhhbik7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLm51bWJlcigpLmxlc3N0aGFub3JlcXVhbChyLm51bWJlcigpKTtcclxufTtcclxuXHJcblhCb29sZWFuLnByb3RvdHlwZS5ncmVhdGVydGhhbm9yZXF1YWwgPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTm9kZVNldCkpIHtcclxuXHRcdHJldHVybiByLmNvbXBhcmVXaXRoTnVtYmVyKHRoaXMubnVtYmVyKCksIE9wZXJhdG9ycy5sZXNzdGhhbik7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLm51bWJlcigpLmdyZWF0ZXJ0aGFub3JlcXVhbChyLm51bWJlcigpKTtcclxufTtcclxuXHJcbi8vIEFWTFRyZWUgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuQVZMVHJlZS5wcm90b3R5cGUgPSBuZXcgT2JqZWN0KCk7XHJcbkFWTFRyZWUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQVZMVHJlZTtcclxuQVZMVHJlZS5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIEFWTFRyZWUobikge1xyXG5cdHRoaXMuaW5pdChuKTtcclxufVxyXG5cclxuQVZMVHJlZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKG4pIHtcclxuXHR0aGlzLmxlZnQgPSBudWxsO1xyXG4gICAgdGhpcy5yaWdodCA9IG51bGw7XHJcblx0dGhpcy5ub2RlID0gbjtcclxuXHR0aGlzLmRlcHRoID0gMTtcclxufTtcclxuXHJcbkFWTFRyZWUucHJvdG90eXBlLmJhbGFuY2UgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBsZGVwdGggPSB0aGlzLmxlZnQgID09IG51bGwgPyAwIDogdGhpcy5sZWZ0LmRlcHRoO1xyXG4gICAgdmFyIHJkZXB0aCA9IHRoaXMucmlnaHQgPT0gbnVsbCA/IDAgOiB0aGlzLnJpZ2h0LmRlcHRoO1xyXG5cclxuXHRpZiAobGRlcHRoID4gcmRlcHRoICsgMSkge1xyXG4gICAgICAgIC8vIExSIG9yIExMIHJvdGF0aW9uXHJcbiAgICAgICAgdmFyIGxsZGVwdGggPSB0aGlzLmxlZnQubGVmdCAgPT0gbnVsbCA/IDAgOiB0aGlzLmxlZnQubGVmdC5kZXB0aDtcclxuICAgICAgICB2YXIgbHJkZXB0aCA9IHRoaXMubGVmdC5yaWdodCA9PSBudWxsID8gMCA6IHRoaXMubGVmdC5yaWdodC5kZXB0aDtcclxuXHJcbiAgICAgICAgaWYgKGxsZGVwdGggPCBscmRlcHRoKSB7XHJcbiAgICAgICAgICAgIC8vIExSIHJvdGF0aW9uIGNvbnNpc3RzIG9mIGEgUlIgcm90YXRpb24gb2YgdGhlIGxlZnQgY2hpbGRcclxuICAgICAgICAgICAgdGhpcy5sZWZ0LnJvdGF0ZVJSKCk7XHJcbiAgICAgICAgICAgIC8vIHBsdXMgYSBMTCByb3RhdGlvbiBvZiB0aGlzIG5vZGUsIHdoaWNoIGhhcHBlbnMgYW55d2F5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucm90YXRlTEwoKTtcclxuICAgIH0gZWxzZSBpZiAobGRlcHRoICsgMSA8IHJkZXB0aCkge1xyXG4gICAgICAgIC8vIFJSIG9yIFJMIHJvcmFyaW9uXHJcblx0XHR2YXIgcnJkZXB0aCA9IHRoaXMucmlnaHQucmlnaHQgPT0gbnVsbCA/IDAgOiB0aGlzLnJpZ2h0LnJpZ2h0LmRlcHRoO1xyXG5cdFx0dmFyIHJsZGVwdGggPSB0aGlzLnJpZ2h0LmxlZnQgID09IG51bGwgPyAwIDogdGhpcy5yaWdodC5sZWZ0LmRlcHRoO1xyXG5cclxuICAgICAgICBpZiAocmxkZXB0aCA+IHJyZGVwdGgpIHtcclxuICAgICAgICAgICAgLy8gUlIgcm90YXRpb24gY29uc2lzdHMgb2YgYSBMTCByb3RhdGlvbiBvZiB0aGUgcmlnaHQgY2hpbGRcclxuICAgICAgICAgICAgdGhpcy5yaWdodC5yb3RhdGVMTCgpO1xyXG4gICAgICAgICAgICAvLyBwbHVzIGEgUlIgcm90YXRpb24gb2YgdGhpcyBub2RlLCB3aGljaCBoYXBwZW5zIGFueXdheVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJvdGF0ZVJSKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5BVkxUcmVlLnByb3RvdHlwZS5yb3RhdGVMTCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gdGhlIGxlZnQgc2lkZSBpcyB0b28gbG9uZyA9PiByb3RhdGUgZnJvbSB0aGUgbGVmdCAoX25vdF8gbGVmdHdhcmRzKVxyXG4gICAgdmFyIG5vZGVCZWZvcmUgPSB0aGlzLm5vZGU7XHJcbiAgICB2YXIgcmlnaHRCZWZvcmUgPSB0aGlzLnJpZ2h0O1xyXG4gICAgdGhpcy5ub2RlID0gdGhpcy5sZWZ0Lm5vZGU7XHJcbiAgICB0aGlzLnJpZ2h0ID0gdGhpcy5sZWZ0O1xyXG4gICAgdGhpcy5sZWZ0ID0gdGhpcy5sZWZ0LmxlZnQ7XHJcbiAgICB0aGlzLnJpZ2h0LmxlZnQgPSB0aGlzLnJpZ2h0LnJpZ2h0O1xyXG4gICAgdGhpcy5yaWdodC5yaWdodCA9IHJpZ2h0QmVmb3JlO1xyXG4gICAgdGhpcy5yaWdodC5ub2RlID0gbm9kZUJlZm9yZTtcclxuICAgIHRoaXMucmlnaHQudXBkYXRlSW5OZXdMb2NhdGlvbigpO1xyXG4gICAgdGhpcy51cGRhdGVJbk5ld0xvY2F0aW9uKCk7XHJcbn07XHJcblxyXG5BVkxUcmVlLnByb3RvdHlwZS5yb3RhdGVSUiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gdGhlIHJpZ2h0IHNpZGUgaXMgdG9vIGxvbmcgPT4gcm90YXRlIGZyb20gdGhlIHJpZ2h0IChfbm90XyByaWdodHdhcmRzKVxyXG4gICAgdmFyIG5vZGVCZWZvcmUgPSB0aGlzLm5vZGU7XHJcbiAgICB2YXIgbGVmdEJlZm9yZSA9IHRoaXMubGVmdDtcclxuICAgIHRoaXMubm9kZSA9IHRoaXMucmlnaHQubm9kZTtcclxuICAgIHRoaXMubGVmdCA9IHRoaXMucmlnaHQ7XHJcbiAgICB0aGlzLnJpZ2h0ID0gdGhpcy5yaWdodC5yaWdodDtcclxuICAgIHRoaXMubGVmdC5yaWdodCA9IHRoaXMubGVmdC5sZWZ0O1xyXG4gICAgdGhpcy5sZWZ0LmxlZnQgPSBsZWZ0QmVmb3JlO1xyXG4gICAgdGhpcy5sZWZ0Lm5vZGUgPSBub2RlQmVmb3JlO1xyXG4gICAgdGhpcy5sZWZ0LnVwZGF0ZUluTmV3TG9jYXRpb24oKTtcclxuICAgIHRoaXMudXBkYXRlSW5OZXdMb2NhdGlvbigpO1xyXG59O1xyXG5cclxuQVZMVHJlZS5wcm90b3R5cGUudXBkYXRlSW5OZXdMb2NhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5nZXREZXB0aEZyb21DaGlsZHJlbigpO1xyXG59O1xyXG5cclxuQVZMVHJlZS5wcm90b3R5cGUuZ2V0RGVwdGhGcm9tQ2hpbGRyZW4gPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuZGVwdGggPSB0aGlzLm5vZGUgPT0gbnVsbCA/IDAgOiAxO1xyXG4gICAgaWYgKHRoaXMubGVmdCAhPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5kZXB0aCA9IHRoaXMubGVmdC5kZXB0aCArIDE7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5yaWdodCAhPSBudWxsICYmIHRoaXMuZGVwdGggPD0gdGhpcy5yaWdodC5kZXB0aCkge1xyXG4gICAgICAgIHRoaXMuZGVwdGggPSB0aGlzLnJpZ2h0LmRlcHRoICsgMTtcclxuICAgIH1cclxufTtcclxuXHJcbkFWTFRyZWUucHJvdG90eXBlLm9yZGVyID0gZnVuY3Rpb24objEsIG4yKSB7XHJcblx0aWYgKG4xID09PSBuMikge1xyXG5cdFx0cmV0dXJuIDA7XHJcblx0fVxyXG5cdHZhciBkMSA9IDA7XHJcblx0dmFyIGQyID0gMDtcclxuXHRmb3IgKHZhciBtMSA9IG4xOyBtMSAhPSBudWxsOyBtMSA9IG0xLnBhcmVudE5vZGUpIHtcclxuXHRcdGQxKys7XHJcblx0fVxyXG5cdGZvciAodmFyIG0yID0gbjI7IG0yICE9IG51bGw7IG0yID0gbTIucGFyZW50Tm9kZSkge1xyXG5cdFx0ZDIrKztcclxuXHR9XHJcblx0aWYgKGQxID4gZDIpIHtcclxuXHRcdHdoaWxlIChkMSA+IGQyKSB7XHJcblx0XHRcdG4xID0gbjEucGFyZW50Tm9kZTtcclxuXHRcdFx0ZDEtLTtcclxuXHRcdH1cclxuXHRcdGlmIChuMSA9PSBuMikge1xyXG5cdFx0XHRyZXR1cm4gMTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYgKGQyID4gZDEpIHtcclxuXHRcdHdoaWxlIChkMiA+IGQxKSB7XHJcblx0XHRcdG4yID0gbjIucGFyZW50Tm9kZTtcclxuXHRcdFx0ZDItLTtcclxuXHRcdH1cclxuXHRcdGlmIChuMSA9PSBuMikge1xyXG5cdFx0XHRyZXR1cm4gLTE7XHJcblx0XHR9XHJcblx0fVxyXG5cdHdoaWxlIChuMS5wYXJlbnROb2RlICE9IG4yLnBhcmVudE5vZGUpIHtcclxuXHRcdG4xID0gbjEucGFyZW50Tm9kZTtcclxuXHRcdG4yID0gbjIucGFyZW50Tm9kZTtcclxuXHR9XHJcblx0d2hpbGUgKG4xLnByZXZpb3VzU2libGluZyAhPSBudWxsICYmIG4yLnByZXZpb3VzU2libGluZyAhPSBudWxsKSB7XHJcblx0XHRuMSA9IG4xLnByZXZpb3VzU2libGluZztcclxuXHRcdG4yID0gbjIucHJldmlvdXNTaWJsaW5nO1xyXG5cdH1cclxuXHRpZiAobjEucHJldmlvdXNTaWJsaW5nID09IG51bGwpIHtcclxuXHRcdHJldHVybiAtMTtcclxuXHR9XHJcblx0cmV0dXJuIDE7XHJcbn07XHJcblxyXG5BVkxUcmVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihuKSAge1xyXG5cdGlmIChuID09PSB0aGlzLm5vZGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG5cdHZhciBvID0gdGhpcy5vcmRlcihuLCB0aGlzLm5vZGUpO1xyXG5cclxuICAgIHZhciByZXQgPSBmYWxzZTtcclxuICAgIGlmIChvID09IC0xKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IG5ldyBBVkxUcmVlKG4pO1xyXG4gICAgICAgICAgICByZXQgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldCA9IHRoaXMubGVmdC5hZGQobik7XHJcbiAgICAgICAgICAgIGlmIChyZXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmFsYW5jZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChvID09IDEpIHtcclxuICAgICAgICBpZiAodGhpcy5yaWdodCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPSBuZXcgQVZMVHJlZShuKTtcclxuICAgICAgICAgICAgcmV0ID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXQgPSB0aGlzLnJpZ2h0LmFkZChuKTtcclxuICAgICAgICAgICAgaWYgKHJldCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iYWxhbmNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJldCkge1xyXG4gICAgICAgIHRoaXMuZ2V0RGVwdGhGcm9tQ2hpbGRyZW4oKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn07XHJcblxyXG4vLyBYTm9kZVNldCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZSA9IG5ldyBFeHByZXNzaW9uKCk7XHJcblhOb2RlU2V0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhOb2RlU2V0O1xyXG5YTm9kZVNldC5zdXBlcmNsYXNzID0gRXhwcmVzc2lvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBYTm9kZVNldCgpIHtcclxuXHR0aGlzLmluaXQoKTtcclxufVxyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLnRyZWUgPSBudWxsO1xyXG5cdHRoaXMuc2l6ZSA9IDA7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgcCA9IHRoaXMuZmlyc3QoKTtcclxuXHRpZiAocCA9PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gXCJcIjtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMuc3RyaW5nRm9yTm9kZShwKTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFhTdHJpbmcodGhpcy50b1N0cmluZygpKTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5zdHJpbmdWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUubnVtYmVyID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBYTnVtYmVyKHRoaXMuc3RyaW5nKCkpO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLm51bWJlclZhbHVlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIE51bWJlcih0aGlzLnN0cmluZygpKTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbih0aGlzLnRyZWUgIT0gbnVsbCk7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuYm9vbGVhblZhbHVlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMudHJlZSAhPSBudWxsO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLm5vZGVzZXQgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5zdHJpbmdGb3JOb2RlID0gZnVuY3Rpb24obikge1xyXG5cdGlmIChuLm5vZGVUeXBlID09IDkgLypOb2RlLkRPQ1VNRU5UX05PREUqLykge1xyXG5cdFx0biA9IG4uZG9jdW1lbnRFbGVtZW50O1xyXG5cdH1cclxuXHRpZiAobi5ub2RlVHlwZSA9PSAxIC8qTm9kZS5FTEVNRU5UX05PREUqLykge1xyXG5cdFx0cmV0dXJuIHRoaXMuc3RyaW5nRm9yTm9kZVJlYyhuKTtcclxuXHR9XHJcblx0aWYgKG4uaXNOYW1lc3BhY2VOb2RlKSB7XHJcblx0XHRyZXR1cm4gbi5uYW1lc3BhY2U7XHJcblx0fVxyXG5cdHJldHVybiBuLm5vZGVWYWx1ZTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5zdHJpbmdGb3JOb2RlUmVjID0gZnVuY3Rpb24obikge1xyXG5cdHZhciBzID0gXCJcIjtcclxuXHRmb3IgKHZhciBuMiA9IG4uZmlyc3RDaGlsZDsgbjIgIT0gbnVsbDsgbjIgPSBuMi5uZXh0U2libGluZykge1xyXG5cdFx0aWYgKG4yLm5vZGVUeXBlID09IDMgLypOb2RlLlRFWFRfTk9ERSovKSB7XHJcblx0XHRcdHMgKz0gbjIubm9kZVZhbHVlO1xyXG5cdFx0fSBlbHNlIGlmIChuMi5ub2RlVHlwZSA9PSAxIC8qTm9kZS5FTEVNRU5UX05PREUqLykge1xyXG5cdFx0XHRzICs9IHRoaXMuc3RyaW5nRm9yTm9kZVJlYyhuMik7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBzO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIHAgPSB0aGlzLnRyZWU7XHJcblx0aWYgKHAgPT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdHdoaWxlIChwLmxlZnQgIT0gbnVsbCkge1xyXG5cdFx0cCA9IHAubGVmdDtcclxuXHR9XHJcblx0cmV0dXJuIHAubm9kZTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihuKSB7XHJcbiAgICB2YXIgYWRkZWQ7XHJcbiAgICBpZiAodGhpcy50cmVlID09IG51bGwpIHtcclxuICAgICAgICB0aGlzLnRyZWUgPSBuZXcgQVZMVHJlZShuKTtcclxuICAgICAgICBhZGRlZCA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFkZGVkID0gdGhpcy50cmVlLmFkZChuKTtcclxuICAgIH1cclxuICAgIGlmIChhZGRlZCkge1xyXG4gICAgICAgIHRoaXMuc2l6ZSsrO1xyXG4gICAgfVxyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLmFkZEFycmF5ID0gZnVuY3Rpb24obnMpIHtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR0aGlzLmFkZChuc1tpXSk7XHJcblx0fVxyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYSA9IFtdO1xyXG5cdHRoaXMudG9BcnJheVJlYyh0aGlzLnRyZWUsIGEpO1xyXG5cdHJldHVybiBhO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLnRvQXJyYXlSZWMgPSBmdW5jdGlvbih0LCBhKSB7XHJcblx0aWYgKHQgIT0gbnVsbCkge1xyXG5cdFx0dGhpcy50b0FycmF5UmVjKHQubGVmdCwgYSk7XHJcblx0XHRhLnB1c2godC5ub2RlKTtcclxuXHRcdHRoaXMudG9BcnJheVJlYyh0LnJpZ2h0LCBhKTtcclxuXHR9XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuY29tcGFyZVdpdGhTdHJpbmcgPSBmdW5jdGlvbihyLCBvKSB7XHJcblx0dmFyIGEgPSB0aGlzLnRvQXJyYXkoKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBuID0gYVtpXTtcclxuXHRcdHZhciBsID0gbmV3IFhTdHJpbmcodGhpcy5zdHJpbmdGb3JOb2RlKG4pKTtcclxuXHRcdHZhciByZXMgPSBvKGwsIHIpO1xyXG5cdFx0aWYgKHJlcy5ib29sZWFuVmFsdWUoKSkge1xyXG5cdFx0XHRyZXR1cm4gcmVzO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKGZhbHNlKTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5jb21wYXJlV2l0aE51bWJlciA9IGZ1bmN0aW9uKHIsIG8pIHtcclxuXHR2YXIgYSA9IHRoaXMudG9BcnJheSgpO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIG4gPSBhW2ldO1xyXG5cdFx0dmFyIGwgPSBuZXcgWE51bWJlcih0aGlzLnN0cmluZ0Zvck5vZGUobikpO1xyXG5cdFx0dmFyIHJlcyA9IG8obCwgcik7XHJcblx0XHRpZiAocmVzLmJvb2xlYW5WYWx1ZSgpKSB7XHJcblx0XHRcdHJldHVybiByZXM7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4oZmFsc2UpO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLmNvbXBhcmVXaXRoQm9vbGVhbiA9IGZ1bmN0aW9uKHIsIG8pIHtcclxuXHRyZXR1cm4gbyh0aGlzLmJvb2woKSwgcik7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuY29tcGFyZVdpdGhOb2RlU2V0ID0gZnVuY3Rpb24ociwgbykge1xyXG5cdHZhciBhID0gdGhpcy50b0FycmF5KCk7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgbiA9IGFbaV07XHJcblx0XHR2YXIgbCA9IG5ldyBYU3RyaW5nKHRoaXMuc3RyaW5nRm9yTm9kZShuKSk7XHJcblx0XHR2YXIgYiA9IHIudG9BcnJheSgpO1xyXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBiLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdHZhciBuMiA9IGJbal07XHJcblx0XHRcdHZhciByID0gbmV3IFhTdHJpbmcodGhpcy5zdHJpbmdGb3JOb2RlKG4yKSk7XHJcblx0XHRcdHZhciByZXMgPSBvKGwsIHIpO1xyXG5cdFx0XHRpZiAocmVzLmJvb2xlYW5WYWx1ZSgpKSB7XHJcblx0XHRcdFx0cmV0dXJuIHJlcztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKGZhbHNlKTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYU3RyaW5nKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhTdHJpbmcociwgT3BlcmF0b3JzLmVxdWFscyk7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE51bWJlcikpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoTnVtYmVyKHIsIE9wZXJhdG9ycy5lcXVhbHMpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhCb29sZWFuKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhCb29sZWFuKHIsIE9wZXJhdG9ycy5lcXVhbHMpO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE5vZGVTZXQociwgT3BlcmF0b3JzLmVxdWFscyk7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUubm90ZXF1YWwgPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYU3RyaW5nKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhTdHJpbmcociwgT3BlcmF0b3JzLm5vdGVxdWFsKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTnVtYmVyKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOdW1iZXIociwgT3BlcmF0b3JzLm5vdGVxdWFsKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYQm9vbGVhbikpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoQm9vbGVhbihyLCBPcGVyYXRvcnMubm90ZXF1YWwpO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE5vZGVTZXQociwgT3BlcmF0b3JzLm5vdGVxdWFsKTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5sZXNzdGhhbiA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhTdHJpbmcpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE51bWJlcihyLm51bWJlcigpLCBPcGVyYXRvcnMubGVzc3RoYW4pO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOdW1iZXIpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE51bWJlcihyLCBPcGVyYXRvcnMubGVzc3RoYW4pO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhCb29sZWFuKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhCb29sZWFuKHIsIE9wZXJhdG9ycy5sZXNzdGhhbik7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoTm9kZVNldChyLCBPcGVyYXRvcnMubGVzc3RoYW4pO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLmdyZWF0ZXJ0aGFuID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWFN0cmluZykpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoTnVtYmVyKHIubnVtYmVyKCksIE9wZXJhdG9ycy5ncmVhdGVydGhhbik7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE51bWJlcikpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoTnVtYmVyKHIsIE9wZXJhdG9ycy5ncmVhdGVydGhhbik7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWEJvb2xlYW4pKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aEJvb2xlYW4ociwgT3BlcmF0b3JzLmdyZWF0ZXJ0aGFuKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOb2RlU2V0KHIsIE9wZXJhdG9ycy5ncmVhdGVydGhhbik7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUubGVzc3RoYW5vcmVxdWFsID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWFN0cmluZykpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoTnVtYmVyKHIubnVtYmVyKCksIE9wZXJhdG9ycy5sZXNzdGhhbm9yZXF1YWwpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOdW1iZXIpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE51bWJlcihyLCBPcGVyYXRvcnMubGVzc3RoYW5vcmVxdWFsKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYQm9vbGVhbikpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoQm9vbGVhbihyLCBPcGVyYXRvcnMubGVzc3RoYW5vcmVxdWFsKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOb2RlU2V0KHIsIE9wZXJhdG9ycy5sZXNzdGhhbm9yZXF1YWwpO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLmdyZWF0ZXJ0aGFub3JlcXVhbCA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhTdHJpbmcpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE51bWJlcihyLm51bWJlcigpLCBPcGVyYXRvcnMuZ3JlYXRlcnRoYW5vcmVxdWFsKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTnVtYmVyKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOdW1iZXIociwgT3BlcmF0b3JzLmdyZWF0ZXJ0aGFub3JlcXVhbCk7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWEJvb2xlYW4pKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aEJvb2xlYW4ociwgT3BlcmF0b3JzLmdyZWF0ZXJ0aGFub3JlcXVhbCk7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoTm9kZVNldChyLCBPcGVyYXRvcnMuZ3JlYXRlcnRoYW5vcmVxdWFsKTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS51bmlvbiA9IGZ1bmN0aW9uKHIpIHtcclxuXHR2YXIgbnMgPSBuZXcgWE5vZGVTZXQoKTtcclxuXHRucy50cmVlID0gdGhpcy50cmVlO1xyXG5cdG5zLnNpemUgPSB0aGlzLnNpemU7XHJcblx0bnMuYWRkQXJyYXkoci50b0FycmF5KCkpO1xyXG5cdHJldHVybiBucztcclxufTtcclxuXHJcbi8vIFhQYXRoTmFtZXNwYWNlIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuWFBhdGhOYW1lc3BhY2UucHJvdG90eXBlID0gbmV3IE9iamVjdCgpO1xyXG5YUGF0aE5hbWVzcGFjZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBYUGF0aE5hbWVzcGFjZTtcclxuWFBhdGhOYW1lc3BhY2Uuc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBYUGF0aE5hbWVzcGFjZShwcmUsIG5zLCBwKSB7XHJcblx0dGhpcy5pc1hQYXRoTmFtZXNwYWNlID0gdHJ1ZTtcclxuXHR0aGlzLm93bmVyRG9jdW1lbnQgPSBwLm93bmVyRG9jdW1lbnQ7XHJcblx0dGhpcy5ub2RlTmFtZSA9IFwiI25hbWVzcGFjZVwiO1xyXG5cdHRoaXMucHJlZml4ID0gcHJlO1xyXG5cdHRoaXMubG9jYWxOYW1lID0gcHJlO1xyXG5cdHRoaXMubmFtZXNwYWNlVVJJID0gbnM7XHJcblx0dGhpcy5ub2RlVmFsdWUgPSBucztcclxuXHR0aGlzLm93bmVyRWxlbWVudCA9IHA7XHJcblx0dGhpcy5ub2RlVHlwZSA9IFhQYXRoTmFtZXNwYWNlLlhQQVRIX05BTUVTUEFDRV9OT0RFO1xyXG59XHJcblxyXG5YUGF0aE5hbWVzcGFjZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCJ7IFxcXCJcIiArIHRoaXMucHJlZml4ICsgXCJcXFwiLCBcXFwiXCIgKyB0aGlzLm5hbWVzcGFjZVVSSSArIFwiXFxcIiB9XCI7XHJcbn07XHJcblxyXG4vLyBPcGVyYXRvcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbnZhciBPcGVyYXRvcnMgPSBuZXcgT2JqZWN0KCk7XHJcblxyXG5PcGVyYXRvcnMuZXF1YWxzID0gZnVuY3Rpb24obCwgcikge1xyXG5cdHJldHVybiBsLmVxdWFscyhyKTtcclxufTtcclxuXHJcbk9wZXJhdG9ycy5ub3RlcXVhbCA9IGZ1bmN0aW9uKGwsIHIpIHtcclxuXHRyZXR1cm4gbC5ub3RlcXVhbChyKTtcclxufTtcclxuXHJcbk9wZXJhdG9ycy5sZXNzdGhhbiA9IGZ1bmN0aW9uKGwsIHIpIHtcclxuXHRyZXR1cm4gbC5sZXNzdGhhbihyKTtcclxufTtcclxuXHJcbk9wZXJhdG9ycy5ncmVhdGVydGhhbiA9IGZ1bmN0aW9uKGwsIHIpIHtcclxuXHRyZXR1cm4gbC5ncmVhdGVydGhhbihyKTtcclxufTtcclxuXHJcbk9wZXJhdG9ycy5sZXNzdGhhbm9yZXF1YWwgPSBmdW5jdGlvbihsLCByKSB7XHJcblx0cmV0dXJuIGwubGVzc3RoYW5vcmVxdWFsKHIpO1xyXG59O1xyXG5cclxuT3BlcmF0b3JzLmdyZWF0ZXJ0aGFub3JlcXVhbCA9IGZ1bmN0aW9uKGwsIHIpIHtcclxuXHRyZXR1cm4gbC5ncmVhdGVydGhhbm9yZXF1YWwocik7XHJcbn07XHJcblxyXG4vLyBYUGF0aENvbnRleHQgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblhQYXRoQ29udGV4dC5wcm90b3R5cGUgPSBuZXcgT2JqZWN0KCk7XHJcblhQYXRoQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBYUGF0aENvbnRleHQ7XHJcblhQYXRoQ29udGV4dC5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFhQYXRoQ29udGV4dCh2ciwgbnIsIGZyKSB7XHJcblx0dGhpcy52YXJpYWJsZVJlc29sdmVyID0gdnIgIT0gbnVsbCA/IHZyIDogbmV3IFZhcmlhYmxlUmVzb2x2ZXIoKTtcclxuXHR0aGlzLm5hbWVzcGFjZVJlc29sdmVyID0gbnIgIT0gbnVsbCA/IG5yIDogbmV3IE5hbWVzcGFjZVJlc29sdmVyKCk7XHJcblx0dGhpcy5mdW5jdGlvblJlc29sdmVyID0gZnIgIT0gbnVsbCA/IGZyIDogbmV3IEZ1bmN0aW9uUmVzb2x2ZXIoKTtcclxufVxyXG5cclxuLy8gVmFyaWFibGVSZXNvbHZlciAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5WYXJpYWJsZVJlc29sdmVyLnByb3RvdHlwZSA9IG5ldyBPYmplY3QoKTtcclxuVmFyaWFibGVSZXNvbHZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWYXJpYWJsZVJlc29sdmVyO1xyXG5WYXJpYWJsZVJlc29sdmVyLnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gVmFyaWFibGVSZXNvbHZlcigpIHtcclxufVxyXG5cclxuVmFyaWFibGVSZXNvbHZlci5wcm90b3R5cGUuZ2V0VmFyaWFibGUgPSBmdW5jdGlvbih2biwgYykge1xyXG5cdHZhciBwYXJ0cyA9IFV0aWxpdGllcy5zcGxpdFFOYW1lKHZuKTtcclxuXHRpZiAocGFydHNbMF0gIT0gbnVsbCkge1xyXG5cdFx0cGFydHNbMF0gPSBjLm5hbWVzcGFjZVJlc29sdmVyLmdldE5hbWVzcGFjZShwYXJ0c1swXSwgYy5leHByZXNzaW9uQ29udGV4dE5vZGUpO1xyXG4gICAgICAgIGlmIChwYXJ0c1swXSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIFFOYW1lIFwiICsgZm4pO1xyXG4gICAgICAgIH1cclxuXHR9XHJcblx0cmV0dXJuIHRoaXMuZ2V0VmFyaWFibGVXaXRoTmFtZShwYXJ0c1swXSwgcGFydHNbMV0sIGMuZXhwcmVzc2lvbkNvbnRleHROb2RlKTtcclxufTtcclxuXHJcblZhcmlhYmxlUmVzb2x2ZXIucHJvdG90eXBlLmdldFZhcmlhYmxlV2l0aE5hbWUgPSBmdW5jdGlvbihucywgbG4sIGMpIHtcclxuXHRyZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8vIEZ1bmN0aW9uUmVzb2x2ZXIgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuRnVuY3Rpb25SZXNvbHZlci5wcm90b3R5cGUgPSBuZXcgT2JqZWN0KCk7XHJcbkZ1bmN0aW9uUmVzb2x2ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRnVuY3Rpb25SZXNvbHZlcjtcclxuRnVuY3Rpb25SZXNvbHZlci5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIEZ1bmN0aW9uUmVzb2x2ZXIodGhpc0FyZykge1xyXG5cdHRoaXMudGhpc0FyZyA9IHRoaXNBcmcgIT0gbnVsbCA/IHRoaXNBcmcgOiBGdW5jdGlvbnM7XHJcblx0dGhpcy5mdW5jdGlvbnMgPSBuZXcgT2JqZWN0KCk7XHJcblx0dGhpcy5hZGRTdGFuZGFyZEZ1bmN0aW9ucygpO1xyXG59XHJcblxyXG5GdW5jdGlvblJlc29sdmVyLnByb3RvdHlwZS5hZGRTdGFuZGFyZEZ1bmN0aW9ucyA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31sYXN0XCJdID0gRnVuY3Rpb25zLmxhc3Q7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fXBvc2l0aW9uXCJdID0gRnVuY3Rpb25zLnBvc2l0aW9uO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31jb3VudFwiXSA9IEZ1bmN0aW9ucy5jb3VudDtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9aWRcIl0gPSBGdW5jdGlvbnMuaWQ7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fWxvY2FsLW5hbWVcIl0gPSBGdW5jdGlvbnMubG9jYWxOYW1lO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31uYW1lc3BhY2UtdXJpXCJdID0gRnVuY3Rpb25zLm5hbWVzcGFjZVVSSTtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9bmFtZVwiXSA9IEZ1bmN0aW9ucy5uYW1lO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31zdHJpbmdcIl0gPSBGdW5jdGlvbnMuc3RyaW5nO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31jb25jYXRcIl0gPSBGdW5jdGlvbnMuY29uY2F0O1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31zdGFydHMtd2l0aFwiXSA9IEZ1bmN0aW9ucy5zdGFydHNXaXRoO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31jb250YWluc1wiXSA9IEZ1bmN0aW9ucy5jb250YWlucztcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9c3Vic3RyaW5nLWJlZm9yZVwiXSA9IEZ1bmN0aW9ucy5zdWJzdHJpbmdCZWZvcmU7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fXN1YnN0cmluZy1hZnRlclwiXSA9IEZ1bmN0aW9ucy5zdWJzdHJpbmdBZnRlcjtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9c3Vic3RyaW5nXCJdID0gRnVuY3Rpb25zLnN1YnN0cmluZztcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9c3RyaW5nLWxlbmd0aFwiXSA9IEZ1bmN0aW9ucy5zdHJpbmdMZW5ndGg7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fW5vcm1hbGl6ZS1zcGFjZVwiXSA9IEZ1bmN0aW9ucy5ub3JtYWxpemVTcGFjZTtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9dHJhbnNsYXRlXCJdID0gRnVuY3Rpb25zLnRyYW5zbGF0ZTtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9Ym9vbGVhblwiXSA9IEZ1bmN0aW9ucy5ib29sZWFuXztcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9bm90XCJdID0gRnVuY3Rpb25zLm5vdDtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9dHJ1ZVwiXSA9IEZ1bmN0aW9ucy50cnVlXztcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9ZmFsc2VcIl0gPSBGdW5jdGlvbnMuZmFsc2VfO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31sYW5nXCJdID0gRnVuY3Rpb25zLmxhbmc7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fW51bWJlclwiXSA9IEZ1bmN0aW9ucy5udW1iZXI7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fXN1bVwiXSA9IEZ1bmN0aW9ucy5zdW07XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fWZsb29yXCJdID0gRnVuY3Rpb25zLmZsb29yO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31jZWlsaW5nXCJdID0gRnVuY3Rpb25zLmNlaWxpbmc7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fXJvdW5kXCJdID0gRnVuY3Rpb25zLnJvdW5kO1xyXG59O1xyXG5cclxuRnVuY3Rpb25SZXNvbHZlci5wcm90b3R5cGUuYWRkRnVuY3Rpb24gPSBmdW5jdGlvbihucywgbG4sIGYpIHtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcIntcIiArIG5zICsgXCJ9XCIgKyBsbl0gPSBmO1xyXG59O1xyXG5cclxuRnVuY3Rpb25SZXNvbHZlci5wcm90b3R5cGUuZ2V0RnVuY3Rpb24gPSBmdW5jdGlvbihmbiwgYykge1xyXG5cdHZhciBwYXJ0cyA9IFV0aWxpdGllcy5yZXNvbHZlUU5hbWUoZm4sIGMubmFtZXNwYWNlUmVzb2x2ZXIsIGMuY29udGV4dE5vZGUsIGZhbHNlKTtcclxuICAgIGlmIChwYXJ0c1swXSA9PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgUU5hbWUgXCIgKyBmbik7XHJcbiAgICB9XHJcblx0cmV0dXJuIHRoaXMuZ2V0RnVuY3Rpb25XaXRoTmFtZShwYXJ0c1swXSwgcGFydHNbMV0sIGMuY29udGV4dE5vZGUpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25SZXNvbHZlci5wcm90b3R5cGUuZ2V0RnVuY3Rpb25XaXRoTmFtZSA9IGZ1bmN0aW9uKG5zLCBsbiwgYykge1xyXG5cdHJldHVybiB0aGlzLmZ1bmN0aW9uc1tcIntcIiArIG5zICsgXCJ9XCIgKyBsbl07XHJcbn07XHJcblxyXG4vLyBOYW1lc3BhY2VSZXNvbHZlciAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbk5hbWVzcGFjZVJlc29sdmVyLnByb3RvdHlwZSA9IG5ldyBPYmplY3QoKTtcclxuTmFtZXNwYWNlUmVzb2x2ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTmFtZXNwYWNlUmVzb2x2ZXI7XHJcbk5hbWVzcGFjZVJlc29sdmVyLnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gTmFtZXNwYWNlUmVzb2x2ZXIoKSB7XHJcbn1cclxuXHJcbk5hbWVzcGFjZVJlc29sdmVyLnByb3RvdHlwZS5nZXROYW1lc3BhY2UgPSBmdW5jdGlvbihwcmVmaXgsIG4pIHtcclxuXHRpZiAocHJlZml4ID09IFwieG1sXCIpIHtcclxuXHRcdHJldHVybiBYUGF0aC5YTUxfTkFNRVNQQUNFX1VSSTtcclxuXHR9IGVsc2UgaWYgKHByZWZpeCA9PSBcInhtbG5zXCIpIHtcclxuXHRcdHJldHVybiBYUGF0aC5YTUxOU19OQU1FU1BBQ0VfVVJJO1xyXG5cdH1cclxuXHRpZiAobi5ub2RlVHlwZSA9PSA5IC8qTm9kZS5ET0NVTUVOVF9OT0RFKi8pIHtcclxuXHRcdG4gPSBuLmRvY3VtZW50RWxlbWVudDtcclxuXHR9IGVsc2UgaWYgKG4ubm9kZVR5cGUgPT0gMiAvKk5vZGUuQVRUUklCVVRFX05PREUqLykge1xyXG5cdFx0biA9IFBhdGhFeHByLnByb3RvdHlwZS5nZXRPd25lckVsZW1lbnQobik7XHJcblx0fSBlbHNlIGlmIChuLm5vZGVUeXBlICE9IDEgLypOb2RlLkVMRU1FTlRfTk9ERSovKSB7XHJcblx0XHRuID0gbi5wYXJlbnROb2RlO1xyXG5cdH1cclxuXHR3aGlsZSAobiAhPSBudWxsICYmIG4ubm9kZVR5cGUgPT0gMSAvKk5vZGUuRUxFTUVOVF9OT0RFKi8pIHtcclxuXHRcdHZhciBubm0gPSBuLmF0dHJpYnV0ZXM7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5ubS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgYSA9IG5ubS5pdGVtKGkpO1xyXG5cdFx0XHR2YXIgYW5hbWUgPSBhLm5vZGVOYW1lO1xyXG5cdFx0XHRpZiAoYW5hbWUgPT0gXCJ4bWxuc1wiICYmIHByZWZpeCA9PSBcIlwiXHJcblx0XHRcdFx0XHR8fCBhbmFtZSA9PSBcInhtbG5zOlwiICsgcHJlZml4KSB7XHJcblx0XHRcdFx0cmV0dXJuIFN0cmluZyhhLm5vZGVWYWx1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdG4gPSBuLnBhcmVudE5vZGU7XHJcblx0fVxyXG5cdHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuLy8gRnVuY3Rpb25zIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5GdW5jdGlvbnMgPSBuZXcgT2JqZWN0KCk7XHJcblxyXG5GdW5jdGlvbnMubGFzdCA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGxhc3QgZXhwZWN0cyAoKVwiKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYTnVtYmVyKGMuY29udGV4dFNpemUpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLnBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gcG9zaXRpb24gZXhwZWN0cyAoKVwiKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYTnVtYmVyKGMuY29udGV4dFBvc2l0aW9uKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5jb3VudCA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdHZhciBucztcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyIHx8ICFVdGlsaXRpZXMuaW5zdGFuY2Vfb2YobnMgPSBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYyksIFhOb2RlU2V0KSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gY291bnQgZXhwZWN0cyAobm9kZS1zZXQpXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIobnMuc2l6ZSk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMuaWQgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHR2YXIgaWQ7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMikge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gaWQgZXhwZWN0cyAob2JqZWN0KVwiKTtcclxuXHR9XHJcblx0aWQgPSBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYyk7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihpZCwgWE5vZGVTZXQpKSB7XHJcblx0XHRpZCA9IGlkLnRvQXJyYXkoKS5qb2luKFwiIFwiKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0aWQgPSBpZC5zdHJpbmdWYWx1ZSgpO1xyXG5cdH1cclxuXHR2YXIgaWRzID0gaWQuc3BsaXQoL1tcXHgwZFxceDBhXFx4MDlcXHgyMF0rLyk7XHJcblx0dmFyIGNvdW50ID0gMDtcclxuXHR2YXIgbnMgPSBuZXcgWE5vZGVTZXQoKTtcclxuXHR2YXIgZG9jID0gYy5jb250ZXh0Tm9kZS5ub2RlVHlwZSA9PSA5IC8qTm9kZS5ET0NVTUVOVF9OT0RFKi9cclxuXHRcdFx0PyBjLmNvbnRleHROb2RlXHJcblx0XHRcdDogYy5jb250ZXh0Tm9kZS5vd25lckRvY3VtZW50O1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgbjtcclxuXHRcdGlmIChkb2MuZ2V0RWxlbWVudEJ5SWQpIHtcclxuXHRcdFx0biA9IGRvYy5nZXRFbGVtZW50QnlJZChpZHNbaV0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0biA9IFV0aWxpdGllcy5nZXRFbGVtZW50QnlJZChkb2MsIGlkc1tpXSk7XHJcblx0XHR9XHJcblx0XHRpZiAobiAhPSBudWxsKSB7XHJcblx0XHRcdG5zLmFkZChuKTtcclxuXHRcdFx0Y291bnQrKztcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIG5zO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLmxvY2FsTmFtZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdHZhciBuO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcclxuXHRcdG4gPSBjLmNvbnRleHROb2RlO1xyXG5cdH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XHJcblx0XHRuID0gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLmZpcnN0KCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGxvY2FsLW5hbWUgZXhwZWN0cyAobm9kZS1zZXQ/KVwiKTtcclxuXHR9XHJcblx0aWYgKG4gPT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIG5ldyBYU3RyaW5nKFwiXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhTdHJpbmcobi5sb2NhbE5hbWUgPyBuLmxvY2FsTmFtZSA6IG4uYmFzZU5hbWUpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLm5hbWVzcGFjZVVSSSA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdHZhciBuO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcclxuXHRcdG4gPSBjLmNvbnRleHROb2RlO1xyXG5cdH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XHJcblx0XHRuID0gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLmZpcnN0KCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIG5hbWVzcGFjZS11cmkgZXhwZWN0cyAobm9kZS1zZXQ/KVwiKTtcclxuXHR9XHJcblx0aWYgKG4gPT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIG5ldyBYU3RyaW5nKFwiXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhTdHJpbmcobi5uYW1lc3BhY2VVUkkpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLm5hbWUgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHR2YXIgbjtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XHJcblx0XHRuID0gYy5jb250ZXh0Tm9kZTtcclxuXHR9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xyXG5cdFx0biA9IGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5maXJzdCgpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBuYW1lIGV4cGVjdHMgKG5vZGUtc2V0PylcIik7XHJcblx0fVxyXG5cdGlmIChuID09IG51bGwpIHtcclxuXHRcdHJldHVybiBuZXcgWFN0cmluZyhcIlwiKTtcclxuXHR9XHJcblx0aWYgKG4ubm9kZVR5cGUgPT0gMSAvKk5vZGUuRUxFTUVOVF9OT0RFKi8gfHwgbi5ub2RlVHlwZSA9PSAyIC8qTm9kZS5BVFRSSUJVVEVfTk9ERSovKSB7XHJcblx0XHRyZXR1cm4gbmV3IFhTdHJpbmcobi5ub2RlTmFtZSk7XHJcblx0fSBlbHNlIGlmIChuLmxvY2FsTmFtZSA9PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gbmV3IFhTdHJpbmcoXCJcIik7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiBuZXcgWFN0cmluZyhuLmxvY2FsTmFtZSk7XHJcblx0fVxyXG59O1xyXG5cclxuRnVuY3Rpb25zLnN0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcclxuXHRcdHJldHVybiBYTm9kZVNldC5wcm90b3R5cGUuc3RyaW5nRm9yTm9kZShjLmNvbnRleHROb2RlKTtcclxuXHR9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xyXG5cdFx0cmV0dXJuIGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5zdHJpbmcoKTtcclxuXHR9XHJcblx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gc3RyaW5nIGV4cGVjdHMgKG9iamVjdD8pXCIpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLmNvbmNhdCA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gY29uY2F0IGV4cGVjdHMgKHN0cmluZywgc3RyaW5nLCBzdHJpbmcqKVwiKTtcclxuXHR9XHJcblx0dmFyIHMgPSBcIlwiO1xyXG5cdGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRzICs9IGFyZ3VtZW50c1tpXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhTdHJpbmcocyk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMuc3RhcnRzV2l0aCA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDMpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIHN0YXJ0c1dpdGggZXhwZWN0cyAoc3RyaW5nLCBzdHJpbmcpXCIpO1xyXG5cdH1cclxuXHR2YXIgczEgPSBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykuc3RyaW5nVmFsdWUoKTtcclxuXHR2YXIgczIgPSBhcmd1bWVudHNbMl0uZXZhbHVhdGUoYykuc3RyaW5nVmFsdWUoKTtcclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHMxLnN1YnN0cmluZygwLCBzMi5sZW5ndGgpID09IHMyKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5jb250YWlucyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDMpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGNvbnRhaW5zIGV4cGVjdHMgKHN0cmluZywgc3RyaW5nKVwiKTtcclxuXHR9XHJcblx0dmFyIHMxID0gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLnN0cmluZ1ZhbHVlKCk7XHJcblx0dmFyIHMyID0gYXJndW1lbnRzWzJdLmV2YWx1YXRlKGMpLnN0cmluZ1ZhbHVlKCk7XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbihzMS5pbmRleE9mKHMyKSAhPSAtMSk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMuc3Vic3RyaW5nQmVmb3JlID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMykge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gc3Vic3RyaW5nLWJlZm9yZSBleHBlY3RzIChzdHJpbmcsIHN0cmluZylcIik7XHJcblx0fVxyXG5cdHZhciBzMSA9IGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdHZhciBzMiA9IGFyZ3VtZW50c1syXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdHJldHVybiBuZXcgWFN0cmluZyhzMS5zdWJzdHJpbmcoMCwgczEuaW5kZXhPZihzMikpKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5zdWJzdHJpbmdBZnRlciA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDMpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIHN1YnN0cmluZy1hZnRlciBleHBlY3RzIChzdHJpbmcsIHN0cmluZylcIik7XHJcblx0fVxyXG5cdHZhciBzMSA9IGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdHZhciBzMiA9IGFyZ3VtZW50c1syXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdGlmIChzMi5sZW5ndGggPT0gMCkge1xyXG5cdFx0cmV0dXJuIG5ldyBYU3RyaW5nKHMxKTtcclxuXHR9XHJcblx0dmFyIGkgPSBzMS5pbmRleE9mKHMyKTtcclxuXHRpZiAoaSA9PSAtMSkge1xyXG5cdFx0cmV0dXJuIG5ldyBYU3RyaW5nKFwiXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhTdHJpbmcoczEuc3Vic3RyaW5nKHMxLmluZGV4T2YoczIpICsgMSkpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLnN1YnN0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdGlmICghKGFyZ3VtZW50cy5sZW5ndGggPT0gMyB8fCBhcmd1bWVudHMubGVuZ3RoID09IDQpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBzdWJzdHJpbmcgZXhwZWN0cyAoc3RyaW5nLCBudW1iZXIsIG51bWJlcj8pXCIpO1xyXG5cdH1cclxuXHR2YXIgcyA9IGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdHZhciBuMSA9IE1hdGgucm91bmQoYXJndW1lbnRzWzJdLmV2YWx1YXRlKGMpLm51bWJlclZhbHVlKCkpIC0gMTtcclxuXHR2YXIgbjIgPSBhcmd1bWVudHMubGVuZ3RoID09IDQgPyBuMSArIE1hdGgucm91bmQoYXJndW1lbnRzWzNdLmV2YWx1YXRlKGMpLm51bWJlclZhbHVlKCkpIDogdW5kZWZpbmVkO1xyXG5cdHJldHVybiBuZXcgWFN0cmluZyhzLnN1YnN0cmluZyhuMSwgbjIpKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5zdHJpbmdMZW5ndGggPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHR2YXIgcztcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XHJcblx0XHRzID0gWE5vZGVTZXQucHJvdG90eXBlLnN0cmluZ0Zvck5vZGUoYy5jb250ZXh0Tm9kZSk7XHJcblx0fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcclxuXHRcdHMgPSBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykuc3RyaW5nVmFsdWUoKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gc3RyaW5nLWxlbmd0aCBleHBlY3RzIChzdHJpbmc/KVwiKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYTnVtYmVyKHMubGVuZ3RoKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5ub3JtYWxpemVTcGFjZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdHZhciBzO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcclxuXHRcdHMgPSBYTm9kZVNldC5wcm90b3R5cGUuc3RyaW5nRm9yTm9kZShjLmNvbnRleHROb2RlKTtcclxuXHR9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xyXG5cdFx0cyA9IGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBub3JtYWxpemUtc3BhY2UgZXhwZWN0cyAoc3RyaW5nPylcIik7XHJcblx0fVxyXG5cdHZhciBpID0gMDtcclxuXHR2YXIgaiA9IHMubGVuZ3RoIC0gMTtcclxuXHR3aGlsZSAoVXRpbGl0aWVzLmlzU3BhY2Uocy5jaGFyQ29kZUF0KGopKSkge1xyXG5cdFx0ai0tO1xyXG5cdH1cclxuXHR2YXIgdCA9IFwiXCI7XHJcblx0d2hpbGUgKGkgPD0gaiAmJiBVdGlsaXRpZXMuaXNTcGFjZShzLmNoYXJDb2RlQXQoaSkpKSB7XHJcblx0XHRpKys7XHJcblx0fVxyXG5cdHdoaWxlIChpIDw9IGopIHtcclxuXHRcdGlmIChVdGlsaXRpZXMuaXNTcGFjZShzLmNoYXJDb2RlQXQoaSkpKSB7XHJcblx0XHRcdHQgKz0gXCIgXCI7XHJcblx0XHRcdHdoaWxlIChpIDw9IGogJiYgVXRpbGl0aWVzLmlzU3BhY2Uocy5jaGFyQ29kZUF0KGkpKSkge1xyXG5cdFx0XHRcdGkrKztcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dCArPSBzLmNoYXJBdChpKTtcclxuXHRcdFx0aSsrO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhTdHJpbmcodCk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMudHJhbnNsYXRlID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gNCkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gdHJhbnNsYXRlIGV4cGVjdHMgKHN0cmluZywgc3RyaW5nLCBzdHJpbmcpXCIpO1xyXG5cdH1cclxuXHR2YXIgczEgPSBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykuc3RyaW5nVmFsdWUoKTtcclxuXHR2YXIgczIgPSBhcmd1bWVudHNbMl0uZXZhbHVhdGUoYykuc3RyaW5nVmFsdWUoKTtcclxuXHR2YXIgczMgPSBhcmd1bWVudHNbM10uZXZhbHVhdGUoYykuc3RyaW5nVmFsdWUoKTtcclxuXHR2YXIgbWFwID0gW107XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzMi5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGogPSBzMi5jaGFyQ29kZUF0KGkpO1xyXG5cdFx0aWYgKG1hcFtqXSA9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dmFyIGsgPSBpID4gczMubGVuZ3RoID8gXCJcIiA6IHMzLmNoYXJBdChpKTtcclxuXHRcdFx0bWFwW2pdID0gaztcclxuXHRcdH1cclxuXHR9XHJcblx0dmFyIHQgPSBcIlwiO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgczEubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBjID0gczEuY2hhckNvZGVBdChpKTtcclxuXHRcdHZhciByID0gbWFwW2NdO1xyXG5cdFx0aWYgKHIgPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHQgKz0gczEuY2hhckF0KGkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dCArPSByO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhTdHJpbmcodCk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMuYm9vbGVhbl8gPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBib29sZWFuIGV4cGVjdHMgKG9iamVjdClcIik7XHJcblx0fVxyXG5cdHJldHVybiBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykuYm9vbCgpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLm5vdCA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIG5vdCBleHBlY3RzIChvYmplY3QpXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLmJvb2woKS5ub3QoKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy50cnVlXyA9IGZ1bmN0aW9uKCkge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIHRydWUgZXhwZWN0cyAoKVwiKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbih0cnVlKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5mYWxzZV8gPSBmdW5jdGlvbigpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAxKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBmYWxzZSBleHBlY3RzICgpXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKGZhbHNlKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5sYW5nID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMikge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gbGFuZyBleHBlY3RzIChzdHJpbmcpXCIpO1xyXG5cdH1cclxuXHR2YXIgbGFuZztcclxuXHRmb3IgKHZhciBuID0gYy5jb250ZXh0Tm9kZTsgbiAhPSBudWxsICYmIG4ubm9kZVR5cGUgIT0gOSAvKk5vZGUuRE9DVU1FTlRfTk9ERSovOyBuID0gbi5wYXJlbnROb2RlKSB7XHJcblx0XHR2YXIgYSA9IG4uZ2V0QXR0cmlidXRlTlMoWFBhdGguWE1MX05BTUVTUEFDRV9VUkksIFwibGFuZ1wiKTtcclxuXHRcdGlmIChhICE9IG51bGwpIHtcclxuXHRcdFx0bGFuZyA9IFN0cmluZyhhKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChsYW5nID09IG51bGwpIHtcclxuXHRcdHJldHVybiBuZXcgWEJvb2xlYW4oZmFsc2UpO1xyXG5cdH1cclxuXHR2YXIgcyA9IGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4obGFuZy5zdWJzdHJpbmcoMCwgcy5sZW5ndGgpID09IHNcclxuXHRcdFx0XHQmJiAobGFuZy5sZW5ndGggPT0gcy5sZW5ndGggfHwgbGFuZy5jaGFyQXQocy5sZW5ndGgpID09ICctJykpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLm51bWJlciA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdGlmICghKGFyZ3VtZW50cy5sZW5ndGggPT0gMSB8fCBhcmd1bWVudHMubGVuZ3RoID09IDIpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBudW1iZXIgZXhwZWN0cyAob2JqZWN0PylcIik7XHJcblx0fVxyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcclxuXHRcdHJldHVybiBuZXcgWE51bWJlcihYTm9kZVNldC5wcm90b3R5cGUuc3RyaW5nRm9yTm9kZShjLmNvbnRleHROb2RlKSk7XHJcblx0fVxyXG5cdHJldHVybiBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykubnVtYmVyKCk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMuc3VtID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0dmFyIG5zO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIgfHwgIVV0aWxpdGllcy5pbnN0YW5jZV9vZigobnMgPSBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykpLCBYTm9kZVNldCkpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIHN1bSBleHBlY3RzIChub2RlLXNldClcIik7XHJcblx0fVxyXG5cdG5zID0gbnMudG9BcnJheSgpO1xyXG5cdHZhciBuID0gMDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRuICs9IG5ldyBYTnVtYmVyKFhOb2RlU2V0LnByb3RvdHlwZS5zdHJpbmdGb3JOb2RlKG5zW2ldKSkubnVtYmVyVmFsdWUoKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYTnVtYmVyKG4pO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLmZsb29yID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMikge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gZmxvb3IgZXhwZWN0cyAobnVtYmVyKVwiKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYTnVtYmVyKE1hdGguZmxvb3IoYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLm51bWJlclZhbHVlKCkpKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5jZWlsaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMikge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gY2VpbGluZyBleHBlY3RzIChudW1iZXIpXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIoTWF0aC5jZWlsKGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5udW1iZXJWYWx1ZSgpKSk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMucm91bmQgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiByb3VuZCBleHBlY3RzIChudW1iZXIpXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIoTWF0aC5yb3VuZChhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykubnVtYmVyVmFsdWUoKSkpO1xyXG59O1xyXG5cclxuLy8gVXRpbGl0aWVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5VdGlsaXRpZXMgPSBuZXcgT2JqZWN0KCk7XHJcblxyXG5VdGlsaXRpZXMuc3BsaXRRTmFtZSA9IGZ1bmN0aW9uKHFuKSB7XHJcblx0dmFyIGkgPSBxbi5pbmRleE9mKFwiOlwiKTtcclxuXHRpZiAoaSA9PSAtMSkge1xyXG5cdFx0cmV0dXJuIFsgbnVsbCwgcW4gXTtcclxuXHR9XHJcblx0cmV0dXJuIFsgcW4uc3Vic3RyaW5nKDAsIGkpLCBxbi5zdWJzdHJpbmcoaSArIDEpIF07XHJcbn07XHJcblxyXG5VdGlsaXRpZXMucmVzb2x2ZVFOYW1lID0gZnVuY3Rpb24ocW4sIG5yLCBuLCB1c2VEZWZhdWx0KSB7XHJcblx0dmFyIHBhcnRzID0gVXRpbGl0aWVzLnNwbGl0UU5hbWUocW4pO1xyXG5cdGlmIChwYXJ0c1swXSAhPSBudWxsKSB7XHJcblx0XHRwYXJ0c1swXSA9IG5yLmdldE5hbWVzcGFjZShwYXJ0c1swXSwgbik7XHJcblx0fSBlbHNlIHtcclxuXHRcdGlmICh1c2VEZWZhdWx0KSB7XHJcblx0XHRcdHBhcnRzWzBdID0gbnIuZ2V0TmFtZXNwYWNlKFwiXCIsIG4pO1xyXG5cdFx0XHRpZiAocGFydHNbMF0gPT0gbnVsbCkge1xyXG5cdFx0XHRcdHBhcnRzWzBdID0gXCJcIjtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cGFydHNbMF0gPSBcIlwiO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcGFydHM7XHJcbn07XHJcblxyXG5VdGlsaXRpZXMuaXNTcGFjZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gYyA9PSAweDkgfHwgYyA9PSAweGQgfHwgYyA9PSAweGEgfHwgYyA9PSAweDIwO1xyXG59O1xyXG5cclxuVXRpbGl0aWVzLmlzTGV0dGVyID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiBjID49IDB4MDA0MSAmJiBjIDw9IDB4MDA1QSB8fFxyXG5cdFx0YyA+PSAweDAwNjEgJiYgYyA8PSAweDAwN0EgfHxcclxuXHRcdGMgPj0gMHgwMEMwICYmIGMgPD0gMHgwMEQ2IHx8XHJcblx0XHRjID49IDB4MDBEOCAmJiBjIDw9IDB4MDBGNiB8fFxyXG5cdFx0YyA+PSAweDAwRjggJiYgYyA8PSAweDAwRkYgfHxcclxuXHRcdGMgPj0gMHgwMTAwICYmIGMgPD0gMHgwMTMxIHx8XHJcblx0XHRjID49IDB4MDEzNCAmJiBjIDw9IDB4MDEzRSB8fFxyXG5cdFx0YyA+PSAweDAxNDEgJiYgYyA8PSAweDAxNDggfHxcclxuXHRcdGMgPj0gMHgwMTRBICYmIGMgPD0gMHgwMTdFIHx8XHJcblx0XHRjID49IDB4MDE4MCAmJiBjIDw9IDB4MDFDMyB8fFxyXG5cdFx0YyA+PSAweDAxQ0QgJiYgYyA8PSAweDAxRjAgfHxcclxuXHRcdGMgPj0gMHgwMUY0ICYmIGMgPD0gMHgwMUY1IHx8XHJcblx0XHRjID49IDB4MDFGQSAmJiBjIDw9IDB4MDIxNyB8fFxyXG5cdFx0YyA+PSAweDAyNTAgJiYgYyA8PSAweDAyQTggfHxcclxuXHRcdGMgPj0gMHgwMkJCICYmIGMgPD0gMHgwMkMxIHx8XHJcblx0XHRjID09IDB4MDM4NiB8fFxyXG5cdFx0YyA+PSAweDAzODggJiYgYyA8PSAweDAzOEEgfHxcclxuXHRcdGMgPT0gMHgwMzhDIHx8XHJcblx0XHRjID49IDB4MDM4RSAmJiBjIDw9IDB4MDNBMSB8fFxyXG5cdFx0YyA+PSAweDAzQTMgJiYgYyA8PSAweDAzQ0UgfHxcclxuXHRcdGMgPj0gMHgwM0QwICYmIGMgPD0gMHgwM0Q2IHx8XHJcblx0XHRjID09IDB4MDNEQSB8fFxyXG5cdFx0YyA9PSAweDAzREMgfHxcclxuXHRcdGMgPT0gMHgwM0RFIHx8XHJcblx0XHRjID09IDB4MDNFMCB8fFxyXG5cdFx0YyA+PSAweDAzRTIgJiYgYyA8PSAweDAzRjMgfHxcclxuXHRcdGMgPj0gMHgwNDAxICYmIGMgPD0gMHgwNDBDIHx8XHJcblx0XHRjID49IDB4MDQwRSAmJiBjIDw9IDB4MDQ0RiB8fFxyXG5cdFx0YyA+PSAweDA0NTEgJiYgYyA8PSAweDA0NUMgfHxcclxuXHRcdGMgPj0gMHgwNDVFICYmIGMgPD0gMHgwNDgxIHx8XHJcblx0XHRjID49IDB4MDQ5MCAmJiBjIDw9IDB4MDRDNCB8fFxyXG5cdFx0YyA+PSAweDA0QzcgJiYgYyA8PSAweDA0QzggfHxcclxuXHRcdGMgPj0gMHgwNENCICYmIGMgPD0gMHgwNENDIHx8XHJcblx0XHRjID49IDB4MDREMCAmJiBjIDw9IDB4MDRFQiB8fFxyXG5cdFx0YyA+PSAweDA0RUUgJiYgYyA8PSAweDA0RjUgfHxcclxuXHRcdGMgPj0gMHgwNEY4ICYmIGMgPD0gMHgwNEY5IHx8XHJcblx0XHRjID49IDB4MDUzMSAmJiBjIDw9IDB4MDU1NiB8fFxyXG5cdFx0YyA9PSAweDA1NTkgfHxcclxuXHRcdGMgPj0gMHgwNTYxICYmIGMgPD0gMHgwNTg2IHx8XHJcblx0XHRjID49IDB4MDVEMCAmJiBjIDw9IDB4MDVFQSB8fFxyXG5cdFx0YyA+PSAweDA1RjAgJiYgYyA8PSAweDA1RjIgfHxcclxuXHRcdGMgPj0gMHgwNjIxICYmIGMgPD0gMHgwNjNBIHx8XHJcblx0XHRjID49IDB4MDY0MSAmJiBjIDw9IDB4MDY0QSB8fFxyXG5cdFx0YyA+PSAweDA2NzEgJiYgYyA8PSAweDA2QjcgfHxcclxuXHRcdGMgPj0gMHgwNkJBICYmIGMgPD0gMHgwNkJFIHx8XHJcblx0XHRjID49IDB4MDZDMCAmJiBjIDw9IDB4MDZDRSB8fFxyXG5cdFx0YyA+PSAweDA2RDAgJiYgYyA8PSAweDA2RDMgfHxcclxuXHRcdGMgPT0gMHgwNkQ1IHx8XHJcblx0XHRjID49IDB4MDZFNSAmJiBjIDw9IDB4MDZFNiB8fFxyXG5cdFx0YyA+PSAweDA5MDUgJiYgYyA8PSAweDA5MzkgfHxcclxuXHRcdGMgPT0gMHgwOTNEIHx8XHJcblx0XHRjID49IDB4MDk1OCAmJiBjIDw9IDB4MDk2MSB8fFxyXG5cdFx0YyA+PSAweDA5ODUgJiYgYyA8PSAweDA5OEMgfHxcclxuXHRcdGMgPj0gMHgwOThGICYmIGMgPD0gMHgwOTkwIHx8XHJcblx0XHRjID49IDB4MDk5MyAmJiBjIDw9IDB4MDlBOCB8fFxyXG5cdFx0YyA+PSAweDA5QUEgJiYgYyA8PSAweDA5QjAgfHxcclxuXHRcdGMgPT0gMHgwOUIyIHx8XHJcblx0XHRjID49IDB4MDlCNiAmJiBjIDw9IDB4MDlCOSB8fFxyXG5cdFx0YyA+PSAweDA5REMgJiYgYyA8PSAweDA5REQgfHxcclxuXHRcdGMgPj0gMHgwOURGICYmIGMgPD0gMHgwOUUxIHx8XHJcblx0XHRjID49IDB4MDlGMCAmJiBjIDw9IDB4MDlGMSB8fFxyXG5cdFx0YyA+PSAweDBBMDUgJiYgYyA8PSAweDBBMEEgfHxcclxuXHRcdGMgPj0gMHgwQTBGICYmIGMgPD0gMHgwQTEwIHx8XHJcblx0XHRjID49IDB4MEExMyAmJiBjIDw9IDB4MEEyOCB8fFxyXG5cdFx0YyA+PSAweDBBMkEgJiYgYyA8PSAweDBBMzAgfHxcclxuXHRcdGMgPj0gMHgwQTMyICYmIGMgPD0gMHgwQTMzIHx8XHJcblx0XHRjID49IDB4MEEzNSAmJiBjIDw9IDB4MEEzNiB8fFxyXG5cdFx0YyA+PSAweDBBMzggJiYgYyA8PSAweDBBMzkgfHxcclxuXHRcdGMgPj0gMHgwQTU5ICYmIGMgPD0gMHgwQTVDIHx8XHJcblx0XHRjID09IDB4MEE1RSB8fFxyXG5cdFx0YyA+PSAweDBBNzIgJiYgYyA8PSAweDBBNzQgfHxcclxuXHRcdGMgPj0gMHgwQTg1ICYmIGMgPD0gMHgwQThCIHx8XHJcblx0XHRjID09IDB4MEE4RCB8fFxyXG5cdFx0YyA+PSAweDBBOEYgJiYgYyA8PSAweDBBOTEgfHxcclxuXHRcdGMgPj0gMHgwQTkzICYmIGMgPD0gMHgwQUE4IHx8XHJcblx0XHRjID49IDB4MEFBQSAmJiBjIDw9IDB4MEFCMCB8fFxyXG5cdFx0YyA+PSAweDBBQjIgJiYgYyA8PSAweDBBQjMgfHxcclxuXHRcdGMgPj0gMHgwQUI1ICYmIGMgPD0gMHgwQUI5IHx8XHJcblx0XHRjID09IDB4MEFCRCB8fFxyXG5cdFx0YyA9PSAweDBBRTAgfHxcclxuXHRcdGMgPj0gMHgwQjA1ICYmIGMgPD0gMHgwQjBDIHx8XHJcblx0XHRjID49IDB4MEIwRiAmJiBjIDw9IDB4MEIxMCB8fFxyXG5cdFx0YyA+PSAweDBCMTMgJiYgYyA8PSAweDBCMjggfHxcclxuXHRcdGMgPj0gMHgwQjJBICYmIGMgPD0gMHgwQjMwIHx8XHJcblx0XHRjID49IDB4MEIzMiAmJiBjIDw9IDB4MEIzMyB8fFxyXG5cdFx0YyA+PSAweDBCMzYgJiYgYyA8PSAweDBCMzkgfHxcclxuXHRcdGMgPT0gMHgwQjNEIHx8XHJcblx0XHRjID49IDB4MEI1QyAmJiBjIDw9IDB4MEI1RCB8fFxyXG5cdFx0YyA+PSAweDBCNUYgJiYgYyA8PSAweDBCNjEgfHxcclxuXHRcdGMgPj0gMHgwQjg1ICYmIGMgPD0gMHgwQjhBIHx8XHJcblx0XHRjID49IDB4MEI4RSAmJiBjIDw9IDB4MEI5MCB8fFxyXG5cdFx0YyA+PSAweDBCOTIgJiYgYyA8PSAweDBCOTUgfHxcclxuXHRcdGMgPj0gMHgwQjk5ICYmIGMgPD0gMHgwQjlBIHx8XHJcblx0XHRjID09IDB4MEI5QyB8fFxyXG5cdFx0YyA+PSAweDBCOUUgJiYgYyA8PSAweDBCOUYgfHxcclxuXHRcdGMgPj0gMHgwQkEzICYmIGMgPD0gMHgwQkE0IHx8XHJcblx0XHRjID49IDB4MEJBOCAmJiBjIDw9IDB4MEJBQSB8fFxyXG5cdFx0YyA+PSAweDBCQUUgJiYgYyA8PSAweDBCQjUgfHxcclxuXHRcdGMgPj0gMHgwQkI3ICYmIGMgPD0gMHgwQkI5IHx8XHJcblx0XHRjID49IDB4MEMwNSAmJiBjIDw9IDB4MEMwQyB8fFxyXG5cdFx0YyA+PSAweDBDMEUgJiYgYyA8PSAweDBDMTAgfHxcclxuXHRcdGMgPj0gMHgwQzEyICYmIGMgPD0gMHgwQzI4IHx8XHJcblx0XHRjID49IDB4MEMyQSAmJiBjIDw9IDB4MEMzMyB8fFxyXG5cdFx0YyA+PSAweDBDMzUgJiYgYyA8PSAweDBDMzkgfHxcclxuXHRcdGMgPj0gMHgwQzYwICYmIGMgPD0gMHgwQzYxIHx8XHJcblx0XHRjID49IDB4MEM4NSAmJiBjIDw9IDB4MEM4QyB8fFxyXG5cdFx0YyA+PSAweDBDOEUgJiYgYyA8PSAweDBDOTAgfHxcclxuXHRcdGMgPj0gMHgwQzkyICYmIGMgPD0gMHgwQ0E4IHx8XHJcblx0XHRjID49IDB4MENBQSAmJiBjIDw9IDB4MENCMyB8fFxyXG5cdFx0YyA+PSAweDBDQjUgJiYgYyA8PSAweDBDQjkgfHxcclxuXHRcdGMgPT0gMHgwQ0RFIHx8XHJcblx0XHRjID49IDB4MENFMCAmJiBjIDw9IDB4MENFMSB8fFxyXG5cdFx0YyA+PSAweDBEMDUgJiYgYyA8PSAweDBEMEMgfHxcclxuXHRcdGMgPj0gMHgwRDBFICYmIGMgPD0gMHgwRDEwIHx8XHJcblx0XHRjID49IDB4MEQxMiAmJiBjIDw9IDB4MEQyOCB8fFxyXG5cdFx0YyA+PSAweDBEMkEgJiYgYyA8PSAweDBEMzkgfHxcclxuXHRcdGMgPj0gMHgwRDYwICYmIGMgPD0gMHgwRDYxIHx8XHJcblx0XHRjID49IDB4MEUwMSAmJiBjIDw9IDB4MEUyRSB8fFxyXG5cdFx0YyA9PSAweDBFMzAgfHxcclxuXHRcdGMgPj0gMHgwRTMyICYmIGMgPD0gMHgwRTMzIHx8XHJcblx0XHRjID49IDB4MEU0MCAmJiBjIDw9IDB4MEU0NSB8fFxyXG5cdFx0YyA+PSAweDBFODEgJiYgYyA8PSAweDBFODIgfHxcclxuXHRcdGMgPT0gMHgwRTg0IHx8XHJcblx0XHRjID49IDB4MEU4NyAmJiBjIDw9IDB4MEU4OCB8fFxyXG5cdFx0YyA9PSAweDBFOEEgfHxcclxuXHRcdGMgPT0gMHgwRThEIHx8XHJcblx0XHRjID49IDB4MEU5NCAmJiBjIDw9IDB4MEU5NyB8fFxyXG5cdFx0YyA+PSAweDBFOTkgJiYgYyA8PSAweDBFOUYgfHxcclxuXHRcdGMgPj0gMHgwRUExICYmIGMgPD0gMHgwRUEzIHx8XHJcblx0XHRjID09IDB4MEVBNSB8fFxyXG5cdFx0YyA9PSAweDBFQTcgfHxcclxuXHRcdGMgPj0gMHgwRUFBICYmIGMgPD0gMHgwRUFCIHx8XHJcblx0XHRjID49IDB4MEVBRCAmJiBjIDw9IDB4MEVBRSB8fFxyXG5cdFx0YyA9PSAweDBFQjAgfHxcclxuXHRcdGMgPj0gMHgwRUIyICYmIGMgPD0gMHgwRUIzIHx8XHJcblx0XHRjID09IDB4MEVCRCB8fFxyXG5cdFx0YyA+PSAweDBFQzAgJiYgYyA8PSAweDBFQzQgfHxcclxuXHRcdGMgPj0gMHgwRjQwICYmIGMgPD0gMHgwRjQ3IHx8XHJcblx0XHRjID49IDB4MEY0OSAmJiBjIDw9IDB4MEY2OSB8fFxyXG5cdFx0YyA+PSAweDEwQTAgJiYgYyA8PSAweDEwQzUgfHxcclxuXHRcdGMgPj0gMHgxMEQwICYmIGMgPD0gMHgxMEY2IHx8XHJcblx0XHRjID09IDB4MTEwMCB8fFxyXG5cdFx0YyA+PSAweDExMDIgJiYgYyA8PSAweDExMDMgfHxcclxuXHRcdGMgPj0gMHgxMTA1ICYmIGMgPD0gMHgxMTA3IHx8XHJcblx0XHRjID09IDB4MTEwOSB8fFxyXG5cdFx0YyA+PSAweDExMEIgJiYgYyA8PSAweDExMEMgfHxcclxuXHRcdGMgPj0gMHgxMTBFICYmIGMgPD0gMHgxMTEyIHx8XHJcblx0XHRjID09IDB4MTEzQyB8fFxyXG5cdFx0YyA9PSAweDExM0UgfHxcclxuXHRcdGMgPT0gMHgxMTQwIHx8XHJcblx0XHRjID09IDB4MTE0QyB8fFxyXG5cdFx0YyA9PSAweDExNEUgfHxcclxuXHRcdGMgPT0gMHgxMTUwIHx8XHJcblx0XHRjID49IDB4MTE1NCAmJiBjIDw9IDB4MTE1NSB8fFxyXG5cdFx0YyA9PSAweDExNTkgfHxcclxuXHRcdGMgPj0gMHgxMTVGICYmIGMgPD0gMHgxMTYxIHx8XHJcblx0XHRjID09IDB4MTE2MyB8fFxyXG5cdFx0YyA9PSAweDExNjUgfHxcclxuXHRcdGMgPT0gMHgxMTY3IHx8XHJcblx0XHRjID09IDB4MTE2OSB8fFxyXG5cdFx0YyA+PSAweDExNkQgJiYgYyA8PSAweDExNkUgfHxcclxuXHRcdGMgPj0gMHgxMTcyICYmIGMgPD0gMHgxMTczIHx8XHJcblx0XHRjID09IDB4MTE3NSB8fFxyXG5cdFx0YyA9PSAweDExOUUgfHxcclxuXHRcdGMgPT0gMHgxMUE4IHx8XHJcblx0XHRjID09IDB4MTFBQiB8fFxyXG5cdFx0YyA+PSAweDExQUUgJiYgYyA8PSAweDExQUYgfHxcclxuXHRcdGMgPj0gMHgxMUI3ICYmIGMgPD0gMHgxMUI4IHx8XHJcblx0XHRjID09IDB4MTFCQSB8fFxyXG5cdFx0YyA+PSAweDExQkMgJiYgYyA8PSAweDExQzIgfHxcclxuXHRcdGMgPT0gMHgxMUVCIHx8XHJcblx0XHRjID09IDB4MTFGMCB8fFxyXG5cdFx0YyA9PSAweDExRjkgfHxcclxuXHRcdGMgPj0gMHgxRTAwICYmIGMgPD0gMHgxRTlCIHx8XHJcblx0XHRjID49IDB4MUVBMCAmJiBjIDw9IDB4MUVGOSB8fFxyXG5cdFx0YyA+PSAweDFGMDAgJiYgYyA8PSAweDFGMTUgfHxcclxuXHRcdGMgPj0gMHgxRjE4ICYmIGMgPD0gMHgxRjFEIHx8XHJcblx0XHRjID49IDB4MUYyMCAmJiBjIDw9IDB4MUY0NSB8fFxyXG5cdFx0YyA+PSAweDFGNDggJiYgYyA8PSAweDFGNEQgfHxcclxuXHRcdGMgPj0gMHgxRjUwICYmIGMgPD0gMHgxRjU3IHx8XHJcblx0XHRjID09IDB4MUY1OSB8fFxyXG5cdFx0YyA9PSAweDFGNUIgfHxcclxuXHRcdGMgPT0gMHgxRjVEIHx8XHJcblx0XHRjID49IDB4MUY1RiAmJiBjIDw9IDB4MUY3RCB8fFxyXG5cdFx0YyA+PSAweDFGODAgJiYgYyA8PSAweDFGQjQgfHxcclxuXHRcdGMgPj0gMHgxRkI2ICYmIGMgPD0gMHgxRkJDIHx8XHJcblx0XHRjID09IDB4MUZCRSB8fFxyXG5cdFx0YyA+PSAweDFGQzIgJiYgYyA8PSAweDFGQzQgfHxcclxuXHRcdGMgPj0gMHgxRkM2ICYmIGMgPD0gMHgxRkNDIHx8XHJcblx0XHRjID49IDB4MUZEMCAmJiBjIDw9IDB4MUZEMyB8fFxyXG5cdFx0YyA+PSAweDFGRDYgJiYgYyA8PSAweDFGREIgfHxcclxuXHRcdGMgPj0gMHgxRkUwICYmIGMgPD0gMHgxRkVDIHx8XHJcblx0XHRjID49IDB4MUZGMiAmJiBjIDw9IDB4MUZGNCB8fFxyXG5cdFx0YyA+PSAweDFGRjYgJiYgYyA8PSAweDFGRkMgfHxcclxuXHRcdGMgPT0gMHgyMTI2IHx8XHJcblx0XHRjID49IDB4MjEyQSAmJiBjIDw9IDB4MjEyQiB8fFxyXG5cdFx0YyA9PSAweDIxMkUgfHxcclxuXHRcdGMgPj0gMHgyMTgwICYmIGMgPD0gMHgyMTgyIHx8XHJcblx0XHRjID49IDB4MzA0MSAmJiBjIDw9IDB4MzA5NCB8fFxyXG5cdFx0YyA+PSAweDMwQTEgJiYgYyA8PSAweDMwRkEgfHxcclxuXHRcdGMgPj0gMHgzMTA1ICYmIGMgPD0gMHgzMTJDIHx8XHJcblx0XHRjID49IDB4QUMwMCAmJiBjIDw9IDB4RDdBMyB8fFxyXG5cdFx0YyA+PSAweDRFMDAgJiYgYyA8PSAweDlGQTUgfHxcclxuXHRcdGMgPT0gMHgzMDA3IHx8XHJcblx0XHRjID49IDB4MzAyMSAmJiBjIDw9IDB4MzAyOTtcclxufTtcclxuXHJcblV0aWxpdGllcy5pc05DTmFtZUNoYXIgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIGMgPj0gMHgwMDMwICYmIGMgPD0gMHgwMDM5XHJcblx0XHR8fCBjID49IDB4MDY2MCAmJiBjIDw9IDB4MDY2OVxyXG5cdFx0fHwgYyA+PSAweDA2RjAgJiYgYyA8PSAweDA2RjlcclxuXHRcdHx8IGMgPj0gMHgwOTY2ICYmIGMgPD0gMHgwOTZGXHJcblx0XHR8fCBjID49IDB4MDlFNiAmJiBjIDw9IDB4MDlFRlxyXG5cdFx0fHwgYyA+PSAweDBBNjYgJiYgYyA8PSAweDBBNkZcclxuXHRcdHx8IGMgPj0gMHgwQUU2ICYmIGMgPD0gMHgwQUVGXHJcblx0XHR8fCBjID49IDB4MEI2NiAmJiBjIDw9IDB4MEI2RlxyXG5cdFx0fHwgYyA+PSAweDBCRTcgJiYgYyA8PSAweDBCRUZcclxuXHRcdHx8IGMgPj0gMHgwQzY2ICYmIGMgPD0gMHgwQzZGXHJcblx0XHR8fCBjID49IDB4MENFNiAmJiBjIDw9IDB4MENFRlxyXG5cdFx0fHwgYyA+PSAweDBENjYgJiYgYyA8PSAweDBENkZcclxuXHRcdHx8IGMgPj0gMHgwRTUwICYmIGMgPD0gMHgwRTU5XHJcblx0XHR8fCBjID49IDB4MEVEMCAmJiBjIDw9IDB4MEVEOVxyXG5cdFx0fHwgYyA+PSAweDBGMjAgJiYgYyA8PSAweDBGMjlcclxuXHRcdHx8IGMgPT0gMHgwMDJFXHJcblx0XHR8fCBjID09IDB4MDAyRFxyXG5cdFx0fHwgYyA9PSAweDAwNUZcclxuXHRcdHx8IFV0aWxpdGllcy5pc0xldHRlcihjKVxyXG5cdFx0fHwgYyA+PSAweDAzMDAgJiYgYyA8PSAweDAzNDVcclxuXHRcdHx8IGMgPj0gMHgwMzYwICYmIGMgPD0gMHgwMzYxXHJcblx0XHR8fCBjID49IDB4MDQ4MyAmJiBjIDw9IDB4MDQ4NlxyXG5cdFx0fHwgYyA+PSAweDA1OTEgJiYgYyA8PSAweDA1QTFcclxuXHRcdHx8IGMgPj0gMHgwNUEzICYmIGMgPD0gMHgwNUI5XHJcblx0XHR8fCBjID49IDB4MDVCQiAmJiBjIDw9IDB4MDVCRFxyXG5cdFx0fHwgYyA9PSAweDA1QkZcclxuXHRcdHx8IGMgPj0gMHgwNUMxICYmIGMgPD0gMHgwNUMyXHJcblx0XHR8fCBjID09IDB4MDVDNFxyXG5cdFx0fHwgYyA+PSAweDA2NEIgJiYgYyA8PSAweDA2NTJcclxuXHRcdHx8IGMgPT0gMHgwNjcwXHJcblx0XHR8fCBjID49IDB4MDZENiAmJiBjIDw9IDB4MDZEQ1xyXG5cdFx0fHwgYyA+PSAweDA2REQgJiYgYyA8PSAweDA2REZcclxuXHRcdHx8IGMgPj0gMHgwNkUwICYmIGMgPD0gMHgwNkU0XHJcblx0XHR8fCBjID49IDB4MDZFNyAmJiBjIDw9IDB4MDZFOFxyXG5cdFx0fHwgYyA+PSAweDA2RUEgJiYgYyA8PSAweDA2RURcclxuXHRcdHx8IGMgPj0gMHgwOTAxICYmIGMgPD0gMHgwOTAzXHJcblx0XHR8fCBjID09IDB4MDkzQ1xyXG5cdFx0fHwgYyA+PSAweDA5M0UgJiYgYyA8PSAweDA5NENcclxuXHRcdHx8IGMgPT0gMHgwOTREXHJcblx0XHR8fCBjID49IDB4MDk1MSAmJiBjIDw9IDB4MDk1NFxyXG5cdFx0fHwgYyA+PSAweDA5NjIgJiYgYyA8PSAweDA5NjNcclxuXHRcdHx8IGMgPj0gMHgwOTgxICYmIGMgPD0gMHgwOTgzXHJcblx0XHR8fCBjID09IDB4MDlCQ1xyXG5cdFx0fHwgYyA9PSAweDA5QkVcclxuXHRcdHx8IGMgPT0gMHgwOUJGXHJcblx0XHR8fCBjID49IDB4MDlDMCAmJiBjIDw9IDB4MDlDNFxyXG5cdFx0fHwgYyA+PSAweDA5QzcgJiYgYyA8PSAweDA5QzhcclxuXHRcdHx8IGMgPj0gMHgwOUNCICYmIGMgPD0gMHgwOUNEXHJcblx0XHR8fCBjID09IDB4MDlEN1xyXG5cdFx0fHwgYyA+PSAweDA5RTIgJiYgYyA8PSAweDA5RTNcclxuXHRcdHx8IGMgPT0gMHgwQTAyXHJcblx0XHR8fCBjID09IDB4MEEzQ1xyXG5cdFx0fHwgYyA9PSAweDBBM0VcclxuXHRcdHx8IGMgPT0gMHgwQTNGXHJcblx0XHR8fCBjID49IDB4MEE0MCAmJiBjIDw9IDB4MEE0MlxyXG5cdFx0fHwgYyA+PSAweDBBNDcgJiYgYyA8PSAweDBBNDhcclxuXHRcdHx8IGMgPj0gMHgwQTRCICYmIGMgPD0gMHgwQTREXHJcblx0XHR8fCBjID49IDB4MEE3MCAmJiBjIDw9IDB4MEE3MVxyXG5cdFx0fHwgYyA+PSAweDBBODEgJiYgYyA8PSAweDBBODNcclxuXHRcdHx8IGMgPT0gMHgwQUJDXHJcblx0XHR8fCBjID49IDB4MEFCRSAmJiBjIDw9IDB4MEFDNVxyXG5cdFx0fHwgYyA+PSAweDBBQzcgJiYgYyA8PSAweDBBQzlcclxuXHRcdHx8IGMgPj0gMHgwQUNCICYmIGMgPD0gMHgwQUNEXHJcblx0XHR8fCBjID49IDB4MEIwMSAmJiBjIDw9IDB4MEIwM1xyXG5cdFx0fHwgYyA9PSAweDBCM0NcclxuXHRcdHx8IGMgPj0gMHgwQjNFICYmIGMgPD0gMHgwQjQzXHJcblx0XHR8fCBjID49IDB4MEI0NyAmJiBjIDw9IDB4MEI0OFxyXG5cdFx0fHwgYyA+PSAweDBCNEIgJiYgYyA8PSAweDBCNERcclxuXHRcdHx8IGMgPj0gMHgwQjU2ICYmIGMgPD0gMHgwQjU3XHJcblx0XHR8fCBjID49IDB4MEI4MiAmJiBjIDw9IDB4MEI4M1xyXG5cdFx0fHwgYyA+PSAweDBCQkUgJiYgYyA8PSAweDBCQzJcclxuXHRcdHx8IGMgPj0gMHgwQkM2ICYmIGMgPD0gMHgwQkM4XHJcblx0XHR8fCBjID49IDB4MEJDQSAmJiBjIDw9IDB4MEJDRFxyXG5cdFx0fHwgYyA9PSAweDBCRDdcclxuXHRcdHx8IGMgPj0gMHgwQzAxICYmIGMgPD0gMHgwQzAzXHJcblx0XHR8fCBjID49IDB4MEMzRSAmJiBjIDw9IDB4MEM0NFxyXG5cdFx0fHwgYyA+PSAweDBDNDYgJiYgYyA8PSAweDBDNDhcclxuXHRcdHx8IGMgPj0gMHgwQzRBICYmIGMgPD0gMHgwQzREXHJcblx0XHR8fCBjID49IDB4MEM1NSAmJiBjIDw9IDB4MEM1NlxyXG5cdFx0fHwgYyA+PSAweDBDODIgJiYgYyA8PSAweDBDODNcclxuXHRcdHx8IGMgPj0gMHgwQ0JFICYmIGMgPD0gMHgwQ0M0XHJcblx0XHR8fCBjID49IDB4MENDNiAmJiBjIDw9IDB4MENDOFxyXG5cdFx0fHwgYyA+PSAweDBDQ0EgJiYgYyA8PSAweDBDQ0RcclxuXHRcdHx8IGMgPj0gMHgwQ0Q1ICYmIGMgPD0gMHgwQ0Q2XHJcblx0XHR8fCBjID49IDB4MEQwMiAmJiBjIDw9IDB4MEQwM1xyXG5cdFx0fHwgYyA+PSAweDBEM0UgJiYgYyA8PSAweDBENDNcclxuXHRcdHx8IGMgPj0gMHgwRDQ2ICYmIGMgPD0gMHgwRDQ4XHJcblx0XHR8fCBjID49IDB4MEQ0QSAmJiBjIDw9IDB4MEQ0RFxyXG5cdFx0fHwgYyA9PSAweDBENTdcclxuXHRcdHx8IGMgPT0gMHgwRTMxXHJcblx0XHR8fCBjID49IDB4MEUzNCAmJiBjIDw9IDB4MEUzQVxyXG5cdFx0fHwgYyA+PSAweDBFNDcgJiYgYyA8PSAweDBFNEVcclxuXHRcdHx8IGMgPT0gMHgwRUIxXHJcblx0XHR8fCBjID49IDB4MEVCNCAmJiBjIDw9IDB4MEVCOVxyXG5cdFx0fHwgYyA+PSAweDBFQkIgJiYgYyA8PSAweDBFQkNcclxuXHRcdHx8IGMgPj0gMHgwRUM4ICYmIGMgPD0gMHgwRUNEXHJcblx0XHR8fCBjID49IDB4MEYxOCAmJiBjIDw9IDB4MEYxOVxyXG5cdFx0fHwgYyA9PSAweDBGMzVcclxuXHRcdHx8IGMgPT0gMHgwRjM3XHJcblx0XHR8fCBjID09IDB4MEYzOVxyXG5cdFx0fHwgYyA9PSAweDBGM0VcclxuXHRcdHx8IGMgPT0gMHgwRjNGXHJcblx0XHR8fCBjID49IDB4MEY3MSAmJiBjIDw9IDB4MEY4NFxyXG5cdFx0fHwgYyA+PSAweDBGODYgJiYgYyA8PSAweDBGOEJcclxuXHRcdHx8IGMgPj0gMHgwRjkwICYmIGMgPD0gMHgwRjk1XHJcblx0XHR8fCBjID09IDB4MEY5N1xyXG5cdFx0fHwgYyA+PSAweDBGOTkgJiYgYyA8PSAweDBGQURcclxuXHRcdHx8IGMgPj0gMHgwRkIxICYmIGMgPD0gMHgwRkI3XHJcblx0XHR8fCBjID09IDB4MEZCOVxyXG5cdFx0fHwgYyA+PSAweDIwRDAgJiYgYyA8PSAweDIwRENcclxuXHRcdHx8IGMgPT0gMHgyMEUxXHJcblx0XHR8fCBjID49IDB4MzAyQSAmJiBjIDw9IDB4MzAyRlxyXG5cdFx0fHwgYyA9PSAweDMwOTlcclxuXHRcdHx8IGMgPT0gMHgzMDlBXHJcblx0XHR8fCBjID09IDB4MDBCN1xyXG5cdFx0fHwgYyA9PSAweDAyRDBcclxuXHRcdHx8IGMgPT0gMHgwMkQxXHJcblx0XHR8fCBjID09IDB4MDM4N1xyXG5cdFx0fHwgYyA9PSAweDA2NDBcclxuXHRcdHx8IGMgPT0gMHgwRTQ2XHJcblx0XHR8fCBjID09IDB4MEVDNlxyXG5cdFx0fHwgYyA9PSAweDMwMDVcclxuXHRcdHx8IGMgPj0gMHgzMDMxICYmIGMgPD0gMHgzMDM1XHJcblx0XHR8fCBjID49IDB4MzA5RCAmJiBjIDw9IDB4MzA5RVxyXG5cdFx0fHwgYyA+PSAweDMwRkMgJiYgYyA8PSAweDMwRkU7XHJcbn07XHJcblxyXG5VdGlsaXRpZXMuY29hbGVzY2VUZXh0ID0gZnVuY3Rpb24obikge1xyXG5cdGZvciAodmFyIG0gPSBuLmZpcnN0Q2hpbGQ7IG0gIT0gbnVsbDsgbSA9IG0ubmV4dFNpYmxpbmcpIHtcclxuXHRcdGlmIChtLm5vZGVUeXBlID09IDMgLypOb2RlLlRFWFRfTk9ERSovIHx8IG0ubm9kZVR5cGUgPT0gNCAvKk5vZGUuQ0RBVEFfU0VDVElPTl9OT0RFKi8pIHtcclxuXHRcdFx0dmFyIHMgPSBtLm5vZGVWYWx1ZTtcclxuXHRcdFx0dmFyIGZpcnN0ID0gbTtcclxuXHRcdFx0bSA9IG0ubmV4dFNpYmxpbmc7XHJcblx0XHRcdHdoaWxlIChtICE9IG51bGwgJiYgKG0ubm9kZVR5cGUgPT0gMyAvKk5vZGUuVEVYVF9OT0RFKi8gfHwgbS5ub2RlVHlwZSA9PSA0IC8qTm9kZS5DREFUQV9TRUNUSU9OX05PREUqLykpIHtcclxuXHRcdFx0XHRzICs9IG0ubm9kZVZhbHVlO1xyXG5cdFx0XHRcdHZhciBkZWwgPSBtO1xyXG5cdFx0XHRcdG0gPSBtLm5leHRTaWJsaW5nO1xyXG5cdFx0XHRcdGRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRlbCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGZpcnN0Lm5vZGVUeXBlID09IDQgLypOb2RlLkNEQVRBX1NFQ1RJT05fTk9ERSovKSB7XHJcblx0XHRcdFx0dmFyIHAgPSBmaXJzdC5wYXJlbnROb2RlO1xyXG5cdFx0XHRcdGlmIChmaXJzdC5uZXh0U2libGluZyA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRwLnJlbW92ZUNoaWxkKGZpcnN0KTtcclxuXHRcdFx0XHRcdHAuYXBwZW5kQ2hpbGQocC5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHMpKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIG5leHQgPSBmaXJzdC5uZXh0U2libGluZztcclxuXHRcdFx0XHRcdHAucmVtb3ZlQ2hpbGQoZmlyc3QpO1xyXG5cdFx0XHRcdFx0cC5pbnNlcnRCZWZvcmUocC5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHMpLCBuZXh0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Zmlyc3Qubm9kZVZhbHVlID0gcztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAobSA9PSBudWxsKSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAobS5ub2RlVHlwZSA9PSAxIC8qTm9kZS5FTEVNRU5UX05PREUqLykge1xyXG5cdFx0XHRVdGlsaXRpZXMuY29hbGVzY2VUZXh0KG0pO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcblV0aWxpdGllcy5pbnN0YW5jZV9vZiA9IGZ1bmN0aW9uKG8sIGMpIHtcclxuXHR3aGlsZSAobyAhPSBudWxsKSB7XHJcblx0XHRpZiAoby5jb25zdHJ1Y3RvciA9PT0gYykge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGlmIChvID09PSBPYmplY3QpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0byA9IG8uY29uc3RydWN0b3Iuc3VwZXJjbGFzcztcclxuXHR9XHJcblx0cmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuVXRpbGl0aWVzLmdldEVsZW1lbnRCeUlkID0gZnVuY3Rpb24obiwgaWQpIHtcclxuXHQvLyBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBjaGVjayB0aGUgRFREIHRvIGNoZWNrIGZvciBhY3R1YWxcclxuXHQvLyBhdHRyaWJ1dGVzIG9mIHR5cGUgSUQsIHNvIHRoaXMgbWF5IGJlIGEgYml0IHdyb25nLlxyXG5cdGlmIChuLm5vZGVUeXBlID09IDEgLypOb2RlLkVMRU1FTlRfTk9ERSovKSB7XHJcblx0XHRpZiAobi5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PSBpZFxyXG5cdFx0XHRcdHx8IG4uZ2V0QXR0cmlidXRlTlMobnVsbCwgXCJpZFwiKSA9PSBpZCkge1xyXG5cdFx0XHRyZXR1cm4gbjtcclxuXHRcdH1cclxuXHR9XHJcblx0Zm9yICh2YXIgbSA9IG4uZmlyc3RDaGlsZDsgbSAhPSBudWxsOyBtID0gbS5uZXh0U2libGluZykge1xyXG5cdFx0dmFyIHJlcyA9IFV0aWxpdGllcy5nZXRFbGVtZW50QnlJZChtLCBpZCk7XHJcblx0XHRpZiAocmVzICE9IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIHJlcztcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG4vLyBYUGF0aEV4Y2VwdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblhQYXRoRXhjZXB0aW9uLnByb3RvdHlwZSA9IHt9O1xyXG5YUGF0aEV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBYUGF0aEV4Y2VwdGlvbjtcclxuWFBhdGhFeGNlcHRpb24uc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBYUGF0aEV4Y2VwdGlvbihjLCBlKSB7XHJcblx0dGhpcy5jb2RlID0gYztcclxuXHR0aGlzLmV4Y2VwdGlvbiA9IGU7XHJcbn1cclxuXHJcblhQYXRoRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBtc2cgPSB0aGlzLmV4Y2VwdGlvbiA/IFwiOiBcIiArIHRoaXMuZXhjZXB0aW9uLnRvU3RyaW5nKCkgOiBcIlwiO1xyXG5cdHN3aXRjaCAodGhpcy5jb2RlKSB7XHJcblx0XHRjYXNlIFhQYXRoRXhjZXB0aW9uLklOVkFMSURfRVhQUkVTU0lPTl9FUlI6XHJcblx0XHRcdHJldHVybiBcIkludmFsaWQgZXhwcmVzc2lvblwiICsgbXNnO1xyXG5cdFx0Y2FzZSBYUGF0aEV4Y2VwdGlvbi5UWVBFX0VSUjpcclxuXHRcdFx0cmV0dXJuIFwiVHlwZSBlcnJvclwiICsgbXNnO1xyXG5cdH1cclxufTtcclxuXHJcblhQYXRoRXhjZXB0aW9uLklOVkFMSURfRVhQUkVTU0lPTl9FUlIgPSA1MTtcclxuWFBhdGhFeGNlcHRpb24uVFlQRV9FUlIgPSA1MjtcclxuXHJcbi8vIFhQYXRoRXhwcmVzc2lvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuWFBhdGhFeHByZXNzaW9uLnByb3RvdHlwZSA9IHt9O1xyXG5YUGF0aEV4cHJlc3Npb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWFBhdGhFeHByZXNzaW9uO1xyXG5YUGF0aEV4cHJlc3Npb24uc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBYUGF0aEV4cHJlc3Npb24oZSwgciwgcCkge1xyXG5cdHRoaXMueHBhdGggPSBwLnBhcnNlKGUpO1xyXG5cdHRoaXMuY29udGV4dCA9IG5ldyBYUGF0aENvbnRleHQoKTtcclxuXHR0aGlzLmNvbnRleHQubmFtZXNwYWNlUmVzb2x2ZXIgPSBuZXcgWFBhdGhOU1Jlc29sdmVyV3JhcHBlcihyKTtcclxufVxyXG5cclxuWFBhdGhFeHByZXNzaW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKG4sIHQsIHJlcykge1xyXG5cdHRoaXMuY29udGV4dC5leHByZXNzaW9uQ29udGV4dE5vZGUgPSBuO1xyXG5cdHZhciByZXN1bHQgPSB0aGlzLnhwYXRoLmV2YWx1YXRlKHRoaXMuY29udGV4dCk7XHJcblx0cmV0dXJuIG5ldyBYUGF0aFJlc3VsdChyZXN1bHQsIHQpO1xyXG59XHJcblxyXG4vLyBYUGF0aE5TUmVzb2x2ZXJXcmFwcGVyIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblhQYXRoTlNSZXNvbHZlcldyYXBwZXIucHJvdG90eXBlID0ge307XHJcblhQYXRoTlNSZXNvbHZlcldyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWFBhdGhOU1Jlc29sdmVyV3JhcHBlcjtcclxuWFBhdGhOU1Jlc29sdmVyV3JhcHBlci5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFhQYXRoTlNSZXNvbHZlcldyYXBwZXIocikge1xyXG5cdHRoaXMueHBhdGhOU1Jlc29sdmVyID0gcjtcclxufVxyXG5cclxuWFBhdGhOU1Jlc29sdmVyV3JhcHBlci5wcm90b3R5cGUuZ2V0TmFtZXNwYWNlID0gZnVuY3Rpb24ocHJlZml4LCBuKSB7XHJcbiAgICBpZiAodGhpcy54cGF0aE5TUmVzb2x2ZXIgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cdHJldHVybiB0aGlzLnhwYXRoTlNSZXNvbHZlci5sb29rdXBOYW1lc3BhY2VVUkkocHJlZml4KTtcclxufTtcclxuXHJcbi8vIE5vZGVYUGF0aE5TUmVzb2x2ZXIgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuTm9kZVhQYXRoTlNSZXNvbHZlci5wcm90b3R5cGUgPSB7fTtcclxuTm9kZVhQYXRoTlNSZXNvbHZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOb2RlWFBhdGhOU1Jlc29sdmVyO1xyXG5Ob2RlWFBhdGhOU1Jlc29sdmVyLnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gTm9kZVhQYXRoTlNSZXNvbHZlcihuKSB7XHJcblx0dGhpcy5ub2RlID0gbjtcclxuXHR0aGlzLm5hbWVzcGFjZVJlc29sdmVyID0gbmV3IE5hbWVzcGFjZVJlc29sdmVyKCk7XHJcbn1cclxuXHJcbk5vZGVYUGF0aE5TUmVzb2x2ZXIucHJvdG90eXBlLmxvb2t1cE5hbWVzcGFjZVVSSSA9IGZ1bmN0aW9uKHByZWZpeCkge1xyXG5cdHJldHVybiB0aGlzLm5hbWVzcGFjZVJlc29sdmVyLmdldE5hbWVzcGFjZShwcmVmaXgsIHRoaXMubm9kZSk7XHJcbn07XHJcblxyXG4vLyBYUGF0aFJlc3VsdCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblhQYXRoUmVzdWx0LnByb3RvdHlwZSA9IHt9O1xyXG5YUGF0aFJlc3VsdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBYUGF0aFJlc3VsdDtcclxuWFBhdGhSZXN1bHQuc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBYUGF0aFJlc3VsdCh2LCB0KSB7XHJcblx0aWYgKHQgPT0gWFBhdGhSZXN1bHQuQU5ZX1RZUEUpIHtcclxuXHRcdGlmICh2LmNvbnN0cnVjdG9yID09PSBYU3RyaW5nKSB7XHJcblx0XHRcdHQgPSBYUGF0aFJlc3VsdC5TVFJJTkdfVFlQRTtcclxuXHRcdH0gZWxzZSBpZiAodi5jb25zdHJ1Y3RvciA9PT0gWE51bWJlcikge1xyXG5cdFx0XHR0ID0gWFBhdGhSZXN1bHQuTlVNQkVSX1RZUEU7XHJcblx0XHR9IGVsc2UgaWYgKHYuY29uc3RydWN0b3IgPT09IFhCb29sZWFuKSB7XHJcblx0XHRcdHQgPSBYUGF0aFJlc3VsdC5CT09MRUFOX1RZUEU7XHJcblx0XHR9IGVsc2UgaWYgKHYuY29uc3RydWN0b3IgPT09IFhOb2RlU2V0KSB7XHJcblx0XHRcdHQgPSBYUGF0aFJlc3VsdC5VTk9SREVSRURfTk9ERV9JVEVSQVRPUl9UWVBFO1xyXG5cdFx0fVxyXG5cdH1cclxuXHR0aGlzLnJlc3VsdFR5cGUgPSB0O1xyXG5cdHN3aXRjaCAodCkge1xyXG5cdFx0Y2FzZSBYUGF0aFJlc3VsdC5OVU1CRVJfVFlQRTpcclxuXHRcdFx0dGhpcy5udW1iZXJWYWx1ZSA9IHYubnVtYmVyVmFsdWUoKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0Y2FzZSBYUGF0aFJlc3VsdC5TVFJJTkdfVFlQRTpcclxuXHRcdFx0dGhpcy5zdHJpbmdWYWx1ZSA9IHYuc3RyaW5nVmFsdWUoKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0Y2FzZSBYUGF0aFJlc3VsdC5CT09MRUFOX1RZUEU6XHJcblx0XHRcdHRoaXMuYm9vbGVhblZhbHVlID0gdi5ib29sZWFuVmFsdWUoKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0Y2FzZSBYUGF0aFJlc3VsdC5BTllfVU5PUkRFUkVEX05PREVfVFlQRTpcclxuXHRcdGNhc2UgWFBhdGhSZXN1bHQuRklSU1RfT1JERVJFRF9OT0RFX1RZUEU6XHJcblx0XHRcdGlmICh2LmNvbnN0cnVjdG9yID09PSBYTm9kZVNldCkge1xyXG5cdFx0XHRcdHRoaXMuc2luZ2xlTm9kZVZhbHVlID0gdi5maXJzdCgpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgWFBhdGhSZXN1bHQuVU5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRTpcclxuXHRcdGNhc2UgWFBhdGhSZXN1bHQuT1JERVJFRF9OT0RFX0lURVJBVE9SX1RZUEU6XHJcblx0XHRcdGlmICh2LmNvbnN0cnVjdG9yID09PSBYTm9kZVNldCkge1xyXG5cdFx0XHRcdHRoaXMuaW52YWxpZEl0ZXJhdG9yU3RhdGUgPSBmYWxzZTtcclxuXHRcdFx0XHR0aGlzLm5vZGVzID0gdi50b0FycmF5KCk7XHJcblx0XHRcdFx0dGhpcy5pdGVyYXRvckluZGV4ID0gMDtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIFhQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEU6XHJcblx0XHRjYXNlIFhQYXRoUmVzdWx0Lk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFOlxyXG5cdFx0XHRpZiAodi5jb25zdHJ1Y3RvciA9PT0gWE5vZGVTZXQpIHtcclxuXHRcdFx0XHR0aGlzLm5vZGVzID0gdi50b0FycmF5KCk7XHJcblx0XHRcdFx0dGhpcy5zbmFwc2hvdExlbmd0aCA9IHRoaXMubm9kZXMubGVuZ3RoO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRicmVhaztcclxuXHR9XHJcblx0dGhyb3cgbmV3IFhQYXRoRXhjZXB0aW9uKFhQYXRoRXhjZXB0aW9uLlRZUEVfRVJSKTtcclxufTtcclxuXHJcblhQYXRoUmVzdWx0LnByb3RvdHlwZS5pdGVyYXRlTmV4dCA9IGZ1bmN0aW9uKCkge1xyXG5cdGlmICh0aGlzLnJlc3VsdFR5cGUgIT0gWFBhdGhSZXN1bHQuVU5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRVxyXG5cdFx0XHQmJiB0aGlzLnJlc3VsdFR5cGUgIT0gWFBhdGhSZXN1bHQuT1JERVJFRF9OT0RFX0lURVJBVE9SX1RZUEUpIHtcclxuXHRcdHRocm93IG5ldyBYUGF0aEV4Y2VwdGlvbihYUGF0aEV4Y2VwdGlvbi5UWVBFX0VSUik7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLm5vZGVzW3RoaXMuaXRlcmF0b3JJbmRleCsrXTtcclxufTtcclxuXHJcblhQYXRoUmVzdWx0LnByb3RvdHlwZS5zbmFwc2hvdEl0ZW0gPSBmdW5jdGlvbihpKSB7XHJcblx0aWYgKHRoaXMucmVzdWx0VHlwZSAhPSBYUGF0aFJlc3VsdC5VTk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFXHJcblx0XHRcdCYmIHRoaXMucmVzdWx0VHlwZSAhPSBYUGF0aFJlc3VsdC5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRSkge1xyXG5cdFx0dGhyb3cgbmV3IFhQYXRoRXhjZXB0aW9uKFhQYXRoRXhjZXB0aW9uLlRZUEVfRVJSKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMubm9kZXNbaV07XHJcbn07XHJcblxyXG5YUGF0aFJlc3VsdC5BTllfVFlQRSA9IDA7XHJcblhQYXRoUmVzdWx0Lk5VTUJFUl9UWVBFID0gMTtcclxuWFBhdGhSZXN1bHQuU1RSSU5HX1RZUEUgPSAyO1xyXG5YUGF0aFJlc3VsdC5CT09MRUFOX1RZUEUgPSAzO1xyXG5YUGF0aFJlc3VsdC5VTk9SREVSRURfTk9ERV9JVEVSQVRPUl9UWVBFID0gNDtcclxuWFBhdGhSZXN1bHQuT1JERVJFRF9OT0RFX0lURVJBVE9SX1RZUEUgPSA1O1xyXG5YUGF0aFJlc3VsdC5VTk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFID0gNjtcclxuWFBhdGhSZXN1bHQuT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEUgPSA3O1xyXG5YUGF0aFJlc3VsdC5BTllfVU5PUkRFUkVEX05PREVfVFlQRSA9IDg7XHJcblhQYXRoUmVzdWx0LkZJUlNUX09SREVSRURfTk9ERV9UWVBFID0gOTtcclxuXHJcbi8vIERPTSAzIFhQYXRoIHN1cHBvcnQgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuZnVuY3Rpb24gaW5zdGFsbERPTTNYUGF0aFN1cHBvcnQoZG9jLCBwKSB7XHJcblx0ZG9jLmNyZWF0ZUV4cHJlc3Npb24gPSBmdW5jdGlvbihlLCByKSB7XHJcblx0XHR0cnkge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFhQYXRoRXhwcmVzc2lvbihlLCByLCBwKTtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0dGhyb3cgbmV3IFhQYXRoRXhjZXB0aW9uKFhQYXRoRXhjZXB0aW9uLklOVkFMSURfRVhQUkVTU0lPTl9FUlIsIGUpO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0ZG9jLmNyZWF0ZU5TUmVzb2x2ZXIgPSBmdW5jdGlvbihuKSB7XHJcblx0XHRyZXR1cm4gbmV3IE5vZGVYUGF0aE5TUmVzb2x2ZXIobik7XHJcblx0fTtcclxuXHRkb2MuZXZhbHVhdGUgPSBmdW5jdGlvbihlLCBjbiwgciwgdCwgcmVzKSB7XHJcblx0XHRpZiAodCA8IDAgfHwgdCA+IDkpIHtcclxuXHRcdFx0dGhyb3cgeyBjb2RlOiAwLCB0b1N0cmluZzogZnVuY3Rpb24oKSB7IHJldHVybiBcIlJlcXVlc3QgdHlwZSBub3Qgc3VwcG9ydGVkXCI7IH0gfTtcclxuXHRcdH1cclxuICAgICAgICByZXR1cm4gZG9jLmNyZWF0ZUV4cHJlc3Npb24oZSwgciwgcCkuZXZhbHVhdGUoY24sIHQsIHJlcyk7XHJcblx0fTtcclxufTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLy8gSW5zdGFsbCBET00gMyBYUGF0aCBzdXBwb3J0IGZvciB0aGUgY3VycmVudCBkb2N1bWVudC5cclxudHJ5IHtcclxuXHR2YXIgc2hvdWxkSW5zdGFsbCA9IHRydWU7XHJcblx0dHJ5IHtcclxuXHRcdGlmIChkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxyXG5cdFx0XHRcdCYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmVcclxuXHRcdFx0XHQmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKFwiWFBhdGhcIiwgbnVsbCkpIHtcclxuXHRcdFx0c2hvdWxkSW5zdGFsbCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHR9XHJcblx0aWYgKHNob3VsZEluc3RhbGwpIHtcclxuXHRcdGluc3RhbGxET00zWFBhdGhTdXBwb3J0KGRvY3VtZW50LCBuZXcgWFBhdGhQYXJzZXIoKSk7XHJcblx0fVxyXG59IGNhdGNoIChlKSB7XHJcbn1cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBleHBvcnRzIGZvciBub2RlLmpzXHJcblxyXG5pbnN0YWxsRE9NM1hQYXRoU3VwcG9ydChleHBvcnRzLCBuZXcgWFBhdGhQYXJzZXIoKSk7XHJcblxyXG5leHBvcnRzLlhQYXRoUmVzdWx0ID0gWFBhdGhSZXN1bHQ7XHJcblxyXG4vLyBoZWxwZXJcclxuZXhwb3J0cy5zZWxlY3QgPSBmdW5jdGlvbihlLCBkb2MsIHNpbmdsZSkge1xyXG5cdHJldHVybiBleHBvcnRzLnNlbGVjdFdpdGhSZXNvbHZlcihlLCBkb2MsIG51bGwsIHNpbmdsZSk7XHJcbn07XHJcblxyXG5leHBvcnRzLnVzZU5hbWVzcGFjZXMgPSBmdW5jdGlvbihtYXBwaW5ncykge1xyXG5cdHZhciByZXNvbHZlciA9IHtcclxuXHRcdG1hcHBpbmdzOiBtYXBwaW5ncyB8fCB7fSxcclxuXHRcdGxvb2t1cE5hbWVzcGFjZVVSSTogZnVuY3Rpb24ocHJlZml4KSB7XHJcblx0XHRcdHJldHVybiB0aGlzLm1hcHBpbmdzW3ByZWZpeF07XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uKGUsIGRvYywgc2luZ2xlKSB7XHJcblx0XHRyZXR1cm4gZXhwb3J0cy5zZWxlY3RXaXRoUmVzb2x2ZXIoZSwgZG9jLCByZXNvbHZlciwgc2luZ2xlKTtcclxuXHR9O1xyXG59O1xyXG5cclxuZXhwb3J0cy5zZWxlY3RXaXRoUmVzb2x2ZXIgPSBmdW5jdGlvbihlLCBkb2MsIHJlc29sdmVyLCBzaW5nbGUpIHtcclxuXHR2YXIgZXhwcmVzc2lvbiA9IG5ldyBYUGF0aEV4cHJlc3Npb24oZSwgcmVzb2x2ZXIsIG5ldyBYUGF0aFBhcnNlcigpKTtcclxuXHR2YXIgdHlwZSA9IFhQYXRoUmVzdWx0LkFOWV9UWVBFO1xyXG5cclxuXHR2YXIgcmVzdWx0ID0gZXhwcmVzc2lvbi5ldmFsdWF0ZShkb2MsIHR5cGUsIG51bGwpO1xyXG5cclxuXHRpZiAocmVzdWx0LnJlc3VsdFR5cGUgPT0gWFBhdGhSZXN1bHQuU1RSSU5HX1RZUEUpIHtcclxuXHRcdHJlc3VsdCA9IHJlc3VsdC5zdHJpbmdWYWx1ZTtcclxuXHR9XHJcblx0ZWxzZSBpZiAocmVzdWx0LnJlc3VsdFR5cGUgPT0gWFBhdGhSZXN1bHQuTlVNQkVSX1RZUEUpIHtcclxuXHRcdHJlc3VsdCA9IHJlc3VsdC5udW1iZXJWYWx1ZTtcclxuXHR9XHJcblx0ZWxzZSBpZiAocmVzdWx0LnJlc3VsdFR5cGUgPT0gWFBhdGhSZXN1bHQuQk9PTEVBTl9UWVBFKSB7XHJcblx0XHRyZXN1bHQgPSByZXN1bHQuYm9vbGVhblZhbHVlO1xyXG5cdH1cclxuXHRlbHNlIHtcclxuXHRcdHJlc3VsdCA9IHJlc3VsdC5ub2RlcztcclxuXHRcdGlmIChzaW5nbGUpIHtcclxuXHRcdFx0cmVzdWx0ID0gcmVzdWx0WzBdO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbmV4cG9ydHMuc2VsZWN0MSA9IGZ1bmN0aW9uKGUsIGRvYykge1xyXG5cdHJldHVybiBleHBvcnRzLnNlbGVjdChlLCBkb2MsIHRydWUpO1xyXG59O1xyXG5cclxuLy8gZW5kIG5vbi1ub2RlIHdyYXBwZXJcclxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHhwYXRoKTtcclxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIHZhciBtO1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gMDtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbWl0dGVyLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IDE7XG4gIGVsc2VcbiAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbm1vZHVsZS5leHBvcnRzLkRpc3BhdGNoZXIgPSByZXF1aXJlKCcuL2xpYi9EaXNwYXRjaGVyJyk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERpc3BhdGNoZXJcbiAqIFxuICogQHByZXZlbnRNdW5nZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIF9wcmVmaXggPSAnSURfJztcblxuLyoqXG4gKiBEaXNwYXRjaGVyIGlzIHVzZWQgdG8gYnJvYWRjYXN0IHBheWxvYWRzIHRvIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLiBUaGlzIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSBnZW5lcmljIHB1Yi1zdWIgc3lzdGVtcyBpbiB0d28gd2F5czpcbiAqXG4gKiAgIDEpIENhbGxiYWNrcyBhcmUgbm90IHN1YnNjcmliZWQgdG8gcGFydGljdWxhciBldmVudHMuIEV2ZXJ5IHBheWxvYWQgaXNcbiAqICAgICAgZGlzcGF0Y2hlZCB0byBldmVyeSByZWdpc3RlcmVkIGNhbGxiYWNrLlxuICogICAyKSBDYWxsYmFja3MgY2FuIGJlIGRlZmVycmVkIGluIHdob2xlIG9yIHBhcnQgdW50aWwgb3RoZXIgY2FsbGJhY2tzIGhhdmVcbiAqICAgICAgYmVlbiBleGVjdXRlZC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgY29uc2lkZXIgdGhpcyBoeXBvdGhldGljYWwgZmxpZ2h0IGRlc3RpbmF0aW9uIGZvcm0sIHdoaWNoXG4gKiBzZWxlY3RzIGEgZGVmYXVsdCBjaXR5IHdoZW4gYSBjb3VudHJ5IGlzIHNlbGVjdGVkOlxuICpcbiAqICAgdmFyIGZsaWdodERpc3BhdGNoZXIgPSBuZXcgRGlzcGF0Y2hlcigpO1xuICpcbiAqICAgLy8gS2VlcHMgdHJhY2sgb2Ygd2hpY2ggY291bnRyeSBpcyBzZWxlY3RlZFxuICogICB2YXIgQ291bnRyeVN0b3JlID0ge2NvdW50cnk6IG51bGx9O1xuICpcbiAqICAgLy8gS2VlcHMgdHJhY2sgb2Ygd2hpY2ggY2l0eSBpcyBzZWxlY3RlZFxuICogICB2YXIgQ2l0eVN0b3JlID0ge2NpdHk6IG51bGx9O1xuICpcbiAqICAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIGJhc2UgZmxpZ2h0IHByaWNlIG9mIHRoZSBzZWxlY3RlZCBjaXR5XG4gKiAgIHZhciBGbGlnaHRQcmljZVN0b3JlID0ge3ByaWNlOiBudWxsfVxuICpcbiAqIFdoZW4gYSB1c2VyIGNoYW5nZXMgdGhlIHNlbGVjdGVkIGNpdHksIHdlIGRpc3BhdGNoIHRoZSBwYXlsb2FkOlxuICpcbiAqICAgZmxpZ2h0RGlzcGF0Y2hlci5kaXNwYXRjaCh7XG4gKiAgICAgYWN0aW9uVHlwZTogJ2NpdHktdXBkYXRlJyxcbiAqICAgICBzZWxlY3RlZENpdHk6ICdwYXJpcydcbiAqICAgfSk7XG4gKlxuICogVGhpcyBwYXlsb2FkIGlzIGRpZ2VzdGVkIGJ5IGBDaXR5U3RvcmVgOlxuICpcbiAqICAgZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgaWYgKHBheWxvYWQuYWN0aW9uVHlwZSA9PT0gJ2NpdHktdXBkYXRlJykge1xuICogICAgICAgQ2l0eVN0b3JlLmNpdHkgPSBwYXlsb2FkLnNlbGVjdGVkQ2l0eTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhIGNvdW50cnksIHdlIGRpc3BhdGNoIHRoZSBwYXlsb2FkOlxuICpcbiAqICAgZmxpZ2h0RGlzcGF0Y2hlci5kaXNwYXRjaCh7XG4gKiAgICAgYWN0aW9uVHlwZTogJ2NvdW50cnktdXBkYXRlJyxcbiAqICAgICBzZWxlY3RlZENvdW50cnk6ICdhdXN0cmFsaWEnXG4gKiAgIH0pO1xuICpcbiAqIFRoaXMgcGF5bG9hZCBpcyBkaWdlc3RlZCBieSBib3RoIHN0b3JlczpcbiAqXG4gKiAgIENvdW50cnlTdG9yZS5kaXNwYXRjaFRva2VuID0gZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgaWYgKHBheWxvYWQuYWN0aW9uVHlwZSA9PT0gJ2NvdW50cnktdXBkYXRlJykge1xuICogICAgICAgQ291bnRyeVN0b3JlLmNvdW50cnkgPSBwYXlsb2FkLnNlbGVjdGVkQ291bnRyeTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFdoZW4gdGhlIGNhbGxiYWNrIHRvIHVwZGF0ZSBgQ291bnRyeVN0b3JlYCBpcyByZWdpc3RlcmVkLCB3ZSBzYXZlIGEgcmVmZXJlbmNlXG4gKiB0byB0aGUgcmV0dXJuZWQgdG9rZW4uIFVzaW5nIHRoaXMgdG9rZW4gd2l0aCBgd2FpdEZvcigpYCwgd2UgY2FuIGd1YXJhbnRlZVxuICogdGhhdCBgQ291bnRyeVN0b3JlYCBpcyB1cGRhdGVkIGJlZm9yZSB0aGUgY2FsbGJhY2sgdGhhdCB1cGRhdGVzIGBDaXR5U3RvcmVgXG4gKiBuZWVkcyB0byBxdWVyeSBpdHMgZGF0YS5cbiAqXG4gKiAgIENpdHlTdG9yZS5kaXNwYXRjaFRva2VuID0gZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgaWYgKHBheWxvYWQuYWN0aW9uVHlwZSA9PT0gJ2NvdW50cnktdXBkYXRlJykge1xuICogICAgICAgLy8gYENvdW50cnlTdG9yZS5jb3VudHJ5YCBtYXkgbm90IGJlIHVwZGF0ZWQuXG4gKiAgICAgICBmbGlnaHREaXNwYXRjaGVyLndhaXRGb3IoW0NvdW50cnlTdG9yZS5kaXNwYXRjaFRva2VuXSk7XG4gKiAgICAgICAvLyBgQ291bnRyeVN0b3JlLmNvdW50cnlgIGlzIG5vdyBndWFyYW50ZWVkIHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogICAgICAgLy8gU2VsZWN0IHRoZSBkZWZhdWx0IGNpdHkgZm9yIHRoZSBuZXcgY291bnRyeVxuICogICAgICAgQ2l0eVN0b3JlLmNpdHkgPSBnZXREZWZhdWx0Q2l0eUZvckNvdW50cnkoQ291bnRyeVN0b3JlLmNvdW50cnkpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogVGhlIHVzYWdlIG9mIGB3YWl0Rm9yKClgIGNhbiBiZSBjaGFpbmVkLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgIEZsaWdodFByaWNlU3RvcmUuZGlzcGF0Y2hUb2tlbiA9XG4gKiAgICAgZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgICBzd2l0Y2ggKHBheWxvYWQuYWN0aW9uVHlwZSkge1xuICogICAgICAgICBjYXNlICdjb3VudHJ5LXVwZGF0ZSc6XG4gKiAgICAgICAgIGNhc2UgJ2NpdHktdXBkYXRlJzpcbiAqICAgICAgICAgICBmbGlnaHREaXNwYXRjaGVyLndhaXRGb3IoW0NpdHlTdG9yZS5kaXNwYXRjaFRva2VuXSk7XG4gKiAgICAgICAgICAgRmxpZ2h0UHJpY2VTdG9yZS5wcmljZSA9XG4gKiAgICAgICAgICAgICBnZXRGbGlnaHRQcmljZVN0b3JlKENvdW50cnlTdG9yZS5jb3VudHJ5LCBDaXR5U3RvcmUuY2l0eSk7XG4gKiAgICAgICAgICAgYnJlYWs7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBUaGUgYGNvdW50cnktdXBkYXRlYCBwYXlsb2FkIHdpbGwgYmUgZ3VhcmFudGVlZCB0byBpbnZva2UgdGhlIHN0b3JlcydcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzIGluIG9yZGVyOiBgQ291bnRyeVN0b3JlYCwgYENpdHlTdG9yZWAsIHRoZW5cbiAqIGBGbGlnaHRQcmljZVN0b3JlYC5cbiAqL1xuXG52YXIgRGlzcGF0Y2hlciA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERpc3BhdGNoZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpc3BhdGNoZXIpO1xuXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgdGhpcy5faXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2lzSGFuZGxlZCA9IHt9O1xuICAgIHRoaXMuX2lzUGVuZGluZyA9IHt9O1xuICAgIHRoaXMuX2xhc3RJRCA9IDE7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aXRoIGV2ZXJ5IGRpc3BhdGNoZWQgcGF5bG9hZC4gUmV0dXJuc1xuICAgKiBhIHRva2VuIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBgd2FpdEZvcigpYC5cbiAgICovXG5cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlcihjYWxsYmFjaykge1xuICAgIHZhciBpZCA9IF9wcmVmaXggKyB0aGlzLl9sYXN0SUQrKztcbiAgICB0aGlzLl9jYWxsYmFja3NbaWRdID0gY2FsbGJhY2s7XG4gICAgcmV0dXJuIGlkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2FsbGJhY2sgYmFzZWQgb24gaXRzIHRva2VuLlxuICAgKi9cblxuICBEaXNwYXRjaGVyLnByb3RvdHlwZS51bnJlZ2lzdGVyID0gZnVuY3Rpb24gdW5yZWdpc3RlcihpZCkge1xuICAgICF0aGlzLl9jYWxsYmFja3NbaWRdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Rpc3BhdGNoZXIudW5yZWdpc3RlciguLi4pOiBgJXNgIGRvZXMgbm90IG1hcCB0byBhIHJlZ2lzdGVyZWQgY2FsbGJhY2suJywgaWQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2lkXTtcbiAgfTtcblxuICAvKipcbiAgICogV2FpdHMgZm9yIHRoZSBjYWxsYmFja3Mgc3BlY2lmaWVkIHRvIGJlIGludm9rZWQgYmVmb3JlIGNvbnRpbnVpbmcgZXhlY3V0aW9uXG4gICAqIG9mIHRoZSBjdXJyZW50IGNhbGxiYWNrLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIGJ5IGEgY2FsbGJhY2sgaW5cbiAgICogcmVzcG9uc2UgdG8gYSBkaXNwYXRjaGVkIHBheWxvYWQuXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLndhaXRGb3IgPSBmdW5jdGlvbiB3YWl0Rm9yKGlkcykge1xuICAgICF0aGlzLl9pc0Rpc3BhdGNoaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Rpc3BhdGNoZXIud2FpdEZvciguLi4pOiBNdXN0IGJlIGludm9rZWQgd2hpbGUgZGlzcGF0Y2hpbmcuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpZHMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICB2YXIgaWQgPSBpZHNbaWldO1xuICAgICAgaWYgKHRoaXMuX2lzUGVuZGluZ1tpZF0pIHtcbiAgICAgICAgIXRoaXMuX2lzSGFuZGxlZFtpZF0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGlzcGF0Y2hlci53YWl0Rm9yKC4uLik6IENpcmN1bGFyIGRlcGVuZGVuY3kgZGV0ZWN0ZWQgd2hpbGUgJyArICd3YWl0aW5nIGZvciBgJXNgLicsIGlkKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgIXRoaXMuX2NhbGxiYWNrc1tpZF0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGlzcGF0Y2hlci53YWl0Rm9yKC4uLik6IGAlc2AgZG9lcyBub3QgbWFwIHRvIGEgcmVnaXN0ZXJlZCBjYWxsYmFjay4nLCBpZCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5faW52b2tlQ2FsbGJhY2soaWQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhIHBheWxvYWQgdG8gYWxsIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICAgKi9cblxuICBEaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoKHBheWxvYWQpIHtcbiAgICAhIXRoaXMuX2lzRGlzcGF0Y2hpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGlzcGF0Y2guZGlzcGF0Y2goLi4uKTogQ2Fubm90IGRpc3BhdGNoIGluIHRoZSBtaWRkbGUgb2YgYSBkaXNwYXRjaC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3RhcnREaXNwYXRjaGluZyhwYXlsb2FkKTtcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1BlbmRpbmdbaWRdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW52b2tlQ2FsbGJhY2soaWQpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9zdG9wRGlzcGF0Y2hpbmcoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIElzIHRoaXMgRGlzcGF0Y2hlciBjdXJyZW50bHkgZGlzcGF0Y2hpbmcuXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLmlzRGlzcGF0Y2hpbmcgPSBmdW5jdGlvbiBpc0Rpc3BhdGNoaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0Rpc3BhdGNoaW5nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBjYWxsYmFjayBzdG9yZWQgd2l0aCB0aGUgZ2l2ZW4gaWQuIEFsc28gZG8gc29tZSBpbnRlcm5hbFxuICAgKiBib29ra2VlcGluZy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLl9pbnZva2VDYWxsYmFjayA9IGZ1bmN0aW9uIF9pbnZva2VDYWxsYmFjayhpZCkge1xuICAgIHRoaXMuX2lzUGVuZGluZ1tpZF0gPSB0cnVlO1xuICAgIHRoaXMuX2NhbGxiYWNrc1tpZF0odGhpcy5fcGVuZGluZ1BheWxvYWQpO1xuICAgIHRoaXMuX2lzSGFuZGxlZFtpZF0gPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdXAgYm9va2tlZXBpbmcgbmVlZGVkIHdoZW4gZGlzcGF0Y2hpbmcuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICBEaXNwYXRjaGVyLnByb3RvdHlwZS5fc3RhcnREaXNwYXRjaGluZyA9IGZ1bmN0aW9uIF9zdGFydERpc3BhdGNoaW5nKHBheWxvYWQpIHtcbiAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgIHRoaXMuX2lzUGVuZGluZ1tpZF0gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzSGFuZGxlZFtpZF0gPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fcGVuZGluZ1BheWxvYWQgPSBwYXlsb2FkO1xuICAgIHRoaXMuX2lzRGlzcGF0Y2hpbmcgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciBib29ra2VlcGluZyB1c2VkIGZvciBkaXNwYXRjaGluZy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLl9zdG9wRGlzcGF0Y2hpbmcgPSBmdW5jdGlvbiBfc3RvcERpc3BhdGNoaW5nKCkge1xuICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nUGF5bG9hZDtcbiAgICB0aGlzLl9pc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gIH07XG5cbiAgcmV0dXJuIERpc3BhdGNoZXI7XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3BhdGNoZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGludmFyaWFudFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignSW52YXJpYW50IFZpb2xhdGlvbjogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7IiwiLyohXG4gKiBub2RlLWNhbGVuZGFyXG4gKiBDb3B5cmlnaHQoYykgMjAxMyBBcm1pbiBUYW16YXJpYW4gPHRhbXphcmlhbjE5ODlAZ21haWwuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIF9EQVlTX0lOX01PTlRIID0gWzAsIDMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuICAgIHZhciBfREFZU19CRUZPUkVfTU9OVEggPSBbLTEsIDAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgY2xkciA9IHJlcXVpcmUoXCJjbGRyXCIpO1xuICAgIH1cbiAgICBjYXRjaChlcnIpIHtcbiAgICAgIGNsZHIgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgdGhlIHByb3ZpZGVkIHdlZWtkYXkgaW5kZXggZnJvbSB0aGUgSmF2YXNjcmlwdCBpbmRleCBzY2hlbWVcbiAgICAgKiAoU1VOPTAsIE1PTj0xLCAuLi4pIHRvIHRoZSBQeXRob24gc2NoZW1lIChNT049MCwgVFVFPTEsIC4uLilcbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9hZGp1c3RXZWVrZGF5KHdlZWtkYXkpIHtcbiAgICAgIHJldHVybiB3ZWVrZGF5ID4gMCA/IHdlZWtkYXkgLSAxIDogNlxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgd2lkZSBvciBhYmJyZXZpYXRlZCBkYXkgbmFtZXMgZm9yIGEgc3BlY2lmaWVkIGxvY2FsZS5cbiAgICAgKiBJZiBjbGRyIGlzIG5vdCBpbnN0YWxsZWQgdmFsdWVzIGRlZmF1bHQgdG8gdGhhdCBmb3IgbG9jYWxlIGVuX1VTLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhYmJyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxvY2FsZVxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9leHRyYWN0TG9jYWxlRGF5cyhhYmJyLCBsb2NhbGUpIHtcbiAgICAgIHNob3J0ID0gdHlwZW9mKGFiYnIpID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBhYmJyO1xuXG4gICAgICBpZihhYmJyKSB7XG4gICAgICAgIHJldHVybiBjbGRyID8gY2xkci5leHRyYWN0RGF5TmFtZXMobG9jYWxlKS5mb3JtYXQuYWJicmV2aWF0ZWQgOiBbJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0JywgJ1N1biddO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjbGRyID8gY2xkci5leHRyYWN0RGF5TmFtZXMobG9jYWxlKS5mb3JtYXQud2lkZSA6IFsnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheScsICdTdW5kYXknXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHdpZGUgb3IgYWJicmV2aWF0ZWQgbW9udGggbmFtZXMgZm9yIGEgc3BlY2lmaWVkIGxvY2FsZS5cbiAgICAgKiBJZiBjbGRyIGlzIG5vdCBpbnN0YWxsZWQgdmFsdWVzIGRlZmF1bHQgdG8gdGhhdCBmb3IgbG9jYWxlIGVuX1VTLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhYmJyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxvY2FsZVxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9leHRyYWN0TG9jYWxlTW9udGhzKGFiYnIsIGxvY2FsZSkge1xuICAgICAgc2hvcnQgPSB0eXBlb2YoYWJicikgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IGFiYnI7XG5cbiAgICAgIHZhciBtb250aHMgPSBbXVxuICAgICAgaWYoYWJicikge1xuICAgICAgICBtb250aHMgPSBjbGRyID8gY2xkci5leHRyYWN0TW9udGhOYW1lcyhsb2NhbGUpLmZvcm1hdC5hYmJyZXZpYXRlZCA6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtb250aHMgPSBjbGRyID8gY2xkci5leHRyYWN0TW9udGhOYW1lcyhsb2NhbGUpLmZvcm1hdC53aWRlIDogWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ107XG4gICAgICB9XG5cbiAgICAgIG1vbnRocy51bnNoaWZ0KCcnKTtcbiAgICAgIHJldHVybiBtb250aHM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG9yZGluYWwgdGltZSBmcm9tIGdpdmVuIHllYXIsIG1vbnRoLCBkYXkgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbW9udGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF5XG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gX3Rvb3JkaW5hbCh5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgICB2YXIgZGF5c19iZWZvcmVfeWVhciA9ICgoeWVhciAtIDEpICogMzY1KSArIE1hdGguZmxvb3IoKHllYXIgLSAxKSAvIDQpIC0gTWF0aC5mbG9vcigoeWVhciAtIDEpIC8gMTAwKSArIE1hdGguZmxvb3IoKHllYXIgLSAxKSAvIDQwMCk7XG4gICAgICB2YXIgZGF5c19iZWZvcmVfbW9udGggPSBfREFZU19CRUZPUkVfTU9OVEhbbW9udGhdICsgKG1vbnRoID4gMiAmJiBpc2xlYXAoeWVhcikgPyAxIDogMCk7XG4gICAgICByZXR1cm4gKGRheXNfYmVmb3JlX3llYXIgKyBkYXlzX2JlZm9yZV9tb250aCArIGRheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgZm9yIGxlYXAgeWVhcnMsIGZhbHNlIGZvciBub24tbGVhcCB5ZWFycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc2xlYXAoeWVhcikge1xuICAgICAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gbnVtYmVyIG9mIGxlYXAgeWVhcnMgaW4gcmFuZ2UgW3kxLCB5MikuXG4gICAgICogQXNzdW1lcyB5MSA8PSB5Mi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVhcGRheXMoeTEsIHkyKSB7XG4gICAgICB5MS0tO1xuICAgICAgeTItLTtcbiAgICAgIHJldHVybiAoTWF0aC5mbG9vcih5Mi80KSAtIE1hdGguZmxvb3IoeTEvNCkpIC0gKE1hdGguZmxvb3IoeTIvMTAwKSAtIE1hdGguZmxvb3IoeTEvMTAwKSkgKyAoTWF0aC5mbG9vcih5Mi80MDApIC0gTWF0aC5mbG9vcih5MS80MDApKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHN0YXJ0aW5nIHdlZWtkYXkgKDAtNiB+IE1vbi1TdW4pIGFuZCBudW1iZXIgb2YgZGF5cyAoMjgtMzEpIGZvclxuICAgICAqIHllYXIsIG1vbnRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbW9udGhcbiAgICAgKiBAdGhyb3dzIHtJbGxlZ2FsTW9udGhFcnJvcn0gSWYgdGhlIHByb3ZpZGVkIG1vbnRoIGlzIGludmFsaWQuXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtb250aHJhbmdlKHllYXIsIG1vbnRoKSB7XG4gICAgICBpZihtb250aCA8IDEgfHwgbW9udGggPiAxMikge1xuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbE1vbnRoRXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRheTEgPSB3ZWVrZGF5KHllYXIsIG1vbnRoLCAxKTtcbiAgICAgIHZhciBuZGF5cyA9IF9EQVlTX0lOX01PTlRIW21vbnRoXSArIChtb250aCA9PT0gMiAmJiBpc2xlYXAoeWVhcikpO1xuXG4gICAgICByZXR1cm4gW2RheTEsIG5kYXlzXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbG9jYWxlIGZvciB1c2UgaW4gZXh0cmFjdGluZyBtb250aCBhbmQgd2Vla2RheSBuYW1lcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsb2NhbGVcbiAgICAgKiBAdGhyb3dzIHtJbGxlZ2FsTG9jYWxlRXJyb3J9IElmIHRoZSBwcm92aWRlZCBsb2NhbGUgaXMgaW52YWxpZC5cbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldGxvY2FsZShsb2NhbGUpIHtcbiAgICAgIGxvY2FsZSA9IHR5cGVvZihsb2NhbGUpID09PSBcInVuZGVmaW5lZFwiID8gXCJlbl9VU1wiIDogbG9jYWxlO1xuXG4gICAgICBpZigoY2xkciAmJiAoY2xkci5sb2NhbGVJZHMuaW5kZXhPZihsb2NhbGUucmVwbGFjZSgvLS9nLCAnXycpLnRvTG93ZXJDYXNlKCkpID09PSAtMSkpIHx8ICghY2xkciAmJiAoKGxvY2FsZS5yZXBsYWNlKC8tL2csICdfJykudG9Mb3dlckNhc2UoKSAhPT0gXCJlbl91c1wiKSkpKSB7XG4gICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbExvY2FsZUVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGF5X25hbWUgICA9IF9leHRyYWN0TG9jYWxlRGF5cyhmYWxzZSwgbG9jYWxlKTtcbiAgICAgIHRoaXMuZGF5X2FiYnIgICA9IF9leHRyYWN0TG9jYWxlRGF5cyh0cnVlLCBsb2NhbGUpO1xuICAgICAgdGhpcy5tb250aF9uYW1lID0gX2V4dHJhY3RMb2NhbGVNb250aHMoZmFsc2UsIGxvY2FsZSk7XG4gICAgICB0aGlzLm1vbnRoX2FiYnIgPSBfZXh0cmFjdExvY2FsZU1vbnRocyh0cnVlLCBsb2NhbGUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgICogVW5yZWxhdGVkIGJ1dCBoYW5keSBmdW5jdGlvbiB0byBjYWxjdWxhdGUgVW5peCB0aW1lc3RhbXAgZnJvbSBHTVQuXG4gICAgICAqXG4gICAgICAqIEBwYXJhbSB7QXJyYXl9IHR1cGxlXG4gICAgICAqIEB0aHJvd3Mge0lsbGVnYWxNb250aEVycm9yfSBJZiB0aGUgcHJvdmlkZWQgbW9udGggZWxlbWVudCBpcyBpbnZhbGlkLlxuICAgICAgKiBAdGhyb3dzIHtJbGxlZ2FsRGF5RXJyb3J9IElmIHRoZSBwcm92aWRlZCBkYXkgZWxlbWVudCBpcyBpbnZhbGlkLlxuICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lZ20odGltZWdtdCkge1xuICAgICAgdmFyIHllYXIgICA9IHRpbWVnbXRbMF07XG4gICAgICB2YXIgbW9udGggID0gdGltZWdtdFsxXTtcbiAgICAgIHZhciBkYXkgICAgPSB0aW1lZ210WzJdO1xuICAgICAgdmFyIGhvdXIgICA9IHRpbWVnbXRbM107XG4gICAgICB2YXIgbWludXRlID0gdGltZWdtdFs0XTtcbiAgICAgIHZhciBzZWNvbmQgPSB0aW1lZ210WzVdO1xuXG4gICAgICBpZihtb250aCA8IDEgfHwgbW9udGggPiAxMikge1xuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbE1vbnRoRXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgaWYoZGF5IDwgMSB8fCBkYXkgPiAoX0RBWVNfSU5fTU9OVEhbbW9udGhdICsgKG1vbnRoID09PSAyICYmIGlzbGVhcCh5ZWFyKSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBJbGxlZ2FsRGF5RXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgaWYoaG91ciA8IDAgfHwgaG91ciA+IDIzIHx8IG1pbnV0ZSA8IDAgfHwgbWludXRlID4gNTkgfHwgc2Vjb25kIDwgMCB8fCBzZWNvbmQgPiA1OSkge1xuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbFRpbWVFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF5cyA9IF90b29yZGluYWwoeWVhciwgbW9udGgsIDEpIC0gNzE5MTYzICsgZGF5IC0gMTtcbiAgICAgIHZhciBob3VycyA9IChkYXlzICogMjQpICsgaG91cjtcbiAgICAgIHZhciBtaW51dGVzID0gKGhvdXJzICogNjApICsgbWludXRlO1xuICAgICAgdmFyIHNlY29uZHMgPSAobWludXRlcyAqIDYwKSArIHNlY29uZDtcblxuICAgICAgcmV0dXJuIHNlY29uZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHdlZWtkYXkgKDAtNiB+IE1vbi1TdW4pIGZvciB5ZWFyICgxOTcwLS4uLiksIG1vbnRoICgxLTEyKSxcbiAgICAgKiBkYXkgKDEtMzEpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbW9udGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF5XG4gICAgICogQHRocm93cyB7SWxsZWdhbE1vbnRoRXJyb3J9IElmIHRoZSBwcm92aWRlZCBtb250aCBlbGVtZW50IGlzIGludmFsaWQuXG4gICAgICogQHRocm93cyB7SWxsZWdhbERheUVycm9yfSBJZiB0aGUgcHJvdmlkZWQgZGF5IGVsZW1lbnQgaXMgaW52YWxpZC5cbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdlZWtkYXkoeWVhciwgbW9udGgsIGRheSkge1xuICAgICAgaWYobW9udGggPCAxIHx8IG1vbnRoID4gMTIpIHtcbiAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxNb250aEVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIGlmKGRheSA8IDEgfHwgZGF5ID4gKF9EQVlTX0lOX01PTlRIW21vbnRoXSArIChtb250aCA9PT0gMiAmJiBpc2xlYXAoeWVhcikpKSkge1xuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbERheUVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXkpO1xuICAgICAgcmV0dXJuIF9hZGp1c3RXZWVrZGF5KGRhdGUuZ2V0RGF5KCkpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEJhc2UgY2FsZW5kYXIgY2xhc3MuIFRoaXMgY2xhc3MgZG9lc24ndCBkbyBhbnkgZm9ybWF0dGluZy4gSXQgc2ltcGx5XG4gICAgICogcHJvdmlkZXMgZGF0YSB0byBzdWJjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZpcnN0d2Vla2RheVxuICAgICAqIEB0aHJvd3Mge0lsbGVnYWxXZWVrZGF5RXJyb3J9IElmIHRoZSBwcm92aWRlZCBmaXJzdHdlZWtkYXkgaXMgaW52YWxpZC5cbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENhbGVuZGFyKGZpcnN0d2Vla2RheSkge1xuICAgICAgdGhpcy5fZmlyc3R3ZWVrZGF5ID0gdHlwZW9mKGZpcnN0d2Vla2RheSkgPT09IFwidW5kZWZpbmVkXCIgPyAwIDogZmlyc3R3ZWVrZGF5O1xuXG4gICAgICBpZihmaXJzdHdlZWtkYXkgPCAwIHx8IGZpcnN0d2Vla2RheSA+IDYpIHtcbiAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxXZWVrZGF5RXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fb25lZGF5ID0gMTAwMCAqIDYwICogNjAgKiAyNDtcbiAgICAgIHRoaXMuX29uZWhvdXIgPSAxMDAwICogNjAgKiA2MDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR0VULWVyIGZvciBmaXJzdHdlZWtkYXlcbiAgICAgKlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldGZpcnN0d2Vla2RheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0d2Vla2RheTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU0VULWVyIGZvciBmaXJzdHdlZWtkYXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmaXJzdHdlZWtkYXlcbiAgICAgKiBAdGhyb3dzIHtJbGxlZ2FsV2Vla2RheUVycm9yfSBJZiB0aGUgcHJvdmlkZWQgZmlyc3R3ZWVrZGF5IGlzIGludmFsaWQuXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBDYWxlbmRhci5wcm90b3R5cGUuc2V0Zmlyc3R3ZWVrZGF5ID0gZnVuY3Rpb24oZmlyc3R3ZWVrZGF5KSB7XG4gICAgICBpZihmaXJzdHdlZWtkYXkgPCAwIHx8IGZpcnN0d2Vla2RheSA+IDYpIHtcbiAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxXZWVrZGF5RXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZmlyc3R3ZWVrZGF5ID0gZmlyc3R3ZWVrZGF5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgZm9yIG9uZSB3ZWVrIG9mIHdlZWtkYXkgbnVtYmVycyBzdGFydGluZyB3aXRoIHRoZVxuICAgICAqIGNvbmZpZ3VyZWQgZmlyc3Qgb25lLlxuICAgICAqXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaXRlcndlZWtkYXlzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgd2Vla2RheXMgPSBbXTtcbiAgICAgIGZvcih2YXIgaSA9IHRoaXMuX2ZpcnN0d2Vla2RheTsgaSA8IHRoaXMuX2ZpcnN0d2Vla2RheSArIDc7IGkrKykge1xuICAgICAgICB3ZWVrZGF5cy5wdXNoKGkgJSA3KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdlZWtkYXlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgZm9yIG9uZSBtb250aC4gVGhlIGFycmF5IHdpbGwgY29udGFpbiBEYXRlXG4gICAgICogdmFsdWVzIGFuZCB3aWxsIGFsd2F5cyBpdGVyYXRlIHRocm91Z2ggY29tcGxldGUgd2Vla3MsIHNvIGl0IHdpbGwgeWllbGRcbiAgICAgKiBkYXRlcyBvdXRzaWRlIHRoZSBzcGVjaWZpZWQgbW9udGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geWVhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtb250aFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaXRlcm1vbnRoZGF0ZXMgPSBmdW5jdGlvbih5ZWFyLCBtb250aCkge1xuICAgICAgaWYobW9udGggPCAxIHx8IG1vbnRoID4gMTIpIHtcbiAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxNb250aEVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCAxKTtcbiAgICAgIHZhciBkYXkgPSBfYWRqdXN0V2Vla2RheShkYXRlLmdldERheSgpKTtcbiAgICAgIHZhciBkYXlzID0gKGRheSAtIHRoaXMuX2ZpcnN0d2Vla2RheSkgID49IDAgPyAoZGF5IC0gdGhpcy5fZmlyc3R3ZWVrZGF5KSAlIDcgOiA3ICsgKGRheSAtIHRoaXMuX2ZpcnN0d2Vla2RheSk7XG5cbiAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSAtIChkYXlzICogdGhpcy5fb25lZGF5KSk7XG5cbiAgICAgIHZhciBkYXRlcyA9IFtdO1xuICAgICAgd2hpbGUodHJ1ZSkge1xuICAgICAgICBkYXRlcy5wdXNoKG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKSk7XG5cbiAgICAgICAgdmFyIGN1cnJlbnREYXRlID0gZGF0ZS5nZXREYXRlKCk7XG4gICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIHRoaXMuX29uZWRheSk7XG5cbiAgICAgICAgLy8gSGFjayB0byBhY2NvdW50IGZvciBEU1RcbiAgICAgICAgd2hpbGUoZGF0ZS5nZXREYXRlKCkgPT09IGN1cnJlbnREYXRlKSB7XG4gICAgICAgICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgdGhpcy5fb25laG91cik7XG4gICAgICAgIH1cblxuICAgICAgICBpZihkYXRlLmdldE1vbnRoKCkgIT09IG1vbnRoIC0gMSAmJiBfYWRqdXN0V2Vla2RheShkYXRlLmdldERheSgpKSA9PT0gdGhpcy5fZmlyc3R3ZWVrZGF5KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTGlrZSBpdGVybW9udGhkYXRlcygpLCBidXQgd2lsbCB5aWVsZCBkYXkgbnVtYmVycy4gRm9yIGRheXMgb3V0c2lkZVxuICAgICAqIHRoZSBzcGVjaWZpZWQgbW9udGggdGhlIGRheSBudW1iZXIgaXMgMC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1vbnRoXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaXRlcm1vbnRoZGF5cyA9IGZ1bmN0aW9uKHllYXIsIG1vbnRoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pdGVybW9udGhkYXRlcyh5ZWFyLCBtb250aCkubWFwKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmdldE1vbnRoKCkgPT09IG1vbnRoIC0gMSA/IHZhbHVlLmdldERhdGUoKSA6IDA7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTGlrZSBpdGVybW9udGhkYXRlcygpLCBidXQgd2lsbCB5aWVsZCBbZGF5IG51bWJlciwgd2Vla2RheSBudW1iZXJdXG4gICAgICogYXJyYXlzLiBGb3IgZGF5cyBvdXRzaWRlIHRoZSBzcGVjaWZpZWQgbW9udGggdGhlIGRheSBudW1iZXIgaXMgMC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1vbnRoXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaXRlcm1vbnRoZGF5czIgPSBmdW5jdGlvbih5ZWFyLCBtb250aCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXRlcm1vbnRoZGF0ZXMoeWVhciwgbW9udGgpLm1hcChmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgIHJldHVybiB2YWx1ZS5nZXRNb250aCgpID09PSBtb250aCAtIDEgPyBbdmFsdWUuZ2V0RGF0ZSgpLCBfYWRqdXN0V2Vla2RheSh2YWx1ZS5nZXREYXkoKSldIDogWzAsIF9hZGp1c3RXZWVrZGF5KHZhbHVlLmdldERheSgpKV07XG4gICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbWF0cml4IChhcnJheSBvZiBhcnJheSkgcmVwcmVzZW50aW5nIGEgbW9udGgncyBjYWxlbmRhci5cbiAgICAgKiBFYWNoIHJvdyByZXByZXNlbnRzIGEgd2Vlazsgd2VlayBlbnRyaWVzIGFyZSBEYXRlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1vbnRoXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBDYWxlbmRhci5wcm90b3R5cGUubW9udGhkYXRlc2NhbGVuZGFyID0gZnVuY3Rpb24oeWVhciwgbW9udGgpIHtcbiAgICAgIHZhciBkYXlzID0gW107XG4gICAgICBkYXRlcyA9IHRoaXMuaXRlcm1vbnRoZGF0ZXMoeWVhciwgbW9udGgpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGRhdGVzLmxlbmd0aDsgaSArPSA3KSB7XG4gICAgICAgIGRheXMucHVzaChkYXRlcy5zbGljZShpLCBpICsgNykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF5cztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbWF0cml4IHJlcHJlc2VudGluZyBhIG1vbnRoJ3MgY2FsZW5kYXIuXG4gICAgICogRWFjaCByb3cgcmVwcmVzZW50cyBhIHdlZWs7IGRheXMgb3V0c2lkZSB0aGlzIG1vbnRoIGFyZSB6ZXJvLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbW9udGhcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5tb250aGRheXNjYWxlbmRhciA9IGZ1bmN0aW9uKHllYXIsIG1vbnRoKSB7XG4gICAgICB2YXIgZGF5cyA9IFtdO1xuICAgICAgZGF0ZXMgPSB0aGlzLml0ZXJtb250aGRheXMoeWVhciwgbW9udGgpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGRhdGVzLmxlbmd0aDsgaSArPSA3KSB7XG4gICAgICAgIGRheXMucHVzaChkYXRlcy5zbGljZShpLCBpICsgNykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF5cztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbWF0cml4IHJlcHJlc2VudGluZyBhIG1vbnRoJ3MgY2FsZW5kYXIuXG4gICAgICogRWFjaCByb3cgcmVwcmVzZW50cyBhIHdlZWs7IHdlZWsgZW50cmllcyBhcmVcbiAgICAgKiBbZGF5IG51bWJlciwgd2Vla2RheSBudW1iZXJdIGFycmF5cy4gRGF5IG51bWJlcnMgb3V0c2lkZSB0aGlzIG1vbnRoXG4gICAgICogYXJlIHplcm8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geWVhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtb250aFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm1vbnRoZGF5czJjYWxlbmRhciA9IGZ1bmN0aW9uKHllYXIsIG1vbnRoKSB7XG4gICAgICB2YXIgZGF5cyA9IFtdO1xuICAgICAgZGF0ZXMgPSB0aGlzLml0ZXJtb250aGRheXMyKHllYXIsIG1vbnRoKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkYXRlcy5sZW5ndGg7IGkgKz0gNykge1xuICAgICAgICBkYXlzLnB1c2goZGF0ZXMuc2xpY2UoaSwgaSArIDcpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRheXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCB5ZWFyIHJlYWR5IGZvciBmb3JtYXR0aW5nLiBUaGUgcmV0dXJuXG4gICAgICogdmFsdWUgaXMgYW4gYXJyYXkgb2YgbW9udGggcm93cy4gRWFjaCBtb250aCByb3cgY29udGFpbnMgdXAgdG8gd2lkdGggbW9udGhzLlxuICAgICAqIEVhY2ggbW9udGggY29udGFpbnMgYmV0d2VlbiA0IGFuZCA2IHdlZWtzIGFuZCBlYWNoIHdlZWsgY29udGFpbnMgMS03XG4gICAgICogZGF5cy4gRGF5cyBhcmUgRGF0ZSBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS55ZWFyZGF0ZXNjYWxlbmRhciA9IGZ1bmN0aW9uKHllYXIsIHdpZHRoKSB7XG4gICAgICB3aWR0aCA9IHR5cGVvZih3aWR0aCkgPT09IFwidW5kZWZpbmVkXCIgPyAzIDogd2lkdGg7XG5cbiAgICAgIHZhciBtb250aHMgPSBbXTtcbiAgICAgIGZvcih2YXIgbW9udGggPSAxOyBtb250aCA8PSAxMjsgbW9udGgrKykge1xuICAgICAgICBtb250aHMucHVzaCh0aGlzLm1vbnRoZGF0ZXNjYWxlbmRhcih5ZWFyLCBtb250aCkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcm93cyA9IFtdO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1vbnRocy5sZW5ndGg7IGkgKz0gd2lkdGgpIHtcbiAgICAgICAgcm93cy5wdXNoKG1vbnRocy5zbGljZShpLCBpICsgd2lkdGgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3dzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRhdGEgZm9yIHRoZSBzcGVjaWZpZWQgeWVhciByZWFkeSBmb3IgZm9ybWF0dGluZyAoc2ltaWxhciB0b1xuICAgICAqIHllYXJkYXRlc2NhbGVuZGFyKCkpLiBFbnRyaWVzIGluIHRoZSB3ZWVrIGFycmF5cyBhcmUgZGF5IG51bWJlcnMuXG4gICAgICogRGF5IG51bWJlcnMgb3V0c2lkZSB0aGlzIG1vbnRoIGFyZSB6ZXJvLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS55ZWFyZGF5c2NhbGVuZGFyID0gZnVuY3Rpb24oeWVhciwgd2lkdGgpIHtcbiAgICAgIHdpZHRoID0gdHlwZW9mKHdpZHRoKSA9PT0gXCJ1bmRlZmluZWRcIiA/IDMgOiB3aWR0aDtcblxuICAgICAgdmFyIG1vbnRocyA9IFtdO1xuICAgICAgZm9yKHZhciBtb250aCA9IDE7IG1vbnRoIDw9IDEyOyBtb250aCsrKSB7XG4gICAgICAgIG1vbnRocy5wdXNoKHRoaXMubW9udGhkYXlzY2FsZW5kYXIoeWVhciwgbW9udGgpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJvd3MgPSBbXTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtb250aHMubGVuZ3RoOyBpICs9IHdpZHRoKSB7XG4gICAgICAgIHJvd3MucHVzaChtb250aHMuc2xpY2UoaSwgaSArIHdpZHRoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm93cztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkYXRhIGZvciB0aGUgc3BlY2lmaWVkIHllYXIgcmVhZHkgZm9yIGZvcm1hdHRpbmcgKHNpbWlsYXIgdG9cbiAgICAgKiB5ZWFyZGF0ZXNjYWxlbmRhcigpKS4gRW50cmllcyBpbiB0aGUgd2VlayBhcnJheXMgYXJlXG4gICAgICogW2RheSBudW1iZXIsIHdlZWtkYXkgbnVtYmVyXSBhcnJheXMuIERheSBudW1iZXJzIG91dHNpZGUgdGhpcyBtb250aCBhcmVcbiAgICAgKiB6ZXJvLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS55ZWFyZGF5czJjYWxlbmRhciA9IGZ1bmN0aW9uKHllYXIsIHdpZHRoKSB7XG4gICAgICB3aWR0aCA9IHR5cGVvZih3aWR0aCkgPT09IFwidW5kZWZpbmVkXCIgPyAzIDogd2lkdGg7XG5cbiAgICAgIHZhciBtb250aHMgPSBbXTtcbiAgICAgIGZvcih2YXIgbW9udGggPSAxOyBtb250aCA8PSAxMjsgbW9udGgrKykge1xuICAgICAgICBtb250aHMucHVzaCh0aGlzLm1vbnRoZGF5czJjYWxlbmRhcih5ZWFyLCBtb250aCkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcm93cyA9IFtdO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1vbnRocy5sZW5ndGg7IGkgKz0gd2lkdGgpIHtcbiAgICAgICAgcm93cy5wdXNoKG1vbnRocy5zbGljZShpLCBpICsgd2lkdGgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3dzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBpbmRpY2F0aW5nIGEgbm9uZXhpc3RlbnQgb3IgdW5zdXBwb3J0ZWQgbG9jYWxlIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbGxlZ2FsTG9jYWxlRXJyb3IobWVzc2FnZSkge1xuICAgICAgdGhpcy5uYW1lID0gXCJJbGxlZ2FsTG9jYWxlRXJyb3JcIjtcbiAgICAgIHRoaXMubWVzc2FnZSA9IHR5cGVvZihtZXNzYWdlKSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwiSW52YWxpZCBsb2NhbGUgc3BlY2lmaWVkLlwiIDogbWVzc2FnZTtcbiAgICB9O1xuICAgIElsbGVnYWxMb2NhbGVFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgICBJbGxlZ2FsTG9jYWxlRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSWxsZWdhbExvY2FsZUVycm9yO1xuXG4gICAgLyoqXG4gICAgICogRXJyb3IgaW5kaWNhdGluZyBhIGRheSBpbmRleCBzcGVjaWZpZWQgb3V0c2lkZSBvZiB0aGUgdmFsaWQgcmFuZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgZnVuY3Rpb24gSWxsZWdhbERheUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgIHRoaXMubmFtZSA9IFwiSWxsZWdhbERheUVycm9yXCI7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSB0eXBlb2YobWVzc2FnZSkgPT09IFwidW5kZWZpbmVkXCIgPyBcIkludmFsaWQgZGF5IHNwZWNpZmllZC5cIiA6IG1lc3NhZ2U7XG4gICAgfTtcbiAgICBJbGxlZ2FsRGF5RXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gICAgSWxsZWdhbERheUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IElsbGVnYWxEYXlFcnJvcjtcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGluZGljYXRpbmcgYSBtb250aCBpbmRleCBzcGVjaWZpZWQgb3V0c2lkZSBvZiB0aGUgZXhwZWN0ZWQgcmFuZ2UgKDEtMTIgfiBKYW4tRGVjKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbGxlZ2FsTW9udGhFcnJvcihtZXNzYWdlKSB7XG4gICAgICB0aGlzLm5hbWUgPSBcIklsbGVnYWxNb250aEVycm9yXCI7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSB0eXBlb2YobWVzc2FnZSkgPT09IFwidW5kZWZpbmVkXCIgPyBcIkludmFsaWQgbW9udGggc3BlY2lmaWVkLlwiIDogbWVzc2FnZTtcbiAgICB9O1xuICAgIElsbGVnYWxNb250aEVycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICAgIElsbGVnYWxNb250aEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IElsbGVnYWxNb250aEVycm9yO1xuXG4gICAgLyoqXG4gICAgICogRXJyb3IgaW5kaWNhdGluZyBhIHRpbWUgZWxlbWVudCBpcyBvdXRzaWRlIG9mIHRoZSB2YWxpZCByYW5nZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbGxlZ2FsVGltZUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgIHRoaXMubmFtZSA9IFwiSWxsZWdhbFRpbWVFcnJvclwiO1xuICAgICAgdGhpcy5tZXNzYWdlID0gdHlwZW9mKG1lc3NhZ2UpID09PSBcInVuZGVmaW5lZFwiID8gXCJJbnZhbGlkIHRpbWUgZWxlbWVudCBzcGVjaWZpZWQuXCIgOiBtZXNzYWdlO1xuICAgIH07XG4gICAgSWxsZWdhbFRpbWVFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgICBJbGxlZ2FsVGltZUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IElsbGVnYWxUaW1lRXJyb3I7XG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBpbmRpY2F0aW5nIGEgd2Vla2RheSBpbmRleCBzcGVjaWZpZWQgb3V0c2lkZSBvZiB0aGUgZXhwZWN0ZWQgcmFuZ2UgKDAtNiB+IE1vbi1TdW4pLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIElsbGVnYWxXZWVrZGF5RXJyb3IobWVzc2FnZSkge1xuICAgICAgdGhpcy5uYW1lID0gXCJJbGxlZ2FsV2Vla2RheUVycm9yXCI7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSB0eXBlb2YobWVzc2FnZSkgPT09IFwidW5kZWZpbmVkXCIgPyBcIkludmFsaWQgd2Vla2RheSBzcGVjaWZpZWQuXCIgOiBtZXNzYWdlO1xuICAgIH07XG4gICAgSWxsZWdhbFdlZWtkYXlFcnJvciAucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gICAgSWxsZWdhbFdlZWtkYXlFcnJvciAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSWxsZWdhbFdlZWtkYXlFcnJvciA7XG5cbiAgICAvLyBleHBvcnQgb2YgcGFja2FnZS1saWtlIG9iamVjdCB3aXRoIGV4cGxpY2l0IHB1YmxpYyBBUElcbiAgICB2YXIgY2FsZW5kYXIgPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgY2FsZW5kYXIuaXNsZWFwICAgICA9IGlzbGVhcDtcbiAgICBjYWxlbmRhci5sZWFwZGF5cyAgID0gbGVhcGRheXM7XG4gICAgY2FsZW5kYXIubW9udGhyYW5nZSA9IG1vbnRocmFuZ2U7XG4gICAgY2FsZW5kYXIud2Vla2RheSAgICA9IHdlZWtkYXk7XG4gICAgY2FsZW5kYXIuc2V0bG9jYWxlICA9IHNldGxvY2FsZTtcbiAgICBjYWxlbmRhci50aW1lZ20gICAgID0gdGltZWdtO1xuICAgIGNhbGVuZGFyLkNhbGVuZGFyICAgPSBDYWxlbmRhcjtcblxuICAgIGNhbGVuZGFyLklsbGVnYWxMb2NhbGVFcnJvciAgPSBJbGxlZ2FsTG9jYWxlRXJyb3I7XG4gICAgY2FsZW5kYXIuSWxsZWdhbERheUVycm9yICAgICA9IElsbGVnYWxEYXlFcnJvcjtcbiAgICBjYWxlbmRhci5JbGxlZ2FsTW9udGhFcnJvciAgID0gSWxsZWdhbE1vbnRoRXJyb3I7XG4gICAgY2FsZW5kYXIuSWxsZWdhbFRpbWVFcnJvciAgICA9IElsbGVnYWxUaW1lRXJyb3I7XG4gICAgY2FsZW5kYXIuSWxsZWdhbFdlZWtkYXlFcnJvciA9IElsbGVnYWxXZWVrZGF5RXJyb3I7XG5cbiAgICBjYWxlbmRhci5NT05EQVkgICAgID0gMDtcbiAgICBjYWxlbmRhci5UVUVTREFZICAgID0gMTtcbiAgICBjYWxlbmRhci5XRURORVNEQVkgID0gMjtcbiAgICBjYWxlbmRhci5USFVSU0RBWSAgID0gMztcbiAgICBjYWxlbmRhci5GUklEQVkgICAgID0gNDtcbiAgICBjYWxlbmRhci5TQVRVUkRBWSAgID0gNTtcbiAgICBjYWxlbmRhci5TVU5EQVkgICAgID0gNjtcblxuICAgIGNhbGVuZGFyLkpBTlVBUlkgICAgPSAgMTtcbiAgICBjYWxlbmRhci5GRUJSVUFSWSAgID0gIDI7XG4gICAgY2FsZW5kYXIuTUFSQ0ggICAgICA9ICAzO1xuICAgIGNhbGVuZGFyLkFQUklMICAgICAgPSAgNDtcbiAgICBjYWxlbmRhci5NQVkgICAgICAgID0gIDU7XG4gICAgY2FsZW5kYXIuSlVORSAgICAgICA9ICA2O1xuICAgIGNhbGVuZGFyLkpVTFkgICAgICAgPSAgNztcbiAgICBjYWxlbmRhci5BVUdVU1QgICAgID0gIDg7XG4gICAgY2FsZW5kYXIuU0VQVEVNQkVSICA9ICA5O1xuICAgIGNhbGVuZGFyLk9DVE9CRVIgICAgPSAxMDtcbiAgICBjYWxlbmRhci5OT1ZFTUJFUiAgID0gMTE7XG4gICAgY2FsZW5kYXIuREVDRU1CRVIgICA9IDEyO1xuXG4gICAgY2FsZW5kYXIuc2V0bG9jYWxlKCk7XG5cbiAgICAvLyBJbml0aWFsaXphdGlvbiBtZXRob2RvbG9neSBhbmQgbm9Db25mbGljdCBjb3VydGVzeSBub2RlLXV1aWQ6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWRcblxuICAgIHZhciBfZ2xvYmFsID0gdGhpcztcblxuICAgIC8vIFB1Ymxpc2ggYXMgbm9kZS5qcyBtb2R1bGVcbiAgICBpZiAodHlwZW9mKG1vZHVsZSkgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gY2FsZW5kYXI7XG4gICAgfVxuXG4gICAgLy8gUHVibGlzaCBhcyBnbG9iYWwgKGluIGJyb3dzZXJzKVxuICAgIGVsc2Uge1xuICAgICAgdmFyIF9wcmV2aW91c1Jvb3QgPSBfZ2xvYmFsLmNhbGVuZGFyO1xuXG4gICAgICAvKipcbiAgICAgICAgKiBSZXNldCBnbG9iYWwgJ2NhbGVuZGFyJyB2YXJpYWJsZVxuICAgICAgICAqXG4gICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAgKi9cbiAgICAgIGNhbGVuZGFyLm5vY29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgX2dsb2JhbC5jYWxlbmRhciA9IF9wcmV2aW91c1Jvb3Q7XG4gICAgICAgIHJldHVybiBjYWxlbmRhcjtcbiAgICAgIH07XG5cbiAgICAgIF9nbG9iYWwuY2FsZW5kYXIgPSBjYWxlbmRhcjtcbiAgICB9XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgT2JqZWN0LmFzc2lnblxuICovXG5cbi8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1vYmplY3QuYXNzaWduXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlcykge1xuICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIHRhcmdldCBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgfVxuXG4gIHZhciB0byA9IE9iamVjdCh0YXJnZXQpO1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIGZvciAodmFyIG5leHRJbmRleCA9IDE7IG5leHRJbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IG5leHRJbmRleCsrKSB7XG4gICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbbmV4dEluZGV4XTtcbiAgICBpZiAobmV4dFNvdXJjZSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgZnJvbSA9IE9iamVjdChuZXh0U291cmNlKTtcblxuICAgIC8vIFdlIGRvbid0IGN1cnJlbnRseSBzdXBwb3J0IGFjY2Vzc29ycyBub3IgcHJveGllcy4gVGhlcmVmb3JlIHRoaXNcbiAgICAvLyBjb3B5IGNhbm5vdCB0aHJvdy4gSWYgd2UgZXZlciBzdXBwb3J0ZWQgdGhpcyB0aGVuIHdlIG11c3QgaGFuZGxlXG4gICAgLy8gZXhjZXB0aW9ucyBhbmQgc2lkZS1lZmZlY3RzLiBXZSBkb24ndCBzdXBwb3J0IHN5bWJvbHMgc28gdGhleSB3b24ndFxuICAgIC8vIGJlIHRyYW5zZmVycmVkLlxuXG4gICAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcbiAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduO1xuIiwidmFyIEFwcERpc3BhdGNoZXIgPSByZXF1aXJlKCcuL0Rpc3BhdGNoZXIuanMnKTtcbnZhciBhcHBDb25zdGFudHMgPSByZXF1aXJlKCcuL0NvbnN0YW50cy5qcycpO1xuXG52YXIgcGxhbm5lckFjdGlvbnMgPSB7XG4gIG5ld01vbnRoOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIEFwcERpc3BhdGNoZXIuaGFuZGxlVmlld0FjdGlvbih7XG4gICAgICBhY3Rpb25UeXBlOiBhcHBDb25zdGFudHMuTkVXX01PTlRILFxuICAgICAgZGF0YTogZGF0ZVxuICAgIH0pO1xuICB9LFxuICBmaW5kTW9udGg6IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICBBcHBEaXNwYXRjaGVyLmhhbmRsZVZpZXdBY3Rpb24oe1xuICAgICAgYWN0aW9uVHlwZTogYXBwQ29uc3RhbnRzLkZJTkRfTU9OVEgsXG4gICAgICBkYXRhOiBkaXJlY3Rpb25cbiAgICB9KTtcbiAgfSxcbiAgc2VsZWN0ZWREYXk6IGZ1bmN0aW9uIChkYXlOdW0pIHtcbiAgICBBcHBEaXNwYXRjaGVyLmhhbmRsZVZpZXdBY3Rpb24oe1xuICAgICAgYWN0aW9uVHlwZTogYXBwQ29uc3RhbnRzLlNFTEVDVEVEX0RBWSxcbiAgICAgIGRhdGE6IGRheU51bVxuICAgIH0pO1xuICB9LFxuICBhZGRFdmVudHM6IGZ1bmN0aW9uIChldnQpIHtcbiAgICBBcHBEaXNwYXRjaGVyLmhhbmRsZVZpZXdBY3Rpb24oe1xuICAgICAgYWN0aW9uVHlwZTogYXBwQ29uc3RhbnRzLkFERF9FVkVOVFMsXG4gICAgICBkYXRhOiBldnRcbiAgICB9KTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwbGFubmVyQWN0aW9ucztcbiIsInZhciBhcHBDb25zdGFudHMgPSB7XG4gIE5FV19NT05USDogJ05FV19NT05USCcsXG4gIEZJTkRfTU9OVEg6ICdGSU5EX01PTlRIJyxcbiAgU0VMRUNURURfREFZOiAnU0VMRUNURURfREFZJyxcbiAgQUREX0VWRU5UUzogJ0FERF9FVkVOVFMnXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcENvbnN0YW50cztcbiIsInZhciBEaXNwYXRjaGVyID0gcmVxdWlyZSgnZmx1eCcpLkRpc3BhdGNoZXI7XG52YXIgQXBwRGlzcGF0Y2hlciA9IG5ldyBEaXNwYXRjaGVyKCk7XG5cbkFwcERpc3BhdGNoZXIuaGFuZGxlVmlld0FjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbikge1xuICB0aGlzLmRpc3BhdGNoKHtcbiAgICBzb3VyY2U6ICdWSUVXX0FDVElPTicsXG4gICAgYWN0aW9uOiBhY3Rpb25cbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXBwRGlzcGF0Y2hlcjtcbiIsInZhciBtb250aENvbnZlcnNpb24gPSB7XG4gIEphbiA6IFsxLCAnSmFudWFyeSddLFxuICBGZWIgOiBbMiwgJ0ZlYnJ1YXJ5J10sXG4gIE1hciA6IFszLCAnTWFyY2gnXSxcbiAgQXByIDogWzQsICdBcHJpbCddLFxuICBNYXkgOiBbNSwgJ01hcmNoJ10sXG4gIEp1biA6IFs2LCAnSnVuZSddLFxuICBKdWwgOiBbNywgJ0p1bHknXSxcbiAgQXVnIDogWzgsICdBdWd1c3QnXSxcbiAgU2VwIDogWzksICdTZXB0ZW1iZXInXSxcbiAgT2N0IDogWzEwLCAnT2N0b2JlciddLFxuICBOb3YgOiBbMTEsICdOb3ZlbWJlciddLFxuICBEZWMgOiBbMTIsICdEZWNlbWJlciddLFxuICAxIDogJ0phbicsXG4gIDIgOiAnRmViJyxcbiAgMyA6ICdNYXInLFxuICA0IDogJ0FwcicsXG4gIDUgOiAnTWF5JyxcbiAgNiA6ICdKdW4nLFxuICA3IDogJ0p1bCcsXG4gIDggOiAnQXVnJyxcbiAgOSA6ICdTZXAnLFxuICAxMCA6ICdPY3QnLFxuICAxMSA6ICdOb3YnLFxuICAxMiA6ICdEZWMnXG59XG5cbnZhciBtb250aEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1vbiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ21vbnRoR3JpZCcpWzBdLmNsYXNzTGlzdDtcbiAgbW9uLmFkZCgnYW5pbWF0ZWQnLCAnem9vbUluJyk7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgbW9uLnJlbW92ZSgnYW5pbWF0ZWQnLCAnem9vbUluJykgfSwgMTAwMCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtb250aENvbnZlcnNpb246IG1vbnRoQ29udmVyc2lvbixcbiAgbW9udGhBbmltYXRpb246IG1vbnRoQW5pbWF0aW9uXG59XG4iLCJ2YXIgRGF5ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdj5cbiAgICAgICAge1xuICAgICAgICAgdGhpcy5wcm9wcy5jdXJyZW50TW9udGguaXRlbXMuZXZlbnRzW3BhcnNlSW50KHRoaXMucHJvcHMuZGF5KV1cbiAgICAgICAgID8gdGhpcy5wcm9wcy5jdXJyZW50TW9udGguaXRlbXMuZXZlbnRzW3BhcnNlSW50KHRoaXMucHJvcHMuZGF5KV0ubWFwKGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgIHJldHVybiA8cD57ZXZ0LnRpbWUuc3RhcnQgK1wiIC0gXCIrIGV2dC50aW1lLmVuZCArJyA6ICcrIGV2dC50aXRsZX08L3A+XG4gICAgICAgICAgIH0pXG4gICAgICAgICA6IG51bGxcbiAgICAgICAgfVxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IERheTtcbiIsInZhciBEYXkgPSByZXF1aXJlKCcuL0RheS5qc3gnKTtcblxudmFyIE1vbnRoID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgcmV0dXJuIChcbiAgICAgIDxzZWN0aW9uPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhbGVuZGFySGVhZGVyXCI+XG4gICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJidG4gYnRuLXByaW1hcnlcIiBvbkNsaWNrPXt0aGlzLnByb3BzLmhhbmRsZXJzLmRpc3BsYXlNb250aH0+QmFjazwvYnV0dG9uPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW9udGhOYW1lXCI+XG4gICAgICAgICAgICA8aDE+e3RoaXMucHJvcHMuY3VycmVudE1vbnRoLm5hbWV9PC9oMT5cbiAgICAgICAgICAgIDxoND57dGhpcy5wcm9wcy5jdXJyZW50TW9udGgueWVhcn08L2g0PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiYnRuIGJ0bi1wcmltYXJ5XCIgb25DbGljaz17dGhpcy5wcm9wcy5oYW5kbGVycy5kaXNwbGF5TW9udGh9PkZvcndhcmQ8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDx0YWJsZSBjbGFzc05hbWU9XCJtb250aEdyaWQgdGFibGUtYm9yZGVyZWRcIj5cbiAgICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgIDx0aD5TdW5kYXk8L3RoPiA8dGg+TW9uZGF5PC90aD4gPHRoPlR1ZXNkYXk8L3RoPiA8dGg+V2VkbmVzZGF5PC90aD4gPHRoPlRodXJzZGF5PC90aD4gPHRoPkZyaWRheTwvdGg+IDx0aD5TYXR1cmRheTwvdGg+XG4gICAgICAgICAgICA8L3RyPlxuICAgICAgICAgIDwvdGhlYWQ+XG4gICAgICAgICAgPHRib2R5PlxuICAgICAgICAgICAge3RoaXMucHJvcHMuY3VycmVudE1vbnRoLm1vbnRoTWF0cml4Lm1hcChmdW5jdGlvbih3ZWVrKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPHRyIGtleT17d2Vla30+XG4gICAgICAgICAgICAgICAgICB7d2Vlay5tYXAoZnVuY3Rpb24oZGF5LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXkgPT0gcGFyc2VJbnQodGhpcy5wcm9wcy5jdXJyZW50TW9udGguc2VsZWN0ZWREYXkpXG4gICAgICAgICAgICAgICAgICAgICAgPyA8dGQgY2xhc3NOYW1lPVwic2VsZWN0ZWREYXlcIiBrZXk9e2l9PjxEYXkgZGF5PXtkYXl9IGN1cnJlbnRNb250aD17dGhpcy5wcm9wcy5jdXJyZW50TW9udGh9IC8+PHNwYW4+e2RheX08L3NwYW4+PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgOiA8dGQgb25DbGljaz17dGhpcy5wcm9wcy5oYW5kbGVycy5zZWxlY3RlZERheX0ga2V5PXtpfT48RGF5IGRheT17ZGF5fSBjdXJyZW50TW9udGg9e3RoaXMucHJvcHMuY3VycmVudE1vbnRofSAvPjxzcGFuPntkYXl9PC9zcGFuPjwvdGQ+XG4gICAgICAgICAgICAgICAgICB9LHRoaXMpfVxuICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LHRoaXMpfVxuICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgIDwvdGFibGU+XG4gICAgICA8L3NlY3Rpb24+XG4gICAgKTtcbiAgfVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBNb250aDtcbiIsInZhciBNb250aCA9IHJlcXVpcmUoJy4vbW9udGguanN4Jyk7XG52YXIgU2VsZWN0ZWREYXkgPSByZXF1aXJlKCcuL3NlbGVjdGVkRGF5LmpzeCcpO1xudmFyIFRhc2tNYW5hZ2VyID0gcmVxdWlyZSgnLi90YXNrTWFuYWdlci5qc3gnKTtcbnZhciBwbGFubmVyU3RvcmUgPSByZXF1aXJlKCcuLi9zdG9yZXMvcGxhbm5lclN0b3JlLmpzJyk7XG52YXIgcGxhbm5lckFjdGlvbnMgPSByZXF1aXJlKCcuLi9BY3Rpb24uanMnKTtcbnZhciBtb250aEFuaW1hdGlvbiA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9jYWxlbmRhckNvbnZlcnNpb25zJykubW9udGhBbmltYXRpb247XG5cbnZhciBQbGFubmVyID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLnRvU3RyaW5nKCkuc3BsaXQoJyAnKTtcbiAgICBwbGFubmVyQWN0aW9ucy5uZXdNb250aChbbm93WzFdLCBub3dbM10sIG5vd1syXV0pO1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50TW9udGg6IHBsYW5uZXJTdG9yZS5nZXRDdXJyZW50TW9udGgoKSxcbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgcGxhbm5lclN0b3JlLmFkZENoYW5nZUxpc3RlbmVyKHRoaXMuX29uQ2hhbmdlKTtcbiAgfSxcbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBwbGFubmVyU3RvcmUucmVtb3ZlQ2hhbmdlTGlzdGVuZXIodGhpcy5fb25DaGFuZ2UpO1xuICB9LFxuICBoYW5kbGVyczoge1xuICAgIHNlbGVjdGVkRGF5OiAgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHBsYW5uZXJBY3Rpb25zLnNlbGVjdGVkRGF5KGUudGFyZ2V0LmNoaWxkTm9kZXNbMV0uaW5uZXJIVE1MKTtcbiAgICB9LFxuICAgIGRpc3BsYXlNb250aDogZnVuY3Rpb24gKGUpIHtcbiAgICAgIG1vbnRoQW5pbWF0aW9uKCk7XG4gICAgICBlLnRhcmdldC5pbm5lckhUTUwgPT0gJ0ZvcndhcmQnID8gcGxhbm5lckFjdGlvbnMuZmluZE1vbnRoKHRydWUpIDogcGxhbm5lckFjdGlvbnMuZmluZE1vbnRoKGZhbHNlKTtcbiAgICB9LFxuICAgIGFkZEV2ZW50czogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHBsYW5uZXJBY3Rpb25zLmFkZEV2ZW50cyhlKTtcbiAgICB9XG4gIH0sXG4gIF9vbkNoYW5nZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY3VycmVudE1vbnRoOiBwbGFubmVyU3RvcmUuZ2V0Q3VycmVudE1vbnRoKClcbiAgICB9KVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImFuaW1hdGVkIHpvb21JbiBjb250YWluZXItZmx1aWRcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3cgdGV4dC1jZW50ZXJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1tZC04XCI+XG4gICAgICAgICAgICA8TW9udGggY3VycmVudE1vbnRoPXt0aGlzLnN0YXRlLmN1cnJlbnRNb250aH0gaGFuZGxlcnM9e3RoaXMuaGFuZGxlcnN9IC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtbWQtNFwiPlxuICAgICAgICAgICAgPFRhc2tNYW5hZ2VyIGN1cnJlbnRNb250aD17dGhpcy5zdGF0ZS5jdXJyZW50TW9udGh9IGFkZEV2ZW50cz17dGhpcy5oYW5kbGVycy5hZGRFdmVudHN9IC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG59KTtcblxuXG5SZWFjdC5yZW5kZXIoPFBsYW5uZXIgLz4sIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhcHAnKSk7XG4iLCJ2YXIgU2VsZWN0ZWREYXkgPSBSZWFjdC5jcmVhdGVDbGFzcyAoe1xuICBoYW5kbGVTdWJtaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm9ybSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCduZXdFdmVudCcpO1xuICAgIHRoaXMucHJvcHMuYWRkRXZlbnRzKHtcbiAgICAgIGRheTogdGhpcy5wcm9wcy5jdXJyZW50TW9udGguc2VsZWN0ZWREYXksIHRpbWU6IHtzdGFydDogZm9ybVsxXS52YWx1ZSwgZW5kOiBmb3JtWzJdLnZhbHVlfSwgdGl0bGU6IGZvcm1bMF0udmFsdWUsIGRlc2NyaXB0aW9uOiBmb3JtWzNdLnZhbHVlXG4gICAgfSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JtLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3JtW2ldLnZhbHVlID0gbnVsbDtcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImFuaW1hdGVkIHpvb21JbiBzZWxlY3RlZERheUhlYWRlclwiPlxuICAgICAgICA8aDQ+QWRkIEV2ZW50PC9oND5cbiAgICAgICAgPGZvcm0+XG4gICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgcGxhY2Vob2xkZXI9XCJUaXRsZVwiIG5hbWU9XCJuZXdFdmVudFwiPjwvaW5wdXQ+XG4gICAgICAgICAgPGlucHV0IHR5cGU9XCJ0aW1lXCIgcGxhY2Vob2xkZXI9XCJTdGFydFwiIG5hbWU9XCJuZXdFdmVudFwiPjwvaW5wdXQ+XG4gICAgICAgICAgPGlucHV0IHR5cGU9XCJ0aW1lXCIgcGxhY2Vob2xkZXI9XCJFbmRcIiBuYW1lPVwibmV3RXZlbnRcIj48L2lucHV0PlxuICAgICAgICAgIDx0ZXh0YXJlYSBkZWZhdWx0VmFsdWU9XCJEZXNjcmlwdGlvblwiIG5hbWU9XCJuZXdFdmVudFwiPjwvdGV4dGFyZWE+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1wbHVzLXNpZ25cIiBvbkNsaWNrPXt0aGlzLmhhbmRsZVN1Ym1pdH0+PC9zcGFuPlxuICAgICAgICA8L2Zvcm0+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3RlZERheVxuIiwidmFyIFNlbGVjdGVkRGF5ID0gcmVxdWlyZSgnLi9zZWxlY3RlZERheS5qc3gnKVxuXG52YXIgVGFza01hbmFnZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGVUb2dnbGU6IHRydWUsXG4gICAgICBldmVudHNUb2dnbGU6IGZhbHNlLFxuICAgICAgdG9Eb1RvZ2dsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGhhbmRsZXJzOiB7XG4gICAgZGF0ZVRvZ2dsZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGRhdGVUb2dnbGU6IHRoaXMuc3RhdGUuZGF0ZVRvZ2dsZSA/IHRoaXMuc3RhdGUuZGF0ZVRvZ2dsZSA9IGZhbHNlIDogdGhpcy5zdGF0ZS5kYXRlVG9nZ2xlID0gdHJ1ZVxuICAgICAgfSlcbiAgICB9LFxuICAgIGV2ZW50c1RvZ2dsZTogZnVuY3Rpb24gKGUpIHtcblxuICAgIH0sXG4gICAgdG9Eb1RvZ2dsZTogZnVuY3Rpb24gKGUpIHtcblxuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxzZWN0aW9uPlxuICAgICAgICA8aDEgY2xhc3NOYW1lPVwidGFza0hlYWRlclwiPlRhc2sgTWFuYWdlcjwvaDE+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGFza0NvbnRhaW5lclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGFza1NlY3Rpb25cIj5cbiAgICAgICAgICAgIDxkaXYgb25DbGljaz17dGhpcy5oYW5kbGVycy5kYXRlVG9nZ2xlLmJpbmQodGhpcyl9PlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e1widGFza0ljb24gZ2x5cGhpY29uIGdseXBoaWNvbi10cmlhbmdsZS1cIiArICh0aGlzLnN0YXRlLmRhdGVUb2dnbGUgPyBcImJvdHRvbVwiIDogXCJyaWdodFwiKX0+PC9zcGFuPlxuICAgICAgICAgICAgICA8aDM+e3RoaXMucHJvcHMuY3VycmVudE1vbnRoLm5hbWUgK1wiIFwiKyB0aGlzLnByb3BzLmN1cnJlbnRNb250aC5zZWxlY3RlZERheSArXCIsIFwiKyB0aGlzLnByb3BzLmN1cnJlbnRNb250aC55ZWFyfTwvaDM+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIHt0aGlzLnN0YXRlLmRhdGVUb2dnbGUgPyA8U2VsZWN0ZWREYXkgY3VycmVudE1vbnRoPXt0aGlzLnByb3BzLmN1cnJlbnRNb250aH0gYWRkRXZlbnRzPXt0aGlzLnByb3BzLmFkZEV2ZW50c30gLz4gOiBudWxsfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGFza1NlY3Rpb25cIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRhc2tJY29uIGdseXBoaWNvbiBnbHlwaGljb24tdHJpYW5nbGUtcmlnaHRcIj48L3NwYW4+XG4gICAgICAgICAgICA8aDM+RXZlbnRzPC9oMz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRhc2tTZWN0aW9uXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0YXNrSWNvbiBnbHlwaGljb24gZ2x5cGhpY29uLXRyaWFuZ2xlLXJpZ2h0XCI+PC9zcGFuPlxuICAgICAgICAgICAgPGgzPlRvRG8nczwvaDM+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9zZWN0aW9uPlxuICAgIClcbiAgfVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBUYXNrTWFuYWdlcjtcbiIsInZhciBBcHBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vRGlzcGF0Y2hlci5qcycpO1xudmFyIGFwcENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL0NvbnN0YW50cy5qcycpO1xudmFyIG9iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9PYmplY3QuYXNzaWduJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGNhbGVuZGFyID0gcmVxdWlyZSgnbm9kZS1jYWxlbmRhcicpO1xudmFyIG1vbnRoQ29udmVyc2lvbiA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9jYWxlbmRhckNvbnZlcnNpb25zJykubW9udGhDb252ZXJzaW9uO1xuXG52YXIgQ0hBTkdFX0VWRU5UID0gJ2NoYW5nZSc7XG5cbnZhciB5ZWFycyA9IHt9O1xudmFyIGN1cnJlbnQgPSB7fTtcblxuZnVuY3Rpb24gTW9udGgoZGF0ZSkge1xuICB0aGlzLm5hbWUgPSBtb250aENvbnZlcnNpb25bZGF0ZVswXV1bMV07XG4gIHRoaXMubW9udGhLZXkgPSBtb250aENvbnZlcnNpb25bZGF0ZVswXV1bMF07XG4gIHRoaXMueWVhciA9IHBhcnNlSW50KGRhdGVbMV0pO1xuICB0aGlzLm1vbnRoTWF0cml4ID0gZGF0ZTtcbiAgdGhpcy5zZWxlY3RlZERheSA9IGRhdGVbMl0gfHwgMTtcbiAgdGhpcy5pdGVtcyA9IHtcbiAgICBldmVudHM6IHt9LFxuICAgIHRvZG9zOiB7fVxuICB9O1xufVxuXG5Nb250aC5wcm90b3R5cGUubmV3TW9udGggPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubW9udGhNYXRyaXggPSBuZXcgY2FsZW5kYXIuQ2FsZW5kYXIoY2FsZW5kYXIuU1VOREFZKS5tb250aGRheXNjYWxlbmRhcih0aGlzLm1vbnRoTWF0cml4WzFdLCBtb250aENvbnZlcnNpb25bdGhpcy5tb250aE1hdHJpeFswXV1bMF0pO1xufTtcblxudmFyIG5ld01vbnRoID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgY3VycmVudCA9IG5ldyBNb250aChkYXRlKTtcbiAgY3VycmVudC5uZXdNb250aCgpO1xuICB5ZWFyc1tjdXJyZW50LnllYXJdID8geWVhcnNbY3VycmVudC55ZWFyXS5wdXNoKGN1cnJlbnQpIDogeWVhcnNbY3VycmVudC55ZWFyXSA9IFtjdXJyZW50XTtcbn1cblxudmFyIGZpbmRNb250aCA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgaWYoZGlyZWN0aW9uKVxuICAgIGN1cnJlbnQubW9udGhLZXkgKzEgPCAxMyA/IG5ld0N1cnJlbnQgPSBbY3VycmVudC5tb250aEtleSArMSwgY3VycmVudC55ZWFyXSA6IG5ld0N1cnJlbnQgPSBbMSwgY3VycmVudC55ZWFyICsxXTtcbiAgZWxzZVxuICAgIGN1cnJlbnQubW9udGhLZXkgLTEgPiAwID8gbmV3Q3VycmVudCA9IFtjdXJyZW50Lm1vbnRoS2V5IC0xLCBjdXJyZW50LnllYXJdIDogbmV3Q3VycmVudCA9IFsxMiwgY3VycmVudC55ZWFyIC0xXTtcbiAgaWYoeWVhcnNbbmV3Q3VycmVudFsxXV0pe1xuICAgIHZhciBjaGVja2VyID0geWVhcnNbbmV3Q3VycmVudFsxXV0uZmlsdGVyKGZ1bmN0aW9uIChtb24pIHtcbiAgICAgIGlmKG1vbi5tb250aEtleSA9PT0gbmV3Q3VycmVudFswXSlcbiAgICAgICAgcmV0dXJuIG1vbjtcbiAgICB9KVxuICAgIGNoZWNrZXIubGVuZ3RoID4gMCA/IGN1cnJlbnQgPSBjaGVja2VyWzBdIDogbmV3TW9udGgoW21vbnRoQ29udmVyc2lvbltuZXdDdXJyZW50WzBdXSwgbmV3Q3VycmVudFsxXV0pO1xuICB9IGVsc2Uge1xuICAgIG5ld01vbnRoKFttb250aENvbnZlcnNpb25bbmV3Q3VycmVudFswXV0sIG5ld0N1cnJlbnRbMV1dKTtcbiAgfVxufVxuXG52YXIgc2VsZWN0ZWREYXkgPSBmdW5jdGlvbiAoZGF5TnVtKSB7XG4gIGN1cnJlbnQuc2VsZWN0ZWREYXkgPSBkYXlOdW07XG59XG5cbnZhciBhZGRFdmVudHMgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gIGN1cnJlbnQuaXRlbXMuZXZlbnRzW2V2dC5kYXldID8gY3VycmVudC5pdGVtcy5ldmVudHNbZXZ0LmRheV0ucHVzaChldnQpIDogY3VycmVudC5pdGVtcy5ldmVudHNbZXZ0LmRheV0gPSBbZXZ0XTtcbn1cblxudmFyIHBsYW5uZXJTdG9yZSA9IG9iamVjdEFzc2lnbih7fSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSwge1xuICBhZGRDaGFuZ2VMaXN0ZW5lcjogZnVuY3Rpb24gKGNiKSB7XG4gICAgdGhpcy5vbihDSEFOR0VfRVZFTlQsIGNiKTtcbiAgfSxcbiAgcmVtb3ZlQ2hhbmdlTGlzdGVuZXI6IGZ1bmN0aW9uIChjYikge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoQ0hBTkdFX0VWRU5ULCBjYik7XG4gIH0sXG4gIGdldEN1cnJlbnRNb250aDogZnVuY3Rpb24gKCkge1xuICAgIGNvbnNvbGUubG9nKHllYXJzLCBjdXJyZW50KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxufSk7XG5cbkFwcERpc3BhdGNoZXIucmVnaXN0ZXIoZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgdmFyIGFjdGlvbiA9IHBheWxvYWQuYWN0aW9uO1xuICBzd2l0Y2goYWN0aW9uLmFjdGlvblR5cGUpe1xuICAgIGNhc2UgYXBwQ29uc3RhbnRzLk5FV19NT05USDpcbiAgICAgIG5ld01vbnRoKGFjdGlvbi5kYXRhKTtcbiAgICAgIHBsYW5uZXJTdG9yZS5lbWl0KENIQU5HRV9FVkVOVCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFwcENvbnN0YW50cy5GSU5EX01PTlRIOlxuICAgICAgZmluZE1vbnRoKGFjdGlvbi5kYXRhKTtcbiAgICAgIHBsYW5uZXJTdG9yZS5lbWl0KENIQU5HRV9FVkVOVCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFwcENvbnN0YW50cy5TRUxFQ1RFRF9EQVk6XG4gICAgICBzZWxlY3RlZERheShhY3Rpb24uZGF0YSk7XG4gICAgICBwbGFubmVyU3RvcmUuZW1pdChDSEFOR0VfRVZFTlQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhcHBDb25zdGFudHMuQUREX0VWRU5UUzpcbiAgICAgIGFkZEV2ZW50cyhhY3Rpb24uZGF0YSk7XG4gICAgICBwbGFubmVyU3RvcmUuZW1pdChDSEFOR0VfRVZFTlQpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGxhbm5lclN0b3JlO1xuIl19

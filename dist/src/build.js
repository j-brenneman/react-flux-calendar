(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/lib/_empty.js":[function(require,module,exports){

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/path-browserify/index.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/CldrPluralRule.js":[function(require,module,exports){
(function (__dirname){
var fs = require('fs'),
    Path = require('path'),
    PEG = require('pegjs'),
    parser = PEG.buildParser(fs.readFileSync(Path.resolve(__dirname, 'cldrPluralRule.pegjs'), 'utf-8'));

function rangeListToJavaScriptAst(rangeListNode, lhsJavaScriptAst, withinSemantics) {
    var javaScriptAst,
        seenRange = false;
    for (var i = rangeListNode.ranges.length - 1 ; i >= 0 ; i -= 1) {
        var range = rangeListNode.ranges[i],
            itemJavaScriptAst;
        if (range.type === 'number') {
            itemJavaScriptAst = ['binary', '===', lhsJavaScriptAst, ['num', range.value]];
        } else {
            // range.type === 'range'
            seenRange = true;
            itemJavaScriptAst = ['binary', '&&', ['binary', '>=', lhsJavaScriptAst, ['num', range.min.value]],
                                                 ['binary', '<=', lhsJavaScriptAst, ['num', range.max.value]]];
        }
        if (javaScriptAst) {
            javaScriptAst = ['binary', '||', itemJavaScriptAst, javaScriptAst];
        } else {
            javaScriptAst = itemJavaScriptAst;
        }
    }
    if (seenRange && !withinSemantics) {
        javaScriptAst = ['binary', '&&', ['binary', '===', lhsJavaScriptAst,
                                                           ['call', ['dot', ['name', 'Math'], 'floor'], [lhsJavaScriptAst]]],
                                         javaScriptAst];
    }
    return javaScriptAst;
}

function nodeToJavaScriptAst(node) {
    switch (node.type) {
    case 'number':
        return ['num', node.value];
    case 'n':
    case 'i':
    case 'v':
    case 'w':
    case 'f':
    case 't':
        return ['name', node.type];
    case 'is':
        return ['binary', '==='].concat(node.operands.map(nodeToJavaScriptAst));
    case 'isnot':
        return ['binary', '!=='].concat(node.operands.map(nodeToJavaScriptAst));
    case 'mod':
        return ['binary', '%'].concat(node.operands.map(nodeToJavaScriptAst));
    case 'and':
        return ['binary', '&&'].concat(node.operands.map(nodeToJavaScriptAst));
    case 'or':
        return ['binary', '||'].concat(node.operands.map(nodeToJavaScriptAst));
    case 'not':
        return ['unary-prefix', '!', nodeToJavaScriptAst(node.operands)];
    case 'isnot':
        return ['binary', '!=='].concat(node.operands.map(nodeToJavaScriptAst));
    case 'within':
        return rangeListToJavaScriptAst(node.operands[1], nodeToJavaScriptAst(node.operands[0]), true);
    case 'notwithin':
        return ['unary-prefix', '!', rangeListToJavaScriptAst(node.operands[1], nodeToJavaScriptAst(node.operands[0]), true)];
    case 'in':
        return rangeListToJavaScriptAst(node.operands[1], nodeToJavaScriptAst(node.operands[0]), false);
    case 'notin':
        return ['unary-prefix', '!', rangeListToJavaScriptAst(node.operands[1], nodeToJavaScriptAst(node.operands[0]), false)];
    default:
        throw new Error('nodeToJavaScriptAst: Unknown node type: ' + node.type);
    }
}

function traverse(node, lambda) {
    lambda(node);
    if (node.operands) {
        node.operands.forEach(function (operand) {
            traverse(operand, lambda);
        });
    }
}

function CldrPluralRule(src) {
    this.topLevelNode = parser.parse(src.replace(/^\s+|\s+$/g, '').replace(/\s{2,}/g, ' '));
}

CldrPluralRule.prototype = {
    toJavaScriptAst: function () {
        return nodeToJavaScriptAst(this.topLevelNode);
    },

    eachNode: function (lambda) {
        traverse(this.topLevelNode, lambda);
    },

    updateIsUsedByTerm: function (isUsedByTerm) {
        this.eachNode(function (node) {
            if (['i', 'v', 'w', 'f', 't', 'n'].indexOf(node.type) !== -1) {
                isUsedByTerm[node.type] = true;
            }
        });
        return isUsedByTerm;
    }
};

module.exports = CldrPluralRule;

}).call(this,"/node_modules/cldr/lib")

},{"fs":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/lib/_empty.js","path":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/path-browserify/index.js","pegjs":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/pegjs/lib/peg.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/CldrPluralRuleSet.js":[function(require,module,exports){
var CldrPluralRule = require('./CldrPluralRule'),
    cldrPluralRuleTermFunctionByName = require('./cldrPluralRuleTermFunctionByName'),
    uglifyJs = require('uglify-js');

function CldrPluralRuleSet() {
    this.cldrPluralRuleByCount = {};
}

CldrPluralRuleSet.prototype = {
    addRule: function (cldrPluralRule, count) {
        if (typeof cldrPluralRule === 'string') {
            cldrPluralRule = cldrPluralRule.replace(/\s*@(?:decimal|integer).*$/, '');
            // Some count="other" nodes in CLDR 24+ consist purely of sample text.
            // Don't add those.
            if (cldrPluralRule.length === 0) {
                return;
            }
            cldrPluralRule = new CldrPluralRule(cldrPluralRule);
        }
        this.cldrPluralRuleByCount[count] = cldrPluralRule;
    },

    toJavaScriptFunctionBodyAst: function () {
        var statementAsts = [],
            isUsedByTerm = {};
        Object.keys(this.cldrPluralRuleByCount).forEach(function (count) {
            var cldrPluralRule = this.cldrPluralRuleByCount[count];
            cldrPluralRule.updateIsUsedByTerm(isUsedByTerm);
            statementAsts.push(
                [
                    'if',
                    cldrPluralRule.toJavaScriptAst(),
                    ['return', ['string', count]]
                ]
            );
        }, this);
        statementAsts.push(['return', ['string', 'other']]);
        var varAsts = [];

        ['i', 'v', 'w', 'f', 't'].forEach(function (term) {
            if (isUsedByTerm[term]) {
                varAsts.push([term, uglifyJs.parser.parse(cldrPluralRuleTermFunctionByName[term].toString())[1][0][3][0][1]]);
            }
        });

        if (Object.keys(isUsedByTerm).length !== 0) {
            statementAsts.unshift(
                // if (typeof n === 'string') n = parseInt(n, 10);
                [ 'if',
                      [ 'binary',
                        '===',
                        [ 'unary-prefix', 'typeof', [ 'name', 'n' ] ],
                        [ 'string', 'string' ] ],
                      [ 'stat',
                        [ 'assign',
                          true,
                          [ 'name', 'n' ],
                          [ 'call',
                            [ 'name', 'parseInt' ],
                            [ [ 'name', 'n' ], [ 'num', 10 ] ] ] ] ],
                      undefined ]
            );
        }

        if (varAsts.length > 0) {
            statementAsts.unshift(['var', varAsts]);
        }
        return statementAsts;
    }
};

module.exports = CldrPluralRuleSet;

},{"./CldrPluralRule":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/CldrPluralRule.js","./cldrPluralRuleTermFunctionByName":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/cldrPluralRuleTermFunctionByName.js","uglify-js":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/uglify-js.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/CldrRbnfRuleSet.js":[function(require,module,exports){
var _ = require('underscore');

function CldrRbnfRuleSet(config) {
    _.extend(this, config);
    this.ruleByValue = {};
}

CldrRbnfRuleSet.getSafeRendererName = function (rendererName) {
    return (
        ("render-" + rendererName)
        .replace(/[^\w-]/g, '-')
        .replace(/[-_]+([0-9a-z])/gi, function ($0, ch) {
            return ch.toUpperCase();
        })
        .replace('GREEKNUMERALMAJUSCULES', 'GreekNumeralMajuscules')
    );
};

CldrRbnfRuleSet.prototype = {
    toFunctionAst: function () {
        var that = this,
            isSeenByRuleSetType = {};

        function ruleToExpressionAst(rule) {
            var expressionAsts = [],
                rbnf = rule.rbnf;

            // "If a rule body begins with an apostrophe, the apostrophe is ignored, but all text after it becomes
            // significant (this is how you can have a rule's rule text begin with whitespace)."
            // -- http://www.icu-project.org/apiref/icu4c/classRuleBasedNumberFormat.html
            rbnf = rbnf.replace(/^'/, '');

            var radix = rule.radix || 10;

            function getDivisor() {
                var divisor = 1;
                while (10 * divisor <= parseInt(rule.value, 10)) { // Inefficient, but won't suffer from Math.log rounding errors
                    divisor *= 10;
                }
                return divisor;
            }

            // Replace is used for tokenization, the return value isn't used:
            rbnf.replace(/(?:([\<\>\=])(?:(%%?[\w\-]+)|([#,0.]+))?\1)|(?:\[([^\]]+)\])|([\x7f-\uffff:'\.\s\w\d\-]+)/gi, function ($0, specialChar, otherFormat, decimalFormat, optional, literal) {
                // The meanings of the substitution token characters are as follows:
                if (specialChar) {
                    var expr;
                    if (specialChar === '<') { // <<
                        if (/^\d+$/.test(rule.value)) {
                            // In normal rule: Divide the number by the rule's divisor and format the quotient
                            expr = ['call', ['dot', ['name', 'Math'], 'floor'], [['binary', '/', ['name', 'n'], ['num', getDivisor()]]]];
                        } else if (rule.value === '-x') {
                            throw new Error('<< not allowed in negative number rule');
                        } else {
                            // In fraction or master rule: Isolate the number's integral part and format it.
                            expr = ['call', ['dot', ['name', 'Math'], 'floor'], [['name', 'n']]];
                        }
                    } else if (specialChar === '>') { // >>
                        if (/\./.test(rule.value)) {
                            // Fraction or master rule => parseInt(String(n).replace(/\d*\./, ''), 10)
                            expr = ['call', ['name', 'parseInt'], [['call', ['dot', ['call', ['name', 'String'], [['name', 'n']]], 'replace'], [['regexp', '\\d*\\.', ''], ['string', '']]], ['num', 10]]];
                        } else if (rule.value === '-x') {
                            expr = ['unary-prefix', '-', ['name', 'n']];
                        } else {
                            expr = ['binary', '%', ['name', 'n'], ['num', getDivisor()]];
                        }
                    } else if (specialChar === '=') { // ==
                        expr = ['name', 'n'];
                    }
                    // FIXME: >>> not supported

                    // The substitution descriptor (i.e., the text between the token characters) may take one of three forms:
                    if (otherFormat) {
                        // A rule set name:
                        // Perform the mathematical operation on the number, and format the result using the named rule set.
                        var otherFormatName = CldrRbnfRuleSet.getSafeRendererName(otherFormat);
                        isSeenByRuleSetType[otherFormatName] = true;
                        // Turn into this.<otherFormatName>(<expr>)
                        expressionAsts.push(['call', ['dot', ['name', 'this'], otherFormatName], [expr]]);
                    } else if (decimalFormat) {
                        // A DecimalFormat pattern:
                        // Perform the mathematical operation on the number, and format the result using a DecimalFormat
                        // with the specified pattern. The pattern must begin with 0 or #.
                        expressionAsts.push(['call', ['dot', ['name', 'this'], 'renderNumber'], [expr, ['string', decimalFormat]]]);
                    } else {
                        // Nothing:
                        if (specialChar === '>') {
                            // If you omit the substitution descriptor in a >> substitution in a fraction rule, format the result one digit at a time using the rule set containing the current rule.
                            expressionAsts.push(['call', ['dot', ['name', 'this'], that.type], [expr]]);
                        } else if (specialChar === '<') {
                            // If you omit the substitution descriptor in a << substitution in a rule in a fraction rule set, format the result using the default rule set for this renderer.
                            // FIXME: Should be the default rule set for this renderer!
                            expressionAsts.push(['call', ['dot', ['name', 'this'], that.type], [expr]]);
                        } else {
                            throw new Error('== not supported!');
                        }
                   }
                } else if (optional) { // [ ... ]
                    var optionalRuleExpressionAst = ruleToExpressionAst({radix: rule.radix, rbnf: optional, value: rule.value});
                    expressionAsts.push(['conditional', ['binary', '===', ['name', 'n'], ['num', parseInt(rule.value, 10)]], ['string', ''], optionalRuleExpressionAst]);
                } else if (literal) {
                    expressionAsts.push(['string', literal]);
                } else {
                    throw new Error("Unknown token in " + rule.rbnf);
                }
            });
            if (expressionAsts.length === 0) {
                expressionAsts = [['string', '']];
            }
            var expressionAst = expressionAsts.shift();
            while (expressionAsts.length > 0) {
                expressionAst = ['binary', '+', expressionAst, expressionAsts.shift()];
            }
            return expressionAst;
        }

        function conditionToStatementAst(conditionAst, rule) {
            return ['if', conditionAst, ['return', ruleToExpressionAst(rule)], null];
        }

        var statementAsts = [];
        if (this.ruleByValue['x.0'] || this.ruleByValue['x.x']) {
            // var isFractional = n !== Math.floor(n);
            statementAsts.push(['var', [['isFractional', ['binary', '!==', ['name', 'n'], ['call', ['dot', ['name', 'Math'], 'floor'], [['name', 'n']]]]]]]);
        }
        if (this.ruleByValue['x.0']) {
            statementAsts.push(conditionToStatementAst(['name', 'isFractional'], this.ruleByValue['x.0']));
        }
        if (this.ruleByValue['-x']) {
            statementAsts.push(conditionToStatementAst(['binary', '<', ['name', 'n'], ['num', 0]], this.ruleByValue['-x']));
        }
        if (this.ruleByValue['x.x']) {
            statementAsts.push(conditionToStatementAst(['binary', '&&', ['name', 'isFractional'], ['binary', '>', ['name', 'n'], ['num', 1]]], this.ruleByValue['x.x']));
        }
        if (this.ruleByValue['0.x']) {
            statementAsts.push(conditionToStatementAst(['binary', '&&', ['binary', '>', ['name', 'n'], ['num', 0]], ['binary', '<', ['name', 'n'], ['num', 1]]], this.ruleByValue['0.x']));
        }

        Object.keys(this.ruleByValue).filter(function (value) {
            return /^\d+$/.test(value);
        }).map(function (value) {
            return parseInt(value, 10);
        }).sort(function (a, b) {
            return b - a;
        }).forEach(function (numericalValue) {
            statementAsts.push(conditionToStatementAst(['binary', '>=', ['name', 'n'], ['num', numericalValue]], this.ruleByValue[numericalValue]));
        }, this);

        return {functionAst: ['function', null, ['n'], statementAsts], dependencies: Object.keys(isSeenByRuleSetType)};
    }
};

module.exports = CldrRbnfRuleSet;

},{"underscore":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/underscore/underscore.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/cldr.js":[function(require,module,exports){
(function (process,__dirname){
var Path = require('path'),
    fs = require('fs'),
    _ = require('underscore'),
    passError = require('passerror'),
    memoizeAsync = require('./memoizeAsync'),
    dom = require('xmldom').DOMParser,
    xpath = require('xpath'),
    seq = require('seq'),
    normalizeLocaleId = require('./normalizeLocaleId'),
    normalizeProperty = require('./normalizeProperty'),
    convertObjectsWithIntegerKeysToArrays = require('./convertObjectsWithIntegerKeysToArrays'),
    CldrPluralRuleSet = require('./CldrPluralRuleSet'),
    CldrRbnfRuleSet = require('./CldrRbnfRuleSet'),
    uglifyJs = require('uglify-js'),
    unicoderegexp = require('unicoderegexp');

function normalizeXPathQuery(xpathQuery) {
    var xpathQueryFragments = xpathQuery.split('/');
    for (var i = 0 ; i < xpathQueryFragments.length ; i += 1) {
        if (i > 0 && xpathQueryFragments[i] === '..' && xpathQueryFragments[i - 1] !== '..') {
            xpathQueryFragments.splice(i - 1, 2);
            i -= 2;
        }
    }
    return xpathQueryFragments.join('/');
}

function expandLocaleIdToPrioritizedList(localeId) {
    localeId = normalizeLocaleId(localeId);
    if (!localeId) {
        return [];
    }
    var localeIds = [localeId];
    while (/_[^_]+$/.test(localeId)) {
        localeId = localeId.replace(/_[^_]+$/, '');
        localeIds.push(localeId);
    }
    return localeIds;
}

function Cldr(cldrPath) {
    // Support instantiation without the 'new' operator:
    if (!(this instanceof Cldr)) {
        return new Cldr(cldrPath);
    }
    this.cldrPath = cldrPath;
    this.documentByFileName = {};
    this.memoizerByFileName = {};
}

Cldr.prototype = {
    get fileNamesByTypeAndNormalizedLocaleId() {
        if (!this._fileNamesByTypeAndNormalizedLocaleId) {
            this._fileNamesByTypeAndNormalizedLocaleId = {};
            ['main', 'rbnf'].forEach(function (type) {
                this._fileNamesByTypeAndNormalizedLocaleId[type] = {};
                var fileNames;
                try {
                    fileNames = fs.readdirSync(Path.resolve(this.cldrPath, "common", type));
                } catch (e) {
                    if (e.code === 'ENOENT') {
                        // Directory doesn't exist, just pretend it's empty.
                        return;
                    }
                }
                fileNames.forEach(function (fileName) {
                    var matchFileName = fileName.match(/^(.*)\.xml$/);
                    if (matchFileName) {
                        this._fileNamesByTypeAndNormalizedLocaleId[type][normalizeLocaleId(matchFileName[1])] =
                            Path.resolve(this.cldrPath, "common", type, fileName);
                    }
                }, this);
            }, this);
        }
        return this._fileNamesByTypeAndNormalizedLocaleId;
    },

    get localeIds() {
        if (!this._localeIds) {
            this._localeIds = Object.keys(this.fileNamesByTypeAndNormalizedLocaleId.main);
        }
        return this._localeIds;
    },

    get calendarIds() {
        if (!this._calendarIds) {
            this._calendarIds = [];
            xpath.select('/ldmlBCP47/keyword/key[@name="ca"]/type', this.getDocument(Path.resolve(this.cldrPath, 'common', 'bcp47', 'calendar.xml'))).forEach(function (keyNode) {
                var calendarId = keyNode.getAttribute('name');
                if (calendarId === 'gregory') {
                    calendarId = 'gregorian';
                }
                this._calendarIds.push(calendarId);
            }, this);
        }
        return this._calendarIds;
    },

    get numberSystemIds() {
        if (!this._numberSystemIds) {
            this._numberSystemIds = [];
            xpath.select('/ldmlBCP47/keyword/key[@name="nu"]/type', this.getDocument(Path.resolve(this.cldrPath, 'common', 'bcp47', 'number.xml'))).forEach(function (keyNode) {
                this._numberSystemIds.push(keyNode.getAttribute('name'));
            }, this);
        }
        return this._numberSystemIds;
    },

    // Works both async and sync (omit cb):
    getDocument: function (fileName, cb) {
        var that = this;
        if (that.documentByFileName[fileName]) {
            if (cb) {
                process.nextTick(function () {
                    cb(null, that.documentByFileName[fileName]);
                });
            } else {
                return that.documentByFileName[fileName];
            }
        } else {
            if (cb) {
                // Make sure not to load file more than once if it's being loaded when getDocument is called for the second time:
                that.memoizerByFileName[fileName] = that.memoizerByFileName[fileName] || memoizeAsync(function (cb) {
                    fs.readFile(fileName, 'utf-8', passError(cb, function (xmlString) {
                        var document = new dom().parseFromString(xmlString);
                        that.documentByFileName[fileName] = document;
                        cb(null, document);
                    }));
                });
                that.memoizerByFileName[fileName](cb);
            } else {
                return that.documentByFileName[fileName] = new dom().parseFromString(fs.readFileSync(fileName, 'utf-8'));
            }
        }
    },

    getPrioritizedDocumentsForLocale: function (localeId, type) {
        var that = this;
        return expandLocaleIdToPrioritizedList(localeId).concat('root').map(function (subLocaleId) {
            return that.fileNamesByTypeAndNormalizedLocaleId[type][normalizeLocaleId(subLocaleId)];
        }).filter(function (fileName) {
            return !!fileName;
        }).map(function (fileName) {
            return that.getDocument(fileName);
        });
    },

    preload: function (localeIds, cb) {
        var that = this;
        if (typeof localeIds === 'function') {
            cb = localeIds;
            localeIds = that.localeIds;
        }
        localeIds = (Array.isArray(localeIds) ? localeIds : [localeIds]).map(normalizeLocaleId);
        var neededLocaleById = {root: true};
        localeIds.forEach(function (localeId) {
            expandLocaleIdToPrioritizedList(localeId).forEach(function (subLocaleId) {
                neededLocaleById[subLocaleId] = true;
            });
        });
        var fileNames = [
            Path.resolve(that.cldrPath, 'common', 'supplemental', 'plurals.xml'),
            Path.resolve(that.cldrPath, 'common', 'supplemental', 'numberingSystems.xml')
        ];
        Object.keys(neededLocaleById).forEach(function (localeId) {
            ['main', 'rbnf'].forEach(function (type) {
                var fileName = that.fileNamesByTypeAndNormalizedLocaleId[type][localeId];
                if (fileName) {
                    fileNames.push(fileName);
                }
            });
        });
        seq(fileNames)
            .parEach(20, function (fileName) {
                that.getDocument(fileName, this);
            })
            .seq(function () {
                cb();
            })
            .catch(cb);
    },

    createFinder: function (prioritizedDocuments) {
        return function finder(xpathQuery) {
            var prioritizedResults = [];
            prioritizedDocuments.forEach(function (document, i) {
                var resultsForLocaleDocument = xpath.select(xpathQuery, document);
                if (resultsForLocaleDocument.length === 0 && i === (prioritizedDocuments.length - 1)) {
                    // We're in root and there were no results, look for alias elements in path:
                    var queryFragments = xpathQuery.split('/'),
                        poppedQueryFragments = [];
                    while (queryFragments.length > 1) {
                        var aliasNodes = xpath.select(queryFragments.join('/') + '/alias', document);
                        if (aliasNodes.length > 0) {
                            var aliasSpecifiedQuery = normalizeXPathQuery(queryFragments.join('/') + '/' + aliasNodes[0].getAttribute('path') + '/' + poppedQueryFragments.join('/'));
                            Array.prototype.push.apply(prioritizedResults, finder(aliasSpecifiedQuery));
                            break;
                        }
                        poppedQueryFragments.unshift(queryFragments.pop());
                    }
                } else {
                    Array.prototype.push.apply(prioritizedResults, resultsForLocaleDocument);
                }
            });
            return prioritizedResults;
        };
    },

    extractLocaleDisplayPattern: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            localeDisplayPattern = {};
        finder("/ldml/localeDisplayNames/localeDisplayPattern/*").forEach(function (node) {
            localeDisplayPattern[node.nodeName] = node.textContent;
        });
        return localeDisplayPattern;
    },

    extractLanguageDisplayNames: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            languageDisplayNames = {};
        finder('/ldml/localeDisplayNames/languages/language').forEach(function (node) {
            var id = normalizeLocaleId(node.getAttribute('type'));
            languageDisplayNames[id] = languageDisplayNames[id] || node.textContent;
        });
        return languageDisplayNames;
    },

    extractTimeZoneDisplayNames: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            timeZoneDisplayNames = {};
        finder("/ldml/dates/timeZoneNames/zone").forEach(function (zoneNode) {
            var timeZoneId = zoneNode.getAttribute('type'),
                exemplarCityNodes = xpath.select("exemplarCity", zoneNode),
                tzNameLocale;
            if (exemplarCityNodes.length > 0) {
                tzNameLocale = exemplarCityNodes[0].textContent;
            } else {
                var genericDisplayNameNodes = xpath.select("long/generic", zoneNode);
                if (genericDisplayNameNodes.length > 0) {
                    tzNameLocale = genericDisplayNameNodes[0].textContent;
                } else {
                    var longDisplayNameNodes = xpath.select("long/standard", zoneNode);
                    if (longDisplayNameNodes.length > 0) {
                        tzNameLocale = longDisplayNameNodes[0].textContent;
                    }
                }
            }
            if (tzNameLocale) {
                timeZoneDisplayNames[timeZoneId] = timeZoneDisplayNames[timeZoneId] || tzNameLocale;
            }
        });
        return timeZoneDisplayNames;
    },

    extractTimeZoneFormats: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            timeZoneFormats = {};
        ['hourFormat', 'gmtFormat', 'gmtZeroFormat', 'regionFormat', 'fallbackFormat', 'fallbackRegionFormat'].forEach(function (tagName) {
            finder("/ldml/dates/timeZoneNames/" + tagName).forEach(function (node) {
                var formatName = node.nodeName.replace(/Format$/, ''),
                    value = node.textContent;
                if (formatName === 'hour') {
                    value = value.split(';');
                }
                timeZoneFormats[formatName] = timeZoneFormats[formatName] || value;
            });
        });
        finder("/ldml/dates/timeZoneNames/regionFormat[@type]").forEach(function (node) {
            var type = node.getAttribute('type');
            timeZoneFormats.regions = timeZoneFormats.regions || {};
            timeZoneFormats.regions[type] = timeZoneFormats.regions[type] || node.textContent;
        });
        return timeZoneFormats;
    },

    extractTerritoryDisplayNames: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            territoryDisplayNames = {};
        finder("/ldml/localeDisplayNames/territories/territory").forEach(function (territoryNode) {
            var territoryId = territoryNode.getAttribute('type');
            territoryDisplayNames[territoryId] = territoryDisplayNames[territoryId] || territoryNode.textContent;
        });
        return territoryDisplayNames;
    },

    extractCurrencyInfoById: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            currencyDisplayNameByCurrencyId = {},
            currencyDisplayNameByCurrencyIdAndCount = {},
            currencySymbolByCurrencyId = {};

        finder("/ldml/numbers/currencies/currency/displayName").forEach(function (displayNameNode) {
            var currencyId = displayNameNode.parentNode.getAttribute('type'),
                countAttribute = displayNameNode.getAttribute('count');
            if (countAttribute) {
                currencyDisplayNameByCurrencyIdAndCount[currencyId] = currencyDisplayNameByCurrencyIdAndCount[currencyId] || {};
                currencyDisplayNameByCurrencyIdAndCount[currencyId][countAttribute] = displayNameNode.textContent;
            } else {
                currencyDisplayNameByCurrencyId[currencyId] = currencyDisplayNameByCurrencyId[currencyId] || displayNameNode.textContent;
            }
        });

        finder("/ldml/numbers/currencies/currency/symbol").forEach(function (symbolNode) {
            var currencyId = symbolNode.parentNode.getAttribute('type');
            currencySymbolByCurrencyId[currencyId] = currencySymbolByCurrencyId[currencyId] || symbolNode.textContent;
        });

        var currencyInfoById = {};
        Object.keys(currencyDisplayNameByCurrencyId).forEach(function (currencyId) {
            currencyInfoById[currencyId] = _.extend({
                displayName: currencyDisplayNameByCurrencyId[currencyId],
                symbol: currencySymbolByCurrencyId[currencyId]
            }, currencyDisplayNameByCurrencyIdAndCount[currencyId]);
        });
        return currencyInfoById;
    },

    extractScriptDisplayNames: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            scriptDisplayNames = {};
        finder("/ldml/localeDisplayNames/scripts/script").forEach(function (scriptNode) {
            var id = scriptNode.getAttribute('type');
            scriptDisplayNames[id] = scriptDisplayNames[id] || scriptNode.textContent;
        });
        return scriptDisplayNames;
    },

    extractKeyTypes: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            keyTypes = {};
        finder('/ldml/localeDisplayNames/keys/key').forEach(function (keyNode) {
            var type = keyNode.getAttribute('type');
            keyTypes[type] = { displayName: keyNode.textContent };
        });
        finder('/ldml/localeDisplayNames/types/type').forEach(function (typeNode) {
            var key = typeNode.getAttribute('key'),
                type = normalizeProperty(typeNode.getAttribute('type'));
            keyTypes[key] = keyTypes[key] || {};
            keyTypes[key].types = keyTypes[key].types || {};
            keyTypes[key].types[type] = typeNode.textContent;
        });
        return keyTypes;
    },

    extractTransformNames: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            transformNames = {};
        finder("/ldml/localeDisplayNames/transformNames/transformName").forEach(function (transformNameNode) {
            var id = transformNameNode.getAttribute('type');
            transformNames[id] = transformNames[id] || transformNameNode.textContent;
        });
        return transformNames;
    },

    extractMeasurementSystemNames: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            measurementSystemNames = {};
        finder("/ldml/localeDisplayNames/measurementSystemNames/measurementSystemName").forEach(function (measurementSystemNameNode) {
            var id = measurementSystemNameNode.getAttribute('type');
            measurementSystemNames[id] = measurementSystemNames[id] || measurementSystemNameNode.textContent;
        });
        return measurementSystemNames;
    },

    extractCodePatterns: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            codePatterns = {};
        finder("/ldml/localeDisplayNames/codePatterns/codePattern").forEach(function (codePatternNode) {
            var id = codePatternNode.getAttribute('type');
            codePatterns[id] = codePatterns[id] || codePatternNode.textContent;
        });
        return codePatterns;
    },

    // Calendar extraction methods:

    extractEraNames: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            eraNames;
        ['eraNames', 'eraAbbr'].forEach(function (eraType) {
            var typeInOutput = {eraNames: 'wide', eraAbbr: 'abbreviated'}[eraType];
            finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/eras/" + eraType + "/era").forEach(function (eraNode) {
                var type = parseInt(eraNode.getAttribute('type'), 10);
                eraNames = eraNames || {};
                eraNames[typeInOutput] = eraNames[typeInOutput] || {};
                eraNames[typeInOutput][type] = eraNames[typeInOutput][type] || eraNode.textContent;
            });
        });
        return convertObjectsWithIntegerKeysToArrays(eraNames);
    },

    extractQuarterNames: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            quarterNames;
        ['format', 'stand-alone'].forEach(function (quarterContext) {
            var quarterContextCamelCase = normalizeProperty(quarterContext); // stand-alone => standAlone
            ['abbreviated', 'narrow', 'wide'].forEach(function (quarterWidth) {
                finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/quarters/quarterContext[@type='" + quarterContext + "']/quarterWidth[@type='" + quarterWidth + "']/quarter").forEach(function (quarterNode) {
                    var quarterNo = parseInt(quarterNode.getAttribute('type'), 10) - 1;

                    quarterNames = quarterNames || {};
                    quarterNames[quarterContextCamelCase] = quarterNames[quarterContextCamelCase] || {};
                    quarterNames[quarterContextCamelCase][quarterWidth] = quarterNames[quarterContextCamelCase][quarterWidth] || {};
                    quarterNames[quarterContextCamelCase][quarterWidth][quarterNo] = quarterNames[quarterContextCamelCase][quarterWidth][quarterNo] || quarterNode.textContent;
                });
            });
        });
        return convertObjectsWithIntegerKeysToArrays(quarterNames);
    },

    extractDayPeriods: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            dayPeriods;
        ['format', 'stand-alone'].forEach(function (dayPeriodContext) {
            var dayPeriodContextCamelCase = normalizeProperty(dayPeriodContext); // stand-alone => standAlone
            ['abbreviated', 'narrow', 'wide', 'short'].forEach(function (dayPeriodWidth) {
                finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/dayPeriods/dayPeriodContext[@type='" + dayPeriodContext + "']/dayPeriodWidth[@type='" + dayPeriodWidth + "']/dayPeriod").forEach(function (dayPeriodNode) {
                    var type = dayPeriodNode.getAttribute('type');

                    dayPeriods = dayPeriods || {};
                    dayPeriods[dayPeriodContextCamelCase] = dayPeriods[dayPeriodContextCamelCase] || {};
                    dayPeriods[dayPeriodContextCamelCase][dayPeriodWidth] =
                        dayPeriods[dayPeriodContextCamelCase][dayPeriodWidth] || {};
                    dayPeriods[dayPeriodContextCamelCase][dayPeriodWidth][type] =
                        dayPeriods[dayPeriodContextCamelCase][dayPeriodWidth][type] || dayPeriodNode.textContent;
                });
            });
        });
        return dayPeriods;
    },

    extractCyclicNames: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            cyclicNames;
        ['dayParts', 'days', 'months', 'years', 'zodiacs'].forEach(function (cyclicNameSet) {
            ['format'].forEach(function (cyclicNameContext) {
                ['abbreviated', 'narrow', 'wide'].forEach(function (cyclicNameWidth) {
                    finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/cyclicNameSets/cyclicNameSet[@type='" + cyclicNameSet + "']/cyclicNameContext[@type='" + cyclicNameContext + "']/cyclicNameWidth[@type='" + cyclicNameWidth + "']/cyclicName").forEach(function (cyclicNameNode) {
                        var type = cyclicNameNode.getAttribute('type');
                        cyclicNames = cyclicNames || {};
                        cyclicNames[cyclicNameSet] = cyclicNames[cyclicNameSet] || {};
                        cyclicNames[cyclicNameSet][cyclicNameContext] = cyclicNames[cyclicNameSet][cyclicNameContext] || {};
                        cyclicNames[cyclicNameSet][cyclicNameContext][cyclicNameWidth] = cyclicNames[cyclicNameSet][cyclicNameContext][cyclicNameWidth] || {};
                        cyclicNames[cyclicNameSet][cyclicNameContext][cyclicNameWidth][type] = cyclicNames[cyclicNameSet][cyclicNameContext][cyclicNameWidth][type] || cyclicNameNode.textContent;
                    });
                });
            });
        });
        return convertObjectsWithIntegerKeysToArrays(cyclicNames);
    },

    extractMonthNames: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            monthNames;
        ['format', 'stand-alone'].forEach(function (monthContext) {
            var monthContextCamelCase = normalizeProperty(monthContext); // stand-alone => standAlone
            ['abbreviated', 'narrow', 'wide'].forEach(function (monthWidth) {
                finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/months/monthContext[@type='" + monthContext + "']/monthWidth[@type='" + monthWidth + "']/month").forEach(function (monthNode) {
                    var monthNo = parseInt(monthNode.getAttribute('type'), 10) - 1;
                    monthNames = monthNames || {};
                    monthNames[monthContextCamelCase] = monthNames[monthContextCamelCase] || {};
                    monthNames[monthContextCamelCase][monthWidth] = monthNames[monthContextCamelCase][monthWidth] || {};
                    monthNames[monthContextCamelCase][monthWidth][monthNo] =
                        monthNames[monthContextCamelCase][monthWidth][monthNo] || monthNode.textContent;
                });
            });
        });
        return convertObjectsWithIntegerKeysToArrays(monthNames);
    },

    extractMonthPatterns: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            monthPatterns;
        ['format', 'numeric', 'stand-alone'].forEach(function (monthPatternContext) {
            var monthPatternContextCamelCase = normalizeProperty(monthPatternContext); // stand-alone => standAlone
            ['abbreviated', 'narrow', 'wide', 'all'].forEach(function (monthPatternWidth) {
                finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/monthPatterns/monthPatternContext[@type='" + monthPatternContext + "']/monthPatternWidth[@type='" + monthPatternWidth + "']/monthPattern").forEach(function (monthPatternNode) {
                    var type = monthPatternNode.getAttribute('type');
                    monthPatterns = monthPatterns || {};
                    monthPatterns[monthPatternContextCamelCase] = monthPatterns[monthPatternContextCamelCase] || {};
                    monthPatterns[monthPatternContextCamelCase][monthPatternWidth] =
                        monthPatterns[monthPatternContextCamelCase][monthPatternWidth] || {};
                    monthPatterns[monthPatternContextCamelCase][monthPatternWidth][type] =
                        monthPatterns[monthPatternContextCamelCase][monthPatternWidth][type] || monthPatternNode.textContent;
                });
            });
        });
        return monthPatterns;
    },

    extractDayNames: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            dayNoByCldrId = {sun: 0, mon: 1, tue: 2, wed: 3, thu: 4, fri: 5, sat: 6},
            dayNames;
        ['format', 'numeric', 'stand-alone'].forEach(function (dayContext) {
            var dayContextCamelCase = normalizeProperty(dayContext); // stand-alone => standAlone
            ['abbreviated', 'narrow', 'wide', 'short'].forEach(function (dayWidth) {
                finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/days/dayContext[@type='" + dayContext + "']/dayWidth[@type='" + dayWidth + "']/day").forEach(function (dayNode) {
                    var dayNo = dayNoByCldrId[dayNode.getAttribute('type')];
                    dayNames = dayNames || {};
                    dayNames[dayContextCamelCase] = dayNames[dayContextCamelCase] || {};
                    dayNames[dayContextCamelCase][dayWidth] = dayNames[dayContextCamelCase][dayWidth] || {};
                    dayNames[dayContextCamelCase][dayWidth][dayNo] = dayNames[dayContextCamelCase][dayWidth][dayNo] || dayNode.textContent;
                });
            });
        });
        return convertObjectsWithIntegerKeysToArrays(dayNames);
    },

    extractFields: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            fields;
        finder("/ldml/dates/fields/field/displayName").forEach(function (fieldDisplayNameNode) {
            var fieldName = fieldDisplayNameNode.parentNode.getAttribute('type');
            fields = fields || {};
            fields[fieldName] = fields[fieldName] || {};
            fields[fieldName].displayName = fields[fieldName].displayName || fieldDisplayNameNode.textContent;
        });

        finder("/ldml/dates/fields/field/relative").forEach(function (fieldRelativeNode) {
            var fieldName = fieldRelativeNode.parentNode.getAttribute('type'),
                type = fieldRelativeNode.getAttribute('type');
            fields = fields || {};
            fields[fieldName] = fields[fieldName] || {};
            fields[fieldName].relative = fields[fieldName].relative || {};
            fields[fieldName].relative[type] = fields[fieldName].relative[type] || fieldRelativeNode.textContent;
        });

        finder("/ldml/dates/fields/field/relativeTime/relativeTimePattern").forEach(function (relativeTimePatternNode) {
            var relativeTimeNode = relativeTimePatternNode.parentNode,
                fieldName = relativeTimeNode.parentNode.getAttribute('type'),
                type = relativeTimeNode.getAttribute('type'),
                count = relativeTimePatternNode.getAttribute('count');
            fields = fields || {};
            fields[fieldName] = fields[fieldName] || {};
            fields[fieldName].relativeTime = fields[fieldName].relativeTime || {};
            fields[fieldName].relativeTime[type] = fields[fieldName].relativeTime[type] || {};
            fields[fieldName].relativeTime[type][count] = fields[fieldName].relativeTime[type][count] || relativeTimePatternNode.textContent
        });
        return fields;
    },

    extractDateTimePatterns: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            dateTimePatterns;
        finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/dateTimeFormats/dateTimeFormatLength/dateTimeFormat").forEach(function (dateTimeFormatNode) {
            var dateTimeFormatLengthType = dateTimeFormatNode.parentNode.getAttribute('type'),
                patternNodes = xpath.select("pattern", dateTimeFormatNode);
            if (patternNodes.length !== 1) {
                throw new Error('Expected exactly one pattern in dateTimeFormatNode');
            }
            dateTimePatterns = dateTimePatterns || {};
            dateTimePatterns[dateTimeFormatLengthType] = dateTimePatterns[dateTimeFormatLengthType] || patternNodes[0].textContent;
        });
        return dateTimePatterns;
    },

    extractDateOrTimeFormats: function (localeId, calendarId, dateOrTime) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            formats;
        finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/" + dateOrTime + "Formats/" + dateOrTime + "FormatLength/" + dateOrTime + "Format/*").forEach(function (patternNode) {
            var type = patternNode.parentNode.parentNode.getAttribute('type');
            formats = formats || {};
            formats[type] = formats[type] || patternNode.textContent;
        });
        return formats;
    },

    extractDateFormats: function (localeId, calendarId) {
        return this.extractDateOrTimeFormats(localeId, calendarId, 'date');
    },

    extractTimeFormats: function (localeId, calendarId) {
        return this.extractDateOrTimeFormats(localeId, calendarId, 'time');
    },

    extractDateFormatItems: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            dateFormatItems;
        finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/dateTimeFormats/availableFormats/dateFormatItem").forEach(function (dateFormatItemNode) {
            var id = dateFormatItemNode.getAttribute('id');
            dateFormatItems = dateFormatItems || {};
            dateFormatItems[id] = dateFormatItems[id] || dateFormatItemNode.textContent;
        });
        return dateFormatItems;
    },

    extractDateIntervalFormats: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            dateIntervalFormats;
        finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/dateTimeFormats/intervalFormats/intervalFormatItem").forEach(function (intervalFormatItemNode) {
            var dateIntervalFormat = {};
            for (var i = 0 ; i < intervalFormatItemNode.childNodes.length ; i += 1) {
                var greatestDifferenceNode = intervalFormatItemNode.childNodes[i];
                if (greatestDifferenceNode.nodeType !== 1) {
                    // Skip whitespace node
                    continue;
                }
                var greatestDifferenceIdAttribute = greatestDifferenceNode.getAttribute('id');
                var greatestDifferenceId = greatestDifferenceIdAttribute;
                dateIntervalFormat[greatestDifferenceId] = dateIntervalFormat[greatestDifferenceId] || greatestDifferenceNode.textContent;
            }
            var id = intervalFormatItemNode.getAttribute('id');
            dateIntervalFormats = dateIntervalFormats || {};
            dateIntervalFormats[id] = dateIntervalFormats[id] || dateIntervalFormat;
        });
        return dateIntervalFormats;
    },

    extractDateIntervalFallbackFormat: function (localeId, calendarId) {
        calendarId = calendarId || 'gregorian';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            dateIntervalFallbackFormat;
        finder("/ldml/dates/calendars/calendar[@type='" + calendarId + "']/dateTimeFormats/intervalFormats/intervalFormatFallback").forEach(function (intervalFormatFallbackNode) {
            dateIntervalFallbackFormat = dateIntervalFallbackFormat || intervalFormatFallbackNode.textContent;
        });
        return dateIntervalFallbackFormat;
    },

    // Number extraction code:

    extractNumberSymbols: function (localeId, numberSystemId) {
        numberSystemId = numberSystemId || 'latn';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            numberSymbols;
        finder("/ldml/numbers/symbols[@numberSystem = '" + numberSystemId + "']/*[name() != 'alias']").concat(finder("/ldml/numbers/symbols/*[name() != 'alias']")).forEach(function (numberSymbolNode) {
            var symbolId = numberSymbolNode.nodeName;
            numberSymbols = numberSymbols || {};
            numberSymbols[symbolId] = numberSymbols[symbolId] || numberSymbolNode.textContent;
        });
        return numberSymbols;
    },

    extractNumberFormats: function (localeId, numberSystemId) {
        numberSystemId = numberSystemId || 'latn';
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            numberFormats;
        ['scientific', 'decimal', 'currency', 'percent'].forEach(function (formatType) {
            ['full', 'long', 'medium', 'short'].forEach(function (length) {
                finder("/ldml/numbers/" + formatType + "Formats[@numberSystem = '" + numberSystemId + "']/" + formatType + "FormatLength[@type='" + length + "']/" + formatType + "Format/pattern").forEach(function (patternNode) {
                    var type = patternNode.getAttribute('type'),
                        count = patternNode.getAttribute('count');
                    numberFormats = numberFormats || {};
                    numberFormats[formatType] = numberFormats[formatType] || {};
                    numberFormats[formatType][length] = numberFormats[formatType][length] || {};
                    numberFormats[formatType][length][type] = numberFormats[formatType][length][type] || {};
                    numberFormats[formatType][length][type][count] = numberFormats[formatType][length][type][count] || patternNode.textContent;
                });
            });
            finder("/ldml/numbers/" + formatType + "Formats[@numberSystem = '" + numberSystemId + "']/" + formatType + "FormatLength[not(@type)]/" + formatType + "Format/pattern").forEach(function (patternNode) {
                numberFormats = numberFormats || {};
                numberFormats[formatType] = numberFormats[formatType] || {};
                numberFormats[formatType].default = numberFormats[formatType].default || patternNode.textContent;
            });
            finder("/ldml/numbers/" + formatType + "Formats[@numberSystem = '" + numberSystemId + "']/unitPattern").forEach(function (unitPatternNode) {
                var count = unitPatternNode.getAttribute('count');
                numberFormats = numberFormats || {};
                numberFormats[formatType] = numberFormats[formatType] || {};
                numberFormats[formatType][count] = numberFormats[formatType][count] || unitPatternNode.textContent;
            });
        });

        finder("/ldml/numbers/currencyFormats[@numberSystem = '" + numberSystemId + "']/currencySpacing").forEach(function (currencySpacingNode) {
            numberFormats = numberFormats || {};
            numberFormats.currency = numberFormats.currency || {};
            numberFormats.currency.currencySpacing = numberFormats.currency.currencySpacing || {};

            ['before', 'after'].forEach(function (place) {
                var placeData = numberFormats.currency.currencySpacing[place + 'Currency'] = numberFormats.currency.currencySpacing[place + 'Currency'] || {};

                ['currencyMatch', 'surroundingMatch', 'insertBetween'].forEach(function (spacingPropertyName) {
                    var match = xpath.select(place + "Currency/" + spacingPropertyName, currencySpacingNode);
                    if (match.length > 0) {
                        numberFormats.currency.currencySpacing[place + 'Currency'][spacingPropertyName] = match[0].textContent;
                    }
                });

                ['currencyMatch', 'surroundingMatch'].forEach(function (spacingPropertyName) {
                    if (placeData[spacingPropertyName]) {
                        placeData[spacingPropertyName] = unicoderegexp.expandCldrUnicodeSetIdToCharacterClass(placeData[spacingPropertyName]);
                    }
                });
            });
        });

        return numberFormats;
    },

    extractDefaultNumberSystemId: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            defaultNumberSystemId;
        finder('/ldml/numbers/defaultNumberingSystem').forEach(function (defaultNumberingSystemNode) {
            defaultNumberSystemId = defaultNumberSystemId || defaultNumberingSystemNode.textContent;
        });
        return defaultNumberSystemId;
    },

    extractUnitPatterns: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            unitPatterns = {};
        finder("/ldml/units/unitLength/unit/unitPattern").forEach(function (unitPatternNode) {
            var unitNode = unitPatternNode.parentNode,
                unitLength = unitNode.parentNode.getAttribute('type'),
                unitId = normalizeProperty(unitNode.getAttribute('type'));
            unitPatterns[unitLength] = unitPatterns[unitLength] || {};
            unitPatterns[unitLength].unit = unitPatterns[unitLength].unit || {};
            unitPatterns[unitLength].unit[unitId] = unitPatterns[unitLength].unit[unitId] || {};
            var count = unitPatternNode.getAttribute('count');
            unitPatterns[unitLength].unit[unitId][count] = unitPatterns[unitLength].unit[unitId][count] || unitPatternNode.textContent;
        });
        finder("/ldml/units/unitLength/compoundUnit/compoundUnitPattern").forEach(function (compoundUnitPatternNode) {
            var compoundUnitNode = compoundUnitPatternNode.parentNode,
                unitLength = compoundUnitNode.parentNode.getAttribute('type'),
                compoundUnitId = compoundUnitNode.getAttribute('type');

            unitPatterns[unitLength].compoundUnit = unitPatterns[unitLength].compoundUnit || {};
            unitPatterns[unitLength].compoundUnit[compoundUnitId] = compoundUnitPatternNode.textContent;
        });
        return unitPatterns;
    },

    extractDelimiters: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            delimiters = {};
        finder("/ldml/delimiters/*").forEach(function (delimiterNode) {
            var type = delimiterNode.nodeName;
            delimiters[type] = delimiters[type] || delimiterNode.textContent;
        });
        return delimiters;
    },

    extractListPatterns: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            listPatterns = {};
        finder("/ldml/listPatterns/listPattern/listPatternPart").forEach(function (listPatternPartNode) {
            var listPatternTypeAttribute = listPatternPartNode.parentNode.getAttribute('type'),
                type = listPatternTypeAttribute ? normalizeProperty(listPatternTypeAttribute) : 'default',
                part = listPatternPartNode.getAttribute('type');
            listPatterns[type] = listPatterns[type] || {};
            listPatterns[type][part] = listPatterns[type][part] || listPatternPartNode.textContent;
        });
        return listPatterns;
    },

    extractCharacters: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            characters = {
                exemplar: {},
                ellipsis: {}
            };
        finder("/ldml/characters/exemplarCharacters").forEach(function (exemplarCharactersNode) {
            var typeAttr = exemplarCharactersNode.getAttribute('type'),
                type = typeAttr || 'default';
            characters.exemplar[type] = characters.exemplar[type] || exemplarCharactersNode.textContent.replace(/^\[|\]$/g, '').split(" ");
        });
        finder("/ldml/characters/ellipsis").forEach(function (ellipsisNode) {
            var type = ellipsisNode.getAttribute('type');
            characters.ellipsis[type] = characters.ellipsis[type] || ellipsisNode.textContent;
        });
        finder("/ldml/characters/moreInformation").forEach(function (moreInformationNode) {
            characters.moreInformation = characters.moreInformation || moreInformationNode.textContent;
        });
        return characters;
    },

    extractPluralRuleFunction: function (localeId) {
        var that = this,
            document = that.getDocument(Path.resolve(that.cldrPath, 'common', 'supplemental', 'plurals.xml')),
            subLocaleIds = expandLocaleIdToPrioritizedList(localeId),
            statementAsts = [];
        for (var i = 0 ; i < subLocaleIds.length ; i += 1) {
            var subLocaleId = subLocaleIds[i],
                matchLocalesXPathExpr =
                    "@locales = '" + subLocaleId + "' or " +
                    "starts-with(@locales, '" + subLocaleId + "') or " +
                    "contains(@locales, ' " + subLocaleId + " ') or " +
                    "substring(@locales, string-length(@locales) - string-length(' " + subLocaleId + "') + 1) = ' " + subLocaleId + "'",
                pluralRulesNodes = xpath.select("/supplementalData/plurals/pluralRules[" + matchLocalesXPathExpr + "]", document),
                cldrPluralRuleSet = new CldrPluralRuleSet();
            if (pluralRulesNodes.length > 0) {
                xpath.select("pluralRule", pluralRulesNodes[0]).forEach(function (pluralRuleNode) {
                    cldrPluralRuleSet.addRule(pluralRuleNode.textContent, pluralRuleNode.getAttribute('count'));
                });
                statementAsts = cldrPluralRuleSet.toJavaScriptFunctionBodyAst();
                break;
            }
        }
        return new Function("n", uglifyJs.uglify.gen_code(['toplevel', statementAsts]));
    },

    // 'types' is optional, defaults to all available
    extractRbnfFunctionByType: function (localeId, types) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'rbnf')),
            cldrRbnfRuleSetByType = {};
        finder('/ldml/rbnf/rulesetGrouping/ruleset/rbnfrule').forEach(function (rbnfRuleNode) {
            var type = CldrRbnfRuleSet.getSafeRendererName(rbnfRuleNode.parentNode.getAttribute('type')),
                value = rbnfRuleNode.getAttribute('value');
            cldrRbnfRuleSetByType[type] = cldrRbnfRuleSetByType[type] || new CldrRbnfRuleSet({type: type});
            if (!cldrRbnfRuleSetByType[type].ruleByValue[value]) {
                var radixAttribute = rbnfRuleNode.getAttribute('radix');
                cldrRbnfRuleSetByType[type].ruleByValue[value] = {
                    value: value,
                    rbnf: rbnfRuleNode.textContent.replace(/;$/, '').replace(//g, '<').replace(//g, '>'),
                    radix: radixAttribute
                };
            }
        });
        var isAddedByType = {},
            typesToAdd = types ? [].concat(types) : Object.keys(cldrRbnfRuleSetByType),
            rbnfFunctionByType = {
                renderNumber: String // Provide a (bad) default number rendering implementation to avoid #13
            };
        while (typesToAdd.length > 0) {
            var type = typesToAdd.shift();
            if (!(type in isAddedByType)) {
                isAddedByType[type] = true;
                var cldrRbnfRuleSet = cldrRbnfRuleSetByType[type];
                // Some rules aren't available in some locales (such as spellout-cardinal-financial).
                // The easiest thing is just to skip the missing ones here, even though it can produce
                // some broken function sets:
                if (cldrRbnfRuleSet) {
                    var result = cldrRbnfRuleSet.toFunctionAst();

                    rbnfFunctionByType[type] = new Function("n", uglifyJs.uglify.gen_code(['toplevel', result.functionAst[3]]));
                    Array.prototype.push.apply(typesToAdd, result.dependencies);
                }
            }
        }
        return rbnfFunctionByType;
    },

    extractDigitsByNumberSystemId: function () {
        var document = this.getDocument(Path.resolve(this.cldrPath, 'common', 'supplemental', 'numberingSystems.xml')),
            digitsByNumberSystemId = {};

        xpath.select('/supplementalData/numberingSystems/numberingSystem', document).forEach(function (numberingSystemNode) {
            var numberSystemId = numberingSystemNode.getAttribute('id');
            if (numberingSystemNode.getAttribute('type') === 'numeric') {
                digitsByNumberSystemId[numberSystemId] = numberingSystemNode.getAttribute('digits').split(/(?:)/);
            } else {
                // type='algorithmic'
                var rulesAttributeFragments = numberingSystemNode.getAttribute('rules').split('/'),
                    sourceLocaleId = rulesAttributeFragments.length === 3 ? normalizeLocaleId(rulesAttributeFragments[0]) : 'root',
                    ruleType = CldrRbnfRuleSet.getSafeRendererName(rulesAttributeFragments[rulesAttributeFragments.length - 1]);
                digitsByNumberSystemId[numberSystemId] = ruleType; // A string value means "use this rbnf renderer for the digits"
            }
        }, this);
        return digitsByNumberSystemId;
    },

    extractLayout: function (localeId) {
        var finder = this.createFinder(this.getPrioritizedDocumentsForLocale(localeId, 'main')),
            layout = {};
        finder("/ldml/layout/*/*").forEach(function (leafNode) {
            var type = leafNode.nodeName,
                parentType = leafNode.parentNode.nodeName;
            layout[parentType] = layout[parentType] || {};
            layout[parentType][type] = layout[parentType][type] || leafNode.textContent;
        });
        return layout;
    }
};

module.exports = new Cldr(Path.resolve(__dirname, '../3rdparty/cldr/'));
module.exports.load = function (cldrPath) {
    return new Cldr(cldrPath);
};

}).call(this,require('_process'),"/node_modules/cldr/lib")

},{"./CldrPluralRuleSet":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/CldrPluralRuleSet.js","./CldrRbnfRuleSet":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/CldrRbnfRuleSet.js","./convertObjectsWithIntegerKeysToArrays":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/convertObjectsWithIntegerKeysToArrays.js","./memoizeAsync":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/memoizeAsync.js","./normalizeLocaleId":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/normalizeLocaleId.js","./normalizeProperty":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/normalizeProperty.js","_process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js","fs":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/lib/_empty.js","passerror":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/passerror/lib/index.js","path":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/path-browserify/index.js","seq":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/index.js","uglify-js":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/uglify-js.js","underscore":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/underscore/underscore.js","unicoderegexp":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/unicoderegexp/lib/unicodeRegExp.js","xmldom":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xmldom/dom-parser.js","xpath":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xpath/xpath.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/cldrPluralRuleTermFunctionByName.js":[function(require,module,exports){
exports.i = function i(n) {
    return Math.floor(Math.abs(n));
};

exports.v = function v(n) {
    return n.toString().replace(/^[^.]*\.?/, '').length;
};

exports.w = function w(n) {
    return n.toString().replace(/^[^.]*\.?|0+$/g, '').length;
};

exports.f = function f(n) {
    return parseInt(n.toString().replace(/^[^.]*\.?/, ''), 10) || 0;
};

exports.t = function t(n) {
    return parseInt(n.toString().replace(/^[^.]*\.?|0+$/g, ''), 10) || 0;
};

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/convertObjectsWithIntegerKeysToArrays.js":[function(require,module,exports){
// Convert objects with all integer keys starting from 0 to arrays and remove undefined values:
module.exports = function convertObjectsWithIntegerKeysToArrays(obj) {
    if (Array.isArray(obj)) {
        return obj.map(convertObjectsWithIntegerKeysToArrays);
    } else if (typeof obj === 'object' && obj !== null) {
        var keys = Object.keys(obj);
        if (0 in obj || 1 in obj) {
            var firstNumericKeyNumber = 0 in obj ? 0 : 1,
                nextNumericKeyNumber = firstNumericKeyNumber + 1;
            while (nextNumericKeyNumber in obj) {
                nextNumericKeyNumber += 1;
            }
            if (keys.length > 0 && nextNumericKeyNumber === keys.length + firstNumericKeyNumber) {
                var array = [],
                    i;
                for (i = 0 ; i < firstNumericKeyNumber ; i += 1) {
                    array.push(undefined);
                }
                for (i = firstNumericKeyNumber ; i < keys.length ; i += 1) {
                    array.push(convertObjectsWithIntegerKeysToArrays(obj[i]));
                }
                return array;
            }
        }
        var resultObj = {};
        keys.forEach(function (key) {
            if (typeof obj[key] !== 'undefined') {
                resultObj[key] = convertObjectsWithIntegerKeysToArrays(obj[key]);
            }
        });
        return resultObj;
    } else {
        return obj;
    }
};

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/memoizeAsync.js":[function(require,module,exports){
(function (process){
// Create a memoizer for an async function
module.exports = function memoizeAsync(fn) {
    var resultArguments,
        waitingCallbacks;
    return function (cb) {
        var that = this;
        if (resultArguments) {
            process.nextTick(function () {
                cb.apply(this, resultArguments);
            });
        } else {
            if (waitingCallbacks) {
                waitingCallbacks.push(cb);
            } else {
                waitingCallbacks = [cb];
                fn(function () { // ...
                    var resultArguments = arguments;
                    waitingCallbacks.forEach(function (waitingCallback) {
                        waitingCallback.apply(this, resultArguments);
                    });
                    waitingCallbacks = null;
                });
            }
        }
    };
};

}).call(this,require('_process'))

},{"_process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/normalizeLocaleId.js":[function(require,module,exports){
/*
 * Replace - with _ and convert to lower case: en-GB => en_gb
 */
module.exports = function normalizeLocaleId(localeId) {
    return localeId && localeId.replace(/-/g, '_').toLowerCase();
};

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/normalizeProperty.js":[function(require,module,exports){
/*
 * Convert foo-bar attribute values to fooBar JavaScript keys
 */
module.exports = function normalizeProperty(str) {
	return str.replace(/-([a-z])/g, function ($0, ch) {
        return ch.toUpperCase();
    });
};

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/passerror/lib/index.js":[function(require,module,exports){
module.exports = function passError(errorCallback, successCallback) {
    return function (err) { // ...
        if (err) {
            errorCallback(err);
        } else if (successCallback) {
            successCallback.apply(this, [].slice.call(arguments, 1));
        }
    };
};

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/pegjs/lib/peg.js":[function(require,module,exports){
/*
 * PEG.js 0.7.0
 *
 * http://pegjs.majda.cz/
 *
 * Copyright (c) 2010-2012 David Majda
 * Licensend under the MIT license.
 */
var PEG = (function(undefined) {

var PEG = {
  /* PEG.js version (uses semantic versioning). */
  VERSION: "0.7.0",

  /*
   * Generates a parser from a specified grammar and returns it.
   *
   * The grammar must be a string in the format described by the metagramar in
   * the parser.pegjs file.
   *
   * Throws |PEG.parser.SyntaxError| if the grammar contains a syntax error or
   * |PEG.GrammarError| if it contains a semantic error. Note that not all
   * errors are detected during the generation and some may protrude to the
   * generated parser and cause its malfunction.
   */
  buildParser: function(grammar, options) {
    return PEG.compiler.compile(PEG.parser.parse(grammar), options);
  }
};

/* Thrown when the grammar contains an error. */

PEG.GrammarError = function(message) {
  this.name = "PEG.GrammarError";
  this.message = message;
};

PEG.GrammarError.prototype = Error.prototype;

/* Like Python's |range|, but without |step|. */
function range(start, stop) {
  if (stop === undefined) {
    stop = start;
    start = 0;
  }

  var result = new Array(Math.max(0, stop - start));
  for (var i = 0, j = start; j < stop; i++, j++) {
    result[i] = j;
  }
  return result;
}

function find(array, callback) {
  var length = array.length;
  for (var i = 0; i < length; i++) {
    if (callback(array[i])) {
      return array[i];
    }
  }
}

function contains(array, value) {
  /*
   * Stupid IE does not have Array.prototype.indexOf, otherwise this function
   * would be a one-liner.
   */
  var length = array.length;
  for (var i = 0; i < length; i++) {
    if (array[i] === value) {
      return true;
    }
  }
  return false;
}

function each(array, callback) {
  var length = array.length;
  for (var i = 0; i < length; i++) {
    callback(array[i], i);
  }
}

function map(array, callback) {
  var result = [];
  var length = array.length;
  for (var i = 0; i < length; i++) {
    result[i] = callback(array[i], i);
  }
  return result;
}

function pluck(array, key) {
  return map(array, function (e) { return e[key]; });
}

function keys(object) {
  var result = [];
  for (var key in object) {
    result.push(key);
  }
  return result;
}

function values(object) {
  var result = [];
  for (var key in object) {
    result.push(object[key]);
  }
  return result;
}

/*
 * Returns a string padded on the left to a desired length with a character.
 *
 * The code needs to be in sync with the code template in the compilation
 * function for "action" nodes.
 */
function padLeft(input, padding, length) {
  var result = input;

  var padLength = length - input.length;
  for (var i = 0; i < padLength; i++) {
    result = padding + result;
  }

  return result;
}

/*
 * Returns an escape sequence for given character. Uses \x for characters <=
 * 0xFF to save space, \u for the rest.
 *
 * The code needs to be in sync with the code template in the compilation
 * function for "action" nodes.
 */
function escape(ch) {
  var charCode = ch.charCodeAt(0);
  var escapeChar;
  var length;

  if (charCode <= 0xFF) {
    escapeChar = 'x';
    length = 2;
  } else {
    escapeChar = 'u';
    length = 4;
  }

  return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
}

/*
 * Surrounds the string with quotes and escapes characters inside so that the
 * result is a valid JavaScript string.
 *
 * The code needs to be in sync with the code template in the compilation
 * function for "action" nodes.
 */
function quote(s) {
  /*
   * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a string
   * literal except for the closing quote character, backslash, carriage return,
   * line separator, paragraph separator, and line feed. Any character may
   * appear in the form of an escape sequence.
   *
   * For portability, we also escape escape all control and non-ASCII
   * characters. Note that "\0" and "\v" escape sequences are not used because
   * JSHint does not like the first and IE the second.
   */
  return '"' + s
    .replace(/\\/g, '\\\\')  // backslash
    .replace(/"/g, '\\"')    // closing quote character
    .replace(/\x08/g, '\\b') // backspace
    .replace(/\t/g, '\\t')   // horizontal tab
    .replace(/\n/g, '\\n')   // line feed
    .replace(/\f/g, '\\f')   // form feed
    .replace(/\r/g, '\\r')   // carriage return
    .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
    + '"';
}

/*
 * Escapes characters inside the string so that it can be used as a list of
 * characters in a character class of a regular expression.
 */
function quoteForRegexpClass(s) {
  /*
   * Based on ECMA-262, 5th ed., 7.8.5 & 15.10.1.
   *
   * For portability, we also escape escape all control and non-ASCII
   * characters.
   */
  return s
    .replace(/\\/g, '\\\\')  // backslash
    .replace(/\//g, '\\/')   // closing slash
    .replace(/\]/g, '\\]')   // closing bracket
    .replace(/-/g, '\\-')    // dash
    .replace(/\0/g, '\\0')   // null
    .replace(/\t/g, '\\t')   // horizontal tab
    .replace(/\n/g, '\\n')   // line feed
    .replace(/\v/g, '\\x0B') // vertical tab
    .replace(/\f/g, '\\f')   // form feed
    .replace(/\r/g, '\\r')   // carriage return
    .replace(/[\x01-\x08\x0E-\x1F\x80-\uFFFF]/g, escape);
}

/*
 * Builds a node visitor -- a function which takes a node and any number of
 * other parameters, calls an appropriate function according to the node type,
 * passes it all its parameters and returns its value. The functions for various
 * node types are passed in a parameter to |buildNodeVisitor| as a hash.
 */
function buildNodeVisitor(functions) {
  return function(node) {
    return functions[node.type].apply(null, arguments);
  };
}

function findRuleByName(ast, name) {
  return find(ast.rules, function(r) { return r.name === name; });
}
PEG.parser = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "grammar": parse_grammar,
        "initializer": parse_initializer,
        "rule": parse_rule,
        "choice": parse_choice,
        "sequence": parse_sequence,
        "labeled": parse_labeled,
        "prefixed": parse_prefixed,
        "suffixed": parse_suffixed,
        "primary": parse_primary,
        "action": parse_action,
        "braced": parse_braced,
        "nonBraceCharacters": parse_nonBraceCharacters,
        "nonBraceCharacter": parse_nonBraceCharacter,
        "equals": parse_equals,
        "colon": parse_colon,
        "semicolon": parse_semicolon,
        "slash": parse_slash,
        "and": parse_and,
        "not": parse_not,
        "question": parse_question,
        "star": parse_star,
        "plus": parse_plus,
        "lparen": parse_lparen,
        "rparen": parse_rparen,
        "dot": parse_dot,
        "identifier": parse_identifier,
        "literal": parse_literal,
        "string": parse_string,
        "doubleQuotedString": parse_doubleQuotedString,
        "doubleQuotedCharacter": parse_doubleQuotedCharacter,
        "simpleDoubleQuotedCharacter": parse_simpleDoubleQuotedCharacter,
        "singleQuotedString": parse_singleQuotedString,
        "singleQuotedCharacter": parse_singleQuotedCharacter,
        "simpleSingleQuotedCharacter": parse_simpleSingleQuotedCharacter,
        "class": parse_class,
        "classCharacterRange": parse_classCharacterRange,
        "classCharacter": parse_classCharacter,
        "bracketDelimitedCharacter": parse_bracketDelimitedCharacter,
        "simpleBracketDelimitedCharacter": parse_simpleBracketDelimitedCharacter,
        "simpleEscapeSequence": parse_simpleEscapeSequence,
        "zeroEscapeSequence": parse_zeroEscapeSequence,
        "hexEscapeSequence": parse_hexEscapeSequence,
        "unicodeEscapeSequence": parse_unicodeEscapeSequence,
        "eolEscapeSequence": parse_eolEscapeSequence,
        "digit": parse_digit,
        "hexDigit": parse_hexDigit,
        "letter": parse_letter,
        "lowerCaseLetter": parse_lowerCaseLetter,
        "upperCaseLetter": parse_upperCaseLetter,
        "__": parse___,
        "comment": parse_comment,
        "singleLineComment": parse_singleLineComment,
        "multiLineComment": parse_multiLineComment,
        "eol": parse_eol,
        "eolChar": parse_eolChar,
        "whitespace": parse_whitespace
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "grammar";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_grammar() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse___();
        if (result0 !== null) {
          result1 = parse_initializer();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result3 = parse_rule();
            if (result3 !== null) {
              result2 = [];
              while (result3 !== null) {
                result2.push(result3);
                result3 = parse_rule();
              }
            } else {
              result2 = null;
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, initializer, rules) {
              return {
                type:        "grammar",
                initializer: initializer !== "" ? initializer : null,
                rules:       rules,
                startRule:   rules[0].name
              };
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_initializer() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_action();
        if (result0 !== null) {
          result1 = parse_semicolon();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, code) {
              return {
                type: "initializer",
                code: code
              };
            })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_rule() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_identifier();
        if (result0 !== null) {
          result1 = parse_string();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_equals();
            if (result2 !== null) {
              result3 = parse_choice();
              if (result3 !== null) {
                result4 = parse_semicolon();
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, name, displayName, expression) {
              return {
                type:        "rule",
                name:        name,
                displayName: displayName !== "" ? displayName : null,
                expression:  expression
              };
            })(pos0, result0[0], result0[1], result0[3]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_choice() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_sequence();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_slash();
          if (result2 !== null) {
            result3 = parse_sequence();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_slash();
            if (result2 !== null) {
              result3 = parse_sequence();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) {
              if (tail.length > 0) {
                var alternatives = [head].concat(map(
                    tail,
                    function(element) { return element[1]; }
                ));
                return {
                  type:         "choice",
                  alternatives: alternatives
                };
              } else {
                return head;
              }
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_sequence() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        result1 = parse_labeled();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_labeled();
        }
        if (result0 !== null) {
          result1 = parse_action();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, elements, code) {
              var expression = elements.length !== 1
                ? {
                    type:     "sequence",
                    elements: elements
                  }
                : elements[0];
              return {
                type:       "action",
                expression: expression,
                code:       code
              };
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = [];
          result1 = parse_labeled();
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_labeled();
          }
          if (result0 !== null) {
            result0 = (function(offset, elements) {
                return elements.length !== 1
                  ? {
                      type:     "sequence",
                      elements: elements
                    }
                  : elements[0];
              })(pos0, result0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_labeled() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_identifier();
        if (result0 !== null) {
          result1 = parse_colon();
          if (result1 !== null) {
            result2 = parse_prefixed();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, label, expression) {
              return {
                type:       "labeled",
                label:      label,
                expression: expression
              };
            })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_prefixed();
        }
        return result0;
      }
      
      function parse_prefixed() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_and();
        if (result0 !== null) {
          result1 = parse_action();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, code) {
              return {
                type: "semantic_and",
                code: code
              };
            })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_and();
          if (result0 !== null) {
            result1 = parse_suffixed();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, expression) {
                return {
                  type:       "simple_and",
                  expression: expression
                };
              })(pos0, result0[1]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            result0 = parse_not();
            if (result0 !== null) {
              result1 = parse_action();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, code) {
                  return {
                    type: "semantic_not",
                    code: code
                  };
                })(pos0, result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              pos1 = pos;
              result0 = parse_not();
              if (result0 !== null) {
                result1 = parse_suffixed();
                if (result1 !== null) {
                  result0 = [result0, result1];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 !== null) {
                result0 = (function(offset, expression) {
                    return {
                      type:       "simple_not",
                      expression: expression
                    };
                  })(pos0, result0[1]);
              }
              if (result0 === null) {
                pos = pos0;
              }
              if (result0 === null) {
                result0 = parse_suffixed();
              }
            }
          }
        }
        return result0;
      }
      
      function parse_suffixed() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_primary();
        if (result0 !== null) {
          result1 = parse_question();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, expression) {
              return {
                type:       "optional",
                expression: expression
              };
            })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_primary();
          if (result0 !== null) {
            result1 = parse_star();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, expression) {
                return {
                  type:       "zero_or_more",
                  expression: expression
                };
              })(pos0, result0[0]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            result0 = parse_primary();
            if (result0 !== null) {
              result1 = parse_plus();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, expression) {
                  return {
                    type:       "one_or_more",
                    expression: expression
                  };
                })(pos0, result0[0]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              result0 = parse_primary();
            }
          }
        }
        return result0;
      }
      
      function parse_primary() {
        var result0, result1, result2;
        var pos0, pos1, pos2, pos3;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_identifier();
        if (result0 !== null) {
          pos2 = pos;
          reportFailures++;
          pos3 = pos;
          result1 = parse_string();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_equals();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos3;
            }
          } else {
            result1 = null;
            pos = pos3;
          }
          reportFailures--;
          if (result1 === null) {
            result1 = "";
          } else {
            result1 = null;
            pos = pos2;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, name) {
              return {
                type: "rule_ref",
                name: name
              };
            })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_literal();
          if (result0 === null) {
            pos0 = pos;
            result0 = parse_dot();
            if (result0 !== null) {
              result0 = (function(offset) { return { type: "any" }; })(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              result0 = parse_class();
              if (result0 === null) {
                pos0 = pos;
                pos1 = pos;
                result0 = parse_lparen();
                if (result0 !== null) {
                  result1 = parse_choice();
                  if (result1 !== null) {
                    result2 = parse_rparen();
                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
                if (result0 !== null) {
                  result0 = (function(offset, expression) { return expression; })(pos0, result0[1]);
                }
                if (result0 === null) {
                  pos = pos0;
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_action() {
        var result0, result1;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_braced();
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, braced) { return braced.substr(1, braced.length - 2); })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("action");
        }
        return result0;
      }
      
      function parse_braced() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 123) {
          result0 = "{";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"{\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_braced();
          if (result2 === null) {
            result2 = parse_nonBraceCharacter();
          }
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_braced();
            if (result2 === null) {
              result2 = parse_nonBraceCharacter();
            }
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 125) {
              result2 = "}";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"}\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, parts) {
              return "{" + parts.join("") + "}";
            })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_nonBraceCharacters() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_nonBraceCharacter();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_nonBraceCharacter();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, chars) { return chars.join(""); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_nonBraceCharacter() {
        var result0;
        
        if (/^[^{}]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[^{}]");
          }
        }
        return result0;
      }
      
      function parse_equals() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 61) {
          result0 = "=";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"=\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "="; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_colon() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 58) {
          result0 = ":";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\":\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return ":"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_semicolon() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 59) {
          result0 = ";";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\";\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return ";"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_slash() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 47) {
          result0 = "/";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "/"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_and() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 38) {
          result0 = "&";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"&\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "&"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_not() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 33) {
          result0 = "!";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"!\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "!"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_question() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 63) {
          result0 = "?";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"?\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "?"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_star() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 42) {
          result0 = "*";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"*\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "*"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_plus() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 43) {
          result0 = "+";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"+\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "+"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_lparen() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 40) {
          result0 = "(";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "("; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_rparen() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 41) {
          result0 = ")";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\")\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return ")"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_dot() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 46) {
          result0 = ".";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\".\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "."; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_identifier() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_letter();
        if (result0 === null) {
          if (input.charCodeAt(pos) === 95) {
            result0 = "_";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"_\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 36) {
              result0 = "$";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"$\"");
              }
            }
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_letter();
          if (result2 === null) {
            result2 = parse_digit();
            if (result2 === null) {
              if (input.charCodeAt(pos) === 95) {
                result2 = "_";
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"_\"");
                }
              }
              if (result2 === null) {
                if (input.charCodeAt(pos) === 36) {
                  result2 = "$";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"$\"");
                  }
                }
              }
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_letter();
            if (result2 === null) {
              result2 = parse_digit();
              if (result2 === null) {
                if (input.charCodeAt(pos) === 95) {
                  result2 = "_";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"_\"");
                  }
                }
                if (result2 === null) {
                  if (input.charCodeAt(pos) === 36) {
                    result2 = "$";
                    pos++;
                  } else {
                    result2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"$\"");
                    }
                  }
                }
              }
            }
          }
          if (result1 !== null) {
            result2 = parse___();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) {
              return head + tail.join("");
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("identifier");
        }
        return result0;
      }
      
      function parse_literal() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_doubleQuotedString();
        if (result0 === null) {
          result0 = parse_singleQuotedString();
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 105) {
            result1 = "i";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"i\"");
            }
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse___();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, value, flags) {
              return {
                type:       "literal",
                value:      value,
                ignoreCase: flags === "i"
              };
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("literal");
        }
        return result0;
      }
      
      function parse_string() {
        var result0, result1;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_doubleQuotedString();
        if (result0 === null) {
          result0 = parse_singleQuotedString();
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, string) { return string; })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("string");
        }
        return result0;
      }
      
      function parse_doubleQuotedString() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 34) {
          result0 = "\"";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\"\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_doubleQuotedCharacter();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_doubleQuotedCharacter();
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 34) {
              result2 = "\"";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\\"\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, chars) { return chars.join(""); })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_doubleQuotedCharacter() {
        var result0;
        
        result0 = parse_simpleDoubleQuotedCharacter();
        if (result0 === null) {
          result0 = parse_simpleEscapeSequence();
          if (result0 === null) {
            result0 = parse_zeroEscapeSequence();
            if (result0 === null) {
              result0 = parse_hexEscapeSequence();
              if (result0 === null) {
                result0 = parse_unicodeEscapeSequence();
                if (result0 === null) {
                  result0 = parse_eolEscapeSequence();
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_simpleDoubleQuotedCharacter() {
        var result0, result1;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        pos2 = pos;
        reportFailures++;
        if (input.charCodeAt(pos) === 34) {
          result0 = "\"";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\"\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 92) {
            result0 = "\\";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\\\"");
            }
          }
          if (result0 === null) {
            result0 = parse_eolChar();
          }
        }
        reportFailures--;
        if (result0 === null) {
          result0 = "";
        } else {
          result0 = null;
          pos = pos2;
        }
        if (result0 !== null) {
          if (input.length > pos) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("any character");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, char_) { return char_; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_singleQuotedString() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 39) {
          result0 = "'";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"'\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_singleQuotedCharacter();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_singleQuotedCharacter();
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 39) {
              result2 = "'";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"'\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, chars) { return chars.join(""); })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_singleQuotedCharacter() {
        var result0;
        
        result0 = parse_simpleSingleQuotedCharacter();
        if (result0 === null) {
          result0 = parse_simpleEscapeSequence();
          if (result0 === null) {
            result0 = parse_zeroEscapeSequence();
            if (result0 === null) {
              result0 = parse_hexEscapeSequence();
              if (result0 === null) {
                result0 = parse_unicodeEscapeSequence();
                if (result0 === null) {
                  result0 = parse_eolEscapeSequence();
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_simpleSingleQuotedCharacter() {
        var result0, result1;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        pos2 = pos;
        reportFailures++;
        if (input.charCodeAt(pos) === 39) {
          result0 = "'";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"'\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 92) {
            result0 = "\\";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\\\"");
            }
          }
          if (result0 === null) {
            result0 = parse_eolChar();
          }
        }
        reportFailures--;
        if (result0 === null) {
          result0 = "";
        } else {
          result0 = null;
          pos = pos2;
        }
        if (result0 !== null) {
          if (input.length > pos) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("any character");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, char_) { return char_; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_class() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 94) {
            result1 = "^";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"^\"");
            }
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = [];
            result3 = parse_classCharacterRange();
            if (result3 === null) {
              result3 = parse_classCharacter();
            }
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_classCharacterRange();
              if (result3 === null) {
                result3 = parse_classCharacter();
              }
            }
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 93) {
                result3 = "]";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"]\"");
                }
              }
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 105) {
                  result4 = "i";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"i\"");
                  }
                }
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result5 = parse___();
                  if (result5 !== null) {
                    result0 = [result0, result1, result2, result3, result4, result5];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, inverted, parts, flags) {
              var partsConverted = map(parts, function(part) { return part.data; });
              var rawText = "["
                + inverted
                + map(parts, function(part) { return part.rawText; }).join("")
                + "]"
                + flags;
        
              return {
                type:       "class",
                inverted:   inverted === "^",
                ignoreCase: flags === "i",
                parts:      partsConverted,
                // FIXME: Get the raw text from the input directly.
                rawText:    rawText
              };
            })(pos0, result0[1], result0[2], result0[4]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("character class");
        }
        return result0;
      }
      
      function parse_classCharacterRange() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_classCharacter();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 45) {
            result1 = "-";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_classCharacter();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, begin, end) {
              if (begin.data.charCodeAt(0) > end.data.charCodeAt(0)) {
                throw new this.SyntaxError(
                  "Invalid character range: " + begin.rawText + "-" + end.rawText + "."
                );
              }
        
              return {
                data:    [begin.data, end.data],
                // FIXME: Get the raw text from the input directly.
                rawText: begin.rawText + "-" + end.rawText
              };
            })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_classCharacter() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_bracketDelimitedCharacter();
        if (result0 !== null) {
          result0 = (function(offset, char_) {
              return {
                data:    char_,
                // FIXME: Get the raw text from the input directly.
                rawText: quoteForRegexpClass(char_)
              };
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_bracketDelimitedCharacter() {
        var result0;
        
        result0 = parse_simpleBracketDelimitedCharacter();
        if (result0 === null) {
          result0 = parse_simpleEscapeSequence();
          if (result0 === null) {
            result0 = parse_zeroEscapeSequence();
            if (result0 === null) {
              result0 = parse_hexEscapeSequence();
              if (result0 === null) {
                result0 = parse_unicodeEscapeSequence();
                if (result0 === null) {
                  result0 = parse_eolEscapeSequence();
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_simpleBracketDelimitedCharacter() {
        var result0, result1;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        pos2 = pos;
        reportFailures++;
        if (input.charCodeAt(pos) === 93) {
          result0 = "]";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"]\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 92) {
            result0 = "\\";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\\\"");
            }
          }
          if (result0 === null) {
            result0 = parse_eolChar();
          }
        }
        reportFailures--;
        if (result0 === null) {
          result0 = "";
        } else {
          result0 = null;
          pos = pos2;
        }
        if (result0 !== null) {
          if (input.length > pos) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("any character");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, char_) { return char_; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_simpleEscapeSequence() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 92) {
          result0 = "\\";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\\"");
          }
        }
        if (result0 !== null) {
          pos2 = pos;
          reportFailures++;
          result1 = parse_digit();
          if (result1 === null) {
            if (input.charCodeAt(pos) === 120) {
              result1 = "x";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"x\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 117) {
                result1 = "u";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"u\"");
                }
              }
              if (result1 === null) {
                result1 = parse_eolChar();
              }
            }
          }
          reportFailures--;
          if (result1 === null) {
            result1 = "";
          } else {
            result1 = null;
            pos = pos2;
          }
          if (result1 !== null) {
            if (input.length > pos) {
              result2 = input.charAt(pos);
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("any character");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, char_) {
              return char_
                .replace("b", "\b")
                .replace("f", "\f")
                .replace("n", "\n")
                .replace("r", "\r")
                .replace("t", "\t")
                .replace("v", "\x0B"); // IE does not recognize "\v".
            })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_zeroEscapeSequence() {
        var result0, result1;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2) === "\\0") {
          result0 = "\\0";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\0\"");
          }
        }
        if (result0 !== null) {
          pos2 = pos;
          reportFailures++;
          result1 = parse_digit();
          reportFailures--;
          if (result1 === null) {
            result1 = "";
          } else {
            result1 = null;
            pos = pos2;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "\x00"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hexEscapeSequence() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2) === "\\x") {
          result0 = "\\x";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\x\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_hexDigit();
          if (result1 !== null) {
            result2 = parse_hexDigit();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, h1, h2) {
              return String.fromCharCode(parseInt(h1 + h2, 16));
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_unicodeEscapeSequence() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2) === "\\u") {
          result0 = "\\u";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\u\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_hexDigit();
          if (result1 !== null) {
            result2 = parse_hexDigit();
            if (result2 !== null) {
              result3 = parse_hexDigit();
              if (result3 !== null) {
                result4 = parse_hexDigit();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, h1, h2, h3, h4) {
              return String.fromCharCode(parseInt(h1 + h2 + h3 + h4, 16));
            })(pos0, result0[1], result0[2], result0[3], result0[4]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_eolEscapeSequence() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 92) {
          result0 = "\\";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_eol();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, eol) { return eol; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_digit() {
        var result0;
        
        if (/^[0-9]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9]");
          }
        }
        return result0;
      }
      
      function parse_hexDigit() {
        var result0;
        
        if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9a-fA-F]");
          }
        }
        return result0;
      }
      
      function parse_letter() {
        var result0;
        
        result0 = parse_lowerCaseLetter();
        if (result0 === null) {
          result0 = parse_upperCaseLetter();
        }
        return result0;
      }
      
      function parse_lowerCaseLetter() {
        var result0;
        
        if (/^[a-z]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-z]");
          }
        }
        return result0;
      }
      
      function parse_upperCaseLetter() {
        var result0;
        
        if (/^[A-Z]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[A-Z]");
          }
        }
        return result0;
      }
      
      function parse___() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_whitespace();
        if (result1 === null) {
          result1 = parse_eol();
          if (result1 === null) {
            result1 = parse_comment();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_whitespace();
          if (result1 === null) {
            result1 = parse_eol();
            if (result1 === null) {
              result1 = parse_comment();
            }
          }
        }
        return result0;
      }
      
      function parse_comment() {
        var result0;
        
        reportFailures++;
        result0 = parse_singleLineComment();
        if (result0 === null) {
          result0 = parse_multiLineComment();
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("comment");
        }
        return result0;
      }
      
      function parse_singleLineComment() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "//") {
          result0 = "//";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"//\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          pos2 = pos;
          reportFailures++;
          result2 = parse_eolChar();
          reportFailures--;
          if (result2 === null) {
            result2 = "";
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            if (input.length > pos) {
              result3 = input.charAt(pos);
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("any character");
              }
            }
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            result2 = parse_eolChar();
            reportFailures--;
            if (result2 === null) {
              result2 = "";
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              if (input.length > pos) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("any character");
                }
              }
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_multiLineComment() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "/*") {
          result0 = "/*";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/*\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          pos2 = pos;
          reportFailures++;
          if (input.substr(pos, 2) === "*/") {
            result2 = "*/";
            pos += 2;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\"*/\"");
            }
          }
          reportFailures--;
          if (result2 === null) {
            result2 = "";
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            if (input.length > pos) {
              result3 = input.charAt(pos);
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("any character");
              }
            }
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            reportFailures--;
            if (result2 === null) {
              result2 = "";
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              if (input.length > pos) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("any character");
                }
              }
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_eol() {
        var result0;
        
        reportFailures++;
        if (input.charCodeAt(pos) === 10) {
          result0 = "\n";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\n\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 2) === "\r\n") {
            result0 = "\r\n";
            pos += 2;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\r\\n\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 13) {
              result0 = "\r";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\r\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 8232) {
                result0 = "\u2028";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\u2028\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 8233) {
                  result0 = "\u2029";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\u2029\"");
                  }
                }
              }
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("end of line");
        }
        return result0;
      }
      
      function parse_eolChar() {
        var result0;
        
        if (/^[\n\r\u2028\u2029]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\n\\r\\u2028\\u2029]");
          }
        }
        return result0;
      }
      
      function parse_whitespace() {
        var result0;
        
        reportFailures++;
        if (/^[ \t\x0B\f\xA0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[ \\t\\x0B\\f\\xA0\\uFEFF\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000]");
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("whitespace");
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();
PEG.compiler = {
  /*
   * Names of passes that will get run during the compilation (in the specified
   * order).
   */
  appliedPassNames: [
    "reportMissingRules",
    "reportLeftRecursion",
    "removeProxyRules",
    "computeVarNames",
    "computeParams"
  ],

  /*
   * Generates a parser from a specified grammar AST. Throws |PEG.GrammarError|
   * if the AST contains a semantic error. Note that not all errors are detected
   * during the generation and some may protrude to the generated parser and
   * cause its malfunction.
   */
  compile: function(ast, options) {
    var that = this;

    each(this.appliedPassNames, function(passName) {
      that.passes[passName](ast);
    });

    var source = this.emitter(ast, options);
    var result = eval(source);
    result._source = source;

    return result;
  }
};

/*
 * Compiler passes.
 *
 * Each pass is a function that is passed the AST. It can perform checks on it
 * or modify it as needed. If the pass encounters a semantic error, it throws
 * |PEG.GrammarError|.
 */
PEG.compiler.passes = {
  /* Checks that all referenced rules exist. */
  reportMissingRules: function(ast) {
    function nop() {}

    function checkExpression(node) { check(node.expression); }

    function checkSubnodes(propertyName) {
      return function(node) { each(node[propertyName], check); };
    }

    var check = buildNodeVisitor({
      grammar:      checkSubnodes("rules"),
      rule:         checkExpression,
      choice:       checkSubnodes("alternatives"),
      sequence:     checkSubnodes("elements"),
      labeled:      checkExpression,
      simple_and:   checkExpression,
      simple_not:   checkExpression,
      semantic_and: nop,
      semantic_not: nop,
      optional:     checkExpression,
      zero_or_more: checkExpression,
      one_or_more:  checkExpression,
      action:       checkExpression,

      rule_ref:
        function(node) {
          if (!findRuleByName(ast, node.name)) {
            throw new PEG.GrammarError(
              "Referenced rule \"" + node.name + "\" does not exist."
            );
          }
        },

      literal:      nop,
      any:          nop,
      "class":      nop
    });

    check(ast);
  },

  /* Checks that no left recursion is present. */
  reportLeftRecursion: function(ast) {
    function nop() {}

    function checkExpression(node, appliedRules) {
      check(node.expression, appliedRules);
    }

    function checkSubnodes(propertyName) {
      return function(node, appliedRules) {
        each(node[propertyName], function(subnode) {
          check(subnode, appliedRules);
        });
      };
    }

    var check = buildNodeVisitor({
      grammar:     checkSubnodes("rules"),

      rule:
        function(node, appliedRules) {
          check(node.expression, appliedRules.concat(node.name));
        },

      choice:      checkSubnodes("alternatives"),

      sequence:
        function(node, appliedRules) {
          if (node.elements.length > 0) {
            check(node.elements[0], appliedRules);
          }
        },

      labeled:      checkExpression,
      simple_and:   checkExpression,
      simple_not:   checkExpression,
      semantic_and: nop,
      semantic_not: nop,
      optional:     checkExpression,
      zero_or_more: checkExpression,
      one_or_more:  checkExpression,
      action:       checkExpression,

      rule_ref:
        function(node, appliedRules) {
          if (contains(appliedRules, node.name)) {
            throw new PEG.GrammarError(
              "Left recursion detected for rule \"" + node.name + "\"."
            );
          }
          check(findRuleByName(ast, node.name), appliedRules);
        },

      literal:      nop,
      any:          nop,
      "class":      nop
    });

    check(ast, []);
  },

  /*
   * Removes proxy rules -- that is, rules that only delegate to other rule.
   */
  removeProxyRules: function(ast) {
    function isProxyRule(node) {
      return node.type === "rule" && node.expression.type === "rule_ref";
    }

    function replaceRuleRefs(ast, from, to) {
      function nop() {}

      function replaceInExpression(node, from, to) {
        replace(node.expression, from, to);
      }

      function replaceInSubnodes(propertyName) {
        return function(node, from, to) {
          each(node[propertyName], function(subnode) {
            replace(subnode, from, to);
          });
        };
      }

      var replace = buildNodeVisitor({
        grammar:      replaceInSubnodes("rules"),
        rule:         replaceInExpression,
        choice:       replaceInSubnodes("alternatives"),
        sequence:     replaceInSubnodes("elements"),
        labeled:      replaceInExpression,
        simple_and:   replaceInExpression,
        simple_not:   replaceInExpression,
        semantic_and: nop,
        semantic_not: nop,
        optional:     replaceInExpression,
        zero_or_more: replaceInExpression,
        one_or_more:  replaceInExpression,
        action:       replaceInExpression,

        rule_ref:
          function(node, from, to) {
            if (node.name === from) {
              node.name = to;
            }
          },

        literal:      nop,
        any:          nop,
        "class":      nop
      });

      replace(ast, from, to);
    }

    var indices = [];

    each(ast.rules, function(rule, i) {
      if (isProxyRule(rule)) {
        replaceRuleRefs(ast, rule.name, rule.expression.name);
        if (rule.name === ast.startRule) {
          ast.startRule = rule.expression.name;
        }
        indices.push(i);
      }
    });

    indices.reverse();

    each(indices, function(index) {
      ast.rules.splice(index, 1);
    });
  },

  /*
   * Computes names of variables used for storing match results and parse
   * positions in generated code. These variables are organized as two stacks.
   * The following will hold after running this pass:
   *
   *   * All nodes except "grammar" and "rule" nodes will have a |resultVar|
   *     property. It will contain a name of the variable that will store a
   *     match result of the expression represented by the node in generated
   *     code.
   *
   *   * Some nodes will have a |posVar| property. It will contain a name of the
   *     variable that will store a parse position in generated code.
   *
   *   * All "rule" nodes will contain |resultVars| and |posVars| properties.
   *     They will contain a list of values of |resultVar| and |posVar|
   *     properties used in rule's subnodes. (This is useful to declare
   *     variables in generated code.)
   */
  computeVarNames: function(ast) {
    function resultVar(index) { return "result" + index; }
    function posVar(index)    { return "pos"    + index; }

    function computeLeaf(node, index) {
      node.resultVar = resultVar(index.result);

      return { result: 0, pos: 0 };
    }

    function computeFromExpression(delta) {
      return function(node, index) {
        var depth = compute(
              node.expression,
              {
                result: index.result + delta.result,
                pos:    index.pos    + delta.pos
              }
            );

        node.resultVar = resultVar(index.result);
        if (delta.pos !== 0) {
          node.posVar = posVar(index.pos);
        }

        return {
          result: depth.result + delta.result,
          pos:    depth.pos    + delta.pos
        };
      };
    }

    var compute = buildNodeVisitor({
      grammar:
        function(node, index) {
          each(node.rules, function(node) {
            compute(node, index);
          });
        },

      rule:
        function(node, index) {
          var depth = compute(node.expression, index);

          node.resultVar  = resultVar(index.result);
          node.resultVars = map(range(depth.result + 1), resultVar);
          node.posVars    = map(range(depth.pos),        posVar);
        },

      choice:
        function(node, index) {
          var depths = map(node.alternatives, function(alternative) {
            return compute(alternative, index);
          });

          node.resultVar = resultVar(index.result);

          return {
            result: Math.max.apply(null, pluck(depths, "result")),
            pos:    Math.max.apply(null, pluck(depths, "pos"))
          };
        },

      sequence:
        function(node, index) {
          var depths = map(node.elements, function(element, i) {
            return compute(
              element,
              { result: index.result + i, pos: index.pos + 1 }
            );
          });

          node.resultVar = resultVar(index.result);
          node.posVar    = posVar(index.pos);

          return {
            result:
              node.elements.length > 0
                ? Math.max.apply(
                    null,
                    map(depths, function(d, i) { return i + d.result; })
                  )
                : 0,

            pos:
              node.elements.length > 0
                ? 1 + Math.max.apply(null, pluck(depths, "pos"))
                : 1
          };
        },

      labeled:      computeFromExpression({ result: 0, pos: 0 }),
      simple_and:   computeFromExpression({ result: 0, pos: 1 }),
      simple_not:   computeFromExpression({ result: 0, pos: 1 }),
      semantic_and: computeLeaf,
      semantic_not: computeLeaf,
      optional:     computeFromExpression({ result: 0, pos: 0 }),
      zero_or_more: computeFromExpression({ result: 1, pos: 0 }),
      one_or_more:  computeFromExpression({ result: 1, pos: 0 }),
      action:       computeFromExpression({ result: 0, pos: 1 }),
      rule_ref:     computeLeaf,
      literal:      computeLeaf,
      any:          computeLeaf,
      "class":      computeLeaf
    });

    compute(ast, { result: 0, pos: 0 });
  },

  /*
   * This pass walks through the AST and tracks what labels are visible at each
   * point. For "action", "semantic_and" and "semantic_or" nodes it computes
   * parameter names and values for the function used in generated code. (In the
   * emitter, user's code is wrapped into a function that is immediately
   * executed. Its parameter names correspond to visible labels and its
   * parameter values to their captured values). Implicitly, this pass defines
   * scoping rules for labels.
   *
   * After running this pass, all "action", "semantic_and" and "semantic_or"
   * nodes will have a |params| property containing an object mapping parameter
   * names to the expressions that will be used as their values.
   */
  computeParams: function(ast) {
    var envs = [];

    function scoped(f) {
      envs.push({});
      f();
      envs.pop();
    }

    function nop() {}

    function computeForScopedExpression(node) {
      scoped(function() { compute(node.expression); });
    }

    function computeParams(node) {
      var env = envs[envs.length - 1], params = {}, name;

      for (name in env) {
        params[name] = env[name];
      }
      node.params = params;
    }

    var compute = buildNodeVisitor({
      grammar:
        function(node) {
          each(node.rules, compute);
        },

      rule:         computeForScopedExpression,

      choice:
        function(node) {
          scoped(function() { each(node.alternatives, compute); });
        },

      sequence:
        function(node) {
          var env = envs[envs.length - 1], name;

          function fixup(name) {
            each(pluck(node.elements, "resultVar"), function(resultVar, i) {
              if ((new RegExp("^" + resultVar + "(\\[\\d+\\])*$")).test(env[name])) {
                env[name] = node.resultVar + "[" + i + "]"
                          + env[name].substr(resultVar.length);
              }
            });
          }

          each(node.elements, compute);

          for (name in env) {
            fixup(name);
          }
        },

      labeled:
        function(node) {
          envs[envs.length - 1][node.label] = node.resultVar;

          scoped(function() { compute(node.expression); });
        },

      simple_and:   computeForScopedExpression,
      simple_not:   computeForScopedExpression,
      semantic_and: computeParams,
      semantic_not: computeParams,
      optional:     computeForScopedExpression,
      zero_or_more: computeForScopedExpression,
      one_or_more:  computeForScopedExpression,

      action:
        function(node) {
          scoped(function() {
            compute(node.expression);
            computeParams(node);
          });
        },

      rule_ref:     nop,
      literal:      nop,
      any:          nop,
      "class":      nop
    });

    compute(ast);
  }
};
/* Emits the generated code for the AST. */
PEG.compiler.emitter = function(ast, options) {
  options = options || {};
  if (options.cache === undefined) {
    options.cache = false;
  }
  if (options.trackLineAndColumn === undefined) {
    options.trackLineAndColumn = false;
  }

  /*
   * Codie 1.1.0
   *
   * https://github.com/dmajda/codie
   *
   * Copyright (c) 2011-2012 David Majda
   * Licensend under the MIT license.
   */
  var Codie = (function(undefined) {

  function stringEscape(s) {
    function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
    return s
      .replace(/\\/g,   '\\\\') // backslash
      .replace(/"/g,    '\\"')  // closing double quote
      .replace(/\x08/g, '\\b')  // backspace
      .replace(/\t/g,   '\\t')  // horizontal tab
      .replace(/\n/g,   '\\n')  // line feed
      .replace(/\f/g,   '\\f')  // form feed
      .replace(/\r/g,   '\\r')  // carriage return
      .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
      .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
      .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
  }

  function push(s) { return '__p.push(' + s + ');'; }

  function pushRaw(template, length, state) {
    function unindent(code, level, unindentFirst) {
      return code.replace(
        new RegExp('^.{' + level +'}', "gm"),
        function(str, offset) {
          if (offset === 0) {
            return unindentFirst ? '' : str;
          } else {
            return "";
          }
        }
      );
    }

    var escaped = stringEscape(unindent(
          template.substring(0, length),
          state.indentLevel(),
          state.atBOL
        ));

    return escaped.length > 0 ? push('"' + escaped + '"') : '';
  }


  var Codie = {
    /* Codie version (uses semantic versioning). */
    VERSION: "1.1.0",

    /*
     * Specifies by how many characters do #if/#else and #for unindent their
     * content in the generated code.
     */
    indentStep: 2,

    /* Description of #-commands. Extend to define your own commands. */
    commands: {
      "if":   {
        params:  /^(.*)$/,
        compile: function(state, prefix, params) {
          return ['if(' + params[0] + '){', []];
        },
        stackOp: "push"
      },
      "else": {
        params:  /^$/,
        compile: function(state) {
          var stack = state.commandStack,
              insideElse = stack[stack.length - 1] === "else",
              insideIf   = stack[stack.length - 1] === "if";

          if (insideElse) { throw new Error("Multiple #elses."); }
          if (!insideIf)  { throw new Error("Using #else outside of #if."); }

          return ['}else{', []];
        },
        stackOp: "replace"
      },
      "for":  {
        params:  /^([a-zA-Z_][a-zA-Z0-9_]*)[ \t]+in[ \t]+(.*)$/,
        init:    function(state) {
          state.forCurrLevel = 0;  // current level of #for loop nesting
          state.forMaxLevel  = 0;  // maximum level of #for loop nesting
        },
        compile: function(state, prefix, params) {
          var c = '__c' + state.forCurrLevel, // __c for "collection"
              l = '__l' + state.forCurrLevel, // __l for "length"
              i = '__i' + state.forCurrLevel; // __i for "index"

          state.forCurrLevel++;
          if (state.forMaxLevel < state.forCurrLevel) {
            state.forMaxLevel = state.forCurrLevel;
          }

          return [
            c + '=' + params[1] + ';'
              + l + '=' + c + '.length;'
              + 'for(' + i + '=0;' + i + '<' + l + ';' + i + '++){'
              + params[0] + '=' + c + '[' + i + '];',
            [params[0], c, l, i]
          ];
        },
        exit:    function(state) { state.forCurrLevel--; },
        stackOp: "push"
      },
      "end":  {
        params:  /^$/,
        compile: function(state) {
          var stack = state.commandStack, exit;

          if (stack.length === 0) { throw new Error("Too many #ends."); }

          exit = Codie.commands[stack[stack.length - 1]].exit;
          if (exit) { exit(state); }

          return ['}', []];
        },
        stackOp: "pop"
      },
      "block": {
        params: /^(.*)$/,
        compile: function(state, prefix, params) {
          var x = '__x', // __x for "prefix",
              n = '__n', // __n for "lines"
              l = '__l', // __l for "length"
              i = '__i'; // __i for "index"

          /*
           * Originally, the generated code used |String.prototype.replace|, but
           * it is buggy in certain versions of V8 so it was rewritten. See the
           * tests for details.
           */
          return [
            x + '="' + stringEscape(prefix.substring(state.indentLevel())) + '";'
              + n + '=(' + params[0] + ').toString().split("\\n");'
              + l + '=' + n + '.length;'
              + 'for(' + i + '=0;' + i + '<' + l + ';' + i + '++){'
              + n + '[' + i +']=' + x + '+' + n + '[' + i + ']+"\\n";'
              + '}'
              + push(n + '.join("")'),
            [x, n, l, i]
          ];
        },
        stackOp: "nop"
      }
    },

    /*
     * Compiles a template into a function. When called, this function will
     * execute the template in the context of an object passed in a parameter and
     * return the result.
     */
    template: function(template) {
      var stackOps = {
        push:    function(stack, name) { stack.push(name); },
        replace: function(stack, name) { stack[stack.length - 1] = name; },
        pop:     function(stack)       { stack.pop(); },
        nop:     function()            { }
      };

      function compileExpr(state, expr) {
        state.atBOL = false;
        return [push(expr), []];
      }

      function compileCommand(state, prefix, name, params) {
        var command, match, result;

        command = Codie.commands[name];
        if (!command) { throw new Error("Unknown command: #" + name + "."); }

        match = command.params.exec(params);
        if (match === null) {
          throw new Error(
            "Invalid params for command #" + name + ": " + params + "."
          );
        }

        result = command.compile(state, prefix, match.slice(1));
        stackOps[command.stackOp](state.commandStack, name);
        state.atBOL = true;
        return result;
      }

      var state = {               // compilation state
            commandStack: [],     //   stack of commands as they were nested
            atBOL:        true,   //   is the next character to process at BOL?
            indentLevel:  function() {
              return Codie.indentStep * this.commandStack.length;
            }
          },
          code = '',              // generated template function code
          vars = ['__p=[]'],      // variables used by generated code
          name, match, result, i;

      /* Initialize state. */
      for (name in Codie.commands) {
        if (Codie.commands[name].init) { Codie.commands[name].init(state); }
      }

      /* Compile the template. */
      while ((match = /^([ \t]*)#([a-zA-Z_][a-zA-Z0-9_]*)(?:[ \t]+([^ \t\n][^\n]*))?[ \t]*(?:\n|$)|#\{([^}]*)\}/m.exec(template)) !== null) {
        code += pushRaw(template, match.index, state);
        result = match[2] !== undefined && match[2] !== ""
          ? compileCommand(state, match[1], match[2], match[3] || "") // #-command
          : compileExpr(state, match[4]);                             // #{...}
        code += result[0];
        vars = vars.concat(result[1]);
        template = template.substring(match.index + match[0].length);
      }
      code += pushRaw(template, template.length, state);

      /* Check the final state. */
      if (state.commandStack.length > 0) { throw new Error("Missing #end."); }

      /* Sanitize the list of variables used by commands. */
      vars.sort();
      for (i = 0; i < vars.length; i++) {
        if (vars[i] === vars[i - 1]) { vars.splice(i--, 1); }
      }

      /* Create the resulting function. */
      return new Function("__v", [
        '__v=__v||{};',
        'var ' + vars.join(',') + ';',
        'with(__v){',
        code,
        'return __p.join("").replace(/^\\n+|\\n+$/g,"");};'
      ].join(''));
    }
  };

  return Codie;

  })();

  var templates = (function() {
    var name,
        templates = {},
        sources = {
          grammar: [
            '(function(){',
            '  /*',
            '   * Generated by PEG.js 0.7.0.',
            '   *',
            '   * http://pegjs.majda.cz/',
            '   */',
            '  ',
            /* This needs to be in sync with |quote| in utils.js. */
            '  function quote(s) {',
            '    /*',
            '     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a',
            '     * string literal except for the closing quote character, backslash,',
            '     * carriage return, line separator, paragraph separator, and line feed.',
            '     * Any character may appear in the form of an escape sequence.',
            '     *',
            '     * For portability, we also escape escape all control and non-ASCII',
            '     * characters. Note that "\\0" and "\\v" escape sequences are not used',
            '     * because JSHint does not like the first and IE the second.',
            '     */',
            '     return \'"\' + s',
            '      .replace(/\\\\/g, \'\\\\\\\\\')  // backslash',
            '      .replace(/"/g, \'\\\\"\')    // closing quote character',
            '      .replace(/\\x08/g, \'\\\\b\') // backspace',
            '      .replace(/\\t/g, \'\\\\t\')   // horizontal tab',
            '      .replace(/\\n/g, \'\\\\n\')   // line feed',
            '      .replace(/\\f/g, \'\\\\f\')   // form feed',
            '      .replace(/\\r/g, \'\\\\r\')   // carriage return',
            '      .replace(/[\\x00-\\x07\\x0B\\x0E-\\x1F\\x80-\\uFFFF]/g, escape)',
            '      + \'"\';',
            '  }',
            '  ',
            '  var result = {',
            '    /*',
            '     * Parses the input with a generated parser. If the parsing is successfull,',
            '     * returns a value explicitly or implicitly specified by the grammar from',
            '     * which the parser was generated (see |PEG.buildParser|). If the parsing is',
            '     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.',
            '     */',
            '    parse: function(input, startRule) {',
            '      var parseFunctions = {',
            '        #for rule in node.rules',
            '          #{string(rule.name) + ": parse_" + rule.name + (rule !== node.rules[node.rules.length - 1] ? "," : "")}',
            '        #end',
            '      };',
            '      ',
            '      if (startRule !== undefined) {',
            '        if (parseFunctions[startRule] === undefined) {',
            '          throw new Error("Invalid rule name: " + quote(startRule) + ".");',
            '        }',
            '      } else {',
            '        startRule = #{string(node.startRule)};',
            '      }',
            '      ',
            '      #{posInit("pos")};',
            '      var reportFailures = 0;', // 0 = report, anything > 0 = do not report
            '      #{posInit("rightmostFailuresPos")};',
            '      var rightmostFailuresExpected = [];',
            '      #if options.cache',
            '        var cache = {};',
            '      #end',
            '      ',
            /* This needs to be in sync with |padLeft| in utils.js. */
            '      function padLeft(input, padding, length) {',
            '        var result = input;',
            '        ',
            '        var padLength = length - input.length;',
            '        for (var i = 0; i < padLength; i++) {',
            '          result = padding + result;',
            '        }',
            '        ',
            '        return result;',
            '      }',
            '      ',
            /* This needs to be in sync with |escape| in utils.js. */
            '      function escape(ch) {',
            '        var charCode = ch.charCodeAt(0);',
            '        var escapeChar;',
            '        var length;',
            '        ',
            '        if (charCode <= 0xFF) {',
            '          escapeChar = \'x\';',
            '          length = 2;',
            '        } else {',
            '          escapeChar = \'u\';',
            '          length = 4;',
            '        }',
            '        ',
            '        return \'\\\\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), \'0\', length);',
            '      }',
            '      ',
            '      #if options.trackLineAndColumn',
            '        function clone(object) {',
            '          var result = {};',
            '          for (var key in object) {',
            '            result[key] = object[key];',
            '          }',
            '          return result;',
            '        }',
            '        ',
            '        function advance(pos, n) {',
            '          var endOffset = pos.offset + n;',
            '          ',
            '          for (var offset = pos.offset; offset < endOffset; offset++) {',
            '            var ch = input.charAt(offset);',
            '            if (ch === "\\n") {',
            '              if (!pos.seenCR) { pos.line++; }',
            '              pos.column = 1;',
            '              pos.seenCR = false;',
            '            } else if (ch === "\\r" || ch === "\\u2028" || ch === "\\u2029") {',
            '              pos.line++;',
            '              pos.column = 1;',
            '              pos.seenCR = true;',
            '            } else {',
            '              pos.column++;',
            '              pos.seenCR = false;',
            '            }',
            '          }',
            '          ',
            '          pos.offset += n;',
            '        }',
            '        ',
            '      #end',
            '      function matchFailed(failure) {',
            '        if (#{posOffset("pos")} < #{posOffset("rightmostFailuresPos")}) {',
            '          return;',
            '        }',
            '        ',
            '        if (#{posOffset("pos")} > #{posOffset("rightmostFailuresPos")}) {',
            '          rightmostFailuresPos = #{posClone("pos")};',
            '          rightmostFailuresExpected = [];',
            '        }',
            '        ',
            '        rightmostFailuresExpected.push(failure);',
            '      }',
            '      ',
            '      #for rule in node.rules',
            '        #block emit(rule)',
            '        ',
            '      #end',
            '      ',
            '      function cleanupExpected(expected) {',
            '        expected.sort();',
            '        ',
            '        var lastExpected = null;',
            '        var cleanExpected = [];',
            '        for (var i = 0; i < expected.length; i++) {',
            '          if (expected[i] !== lastExpected) {',
            '            cleanExpected.push(expected[i]);',
            '            lastExpected = expected[i];',
            '          }',
            '        }',
            '        return cleanExpected;',
            '      }',
            '      ',
            '      #if !options.trackLineAndColumn',
            '        function computeErrorPosition() {',
            '          /*',
            '           * The first idea was to use |String.split| to break the input up to the',
            '           * error position along newlines and derive the line and column from',
            '           * there. However IE\'s |split| implementation is so broken that it was',
            '           * enough to prevent it.',
            '           */',
            '          ',
            '          var line = 1;',
            '          var column = 1;',
            '          var seenCR = false;',
            '          ',
            '          for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {',
            '            var ch = input.charAt(i);',
            '            if (ch === "\\n") {',
            '              if (!seenCR) { line++; }',
            '              column = 1;',
            '              seenCR = false;',
            '            } else if (ch === "\\r" || ch === "\\u2028" || ch === "\\u2029") {',
            '              line++;',
            '              column = 1;',
            '              seenCR = true;',
            '            } else {',
            '              column++;',
            '              seenCR = false;',
            '            }',
            '          }',
            '          ',
            '          return { line: line, column: column };',
            '        }',
            '      #end',
            '      ',
            '      #if node.initializer',
            '        #block emit(node.initializer)',
            '      #end',
            '      ',
            '      var result = parseFunctions[startRule]();',
            '      ',
            '      /*',
            '       * The parser is now in one of the following three states:',
            '       *',
            '       * 1. The parser successfully parsed the whole input.',
            '       *',
            '       *    - |result !== null|',
            '       *    - |#{posOffset("pos")} === input.length|',
            '       *    - |rightmostFailuresExpected| may or may not contain something',
            '       *',
            '       * 2. The parser successfully parsed only a part of the input.',
            '       *',
            '       *    - |result !== null|',
            '       *    - |#{posOffset("pos")} < input.length|',
            '       *    - |rightmostFailuresExpected| may or may not contain something',
            '       *',
            '       * 3. The parser did not successfully parse any part of the input.',
            '       *',
            '       *   - |result === null|',
            '       *   - |#{posOffset("pos")} === 0|',
            '       *   - |rightmostFailuresExpected| contains at least one failure',
            '       *',
            '       * All code following this comment (including called functions) must',
            '       * handle these states.',
            '       */',
            '      if (result === null || #{posOffset("pos")} !== input.length) {',
            '        var offset = Math.max(#{posOffset("pos")}, #{posOffset("rightmostFailuresPos")});',
            '        var found = offset < input.length ? input.charAt(offset) : null;',
            '        #if options.trackLineAndColumn',
            '          var errorPosition = #{posOffset("pos")} > #{posOffset("rightmostFailuresPos")} ? pos : rightmostFailuresPos;',
            '        #else',
            '          var errorPosition = computeErrorPosition();',
            '        #end',
            '        ',
            '        throw new this.SyntaxError(',
            '          cleanupExpected(rightmostFailuresExpected),',
            '          found,',
            '          offset,',
            '          errorPosition.line,',
            '          errorPosition.column',
            '        );',
            '      }',
            '      ',
            '      return result;',
            '    },',
            '    ',
            '    /* Returns the parser source code. */',
            '    toSource: function() { return this._source; }',
            '  };',
            '  ',
            '  /* Thrown when a parser encounters a syntax error. */',
            '  ',
            '  result.SyntaxError = function(expected, found, offset, line, column) {',
            '    function buildMessage(expected, found) {',
            '      var expectedHumanized, foundHumanized;',
            '      ',
            '      switch (expected.length) {',
            '        case 0:',
            '          expectedHumanized = "end of input";',
            '          break;',
            '        case 1:',
            '          expectedHumanized = expected[0];',
            '          break;',
            '        default:',
            '          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")',
            '            + " or "',
            '            + expected[expected.length - 1];',
            '      }',
            '      ',
            '      foundHumanized = found ? quote(found) : "end of input";',
            '      ',
            '      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";',
            '    }',
            '    ',
            '    this.name = "SyntaxError";',
            '    this.expected = expected;',
            '    this.found = found;',
            '    this.message = buildMessage(expected, found);',
            '    this.offset = offset;',
            '    this.line = line;',
            '    this.column = column;',
            '  };',
            '  ',
            '  result.SyntaxError.prototype = Error.prototype;',
            '  ',
            '  return result;',
            '})()'
          ],
          rule: [
            'function parse_#{node.name}() {',
            '  #if options.cache',
            '    var cacheKey = "#{node.name}@" + #{posOffset("pos")};',
            '    var cachedResult = cache[cacheKey];',
            '    if (cachedResult) {',
            '      pos = #{posClone("cachedResult.nextPos")};',
            '      return cachedResult.result;',
            '    }',
            '    ',
            '  #end',
            '  #if node.resultVars.length > 0',
            '    var #{node.resultVars.join(", ")};',
            '  #end',
            '  #if node.posVars.length > 0',
            '    var #{node.posVars.join(", ")};',
            '  #end',
            '  ',
            '  #if node.displayName !== null',
            '    reportFailures++;',
            '  #end',
            '  #block emit(node.expression)',
            '  #if node.displayName !== null',
            '    reportFailures--;',
            '    if (reportFailures === 0 && #{node.resultVar} === null) {',
            '      matchFailed(#{string(node.displayName)});',
            '    }',
            '  #end',
            '  #if options.cache',
            '    ',
            '    cache[cacheKey] = {',
            '      nextPos: #{posClone("pos")},',
            '      result:  #{node.resultVar}',
            '    };',
            '  #end',
            '  return #{node.resultVar};',
            '}'
          ],
          choice: [
            '#block emit(alternative)',
            '#block nextAlternativesCode'
          ],
          "choice.next": [
            'if (#{node.resultVar} === null) {',
            '  #block code',
            '}'
          ],
          sequence: [
            '#{posSave(node)};',
            '#block code'
          ],
          "sequence.iteration": [
            '#block emit(element)',
            'if (#{element.resultVar} !== null) {',
            '  #block code',
            '} else {',
            '  #{node.resultVar} = null;',
            '  #{posRestore(node)};',
            '}'
          ],
          "sequence.inner": [
            '#{node.resultVar} = [#{pluck(node.elements, "resultVar").join(", ")}];'
          ],
          simple_and: [
            '#{posSave(node)};',
            'reportFailures++;',
            '#block emit(node.expression)',
            'reportFailures--;',
            'if (#{node.resultVar} !== null) {',
            '  #{node.resultVar} = "";',
            '  #{posRestore(node)};',
            '} else {',
            '  #{node.resultVar} = null;',
            '}'
          ],
          simple_not: [
            '#{posSave(node)};',
            'reportFailures++;',
            '#block emit(node.expression)',
            'reportFailures--;',
            'if (#{node.resultVar} === null) {',
            '  #{node.resultVar} = "";',
            '} else {',
            '  #{node.resultVar} = null;',
            '  #{posRestore(node)};',
            '}'
          ],
          semantic_and: [
            '#{node.resultVar} = (function(#{(options.trackLineAndColumn ? ["offset", "line", "column"] : ["offset"]).concat(keys(node.params)).join(", ")}) {#{node.code}})(#{(options.trackLineAndColumn ? ["pos.offset", "pos.line", "pos.column"] : ["pos"]).concat(values(node.params)).join(", ")}) ? "" : null;'
          ],
          semantic_not: [
            '#{node.resultVar} = (function(#{(options.trackLineAndColumn ? ["offset", "line", "column"] : ["offset"]).concat(keys(node.params)).join(", ")}) {#{node.code}})(#{(options.trackLineAndColumn ? ["pos.offset", "pos.line", "pos.column"] : ["pos"]).concat(values(node.params)).join(", ")}) ? null : "";'
          ],
          optional: [
            '#block emit(node.expression)',
            '#{node.resultVar} = #{node.resultVar} !== null ? #{node.resultVar} : "";'
          ],
          zero_or_more: [
            '#{node.resultVar} = [];',
            '#block emit(node.expression)',
            'while (#{node.expression.resultVar} !== null) {',
            '  #{node.resultVar}.push(#{node.expression.resultVar});',
            '  #block emit(node.expression)',
            '}'
          ],
          one_or_more: [
            '#block emit(node.expression)',
            'if (#{node.expression.resultVar} !== null) {',
            '  #{node.resultVar} = [];',
            '  while (#{node.expression.resultVar} !== null) {',
            '    #{node.resultVar}.push(#{node.expression.resultVar});',
            '    #block emit(node.expression)',
            '  }',
            '} else {',
            '  #{node.resultVar} = null;',
            '}'
          ],
          action: [
            '#{posSave(node)};',
            '#block emit(node.expression)',
            'if (#{node.resultVar} !== null) {',
            '  #{node.resultVar} = (function(#{(options.trackLineAndColumn ? ["offset", "line", "column"] : ["offset"]).concat(keys(node.params)).join(", ")}) {#{node.code}})(#{(options.trackLineAndColumn ? [node.posVar + ".offset", node.posVar + ".line", node.posVar + ".column"] : [node.posVar]).concat(values(node.params)).join(", ")});',
            '}',
            'if (#{node.resultVar} === null) {',
            '  #{posRestore(node)};',
            '}'
          ],
          rule_ref: [
            '#{node.resultVar} = parse_#{node.name}();'
          ],
          literal: [
            '#if node.value.length === 0',
            '  #{node.resultVar} = "";',
            '#else',
            '  #if !node.ignoreCase',
            '    #if node.value.length === 1',
            '      if (input.charCodeAt(#{posOffset("pos")}) === #{node.value.charCodeAt(0)}) {',
            '    #else',
            '      if (input.substr(#{posOffset("pos")}, #{node.value.length}) === #{string(node.value)}) {',
            '    #end',
            '  #else',
            /*
             * One-char literals are not optimized when case-insensitive
             * matching is enabled. This is because there is no simple way to
             * lowercase a character code that works for character outside ASCII
             * letters. Moreover, |toLowerCase| can change string length,
             * meaning the result of lowercasing a character can be more
             * characters.
             */
            '    if (input.substr(#{posOffset("pos")}, #{node.value.length}).toLowerCase() === #{string(node.value.toLowerCase())}) {',
            '  #end',
            '    #if !node.ignoreCase',
            '      #{node.resultVar} = #{string(node.value)};',
            '    #else',
            '      #{node.resultVar} = input.substr(#{posOffset("pos")}, #{node.value.length});',
            '    #end',
            '    #{posAdvance(node.value.length)};',
            '  } else {',
            '    #{node.resultVar} = null;',
            '    if (reportFailures === 0) {',
            '      matchFailed(#{string(string(node.value))});',
            '    }',
            '  }',
            '#end'
          ],
          any: [
            'if (input.length > #{posOffset("pos")}) {',
            '  #{node.resultVar} = input.charAt(#{posOffset("pos")});',
            '  #{posAdvance(1)};',
            '} else {',
            '  #{node.resultVar} = null;',
            '  if (reportFailures === 0) {',
            '    matchFailed("any character");',
            '  }',
            '}'
          ],
          "class": [
            'if (#{regexp}.test(input.charAt(#{posOffset("pos")}))) {',
            '  #{node.resultVar} = input.charAt(#{posOffset("pos")});',
            '  #{posAdvance(1)};',
            '} else {',
            '  #{node.resultVar} = null;',
            '  if (reportFailures === 0) {',
            '    matchFailed(#{string(node.rawText)});',
            '  }',
            '}'
          ]
        };

    for (name in sources) {
      templates[name] = Codie.template(sources[name].join('\n'));
    }

    return templates;
  })();

  function fill(name, vars) {
    vars.string  = quote;
    vars.pluck   = pluck;
    vars.keys    = keys;
    vars.values  = values;
    vars.emit    = emit;
    vars.options = options;

    /* Position-handling macros */
    if (options.trackLineAndColumn) {
      vars.posInit    = function(name) {
        return "var "
             + name
             + " = "
             + "{ offset: 0, line: 1, column: 1, seenCR: false }";
      };
      vars.posClone   = function(name) { return "clone(" + name + ")"; };
      vars.posOffset  = function(name) { return name + ".offset"; };

      vars.posAdvance = function(n)    { return "advance(pos, " + n + ")"; };
    } else {
      vars.posInit    = function(name) { return "var " + name + " = 0"; };
      vars.posClone   = function(name) { return name; };
      vars.posOffset  = function(name) { return name; };

      vars.posAdvance = function(n) {
        return n === 1 ? "pos++" : "pos += " + n;
      };
    }
    vars.posSave    = function(node) {
      return node.posVar + " = " + vars.posClone("pos");
    };
    vars.posRestore = function(node) {
      return "pos" + " = " + vars.posClone(node.posVar);
    };

    return templates[name](vars);
  }

  function emitSimple(name) {
    return function(node) { return fill(name, { node: node }); };
  }

  var emit = buildNodeVisitor({
    grammar: emitSimple("grammar"),

    initializer: function(node) { return node.code; },

    rule: emitSimple("rule"),

    /*
     * The contract for all code fragments generated by the following functions
     * is as follows.
     *
     * The code fragment tries to match a part of the input starting with the
     * position indicated in |pos|. That position may point past the end of the
     * input.
     *
     * * If the code fragment matches the input, it advances |pos| to point to
     *   the first chracter following the matched part of the input and sets
     *   variable with a name stored in |node.resultVar| to an appropriate
     *   value. This value is always non-|null|.
     *
     * * If the code fragment does not match the input, it returns with |pos|
     *   set to the original value and it sets a variable with a name stored in
     *   |node.resultVar| to |null|.
     *
     * The code can use variables with names stored in |resultVar| and |posVar|
     * properties of the current node's subnodes. It can't use any other
     * variables.
     */

    choice: function(node) {
      var code, nextAlternativesCode;

      for (var i = node.alternatives.length - 1; i >= 0; i--) {
        nextAlternativesCode = i !== node.alternatives.length - 1
          ? fill("choice.next", { node: node, code: code })
          : '';
        code = fill("choice", {
          alternative:          node.alternatives[i],
          nextAlternativesCode: nextAlternativesCode
        });
      }

      return code;
    },

    sequence: function(node) {
      var code = fill("sequence.inner", { node: node });

      for (var i = node.elements.length - 1; i >= 0; i--) {
        code = fill("sequence.iteration", {
          node:    node,
          element: node.elements[i],
          code:    code
        });
      }

      return fill("sequence", { node: node, code: code });
    },

    labeled: function(node) { return emit(node.expression); },

    simple_and:   emitSimple("simple_and"),
    simple_not:   emitSimple("simple_not"),
    semantic_and: emitSimple("semantic_and"),
    semantic_not: emitSimple("semantic_not"),
    optional:     emitSimple("optional"),
    zero_or_more: emitSimple("zero_or_more"),
    one_or_more:  emitSimple("one_or_more"),
    action:       emitSimple("action"),
    rule_ref:     emitSimple("rule_ref"),
    literal:      emitSimple("literal"),
    any:          emitSimple("any"),

    "class": function(node) {
      var regexp;

      if (node.parts.length > 0) {
        regexp = '/^['
          + (node.inverted ? '^' : '')
          + map(node.parts, function(part) {
              return part instanceof Array
                ? quoteForRegexpClass(part[0])
                  + '-'
                  + quoteForRegexpClass(part[1])
                : quoteForRegexpClass(part);
            }).join('')
          + ']/' + (node.ignoreCase ? 'i' : '');
      } else {
        /*
         * Stupid IE considers regexps /[]/ and /[^]/ syntactically invalid, so
         * we translate them into euqivalents it can handle.
         */
        regexp = node.inverted ? '/^[\\S\\s]/' : '/^(?!)/';
      }

      return fill("class", { node: node, regexp: regexp });
    }
  });

  return emit(ast);
};

return PEG;

})();

if (typeof module !== "undefined") {
  module.exports = PEG;
}

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/index.js":[function(require,module,exports){
(function (process){
var EventEmitter = require('events').EventEmitter;
var Hash = require('hashish');
var Chainsaw = require('chainsaw');

module.exports = Seq;
function Seq (xs) {
    if (xs && !Array.isArray(xs) || arguments.length > 1) {
        throw new Error('Optional argument to Seq() is exactly one Array');
    }
    
    var ch = Chainsaw(function (saw) {
        builder.call(this, saw, xs || []);
    });
    
    process.nextTick(function () {
        ch['catch'](function (err) {
            console.error(err.stack ? err.stack : err)
        });
    });
    return ch;
}

Seq.ap = Seq; // for compatability with versions <0.3

function builder (saw, xs) {
    var context = {
        vars : {},
        args : {},
        stack : xs,
        error : null
    };
    context.stack_ = context.stack;
    
    function action (step, key, f, g) {
        var cb = function (err) {
            var args = [].slice.call(arguments, 1);
            if (err) {
                context.error = { message : err, key : key };
                saw.jump(lastPar);
                saw.down('catch');
                g();
            }
            else {
                if (typeof key == 'number') {
                    context.stack_[key] = args[0];
                    context.args[key] = args;
                }
                else {
                    context.stack_.push.apply(context.stack_, args);
                    if (key !== undefined) {
                        context.vars[key] = args[0];
                        context.args[key] = args;
                    }
                }
                if (g) g(args, key);
            }
        };
        Hash(context).forEach(function (v,k) { cb[k] = v });
        
        cb.into = function (k) {
            key = k;
            return cb;
        };
        
        cb.next = function (err, xs) {
            context.stack_.push.apply(context.stack_, xs);
            cb.apply(cb, [err].concat(context.stack));
        };
        
        cb.pass = function (err) {
            cb.apply(cb, [err].concat(context.stack));
        };
        
        cb.ok = cb.bind(cb, null);
        
        f.apply(cb, context.stack);
    }
    
    var running = 0;
    var errors = 0;
    
    this.seq = function (key, cb) {
        var bound = [].slice.call(arguments, 2);
        
        if (typeof key === 'function') {
            if (arguments.length > 1) bound.unshift(cb);
            cb = key;
            key = undefined;
        }
        
        if (context.error) saw.next()
        else if (running === 0) {
            action(saw.step, key,
                function () {
                    context.stack_ = [];
                    var args = [].slice.call(arguments);
                    args.unshift.apply(args, bound.map(function (arg) {
                        return arg === Seq ? this : arg
                    }, this));
                    
                    cb.apply(this, args);
                }, function () {
                    context.stack = context.stack_;
                    saw.next()
                }
            );
        }
    };
    
    var lastPar = null;
    this.par = function (key, cb) {
        lastPar = saw.step;
        
        if (running == 0) {
            // empty the active stack for the first par() in a chain
            context.stack_ = [];
        }
        
        var bound = [].slice.call(arguments, 2);
        if (typeof key === 'function') {
            if (arguments.length > 1) bound.unshift(cb);
            cb = key;
            key = context.stack_.length;
            context.stack_.push(null);
        }
        var cb_ = function () {
            var args = [].slice.call(arguments);
            args.unshift.apply(args, bound.map(function (arg) {
                return arg === Seq ? this : arg
            }, this));
            
            cb.apply(this, args);
        };
        
        running ++;
        
        var step = saw.step;
        process.nextTick(function () {
            action(step, key, cb_, function (args) {
                if (!args) errors ++;
                
                running --;
                if (running == 0) {
                    context.stack = context.stack_.slice();
                    saw.step = lastPar;
                    if (errors > 0) saw.down('catch');
                    errors = 0;
                    saw.next();
                }
            });
        });
        saw.next();
    };
    
    [ 'seq', 'par' ].forEach(function (name) {
        this[name + '_'] = function (key) {
            var args = [].slice.call(arguments);
            
            var cb = typeof key === 'function'
                ? args[0] : args[1];
            
            var fn = function () {
                var argv = [].slice.call(arguments);
                argv.unshift(this);
                cb.apply(this, argv);
            };
            
            if (typeof key === 'function') {
                args[0] = fn;
            }
            else {
                args[1] = fn;
            }
            
            this[name].apply(this, args);
        };
    }, this);
    
    this['catch'] = function (cb) {
        if (context.error) {
            cb.call(context, context.error.message, context.error.key);
            context.error = null;
        }
        saw.next();
    };
    
    this.forEach = function (cb) {
        this.seq(function () {
            context.stack_ = context.stack.slice();
            var end = context.stack.length;
            
            if (end === 0) this(null)
            else context.stack.forEach(function (x, i) {
                action(saw.step, i, function () {
                    cb.call(this, x, i);
                    if (i == end - 1) saw.next();
                });
            });
        });
    };
    
    this.seqEach = function (cb) {
        this.seq(function () {
            context.stack_ = context.stack.slice();
            var xs = context.stack.slice();
            if (xs.length === 0) this(null);
            else (function next (i) {
                action(
                    saw.step, i,
                    function () { cb.call(this, xs[i], i) },
                    function (args) {
                        if (!args || i === xs.length - 1) saw.next();
                        else next(i + 1);
                    }
                );
            }).bind(this)(0);
        });
    };
    
    this.parEach = function (limit, cb) {
        var xs = context.stack.slice();
        if (cb === undefined) { cb = limit; limit = xs.length }
        context.stack_ = [];
        
        var active = 0;
        var finished = 0;
        var queue = [];
        
        if (xs.length === 0) saw.next()
        else xs.forEach(function call (x, i) {
            if (active >= limit) {
                queue.push(call.bind(this, x, i));
            }
            else {
                active ++;
                action(saw.step, i,
                    function () {
                        cb.call(this, x, i);
                    },
                    function () {
                        active --;
                        finished ++;
                        if (queue.length > 0) queue.shift()();
                        else if (finished === xs.length) {
                            saw.next();
                        }
                    }
                );
            }
        });
    };
    
    this.parMap = function (limit, cb) {
        var res = [];
        var len = context.stack.length;
        if (cb === undefined) { cb = limit; limit = len }
        var res = [];
        
        Seq()
            .extend(context.stack)
            .parEach(limit, function (x, i) {
                var self = this;
                
                var next = function () {
                    res[i] = arguments[1];
                    self.apply(self, arguments);
                };
                
                next.stack = self.stack;
                next.stack_ = self.stack_;
                next.vars = self.vars;
                next.args = self.args;
                next.error = self.error;
                
                next.into = function (key) {
                    return function () {
                        res[key] = arguments[1];
                        self.apply(self, arguments);
                    };
                };
                
                next.ok = function () {
                    var args = [].slice.call(arguments);
                    args.unshift(null);
                    return next.apply(next, args);
                };
                
                cb.apply(next, arguments);
            })
            .seq(function () {
                context.stack = res;
                saw.next();
            })
        ;
    };
    
    this.seqMap = function (cb) {
        var res = [];
        var lastIdx = context.stack.length - 1;
        
        this.seqEach(function (x, i) {
            var self = this;
            
            var next = function () {
                res[i] = arguments[1];
                if (i === lastIdx)
                    context.stack = res;
                self.apply(self, arguments);
            };
            
            next.stack = self.stack;
            next.stack_ = self.stack_;
            next.vars = self.vars;
            next.args = self.args;
            next.error = self.error;
            
            next.into = function (key) {
                return function () {
                    res[key] = arguments[1];
                    if (i === lastIdx)
                        context.stack = res;
                    self.apply(self, arguments);
                };
            };
            
            next.ok = function () {
                var args = [].slice.call(arguments);
                args.unshift(null);
                return next.apply(next, args);
            };
            
            cb.apply(next, arguments);
        });
    };
    
    /**
     * Consumes any errors that occur in `cb`. Calls to `this.into(i)` will place
     * that value, if accepted by the filter, at the index in the results as
     * if it were the i-th index before filtering. (This means it will never 
     * override another value, and will only actually appear at i if the filter
     * accepts all values before i.)
     */
    this.parFilter = function (limit, cb) {
        var res = [];
        var len = context.stack.length;
        if (cb === undefined) { cb = limit; limit = len }
        var res = [];
        
        Seq()
            .extend(context.stack)
            .parEach(limit, function (x, i) {
                var self = this;
                
                var next = function (err, ok) {
                    if (!err && ok)
                        res.push([i, x]);
                    arguments[0] = null; // discard errors
                    self.apply(self, arguments);
                };
                
                next.stack = self.stack;
                next.stack_ = self.stack_;
                next.vars = self.vars;
                next.args = self.args;
                next.error = self.error;
                
                next.into = function (key) {
                    return function (err, ok) {
                        if (!err && ok)
                            res.push([key, x]);
                        arguments[0] = null; // discard errors
                        self.apply(self, arguments);
                    };
                };
                
                next.ok = function () {
                    var args = [].slice.call(arguments);
                    args.unshift(null);
                    return next.apply(next, args);
                };
                
                cb.apply(next, arguments);
            })
            .seq(function () {
                context.stack = res.sort().map(function(pair){ return pair[1]; });
                saw.next();
            })
        ;
    };
    
    /**
     * Consumes any errors that occur in `cb`. Calls to `this.into(i)` will place
     * that value, if accepted by the filter, at the index in the results as
     * if it were the i-th index before filtering. (This means it will never 
     * override another value, and will only actually appear at i if the filter
     * accepts all values before i.)
     */
    this.seqFilter = function (cb) {
        var res = [];
        var lastIdx = context.stack.length - 1;
        
        this.seqEach(function (x, i) {
            var self = this;
            
            var next = function (err, ok) {
                if (!err && ok)
                    res.push([i, x]);
                if (i === lastIdx)
                    context.stack = res.sort().map(function(pair){ return pair[1]; });
                arguments[0] = null; // discard errors
                self.apply(self, arguments);
            };
            
            next.stack = self.stack;
            next.stack_ = self.stack_;
            next.vars = self.vars;
            next.args = self.args;
            next.error = self.error;
            
            next.into = function (key) {
                return function (err, ok) {
                    if (!err && ok)
                        res.push([key, x]);
                    if (i === lastIdx)
                        context.stack = res.sort().map(function(pair){ return pair[1]; });
                    arguments[0] = null; // discard errors
                    self.apply(self, arguments);
                };
            };
            
            next.ok = function () {
                var args = [].slice.call(arguments);
                args.unshift(null);
                return next.apply(next, args);
            };
            
            cb.apply(next, arguments);
        });
    };
    
    [ 'forEach', 'seqEach', 'parEach', 'seqMap', 'parMap', 'seqFilter', 'parFilter' ]
        .forEach(function (name) {
            this[name + '_'] = function (cb) {
                this[name].call(this, function () {
                    var args = [].slice.call(arguments);
                    args.unshift(this);
                    cb.apply(this, args);
                });
            };
        }, this)
    ;
    
    ['push','pop','shift','unshift','splice','reverse']
        .forEach(function (name) {
            this[name] = function () {
                context.stack[name].apply(
                    context.stack,
                    [].slice.call(arguments)
                );
                saw.next();
                return this;
            };
        }, this)
    ;
    
    [ 'map', 'filter', 'reduce' ]
        .forEach(function (name) {
            this[name] = function () {
                var res = context.stack[name].apply(
                    context.stack,
                    [].slice.call(arguments)
                );
                // stack must be an array, or bad things happen
                context.stack = (Array.isArray(res) ? res : [res]);
                saw.next();
                return this;
            };
        }, this)
    ;
    
    this.extend = function (xs) {
        if (!Array.isArray(xs)) {
            throw new Error('argument to .extend() is not an Array');
        }
        context.stack.push.apply(context.stack, xs);
        saw.next();
    };
    
    this.flatten = function (pancake) {
        var xs = [];
        // should we fully flatten this array? (default: true)
        if (pancake === undefined) { pancake = true; }
        context.stack.forEach(function f (x) {
            if (Array.isArray(x) && pancake) x.forEach(f);
            else if (Array.isArray(x)) xs = xs.concat(x);
            else xs.push(x);
        });
        context.stack = xs;
        saw.next();
    };
    
    this.unflatten = function () {
        context.stack = [context.stack];
        saw.next();
    };
    
    this.empty = function () {
        context.stack = [];
        saw.next();
    };
    
    this.set = function (stack) {
        context.stack = stack;
        saw.next();
    };
    
    this['do'] = function (cb) {
        saw.nest(cb, context);
    };
}

}).call(this,require('_process'))

},{"_process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js","chainsaw":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/chainsaw/index.js","events":"/Users/Jacob/workspace/scheduler/front-end/node_modules/events/events.js","hashish":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/hashish/index.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/chainsaw/index.js":[function(require,module,exports){
(function (process){
var Traverse = require('traverse');
var EventEmitter = require('events').EventEmitter;

module.exports = Chainsaw;
function Chainsaw (builder) {
    var saw = Chainsaw.saw(builder, {});
    var r = builder.call(saw.handlers, saw);
    if (r !== undefined) saw.handlers = r;
    return saw.chain();
};

Chainsaw.saw = function (builder, handlers) {
    var saw = new EventEmitter;
    saw.handlers = handlers;
    saw.actions = [];
    saw.step = 0;
    
    saw.chain = function () {
        var ch = Traverse(saw.handlers).map(function (node) {
            if (this.isRoot) return node;
            var ps = this.path;
            
            if (typeof node === 'function') {
                this.update(function () {
                    saw.actions.push({
                        path : ps,
                        args : [].slice.call(arguments)
                    });
                    return ch;
                });
            }
        });
        
        process.nextTick(function () {
            saw.emit('begin');
            saw.next();
        });
        
        return ch;
    };
    
    saw.next = function () {
        var action = saw.actions[saw.step];
        saw.step ++;
        
        if (!action) {
            saw.emit('end');
        }
        else if (!action.trap) {
            var node = saw.handlers;
            action.path.forEach(function (key) { node = node[key] });
            node.apply(saw.handlers, action.args);
        }
    };
    
    saw.nest = function (cb) {
        var args = [].slice.call(arguments, 1);
        var autonext = true;
        
        if (typeof cb === 'boolean') {
            var autonext = cb;
            cb = args.shift();
        }
        
        var s = Chainsaw.saw(builder, {});
        var r = builder.call(s.handlers, s);
        
        if (r !== undefined) s.handlers = r;
        cb.apply(s.chain(), args);
        if (autonext !== false) s.on('end', saw.next);
    };
    
    saw.trap = function (name, cb) {
        var ps = Array.isArray(name) ? name : [name];
        saw.actions.push({
            path : ps,
            step : saw.step,
            cb : cb,
            trap : true
        });
    };
    
    saw.down = function (name) {
        var ps = (Array.isArray(name) ? name : [name]).join('/');
        var i = saw.actions.slice(saw.step).map(function (x) {
            if (x.trap && x.step <= saw.step) return false;
            return x.path.join('/') == ps;
        }).indexOf(true);
        
        if (i >= 0) saw.step += i;
        else saw.step = saw.actions.length;
        
        var act = saw.actions[saw.step - 1];
        if (act && act.trap) {
            // It's a trap!
            saw.step = act.step;
            act.cb();
        }
        else saw.next();
    };
    
    saw.jump = function (step) {
        saw.step = step;
        saw.next();
    };
    
    return saw;
}; 

}).call(this,require('_process'))

},{"_process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js","events":"/Users/Jacob/workspace/scheduler/front-end/node_modules/events/events.js","traverse":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/chainsaw/node_modules/traverse/index.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/chainsaw/node_modules/traverse/index.js":[function(require,module,exports){
module.exports = Traverse;
function Traverse (obj) {
    if (!(this instanceof Traverse)) return new Traverse(obj);
    this.value = obj;
}

Traverse.prototype.get = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key)) {
            node = undefined;
            break;
        }
        node = node[key];
    }
    return node;
};

Traverse.prototype.set = function (ps, value) {
    var node = this.value;
    for (var i = 0; i < ps.length - 1; i ++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key)) node[key] = {};
        node = node[key];
    }
    node[ps[i]] = value;
    return value;
};

Traverse.prototype.map = function (cb) {
    return walk(this.value, cb, true);
};

Traverse.prototype.forEach = function (cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
};

Traverse.prototype.reduce = function (cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function (x) {
        if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x);
        }
    });
    return acc;
};

Traverse.prototype.deepEqual = function (obj) {
    if (arguments.length !== 1) {
        throw new Error(
            'deepEqual requires exactly one object to compare against'
        );
    }
    
    var equal = true;
    var node = obj;
    
    this.forEach(function (y) {
        var notEqual = (function () {
            equal = false;
            //this.stop();
            return undefined;
        }).bind(this);
        
        //if (node === undefined || node === null) return notEqual();
        
        if (!this.isRoot) {
        /*
            if (!Object.hasOwnProperty.call(node, this.key)) {
                return notEqual();
            }
        */
            if (typeof node !== 'object') return notEqual();
            node = node[this.key];
        }
        
        var x = node;
        
        this.post(function () {
            node = x;
        });
        
        var toS = function (o) {
            return Object.prototype.toString.call(o);
        };
        
        if (this.circular) {
            if (Traverse(obj).get(this.circular.path) !== x) notEqual();
        }
        else if (typeof x !== typeof y) {
            notEqual();
        }
        else if (x === null || y === null || x === undefined || y === undefined) {
            if (x !== y) notEqual();
        }
        else if (x.__proto__ !== y.__proto__) {
            notEqual();
        }
        else if (x === y) {
            // nop
        }
        else if (typeof x === 'function') {
            if (x instanceof RegExp) {
                // both regexps on account of the __proto__ check
                if (x.toString() != y.toString()) notEqual();
            }
            else if (x !== y) notEqual();
        }
        else if (typeof x === 'object') {
            if (toS(y) === '[object Arguments]'
            || toS(x) === '[object Arguments]') {
                if (toS(x) !== toS(y)) {
                    notEqual();
                }
            }
            else if (x instanceof Date || y instanceof Date) {
                if (!(x instanceof Date) || !(y instanceof Date)
                || x.getTime() !== y.getTime()) {
                    notEqual();
                }
            }
            else {
                var kx = Object.keys(x);
                var ky = Object.keys(y);
                if (kx.length !== ky.length) return notEqual();
                for (var i = 0; i < kx.length; i++) {
                    var k = kx[i];
                    if (!Object.hasOwnProperty.call(y, k)) {
                        notEqual();
                    }
                }
            }
        }
    });
    
    return equal;
};

Traverse.prototype.paths = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.path); 
    });
    return acc;
};

Traverse.prototype.nodes = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.node);
    });
    return acc;
};

Traverse.prototype.clone = function () {
    var parents = [], nodes = [];
    
    return (function clone (src) {
        for (var i = 0; i < parents.length; i++) {
            if (parents[i] === src) {
                return nodes[i];
            }
        }
        
        if (typeof src === 'object' && src !== null) {
            var dst = copy(src);
            
            parents.push(src);
            nodes.push(dst);
            
            Object.keys(src).forEach(function (key) {
                dst[key] = clone(src[key]);
            });
            
            parents.pop();
            nodes.pop();
            return dst;
        }
        else {
            return src;
        }
    })(this.value);
};

function walk (root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    
    return (function walker (node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        
        var state = {
            node : node,
            node_ : node_,
            path : [].concat(path),
            parent : parents.slice(-1)[0],
            key : path.slice(-1)[0],
            isRoot : path.length === 0,
            level : path.length,
            circular : null,
            update : function (x) {
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
            },
            'delete' : function () {
                delete state.parent.node[state.key];
            },
            remove : function () {
                if (Array.isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                }
                else {
                    delete state.parent.node[state.key];
                }
            },
            before : function (f) { modifiers.before = f },
            after : function (f) { modifiers.after = f },
            pre : function (f) { modifiers.pre = f },
            post : function (f) { modifiers.post = f },
            stop : function () { alive = false }
        };
        
        if (!alive) return state;
        
        if (typeof node === 'object' && node !== null) {
            state.isLeaf = Object.keys(node).length == 0;
            
            for (var i = 0; i < parents.length; i++) {
                if (parents[i].node_ === node_) {
                    state.circular = parents[i];
                    break;
                }
            }
        }
        else {
            state.isLeaf = true;
        }
        
        state.notLeaf = !state.isLeaf;
        state.notRoot = !state.isRoot;
        
        // use return values to update if defined
        var ret = cb.call(state, state.node);
        if (ret !== undefined && state.update) state.update(ret);
        if (modifiers.before) modifiers.before.call(state, state.node);
        
        if (typeof state.node == 'object'
        && state.node !== null && !state.circular) {
            parents.push(state);
            
            var keys = Object.keys(state.node);
            keys.forEach(function (key, i) {
                path.push(key);
                
                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
                
                var child = walker(state.node[key]);
                if (immutable && Object.hasOwnProperty.call(state.node, key)) {
                    state.node[key] = child.node;
                }
                
                child.isLast = i == keys.length - 1;
                child.isFirst = i == 0;
                
                if (modifiers.post) modifiers.post.call(state, child);
                
                path.pop();
            });
            parents.pop();
        }
        
        if (modifiers.after) modifiers.after.call(state, state.node);
        
        return state;
    })(root).node;
}

Object.keys(Traverse.prototype).forEach(function (key) {
    Traverse[key] = function (obj) {
        var args = [].slice.call(arguments, 1);
        var t = Traverse(obj);
        return t[key].apply(t, args);
    };
});

function copy (src) {
    if (typeof src === 'object' && src !== null) {
        var dst;
        
        if (Array.isArray(src)) {
            dst = [];
        }
        else if (src instanceof Date) {
            dst = new Date(src);
        }
        else if (src instanceof Boolean) {
            dst = new Boolean(src);
        }
        else if (src instanceof Number) {
            dst = new Number(src);
        }
        else if (src instanceof String) {
            dst = new String(src);
        }
        else {
            dst = Object.create(Object.getPrototypeOf(src));
        }
        
        Object.keys(src).forEach(function (key) {
            dst[key] = src[key];
        });
        return dst;
    }
    else return src;
}

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/hashish/index.js":[function(require,module,exports){
module.exports = Hash;
var Traverse = require('traverse');

function Hash (hash, xs) {
    if (Array.isArray(hash) && Array.isArray(xs)) {
        var to = Math.min(hash.length, xs.length);
        var acc = {};
        for (var i = 0; i < to; i++) {
            acc[hash[i]] = xs[i];
        }
        return Hash(acc);
    }
    
    if (hash === undefined) return Hash({});
    
    var self = {
        map : function (f) {
            var acc = { __proto__ : hash.__proto__ };
            Object.keys(hash).forEach(function (key) {
                acc[key] = f.call(self, hash[key], key);
            });
            return Hash(acc);
        },
        forEach : function (f) {
            Object.keys(hash).forEach(function (key) {
                f.call(self, hash[key], key);
            });
            return self;
        },
        filter : function (f) {
            var acc = { __proto__ : hash.__proto__ };
            Object.keys(hash).forEach(function (key) {
                if (f.call(self, hash[key], key)) {
                    acc[key] = hash[key];
                }
            });
            return Hash(acc);
        },
        detect : function (f) {
            for (var key in hash) {
                if (f.call(self, hash[key], key)) {
                    return hash[key];
                }
            }
            return undefined;
        },
        reduce : function (f, acc) {
            var keys = Object.keys(hash);
            if (acc === undefined) acc = keys.shift();
            keys.forEach(function (key) {
                acc = f.call(self, acc, hash[key], key);
            });
            return acc;
        },
        some : function (f) {
            for (var key in hash) {
                if (f.call(self, hash[key], key)) return true;
            }
            return false;
        },
        update : function (obj) {
            if (arguments.length > 1) {
                self.updateAll([].slice.call(arguments));
            }
            else {
                Object.keys(obj).forEach(function (key) {
                    hash[key] = obj[key];
                });
            }
            return self;
        },
        updateAll : function (xs) {
            xs.filter(Boolean).forEach(function (x) {
                self.update(x);
            });
            return self;
        },
        merge : function (obj) {
            if (arguments.length > 1) {
                return self.copy.updateAll([].slice.call(arguments));
            }
            else {
                return self.copy.update(obj);
            }
        },
        mergeAll : function (xs) {
            return self.copy.updateAll(xs);
        },
        has : function (key) { // only operates on enumerables
            return Array.isArray(key)
                ? key.every(function (k) { return self.has(k) })
                : self.keys.indexOf(key.toString()) >= 0;
        },
        valuesAt : function (keys) {
            return Array.isArray(keys)
                ? keys.map(function (key) { return hash[key] })
                : hash[keys]
            ;
        },
        tap : function (f) {
            f.call(self, hash);
            return self;
        },
        extract : function (keys) {
            var acc = {};
            keys.forEach(function (key) {
                acc[key] = hash[key];
            });
            return Hash(acc);
        },
        exclude : function (keys) {
            return self.filter(function (_, key) {
                return keys.indexOf(key) < 0
            });
        },
        end : hash,
        items : hash
    };
    
    var props = {
        keys : function () { return Object.keys(hash) },
        values : function () {
            return Object.keys(hash).map(function (key) { return hash[key] });
        },
        compact : function () {
            return self.filter(function (x) { return x !== undefined });
        },
        clone : function () { return Hash(Hash.clone(hash)) },
        copy : function () { return Hash(Hash.copy(hash)) },
        length : function () { return Object.keys(hash).length },
        size : function () { return self.length }
    };
    
    if (Object.defineProperty) {
        // es5-shim has an Object.defineProperty but it throws for getters
        try {
            for (var key in props) {
                Object.defineProperty(self, key, { get : props[key] });
            }
        }
        catch (err) {
            for (var key in props) {
                if (key !== 'clone' && key !== 'copy' && key !== 'compact') {
                    // ^ those keys use Hash() so can't call them without
                    // a stack overflow
                    self[key] = props[key]();
                }
            }
        }
    }
    else if (self.__defineGetter__) {
        for (var key in props) {
            self.__defineGetter__(key, props[key]);
        }
    }
    else {
        // non-lazy version for browsers that suck >_<
        for (var key in props) {
            self[key] = props[key]();
        }
    }
    
    return self;
};

// deep copy
Hash.clone = function (ref) {
    return Traverse.clone(ref);
};

// shallow copy
Hash.copy = function (ref) {
    var hash = { __proto__ : ref.__proto__ };
    Object.keys(ref).forEach(function (key) {
        hash[key] = ref[key];
    });
    return hash;
};

Hash.map = function (ref, f) {
    return Hash(ref).map(f).items;
};

Hash.forEach = function (ref, f) {
    Hash(ref).forEach(f);
};

Hash.filter = function (ref, f) {
    return Hash(ref).filter(f).items;
};

Hash.detect = function (ref, f) {
    return Hash(ref).detect(f);
};

Hash.reduce = function (ref, f, acc) {
    return Hash(ref).reduce(f, acc);
};

Hash.some = function (ref, f) {
    return Hash(ref).some(f);
};

Hash.update = function (a /*, b, c, ... */) {
    var args = Array.prototype.slice.call(arguments, 1);
    var hash = Hash(a);
    return hash.update.apply(hash, args).items;
};

Hash.merge = function (a /*, b, c, ... */) {
    var args = Array.prototype.slice.call(arguments, 1);
    var hash = Hash(a);
    return hash.merge.apply(hash, args).items;
};

Hash.has = function (ref, key) {
    return Hash(ref).has(key);
};

Hash.valuesAt = function (ref, keys) {
    return Hash(ref).valuesAt(keys);
};

Hash.tap = function (ref, f) {
    return Hash(ref).tap(f).items;
};

Hash.extract = function (ref, keys) {
    return Hash(ref).extract(keys).items;
};

Hash.exclude = function (ref, keys) {
    return Hash(ref).exclude(keys).items;
};

Hash.concat = function (xs) {
    var hash = Hash({});
    xs.forEach(function (x) { hash.update(x) });
    return hash.items;
};

Hash.zip = function (xs, ys) {
    return Hash(xs, ys).items;
};

// .length is already defined for function prototypes
Hash.size = function (ref) {
    return Hash(ref).size;
};

Hash.compact = function (ref) {
    return Hash(ref).compact.items;
};

},{"traverse":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/hashish/node_modules/traverse/index.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/seq/node_modules/hashish/node_modules/traverse/index.js":[function(require,module,exports){
var traverse = module.exports = function (obj) {
    return new Traverse(obj);
};

function Traverse (obj) {
    this.value = obj;
}

Traverse.prototype.get = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            node = undefined;
            break;
        }
        node = node[key];
    }
    return node;
};

Traverse.prototype.has = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            return false;
        }
        node = node[key];
    }
    return true;
};

Traverse.prototype.set = function (ps, value) {
    var node = this.value;
    for (var i = 0; i < ps.length - 1; i ++) {
        var key = ps[i];
        if (!hasOwnProperty.call(node, key)) node[key] = {};
        node = node[key];
    }
    node[ps[i]] = value;
    return value;
};

Traverse.prototype.map = function (cb) {
    return walk(this.value, cb, true);
};

Traverse.prototype.forEach = function (cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
};

Traverse.prototype.reduce = function (cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function (x) {
        if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x);
        }
    });
    return acc;
};

Traverse.prototype.paths = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.path); 
    });
    return acc;
};

Traverse.prototype.nodes = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.node);
    });
    return acc;
};

Traverse.prototype.clone = function () {
    var parents = [], nodes = [];
    
    return (function clone (src) {
        for (var i = 0; i < parents.length; i++) {
            if (parents[i] === src) {
                return nodes[i];
            }
        }
        
        if (typeof src === 'object' && src !== null) {
            var dst = copy(src);
            
            parents.push(src);
            nodes.push(dst);
            
            forEach(objectKeys(src), function (key) {
                dst[key] = clone(src[key]);
            });
            
            parents.pop();
            nodes.pop();
            return dst;
        }
        else {
            return src;
        }
    })(this.value);
};

function walk (root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    
    return (function walker (node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        
        var keepGoing = true;
        
        var state = {
            node : node,
            node_ : node_,
            path : [].concat(path),
            parent : parents[parents.length - 1],
            parents : parents,
            key : path.slice(-1)[0],
            isRoot : path.length === 0,
            level : path.length,
            circular : null,
            update : function (x, stopHere) {
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
                if (stopHere) keepGoing = false;
            },
            'delete' : function (stopHere) {
                delete state.parent.node[state.key];
                if (stopHere) keepGoing = false;
            },
            remove : function (stopHere) {
                if (isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                }
                else {
                    delete state.parent.node[state.key];
                }
                if (stopHere) keepGoing = false;
            },
            keys : null,
            before : function (f) { modifiers.before = f },
            after : function (f) { modifiers.after = f },
            pre : function (f) { modifiers.pre = f },
            post : function (f) { modifiers.post = f },
            stop : function () { alive = false },
            block : function () { keepGoing = false }
        };
        
        if (!alive) return state;
        
        function updateState() {
            if (typeof state.node === 'object' && state.node !== null) {
                if (!state.keys || state.node_ !== state.node) {
                    state.keys = objectKeys(state.node)
                }
                
                state.isLeaf = state.keys.length == 0;
                
                for (var i = 0; i < parents.length; i++) {
                    if (parents[i].node_ === node_) {
                        state.circular = parents[i];
                        break;
                    }
                }
            }
            else {
                state.isLeaf = true;
                state.keys = null;
            }
            
            state.notLeaf = !state.isLeaf;
            state.notRoot = !state.isRoot;
        }
        
        updateState();
        
        // use return values to update if defined
        var ret = cb.call(state, state.node);
        if (ret !== undefined && state.update) state.update(ret);
        
        if (modifiers.before) modifiers.before.call(state, state.node);
        
        if (!keepGoing) return state;
        
        if (typeof state.node == 'object'
        && state.node !== null && !state.circular) {
            parents.push(state);
            
            updateState();
            
            forEach(state.keys, function (key, i) {
                path.push(key);
                
                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
                
                var child = walker(state.node[key]);
                if (immutable && hasOwnProperty.call(state.node, key)) {
                    state.node[key] = child.node;
                }
                
                child.isLast = i == state.keys.length - 1;
                child.isFirst = i == 0;
                
                if (modifiers.post) modifiers.post.call(state, child);
                
                path.pop();
            });
            parents.pop();
        }
        
        if (modifiers.after) modifiers.after.call(state, state.node);
        
        return state;
    })(root).node;
}

function copy (src) {
    if (typeof src === 'object' && src !== null) {
        var dst;
        
        if (isArray(src)) {
            dst = [];
        }
        else if (isDate(src)) {
            dst = new Date(src.getTime ? src.getTime() : src);
        }
        else if (isRegExp(src)) {
            dst = new RegExp(src);
        }
        else if (isError(src)) {
            dst = { message: src.message };
        }
        else if (isBoolean(src)) {
            dst = new Boolean(src);
        }
        else if (isNumber(src)) {
            dst = new Number(src);
        }
        else if (isString(src)) {
            dst = new String(src);
        }
        else if (Object.create && Object.getPrototypeOf) {
            dst = Object.create(Object.getPrototypeOf(src));
        }
        else if (src.constructor === Object) {
            dst = {};
        }
        else {
            var proto =
                (src.constructor && src.constructor.prototype)
                || src.__proto__
                || {}
            ;
            var T = function () {};
            T.prototype = proto;
            dst = new T;
        }
        
        forEach(objectKeys(src), function (key) {
            dst[key] = src[key];
        });
        return dst;
    }
    else return src;
}

var objectKeys = Object.keys || function keys (obj) {
    var res = [];
    for (var key in obj) res.push(key)
    return res;
};

function toS (obj) { return Object.prototype.toString.call(obj) }
function isDate (obj) { return toS(obj) === '[object Date]' }
function isRegExp (obj) { return toS(obj) === '[object RegExp]' }
function isError (obj) { return toS(obj) === '[object Error]' }
function isBoolean (obj) { return toS(obj) === '[object Boolean]' }
function isNumber (obj) { return toS(obj) === '[object Number]' }
function isString (obj) { return toS(obj) === '[object String]' }

var isArray = Array.isArray || function isArray (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

forEach(objectKeys(Traverse.prototype), function (key) {
    traverse[key] = function (obj) {
        var args = [].slice.call(arguments, 1);
        var t = new Traverse(obj);
        return t[key].apply(t, args);
    };
});

var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
    return key in obj;
};

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/consolidator.js":[function(require,module,exports){
/**
 * @preserve Copyright 2012 Robert Gust-Bardon <http://robert.gust-bardon.org/>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *     * Redistributions of source code must retain the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/**
 * @fileoverview Enhances <a href="https://github.com/mishoo/UglifyJS/"
 * >UglifyJS</a> with consolidation of null, Boolean, and String values.
 * <p>Also known as aliasing, this feature has been deprecated in <a href=
 * "http://closure-compiler.googlecode.com/">the Closure Compiler</a> since its
 * initial release, where it is unavailable from the <abbr title=
 * "command line interface">CLI</a>. The Closure Compiler allows one to log and
 * influence this process. In contrast, this implementation does not introduce
 * any variable declarations in global code and derives String values from
 * identifier names used as property accessors.</p>
 * <p>Consolidating literals may worsen the data compression ratio when an <a
 * href="http://tools.ietf.org/html/rfc2616#section-3.5">encoding
 * transformation</a> is applied. For instance, <a href=
 * "http://code.jquery.com/jquery-1.7.1.js">jQuery 1.7.1</a> takes 248235 bytes.
 * Building it with <a href="https://github.com/mishoo/UglifyJS/tarball/v1.2.5">
 * UglifyJS v1.2.5</a> results in 93647 bytes (37.73% of the original) which are
 * then compressed to 33154 bytes (13.36% of the original) using <a href=
 * "http://linux.die.net/man/1/gzip">gzip(1)</a>. Building it with the same
 * version of UglifyJS 1.2.5 patched with the implementation of consolidation
 * results in 80784 bytes (a decrease of 12863 bytes, i.e. 13.74%, in comparison
 * to the aforementioned 93647 bytes) which are then compressed to 34013 bytes
 * (an increase of 859 bytes, i.e. 2.59%, in comparison to the aforementioned
 * 33154 bytes).</p>
 * <p>Written in <a href="http://es5.github.com/#x4.2.2">the strict variant</a>
 * of <a href="http://es5.github.com/">ECMA-262 5.1 Edition</a>. Encoded in <a
 * href="http://tools.ietf.org/html/rfc3629">UTF-8</a>. Follows <a href=
 * "http://google-styleguide.googlecode.com/svn-history/r76/trunk/javascriptguide.xml"
 * >Revision 2.28 of the Google JavaScript Style Guide</a> (except for the
 * discouraged use of the {@code function} tag and the {@code namespace} tag).
 * 100% typed for the <a href=
 * "http://closure-compiler.googlecode.com/files/compiler-20120123.tar.gz"
 * >Closure Compiler Version 1741</a>.</p>
 * <p>Should you find this software useful, please consider <a href=
 * "https://paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=JZLW72X8FD4WG"
 * >a donation</a>.</p>
 * @author follow.me@RGustBardon (Robert Gust-Bardon)
 * @supported Tested with:
 *     <ul>
 *     <li><a href="http://nodejs.org/dist/v0.6.10/">Node v0.6.10</a>,</li>
 *     <li><a href="https://github.com/mishoo/UglifyJS/tarball/v1.2.5">UglifyJS
 *       v1.2.5</a>.</li>
 *     </ul>
 */

/*global console:false, exports:true, module:false, require:false */
/*jshint sub:true */
/**
 * Consolidates null, Boolean, and String values found inside an <abbr title=
 * "abstract syntax tree">AST</abbr>.
 * @param {!TSyntacticCodeUnit} oAbstractSyntaxTree An array-like object
 *     representing an <abbr title="abstract syntax tree">AST</abbr>.
 * @return {!TSyntacticCodeUnit} An array-like object representing an <abbr
 *     title="abstract syntax tree">AST</abbr> with its null, Boolean, and
 *     String values consolidated.
 */
// TODO(user) Consolidation of mathematical values found in numeric literals.
// TODO(user) Unconsolidation.
// TODO(user) Consolidation of ECMA-262 6th Edition programs.
// TODO(user) Rewrite in ECMA-262 6th Edition.
exports['ast_consolidate'] = function(oAbstractSyntaxTree) {
  'use strict';
  /*jshint bitwise:true, curly:true, eqeqeq:true, forin:true, immed:true,
        latedef:true, newcap:true, noarge:true, noempty:true, nonew:true,
        onevar:true, plusplus:true, regexp:true, undef:true, strict:true,
        sub:false, trailing:true */

  var _,
      /**
       * A record consisting of data about one or more source elements.
       * @constructor
       * @nosideeffects
       */
      TSourceElementsData = function() {
        /**
         * The category of the elements.
         * @type {number}
         * @see ESourceElementCategories
         */
        this.nCategory = ESourceElementCategories.N_OTHER;
        /**
         * The number of occurrences (within the elements) of each primitive
         * value that could be consolidated.
         * @type {!Array.<!Object.<string, number>>}
         */
        this.aCount = [];
        this.aCount[EPrimaryExpressionCategories.N_IDENTIFIER_NAMES] = {};
        this.aCount[EPrimaryExpressionCategories.N_STRING_LITERALS] = {};
        this.aCount[EPrimaryExpressionCategories.N_NULL_AND_BOOLEAN_LITERALS] =
            {};
        /**
         * Identifier names found within the elements.
         * @type {!Array.<string>}
         */
        this.aIdentifiers = [];
        /**
         * Prefixed representation Strings of each primitive value that could be
         * consolidated within the elements.
         * @type {!Array.<string>}
         */
        this.aPrimitiveValues = [];
      },
      /**
       * A record consisting of data about a primitive value that could be
       * consolidated.
       * @constructor
       * @nosideeffects
       */
      TPrimitiveValue = function() {
        /**
         * The difference in the number of terminal symbols between the original
         * source text and the one with the primitive value consolidated. If the
         * difference is positive, the primitive value is considered worthwhile.
         * @type {number}
         */
        this.nSaving = 0;
        /**
         * An identifier name of the variable that will be declared and assigned
         * the primitive value if the primitive value is consolidated.
         * @type {string}
         */
        this.sName = '';
      },
      /**
       * A record consisting of data on what to consolidate within the range of
       * source elements that is currently being considered.
       * @constructor
       * @nosideeffects
       */
      TSolution = function() {
        /**
         * An object whose keys are prefixed representation Strings of each
         * primitive value that could be consolidated within the elements and
         * whose values are corresponding data about those primitive values.
         * @type {!Object.<string, {nSaving: number, sName: string}>}
         * @see TPrimitiveValue
         */
        this.oPrimitiveValues = {};
        /**
         * The difference in the number of terminal symbols between the original
         * source text and the one with all the worthwhile primitive values
         * consolidated.
         * @type {number}
         * @see TPrimitiveValue#nSaving
         */
        this.nSavings = 0;
      },
      /**
       * The processor of <abbr title="abstract syntax tree">AST</abbr>s found
       * in UglifyJS.
       * @namespace
       * @type {!TProcessor}
       */
      oProcessor = (/** @type {!TProcessor} */ require('./process')),
      /**
       * A record consisting of a number of constants that represent the
       * difference in the number of terminal symbols between a source text with
       * a modified syntactic code unit and the original one.
       * @namespace
       * @type {!Object.<string, number>}
       */
      oWeights = {
        /**
         * The difference in the number of punctuators required by the bracket
         * notation and the dot notation.
         * <p><code>'[]'.length - '.'.length</code></p>
         * @const
         * @type {number}
         */
        N_PROPERTY_ACCESSOR: 1,
        /**
         * The number of punctuators required by a variable declaration with an
         * initialiser.
         * <p><code>':'.length + ';'.length</code></p>
         * @const
         * @type {number}
         */
        N_VARIABLE_DECLARATION: 2,
        /**
         * The number of terminal symbols required to introduce a variable
         * statement (excluding its variable declaration list).
         * <p><code>'var '.length</code></p>
         * @const
         * @type {number}
         */
        N_VARIABLE_STATEMENT_AFFIXATION: 4,
        /**
         * The number of terminal symbols needed to enclose source elements
         * within a function call with no argument values to a function with an
         * empty parameter list.
         * <p><code>'(function(){}());'.length</code></p>
         * @const
         * @type {number}
         */
        N_CLOSURE: 17
      },
      /**
       * Categories of primary expressions from which primitive values that
       * could be consolidated are derivable.
       * @namespace
       * @enum {number}
       */
      EPrimaryExpressionCategories = {
        /**
         * Identifier names used as property accessors.
         * @type {number}
         */
        N_IDENTIFIER_NAMES: 0,
        /**
         * String literals.
         * @type {number}
         */
        N_STRING_LITERALS: 1,
        /**
         * Null and Boolean literals.
         * @type {number}
         */
        N_NULL_AND_BOOLEAN_LITERALS: 2
      },
      /**
       * Prefixes of primitive values that could be consolidated.
       * The String values of the prefixes must have same number of characters.
       * The prefixes must not be used in any properties defined in any version
       * of <a href=
       * "http://www.ecma-international.org/publications/standards/Ecma-262.htm"
       * >ECMA-262</a>.
       * @namespace
       * @enum {string}
       */
      EValuePrefixes = {
        /**
         * Identifies String values.
         * @type {string}
         */
        S_STRING: '#S',
        /**
         * Identifies null and Boolean values.
         * @type {string}
         */
        S_SYMBOLIC: '#O'
      },
      /**
       * Categories of source elements in terms of their appropriateness of
       * having their primitive values consolidated.
       * @namespace
       * @enum {number}
       */
      ESourceElementCategories = {
        /**
         * Identifies a source element that includes the <a href=
         * "http://es5.github.com/#x12.10">{@code with}</a> statement.
         * @type {number}
         */
        N_WITH: 0,
        /**
         * Identifies a source element that includes the <a href=
         * "http://es5.github.com/#x15.1.2.1">{@code eval}</a> identifier name.
         * @type {number}
         */
        N_EVAL: 1,
        /**
         * Identifies a source element that must be excluded from the process
         * unless its whole scope is examined.
         * @type {number}
         */
        N_EXCLUDABLE: 2,
        /**
         * Identifies source elements not posing any problems.
         * @type {number}
         */
        N_OTHER: 3
      },
      /**
       * The list of literals (other than the String ones) whose primitive
       * values can be consolidated.
       * @const
       * @type {!Array.<string>}
       */
      A_OTHER_SUBSTITUTABLE_LITERALS = [
        'null',   // The null literal.
        'false',  // The Boolean literal {@code false}.
        'true'    // The Boolean literal {@code true}.
      ];

  (/**
    * Consolidates all worthwhile primitive values in a syntactic code unit.
    * @param {!TSyntacticCodeUnit} oSyntacticCodeUnit An array-like object
    *     representing the branch of the abstract syntax tree representing the
    *     syntactic code unit along with its scope.
    * @see TPrimitiveValue#nSaving
    */
   function fExamineSyntacticCodeUnit(oSyntacticCodeUnit) {
     var _,
         /**
          * Indicates whether the syntactic code unit represents global code.
          * @type {boolean}
          */
         bIsGlobal = 'toplevel' === oSyntacticCodeUnit[0],
         /**
          * Indicates whether the whole scope is being examined.
          * @type {boolean}
          */
         bIsWhollyExaminable = !bIsGlobal,
         /**
          * An array-like object representing source elements that constitute a
          * syntactic code unit.
          * @type {!TSyntacticCodeUnit}
          */
         oSourceElements,
         /**
          * A record consisting of data about the source element that is
          * currently being examined.
          * @type {!TSourceElementsData}
          */
         oSourceElementData,
         /**
          * The scope of the syntactic code unit.
          * @type {!TScope}
          */
         oScope,
         /**
          * An instance of an object that allows the traversal of an <abbr
          * title="abstract syntax tree">AST</abbr>.
          * @type {!TWalker}
          */
         oWalker,
         /**
          * An object encompassing collections of functions used during the
          * traversal of an <abbr title="abstract syntax tree">AST</abbr>.
          * @namespace
          * @type {!Object.<string, !Object.<string, function(...[*])>>}
          */
         oWalkers = {
           /**
            * A collection of functions used during the surveyance of source
            * elements.
            * @namespace
            * @type {!Object.<string, function(...[*])>}
            */
           oSurveySourceElement: {
             /**#nocode+*/  // JsDoc Toolkit 2.4.0 hides some of the keys.
             /**
              * Classifies the source element as excludable if it does not
              * contain a {@code with} statement or the {@code eval} identifier
              * name. Adds the identifier of the function and its formal
              * parameters to the list of identifier names found.
              * @param {string} sIdentifier The identifier of the function.
              * @param {!Array.<string>} aFormalParameterList Formal parameters.
              * @param {!TSyntacticCodeUnit} oFunctionBody Function code.
              */
             'defun': function(
                 sIdentifier,
                 aFormalParameterList,
                 oFunctionBody) {
               fClassifyAsExcludable();
               fAddIdentifier(sIdentifier);
               aFormalParameterList.forEach(fAddIdentifier);
             },
             /**
              * Increments the count of the number of occurrences of the String
              * value that is equivalent to the sequence of terminal symbols
              * that constitute the encountered identifier name.
              * @param {!TSyntacticCodeUnit} oExpression The nonterminal
              *     MemberExpression.
              * @param {string} sIdentifierName The identifier name used as the
              *     property accessor.
              * @return {!Array} The encountered branch of an <abbr title=
              *     "abstract syntax tree">AST</abbr> with its nonterminal
              *     MemberExpression traversed.
              */
             'dot': function(oExpression, sIdentifierName) {
               fCountPrimaryExpression(
                   EPrimaryExpressionCategories.N_IDENTIFIER_NAMES,
                   EValuePrefixes.S_STRING + sIdentifierName);
               return ['dot', oWalker.walk(oExpression), sIdentifierName];
             },
             /**
              * Adds the optional identifier of the function and its formal
              * parameters to the list of identifier names found.
              * @param {?string} sIdentifier The optional identifier of the
              *     function.
              * @param {!Array.<string>} aFormalParameterList Formal parameters.
              * @param {!TSyntacticCodeUnit} oFunctionBody Function code.
              */
             'function': function(
                 sIdentifier,
                 aFormalParameterList,
                 oFunctionBody) {
               if ('string' === typeof sIdentifier) {
                 fAddIdentifier(sIdentifier);
               }
               aFormalParameterList.forEach(fAddIdentifier);
             },
             /**
              * Either increments the count of the number of occurrences of the
              * encountered null or Boolean value or classifies a source element
              * as containing the {@code eval} identifier name.
              * @param {string} sIdentifier The identifier encountered.
              */
             'name': function(sIdentifier) {
               if (-1 !== A_OTHER_SUBSTITUTABLE_LITERALS.indexOf(sIdentifier)) {
                 fCountPrimaryExpression(
                     EPrimaryExpressionCategories.N_NULL_AND_BOOLEAN_LITERALS,
                     EValuePrefixes.S_SYMBOLIC + sIdentifier);
               } else {
                 if ('eval' === sIdentifier) {
                   oSourceElementData.nCategory =
                       ESourceElementCategories.N_EVAL;
                 }
                 fAddIdentifier(sIdentifier);
               }
             },
             /**
              * Classifies the source element as excludable if it does not
              * contain a {@code with} statement or the {@code eval} identifier
              * name.
              * @param {TSyntacticCodeUnit} oExpression The expression whose
              *     value is to be returned.
              */
             'return': function(oExpression) {
               fClassifyAsExcludable();
             },
             /**
              * Increments the count of the number of occurrences of the
              * encountered String value.
              * @param {string} sStringValue The String value of the string
              *     literal encountered.
              */
             'string': function(sStringValue) {
               if (sStringValue.length > 0) {
                 fCountPrimaryExpression(
                     EPrimaryExpressionCategories.N_STRING_LITERALS,
                     EValuePrefixes.S_STRING + sStringValue);
               }
             },
             /**
              * Adds the identifier reserved for an exception to the list of
              * identifier names found.
              * @param {!TSyntacticCodeUnit} oTry A block of code in which an
              *     exception can occur.
              * @param {Array} aCatch The identifier reserved for an exception
              *     and a block of code to handle the exception.
              * @param {TSyntacticCodeUnit} oFinally An optional block of code
              *     to be evaluated regardless of whether an exception occurs.
              */
             'try': function(oTry, aCatch, oFinally) {
               if (Array.isArray(aCatch)) {
                 fAddIdentifier(aCatch[0]);
               }
             },
             /**
              * Classifies the source element as excludable if it does not
              * contain a {@code with} statement or the {@code eval} identifier
              * name. Adds the identifier of each declared variable to the list
              * of identifier names found.
              * @param {!Array.<!Array>} aVariableDeclarationList Variable
              *     declarations.
              */
             'var': function(aVariableDeclarationList) {
               fClassifyAsExcludable();
               aVariableDeclarationList.forEach(fAddVariable);
             },
             /**
              * Classifies a source element as containing the {@code with}
              * statement.
              * @param {!TSyntacticCodeUnit} oExpression An expression whose
              *     value is to be converted to a value of type Object and
              *     become the binding object of a new object environment
              *     record of a new lexical environment in which the statement
              *     is to be executed.
              * @param {!TSyntacticCodeUnit} oStatement The statement to be
              *     executed in the augmented lexical environment.
              * @return {!Array} An empty array to stop the traversal.
              */
             'with': function(oExpression, oStatement) {
               oSourceElementData.nCategory = ESourceElementCategories.N_WITH;
               return [];
             }
             /**#nocode-*/  // JsDoc Toolkit 2.4.0 hides some of the keys.
           },
           /**
            * A collection of functions used while looking for nested functions.
            * @namespace
            * @type {!Object.<string, function(...[*])>}
            */
           oExamineFunctions: {
             /**#nocode+*/  // JsDoc Toolkit 2.4.0 hides some of the keys.
             /**
              * Orders an examination of a nested function declaration.
              * @this {!TSyntacticCodeUnit} An array-like object representing
              *     the branch of an <abbr title="abstract syntax tree"
              *     >AST</abbr> representing the syntactic code unit along with
              *     its scope.
              * @return {!Array} An empty array to stop the traversal.
              */
             'defun': function() {
               fExamineSyntacticCodeUnit(this);
               return [];
             },
             /**
              * Orders an examination of a nested function expression.
              * @this {!TSyntacticCodeUnit} An array-like object representing
              *     the branch of an <abbr title="abstract syntax tree"
              *     >AST</abbr> representing the syntactic code unit along with
              *     its scope.
              * @return {!Array} An empty array to stop the traversal.
              */
             'function': function() {
               fExamineSyntacticCodeUnit(this);
               return [];
             }
             /**#nocode-*/  // JsDoc Toolkit 2.4.0 hides some of the keys.
           }
         },
         /**
          * Records containing data about source elements.
          * @type {Array.<TSourceElementsData>}
          */
         aSourceElementsData = [],
         /**
          * The index (in the source text order) of the source element
          * immediately following a <a href="http://es5.github.com/#x14.1"
          * >Directive Prologue</a>.
          * @type {number}
          */
         nAfterDirectivePrologue = 0,
         /**
          * The index (in the source text order) of the source element that is
          * currently being considered.
          * @type {number}
          */
         nPosition,
         /**
          * The index (in the source text order) of the source element that is
          * the last element of the range of source elements that is currently
          * being considered.
          * @type {(undefined|number)}
          */
         nTo,
         /**
          * Initiates the traversal of a source element.
          * @param {!TWalker} oWalker An instance of an object that allows the
          *     traversal of an abstract syntax tree.
          * @param {!TSyntacticCodeUnit} oSourceElement A source element from
          *     which the traversal should commence.
          * @return {function(): !TSyntacticCodeUnit} A function that is able to
          *     initiate the traversal from a given source element.
          */
         cContext = function(oWalker, oSourceElement) {
           /**
            * @return {!TSyntacticCodeUnit} A function that is able to
            *     initiate the traversal from a given source element.
            */
           var fLambda = function() {
             return oWalker.walk(oSourceElement);
           };

           return fLambda;
         },
         /**
          * Classifies the source element as excludable if it does not
          * contain a {@code with} statement or the {@code eval} identifier
          * name.
          */
         fClassifyAsExcludable = function() {
           if (oSourceElementData.nCategory ===
               ESourceElementCategories.N_OTHER) {
             oSourceElementData.nCategory =
                 ESourceElementCategories.N_EXCLUDABLE;
           }
         },
         /**
          * Adds an identifier to the list of identifier names found.
          * @param {string} sIdentifier The identifier to be added.
          */
         fAddIdentifier = function(sIdentifier) {
           if (-1 === oSourceElementData.aIdentifiers.indexOf(sIdentifier)) {
             oSourceElementData.aIdentifiers.push(sIdentifier);
           }
         },
         /**
          * Adds the identifier of a variable to the list of identifier names
          * found.
          * @param {!Array} aVariableDeclaration A variable declaration.
          */
         fAddVariable = function(aVariableDeclaration) {
           fAddIdentifier(/** @type {string} */ aVariableDeclaration[0]);
         },
         /**
          * Increments the count of the number of occurrences of the prefixed
          * String representation attributed to the primary expression.
          * @param {number} nCategory The category of the primary expression.
          * @param {string} sName The prefixed String representation attributed
          *     to the primary expression.
          */
         fCountPrimaryExpression = function(nCategory, sName) {
           if (!oSourceElementData.aCount[nCategory].hasOwnProperty(sName)) {
             oSourceElementData.aCount[nCategory][sName] = 0;
             if (-1 === oSourceElementData.aPrimitiveValues.indexOf(sName)) {
               oSourceElementData.aPrimitiveValues.push(sName);
             }
           }
           oSourceElementData.aCount[nCategory][sName] += 1;
         },
         /**
          * Consolidates all worthwhile primitive values in a range of source
          *     elements.
          * @param {number} nFrom The index (in the source text order) of the
          *     source element that is the first element of the range.
          * @param {number} nTo The index (in the source text order) of the
          *     source element that is the last element of the range.
          * @param {boolean} bEnclose Indicates whether the range should be
          *     enclosed within a function call with no argument values to a
          *     function with an empty parameter list if any primitive values
          *     are consolidated.
          * @see TPrimitiveValue#nSaving
          */
         fExamineSourceElements = function(nFrom, nTo, bEnclose) {
           var _,
               /**
                * The index of the last mangled name.
                * @type {number}
                */
               nIndex = oScope.cname,
               /**
                * The index of the source element that is currently being
                * considered.
                * @type {number}
                */
               nPosition,
               /**
                * A collection of functions used during the consolidation of
                * primitive values and identifier names used as property
                * accessors.
                * @namespace
                * @type {!Object.<string, function(...[*])>}
                */
               oWalkersTransformers = {
                 /**
                  * If the String value that is equivalent to the sequence of
                  * terminal symbols that constitute the encountered identifier
                  * name is worthwhile, a syntactic conversion from the dot
                  * notation to the bracket notation ensues with that sequence
                  * being substituted by an identifier name to which the value
                  * is assigned.
                  * Applies to property accessors that use the dot notation.
                  * @param {!TSyntacticCodeUnit} oExpression The nonterminal
                  *     MemberExpression.
                  * @param {string} sIdentifierName The identifier name used as
                  *     the property accessor.
                  * @return {!Array} A syntactic code unit that is equivalent to
                  *     the one encountered.
                  * @see TPrimitiveValue#nSaving
                  */
                 'dot': function(oExpression, sIdentifierName) {
                   /**
                    * The prefixed String value that is equivalent to the
                    * sequence of terminal symbols that constitute the
                    * encountered identifier name.
                    * @type {string}
                    */
                   var sPrefixed = EValuePrefixes.S_STRING + sIdentifierName;

                   return oSolutionBest.oPrimitiveValues.hasOwnProperty(
                       sPrefixed) &&
                       oSolutionBest.oPrimitiveValues[sPrefixed].nSaving > 0 ?
                       ['sub',
                        oWalker.walk(oExpression),
                        ['name',
                         oSolutionBest.oPrimitiveValues[sPrefixed].sName]] :
                       ['dot', oWalker.walk(oExpression), sIdentifierName];
                 },
                 /**
                  * If the encountered identifier is a null or Boolean literal
                  * and its value is worthwhile, the identifier is substituted
                  * by an identifier name to which that value is assigned.
                  * Applies to identifier names.
                  * @param {string} sIdentifier The identifier encountered.
                  * @return {!Array} A syntactic code unit that is equivalent to
                  *     the one encountered.
                  * @see TPrimitiveValue#nSaving
                  */
                 'name': function(sIdentifier) {
                   /**
                    * The prefixed representation String of the identifier.
                    * @type {string}
                    */
                   var sPrefixed = EValuePrefixes.S_SYMBOLIC + sIdentifier;

                   return [
                     'name',
                     oSolutionBest.oPrimitiveValues.hasOwnProperty(sPrefixed) &&
                     oSolutionBest.oPrimitiveValues[sPrefixed].nSaving > 0 ?
                     oSolutionBest.oPrimitiveValues[sPrefixed].sName :
                     sIdentifier
                   ];
                 },
                 /**
                  * If the encountered String value is worthwhile, it is
                  * substituted by an identifier name to which that value is
                  * assigned.
                  * Applies to String values.
                  * @param {string} sStringValue The String value of the string
                  *     literal encountered.
                  * @return {!Array} A syntactic code unit that is equivalent to
                  *     the one encountered.
                  * @see TPrimitiveValue#nSaving
                  */
                 'string': function(sStringValue) {
                   /**
                    * The prefixed representation String of the primitive value
                    * of the literal.
                    * @type {string}
                    */
                   var sPrefixed =
                       EValuePrefixes.S_STRING + sStringValue;

                   return oSolutionBest.oPrimitiveValues.hasOwnProperty(
                       sPrefixed) &&
                       oSolutionBest.oPrimitiveValues[sPrefixed].nSaving > 0 ?
                       ['name',
                        oSolutionBest.oPrimitiveValues[sPrefixed].sName] :
                       ['string', sStringValue];
                 }
               },
               /**
                * Such data on what to consolidate within the range of source
                * elements that is currently being considered that lead to the
                * greatest known reduction of the number of the terminal symbols
                * in comparison to the original source text.
                * @type {!TSolution}
                */
               oSolutionBest = new TSolution(),
               /**
                * Data representing an ongoing attempt to find a better
                * reduction of the number of the terminal symbols in comparison
                * to the original source text than the best one that is
                * currently known.
                * @type {!TSolution}
                * @see oSolutionBest
                */
               oSolutionCandidate = new TSolution(),
               /**
                * A record consisting of data about the range of source elements
                * that is currently being examined.
                * @type {!TSourceElementsData}
                */
               oSourceElementsData = new TSourceElementsData(),
               /**
                * Variable declarations for each primitive value that is to be
                * consolidated within the elements.
                * @type {!Array.<!Array>}
                */
               aVariableDeclarations = [],
               /**
                * Augments a list with a prefixed representation String.
                * @param {!Array.<string>} aList A list that is to be augmented.
                * @return {function(string)} A function that augments a list
                *     with a prefixed representation String.
                */
               cAugmentList = function(aList) {
                 /**
                  * @param {string} sPrefixed Prefixed representation String of
                  *     a primitive value that could be consolidated within the
                  *     elements.
                  */
                 var fLambda = function(sPrefixed) {
                   if (-1 === aList.indexOf(sPrefixed)) {
                     aList.push(sPrefixed);
                   }
                 };

                 return fLambda;
               },
               /**
                * Adds the number of occurrences of a primitive value of a given
                * category that could be consolidated in the source element with
                * a given index to the count of occurrences of that primitive
                * value within the range of source elements that is currently
                * being considered.
                * @param {number} nPosition The index (in the source text order)
                *     of a source element.
                * @param {number} nCategory The category of the primary
                *     expression from which the primitive value is derived.
                * @return {function(string)} A function that performs the
                *     addition.
                * @see cAddOccurrencesInCategory
                */
               cAddOccurrences = function(nPosition, nCategory) {
                 /**
                  * @param {string} sPrefixed The prefixed representation String
                  *     of a primitive value.
                  */
                 var fLambda = function(sPrefixed) {
                   if (!oSourceElementsData.aCount[nCategory].hasOwnProperty(
                           sPrefixed)) {
                     oSourceElementsData.aCount[nCategory][sPrefixed] = 0;
                   }
                   oSourceElementsData.aCount[nCategory][sPrefixed] +=
                       aSourceElementsData[nPosition].aCount[nCategory][
                           sPrefixed];
                 };

                 return fLambda;
               },
               /**
                * Adds the number of occurrences of each primitive value of a
                * given category that could be consolidated in the source
                * element with a given index to the count of occurrences of that
                * primitive values within the range of source elements that is
                * currently being considered.
                * @param {number} nPosition The index (in the source text order)
                *     of a source element.
                * @return {function(number)} A function that performs the
                *     addition.
                * @see fAddOccurrences
                */
               cAddOccurrencesInCategory = function(nPosition) {
                 /**
                  * @param {number} nCategory The category of the primary
                  *     expression from which the primitive value is derived.
                  */
                 var fLambda = function(nCategory) {
                   Object.keys(
                       aSourceElementsData[nPosition].aCount[nCategory]
                   ).forEach(cAddOccurrences(nPosition, nCategory));
                 };

                 return fLambda;
               },
               /**
                * Adds the number of occurrences of each primitive value that
                * could be consolidated in the source element with a given index
                * to the count of occurrences of that primitive values within
                * the range of source elements that is currently being
                * considered.
                * @param {number} nPosition The index (in the source text order)
                *     of a source element.
                */
               fAddOccurrences = function(nPosition) {
                 Object.keys(aSourceElementsData[nPosition].aCount).forEach(
                     cAddOccurrencesInCategory(nPosition));
               },
               /**
                * Creates a variable declaration for a primitive value if that
                * primitive value is to be consolidated within the elements.
                * @param {string} sPrefixed Prefixed representation String of a
                *     primitive value that could be consolidated within the
                *     elements.
                * @see aVariableDeclarations
                */
               cAugmentVariableDeclarations = function(sPrefixed) {
                 if (oSolutionBest.oPrimitiveValues[sPrefixed].nSaving > 0) {
                   aVariableDeclarations.push([
                     oSolutionBest.oPrimitiveValues[sPrefixed].sName,
                     [0 === sPrefixed.indexOf(EValuePrefixes.S_SYMBOLIC) ?
                      'name' : 'string',
                      sPrefixed.substring(EValuePrefixes.S_SYMBOLIC.length)]
                   ]);
                 }
               },
               /**
                * Sorts primitive values with regard to the difference in the
                * number of terminal symbols between the original source text
                * and the one with those primitive values consolidated.
                * @param {string} sPrefixed0 The prefixed representation String
                *     of the first of the two primitive values that are being
                *     compared.
                * @param {string} sPrefixed1 The prefixed representation String
                *     of the second of the two primitive values that are being
                *     compared.
                * @return {number}
                *     <dl>
                *         <dt>-1</dt>
                *         <dd>if the first primitive value must be placed before
                *              the other one,</dd>
                *         <dt>0</dt>
                *         <dd>if the first primitive value may be placed before
                *              the other one,</dd>
                *         <dt>1</dt>
                *         <dd>if the first primitive value must not be placed
                *              before the other one.</dd>
                *     </dl>
                * @see TSolution.oPrimitiveValues
                */
               cSortPrimitiveValues = function(sPrefixed0, sPrefixed1) {
                 /**
                  * The difference between:
                  * <ol>
                  * <li>the difference in the number of terminal symbols
                  *     between the original source text and the one with the
                  *     first primitive value consolidated, and</li>
                  * <li>the difference in the number of terminal symbols
                  *     between the original source text and the one with the
                  *     second primitive value consolidated.</li>
                  * </ol>
                  * @type {number}
                  */
                 var nDifference =
                     oSolutionCandidate.oPrimitiveValues[sPrefixed0].nSaving -
                     oSolutionCandidate.oPrimitiveValues[sPrefixed1].nSaving;

                 return nDifference > 0 ? -1 : nDifference < 0 ? 1 : 0;
               },
               /**
                * Assigns an identifier name to a primitive value and calculates
                * whether instances of that primitive value are worth
                * consolidating.
                * @param {string} sPrefixed The prefixed representation String
                *     of a primitive value that is being evaluated.
                */
               fEvaluatePrimitiveValue = function(sPrefixed) {
                 var _,
                     /**
                      * The index of the last mangled name.
                      * @type {number}
                      */
                     nIndex,
                     /**
                      * The representation String of the primitive value that is
                      * being evaluated.
                      * @type {string}
                      */
                     sName =
                         sPrefixed.substring(EValuePrefixes.S_SYMBOLIC.length),
                     /**
                      * The number of source characters taken up by the
                      * representation String of the primitive value that is
                      * being evaluated.
                      * @type {number}
                      */
                     nLengthOriginal = sName.length,
                     /**
                      * The number of source characters taken up by the
                      * identifier name that could substitute the primitive
                      * value that is being evaluated.
                      * substituted.
                      * @type {number}
                      */
                     nLengthSubstitution,
                     /**
                      * The number of source characters taken up by by the
                      * representation String of the primitive value that is
                      * being evaluated when it is represented by a string
                      * literal.
                      * @type {number}
                      */
                     nLengthString = oProcessor.make_string(sName).length;

                 oSolutionCandidate.oPrimitiveValues[sPrefixed] =
                     new TPrimitiveValue();
                 do {  // Find an identifier unused in this or any nested scope.
                   nIndex = oScope.cname;
                   oSolutionCandidate.oPrimitiveValues[sPrefixed].sName =
                       oScope.next_mangled();
                 } while (-1 !== oSourceElementsData.aIdentifiers.indexOf(
                     oSolutionCandidate.oPrimitiveValues[sPrefixed].sName));
                 nLengthSubstitution = oSolutionCandidate.oPrimitiveValues[
                     sPrefixed].sName.length;
                 if (0 === sPrefixed.indexOf(EValuePrefixes.S_SYMBOLIC)) {
                   // foo:null, or foo:null;
                   oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving -=
                       nLengthSubstitution + nLengthOriginal +
                       oWeights.N_VARIABLE_DECLARATION;
                   // null vs foo
                   oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving +=
                       oSourceElementsData.aCount[
                           EPrimaryExpressionCategories.
                               N_NULL_AND_BOOLEAN_LITERALS][sPrefixed] *
                       (nLengthOriginal - nLengthSubstitution);
                 } else {
                   // foo:'fromCharCode';
                   oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving -=
                       nLengthSubstitution + nLengthString +
                       oWeights.N_VARIABLE_DECLARATION;
                   // .fromCharCode vs [foo]
                   if (oSourceElementsData.aCount[
                           EPrimaryExpressionCategories.N_IDENTIFIER_NAMES
                       ].hasOwnProperty(sPrefixed)) {
                     oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving +=
                         oSourceElementsData.aCount[
                             EPrimaryExpressionCategories.N_IDENTIFIER_NAMES
                         ][sPrefixed] *
                         (nLengthOriginal - nLengthSubstitution -
                          oWeights.N_PROPERTY_ACCESSOR);
                   }
                   // 'fromCharCode' vs foo
                   if (oSourceElementsData.aCount[
                           EPrimaryExpressionCategories.N_STRING_LITERALS
                       ].hasOwnProperty(sPrefixed)) {
                     oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving +=
                         oSourceElementsData.aCount[
                             EPrimaryExpressionCategories.N_STRING_LITERALS
                         ][sPrefixed] *
                         (nLengthString - nLengthSubstitution);
                   }
                 }
                 if (oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving >
                     0) {
                   oSolutionCandidate.nSavings +=
                       oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving;
                 } else {
                   oScope.cname = nIndex; // Free the identifier name.
                 }
               },
               /**
                * Adds a variable declaration to an existing variable statement.
                * @param {!Array} aVariableDeclaration A variable declaration
                *     with an initialiser.
                */
               cAddVariableDeclaration = function(aVariableDeclaration) {
                 (/** @type {!Array} */ oSourceElements[nFrom][1]).unshift(
                     aVariableDeclaration);
               };

           if (nFrom > nTo) {
             return;
           }
           // If the range is a closure, reuse the closure.
           if (nFrom === nTo &&
               'stat' === oSourceElements[nFrom][0] &&
               'call' === oSourceElements[nFrom][1][0] &&
               'function' === oSourceElements[nFrom][1][1][0]) {
             fExamineSyntacticCodeUnit(oSourceElements[nFrom][1][1]);
             return;
           }
           // Create a list of all derived primitive values within the range.
           for (nPosition = nFrom; nPosition <= nTo; nPosition += 1) {
             aSourceElementsData[nPosition].aPrimitiveValues.forEach(
                 cAugmentList(oSourceElementsData.aPrimitiveValues));
           }
           if (0 === oSourceElementsData.aPrimitiveValues.length) {
             return;
           }
           for (nPosition = nFrom; nPosition <= nTo; nPosition += 1) {
             // Add the number of occurrences to the total count.
             fAddOccurrences(nPosition);
             // Add identifiers of this or any nested scope to the list.
             aSourceElementsData[nPosition].aIdentifiers.forEach(
                 cAugmentList(oSourceElementsData.aIdentifiers));
           }
           // Distribute identifier names among derived primitive values.
           do {  // If there was any progress, find a better distribution.
             oSolutionBest = oSolutionCandidate;
             if (Object.keys(oSolutionCandidate.oPrimitiveValues).length > 0) {
               // Sort primitive values descending by their worthwhileness.
               oSourceElementsData.aPrimitiveValues.sort(cSortPrimitiveValues);
             }
             oSolutionCandidate = new TSolution();
             oSourceElementsData.aPrimitiveValues.forEach(
                 fEvaluatePrimitiveValue);
             oScope.cname = nIndex;
           } while (oSolutionCandidate.nSavings > oSolutionBest.nSavings);
           // Take the necessity of adding a variable statement into account.
           if ('var' !== oSourceElements[nFrom][0]) {
             oSolutionBest.nSavings -= oWeights.N_VARIABLE_STATEMENT_AFFIXATION;
           }
           if (bEnclose) {
             // Take the necessity of forming a closure into account.
             oSolutionBest.nSavings -= oWeights.N_CLOSURE;
           }
           if (oSolutionBest.nSavings > 0) {
             // Create variable declarations suitable for UglifyJS.
             Object.keys(oSolutionBest.oPrimitiveValues).forEach(
                 cAugmentVariableDeclarations);
             // Rewrite expressions that contain worthwhile primitive values.
             for (nPosition = nFrom; nPosition <= nTo; nPosition += 1) {
               oWalker = oProcessor.ast_walker();
               oSourceElements[nPosition] =
                   oWalker.with_walkers(
                       oWalkersTransformers,
                       cContext(oWalker, oSourceElements[nPosition]));
             }
             if ('var' === oSourceElements[nFrom][0]) {  // Reuse the statement.
               (/** @type {!Array.<!Array>} */ aVariableDeclarations.reverse(
                   )).forEach(cAddVariableDeclaration);
             } else {  // Add a variable statement.
               Array.prototype.splice.call(
                   oSourceElements,
                   nFrom,
                   0,
                   ['var', aVariableDeclarations]);
               nTo += 1;
             }
             if (bEnclose) {
               // Add a closure.
               Array.prototype.splice.call(
                   oSourceElements,
                   nFrom,
                   0,
                   ['stat', ['call', ['function', null, [], []], []]]);
               // Copy source elements into the closure.
               for (nPosition = nTo + 1; nPosition > nFrom; nPosition -= 1) {
                 Array.prototype.unshift.call(
                     oSourceElements[nFrom][1][1][3],
                     oSourceElements[nPosition]);
               }
               // Remove source elements outside the closure.
               Array.prototype.splice.call(
                   oSourceElements,
                   nFrom + 1,
                   nTo - nFrom + 1);
             }
           }
           if (bEnclose) {
             // Restore the availability of identifier names.
             oScope.cname = nIndex;
           }
         };

     oSourceElements = (/** @type {!TSyntacticCodeUnit} */
         oSyntacticCodeUnit[bIsGlobal ? 1 : 3]);
     if (0 === oSourceElements.length) {
       return;
     }
     oScope = bIsGlobal ? oSyntacticCodeUnit.scope : oSourceElements.scope;
     // Skip a Directive Prologue.
     while (nAfterDirectivePrologue < oSourceElements.length &&
            'directive' === oSourceElements[nAfterDirectivePrologue][0]) {
       nAfterDirectivePrologue += 1;
       aSourceElementsData.push(null);
     }
     if (oSourceElements.length === nAfterDirectivePrologue) {
       return;
     }
     for (nPosition = nAfterDirectivePrologue;
          nPosition < oSourceElements.length;
          nPosition += 1) {
       oSourceElementData = new TSourceElementsData();
       oWalker = oProcessor.ast_walker();
       // Classify a source element.
       // Find its derived primitive values and count their occurrences.
       // Find all identifiers used (including nested scopes).
       oWalker.with_walkers(
           oWalkers.oSurveySourceElement,
           cContext(oWalker, oSourceElements[nPosition]));
       // Establish whether the scope is still wholly examinable.
       bIsWhollyExaminable = bIsWhollyExaminable &&
           ESourceElementCategories.N_WITH !== oSourceElementData.nCategory &&
           ESourceElementCategories.N_EVAL !== oSourceElementData.nCategory;
       aSourceElementsData.push(oSourceElementData);
     }
     if (bIsWhollyExaminable) {  // Examine the whole scope.
       fExamineSourceElements(
           nAfterDirectivePrologue,
           oSourceElements.length - 1,
           false);
     } else {  // Examine unexcluded ranges of source elements.
       for (nPosition = oSourceElements.length - 1;
            nPosition >= nAfterDirectivePrologue;
            nPosition -= 1) {
         oSourceElementData = (/** @type {!TSourceElementsData} */
             aSourceElementsData[nPosition]);
         if (ESourceElementCategories.N_OTHER ===
             oSourceElementData.nCategory) {
           if ('undefined' === typeof nTo) {
             nTo = nPosition;  // Indicate the end of a range.
           }
           // Examine the range if it immediately follows a Directive Prologue.
           if (nPosition === nAfterDirectivePrologue) {
             fExamineSourceElements(nPosition, nTo, true);
           }
         } else {
           if ('undefined' !== typeof nTo) {
             // Examine the range that immediately follows this source element.
             fExamineSourceElements(nPosition + 1, nTo, true);
             nTo = void 0;  // Obliterate the range.
           }
           // Examine nested functions.
           oWalker = oProcessor.ast_walker();
           oWalker.with_walkers(
               oWalkers.oExamineFunctions,
               cContext(oWalker, oSourceElements[nPosition]));
         }
       }
     }
   }(oAbstractSyntaxTree = oProcessor.ast_add_scope(oAbstractSyntaxTree)));
  return oAbstractSyntaxTree;
};
/*jshint sub:false */

/* Local Variables:      */
/* mode: js              */
/* coding: utf-8         */
/* indent-tabs-mode: nil */
/* tab-width: 2          */
/* End:                  */
/* vim: set ft=javascript fenc=utf-8 et ts=2 sts=2 sw=2: */
/* :mode=javascript:noTabs=true:tabSize=2:indentSize=2:deepIndent=true: */


},{"./process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/process.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/parse-js.js":[function(require,module,exports){
/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.

  This version is suitable for Node.js.  With minimal changes (the
  exports stuff) it should work on any JS platform.

  This file contains the tokenizer/parser.  It is a port to JavaScript
  of parse-js [1], a JavaScript parser library written in Common Lisp
  by Marijn Haverbeke.  Thank you Marijn!

  [1] http://marijn.haverbeke.nl/parse-js/

  Exported functions:

    - tokenizer(code) -- returns a function.  Call the returned
      function to fetch the next token.

    - parse(code) -- returns an AST of the given JavaScript code.

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2010 (c) Mihai Bazon <mihai.bazon@gmail.com>
    Based on parse-js (http://marijn.haverbeke.nl/parse-js/).

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

/* -----[ Tokenizer (constants) ]----- */

var KEYWORDS = array_to_hash([
        "break",
        "case",
        "catch",
        "const",
        "continue",
        "debugger",
        "default",
        "delete",
        "do",
        "else",
        "finally",
        "for",
        "function",
        "if",
        "in",
        "instanceof",
        "new",
        "return",
        "switch",
        "throw",
        "try",
        "typeof",
        "var",
        "void",
        "while",
        "with"
]);

var RESERVED_WORDS = array_to_hash([
        "abstract",
        "boolean",
        "byte",
        "char",
        "class",
        "double",
        "enum",
        "export",
        "extends",
        "final",
        "float",
        "goto",
        "implements",
        "import",
        "int",
        "interface",
        "long",
        "native",
        "package",
        "private",
        "protected",
        "public",
        "short",
        "static",
        "super",
        "synchronized",
        "throws",
        "transient",
        "volatile"
]);

var KEYWORDS_BEFORE_EXPRESSION = array_to_hash([
        "return",
        "new",
        "delete",
        "throw",
        "else",
        "case"
]);

var KEYWORDS_ATOM = array_to_hash([
        "false",
        "null",
        "true",
        "undefined"
]);

var OPERATOR_CHARS = array_to_hash(characters("+-*&%=<>!?|~^"));

var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;
var RE_OCT_NUMBER = /^0[0-7]+$/;
var RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i;

var OPERATORS = array_to_hash([
        "in",
        "instanceof",
        "typeof",
        "new",
        "void",
        "delete",
        "++",
        "--",
        "+",
        "-",
        "!",
        "~",
        "&",
        "|",
        "^",
        "*",
        "/",
        "%",
        ">>",
        "<<",
        ">>>",
        "<",
        ">",
        "<=",
        ">=",
        "==",
        "===",
        "!=",
        "!==",
        "?",
        "=",
        "+=",
        "-=",
        "/=",
        "*=",
        "%=",
        ">>=",
        "<<=",
        ">>>=",
        "|=",
        "^=",
        "&=",
        "&&",
        "||"
]);

var WHITESPACE_CHARS = array_to_hash(characters(" \u00a0\n\r\t\f\u000b\u200b\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000"));

var PUNC_BEFORE_EXPRESSION = array_to_hash(characters("[{(,.;:"));

var PUNC_CHARS = array_to_hash(characters("[]{}(),;:"));

var REGEXP_MODIFIERS = array_to_hash(characters("gmsiy"));

/* -----[ Tokenizer ]----- */

var UNICODE = {  // Unicode 6.1
        letter: new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
        combining_mark: new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08E4-\\u08FE\\u0900-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C01-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C82\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D02\\u0D03\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F\\u109A-\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF2-\\u1CF4\\u1DC0-\\u1DE6\\u1DFC-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA674-\\uA67D\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA7B\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),
        connector_punctuation: new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]"),
        digit: new RegExp("[\\u0030-\\u0039\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]")
};

function is_letter(ch) {
        return UNICODE.letter.test(ch);
};

function is_digit(ch) {
        ch = ch.charCodeAt(0);
        return ch >= 48 && ch <= 57;
};

function is_unicode_digit(ch) {
        return UNICODE.digit.test(ch);
}

function is_alphanumeric_char(ch) {
        return is_digit(ch) || is_letter(ch);
};

function is_unicode_combining_mark(ch) {
        return UNICODE.combining_mark.test(ch);
};

function is_unicode_connector_punctuation(ch) {
        return UNICODE.connector_punctuation.test(ch);
};

function is_identifier_start(ch) {
        return ch == "$" || ch == "_" || is_letter(ch);
};

function is_identifier_char(ch) {
        return is_identifier_start(ch)
                || is_unicode_combining_mark(ch)
                || is_unicode_digit(ch)
                || is_unicode_connector_punctuation(ch)
                || ch == "\u200c" // zero-width non-joiner <ZWNJ>
                || ch == "\u200d" // zero-width joiner <ZWJ> (in my ECMA-262 PDF, this is also 200c)
        ;
};

function parse_js_number(num) {
        if (RE_HEX_NUMBER.test(num)) {
                return parseInt(num.substr(2), 16);
        } else if (RE_OCT_NUMBER.test(num)) {
                return parseInt(num.substr(1), 8);
        } else if (RE_DEC_NUMBER.test(num)) {
                return parseFloat(num);
        }
};

function JS_Parse_Error(message, line, col, pos) {
        this.message = message;
        this.line = line + 1;
        this.col = col + 1;
        this.pos = pos + 1;
        this.stack = new Error().stack;
};

JS_Parse_Error.prototype.toString = function() {
        return this.message + " (line: " + this.line + ", col: " + this.col + ", pos: " + this.pos + ")" + "\n\n" + this.stack;
};

function js_error(message, line, col, pos) {
        throw new JS_Parse_Error(message, line, col, pos);
};

function is_token(token, type, val) {
        return token.type == type && (val == null || token.value == val);
};

var EX_EOF = {};

function tokenizer($TEXT) {

        var S = {
                text            : $TEXT.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/^\uFEFF/, ''),
                pos             : 0,
                tokpos          : 0,
                line            : 0,
                tokline         : 0,
                col             : 0,
                tokcol          : 0,
                newline_before  : false,
                regex_allowed   : false,
                comments_before : []
        };

        function peek() { return S.text.charAt(S.pos); };

        function next(signal_eof, in_string) {
                var ch = S.text.charAt(S.pos++);
                if (signal_eof && !ch)
                        throw EX_EOF;
                if (ch == "\n") {
                        S.newline_before = S.newline_before || !in_string;
                        ++S.line;
                        S.col = 0;
                } else {
                        ++S.col;
                }
                return ch;
        };

        function eof() {
                return !S.peek();
        };

        function find(what, signal_eof) {
                var pos = S.text.indexOf(what, S.pos);
                if (signal_eof && pos == -1) throw EX_EOF;
                return pos;
        };

        function start_token() {
                S.tokline = S.line;
                S.tokcol = S.col;
                S.tokpos = S.pos;
        };

        function token(type, value, is_comment) {
                S.regex_allowed = ((type == "operator" && !HOP(UNARY_POSTFIX, value)) ||
                                   (type == "keyword" && HOP(KEYWORDS_BEFORE_EXPRESSION, value)) ||
                                   (type == "punc" && HOP(PUNC_BEFORE_EXPRESSION, value)));
                var ret = {
                        type   : type,
                        value  : value,
                        line   : S.tokline,
                        col    : S.tokcol,
                        pos    : S.tokpos,
                        endpos : S.pos,
                        nlb    : S.newline_before
                };
                if (!is_comment) {
                        ret.comments_before = S.comments_before;
                        S.comments_before = [];
                        // make note of any newlines in the comments that came before
                        for (var i = 0, len = ret.comments_before.length; i < len; i++) {
                                ret.nlb = ret.nlb || ret.comments_before[i].nlb;
                        }
                }
                S.newline_before = false;
                return ret;
        };

        function skip_whitespace() {
                while (HOP(WHITESPACE_CHARS, peek()))
                        next();
        };

        function read_while(pred) {
                var ret = "", ch = peek(), i = 0;
                while (ch && pred(ch, i++)) {
                        ret += next();
                        ch = peek();
                }
                return ret;
        };

        function parse_error(err) {
                js_error(err, S.tokline, S.tokcol, S.tokpos);
        };

        function read_num(prefix) {
                var has_e = false, after_e = false, has_x = false, has_dot = prefix == ".";
                var num = read_while(function(ch, i){
                        if (ch == "x" || ch == "X") {
                                if (has_x) return false;
                                return has_x = true;
                        }
                        if (!has_x && (ch == "E" || ch == "e")) {
                                if (has_e) return false;
                                return has_e = after_e = true;
                        }
                        if (ch == "-") {
                                if (after_e || (i == 0 && !prefix)) return true;
                                return false;
                        }
                        if (ch == "+") return after_e;
                        after_e = false;
                        if (ch == ".") {
                                if (!has_dot && !has_x && !has_e)
                                        return has_dot = true;
                                return false;
                        }
                        return is_alphanumeric_char(ch);
                });
                if (prefix)
                        num = prefix + num;
                var valid = parse_js_number(num);
                if (!isNaN(valid)) {
                        return token("num", valid);
                } else {
                        parse_error("Invalid syntax: " + num);
                }
        };

        function read_escaped_char(in_string) {
                var ch = next(true, in_string);
                switch (ch) {
                    case "n" : return "\n";
                    case "r" : return "\r";
                    case "t" : return "\t";
                    case "b" : return "\b";
                    case "v" : return "\u000b";
                    case "f" : return "\f";
                    case "0" : return "\0";
                    case "x" : return String.fromCharCode(hex_bytes(2));
                    case "u" : return String.fromCharCode(hex_bytes(4));
                    case "\n": return "";
                    default  : return ch;
                }
        };

        function hex_bytes(n) {
                var num = 0;
                for (; n > 0; --n) {
                        var digit = parseInt(next(true), 16);
                        if (isNaN(digit))
                                parse_error("Invalid hex-character pattern in string");
                        num = (num << 4) | digit;
                }
                return num;
        };

        function read_string() {
                return with_eof_error("Unterminated string constant", function(){
                        var quote = next(), ret = "";
                        for (;;) {
                                var ch = next(true);
                                if (ch == "\\") {
                                        // read OctalEscapeSequence (XXX: deprecated if "strict mode")
                                        // https://github.com/mishoo/UglifyJS/issues/178
                                        var octal_len = 0, first = null;
                                        ch = read_while(function(ch){
                                                if (ch >= "0" && ch <= "7") {
                                                        if (!first) {
                                                                first = ch;
                                                                return ++octal_len;
                                                        }
                                                        else if (first <= "3" && octal_len <= 2) return ++octal_len;
                                                        else if (first >= "4" && octal_len <= 1) return ++octal_len;
                                                }
                                                return false;
                                        });
                                        if (octal_len > 0) ch = String.fromCharCode(parseInt(ch, 8));
                                        else ch = read_escaped_char(true);
                                }
                                else if (ch == quote) break;
                                ret += ch;
                        }
                        return token("string", ret);
                });
        };

        function read_line_comment() {
                next();
                var i = find("\n"), ret;
                if (i == -1) {
                        ret = S.text.substr(S.pos);
                        S.pos = S.text.length;
                } else {
                        ret = S.text.substring(S.pos, i);
                        S.pos = i;
                }
                return token("comment1", ret, true);
        };

        function read_multiline_comment() {
                next();
                return with_eof_error("Unterminated multiline comment", function(){
                        var i = find("*/", true),
                            text = S.text.substring(S.pos, i);
                        S.pos = i + 2;
                        S.line += text.split("\n").length - 1;
                        S.newline_before = S.newline_before || text.indexOf("\n") >= 0;

                        // https://github.com/mishoo/UglifyJS/issues/#issue/100
                        if (/^@cc_on/i.test(text)) {
                                warn("WARNING: at line " + S.line);
                                warn("*** Found \"conditional comment\": " + text);
                                warn("*** UglifyJS DISCARDS ALL COMMENTS.  This means your code might no longer work properly in Internet Explorer.");
                        }

                        return token("comment2", text, true);
                });
        };

        function read_name() {
                var backslash = false, name = "", ch, escaped = false, hex;
                while ((ch = peek()) != null) {
                        if (!backslash) {
                                if (ch == "\\") escaped = backslash = true, next();
                                else if (is_identifier_char(ch)) name += next();
                                else break;
                        }
                        else {
                                if (ch != "u") parse_error("Expecting UnicodeEscapeSequence -- uXXXX");
                                ch = read_escaped_char();
                                if (!is_identifier_char(ch)) parse_error("Unicode char: " + ch.charCodeAt(0) + " is not valid in identifier");
                                name += ch;
                                backslash = false;
                        }
                }
                if (HOP(KEYWORDS, name) && escaped) {
                        hex = name.charCodeAt(0).toString(16).toUpperCase();
                        name = "\\u" + "0000".substr(hex.length) + hex + name.slice(1);
                }
                return name;
        };

        function read_regexp(regexp) {
                return with_eof_error("Unterminated regular expression", function(){
                        var prev_backslash = false, ch, in_class = false;
                        while ((ch = next(true))) if (prev_backslash) {
                                regexp += "\\" + ch;
                                prev_backslash = false;
                        } else if (ch == "[") {
                                in_class = true;
                                regexp += ch;
                        } else if (ch == "]" && in_class) {
                                in_class = false;
                                regexp += ch;
                        } else if (ch == "/" && !in_class) {
                                break;
                        } else if (ch == "\\") {
                                prev_backslash = true;
                        } else {
                                regexp += ch;
                        }
                        var mods = read_name();
                        return token("regexp", [ regexp, mods ]);
                });
        };

        function read_operator(prefix) {
                function grow(op) {
                        if (!peek()) return op;
                        var bigger = op + peek();
                        if (HOP(OPERATORS, bigger)) {
                                next();
                                return grow(bigger);
                        } else {
                                return op;
                        }
                };
                return token("operator", grow(prefix || next()));
        };

        function handle_slash() {
                next();
                var regex_allowed = S.regex_allowed;
                switch (peek()) {
                    case "/":
                        S.comments_before.push(read_line_comment());
                        S.regex_allowed = regex_allowed;
                        return next_token();
                    case "*":
                        S.comments_before.push(read_multiline_comment());
                        S.regex_allowed = regex_allowed;
                        return next_token();
                }
                return S.regex_allowed ? read_regexp("") : read_operator("/");
        };

        function handle_dot() {
                next();
                return is_digit(peek())
                        ? read_num(".")
                        : token("punc", ".");
        };

        function read_word() {
                var word = read_name();
                return !HOP(KEYWORDS, word)
                        ? token("name", word)
                        : HOP(OPERATORS, word)
                        ? token("operator", word)
                        : HOP(KEYWORDS_ATOM, word)
                        ? token("atom", word)
                        : token("keyword", word);
        };

        function with_eof_error(eof_error, cont) {
                try {
                        return cont();
                } catch(ex) {
                        if (ex === EX_EOF) parse_error(eof_error);
                        else throw ex;
                }
        };

        function next_token(force_regexp) {
                if (force_regexp != null)
                        return read_regexp(force_regexp);
                skip_whitespace();
                start_token();
                var ch = peek();
                if (!ch) return token("eof");
                if (is_digit(ch)) return read_num();
                if (ch == '"' || ch == "'") return read_string();
                if (HOP(PUNC_CHARS, ch)) return token("punc", next());
                if (ch == ".") return handle_dot();
                if (ch == "/") return handle_slash();
                if (HOP(OPERATOR_CHARS, ch)) return read_operator();
                if (ch == "\\" || is_identifier_start(ch)) return read_word();
                parse_error("Unexpected character '" + ch + "'");
        };

        next_token.context = function(nc) {
                if (nc) S = nc;
                return S;
        };

        return next_token;

};

/* -----[ Parser (constants) ]----- */

var UNARY_PREFIX = array_to_hash([
        "typeof",
        "void",
        "delete",
        "--",
        "++",
        "!",
        "~",
        "-",
        "+"
]);

var UNARY_POSTFIX = array_to_hash([ "--", "++" ]);

var ASSIGNMENT = (function(a, ret, i){
        while (i < a.length) {
                ret[a[i]] = a[i].substr(0, a[i].length - 1);
                i++;
        }
        return ret;
})(
        ["+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&="],
        { "=": true },
        0
);

var PRECEDENCE = (function(a, ret){
        for (var i = 0, n = 1; i < a.length; ++i, ++n) {
                var b = a[i];
                for (var j = 0; j < b.length; ++j) {
                        ret[b[j]] = n;
                }
        }
        return ret;
})(
        [
                ["||"],
                ["&&"],
                ["|"],
                ["^"],
                ["&"],
                ["==", "===", "!=", "!=="],
                ["<", ">", "<=", ">=", "in", "instanceof"],
                [">>", "<<", ">>>"],
                ["+", "-"],
                ["*", "/", "%"]
        ],
        {}
);

var STATEMENTS_WITH_LABELS = array_to_hash([ "for", "do", "while", "switch" ]);

var ATOMIC_START_TOKEN = array_to_hash([ "atom", "num", "string", "regexp", "name" ]);

/* -----[ Parser ]----- */

function NodeWithToken(str, start, end) {
        this.name = str;
        this.start = start;
        this.end = end;
};

NodeWithToken.prototype.toString = function() { return this.name; };

function parse($TEXT, exigent_mode, embed_tokens) {

        var S = {
                input         : typeof $TEXT == "string" ? tokenizer($TEXT, true) : $TEXT,
                token         : null,
                prev          : null,
                peeked        : null,
                in_function   : 0,
                in_directives : true,
                in_loop       : 0,
                labels        : []
        };

        S.token = next();

        function is(type, value) {
                return is_token(S.token, type, value);
        };

        function peek() { return S.peeked || (S.peeked = S.input()); };

        function next() {
                S.prev = S.token;
                if (S.peeked) {
                        S.token = S.peeked;
                        S.peeked = null;
                } else {
                        S.token = S.input();
                }
                S.in_directives = S.in_directives && (
                        S.token.type == "string" || is("punc", ";")
                );
                return S.token;
        };

        function prev() {
                return S.prev;
        };

        function croak(msg, line, col, pos) {
                var ctx = S.input.context();
                js_error(msg,
                         line != null ? line : ctx.tokline,
                         col != null ? col : ctx.tokcol,
                         pos != null ? pos : ctx.tokpos);
        };

        function token_error(token, msg) {
                croak(msg, token.line, token.col);
        };

        function unexpected(token) {
                if (token == null)
                        token = S.token;
                token_error(token, "Unexpected token: " + token.type + " (" + token.value + ")");
        };

        function expect_token(type, val) {
                if (is(type, val)) {
                        return next();
                }
                token_error(S.token, "Unexpected token " + S.token.type + ", expected " + type);
        };

        function expect(punc) { return expect_token("punc", punc); };

        function can_insert_semicolon() {
                return !exigent_mode && (
                        S.token.nlb || is("eof") || is("punc", "}")
                );
        };

        function semicolon() {
                if (is("punc", ";")) next();
                else if (!can_insert_semicolon()) unexpected();
        };

        function as() {
                return slice(arguments);
        };

        function parenthesised() {
                expect("(");
                var ex = expression();
                expect(")");
                return ex;
        };

        function add_tokens(str, start, end) {
                return str instanceof NodeWithToken ? str : new NodeWithToken(str, start, end);
        };

        function maybe_embed_tokens(parser) {
                if (embed_tokens) return function() {
                        var start = S.token;
                        var ast = parser.apply(this, arguments);
                        ast[0] = add_tokens(ast[0], start, prev());
                        return ast;
                };
                else return parser;
        };

        var statement = maybe_embed_tokens(function() {
                if (is("operator", "/") || is("operator", "/=")) {
                        S.peeked = null;
                        S.token = S.input(S.token.value.substr(1)); // force regexp
                }
                switch (S.token.type) {
                    case "string":
                        var dir = S.in_directives, stat = simple_statement();
                        if (dir && stat[1][0] == "string" && !is("punc", ","))
                            return as("directive", stat[1][1]);
                        return stat;
                    case "num":
                    case "regexp":
                    case "operator":
                    case "atom":
                        return simple_statement();

                    case "name":
                        return is_token(peek(), "punc", ":")
                                ? labeled_statement(prog1(S.token.value, next, next))
                                : simple_statement();

                    case "punc":
                        switch (S.token.value) {
                            case "{":
                                return as("block", block_());
                            case "[":
                            case "(":
                                return simple_statement();
                            case ";":
                                next();
                                return as("block");
                            default:
                                unexpected();
                        }

                    case "keyword":
                        switch (prog1(S.token.value, next)) {
                            case "break":
                                return break_cont("break");

                            case "continue":
                                return break_cont("continue");

                            case "debugger":
                                semicolon();
                                return as("debugger");

                            case "do":
                                return (function(body){
                                        expect_token("keyword", "while");
                                        return as("do", prog1(parenthesised, semicolon), body);
                                })(in_loop(statement));

                            case "for":
                                return for_();

                            case "function":
                                return function_(true);

                            case "if":
                                return if_();

                            case "return":
                                if (S.in_function == 0)
                                        croak("'return' outside of function");
                                return as("return",
                                          is("punc", ";")
                                          ? (next(), null)
                                          : can_insert_semicolon()
                                          ? null
                                          : prog1(expression, semicolon));

                            case "switch":
                                return as("switch", parenthesised(), switch_block_());

                            case "throw":
                                if (S.token.nlb)
                                        croak("Illegal newline after 'throw'");
                                return as("throw", prog1(expression, semicolon));

                            case "try":
                                return try_();

                            case "var":
                                return prog1(var_, semicolon);

                            case "const":
                                return prog1(const_, semicolon);

                            case "while":
                                return as("while", parenthesised(), in_loop(statement));

                            case "with":
                                return as("with", parenthesised(), statement());

                            default:
                                unexpected();
                        }
                }
        });

        function labeled_statement(label) {
                S.labels.push(label);
                var start = S.token, stat = statement();
                if (exigent_mode && !HOP(STATEMENTS_WITH_LABELS, stat[0]))
                        unexpected(start);
                S.labels.pop();
                return as("label", label, stat);
        };

        function simple_statement() {
                return as("stat", prog1(expression, semicolon));
        };

        function break_cont(type) {
                var name;
                if (!can_insert_semicolon()) {
                        name = is("name") ? S.token.value : null;
                }
                if (name != null) {
                        next();
                        if (!member(name, S.labels))
                                croak("Label " + name + " without matching loop or statement");
                }
                else if (S.in_loop == 0)
                        croak(type + " not inside a loop or switch");
                semicolon();
                return as(type, name);
        };

        function for_() {
                expect("(");
                var init = null;
                if (!is("punc", ";")) {
                        init = is("keyword", "var")
                                ? (next(), var_(true))
                                : expression(true, true);
                        if (is("operator", "in")) {
                                if (init[0] == "var" && init[1].length > 1)
                                        croak("Only one variable declaration allowed in for..in loop");
                                return for_in(init);
                        }
                }
                return regular_for(init);
        };

        function regular_for(init) {
                expect(";");
                var test = is("punc", ";") ? null : expression();
                expect(";");
                var step = is("punc", ")") ? null : expression();
                expect(")");
                return as("for", init, test, step, in_loop(statement));
        };

        function for_in(init) {
                var lhs = init[0] == "var" ? as("name", init[1][0]) : init;
                next();
                var obj = expression();
                expect(")");
                return as("for-in", init, lhs, obj, in_loop(statement));
        };

        var function_ = function(in_statement) {
                var name = is("name") ? prog1(S.token.value, next) : null;
                if (in_statement && !name)
                        unexpected();
                expect("(");
                return as(in_statement ? "defun" : "function",
                          name,
                          // arguments
                          (function(first, a){
                                  while (!is("punc", ")")) {
                                          if (first) first = false; else expect(",");
                                          if (!is("name")) unexpected();
                                          a.push(S.token.value);
                                          next();
                                  }
                                  next();
                                  return a;
                          })(true, []),
                          // body
                          (function(){
                                  ++S.in_function;
                                  var loop = S.in_loop;
                                  S.in_directives = true;
                                  S.in_loop = 0;
                                  var a = block_();
                                  --S.in_function;
                                  S.in_loop = loop;
                                  return a;
                          })());
        };

        function if_() {
                var cond = parenthesised(), body = statement(), belse;
                if (is("keyword", "else")) {
                        next();
                        belse = statement();
                }
                return as("if", cond, body, belse);
        };

        function block_() {
                expect("{");
                var a = [];
                while (!is("punc", "}")) {
                        if (is("eof")) unexpected();
                        a.push(statement());
                }
                next();
                return a;
        };

        var switch_block_ = curry(in_loop, function(){
                expect("{");
                var a = [], cur = null;
                while (!is("punc", "}")) {
                        if (is("eof")) unexpected();
                        if (is("keyword", "case")) {
                                next();
                                cur = [];
                                a.push([ expression(), cur ]);
                                expect(":");
                        }
                        else if (is("keyword", "default")) {
                                next();
                                expect(":");
                                cur = [];
                                a.push([ null, cur ]);
                        }
                        else {
                                if (!cur) unexpected();
                                cur.push(statement());
                        }
                }
                next();
                return a;
        });

        function try_() {
                var body = block_(), bcatch, bfinally;
                if (is("keyword", "catch")) {
                        next();
                        expect("(");
                        if (!is("name"))
                                croak("Name expected");
                        var name = S.token.value;
                        next();
                        expect(")");
                        bcatch = [ name, block_() ];
                }
                if (is("keyword", "finally")) {
                        next();
                        bfinally = block_();
                }
                if (!bcatch && !bfinally)
                        croak("Missing catch/finally blocks");
                return as("try", body, bcatch, bfinally);
        };

        function vardefs(no_in) {
                var a = [];
                for (;;) {
                        if (!is("name"))
                                unexpected();
                        var name = S.token.value;
                        next();
                        if (is("operator", "=")) {
                                next();
                                a.push([ name, expression(false, no_in) ]);
                        } else {
                                a.push([ name ]);
                        }
                        if (!is("punc", ","))
                                break;
                        next();
                }
                return a;
        };

        function var_(no_in) {
                return as("var", vardefs(no_in));
        };

        function const_() {
                return as("const", vardefs());
        };

        function new_() {
                var newexp = expr_atom(false), args;
                if (is("punc", "(")) {
                        next();
                        args = expr_list(")");
                } else {
                        args = [];
                }
                return subscripts(as("new", newexp, args), true);
        };

        var expr_atom = maybe_embed_tokens(function(allow_calls) {
                if (is("operator", "new")) {
                        next();
                        return new_();
                }
                if (is("punc")) {
                        switch (S.token.value) {
                            case "(":
                                next();
                                return subscripts(prog1(expression, curry(expect, ")")), allow_calls);
                            case "[":
                                next();
                                return subscripts(array_(), allow_calls);
                            case "{":
                                next();
                                return subscripts(object_(), allow_calls);
                        }
                        unexpected();
                }
                if (is("keyword", "function")) {
                        next();
                        return subscripts(function_(false), allow_calls);
                }
                if (HOP(ATOMIC_START_TOKEN, S.token.type)) {
                        var atom = S.token.type == "regexp"
                                ? as("regexp", S.token.value[0], S.token.value[1])
                                : as(S.token.type, S.token.value);
                        return subscripts(prog1(atom, next), allow_calls);
                }
                unexpected();
        });

        function expr_list(closing, allow_trailing_comma, allow_empty) {
                var first = true, a = [];
                while (!is("punc", closing)) {
                        if (first) first = false; else expect(",");
                        if (allow_trailing_comma && is("punc", closing)) break;
                        if (is("punc", ",") && allow_empty) {
                                a.push([ "atom", "undefined" ]);
                        } else {
                                a.push(expression(false));
                        }
                }
                next();
                return a;
        };

        function array_() {
                return as("array", expr_list("]", !exigent_mode, true));
        };

        function object_() {
                var first = true, a = [];
                while (!is("punc", "}")) {
                        if (first) first = false; else expect(",");
                        if (!exigent_mode && is("punc", "}"))
                                // allow trailing comma
                                break;
                        var type = S.token.type;
                        var name = as_property_name();
                        if (type == "name" && (name == "get" || name == "set") && !is("punc", ":")) {
                                a.push([ as_name(), function_(false), name ]);
                        } else {
                                expect(":");
                                a.push([ name, expression(false) ]);
                        }
                }
                next();
                return as("object", a);
        };

        function as_property_name() {
                switch (S.token.type) {
                    case "num":
                    case "string":
                        return prog1(S.token.value, next);
                }
                return as_name();
        };

        function as_name() {
                switch (S.token.type) {
                    case "name":
                    case "operator":
                    case "keyword":
                    case "atom":
                        return prog1(S.token.value, next);
                    default:
                        unexpected();
                }
        };

        function subscripts(expr, allow_calls) {
                if (is("punc", ".")) {
                        next();
                        return subscripts(as("dot", expr, as_name()), allow_calls);
                }
                if (is("punc", "[")) {
                        next();
                        return subscripts(as("sub", expr, prog1(expression, curry(expect, "]"))), allow_calls);
                }
                if (allow_calls && is("punc", "(")) {
                        next();
                        return subscripts(as("call", expr, expr_list(")")), true);
                }
                return expr;
        };

        function maybe_unary(allow_calls) {
                if (is("operator") && HOP(UNARY_PREFIX, S.token.value)) {
                        return make_unary("unary-prefix",
                                          prog1(S.token.value, next),
                                          maybe_unary(allow_calls));
                }
                var val = expr_atom(allow_calls);
                while (is("operator") && HOP(UNARY_POSTFIX, S.token.value) && !S.token.nlb) {
                        val = make_unary("unary-postfix", S.token.value, val);
                        next();
                }
                return val;
        };

        function make_unary(tag, op, expr) {
                if ((op == "++" || op == "--") && !is_assignable(expr))
                        croak("Invalid use of " + op + " operator");
                return as(tag, op, expr);
        };

        function expr_op(left, min_prec, no_in) {
                var op = is("operator") ? S.token.value : null;
                if (op && op == "in" && no_in) op = null;
                var prec = op != null ? PRECEDENCE[op] : null;
                if (prec != null && prec > min_prec) {
                        next();
                        var right = expr_op(maybe_unary(true), prec, no_in);
                        return expr_op(as("binary", op, left, right), min_prec, no_in);
                }
                return left;
        };

        function expr_ops(no_in) {
                return expr_op(maybe_unary(true), 0, no_in);
        };

        function maybe_conditional(no_in) {
                var expr = expr_ops(no_in);
                if (is("operator", "?")) {
                        next();
                        var yes = expression(false);
                        expect(":");
                        return as("conditional", expr, yes, expression(false, no_in));
                }
                return expr;
        };

        function is_assignable(expr) {
                if (!exigent_mode) return true;
                switch (expr[0]+"") {
                    case "dot":
                    case "sub":
                    case "new":
                    case "call":
                        return true;
                    case "name":
                        return expr[1] != "this";
                }
        };

        function maybe_assign(no_in) {
                var left = maybe_conditional(no_in), val = S.token.value;
                if (is("operator") && HOP(ASSIGNMENT, val)) {
                        if (is_assignable(left)) {
                                next();
                                return as("assign", ASSIGNMENT[val], left, maybe_assign(no_in));
                        }
                        croak("Invalid assignment");
                }
                return left;
        };

        var expression = maybe_embed_tokens(function(commas, no_in) {
                if (arguments.length == 0)
                        commas = true;
                var expr = maybe_assign(no_in);
                if (commas && is("punc", ",")) {
                        next();
                        return as("seq", expr, expression(true, no_in));
                }
                return expr;
        });

        function in_loop(cont) {
                try {
                        ++S.in_loop;
                        return cont();
                } finally {
                        --S.in_loop;
                }
        };

        return as("toplevel", (function(a){
                while (!is("eof"))
                        a.push(statement());
                return a;
        })([]));

};

/* -----[ Utilities ]----- */

function curry(f) {
        var args = slice(arguments, 1);
        return function() { return f.apply(this, args.concat(slice(arguments))); };
};

function prog1(ret) {
        if (ret instanceof Function)
                ret = ret();
        for (var i = 1, n = arguments.length; --n > 0; ++i)
                arguments[i]();
        return ret;
};

function array_to_hash(a) {
        var ret = {};
        for (var i = 0; i < a.length; ++i)
                ret[a[i]] = true;
        return ret;
};

function slice(a, start) {
        return Array.prototype.slice.call(a, start || 0);
};

function characters(str) {
        return str.split("");
};

function member(name, array) {
        for (var i = array.length; --i >= 0;)
                if (array[i] == name)
                        return true;
        return false;
};

function HOP(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
};

var warn = function() {};

/* -----[ Exports ]----- */

exports.tokenizer = tokenizer;
exports.parse = parse;
exports.slice = slice;
exports.curry = curry;
exports.member = member;
exports.array_to_hash = array_to_hash;
exports.PRECEDENCE = PRECEDENCE;
exports.KEYWORDS_ATOM = KEYWORDS_ATOM;
exports.RESERVED_WORDS = RESERVED_WORDS;
exports.KEYWORDS = KEYWORDS;
exports.ATOMIC_START_TOKEN = ATOMIC_START_TOKEN;
exports.OPERATORS = OPERATORS;
exports.is_alphanumeric_char = is_alphanumeric_char;
exports.is_identifier_start = is_identifier_start;
exports.is_identifier_char = is_identifier_char;
exports.set_logger = function(logger) {
        warn = logger;
};

// Local variables:
// js-indent-level: 8
// End:

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/process.js":[function(require,module,exports){
/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.

  This version is suitable for Node.js.  With minimal changes (the
  exports stuff) it should work on any JS platform.

  This file implements some AST processors.  They work on data built
  by parse-js.

  Exported functions:

    - ast_mangle(ast, options) -- mangles the variable/function names
      in the AST.  Returns an AST.

    - ast_squeeze(ast) -- employs various optimizations to make the
      final generated code even smaller.  Returns an AST.

    - gen_code(ast, options) -- generates JS code from the AST.  Pass
      true (or an object, see the code for some options) as second
      argument to get "pretty" (indented) code.

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2010 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

var jsp = require("./parse-js"),
    curry = jsp.curry,
    slice = jsp.slice,
    member = jsp.member,
    is_identifier_char = jsp.is_identifier_char,
    PRECEDENCE = jsp.PRECEDENCE,
    OPERATORS = jsp.OPERATORS;

/* -----[ helper for AST traversal ]----- */

function ast_walker() {
        function _vardefs(defs) {
                return [ this[0], MAP(defs, function(def){
                        var a = [ def[0] ];
                        if (def.length > 1)
                                a[1] = walk(def[1]);
                        return a;
                }) ];
        };
        function _block(statements) {
                var out = [ this[0] ];
                if (statements != null)
                        out.push(MAP(statements, walk));
                return out;
        };
        var walkers = {
                "string": function(str) {
                        return [ this[0], str ];
                },
                "num": function(num) {
                        return [ this[0], num ];
                },
                "name": function(name) {
                        return [ this[0], name ];
                },
                "toplevel": function(statements) {
                        return [ this[0], MAP(statements, walk) ];
                },
                "block": _block,
                "splice": _block,
                "var": _vardefs,
                "const": _vardefs,
                "try": function(t, c, f) {
                        return [
                                this[0],
                                MAP(t, walk),
                                c != null ? [ c[0], MAP(c[1], walk) ] : null,
                                f != null ? MAP(f, walk) : null
                        ];
                },
                "throw": function(expr) {
                        return [ this[0], walk(expr) ];
                },
                "new": function(ctor, args) {
                        return [ this[0], walk(ctor), MAP(args, walk) ];
                },
                "switch": function(expr, body) {
                        return [ this[0], walk(expr), MAP(body, function(branch){
                                return [ branch[0] ? walk(branch[0]) : null,
                                         MAP(branch[1], walk) ];
                        }) ];
                },
                "break": function(label) {
                        return [ this[0], label ];
                },
                "continue": function(label) {
                        return [ this[0], label ];
                },
                "conditional": function(cond, t, e) {
                        return [ this[0], walk(cond), walk(t), walk(e) ];
                },
                "assign": function(op, lvalue, rvalue) {
                        return [ this[0], op, walk(lvalue), walk(rvalue) ];
                },
                "dot": function(expr) {
                        return [ this[0], walk(expr) ].concat(slice(arguments, 1));
                },
                "call": function(expr, args) {
                        return [ this[0], walk(expr), MAP(args, walk) ];
                },
                "function": function(name, args, body) {
                        return [ this[0], name, args.slice(), MAP(body, walk) ];
                },
                "debugger": function() {
                        return [ this[0] ];
                },
                "defun": function(name, args, body) {
                        return [ this[0], name, args.slice(), MAP(body, walk) ];
                },
                "if": function(conditional, t, e) {
                        return [ this[0], walk(conditional), walk(t), walk(e) ];
                },
                "for": function(init, cond, step, block) {
                        return [ this[0], walk(init), walk(cond), walk(step), walk(block) ];
                },
                "for-in": function(vvar, key, hash, block) {
                        return [ this[0], walk(vvar), walk(key), walk(hash), walk(block) ];
                },
                "while": function(cond, block) {
                        return [ this[0], walk(cond), walk(block) ];
                },
                "do": function(cond, block) {
                        return [ this[0], walk(cond), walk(block) ];
                },
                "return": function(expr) {
                        return [ this[0], walk(expr) ];
                },
                "binary": function(op, left, right) {
                        return [ this[0], op, walk(left), walk(right) ];
                },
                "unary-prefix": function(op, expr) {
                        return [ this[0], op, walk(expr) ];
                },
                "unary-postfix": function(op, expr) {
                        return [ this[0], op, walk(expr) ];
                },
                "sub": function(expr, subscript) {
                        return [ this[0], walk(expr), walk(subscript) ];
                },
                "object": function(props) {
                        return [ this[0], MAP(props, function(p){
                                return p.length == 2
                                        ? [ p[0], walk(p[1]) ]
                                        : [ p[0], walk(p[1]), p[2] ]; // get/set-ter
                        }) ];
                },
                "regexp": function(rx, mods) {
                        return [ this[0], rx, mods ];
                },
                "array": function(elements) {
                        return [ this[0], MAP(elements, walk) ];
                },
                "stat": function(stat) {
                        return [ this[0], walk(stat) ];
                },
                "seq": function() {
                        return [ this[0] ].concat(MAP(slice(arguments), walk));
                },
                "label": function(name, block) {
                        return [ this[0], name, walk(block) ];
                },
                "with": function(expr, block) {
                        return [ this[0], walk(expr), walk(block) ];
                },
                "atom": function(name) {
                        return [ this[0], name ];
                },
                "directive": function(dir) {
                        return [ this[0], dir ];
                }
        };

        var user = {};
        var stack = [];
        function walk(ast) {
                if (ast == null)
                        return null;
                try {
                        stack.push(ast);
                        var type = ast[0];
                        var gen = user[type];
                        if (gen) {
                                var ret = gen.apply(ast, ast.slice(1));
                                if (ret != null)
                                        return ret;
                        }
                        gen = walkers[type];
                        return gen.apply(ast, ast.slice(1));
                } finally {
                        stack.pop();
                }
        };

        function dive(ast) {
                if (ast == null)
                        return null;
                try {
                        stack.push(ast);
                        return walkers[ast[0]].apply(ast, ast.slice(1));
                } finally {
                        stack.pop();
                }
        };

        function with_walkers(walkers, cont){
                var save = {}, i;
                for (i in walkers) if (HOP(walkers, i)) {
                        save[i] = user[i];
                        user[i] = walkers[i];
                }
                var ret = cont();
                for (i in save) if (HOP(save, i)) {
                        if (!save[i]) delete user[i];
                        else user[i] = save[i];
                }
                return ret;
        };

        return {
                walk: walk,
                dive: dive,
                with_walkers: with_walkers,
                parent: function() {
                        return stack[stack.length - 2]; // last one is current node
                },
                stack: function() {
                        return stack;
                }
        };
};

/* -----[ Scope and mangling ]----- */

function Scope(parent) {
        this.names = {};        // names defined in this scope
        this.mangled = {};      // mangled names (orig.name => mangled)
        this.rev_mangled = {};  // reverse lookup (mangled => orig.name)
        this.cname = -1;        // current mangled name
        this.refs = {};         // names referenced from this scope
        this.uses_with = false; // will become TRUE if with() is detected in this or any subscopes
        this.uses_eval = false; // will become TRUE if eval() is detected in this or any subscopes
        this.directives = [];   // directives activated from this scope
        this.parent = parent;   // parent scope
        this.children = [];     // sub-scopes
        if (parent) {
                this.level = parent.level + 1;
                parent.children.push(this);
        } else {
                this.level = 0;
        }
};

function base54_digits() {
        if (typeof DIGITS_OVERRIDE_FOR_TESTING != "undefined")
                return DIGITS_OVERRIDE_FOR_TESTING;
        else
                return "etnrisouaflchpdvmgybwESxTNCkLAOM_DPHBjFIqRUzWXV$JKQGYZ0516372984";
}

var base54 = (function(){
        var DIGITS = base54_digits();
        return function(num) {
                var ret = "", base = 54;
                do {
                        ret += DIGITS.charAt(num % base);
                        num = Math.floor(num / base);
                        base = 64;
                } while (num > 0);
                return ret;
        };
})();

Scope.prototype = {
        has: function(name) {
                for (var s = this; s; s = s.parent)
                        if (HOP(s.names, name))
                                return s;
        },
        has_mangled: function(mname) {
                for (var s = this; s; s = s.parent)
                        if (HOP(s.rev_mangled, mname))
                                return s;
        },
        toJSON: function() {
                return {
                        names: this.names,
                        uses_eval: this.uses_eval,
                        uses_with: this.uses_with
                };
        },

        next_mangled: function() {
                // we must be careful that the new mangled name:
                //
                // 1. doesn't shadow a mangled name from a parent
                //    scope, unless we don't reference the original
                //    name from this scope OR from any sub-scopes!
                //    This will get slow.
                //
                // 2. doesn't shadow an original name from a parent
                //    scope, in the event that the name is not mangled
                //    in the parent scope and we reference that name
                //    here OR IN ANY SUBSCOPES!
                //
                // 3. doesn't shadow a name that is referenced but not
                //    defined (possibly global defined elsewhere).
                for (;;) {
                        var m = base54(++this.cname), prior;

                        // case 1.
                        prior = this.has_mangled(m);
                        if (prior && this.refs[prior.rev_mangled[m]] === prior)
                                continue;

                        // case 2.
                        prior = this.has(m);
                        if (prior && prior !== this && this.refs[m] === prior && !prior.has_mangled(m))
                                continue;

                        // case 3.
                        if (HOP(this.refs, m) && this.refs[m] == null)
                                continue;

                        // I got "do" once. :-/
                        if (!is_identifier(m))
                                continue;

                        return m;
                }
        },
        set_mangle: function(name, m) {
                this.rev_mangled[m] = name;
                return this.mangled[name] = m;
        },
        get_mangled: function(name, newMangle) {
                if (this.uses_eval || this.uses_with) return name; // no mangle if eval or with is in use
                var s = this.has(name);
                if (!s) return name; // not in visible scope, no mangle
                if (HOP(s.mangled, name)) return s.mangled[name]; // already mangled in this scope
                if (!newMangle) return name;                      // not found and no mangling requested
                return s.set_mangle(name, s.next_mangled());
        },
        references: function(name) {
                return name && !this.parent || this.uses_with || this.uses_eval || this.refs[name];
        },
        define: function(name, type) {
                if (name != null) {
                        if (type == "var" || !HOP(this.names, name))
                                this.names[name] = type || "var";
                        return name;
                }
        },
        active_directive: function(dir) {
                return member(dir, this.directives) || this.parent && this.parent.active_directive(dir);
        }
};

function ast_add_scope(ast) {

        var current_scope = null;
        var w = ast_walker(), walk = w.walk;
        var having_eval = [];

        function with_new_scope(cont) {
                current_scope = new Scope(current_scope);
                current_scope.labels = new Scope();
                var ret = current_scope.body = cont();
                ret.scope = current_scope;
                current_scope = current_scope.parent;
                return ret;
        };

        function define(name, type) {
                return current_scope.define(name, type);
        };

        function reference(name) {
                current_scope.refs[name] = true;
        };

        function _lambda(name, args, body) {
                var is_defun = this[0] == "defun";
                return [ this[0], is_defun ? define(name, "defun") : name, args, with_new_scope(function(){
                        if (!is_defun) define(name, "lambda");
                        MAP(args, function(name){ define(name, "arg") });
                        return MAP(body, walk);
                })];
        };

        function _vardefs(type) {
                return function(defs) {
                        MAP(defs, function(d){
                                define(d[0], type);
                                if (d[1]) reference(d[0]);
                        });
                };
        };

        function _breacont(label) {
                if (label)
                        current_scope.labels.refs[label] = true;
        };

        return with_new_scope(function(){
                // process AST
                var ret = w.with_walkers({
                        "function": _lambda,
                        "defun": _lambda,
                        "label": function(name, stat) { current_scope.labels.define(name) },
                        "break": _breacont,
                        "continue": _breacont,
                        "with": function(expr, block) {
                                for (var s = current_scope; s; s = s.parent)
                                        s.uses_with = true;
                        },
                        "var": _vardefs("var"),
                        "const": _vardefs("const"),
                        "try": function(t, c, f) {
                                if (c != null) return [
                                        this[0],
                                        MAP(t, walk),
                                        [ define(c[0], "catch"), MAP(c[1], walk) ],
                                        f != null ? MAP(f, walk) : null
                                ];
                        },
                        "name": function(name) {
                                if (name == "eval")
                                        having_eval.push(current_scope);
                                reference(name);
                        }
                }, function(){
                        return walk(ast);
                });

                // the reason why we need an additional pass here is
                // that names can be used prior to their definition.

                // scopes where eval was detected and their parents
                // are marked with uses_eval, unless they define the
                // "eval" name.
                MAP(having_eval, function(scope){
                        if (!scope.has("eval")) while (scope) {
                                scope.uses_eval = true;
                                scope = scope.parent;
                        }
                });

                // for referenced names it might be useful to know
                // their origin scope.  current_scope here is the
                // toplevel one.
                function fixrefs(scope, i) {
                        // do children first; order shouldn't matter
                        for (i = scope.children.length; --i >= 0;)
                                fixrefs(scope.children[i]);
                        for (i in scope.refs) if (HOP(scope.refs, i)) {
                                // find origin scope and propagate the reference to origin
                                for (var origin = scope.has(i), s = scope; s; s = s.parent) {
                                        s.refs[i] = origin;
                                        if (s === origin) break;
                                }
                        }
                };
                fixrefs(current_scope);

                return ret;
        });

};

/* -----[ mangle names ]----- */

function ast_mangle(ast, options) {
        var w = ast_walker(), walk = w.walk, scope;
        options = defaults(options, {
                mangle       : true,
                toplevel     : false,
                defines      : null,
                except       : null,
                no_functions : false
        });

        function get_mangled(name, newMangle) {
                if (!options.mangle) return name;
                if (!options.toplevel && !scope.parent) return name; // don't mangle toplevel
                if (options.except && member(name, options.except))
                        return name;
                if (options.no_functions && HOP(scope.names, name) &&
                    (scope.names[name] == 'defun' || scope.names[name] == 'lambda'))
                        return name;
                return scope.get_mangled(name, newMangle);
        };

        function get_define(name) {
                if (options.defines) {
                        // we always lookup a defined symbol for the current scope FIRST, so declared
                        // vars trump a DEFINE symbol, but if no such var is found, then match a DEFINE value
                        if (!scope.has(name)) {
                                if (HOP(options.defines, name)) {
                                        return options.defines[name];
                                }
                        }
                        return null;
                }
        };

        function _lambda(name, args, body) {
                if (!options.no_functions && options.mangle) {
                        var is_defun = this[0] == "defun", extra;
                        if (name) {
                                if (is_defun) name = get_mangled(name);
                                else if (body.scope.references(name)) {
                                        extra = {};
                                        if (!(scope.uses_eval || scope.uses_with))
                                                name = extra[name] = scope.next_mangled();
                                        else
                                                extra[name] = name;
                                }
                                else name = null;
                        }
                }
                body = with_scope(body.scope, function(){
                        args = MAP(args, function(name){ return get_mangled(name) });
                        return MAP(body, walk);
                }, extra);
                return [ this[0], name, args, body ];
        };

        function with_scope(s, cont, extra) {
                var _scope = scope;
                scope = s;
                if (extra) for (var i in extra) if (HOP(extra, i)) {
                        s.set_mangle(i, extra[i]);
                }
                for (var i in s.names) if (HOP(s.names, i)) {
                        get_mangled(i, true);
                }
                var ret = cont();
                ret.scope = s;
                scope = _scope;
                return ret;
        };

        function _vardefs(defs) {
                return [ this[0], MAP(defs, function(d){
                        return [ get_mangled(d[0]), walk(d[1]) ];
                }) ];
        };

        function _breacont(label) {
                if (label) return [ this[0], scope.labels.get_mangled(label) ];
        };

        return w.with_walkers({
                "function": _lambda,
                "defun": function() {
                        // move function declarations to the top when
                        // they are not in some block.
                        var ast = _lambda.apply(this, arguments);
                        switch (w.parent()[0]) {
                            case "toplevel":
                            case "function":
                            case "defun":
                                return MAP.at_top(ast);
                        }
                        return ast;
                },
                "label": function(label, stat) {
                        if (scope.labels.refs[label]) return [
                                this[0],
                                scope.labels.get_mangled(label, true),
                                walk(stat)
                        ];
                        return walk(stat);
                },
                "break": _breacont,
                "continue": _breacont,
                "var": _vardefs,
                "const": _vardefs,
                "name": function(name) {
                        return get_define(name) || [ this[0], get_mangled(name) ];
                },
                "try": function(t, c, f) {
                        return [ this[0],
                                 MAP(t, walk),
                                 c != null ? [ get_mangled(c[0]), MAP(c[1], walk) ] : null,
                                 f != null ? MAP(f, walk) : null ];
                },
                "toplevel": function(body) {
                        var self = this;
                        return with_scope(self.scope, function(){
                                return [ self[0], MAP(body, walk) ];
                        });
                },
                "directive": function() {
                        return MAP.at_top(this);
                }
        }, function() {
                return walk(ast_add_scope(ast));
        });
};

/* -----[
   - compress foo["bar"] into foo.bar,
   - remove block brackets {} where possible
   - join consecutive var declarations
   - various optimizations for IFs:
     - if (cond) foo(); else bar();  ==>  cond?foo():bar();
     - if (cond) foo();  ==>  cond&&foo();
     - if (foo) return bar(); else return baz();  ==> return foo?bar():baz(); // also for throw
     - if (foo) return bar(); else something();  ==> {if(foo)return bar();something()}
   ]----- */

var warn = function(){};

function best_of(ast1, ast2) {
        return gen_code(ast1).length > gen_code(ast2[0] == "stat" ? ast2[1] : ast2).length ? ast2 : ast1;
};

function last_stat(b) {
        if (b[0] == "block" && b[1] && b[1].length > 0)
                return b[1][b[1].length - 1];
        return b;
}

function aborts(t) {
        if (t) switch (last_stat(t)[0]) {
            case "return":
            case "break":
            case "continue":
            case "throw":
                return true;
        }
};

function boolean_expr(expr) {
        return ( (expr[0] == "unary-prefix"
                  && member(expr[1], [ "!", "delete" ])) ||

                 (expr[0] == "binary"
                  && member(expr[1], [ "in", "instanceof", "==", "!=", "===", "!==", "<", "<=", ">=", ">" ])) ||

                 (expr[0] == "binary"
                  && member(expr[1], [ "&&", "||" ])
                  && boolean_expr(expr[2])
                  && boolean_expr(expr[3])) ||

                 (expr[0] == "conditional"
                  && boolean_expr(expr[2])
                  && boolean_expr(expr[3])) ||

                 (expr[0] == "assign"
                  && expr[1] === true
                  && boolean_expr(expr[3])) ||

                 (expr[0] == "seq"
                  && boolean_expr(expr[expr.length - 1]))
               );
};

function empty(b) {
        return !b || (b[0] == "block" && (!b[1] || b[1].length == 0));
};

function is_string(node) {
        return (node[0] == "string" ||
                node[0] == "unary-prefix" && node[1] == "typeof" ||
                node[0] == "binary" && node[1] == "+" &&
                (is_string(node[2]) || is_string(node[3])));
};

var when_constant = (function(){

        var $NOT_CONSTANT = {};

        // this can only evaluate constant expressions.  If it finds anything
        // not constant, it throws $NOT_CONSTANT.
        function evaluate(expr) {
                switch (expr[0]) {
                    case "string":
                    case "num":
                        return expr[1];
                    case "name":
                    case "atom":
                        switch (expr[1]) {
                            case "true": return true;
                            case "false": return false;
                            case "null": return null;
                        }
                        break;
                    case "unary-prefix":
                        switch (expr[1]) {
                            case "!": return !evaluate(expr[2]);
                            case "typeof": return typeof evaluate(expr[2]);
                            case "~": return ~evaluate(expr[2]);
                            case "-": return -evaluate(expr[2]);
                            case "+": return +evaluate(expr[2]);
                        }
                        break;
                    case "binary":
                        var left = expr[2], right = expr[3];
                        switch (expr[1]) {
                            case "&&"         : return evaluate(left) &&         evaluate(right);
                            case "||"         : return evaluate(left) ||         evaluate(right);
                            case "|"          : return evaluate(left) |          evaluate(right);
                            case "&"          : return evaluate(left) &          evaluate(right);
                            case "^"          : return evaluate(left) ^          evaluate(right);
                            case "+"          : return evaluate(left) +          evaluate(right);
                            case "*"          : return evaluate(left) *          evaluate(right);
                            case "/"          : return evaluate(left) /          evaluate(right);
                            case "%"          : return evaluate(left) %          evaluate(right);
                            case "-"          : return evaluate(left) -          evaluate(right);
                            case "<<"         : return evaluate(left) <<         evaluate(right);
                            case ">>"         : return evaluate(left) >>         evaluate(right);
                            case ">>>"        : return evaluate(left) >>>        evaluate(right);
                            case "=="         : return evaluate(left) ==         evaluate(right);
                            case "==="        : return evaluate(left) ===        evaluate(right);
                            case "!="         : return evaluate(left) !=         evaluate(right);
                            case "!=="        : return evaluate(left) !==        evaluate(right);
                            case "<"          : return evaluate(left) <          evaluate(right);
                            case "<="         : return evaluate(left) <=         evaluate(right);
                            case ">"          : return evaluate(left) >          evaluate(right);
                            case ">="         : return evaluate(left) >=         evaluate(right);
                            case "in"         : return evaluate(left) in         evaluate(right);
                            case "instanceof" : return evaluate(left) instanceof evaluate(right);
                        }
                }
                throw $NOT_CONSTANT;
        };

        return function(expr, yes, no) {
                try {
                        var val = evaluate(expr), ast;
                        switch (typeof val) {
                            case "string": ast =  [ "string", val ]; break;
                            case "number": ast =  [ "num", val ]; break;
                            case "boolean": ast =  [ "name", String(val) ]; break;
                            default:
                                if (val === null) { ast = [ "atom", "null" ]; break; }
                                throw new Error("Can't handle constant of type: " + (typeof val));
                        }
                        return yes.call(expr, ast, val);
                } catch(ex) {
                        if (ex === $NOT_CONSTANT) {
                                if (expr[0] == "binary"
                                    && (expr[1] == "===" || expr[1] == "!==")
                                    && ((is_string(expr[2]) && is_string(expr[3]))
                                        || (boolean_expr(expr[2]) && boolean_expr(expr[3])))) {
                                        expr[1] = expr[1].substr(0, 2);
                                }
                                else if (no && expr[0] == "binary"
                                         && (expr[1] == "||" || expr[1] == "&&")) {
                                    // the whole expression is not constant but the lval may be...
                                    try {
                                        var lval = evaluate(expr[2]);
                                        expr = ((expr[1] == "&&" && (lval ? expr[3] : lval))    ||
                                                (expr[1] == "||" && (lval ? lval    : expr[3])) ||
                                                expr);
                                    } catch(ex2) {
                                        // IGNORE... lval is not constant
                                    }
                                }
                                return no ? no.call(expr, expr) : null;
                        }
                        else throw ex;
                }
        };

})();

function warn_unreachable(ast) {
        if (!empty(ast))
                warn("Dropping unreachable code: " + gen_code(ast, true));
};

function prepare_ifs(ast) {
        var w = ast_walker(), walk = w.walk;
        // In this first pass, we rewrite ifs which abort with no else with an
        // if-else.  For example:
        //
        // if (x) {
        //     blah();
        //     return y;
        // }
        // foobar();
        //
        // is rewritten into:
        //
        // if (x) {
        //     blah();
        //     return y;
        // } else {
        //     foobar();
        // }
        function redo_if(statements) {
                statements = MAP(statements, walk);

                for (var i = 0; i < statements.length; ++i) {
                        var fi = statements[i];
                        if (fi[0] != "if") continue;

                        if (fi[3]) continue;

                        var t = fi[2];
                        if (!aborts(t)) continue;

                        var conditional = walk(fi[1]);

                        var e_body = redo_if(statements.slice(i + 1));
                        var e = e_body.length == 1 ? e_body[0] : [ "block", e_body ];

                        return statements.slice(0, i).concat([ [
                                fi[0],          // "if"
                                conditional,    // conditional
                                t,              // then
                                e               // else
                        ] ]);
                }

                return statements;
        };

        function redo_if_lambda(name, args, body) {
                body = redo_if(body);
                return [ this[0], name, args, body ];
        };

        function redo_if_block(statements) {
                return [ this[0], statements != null ? redo_if(statements) : null ];
        };

        return w.with_walkers({
                "defun": redo_if_lambda,
                "function": redo_if_lambda,
                "block": redo_if_block,
                "splice": redo_if_block,
                "toplevel": function(statements) {
                        return [ this[0], redo_if(statements) ];
                },
                "try": function(t, c, f) {
                        return [
                                this[0],
                                redo_if(t),
                                c != null ? [ c[0], redo_if(c[1]) ] : null,
                                f != null ? redo_if(f) : null
                        ];
                }
        }, function() {
                return walk(ast);
        });
};

function for_side_effects(ast, handler) {
        var w = ast_walker(), walk = w.walk;
        var $stop = {}, $restart = {};
        function stop() { throw $stop };
        function restart() { throw $restart };
        function found(){ return handler.call(this, this, w, stop, restart) };
        function unary(op) {
                if (op == "++" || op == "--")
                        return found.apply(this, arguments);
        };
        function binary(op) {
                if (op == "&&" || op == "||")
                        return found.apply(this, arguments);
        };
        return w.with_walkers({
                "try": found,
                "throw": found,
                "return": found,
                "new": found,
                "switch": found,
                "break": found,
                "continue": found,
                "assign": found,
                "call": found,
                "if": found,
                "for": found,
                "for-in": found,
                "while": found,
                "do": found,
                "return": found,
                "unary-prefix": unary,
                "unary-postfix": unary,
                "conditional": found,
                "binary": binary,
                "defun": found
        }, function(){
                while (true) try {
                        walk(ast);
                        break;
                } catch(ex) {
                        if (ex === $stop) break;
                        if (ex === $restart) continue;
                        throw ex;
                }
        });
};

function ast_lift_variables(ast) {
        var w = ast_walker(), walk = w.walk, scope;
        function do_body(body, env) {
                var _scope = scope;
                scope = env;
                body = MAP(body, walk);
                var hash = {}, names = MAP(env.names, function(type, name){
                        if (type != "var") return MAP.skip;
                        if (!env.references(name)) return MAP.skip;
                        hash[name] = true;
                        return [ name ];
                });
                if (names.length > 0) {
                        // looking for assignments to any of these variables.
                        // we can save considerable space by moving the definitions
                        // in the var declaration.
                        for_side_effects([ "block", body ], function(ast, walker, stop, restart) {
                                if (ast[0] == "assign"
                                    && ast[1] === true
                                    && ast[2][0] == "name"
                                    && HOP(hash, ast[2][1])) {
                                        // insert the definition into the var declaration
                                        for (var i = names.length; --i >= 0;) {
                                                if (names[i][0] == ast[2][1]) {
                                                        if (names[i][1]) // this name already defined, we must stop
                                                                stop();
                                                        names[i][1] = ast[3]; // definition
                                                        names.push(names.splice(i, 1)[0]);
                                                        break;
                                                }
                                        }
                                        // remove this assignment from the AST.
                                        var p = walker.parent();
                                        if (p[0] == "seq") {
                                                var a = p[2];
                                                a.unshift(0, p.length);
                                                p.splice.apply(p, a);
                                        }
                                        else if (p[0] == "stat") {
                                                p.splice(0, p.length, "block"); // empty statement
                                        }
                                        else {
                                                stop();
                                        }
                                        restart();
                                }
                                stop();
                        });
                        body.unshift([ "var", names ]);
                }
                scope = _scope;
                return body;
        };
        function _vardefs(defs) {
                var ret = null;
                for (var i = defs.length; --i >= 0;) {
                        var d = defs[i];
                        if (!d[1]) continue;
                        d = [ "assign", true, [ "name", d[0] ], d[1] ];
                        if (ret == null) ret = d;
                        else ret = [ "seq", d, ret ];
                }
                if (ret == null && w.parent()[0] != "for") {
                        if (w.parent()[0] == "for-in")
                                return [ "name", defs[0][0] ];
                        return MAP.skip;
                }
                return [ "stat", ret ];
        };
        function _toplevel(body) {
                return [ this[0], do_body(body, this.scope) ];
        };
        return w.with_walkers({
                "function": function(name, args, body){
                        for (var i = args.length; --i >= 0 && !body.scope.references(args[i]);)
                                args.pop();
                        if (!body.scope.references(name)) name = null;
                        return [ this[0], name, args, do_body(body, body.scope) ];
                },
                "defun": function(name, args, body){
                        if (!scope.references(name)) return MAP.skip;
                        for (var i = args.length; --i >= 0 && !body.scope.references(args[i]);)
                                args.pop();
                        return [ this[0], name, args, do_body(body, body.scope) ];
                },
                "var": _vardefs,
                "toplevel": _toplevel
        }, function(){
                return walk(ast_add_scope(ast));
        });
};

function ast_squeeze(ast, options) {
        ast = squeeze_1(ast, options);
        ast = squeeze_2(ast, options);
        return ast;
};

function squeeze_1(ast, options) {
        options = defaults(options, {
                make_seqs   : true,
                dead_code   : true,
                no_warnings : false,
                keep_comps  : true,
                unsafe      : false
        });

        var w = ast_walker(), walk = w.walk, scope;

        function negate(c) {
                var not_c = [ "unary-prefix", "!", c ];
                switch (c[0]) {
                    case "unary-prefix":
                        return c[1] == "!" && boolean_expr(c[2]) ? c[2] : not_c;
                    case "seq":
                        c = slice(c);
                        c[c.length - 1] = negate(c[c.length - 1]);
                        return c;
                    case "conditional":
                        return best_of(not_c, [ "conditional", c[1], negate(c[2]), negate(c[3]) ]);
                    case "binary":
                        var op = c[1], left = c[2], right = c[3];
                        if (!options.keep_comps) switch (op) {
                            case "<="  : return [ "binary", ">", left, right ];
                            case "<"   : return [ "binary", ">=", left, right ];
                            case ">="  : return [ "binary", "<", left, right ];
                            case ">"   : return [ "binary", "<=", left, right ];
                        }
                        switch (op) {
                            case "=="  : return [ "binary", "!=", left, right ];
                            case "!="  : return [ "binary", "==", left, right ];
                            case "===" : return [ "binary", "!==", left, right ];
                            case "!==" : return [ "binary", "===", left, right ];
                            case "&&"  : return best_of(not_c, [ "binary", "||", negate(left), negate(right) ]);
                            case "||"  : return best_of(not_c, [ "binary", "&&", negate(left), negate(right) ]);
                        }
                        break;
                }
                return not_c;
        };

        function make_conditional(c, t, e) {
                var make_real_conditional = function() {
                        if (c[0] == "unary-prefix" && c[1] == "!") {
                                return e ? [ "conditional", c[2], e, t ] : [ "binary", "||", c[2], t ];
                        } else {
                                return e ? best_of(
                                        [ "conditional", c, t, e ],
                                        [ "conditional", negate(c), e, t ]
                                ) : [ "binary", "&&", c, t ];
                        }
                };
                // shortcut the conditional if the expression has a constant value
                return when_constant(c, function(ast, val){
                        warn_unreachable(val ? e : t);
                        return          (val ? t : e);
                }, make_real_conditional);
        };

        function rmblock(block) {
                if (block != null && block[0] == "block" && block[1]) {
                        if (block[1].length == 1)
                                block = block[1][0];
                        else if (block[1].length == 0)
                                block = [ "block" ];
                }
                return block;
        };

        function _lambda(name, args, body) {
                return [ this[0], name, args, tighten(body, "lambda") ];
        };

        // this function does a few things:
        // 1. discard useless blocks
        // 2. join consecutive var declarations
        // 3. remove obviously dead code
        // 4. transform consecutive statements using the comma operator
        // 5. if block_type == "lambda" and it detects constructs like if(foo) return ... - rewrite like if (!foo) { ... }
        function tighten(statements, block_type) {
                statements = MAP(statements, walk);

                statements = statements.reduce(function(a, stat){
                        if (stat[0] == "block") {
                                if (stat[1]) {
                                        a.push.apply(a, stat[1]);
                                }
                        } else {
                                a.push(stat);
                        }
                        return a;
                }, []);

                statements = (function(a, prev){
                        statements.forEach(function(cur){
                                if (prev && ((cur[0] == "var" && prev[0] == "var") ||
                                             (cur[0] == "const" && prev[0] == "const"))) {
                                        prev[1] = prev[1].concat(cur[1]);
                                } else {
                                        a.push(cur);
                                        prev = cur;
                                }
                        });
                        return a;
                })([]);

                if (options.dead_code) statements = (function(a, has_quit){
                        statements.forEach(function(st){
                                if (has_quit) {
                                        if (st[0] == "function" || st[0] == "defun") {
                                                a.push(st);
                                        }
                                        else if (st[0] == "var" || st[0] == "const") {
                                                if (!options.no_warnings)
                                                        warn("Variables declared in unreachable code");
                                                st[1] = MAP(st[1], function(def){
                                                        if (def[1] && !options.no_warnings)
                                                                warn_unreachable([ "assign", true, [ "name", def[0] ], def[1] ]);
                                                        return [ def[0] ];
                                                });
                                                a.push(st);
                                        }
                                        else if (!options.no_warnings)
                                                warn_unreachable(st);
                                }
                                else {
                                        a.push(st);
                                        if (member(st[0], [ "return", "throw", "break", "continue" ]))
                                                has_quit = true;
                                }
                        });
                        return a;
                })([]);

                if (options.make_seqs) statements = (function(a, prev) {
                        statements.forEach(function(cur){
                                if (prev && prev[0] == "stat" && cur[0] == "stat") {
                                        prev[1] = [ "seq", prev[1], cur[1] ];
                                } else {
                                        a.push(cur);
                                        prev = cur;
                                }
                        });
                        if (a.length >= 2
                            && a[a.length-2][0] == "stat"
                            && (a[a.length-1][0] == "return" || a[a.length-1][0] == "throw")
                            && a[a.length-1][1])
                        {
                                a.splice(a.length - 2, 2,
                                         [ a[a.length-1][0],
                                           [ "seq", a[a.length-2][1], a[a.length-1][1] ]]);
                        }
                        return a;
                })([]);

                // this increases jQuery by 1K.  Probably not such a good idea after all..
                // part of this is done in prepare_ifs anyway.
                // if (block_type == "lambda") statements = (function(i, a, stat){
                //         while (i < statements.length) {
                //                 stat = statements[i++];
                //                 if (stat[0] == "if" && !stat[3]) {
                //                         if (stat[2][0] == "return" && stat[2][1] == null) {
                //                                 a.push(make_if(negate(stat[1]), [ "block", statements.slice(i) ]));
                //                                 break;
                //                         }
                //                         var last = last_stat(stat[2]);
                //                         if (last[0] == "return" && last[1] == null) {
                //                                 a.push(make_if(stat[1], [ "block", stat[2][1].slice(0, -1) ], [ "block", statements.slice(i) ]));
                //                                 break;
                //                         }
                //                 }
                //                 a.push(stat);
                //         }
                //         return a;
                // })(0, []);

                return statements;
        };

        function make_if(c, t, e) {
                return when_constant(c, function(ast, val){
                        if (val) {
                                t = walk(t);
                                warn_unreachable(e);
                                return t || [ "block" ];
                        } else {
                                e = walk(e);
                                warn_unreachable(t);
                                return e || [ "block" ];
                        }
                }, function() {
                        return make_real_if(c, t, e);
                });
        };

        function abort_else(c, t, e) {
                var ret = [ [ "if", negate(c), e ] ];
                if (t[0] == "block") {
                        if (t[1]) ret = ret.concat(t[1]);
                } else {
                        ret.push(t);
                }
                return walk([ "block", ret ]);
        };

        function make_real_if(c, t, e) {
                c = walk(c);
                t = walk(t);
                e = walk(e);

                if (empty(e) && empty(t))
                        return [ "stat", c ];

                if (empty(t)) {
                        c = negate(c);
                        t = e;
                        e = null;
                } else if (empty(e)) {
                        e = null;
                } else {
                        // if we have both else and then, maybe it makes sense to switch them?
                        (function(){
                                var a = gen_code(c);
                                var n = negate(c);
                                var b = gen_code(n);
                                if (b.length < a.length) {
                                        var tmp = t;
                                        t = e;
                                        e = tmp;
                                        c = n;
                                }
                        })();
                }
                var ret = [ "if", c, t, e ];
                if (t[0] == "if" && empty(t[3]) && empty(e)) {
                        ret = best_of(ret, walk([ "if", [ "binary", "&&", c, t[1] ], t[2] ]));
                }
                else if (t[0] == "stat") {
                        if (e) {
                                if (e[0] == "stat")
                                        ret = best_of(ret, [ "stat", make_conditional(c, t[1], e[1]) ]);
                                else if (aborts(e))
                                        ret = abort_else(c, t, e);
                        }
                        else {
                                ret = best_of(ret, [ "stat", make_conditional(c, t[1]) ]);
                        }
                }
                else if (e && t[0] == e[0] && (t[0] == "return" || t[0] == "throw") && t[1] && e[1]) {
                        ret = best_of(ret, [ t[0], make_conditional(c, t[1], e[1] ) ]);
                }
                else if (e && aborts(t)) {
                        ret = [ [ "if", c, t ] ];
                        if (e[0] == "block") {
                                if (e[1]) ret = ret.concat(e[1]);
                        }
                        else {
                                ret.push(e);
                        }
                        ret = walk([ "block", ret ]);
                }
                else if (t && aborts(e)) {
                        ret = abort_else(c, t, e);
                }
                return ret;
        };

        function _do_while(cond, body) {
                return when_constant(cond, function(cond, val){
                        if (!val) {
                                warn_unreachable(body);
                                return [ "block" ];
                        } else {
                                return [ "for", null, null, null, walk(body) ];
                        }
                });
        };

        return w.with_walkers({
                "sub": function(expr, subscript) {
                        if (subscript[0] == "string") {
                                var name = subscript[1];
                                if (is_identifier(name))
                                        return [ "dot", walk(expr), name ];
                                else if (/^[1-9][0-9]*$/.test(name) || name === "0")
                                        return [ "sub", walk(expr), [ "num", parseInt(name, 10) ] ];
                        }
                },
                "if": make_if,
                "toplevel": function(body) {
                        return [ "toplevel", tighten(body) ];
                },
                "switch": function(expr, body) {
                        var last = body.length - 1;
                        return [ "switch", walk(expr), MAP(body, function(branch, i){
                                var block = tighten(branch[1]);
                                if (i == last && block.length > 0) {
                                        var node = block[block.length - 1];
                                        if (node[0] == "break" && !node[1])
                                                block.pop();
                                }
                                return [ branch[0] ? walk(branch[0]) : null, block ];
                        }) ];
                },
                "function": _lambda,
                "defun": _lambda,
                "block": function(body) {
                        if (body) return rmblock([ "block", tighten(body) ]);
                },
                "binary": function(op, left, right) {
                        return when_constant([ "binary", op, walk(left), walk(right) ], function yes(c){
                                return best_of(walk(c), this);
                        }, function no() {
                                return function(){
                                        if(op != "==" && op != "!=") return;
                                        var l = walk(left), r = walk(right);
                                        if(l && l[0] == "unary-prefix" && l[1] == "!" && l[2][0] == "num")
                                                left = ['num', +!l[2][1]];
                                        else if (r && r[0] == "unary-prefix" && r[1] == "!" && r[2][0] == "num")
                                                right = ['num', +!r[2][1]];
                                        return ["binary", op, left, right];
                                }() || this;
                        });
                },
                "conditional": function(c, t, e) {
                        return make_conditional(walk(c), walk(t), walk(e));
                },
                "try": function(t, c, f) {
                        return [
                                "try",
                                tighten(t),
                                c != null ? [ c[0], tighten(c[1]) ] : null,
                                f != null ? tighten(f) : null
                        ];
                },
                "unary-prefix": function(op, expr) {
                        expr = walk(expr);
                        var ret = [ "unary-prefix", op, expr ];
                        if (op == "!")
                                ret = best_of(ret, negate(expr));
                        return when_constant(ret, function(ast, val){
                                return walk(ast); // it's either true or false, so minifies to !0 or !1
                        }, function() { return ret });
                },
                "name": function(name) {
                        switch (name) {
                            case "true": return [ "unary-prefix", "!", [ "num", 0 ]];
                            case "false": return [ "unary-prefix", "!", [ "num", 1 ]];
                        }
                },
                "while": _do_while,
                "assign": function(op, lvalue, rvalue) {
                        lvalue = walk(lvalue);
                        rvalue = walk(rvalue);
                        var okOps = [ '+', '-', '/', '*', '%', '>>', '<<', '>>>', '|', '^', '&' ];
                        if (op === true && lvalue[0] === "name" && rvalue[0] === "binary" &&
                            ~okOps.indexOf(rvalue[1]) && rvalue[2][0] === "name" &&
                            rvalue[2][1] === lvalue[1]) {
                                return [ this[0], rvalue[1], lvalue, rvalue[3] ]
                        }
                        return [ this[0], op, lvalue, rvalue ];
                },
                "call": function(expr, args) {
                        expr = walk(expr);
                        if (options.unsafe && expr[0] == "dot" && expr[1][0] == "string" && expr[2] == "toString") {
                                return expr[1];
                        }
                        return [ this[0], expr,  MAP(args, walk) ];
                },
                "num": function (num) {
                        if (!isFinite(num))
                                return [ "binary", "/", num === 1 / 0
                                         ? [ "num", 1 ] : num === -1 / 0
                                         ? [ "unary-prefix", "-", [ "num", 1 ] ]
                                         : [ "num", 0 ], [ "num", 0 ] ];

                        return [ this[0], num ];
                }
        }, function() {
                return walk(prepare_ifs(walk(prepare_ifs(ast))));
        });
};

function squeeze_2(ast, options) {
        var w = ast_walker(), walk = w.walk, scope;
        function with_scope(s, cont) {
                var save = scope, ret;
                scope = s;
                ret = cont();
                scope = save;
                return ret;
        };
        function lambda(name, args, body) {
                return [ this[0], name, args, with_scope(body.scope, curry(MAP, body, walk)) ];
        };
        return w.with_walkers({
                "directive": function(dir) {
                        if (scope.active_directive(dir))
                                return [ "block" ];
                        scope.directives.push(dir);
                },
                "toplevel": function(body) {
                        return [ this[0], with_scope(this.scope, curry(MAP, body, walk)) ];
                },
                "function": lambda,
                "defun": lambda
        }, function(){
                return walk(ast_add_scope(ast));
        });
};

/* -----[ re-generate code from the AST ]----- */

var DOT_CALL_NO_PARENS = jsp.array_to_hash([
        "name",
        "array",
        "object",
        "string",
        "dot",
        "sub",
        "call",
        "regexp",
        "defun"
]);

function make_string(str, ascii_only) {
        var dq = 0, sq = 0;
        str = str.replace(/[\\\b\f\n\r\t\x22\x27\u2028\u2029\0]/g, function(s){
                switch (s) {
                    case "\\": return "\\\\";
                    case "\b": return "\\b";
                    case "\f": return "\\f";
                    case "\n": return "\\n";
                    case "\r": return "\\r";
                    case "\u2028": return "\\u2028";
                    case "\u2029": return "\\u2029";
                    case '"': ++dq; return '"';
                    case "'": ++sq; return "'";
                    case "\0": return "\\0";
                }
                return s;
        });
        if (ascii_only) str = to_ascii(str);
        if (dq > sq) return "'" + str.replace(/\x27/g, "\\'") + "'";
        else return '"' + str.replace(/\x22/g, '\\"') + '"';
};

function to_ascii(str) {
        return str.replace(/[\u0080-\uffff]/g, function(ch) {
                var code = ch.charCodeAt(0).toString(16);
                while (code.length < 4) code = "0" + code;
                return "\\u" + code;
        });
};

var SPLICE_NEEDS_BRACKETS = jsp.array_to_hash([ "if", "while", "do", "for", "for-in", "with" ]);

function gen_code(ast, options) {
        options = defaults(options, {
                indent_start : 0,
                indent_level : 4,
                quote_keys   : false,
                space_colon  : false,
                beautify     : false,
                ascii_only   : false,
                inline_script: false
        });
        var beautify = !!options.beautify;
        var indentation = 0,
            newline = beautify ? "\n" : "",
            space = beautify ? " " : "";

        function encode_string(str) {
                var ret = make_string(str, options.ascii_only);
                if (options.inline_script)
                        ret = ret.replace(/<\x2fscript([>\/\t\n\f\r ])/gi, "<\\/script$1");
                return ret;
        };

        function make_name(name) {
                name = name.toString();
                if (options.ascii_only)
                        name = to_ascii(name);
                return name;
        };

        function indent(line) {
                if (line == null)
                        line = "";
                if (beautify)
                        line = repeat_string(" ", options.indent_start + indentation * options.indent_level) + line;
                return line;
        };

        function with_indent(cont, incr) {
                if (incr == null) incr = 1;
                indentation += incr;
                try { return cont.apply(null, slice(arguments, 1)); }
                finally { indentation -= incr; }
        };

        function last_char(str) {
                str = str.toString();
                return str.charAt(str.length - 1);
        };

        function first_char(str) {
                return str.toString().charAt(0);
        };

        function add_spaces(a) {
                if (beautify)
                        return a.join(" ");
                var b = [];
                for (var i = 0; i < a.length; ++i) {
                        var next = a[i + 1];
                        b.push(a[i]);
                        if (next &&
                            ((is_identifier_char(last_char(a[i])) && (is_identifier_char(first_char(next))
                                                                      || first_char(next) == "\\")) ||
                             (/[\+\-]$/.test(a[i].toString()) && /^[\+\-]/.test(next.toString())))) {
                                b.push(" ");
                        }
                }
                return b.join("");
        };

        function add_commas(a) {
                return a.join("," + space);
        };

        function parenthesize(expr) {
                var gen = make(expr);
                for (var i = 1; i < arguments.length; ++i) {
                        var el = arguments[i];
                        if ((el instanceof Function && el(expr)) || expr[0] == el)
                                return "(" + gen + ")";
                }
                return gen;
        };

        function best_of(a) {
                if (a.length == 1) {
                        return a[0];
                }
                if (a.length == 2) {
                        var b = a[1];
                        a = a[0];
                        return a.length <= b.length ? a : b;
                }
                return best_of([ a[0], best_of(a.slice(1)) ]);
        };

        function needs_parens(expr) {
                if (expr[0] == "function" || expr[0] == "object") {
                        // dot/call on a literal function requires the
                        // function literal itself to be parenthesized
                        // only if it's the first "thing" in a
                        // statement.  This means that the parent is
                        // "stat", but it could also be a "seq" and
                        // we're the first in this "seq" and the
                        // parent is "stat", and so on.  Messy stuff,
                        // but it worths the trouble.
                        var a = slice(w.stack()), self = a.pop(), p = a.pop();
                        while (p) {
                                if (p[0] == "stat") return true;
                                if (((p[0] == "seq" || p[0] == "call" || p[0] == "dot" || p[0] == "sub" || p[0] == "conditional") && p[1] === self) ||
                                    ((p[0] == "binary" || p[0] == "assign" || p[0] == "unary-postfix") && p[2] === self)) {
                                        self = p;
                                        p = a.pop();
                                } else {
                                        return false;
                                }
                        }
                }
                return !HOP(DOT_CALL_NO_PARENS, expr[0]);
        };

        function make_num(num) {
                var str = num.toString(10), a = [ str.replace(/^0\./, ".").replace('e+', 'e') ], m;
                if (Math.floor(num) === num) {
                        if (num >= 0) {
                                a.push("0x" + num.toString(16).toLowerCase(), // probably pointless
                                       "0" + num.toString(8)); // same.
                        } else {
                                a.push("-0x" + (-num).toString(16).toLowerCase(), // probably pointless
                                       "-0" + (-num).toString(8)); // same.
                        }
                        if ((m = /^(.*?)(0+)$/.exec(num))) {
                                a.push(m[1] + "e" + m[2].length);
                        }
                } else if ((m = /^0?\.(0+)(.*)$/.exec(num))) {
                        a.push(m[2] + "e-" + (m[1].length + m[2].length),
                               str.substr(str.indexOf(".")));
                }
                return best_of(a);
        };

        var w = ast_walker();
        var make = w.walk;
        return w.with_walkers({
                "string": encode_string,
                "num": make_num,
                "name": make_name,
                "debugger": function(){ return "debugger;" },
                "toplevel": function(statements) {
                        return make_block_statements(statements)
                                .join(newline + newline);
                },
                "splice": function(statements) {
                        var parent = w.parent();
                        if (HOP(SPLICE_NEEDS_BRACKETS, parent)) {
                                // we need block brackets in this case
                                return make_block.apply(this, arguments);
                        } else {
                                return MAP(make_block_statements(statements, true),
                                           function(line, i) {
                                                   // the first line is already indented
                                                   return i > 0 ? indent(line) : line;
                                           }).join(newline);
                        }
                },
                "block": make_block,
                "var": function(defs) {
                        return "var " + add_commas(MAP(defs, make_1vardef)) + ";";
                },
                "const": function(defs) {
                        return "const " + add_commas(MAP(defs, make_1vardef)) + ";";
                },
                "try": function(tr, ca, fi) {
                        var out = [ "try", make_block(tr) ];
                        if (ca) out.push("catch", "(" + ca[0] + ")", make_block(ca[1]));
                        if (fi) out.push("finally", make_block(fi));
                        return add_spaces(out);
                },
                "throw": function(expr) {
                        return add_spaces([ "throw", make(expr) ]) + ";";
                },
                "new": function(ctor, args) {
                        args = args.length > 0 ? "(" + add_commas(MAP(args, function(expr){
                                return parenthesize(expr, "seq");
                        })) + ")" : "";
                        return add_spaces([ "new", parenthesize(ctor, "seq", "binary", "conditional", "assign", function(expr){
                                var w = ast_walker(), has_call = {};
                                try {
                                        w.with_walkers({
                                                "call": function() { throw has_call },
                                                "function": function() { return this }
                                        }, function(){
                                                w.walk(expr);
                                        });
                                } catch(ex) {
                                        if (ex === has_call)
                                                return true;
                                        throw ex;
                                }
                        }) + args ]);
                },
                "switch": function(expr, body) {
                        return add_spaces([ "switch", "(" + make(expr) + ")", make_switch_block(body) ]);
                },
                "break": function(label) {
                        var out = "break";
                        if (label != null)
                                out += " " + make_name(label);
                        return out + ";";
                },
                "continue": function(label) {
                        var out = "continue";
                        if (label != null)
                                out += " " + make_name(label);
                        return out + ";";
                },
                "conditional": function(co, th, el) {
                        return add_spaces([ parenthesize(co, "assign", "seq", "conditional"), "?",
                                            parenthesize(th, "seq"), ":",
                                            parenthesize(el, "seq") ]);
                },
                "assign": function(op, lvalue, rvalue) {
                        if (op && op !== true) op += "=";
                        else op = "=";
                        return add_spaces([ make(lvalue), op, parenthesize(rvalue, "seq") ]);
                },
                "dot": function(expr) {
                        var out = make(expr), i = 1;
                        if (expr[0] == "num") {
                                if (!/[a-f.]/i.test(out))
                                        out += ".";
                        } else if (expr[0] != "function" && needs_parens(expr))
                                out = "(" + out + ")";
                        while (i < arguments.length)
                                out += "." + make_name(arguments[i++]);
                        return out;
                },
                "call": function(func, args) {
                        var f = make(func);
                        if (f.charAt(0) != "(" && needs_parens(func))
                                f = "(" + f + ")";
                        return f + "(" + add_commas(MAP(args, function(expr){
                                return parenthesize(expr, "seq");
                        })) + ")";
                },
                "function": make_function,
                "defun": make_function,
                "if": function(co, th, el) {
                        var out = [ "if", "(" + make(co) + ")", el ? make_then(th) : make(th) ];
                        if (el) {
                                out.push("else", make(el));
                        }
                        return add_spaces(out);
                },
                "for": function(init, cond, step, block) {
                        var out = [ "for" ];
                        init = (init != null ? make(init) : "").replace(/;*\s*$/, ";" + space);
                        cond = (cond != null ? make(cond) : "").replace(/;*\s*$/, ";" + space);
                        step = (step != null ? make(step) : "").replace(/;*\s*$/, "");
                        var args = init + cond + step;
                        if (args == "; ; ") args = ";;";
                        out.push("(" + args + ")", make(block));
                        return add_spaces(out);
                },
                "for-in": function(vvar, key, hash, block) {
                        return add_spaces([ "for", "(" +
                                            (vvar ? make(vvar).replace(/;+$/, "") : make(key)),
                                            "in",
                                            make(hash) + ")", make(block) ]);
                },
                "while": function(condition, block) {
                        return add_spaces([ "while", "(" + make(condition) + ")", make(block) ]);
                },
                "do": function(condition, block) {
                        return add_spaces([ "do", make(block), "while", "(" + make(condition) + ")" ]) + ";";
                },
                "return": function(expr) {
                        var out = [ "return" ];
                        if (expr != null) out.push(make(expr));
                        return add_spaces(out) + ";";
                },
                "binary": function(operator, lvalue, rvalue) {
                        var left = make(lvalue), right = make(rvalue);
                        // XXX: I'm pretty sure other cases will bite here.
                        //      we need to be smarter.
                        //      adding parens all the time is the safest bet.
                        if (member(lvalue[0], [ "assign", "conditional", "seq" ]) ||
                            lvalue[0] == "binary" && PRECEDENCE[operator] > PRECEDENCE[lvalue[1]] ||
                            lvalue[0] == "function" && needs_parens(this)) {
                                left = "(" + left + ")";
                        }
                        if (member(rvalue[0], [ "assign", "conditional", "seq" ]) ||
                            rvalue[0] == "binary" && PRECEDENCE[operator] >= PRECEDENCE[rvalue[1]] &&
                            !(rvalue[1] == operator && member(operator, [ "&&", "||", "*" ]))) {
                                right = "(" + right + ")";
                        }
                        else if (!beautify && options.inline_script && (operator == "<" || operator == "<<")
                                 && rvalue[0] == "regexp" && /^script/i.test(rvalue[1])) {
                                right = " " + right;
                        }
                        return add_spaces([ left, operator, right ]);
                },
                "unary-prefix": function(operator, expr) {
                        var val = make(expr);
                        if (!(expr[0] == "num" || (expr[0] == "unary-prefix" && !HOP(OPERATORS, operator + expr[1])) || !needs_parens(expr)))
                                val = "(" + val + ")";
                        return operator + (jsp.is_alphanumeric_char(operator.charAt(0)) ? " " : "") + val;
                },
                "unary-postfix": function(operator, expr) {
                        var val = make(expr);
                        if (!(expr[0] == "num" || (expr[0] == "unary-postfix" && !HOP(OPERATORS, operator + expr[1])) || !needs_parens(expr)))
                                val = "(" + val + ")";
                        return val + operator;
                },
                "sub": function(expr, subscript) {
                        var hash = make(expr);
                        if (needs_parens(expr))
                                hash = "(" + hash + ")";
                        return hash + "[" + make(subscript) + "]";
                },
                "object": function(props) {
                        var obj_needs_parens = needs_parens(this);
                        if (props.length == 0)
                                return obj_needs_parens ? "({})" : "{}";
                        var out = "{" + newline + with_indent(function(){
                                return MAP(props, function(p){
                                        if (p.length == 3) {
                                                // getter/setter.  The name is in p[0], the arg.list in p[1][2], the
                                                // body in p[1][3] and type ("get" / "set") in p[2].
                                                return indent(make_function(p[0], p[1][2], p[1][3], p[2], true));
                                        }
                                        var key = p[0], val = parenthesize(p[1], "seq");
                                        if (options.quote_keys) {
                                                key = encode_string(key);
                                        } else if ((typeof key == "number" || !beautify && +key + "" == key)
                                                   && parseFloat(key) >= 0) {
                                                key = make_num(+key);
                                        } else if (!is_identifier(key)) {
                                                key = encode_string(key);
                                        }
                                        return indent(add_spaces(beautify && options.space_colon
                                                                 ? [ key, ":", val ]
                                                                 : [ key + ":", val ]));
                                }).join("," + newline);
                        }) + newline + indent("}");
                        return obj_needs_parens ? "(" + out + ")" : out;
                },
                "regexp": function(rx, mods) {
                        if (options.ascii_only) rx = to_ascii(rx);
                        return "/" + rx + "/" + mods;
                },
                "array": function(elements) {
                        if (elements.length == 0) return "[]";
                        return add_spaces([ "[", add_commas(MAP(elements, function(el, i){
                                if (!beautify && el[0] == "atom" && el[1] == "undefined") return i === elements.length - 1 ? "," : "";
                                return parenthesize(el, "seq");
                        })), "]" ]);
                },
                "stat": function(stmt) {
                        return stmt != null
                                ? make(stmt).replace(/;*\s*$/, ";")
                                : ";";
                },
                "seq": function() {
                        return add_commas(MAP(slice(arguments), make));
                },
                "label": function(name, block) {
                        return add_spaces([ make_name(name), ":", make(block) ]);
                },
                "with": function(expr, block) {
                        return add_spaces([ "with", "(" + make(expr) + ")", make(block) ]);
                },
                "atom": function(name) {
                        return make_name(name);
                },
                "directive": function(dir) {
                        return make_string(dir) + ";";
                }
        }, function(){ return make(ast) });

        // The squeezer replaces "block"-s that contain only a single
        // statement with the statement itself; technically, the AST
        // is correct, but this can create problems when we output an
        // IF having an ELSE clause where the THEN clause ends in an
        // IF *without* an ELSE block (then the outer ELSE would refer
        // to the inner IF).  This function checks for this case and
        // adds the block brackets if needed.
        function make_then(th) {
                if (th == null) return ";";
                if (th[0] == "do") {
                        // https://github.com/mishoo/UglifyJS/issues/#issue/57
                        // IE croaks with "syntax error" on code like this:
                        //     if (foo) do ... while(cond); else ...
                        // we need block brackets around do/while
                        return make_block([ th ]);
                }
                var b = th;
                while (true) {
                        var type = b[0];
                        if (type == "if") {
                                if (!b[3])
                                        // no else, we must add the block
                                        return make([ "block", [ th ]]);
                                b = b[3];
                        }
                        else if (type == "while" || type == "do") b = b[2];
                        else if (type == "for" || type == "for-in") b = b[4];
                        else break;
                }
                return make(th);
        };

        function make_function(name, args, body, keyword, no_parens) {
                var out = keyword || "function";
                if (name) {
                        out += " " + make_name(name);
                }
                out += "(" + add_commas(MAP(args, make_name)) + ")";
                out = add_spaces([ out, make_block(body) ]);
                return (!no_parens && needs_parens(this)) ? "(" + out + ")" : out;
        };

        function must_has_semicolon(node) {
                switch (node[0]) {
                    case "with":
                    case "while":
                        return empty(node[2]) || must_has_semicolon(node[2]);
                    case "for":
                    case "for-in":
                        return empty(node[4]) || must_has_semicolon(node[4]);
                    case "if":
                        if (empty(node[2]) && !node[3]) return true; // `if' with empty `then' and no `else'
                        if (node[3]) {
                                if (empty(node[3])) return true; // `else' present but empty
                                return must_has_semicolon(node[3]); // dive into the `else' branch
                        }
                        return must_has_semicolon(node[2]); // dive into the `then' branch
                    case "directive":
                        return true;
                }
        };

        function make_block_statements(statements, noindent) {
                for (var a = [], last = statements.length - 1, i = 0; i <= last; ++i) {
                        var stat = statements[i];
                        var code = make(stat);
                        if (code != ";") {
                                if (!beautify && i == last && !must_has_semicolon(stat)) {
                                        code = code.replace(/;+\s*$/, "");
                                }
                                a.push(code);
                        }
                }
                return noindent ? a : MAP(a, indent);
        };

        function make_switch_block(body) {
                var n = body.length;
                if (n == 0) return "{}";
                return "{" + newline + MAP(body, function(branch, i){
                        var has_body = branch[1].length > 0, code = with_indent(function(){
                                return indent(branch[0]
                                              ? add_spaces([ "case", make(branch[0]) + ":" ])
                                              : "default:");
                        }, 0.5) + (has_body ? newline + with_indent(function(){
                                return make_block_statements(branch[1]).join(newline);
                        }) : "");
                        if (!beautify && has_body && i < n - 1)
                                code += ";";
                        return code;
                }).join(newline) + newline + indent("}");
        };

        function make_block(statements) {
                if (!statements) return ";";
                if (statements.length == 0) return "{}";
                return "{" + newline + with_indent(function(){
                        return make_block_statements(statements).join(newline);
                }) + newline + indent("}");
        };

        function make_1vardef(def) {
                var name = def[0], val = def[1];
                if (val != null)
                        name = add_spaces([ make_name(name), "=", parenthesize(val, "seq") ]);
                return name;
        };

};

function split_lines(code, max_line_length) {
        var splits = [ 0 ];
        jsp.parse(function(){
                var next_token = jsp.tokenizer(code);
                var last_split = 0;
                var prev_token;
                function current_length(tok) {
                        return tok.pos - last_split;
                };
                function split_here(tok) {
                        last_split = tok.pos;
                        splits.push(last_split);
                };
                function custom(){
                        var tok = next_token.apply(this, arguments);
                        out: {
                                if (prev_token) {
                                        if (prev_token.type == "keyword") break out;
                                }
                                if (current_length(tok) > max_line_length) {
                                        switch (tok.type) {
                                            case "keyword":
                                            case "atom":
                                            case "name":
                                            case "punc":
                                                split_here(tok);
                                                break out;
                                        }
                                }
                        }
                        prev_token = tok;
                        return tok;
                };
                custom.context = function() {
                        return next_token.context.apply(this, arguments);
                };
                return custom;
        }());
        return splits.map(function(pos, i){
                return code.substring(pos, splits[i + 1] || code.length);
        }).join("\n");
};

/* -----[ Utilities ]----- */

function repeat_string(str, i) {
        if (i <= 0) return "";
        if (i == 1) return str;
        var d = repeat_string(str, i >> 1);
        d += d;
        if (i & 1) d += str;
        return d;
};

function defaults(args, defs) {
        var ret = {};
        if (args === true)
                args = {};
        for (var i in defs) if (HOP(defs, i)) {
                ret[i] = (args && HOP(args, i)) ? args[i] : defs[i];
        }
        return ret;
};

function is_identifier(name) {
        return /^[a-z_$][a-z0-9_$]*$/i.test(name)
                && name != "this"
                && !HOP(jsp.KEYWORDS_ATOM, name)
                && !HOP(jsp.RESERVED_WORDS, name)
                && !HOP(jsp.KEYWORDS, name);
};

function HOP(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
};

// some utilities

var MAP;

(function(){
        MAP = function(a, f, o) {
                var ret = [], top = [], i;
                function doit() {
                        var val = f.call(o, a[i], i);
                        if (val instanceof AtTop) {
                                val = val.v;
                                if (val instanceof Splice) {
                                        top.push.apply(top, val.v);
                                } else {
                                        top.push(val);
                                }
                        }
                        else if (val != skip) {
                                if (val instanceof Splice) {
                                        ret.push.apply(ret, val.v);
                                } else {
                                        ret.push(val);
                                }
                        }
                };
                if (a instanceof Array) for (i = 0; i < a.length; ++i) doit();
                else for (i in a) if (HOP(a, i)) doit();
                return top.concat(ret);
        };
        MAP.at_top = function(val) { return new AtTop(val) };
        MAP.splice = function(val) { return new Splice(val) };
        var skip = MAP.skip = {};
        function AtTop(val) { this.v = val };
        function Splice(val) { this.v = val };
})();

/* -----[ Exports ]----- */

exports.ast_walker = ast_walker;
exports.ast_mangle = ast_mangle;
exports.ast_squeeze = ast_squeeze;
exports.ast_lift_variables = ast_lift_variables;
exports.gen_code = gen_code;
exports.ast_add_scope = ast_add_scope;
exports.set_logger = function(logger) { warn = logger };
exports.make_string = make_string;
exports.split_lines = split_lines;
exports.MAP = MAP;

// keep this last!
exports.ast_squeeze_more = require("./squeeze-more").ast_squeeze_more;

// Local variables:
// js-indent-level: 8
// End:

},{"./parse-js":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/parse-js.js","./squeeze-more":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/squeeze-more.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/squeeze-more.js":[function(require,module,exports){
var jsp = require("./parse-js"),
    pro = require("./process"),
    slice = jsp.slice,
    member = jsp.member,
    curry = jsp.curry,
    MAP = pro.MAP,
    PRECEDENCE = jsp.PRECEDENCE,
    OPERATORS = jsp.OPERATORS;

function ast_squeeze_more(ast) {
        var w = pro.ast_walker(), walk = w.walk, scope;
        function with_scope(s, cont) {
                var save = scope, ret;
                scope = s;
                ret = cont();
                scope = save;
                return ret;
        };
        function _lambda(name, args, body) {
                return [ this[0], name, args, with_scope(body.scope, curry(MAP, body, walk)) ];
        };
        return w.with_walkers({
                "toplevel": function(body) {
                        return [ this[0], with_scope(this.scope, curry(MAP, body, walk)) ];
                },
                "function": _lambda,
                "defun": _lambda,
                "new": function(ctor, args) {
                        if (ctor[0] == "name") {
                                if (ctor[1] == "Array" && !scope.has("Array")) {
                                        if (args.length != 1) {
                                                return [ "array", args ];
                                        } else {
                                                return walk([ "call", [ "name", "Array" ], args ]);
                                        }
                                } else if (ctor[1] == "Object" && !scope.has("Object")) {
                                        if (!args.length) {
                                                return [ "object", [] ];
                                        } else {
                                                return walk([ "call", [ "name", "Object" ], args ]);
                                        }
                                } else if ((ctor[1] == "RegExp" || ctor[1] == "Function" || ctor[1] == "Error") && !scope.has(ctor[1])) {
                                        return walk([ "call", [ "name", ctor[1] ], args]);
                                }
                        }
                },
                "call": function(expr, args) {
                        if (expr[0] == "dot" && expr[1][0] == "string" && args.length == 1
                            && (args[0][1] > 0 && expr[2] == "substring" || expr[2] == "substr")) {
                                return [ "call", [ "dot", expr[1], "slice"], args];
                        }
                        if (expr[0] == "dot" && expr[2] == "toString" && args.length == 0) {
                                // foo.toString()  ==>  foo+""
                                if (expr[1][0] == "string") return expr[1];
                                return [ "binary", "+", expr[1], [ "string", "" ]];
                        }
                        if (expr[0] == "name") {
                                if (expr[1] == "Array" && args.length != 1 && !scope.has("Array")) {
                                        return [ "array", args ];
                                }
                                if (expr[1] == "Object" && !args.length && !scope.has("Object")) {
                                        return [ "object", [] ];
                                }
                                if (expr[1] == "String" && !scope.has("String")) {
                                        return [ "binary", "+", args[0], [ "string", "" ]];
                                }
                        }
                }
        }, function() {
                return walk(pro.ast_add_scope(ast));
        });
};

exports.ast_squeeze_more = ast_squeeze_more;

// Local variables:
// js-indent-level: 8
// End:

},{"./parse-js":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/parse-js.js","./process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/process.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/uglify-js.js":[function(require,module,exports){
//convienence function(src, [options]);
function uglify(orig_code, options){
  options || (options = {});
  var jsp = uglify.parser;
  var pro = uglify.uglify;

  var ast = jsp.parse(orig_code, options.strict_semicolons); // parse code and get the initial AST
  ast = pro.ast_mangle(ast, options.mangle_options); // get a new AST with mangled names
  ast = pro.ast_squeeze(ast, options.squeeze_options); // get an AST with compression optimizations
  var final_code = pro.gen_code(ast, options.gen_options); // compressed code here
  return final_code;
};

uglify.parser = require("./lib/parse-js");
uglify.uglify = require("./lib/process");
uglify.consolidator = require("./lib/consolidator");

module.exports = uglify

},{"./lib/consolidator":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/consolidator.js","./lib/parse-js":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/parse-js.js","./lib/process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/uglify-js/lib/process.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/underscore/underscore.js":[function(require,module,exports){
//     Underscore.js 1.3.3
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore is freely distributable under the MIT license.
//     Portions of Underscore are inspired or borrowed from Prototype,
//     Oliver Steele's Functional, and John Resig's Micro-Templating.
//     For all details and documentation:
//     http://documentcloud.github.com/underscore

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var slice            = ArrayProto.slice,
      unshift          = ArrayProto.unshift,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) { return new wrapper(obj); };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root['_'] = _;
  }

  // Current version.
  _.VERSION = '1.3.3';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    if (obj.length === +obj.length) results.length = obj.length;
    return results;
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError('Reduce of empty array with no initial value');
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var reversed = _.toArray(obj).reverse();
    if (context && !initial) iterator = _.bind(iterator, context);
    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    each(obj, function(value, index, list) {
      if (!iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if a given value is included in the array or object using `===`.
  // Aliased as `contains`.
  _.include = _.contains = function(obj, target) {
    var found = false;
    if (obj == null) return found;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    found = any(obj, function(value) {
      return value === target;
    });
    return found;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    return _.map(obj, function(value) {
      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Return the maximum element or (element-based computation).
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var shuffled = [], rand;
    each(obj, function(value, index, list) {
      rand = Math.floor(Math.random() * (index + 1));
      shuffled[index] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, val, context) {
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      if (a === void 0) return 1;
      if (b === void 0) return -1;
      return a < b ? -1 : a > b ? 1 : 0;
    }), 'value');
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, val) {
    var result = {};
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    each(obj, function(value, index) {
      var key = iterator(value, index);
      (result[key] || (result[key] = [])).push(value);
    });
    return result;
  };

  // Use a comparator function to figure out at what index an object should
  // be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator) {
    iterator || (iterator = _.identity);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >> 1;
      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj)                                     return [];
    if (_.isArray(obj))                           return slice.call(obj);
    if (_.isArguments(obj))                       return slice.call(obj);
    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    return _.isArray(obj) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especcialy useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail`.
  // Especially useful on the arguments object. Passing an **index** will return
  // the rest of the values in the array from that index onward. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = function(array, index, guard) {
    return slice.call(array, (index == null) || guard ? 1 : index);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, function(value){ return !!value; });
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return _.reduce(array, function(memo, value) {
      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));
      memo[memo.length] = value;
      return memo;
    }, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator) {
    var initial = iterator ? _.map(array, iterator) : array;
    var results = [];
    // The `isSorted` flag is irrelevant if the array only contains two elements.
    if (array.length < 3) isSorted = true;
    _.reduce(initial, function (memo, value, index) {
      if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {
        memo.push(value);
        results.push(array[index]);
      }
      return memo;
    }, []);
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays. (Aliased as "intersect" for back-compat.)
  _.intersection = _.intersect = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = _.flatten(slice.call(arguments, 1), true);
    return _.filter(array, function(value){ return !_.include(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) results[i] = _.pluck(args, "" + i);
    return results;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i, l;
    if (isSorted) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item) {
    if (array == null) return -1;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
    var i = array.length;
    while (i--) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Binding with arguments is also known as `curry`.
  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
  // We check for `func.bind` first, to fail fast when `func` is undefined.
  _.bind = function bind(func, context) {
    var bound, args;
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length == 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, throttling, more, result;
    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);
    return function() {
      context = this; args = arguments;
      var later = function() {
        timeout = null;
        if (more) func.apply(context, args);
        whenDone();
      };
      if (!timeout) timeout = setTimeout(later, wait);
      if (throttling) {
        more = true;
      } else {
        result = func.apply(context, args);
      }
      whenDone();
      throttling = true;
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      if (immediate && !timeout) func.apply(context, args);
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      return memo = func.apply(this, arguments);
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func].concat(slice.call(arguments, 0));
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) { return func.apply(this, arguments); }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    return _.map(obj, _.identity);
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var result = {};
    each(_.flatten(slice.call(arguments, 1)), function(key) {
      if (key in obj) result[key] = obj[key];
    });
    return result;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        if (obj[prop] == null) obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function.
  function eq(a, b, stack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a._chain) a = a._wrapped;
    if (b._chain) b = b._wrapped;
    // Invoke a custom `isEqual` method if one is provided.
    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);
    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = stack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (stack[length] == a) return true;
    }
    // Add the first object to the stack of traversed objects.
    stack.push(a);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          // Ensure commutative equality for sparse arrays.
          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent.
      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    stack.pop();
    return result;
  }

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType == 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Is a given variable an arguments object?
  _.isArguments = function(obj) {
    return toString.call(obj) == '[object Arguments]';
  };
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Is a given value a function?
  _.isFunction = function(obj) {
    return toString.call(obj) == '[object Function]';
  };

  // Is a given value a string?
  _.isString = function(obj) {
    return toString.call(obj) == '[object String]';
  };

  // Is a given value a number?
  _.isNumber = function(obj) {
    return toString.call(obj) == '[object Number]';
  };

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return _.isNumber(obj) && isFinite(obj);
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    // `NaN` is the only value for which `===` is not reflexive.
    return obj !== obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value a date?
  _.isDate = function(obj) {
    return toString.call(obj) == '[object Date]';
  };

  // Is the given value a regular expression?
  _.isRegExp = function(obj) {
    return toString.call(obj) == '[object RegExp]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Has own property?
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function (n, iterator, context) {
    for (var i = 0; i < n; i++) iterator.call(context, i);
  };

  // Escape a string for HTML interpolation.
  _.escape = function(string) {
    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g,'&#x2F;');
  };

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object, ensuring that
  // they're correctly added to the OOP wrapper as well.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      addToWrapper(name, _[name] = obj[name]);
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = idCounter++;
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /.^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    '\\': '\\',
    "'": "'",
    'r': '\r',
    'n': '\n',
    't': '\t',
    'u2028': '\u2028',
    'u2029': '\u2029'
  };

  for (var p in escapes) escapes[escapes[p]] = p;
  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
  var unescaper = /\\(\\|'|r|n|t|u2028|u2029)/g;

  // Within an interpolation, evaluation, or escaping, remove HTML escaping
  // that had been previously added.
  var unescape = function(code) {
    return code.replace(unescaper, function(match, escape) {
      return escapes[escape];
    });
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    settings = _.defaults(settings || {}, _.templateSettings);

    // Compile the template source, taking care to escape characters that
    // cannot be included in a string literal and then unescape them in code
    // blocks.
    var source = "__p+='" + text
      .replace(escaper, function(match) {
        return '\\' + escapes[match];
      })
      .replace(settings.escape || noMatch, function(match, code) {
        return "'+\n_.escape(" + unescape(code) + ")+\n'";
      })
      .replace(settings.interpolate || noMatch, function(match, code) {
        return "'+\n(" + unescape(code) + ")+\n'";
      })
      .replace(settings.evaluate || noMatch, function(match, code) {
        return "';\n" + unescape(code) + "\n;__p+='";
      }) + "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __p='';" +
      "var print=function(){__p+=Array.prototype.join.call(arguments, '')};\n" +
      source + "return __p;\n";

    var render = new Function(settings.variable || 'obj', '_', source);
    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for build time
    // precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' +
      source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // The OOP Wrapper
  // ---------------

  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.
  var wrapper = function(obj) { this._wrapped = obj; };

  // Expose `wrapper.prototype` as `_.prototype`
  _.prototype = wrapper.prototype;

  // Helper function to continue chaining intermediate results.
  var result = function(obj, chain) {
    return chain ? _(obj).chain() : obj;
  };

  // A method to easily add functions to the OOP wrapper.
  var addToWrapper = function(name, func) {
    wrapper.prototype[name] = function() {
      var args = slice.call(arguments);
      unshift.call(args, this._wrapped);
      return result(func.apply(_, args), this._chain);
    };
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      var wrapped = this._wrapped;
      method.apply(wrapped, arguments);
      var length = wrapped.length;
      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];
      return result(wrapped, this._chain);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      return result(method.apply(this._wrapped, arguments), this._chain);
    };
  });

  // Start chaining a wrapped Underscore object.
  wrapper.prototype.chain = function() {
    this._chain = true;
    return this;
  };

  // Extracts the result from a wrapped and chained object.
  wrapper.prototype.value = function() {
    return this._wrapped;
  };

}).call(this);

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/unicoderegexp/lib/unicodeRegExp.js":[function(require,module,exports){
(function (root, factory) {
    // expose unicodeRegExp as
    // - an AMD module (require)
    // - a node module

    if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
        define(factory);
    } else {
        root.unicodeRegExp = factory();
    }
}(this, function (xregexp) {
    var unicodeRegExp = {};

    // These are taken from the XRegExp library (see ../extractRegExpsFromXRegExp.js):
    unicodeRegExp.letter = /[A-Za-z-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]/;
    unicodeRegExp.mark = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u08FE\u0900-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C01-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C82\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D02\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1DC0-\u1DE6\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE26]/;
    unicodeRegExp.number = /[0-9----------------------------------------------------------]/;
    unicodeRegExp.punctuation = /[\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
    unicodeRegExp.symbol = /[\u0024+<->\u005E`\u007C~--------------------------------------------------------------------]/;
    unicodeRegExp.separator = /[\u0020\u00A0\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
    unicodeRegExp.other = /[\u0000-\u001F\u007F-\u009F\u00AD\u0378\u0379\u037F-\u0383\u038B\u038D\u03A2\u0528-\u0530\u0557\u0558\u0560\u0588\u058B-\u058E\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u0605\u061C\u061D\u06DD\u070E\u070F\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08A1\u08AD-\u08E3\u08FF\u0978\u0980\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0C00\u0C04\u0C0D\u0C11\u0C29\u0C34\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5A-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C80\u0C81\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D01\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D4F-\u0D56\u0D58-\u0D5F\u0D64\u0D65\u0D76-\u0D78\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F5-\u13FF\u169D-\u169F\u16F1-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191D-\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C80-\u1CBF\u1CC8-\u1CCF\u1CF7-\u1CFF\u1DE7-\u1DFB\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u200B-\u200F\u202A-\u202E\u2060-\u206F\u2072\u2073\u208F\u209D-\u209F\u20BA-\u20CF\u20F1-\u20FF\u218A-\u218F\u23F4-\u23FF\u2427-\u243F\u244B-\u245F\u2700\u2B4D-\u2B4F\u2B5A-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E3C-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FCD-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA698-\uA69E\uA6F8-\uA6FF\uA78F\uA794-\uA79F\uA7AB-\uA7F7\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C5-\uA8CD\uA8DA-\uA8DF\uA8FC-\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9E0-\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAA7C-\uAA7F\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F-\uABBF\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE27-\uFE2F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD-\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFFB\uFFFE\uFFFF]/; // Other (control, format, private use, surrogate, and unassigned codes)

    var unicodePackageNamesMapping = {
        L: unicodeRegExp.letter,
        M: unicodeRegExp.mark,
        N: unicodeRegExp.number,
        P: unicodeRegExp.punctuation,
        S: unicodeRegExp.symbol,
        Z: unicodeRegExp.separator,
        C: unicodeRegExp.other,
        letter: unicodeRegExp.letter,
        mark: unicodeRegExp.mark,
        number: unicodeRegExp.number,
        digit: unicodeRegExp.number,
        punctuation: unicodeRegExp.punctuation,
        symbol: unicodeRegExp.symbol,
        separator: unicodeRegExp.separator,
        other: unicodeRegExp.other
    };

    unicodeRegExp.unicodePackageNameRegExp = new RegExp('^\\[\\:(\\^)?(' + Object.keys(unicodePackageNamesMapping).join('|') + ')\\:\\]$');

    unicodeRegExp.expandCldrUnicodeSetIdToCharacterClass = function (unicodeSetId) {
        return new RegExp(unicodeSetId.replace(unicodeRegExp.unicodePackageNameRegExp, function ($0, negated, packageName) {
            var characters = unicodePackageNamesMapping[packageName].source.replace(/^\[|\]$/g, '');
            return '[' + (negated ? '^' + characters : characters) + ']';
        }));
    };

    unicodeRegExp.spliceCharacterClassRegExps = function () { // ...
        var args = Array.prototype.slice.call(arguments);

        return new RegExp('[' + args.map(function (regExp) {
            return regExp.source.replace(/^\[|\]$/g, '');
        }).join("") + ']');
    };

    // All of the above combined, except 'separator', and 'other':
    unicodeRegExp.visible = unicodeRegExp.spliceCharacterClassRegExps(
        unicodeRegExp.letter,
        unicodeRegExp.mark,
        unicodeRegExp.number,
        unicodeRegExp.punctuation,
        unicodeRegExp.symbol
    );

    // The set of printable characters also includes space:
    unicodeRegExp.printable = unicodeRegExp.spliceCharacterClassRegExps(
        unicodeRegExp.visible,
        unicodeRegExp.separator
    );

    // Helper function for removing a char from a character class regular expression:

    function parseCharCode(u4, x2, literal) {
        if (u4 || x2) {
            return parseInt(u4 || x2, 16);
        } else {
            return literal.charCodeAt(0);
        }
    }

    function charCodeToRegExpToken(charCode) {
        if (charCode >= 0x20 && charCode < 0x7f) {
            return String.fromCharCode(charCode);
        } else {
            var hexStr = charCode.toString(16);
            return "\\u" + "0000".slice(hexStr.length) + hexStr;
        }
    }

    var characterClassToken = /(?:\\u([0-9a-f]{4})|\\x([0-9a-f]{2})|([^\-]))(?:-(?:\\u([0-9a-f]{4})|\\x([0-9a-f]{2})|([^\-])))?/gi;

    unicodeRegExp.removeCharacterFromCharacterClassRegExp = function (regExp, ch) {
        var charCode = ch.charCodeAt(0);

        return new RegExp('[' + regExp.source.replace(/^\[|\]$/g, '').replace(characterClassToken, function ($0, fromU4, fromX2, fromLiteral, toU4, toX2, toLiteral) {
            var fromCharCode = parseCharCode(fromU4, fromX2, fromLiteral);
            if (toU4 || toX2 || toLiteral) {
                var toCharCode = parseCharCode(toU4, toX2, toLiteral);
                if (charCode === fromCharCode) {
                    if (charCode + 1 < toCharCode) {
                        return charCodeToRegExpToken(charCode + 1) + '-' + charCodeToRegExpToken(toCharCode);
                    } else {
                        return charCodeToRegExpToken(toCharCode);
                    }
                } else if (charCode === toCharCode) {
                    if (fromCharCode < charCode - 1) {
                        return charCodeToRegExpToken(fromCharCode) + '-' + charCodeToRegExpToken(charCode - 1);
                    } else {
                        // fromCharCode === toCharCode - 1, rewrite to single char
                        return charCodeToRegExpToken(fromCharCode);
                    }
                } else if (charCode > fromCharCode && charCode < toCharCode) {
                    return charCodeToRegExpToken(fromCharCode) + (charCode > fromCharCode + 1 ? '-' + charCodeToRegExpToken(charCode - 1) : '') +
                        (charCode + 1 < toCharCode ? charCodeToRegExpToken(charCode + 1) + '-' : '') + charCodeToRegExpToken(toCharCode);
                } else {
                    return $0;
                }
            } else {
                if (charCode === fromCharCode) {
                    return "";
                } else {
                    return charCodeToRegExpToken(fromCharCode);
                }
            }
        }) + ']');
    };

    return unicodeRegExp;
}));

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xmldom/dom-parser.js":[function(require,module,exports){
function DOMParser(options){
	this.options = options ||{locator:{}};
	
}
DOMParser.prototype.parseFromString = function(source,mimeType){	
	var options = this.options;
	var sax =  new XMLReader();
	var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
	var errorHandler = options.errorHandler;
	var locator = options.locator;
	var defaultNSMap = options.xmlns||{};
	var entityMap = {'lt':'<','gt':'>','amp':'&','quot':'"','apos':"'"}
	if(locator){
		domBuilder.setDocumentLocator(locator)
	}
	
	sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);
	sax.domBuilder = options.domBuilder || domBuilder;
	if(/\/x?html?$/.test(mimeType)){
		entityMap.nbsp = '\xa0';
		entityMap.copy = '\xa9';
		defaultNSMap['']= 'http://www.w3.org/1999/xhtml';
	}
	if(source){
		sax.parse(source,defaultNSMap,entityMap);
	}else{
		sax.errorHandler.error("invalid document source");
	}
	return domBuilder.document;
}
function buildErrorHandler(errorImpl,domBuilder,locator){
	if(!errorImpl){
		if(domBuilder instanceof DOMHandler){
			return domBuilder;
		}
		errorImpl = domBuilder ;
	}
	var errorHandler = {}
	var isCallback = errorImpl instanceof Function;
	locator = locator||{}
	function build(key){
		var fn = errorImpl[key];
		if(!fn){
			if(isCallback){
				fn = errorImpl.length == 2?function(msg){errorImpl(key,msg)}:errorImpl;
			}else{
				var i=arguments.length;
				while(--i){
					if(fn = errorImpl[arguments[i]]){
						break;
					}
				}
			}
		}
		errorHandler[key] = fn && function(msg){
			fn(msg+_locator(locator));
		}||function(){};
	}
	build('warning','warn');
	build('error','warn','warning');
	build('fatalError','warn','warning','error');
	return errorHandler;
}
/**
 * +ContentHandler+ErrorHandler
 * +LexicalHandler+EntityResolver2
 * -DeclHandler-DTDHandler 
 * 
 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
 */
function DOMHandler() {
    this.cdata = false;
}
function position(locator,node){
	node.lineNumber = locator.lineNumber;
	node.columnNumber = locator.columnNumber;
}
/**
 * @see org.xml.sax.ContentHandler#startDocument
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
 */ 
DOMHandler.prototype = {
	startDocument : function() {
    	this.document = new DOMImplementation().createDocument(null, null, null);
    	if (this.locator) {
        	this.document.documentURI = this.locator.systemId;
    	}
	},
	startElement:function(namespaceURI, localName, qName, attrs) {
		var doc = this.document;
	    var el = doc.createElementNS(namespaceURI, qName||localName);
	    var len = attrs.length;
	    appendElement(this, el);
	    this.currentElement = el;
	    
		this.locator && position(this.locator,el)
	    for (var i = 0 ; i < len; i++) {
	        var namespaceURI = attrs.getURI(i);
	        var value = attrs.getValue(i);
	        var qName = attrs.getQName(i);
			var attr = doc.createAttributeNS(namespaceURI, qName);
			if( attr.getOffset){
				position(attr.getOffset(1),attr)
			}
			attr.value = attr.nodeValue = value;
			el.setAttributeNode(attr)
	    }
	},
	endElement:function(namespaceURI, localName, qName) {
		var current = this.currentElement
	    var tagName = current.tagName;
	    this.currentElement = current.parentNode;
	},
	startPrefixMapping:function(prefix, uri) {
	},
	endPrefixMapping:function(prefix) {
	},
	processingInstruction:function(target, data) {
	    var ins = this.document.createProcessingInstruction(target, data);
	    this.locator && position(this.locator,ins)
	    appendElement(this, ins);
	},
	ignorableWhitespace:function(ch, start, length) {
	},
	characters:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
		//console.log(chars)
		if(this.currentElement && chars){
			if (this.cdata) {
				var charNode = this.document.createCDATASection(chars);
				this.currentElement.appendChild(charNode);
			} else {
				var charNode = this.document.createTextNode(chars);
				this.currentElement.appendChild(charNode);
			}
			this.locator && position(this.locator,charNode)
		}
	},
	skippedEntity:function(name) {
	},
	endDocument:function() {
		this.document.normalize();
	},
	setDocumentLocator:function (locator) {
	    if(this.locator = locator){// && !('lineNumber' in locator)){
	    	locator.lineNumber = 0;
	    }
	},
	//LexicalHandler
	comment:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
	    var comm = this.document.createComment(chars);
	    this.locator && position(this.locator,comm)
	    appendElement(this, comm);
	},
	
	startCDATA:function() {
	    //used in characters() methods
	    this.cdata = true;
	},
	endCDATA:function() {
	    this.cdata = false;
	},
	
	startDTD:function(name, publicId, systemId) {
		var impl = this.document.implementation;
	    if (impl && impl.createDocumentType) {
	        var dt = impl.createDocumentType(name, publicId, systemId);
	        this.locator && position(this.locator,dt)
	        appendElement(this, dt);
	    }
	},
	/**
	 * @see org.xml.sax.ErrorHandler
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
	 */
	warning:function(error) {
		console.warn(error,_locator(this.locator));
	},
	error:function(error) {
		console.error(error,_locator(this.locator));
	},
	fatalError:function(error) {
		console.error(error,_locator(this.locator));
	    throw error;
	}
}
function _locator(l){
	if(l){
		return '\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'
	}
}
function _toString(chars,start,length){
	if(typeof chars == 'string'){
		return chars.substr(start,length)
	}else{//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
		if(chars.length >= start+length || start){
			return new java.lang.String(chars,start,length)+'';
		}
		return chars;
	}
}

/*
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
 * used method of org.xml.sax.ext.LexicalHandler:
 *  #comment(chars, start, length)
 *  #startCDATA()
 *  #endCDATA()
 *  #startDTD(name, publicId, systemId)
 *
 *
 * IGNORED method of org.xml.sax.ext.LexicalHandler:
 *  #endDTD()
 *  #startEntity(name)
 *  #endEntity(name)
 *
 *
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
 * IGNORED method of org.xml.sax.ext.DeclHandler
 * 	#attributeDecl(eName, aName, type, mode, value)
 *  #elementDecl(name, model)
 *  #externalEntityDecl(name, publicId, systemId)
 *  #internalEntityDecl(name, value)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
 * IGNORED method of org.xml.sax.EntityResolver2
 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
 *  #resolveEntity(publicId, systemId)
 *  #getExternalSubset(name, baseURI)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
 * IGNORED method of org.xml.sax.DTDHandler
 *  #notationDecl(name, publicId, systemId) {};
 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
 */
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){
	DOMHandler.prototype[key] = function(){return null}
})

/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
function appendElement (hander,node) {
    if (!hander.currentElement) {
        hander.document.appendChild(node);
    } else {
        hander.currentElement.appendChild(node);
    }
}//appendChild and setAttributeNS are preformance key

if(typeof require == 'function'){
	var XMLReader = require('./sax').XMLReader;
	var DOMImplementation = exports.DOMImplementation = require('./dom').DOMImplementation;
	exports.XMLSerializer = require('./dom').XMLSerializer ;
	exports.DOMParser = DOMParser;
}

},{"./dom":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xmldom/dom.js","./sax":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xmldom/sax.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xmldom/dom.js":[function(require,module,exports){
/*
 * DOM Level 2
 * Object DOMException
 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
 */

function copy(src,dest){
	for(var p in src){
		dest[p] = src[p];
	}
}
/**
^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
 */
function _extends(Class,Super){
	var pt = Class.prototype;
	if(Object.create){
		var ppt = Object.create(Super.prototype)
		pt.__proto__ = ppt;
	}
	if(!(pt instanceof Super)){
		function t(){};
		t.prototype = Super.prototype;
		t = new t();
		copy(pt,t);
		Class.prototype = pt = t;
	}
	if(pt.constructor != Class){
		if(typeof Class != 'function'){
			console.error("unknow Class:"+Class)
		}
		pt.constructor = Class
	}
}
var htmlns = 'http://www.w3.org/1999/xhtml' ;
// Node Types
var NodeType = {}
var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

// ExceptionCode
var ExceptionCode = {}
var ExceptionMessage = {};
var INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
var DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
var WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
var INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
var NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
var NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
//level2
var INVALID_STATE_ERR        	= ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
var SYNTAX_ERR               	= ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
var INVALID_MODIFICATION_ERR 	= ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
var NAMESPACE_ERR            	= ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
var INVALID_ACCESS_ERR       	= ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);


function DOMException(code, message) {
	if(message instanceof Error){
		var error = message;
	}else{
		error = this;
		Error.call(this, ExceptionMessage[code]);
		this.message = ExceptionMessage[code];
		if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
	}
	error.code = code;
	if(message) this.message = this.message + ": " + message;
	return error;
};
DOMException.prototype = Error.prototype;
copy(ExceptionCode,DOMException)
/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
 * The items in the NodeList are accessible via an integral index, starting from 0.
 */
function NodeList() {
};
NodeList.prototype = {
	/**
	 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
	 * @standard level1
	 */
	length:0, 
	/**
	 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
	 * @standard level1
	 * @param index  unsigned long 
	 *   Index into the collection.
	 * @return Node
	 * 	The node at the indexth position in the NodeList, or null if that is not a valid index. 
	 */
	item: function(index) {
		return this[index] || null;
	}
};
function LiveNodeList(node,refresh){
	this._node = node;
	this._refresh = refresh
	_updateLiveList(this);
}
function _updateLiveList(list){
	var inc = list._node._inc || list._node.ownerDocument._inc;
	if(list._inc != inc){
		var ls = list._refresh(list._node);
		//console.log(ls.length)
		__set__(list,'length',ls.length);
		copy(ls,list);
		list._inc = inc;
	}
}
LiveNodeList.prototype.item = function(i){
	_updateLiveList(this);
	return this[i];
}

_extends(LiveNodeList,NodeList);
/**
 * 
 * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.
 * NamedNodeMap objects in the DOM are live.
 * used for attributes or DocumentType entities 
 */
function NamedNodeMap() {
};

function _findNodeIndex(list,node){
	var i = list.length;
	while(i--){
		if(list[i] === node){return i}
	}
}

function _addNamedNode(el,list,newAttr,oldAttr){
	if(oldAttr){
		list[_findNodeIndex(list,oldAttr)] = newAttr;
	}else{
		list[list.length++] = newAttr;
	}
	if(el){
		newAttr.ownerElement = el;
		var doc = el.ownerDocument;
		if(doc){
			oldAttr && _onRemoveAttribute(doc,el,oldAttr);
			_onAddAttribute(doc,el,newAttr);
		}
	}
}
function _removeNamedNode(el,list,attr){
	var i = _findNodeIndex(list,attr);
	if(i>=0){
		var lastIndex = list.length-1
		while(i<lastIndex){
			list[i] = list[++i]
		}
		list.length = lastIndex;
		if(el){
			var doc = el.ownerDocument;
			if(doc){
				_onRemoveAttribute(doc,el,attr);
				attr.ownerElement = null;
			}
		}
	}else{
		throw DOMException(NOT_FOUND_ERR,new Error())
	}
}
NamedNodeMap.prototype = {
	length:0,
	item:NodeList.prototype.item,
	getNamedItem: function(key) {
//		if(key.indexOf(':')>0 || key == 'xmlns'){
//			return null;
//		}
		var i = this.length;
		while(i--){
			var attr = this[i];
			if(attr.nodeName == key){
				return attr;
			}
		}
	},
	setNamedItem: function(attr) {
		var el = attr.ownerElement;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		var oldAttr = this.getNamedItem(attr.nodeName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},
	/* returns Node */
	setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
		var el = attr.ownerElement, oldAttr;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},

	/* returns Node */
	removeNamedItem: function(key) {
		var attr = this.getNamedItem(key);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
		
		
	},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
	
	//for level2
	removeNamedItemNS:function(namespaceURI,localName){
		var attr = this.getNamedItemNS(namespaceURI,localName);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
	},
	getNamedItemNS: function(namespaceURI, localName) {
		var i = this.length;
		while(i--){
			var node = this[i];
			if(node.localName == localName && node.namespaceURI == namespaceURI){
				return node;
			}
		}
		return null;
	}
};
/**
 * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490
 */
function DOMImplementation(/* Object */ features) {
	this._features = {};
	if (features) {
		for (var feature in features) {
			 this._features = features[feature];
		}
	}
};

DOMImplementation.prototype = {
	hasFeature: function(/* string */ feature, /* string */ version) {
		var versions = this._features[feature.toLowerCase()];
		if (versions && (!version || version in versions)) {
			return true;
		} else {
			return false;
		}
	},
	// Introduced in DOM Level 2:
	createDocument:function(namespaceURI,  qualifiedName, doctype){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR
		var doc = new Document();
		doc.doctype = doctype;
		if(doctype){
			doc.appendChild(doctype);
		}
		doc.implementation = this;
		doc.childNodes = new NodeList();
		if(qualifiedName){
			var root = doc.createElementNS(namespaceURI,qualifiedName);
			doc.appendChild(root);
		}
		return doc;
	},
	// Introduced in DOM Level 2:
	createDocumentType:function(qualifiedName, publicId, systemId){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR
		var node = new DocumentType();
		node.name = qualifiedName;
		node.nodeName = qualifiedName;
		node.publicId = publicId;
		node.systemId = systemId;
		// Introduced in DOM Level 2:
		//readonly attribute DOMString        internalSubset;
		
		//TODO:..
		//  readonly attribute NamedNodeMap     entities;
		//  readonly attribute NamedNodeMap     notations;
		return node;
	}
};


/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
 */

function Node() {
};

Node.prototype = {
	firstChild : null,
	lastChild : null,
	previousSibling : null,
	nextSibling : null,
	attributes : null,
	parentNode : null,
	childNodes : null,
	ownerDocument : null,
	nodeValue : null,
	namespaceURI : null,
	prefix : null,
	localName : null,
	// Modified in DOM Level 2:
	insertBefore:function(newChild, refChild){//raises 
		return _insertBefore(this,newChild,refChild);
	},
	replaceChild:function(newChild, oldChild){//raises 
		this.insertBefore(newChild,oldChild);
		if(oldChild){
			this.removeChild(oldChild);
		}
	},
	removeChild:function(oldChild){
		return _removeChild(this,oldChild);
	},
	appendChild:function(newChild){
		return this.insertBefore(newChild,null);
	},
	hasChildNodes:function(){
		return this.firstChild != null;
	},
	cloneNode:function(deep){
		return cloneNode(this.ownerDocument||this,this,deep);
	},
	// Modified in DOM Level 2:
	normalize:function(){
		var child = this.firstChild;
		while(child){
			var next = child.nextSibling;
			if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
				this.removeChild(next);
				child.appendData(next.data);
			}else{
				child.normalize();
				child = next;
			}
		}
	},
  	// Introduced in DOM Level 2:
	isSupported:function(feature, version){
		return this.ownerDocument.implementation.hasFeature(feature,version);
	},
    // Introduced in DOM Level 2:
    hasAttributes:function(){
    	return this.attributes.length>0;
    },
    lookupPrefix:function(namespaceURI){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			for(var n in map){
    				if(map[n] == namespaceURI){
    					return n;
    				}
    			}
    		}
    		el = el.nodeType == 2?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI:function(prefix){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			if(prefix in map){
    				return map[prefix] ;
    			}
    		}
    		el = el.nodeType == 2?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace:function(namespaceURI){
    	var prefix = this.lookupPrefix(namespaceURI);
    	return prefix == null;
    }
};


function _xmlEncoder(c){
	return c == '<' && '&lt;' ||
         c == '>' && '&gt;' ||
         c == '&' && '&amp;' ||
         c == '"' && '&quot;' ||
         '&#'+c.charCodeAt()+';'
}


copy(NodeType,Node);
copy(NodeType,Node.prototype);

/**
 * @param callback return true for continue,false for break
 * @return boolean true: break visit;
 */
function _visitNode(node,callback){
	if(callback(node)){
		return true;
	}
	if(node = node.firstChild){
		do{
			if(_visitNode(node,callback)){return true}
        }while(node=node.nextSibling)
    }
}



function Document(){
}
function _onAddAttribute(doc,el,newAttr){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value
	}
}
function _onRemoveAttribute(doc,el,newAttr,remove){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		delete el._nsMap[newAttr.prefix?newAttr.localName:'']
	}
}
function _onUpdateChild(doc,el,newChild){
	if(doc && doc._inc){
		doc._inc++;
		//update childNodes
		var cs = el.childNodes;
		if(newChild){
			cs[cs.length++] = newChild;
		}else{
			//console.log(1)
			var child = el.firstChild;
			var i = 0;
			while(child){
				cs[i++] = child;
				child =child.nextSibling;
			}
			cs.length = i;
		}
	}
}

/**
 * attributes;
 * children;
 * 
 * writeable properties:
 * nodeValue,Attr:value,CharacterData:data
 * prefix
 */
function _removeChild(parentNode,child){
	var previous = child.previousSibling;
	var next = child.nextSibling;
	if(previous){
		previous.nextSibling = next;
	}else{
		parentNode.firstChild = next
	}
	if(next){
		next.previousSibling = previous;
	}else{
		parentNode.lastChild = previous;
	}
	_onUpdateChild(parentNode.ownerDocument,parentNode);
	return child;
}
/**
 * preformance key(refChild == null)
 */
function _insertBefore(parentNode,newChild,nextChild){
	var cp = newChild.parentNode;
	if(cp){
		cp.removeChild(newChild);//remove and update
	}
	if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
		var newFirst = newChild.firstChild;
		if (newFirst == null) {
			return newChild;
		}
		var newLast = newChild.lastChild;
	}else{
		newFirst = newLast = newChild;
	}
	var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;

	newFirst.previousSibling = pre;
	newLast.nextSibling = nextChild;
	
	
	if(pre){
		pre.nextSibling = newFirst;
	}else{
		parentNode.firstChild = newFirst;
	}
	if(nextChild == null){
		parentNode.lastChild = newLast;
	}else{
		nextChild.previousSibling = newLast;
	}
	do{
		newFirst.parentNode = parentNode;
	}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
	_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);
	//console.log(parentNode.lastChild.nextSibling == null)
	if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
		newChild.firstChild = newChild.lastChild = null;
	}
	return newChild;
}
function _appendSingleChild(parentNode,newChild){
	var cp = newChild.parentNode;
	if(cp){
		var pre = parentNode.lastChild;
		cp.removeChild(newChild);//remove and update
		var pre = parentNode.lastChild;
	}
	var pre = parentNode.lastChild;
	newChild.parentNode = parentNode;
	newChild.previousSibling = pre;
	newChild.nextSibling = null;
	if(pre){
		pre.nextSibling = newChild;
	}else{
		parentNode.firstChild = newChild;
	}
	parentNode.lastChild = newChild;
	_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);
	return newChild;
	//console.log("__aa",parentNode.lastChild.nextSibling == null)
}
Document.prototype = {
	//implementation : null,
	nodeName :  '#document',
	nodeType :  DOCUMENT_NODE,
	doctype :  null,
	documentElement :  null,
	_inc : 1,
	
	insertBefore :  function(newChild, refChild){//raises 
		if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
			var child = newChild.firstChild;
			while(child){
				var next = child.nextSibling;
				this.insertBefore(child,refChild);
				child = next;
			}
			return newChild;
		}
		if(this.documentElement == null && newChild.nodeType == 1){
			this.documentElement = newChild;
		}
		
		return _insertBefore(this,newChild,refChild),(newChild.ownerDocument = this),newChild;
	},
	removeChild :  function(oldChild){
		if(this.documentElement == oldChild){
			this.documentElement = null;
		}
		return _removeChild(this,oldChild);
	},
	// Introduced in DOM Level 2:
	importNode : function(importedNode,deep){
		return importNode(this,importedNode,deep);
	},
	// Introduced in DOM Level 2:
	getElementById :	function(id){
		var rtv = null;
		_visitNode(this.documentElement,function(node){
			if(node.nodeType == 1){
				if(node.getAttribute('id') == id){
					rtv = node;
					return true;
				}
			}
		})
		return rtv;
	},
	
	//document factory method:
	createElement :	function(tagName){
		var node = new Element();
		node.ownerDocument = this;
		node.nodeName = tagName;
		node.tagName = tagName;
		node.childNodes = new NodeList();
		var attrs	= node.attributes = new NamedNodeMap();
		attrs._ownerElement = node;
		return node;
	},
	createDocumentFragment :	function(){
		var node = new DocumentFragment();
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		return node;
	},
	createTextNode :	function(data){
		var node = new Text();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createComment :	function(data){
		var node = new Comment();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createCDATASection :	function(data){
		var node = new CDATASection();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createProcessingInstruction :	function(target,data){
		var node = new ProcessingInstruction();
		node.ownerDocument = this;
		node.tagName = node.target = target;
		node.nodeValue= node.data = data;
		return node;
	},
	createAttribute :	function(name){
		var node = new Attr();
		node.ownerDocument	= this;
		node.name = name;
		node.nodeName	= name;
		node.localName = name;
		node.specified = true;
		return node;
	},
	createEntityReference :	function(name){
		var node = new EntityReference();
		node.ownerDocument	= this;
		node.nodeName	= name;
		return node;
	},
	// Introduced in DOM Level 2:
	createElementNS :	function(namespaceURI,qualifiedName){
		var node = new Element();
		var pl = qualifiedName.split(':');
		var attrs	= node.attributes = new NamedNodeMap();
		node.childNodes = new NodeList();
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.tagName = qualifiedName;
		node.namespaceURI = namespaceURI;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		attrs._ownerElement = node;
		return node;
	},
	// Introduced in DOM Level 2:
	createAttributeNS :	function(namespaceURI,qualifiedName){
		var node = new Attr();
		var pl = qualifiedName.split(':');
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.name = qualifiedName;
		node.namespaceURI = namespaceURI;
		node.specified = true;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		return node;
	}
};
_extends(Document,Node);


function Element() {
	this._nsMap = {};
};
Element.prototype = {
	nodeType : ELEMENT_NODE,
	hasAttribute : function(name){
		return this.getAttributeNode(name)!=null;
	},
	getAttribute : function(name){
		var attr = this.getAttributeNode(name);
		return attr && attr.value || '';
	},
	getAttributeNode : function(name){
		return this.attributes.getNamedItem(name);
	},
	setAttribute : function(name, value){
		var attr = this.ownerDocument.createAttribute(name);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	removeAttribute : function(name){
		var attr = this.getAttributeNode(name)
		attr && this.removeAttributeNode(attr);
	},
	
	//four real opeartion method
	appendChild:function(newChild){
		if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
			return this.insertBefore(newChild,null);
		}else{
			return _appendSingleChild(this,newChild);
		}
	},
	setAttributeNode : function(newAttr){
		return this.attributes.setNamedItem(newAttr);
	},
	setAttributeNodeNS : function(newAttr){
		return this.attributes.setNamedItemNS(newAttr);
	},
	removeAttributeNode : function(oldAttr){
		return this.attributes.removeNamedItem(oldAttr.nodeName);
	},
	//get real attribute name,and remove it by removeAttributeNode
	removeAttributeNS : function(namespaceURI, localName){
		var old = this.getAttributeNodeNS(namespaceURI, localName);
		old && this.removeAttributeNode(old);
	},
	
	hasAttributeNS : function(namespaceURI, localName){
		return this.getAttributeNodeNS(namespaceURI, localName)!=null;
	},
	getAttributeNS : function(namespaceURI, localName){
		var attr = this.getAttributeNodeNS(namespaceURI, localName);
		return attr && attr.value || '';
	},
	setAttributeNS : function(namespaceURI, qualifiedName, value){
		var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
		attr.value = attr.nodeValue = value;
		this.setAttributeNode(attr)
	},
	getAttributeNodeNS : function(namespaceURI, localName){
		return this.attributes.getNamedItemNS(namespaceURI, localName);
	},
	
	getElementsByTagName : function(tagName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
					ls.push(node);
				}
			});
			return ls;
		});
	},
	getElementsByTagNameNS : function(namespaceURI, localName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType === ELEMENT_NODE && node.namespaceURI === namespaceURI && (localName === '*' || node.localName == localName)){
					ls.push(node);
				}
			});
			return ls;
		});
	}
};
Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


_extends(Element,Node);
function Attr() {
};
Attr.prototype.nodeType = ATTRIBUTE_NODE;
_extends(Attr,Node);


function CharacterData() {
};
CharacterData.prototype = {
	data : '',
	substringData : function(offset, count) {
		return this.data.substring(offset, offset+count);
	},
	appendData: function(text) {
		text = this.data+text;
		this.nodeValue = this.data = text;
		this.length = text.length;
	},
	insertData: function(offset,text) {
		this.replaceData(offset,0,text);
	
	},
	appendChild:function(newChild){
		//if(!(newChild instanceof CharacterData)){
			throw new Error(ExceptionMessage[3])
		//}
		return Node.prototype.appendChild.apply(this,arguments)
	},
	deleteData: function(offset, count) {
		this.replaceData(offset,count,"");
	},
	replaceData: function(offset, count, text) {
		var start = this.data.substring(0,offset);
		var end = this.data.substring(offset+count);
		text = start + text + end;
		this.nodeValue = this.data = text;
		this.length = text.length;
	}
}
_extends(CharacterData,Node);
function Text() {
};
Text.prototype = {
	nodeName : "#text",
	nodeType : TEXT_NODE,
	splitText : function(offset) {
		var text = this.data;
		var newText = text.substring(offset);
		text = text.substring(0, offset);
		this.data = this.nodeValue = text;
		this.length = text.length;
		var newNode = this.ownerDocument.createTextNode(newText);
		if(this.parentNode){
			this.parentNode.insertBefore(newNode, this.nextSibling);
		}
		return newNode;
	}
}
_extends(Text,CharacterData);
function Comment() {
};
Comment.prototype = {
	nodeName : "#comment",
	nodeType : COMMENT_NODE
}
_extends(Comment,CharacterData);

function CDATASection() {
};
CDATASection.prototype = {
	nodeName : "#cdata-section",
	nodeType : CDATA_SECTION_NODE
}
_extends(CDATASection,CharacterData);


function DocumentType() {
};
DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
_extends(DocumentType,Node);

function Notation() {
};
Notation.prototype.nodeType = NOTATION_NODE;
_extends(Notation,Node);

function Entity() {
};
Entity.prototype.nodeType = ENTITY_NODE;
_extends(Entity,Node);

function EntityReference() {
};
EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
_extends(EntityReference,Node);

function DocumentFragment() {
};
DocumentFragment.prototype.nodeName =	"#document-fragment";
DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
_extends(DocumentFragment,Node);


function ProcessingInstruction() {
}
ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
_extends(ProcessingInstruction,Node);
function XMLSerializer(){}
XMLSerializer.prototype.serializeToString = function(node){
	var buf = [];
	serializeToString(node,buf);
	return buf.join('');
}
Node.prototype.toString =function(){
	return XMLSerializer.prototype.serializeToString(this);
}
function serializeToString(node,buf){
	switch(node.nodeType){
	case ELEMENT_NODE:
		var attrs = node.attributes;
		var len = attrs.length;
		var child = node.firstChild;
		var nodeName = node.tagName;
		var isHTML = htmlns === node.namespaceURI
		buf.push('<',nodeName);
		for(var i=0;i<len;i++){
			serializeToString(attrs.item(i),buf,isHTML);
		}
		if(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){
			buf.push('>');
			//if is cdata child node
			if(isHTML && /^script$/i.test(nodeName)){
				if(child){
					buf.push(child.data);
				}
			}else{
				while(child){
					serializeToString(child,buf);
					child = child.nextSibling;
				}
			}
			buf.push('</',nodeName,'>');
		}else{
			buf.push('/>');
		}
		return;
	case DOCUMENT_NODE:
	case DOCUMENT_FRAGMENT_NODE:
		var child = node.firstChild;
		while(child){
			serializeToString(child,buf);
			child = child.nextSibling;
		}
		return;
	case ATTRIBUTE_NODE:
		return buf.push(' ',node.name,'="',node.value.replace(/[<&"]/g,_xmlEncoder),'"');
	case TEXT_NODE:
		return buf.push(node.data.replace(/[<&]/g,_xmlEncoder));
	case CDATA_SECTION_NODE:
		return buf.push( '<![CDATA[',node.data,']]>');
	case COMMENT_NODE:
		return buf.push( "<!--",node.data,"-->");
	case DOCUMENT_TYPE_NODE:
		var pubid = node.publicId;
		var sysid = node.systemId;
		buf.push('<!DOCTYPE ',node.name);
		if(pubid){
			buf.push(' PUBLIC "',pubid);
			if (sysid && sysid!='.') {
				buf.push( '" "',sysid);
			}
			buf.push('">');
		}else if(sysid && sysid!='.'){
			buf.push(' SYSTEM "',sysid,'">');
		}else{
			var sub = node.internalSubset;
			if(sub){
				buf.push(" [",sub,"]");
			}
			buf.push(">");
		}
		return;
	case PROCESSING_INSTRUCTION_NODE:
		return buf.push( "<?",node.target," ",node.data,"?>");
	case ENTITY_REFERENCE_NODE:
		return buf.push( '&',node.nodeName,';');
	//case ENTITY_NODE:
	//case NOTATION_NODE:
	default:
		buf.push('??',node.nodeName);
	}
}
function importNode(doc,node,deep){
	var node2;
	switch (node.nodeType) {
	case ELEMENT_NODE:
		node2 = node.cloneNode(false);
		node2.ownerDocument = doc;
		//var attrs = node2.attributes;
		//var len = attrs.length;
		//for(var i=0;i<len;i++){
			//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
		//}
	case DOCUMENT_FRAGMENT_NODE:
		break;
	case ATTRIBUTE_NODE:
		deep = true;
		break;
	//case ENTITY_REFERENCE_NODE:
	//case PROCESSING_INSTRUCTION_NODE:
	////case TEXT_NODE:
	//case CDATA_SECTION_NODE:
	//case COMMENT_NODE:
	//	deep = false;
	//	break;
	//case DOCUMENT_NODE:
	//case DOCUMENT_TYPE_NODE:
	//cannot be imported.
	//case ENTITY_NODE:
	//case NOTATION_NODE
	//can not hit in level3
	//default:throw e;
	}
	if(!node2){
		node2 = node.cloneNode(false);//false
	}
	node2.ownerDocument = doc;
	node2.parentNode = null;
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(importNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}
//
//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
function cloneNode(doc,node,deep){
	var node2 = new node.constructor();
	for(var n in node){
		var v = node[n];
		if(typeof v != 'object' ){
			if(v != node2[n]){
				node2[n] = v;
			}
		}
	}
	if(node.childNodes){
		node2.childNodes = new NodeList();
	}
	node2.ownerDocument = doc;
	switch (node2.nodeType) {
	case ELEMENT_NODE:
		var attrs	= node.attributes;
		var attrs2	= node2.attributes = new NamedNodeMap();
		var len = attrs.length
		attrs2._ownerElement = node2;
		for(var i=0;i<len;i++){
			node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
		}
		break;;
	case ATTRIBUTE_NODE:
		deep = true;
	}
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(cloneNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}

function __set__(object,key,value){
	object[key] = value
}
//do dynamic
try{
	if(Object.defineProperty){
		Object.defineProperty(LiveNodeList.prototype,'length',{
			get:function(){
				_updateLiveList(this);
				return this.$$length;
			}
		});
		Object.defineProperty(Node.prototype,'textContent',{
			get:function(){
				return getTextContent(this);
			},
			set:function(data){
				switch(this.nodeType){
				case 1:
				case 11:
					while(this.firstChild){
						this.removeChild(this.firstChild);
					}
					if(data || String(data)){
						this.appendChild(this.ownerDocument.createTextNode(data));
					}
					break;
				default:
					//TODO:
					this.data = data;
					this.value = value;
					this.nodeValue = data;
				}
			}
		})
		
		function getTextContent(node){
			switch(node.nodeType){
			case 1:
			case 11:
				var buf = [];
				node = node.firstChild;
				while(node){
					if(node.nodeType!==7 && node.nodeType !==8){
						buf.push(getTextContent(node));
					}
					node = node.nextSibling;
				}
				return buf.join('');
			default:
				return node.nodeValue;
			}
		}
		__set__ = function(object,key,value){
			//console.log(value)
			object['$$'+key] = value
		}
	}
}catch(e){//ie8
}

if(typeof require == 'function'){
	exports.DOMImplementation = DOMImplementation;
	exports.XMLSerializer = XMLSerializer;
}

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xmldom/sax.js":[function(require,module,exports){
//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
//[5]   	Name	   ::=   	NameStartChar (NameChar)*
var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]///\u10000-\uEFFFF
var nameChar = new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\u00B7\u0300-\u036F\\ux203F-\u2040]");
var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\:'+nameStartChar.source+nameChar.source+'*)?$');
//var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

//S_TAG,	S_ATTR,	S_EQ,	S_V
//S_ATTR_S,	S_E,	S_S,	S_C
var S_TAG = 0;//tag name offerring
var S_ATTR = 1;//attr name offerring 
var S_ATTR_S=2;//attr name end and space offer
var S_EQ = 3;//=space?
var S_V = 4;//attr value(no quot value only)
var S_E = 5;//attr value end and no space(quot end)
var S_S = 6;//(attr value end || tag end ) && (space offer)
var S_C = 7;//closed el<el />

function XMLReader(){
	
}

XMLReader.prototype = {
	parse:function(source,defaultNSMap,entityMap){
		var domBuilder = this.domBuilder;
		domBuilder.startDocument();
		_copy(defaultNSMap ,defaultNSMap = {})
		parse(source,defaultNSMap,entityMap,
				domBuilder,this.errorHandler);
		domBuilder.endDocument();
	}
}
function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){
  function fixedFromCharCode(code) {
		// String.prototype.fromCharCode does not supports
		// > 2 bytes unicode chars directly
		if (code > 0xffff) {
			code -= 0x10000;
			var surrogate1 = 0xd800 + (code >> 10)
				, surrogate2 = 0xdc00 + (code & 0x3ff);

			return String.fromCharCode(surrogate1, surrogate2);
		} else {
			return String.fromCharCode(code);
		}
	}
	function entityReplacer(a){
		var k = a.slice(1,-1);
		if(k in entityMap){
			return entityMap[k]; 
		}else if(k.charAt(0) === '#'){
			return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))
		}else{
			errorHandler.error('entity not found:'+a);
			return a;
		}
	}
	function appendText(end){//has some bugs
		var xt = source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);
		locator&&position(start);
		domBuilder.characters(xt,0,end-start);
		start = end
	}
	function position(start,m){
		while(start>=endPos && (m = linePattern.exec(source))){
			startPos = m.index;
			endPos = startPos + m[0].length;
			locator.lineNumber++;
			//console.log('line++:',locator,startPos,endPos)
		}
		locator.columnNumber = start-startPos+1;
	}
	var startPos = 0;
	var endPos = 0;
	var linePattern = /.+(?:\r\n?|\n)|.*$/g
	var locator = domBuilder.locator;
	
	var parseStack = [{currentNSMap:defaultNSMapCopy}]
	var closeMap = {};
	var start = 0;
	while(true){
		var i = source.indexOf('<',start);
		if(i<0){
			if(!source.substr(start).match(/^\s*$/)){
				var doc = domBuilder.document;
    			var text = doc.createTextNode(source.substr(start));
    			doc.appendChild(text);
    			domBuilder.currentElement = text;
			}
			return;
		}
		if(i>start){
			appendText(i);
		}
		switch(source.charAt(i+1)){
		case '/':
			var end = source.indexOf('>',i+3);
			var tagName = source.substring(i+2,end);
			var config = parseStack.pop();
			var localNSMap = config.localNSMap;
			
	        if(config.tagName != tagName){
	            errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName );
	        }
			domBuilder.endElement(config.uri,config.localName,tagName);
			if(localNSMap){
				for(var prefix in localNSMap){
					domBuilder.endPrefixMapping(prefix) ;
				}
			}
			end++;
			break;
			// end elment
		case '?':// <?...?>
			locator&&position(i);
			end = parseInstruction(source,i,domBuilder);
			break;
		case '!':// <!doctype,<![CDATA,<!--
			locator&&position(i);
			end = parseDCC(source,i,domBuilder,errorHandler);
			break;
		default:
			try{
				locator&&position(i);
				
				var el = new ElementAttributes();
				
				//elStartEnd
				var end = parseElementStartPart(source,i,el,entityReplacer,errorHandler);
				var len = el.length;
				//position fixed
				if(len && locator){
					var backup = copyLocator(locator,{});
					for(var i = 0;i<len;i++){
						var a = el[i];
						position(a.offset);
						a.offset = copyLocator(locator,{});
					}
					copyLocator(backup,locator);
				}
				if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){
					el.closed = true;
					if(!entityMap.nbsp){
						errorHandler.warning('unclosed xml attribute');
					}
				}
				appendElement(el,domBuilder,parseStack);
				
				
				if(el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed){
					end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)
				}else{
					end++;
				}
			}catch(e){
				errorHandler.error('element parse error: '+e);
				end = -1;
			}

		}
		if(end<0){
			//TODO: sax
			appendText(i+1);
		}else{
			start = end;
		}
	}
}
function copyLocator(f,t){
	t.lineNumber = f.lineNumber;
	t.columnNumber = f.columnNumber;
	return t;
	
}

/**
 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
 */
function parseElementStartPart(source,start,el,entityReplacer,errorHandler){
	var attrName;
	var value;
	var p = ++start;
	var s = S_TAG;//status
	while(true){
		var c = source.charAt(p);
		switch(c){
		case '=':
			if(s === S_ATTR){//attrName
				attrName = source.slice(start,p);
				s = S_EQ;
			}else if(s === S_ATTR_S){
				s = S_EQ;
			}else{
				//fatalError: equal must after attrName or space after attrName
				throw new Error('attribute equal must after attrName');
			}
			break;
		case '\'':
		case '"':
			if(s === S_EQ){//equal
				start = p+1;
				p = source.indexOf(c,start)
				if(p>0){
					value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					el.add(attrName,value,start-1);
					s = S_E;
				}else{
					//fatalError: no end quot match
					throw new Error('attribute value no end \''+c+'\' match');
				}
			}else if(s == S_V){
				value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
				//console.log(attrName,value,start,p)
				el.add(attrName,value,start);
				//console.dir(el)
				errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');
				start = p+1;
				s = S_E
			}else{
				//fatalError: no equal before
				throw new Error('attribute value must after "="');
			}
			break;
		case '/':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_E:
			case S_S:
			case S_C:
				s = S_C;
				el.closed = true;
			case S_V:
			case S_ATTR:
			case S_ATTR_S:
				break;
			//case S_EQ:
			default:
				throw new Error("attribute invalid close char('/')")
			}
			break;
		case ''://end document
			//throw new Error('unexpected end of input')
			errorHandler.error('unexpected end of input');
		case '>':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_E:
			case S_S:
			case S_C:
				break;//normal
			case S_V://Compatible state
			case S_ATTR:
				value = source.slice(start,p);
				if(value.slice(-1) === '/'){
					el.closed  = true;
					value = value.slice(0,-1)
				}
			case S_ATTR_S:
				if(s === S_ATTR_S){
					value = attrName;
				}
				if(s == S_V){
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					el.add(attrName,value.replace(/&#?\w+;/g,entityReplacer),start)
				}else{
					errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')
					el.add(value,value,start)
				}
				break;
			case S_EQ:
				throw new Error('attribute value missed!!');
			}
//			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
			return p;
		/*xml space '\x20' | #x9 | #xD | #xA; */
		case '\u0080':
			c = ' ';
		default:
			if(c<= ' '){//space
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));//tagName
					s = S_S;
					break;
				case S_ATTR:
					attrName = source.slice(start,p)
					s = S_ATTR_S;
					break;
				case S_V:
					var value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					el.add(attrName,value,start)
				case S_E:
					s = S_S;
					break;
				//case S_S:
				//case S_EQ:
				//case S_ATTR_S:
				//	void();break;
				//case S_C:
					//ignore warning
				}
			}else{//not space
//S_TAG,	S_ATTR,	S_EQ,	S_V
//S_ATTR_S,	S_E,	S_S,	S_C
				switch(s){
				//case S_TAG:void();break;
				//case S_ATTR:void();break;
				//case S_V:void();break;
				case S_ATTR_S:
					errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead!!')
					el.add(attrName,attrName,start);
					start = p;
					s = S_ATTR;
					break;
				case S_E:
					errorHandler.warning('attribute space is required"'+attrName+'"!!')
				case S_S:
					s = S_ATTR;
					start = p;
					break;
				case S_EQ:
					s = S_V;
					start = p;
					break;
				case S_C:
					throw new Error("elements closed character '/' and '>' must be connected to");
				}
			}
		}
		p++;
	}
}
/**
 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
 */
function appendElement(el,domBuilder,parseStack){
	var tagName = el.tagName;
	var localNSMap = null;
	var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
	var i = el.length;
	while(i--){
		var a = el[i];
		var qName = a.qName;
		var value = a.value;
		var nsp = qName.indexOf(':');
		if(nsp>0){
			var prefix = a.prefix = qName.slice(0,nsp);
			var localName = qName.slice(nsp+1);
			var nsPrefix = prefix === 'xmlns' && localName
		}else{
			localName = qName;
			prefix = null
			nsPrefix = qName === 'xmlns' && ''
		}
		//can not set prefix,because prefix !== ''
		a.localName = localName ;
		//prefix == null for no ns prefix attribute 
		if(nsPrefix !== false){//hack!!
			if(localNSMap == null){
				localNSMap = {}
				//console.log(currentNSMap,0)
				_copy(currentNSMap,currentNSMap={})
				//console.log(currentNSMap,1)
			}
			currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
			a.uri = 'http://www.w3.org/2000/xmlns/'
			domBuilder.startPrefixMapping(nsPrefix, value) 
		}
	}
	var i = el.length;
	while(i--){
		a = el[i];
		var prefix = a.prefix;
		if(prefix){//no prefix attribute has no namespace
			if(prefix === 'xml'){
				a.uri = 'http://www.w3.org/XML/1998/namespace';
			}if(prefix !== 'xmlns'){
				a.uri = currentNSMap[prefix]
				
				//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
			}
		}
	}
	var nsp = tagName.indexOf(':');
	if(nsp>0){
		prefix = el.prefix = tagName.slice(0,nsp);
		localName = el.localName = tagName.slice(nsp+1);
	}else{
		prefix = null;//important!!
		localName = el.localName = tagName;
	}
	//no prefix element has default namespace
	var ns = el.uri = currentNSMap[prefix || ''];
	domBuilder.startElement(ns,localName,tagName,el);
	//endPrefixMapping and startPrefixMapping have not any help for dom builder
	//localNSMap = null
	if(el.closed){
		domBuilder.endElement(ns,localName,tagName);
		if(localNSMap){
			for(prefix in localNSMap){
				domBuilder.endPrefixMapping(prefix) 
			}
		}
	}else{
		el.currentNSMap = currentNSMap;
		el.localNSMap = localNSMap;
		parseStack.push(el);
	}
}
function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){
	if(/^(?:script|textarea)$/i.test(tagName)){
		var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);
		var text = source.substring(elStartEnd+1,elEndStart);
		if(/[&<]/.test(text)){
			if(/^script$/i.test(tagName)){
				//if(!/\]\]>/.test(text)){
					//lexHandler.startCDATA();
					domBuilder.characters(text,0,text.length);
					//lexHandler.endCDATA();
					return elEndStart;
				//}
			}//}else{//text area
				text = text.replace(/&#?\w+;/g,entityReplacer);
				domBuilder.characters(text,0,text.length);
				return elEndStart;
			//}
			
		}
	}
	return elStartEnd+1;
}
function fixSelfClosed(source,elStartEnd,tagName,closeMap){
	//if(tagName in closeMap){
	var pos = closeMap[tagName];
	if(pos == null){
		//console.log(tagName)
		pos = closeMap[tagName] = source.lastIndexOf('</'+tagName+'>')
	}
	return pos<elStartEnd;
	//} 
}
function _copy(source,target){
	for(var n in source){target[n] = source[n]}
}
function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'
	var next= source.charAt(start+2)
	switch(next){
	case '-':
		if(source.charAt(start + 3) === '-'){
			var end = source.indexOf('-->',start+4);
			//append comment source.substring(4,end)//<!--
			if(end>start){
				domBuilder.comment(source,start+4,end-start-4);
				return end+3;
			}else{
				errorHandler.error("Unclosed comment");
				return -1;
			}
		}else{
			//error
			return -1;
		}
	default:
		if(source.substr(start+3,6) == 'CDATA['){
			var end = source.indexOf(']]>',start+9);
			domBuilder.startCDATA();
			domBuilder.characters(source,start+9,end-start-9);
			domBuilder.endCDATA() 
			return end+3;
		}
		//<!DOCTYPE
		//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) 
		var matchs = split(source,start);
		var len = matchs.length;
		if(len>1 && /!doctype/i.test(matchs[0][0])){
			var name = matchs[1][0];
			var pubid = len>3 && /^public$/i.test(matchs[2][0]) && matchs[3][0]
			var sysid = len>4 && matchs[4][0];
			var lastMatch = matchs[len-1]
			domBuilder.startDTD(name,pubid && pubid.replace(/^(['"])(.*?)\1$/,'$2'),
					sysid && sysid.replace(/^(['"])(.*?)\1$/,'$2'));
			domBuilder.endDTD();
			
			return lastMatch.index+lastMatch[0].length
		}
	}
	return -1;
}



function parseInstruction(source,start,domBuilder){
	var end = source.indexOf('?>',start);
	if(end){
		var match = source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
		if(match){
			var len = match[0].length;
			domBuilder.processingInstruction(match[1], match[2]) ;
			return end+2;
		}else{//error
			return -1;
		}
	}
	return -1;
}

/**
 * @param source
 */
function ElementAttributes(source){
	
}
ElementAttributes.prototype = {
	setTagName:function(tagName){
		if(!tagNamePattern.test(tagName)){
			throw new Error('invalid tagName:'+tagName)
		}
		this.tagName = tagName
	},
	add:function(qName,value,offset){
		if(!tagNamePattern.test(qName)){
			throw new Error('invalid attribute:'+qName)
		}
		this[this.length++] = {qName:qName,value:value,offset:offset}
	},
	length:0,
	getLocalName:function(i){return this[i].localName},
	getOffset:function(i){return this[i].offset},
	getQName:function(i){return this[i].qName},
	getURI:function(i){return this[i].uri},
	getValue:function(i){return this[i].value}
//	,getIndex:function(uri, localName)){
//		if(localName){
//			
//		}else{
//			var qName = uri
//		}
//	},
//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
//	getType:function(uri,localName){}
//	getType:function(i){},
}




function _set_proto_(thiz,parent){
	thiz.__proto__ = parent;
	return thiz;
}
if(!(_set_proto_({},_set_proto_.prototype) instanceof _set_proto_)){
	_set_proto_ = function(thiz,parent){
		function p(){};
		p.prototype = parent;
		p = new p();
		for(parent in thiz){
			p[parent] = thiz[parent];
		}
		return p;
	}
}

function split(source,start){
	var match;
	var buf = [];
	var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
	reg.lastIndex = start;
	reg.exec(source);//skip <
	while(match = reg.exec(source)){
		buf.push(match);
		if(match[1])return buf;
	}
}

if(typeof require == 'function'){
	exports.XMLReader = XMLReader;
}


},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/node_modules/xpath/xpath.js":[function(require,module,exports){
/*
 * xpath.js
 *
 * An XPath 1.0 library for JavaScript.
 *
 * Cameron McCormack <cam (at) mcc.id.au>
 *
 * This work is licensed under the Creative Commons Attribution-ShareAlike
 * License. To view a copy of this license, visit
 *
 *   http://creativecommons.org/licenses/by-sa/2.0/
 *
 * or send a letter to Creative Commons, 559 Nathan Abbott Way, Stanford,
 * California 94305, USA.
 *
 * Revision 20: April 26, 2011
 *   Fixed a typo resulting in FIRST_ORDERED_NODE_TYPE results being wrong,
 *   thanks to <shi_a009 (at) hotmail.com>.
 *
 * Revision 19: November 29, 2005
 *   Nodesets now store their nodes in a height balanced tree, increasing
 *   performance for the common case of selecting nodes in document order,
 *   thanks to Sastien Cramatte <contact (at) zeninteractif.com>.
 *   AVL tree code adapted from Raimund Neumann <rnova (at) gmx.net>.
 *
 * Revision 18: October 27, 2005
 *   DOM 3 XPath support.  Caveats:
 *     - namespace prefixes aren't resolved in XPathEvaluator.createExpression,
 *       but in XPathExpression.evaluate.
 *     - XPathResult.invalidIteratorState is not implemented.
 *
 * Revision 17: October 25, 2005
 *   Some core XPath function fixes and a patch to avoid crashing certain
 *   versions of MSXML in PathExpr.prototype.getOwnerElement, thanks to
 *   Sastien Cramatte <contact (at) zeninteractif.com>.
 *
 * Revision 16: September 22, 2005
 *   Workarounds for some IE 5.5 deficiencies.
 *   Fixed problem with prefix node tests on attribute nodes.
 *
 * Revision 15: May 21, 2005
 *   Fixed problem with QName node tests on elements with an xmlns="...".
 *
 * Revision 14: May 19, 2005
 *   Fixed QName node tests on attribute node regression.
 *
 * Revision 13: May 3, 2005
 *   Node tests are case insensitive now if working in an HTML DOM.
 *
 * Revision 12: April 26, 2005
 *   Updated licence.  Slight code changes to enable use of Dean
 *   Edwards' script compression, http://dean.edwards.name/packer/ .
 *
 * Revision 11: April 23, 2005
 *   Fixed bug with 'and' and 'or' operators, fix thanks to
 *   Sandy McArthur <sandy (at) mcarthur.org>.
 *
 * Revision 10: April 15, 2005
 *   Added support for a virtual root node, supposedly helpful for
 *   implementing XForms.  Fixed problem with QName node tests and
 *   the parent axis.
 *
 * Revision 9: March 17, 2005
 *   Namespace resolver tweaked so using the document node as the context
 *   for namespace lookups is equivalent to using the document element.
 *
 * Revision 8: February 13, 2005
 *   Handle implicit declaration of 'xmlns' namespace prefix.
 *   Fixed bug when comparing nodesets.
 *   Instance data can now be associated with a FunctionResolver, and
 *     workaround for MSXML not supporting 'localName' and 'getElementById',
 *     thanks to Grant Gongaware.
 *   Fix a few problems when the context node is the root node.
 *
 * Revision 7: February 11, 2005
 *   Default namespace resolver fix from Grant Gongaware
 *   <grant (at) gongaware.com>.
 *
 * Revision 6: February 10, 2005
 *   Fixed bug in 'number' function.
 *
 * Revision 5: February 9, 2005
 *   Fixed bug where text nodes not getting converted to string values.
 *
 * Revision 4: January 21, 2005
 *   Bug in 'name' function, fix thanks to Bill Edney.
 *   Fixed incorrect processing of namespace nodes.
 *   Fixed NamespaceResolver to resolve 'xml' namespace.
 *   Implemented union '|' operator.
 *
 * Revision 3: January 14, 2005
 *   Fixed bug with nodeset comparisons, bug lexing < and >.
 *
 * Revision 2: October 26, 2004
 *   QName node test namespace handling fixed.  Few other bug fixes.
 *
 * Revision 1: August 13, 2004
 *   Bug fixes from William J. Edney <bedney (at) technicalpursuit.com>.
 *   Added minimal licence.
 *
 * Initial version: June 14, 2004
 */

// non-node wrapper
if(typeof exports === 'undefined' ) {
	xpath = {};
}
(function(exports) {
	
// XPathParser ///////////////////////////////////////////////////////////////

XPathParser.prototype = new Object();
XPathParser.prototype.constructor = XPathParser;
XPathParser.superclass = Object.prototype;

function XPathParser() {
	this.init();
}

XPathParser.prototype.init = function() {
	this.reduceActions = [];

	this.reduceActions[3] = function(rhs) {
		return new OrOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[5] = function(rhs) {
		return new AndOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[7] = function(rhs) {
		return new EqualsOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[8] = function(rhs) {
		return new NotEqualOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[10] = function(rhs) {
		return new LessThanOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[11] = function(rhs) {
		return new GreaterThanOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[12] = function(rhs) {
		return new LessThanOrEqualOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[13] = function(rhs) {
		return new GreaterThanOrEqualOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[15] = function(rhs) {
		return new PlusOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[16] = function(rhs) {
		return new MinusOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[18] = function(rhs) {
		return new MultiplyOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[19] = function(rhs) {
		return new DivOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[20] = function(rhs) {
		return new ModOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[22] = function(rhs) {
		return new UnaryMinusOperation(rhs[1]);
	};
	this.reduceActions[24] = function(rhs) {
		return new BarOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[25] = function(rhs) {
		return new PathExpr(undefined, undefined, rhs[0]);
	};
	this.reduceActions[27] = function(rhs) {
		rhs[0].locationPath = rhs[2];
		return rhs[0];
	};
	this.reduceActions[28] = function(rhs) {
		rhs[0].locationPath = rhs[2];
		rhs[0].locationPath.steps.unshift(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));
		return rhs[0];
	};
	this.reduceActions[29] = function(rhs) {
		return new PathExpr(rhs[0], [], undefined);
	};
	this.reduceActions[30] = function(rhs) {
		if (Utilities.instance_of(rhs[0], PathExpr)) {
			if (rhs[0].filterPredicates == undefined) {
				rhs[0].filterPredicates = [];
			}
			rhs[0].filterPredicates.push(rhs[1]);
			return rhs[0];
		} else {
			return new PathExpr(rhs[0], [rhs[1]], undefined);
		}
	};
	this.reduceActions[32] = function(rhs) {
		return rhs[1];
	};
	this.reduceActions[33] = function(rhs) {
		return new XString(rhs[0]);
	};
	this.reduceActions[34] = function(rhs) {
		return new XNumber(rhs[0]);
	};
	this.reduceActions[36] = function(rhs) {
		return new FunctionCall(rhs[0], []);
	};
	this.reduceActions[37] = function(rhs) {
		return new FunctionCall(rhs[0], rhs[2]);
	};
	this.reduceActions[38] = function(rhs) {
		return [ rhs[0] ];
	};
	this.reduceActions[39] = function(rhs) {
		rhs[2].unshift(rhs[0]);
		return rhs[2];
	};
	this.reduceActions[43] = function(rhs) {
		return new LocationPath(true, []);
	};
	this.reduceActions[44] = function(rhs) {
		rhs[1].absolute = true;
		return rhs[1];
	};
	this.reduceActions[46] = function(rhs) {
		return new LocationPath(false, [ rhs[0] ]);
	};
	this.reduceActions[47] = function(rhs) {
		rhs[0].steps.push(rhs[2]);
		return rhs[0];
	};
	this.reduceActions[49] = function(rhs) {
		return new Step(rhs[0], rhs[1], []);
	};
	this.reduceActions[50] = function(rhs) {
		return new Step(Step.CHILD, rhs[0], []);
	};
	this.reduceActions[51] = function(rhs) {
		return new Step(rhs[0], rhs[1], rhs[2]);
	};
	this.reduceActions[52] = function(rhs) {
		return new Step(Step.CHILD, rhs[0], rhs[1]);
	};
	this.reduceActions[54] = function(rhs) {
		return [ rhs[0] ];
	};
	this.reduceActions[55] = function(rhs) {
		rhs[1].unshift(rhs[0]);
		return rhs[1];
	};
	this.reduceActions[56] = function(rhs) {
		if (rhs[0] == "ancestor") {
			return Step.ANCESTOR;
		} else if (rhs[0] == "ancestor-or-self") {
			return Step.ANCESTORORSELF;
		} else if (rhs[0] == "attribute") {
			return Step.ATTRIBUTE;
		} else if (rhs[0] == "child") {
			return Step.CHILD;
		} else if (rhs[0] == "descendant") {
			return Step.DESCENDANT;
		} else if (rhs[0] == "descendant-or-self") {
			return Step.DESCENDANTORSELF;
		} else if (rhs[0] == "following") {
			return Step.FOLLOWING;
		} else if (rhs[0] == "following-sibling") {
			return Step.FOLLOWINGSIBLING;
		} else if (rhs[0] == "namespace") {
			return Step.NAMESPACE;
		} else if (rhs[0] == "parent") {
			return Step.PARENT;
		} else if (rhs[0] == "preceding") {
			return Step.PRECEDING;
		} else if (rhs[0] == "preceding-sibling") {
			return Step.PRECEDINGSIBLING;
		} else if (rhs[0] == "self") {
			return Step.SELF;
		}
		return -1;
	};
	this.reduceActions[57] = function(rhs) {
		return Step.ATTRIBUTE;
	};
	this.reduceActions[59] = function(rhs) {
		if (rhs[0] == "comment") {
			return new NodeTest(NodeTest.COMMENT, undefined);
		} else if (rhs[0] == "text") {
			return new NodeTest(NodeTest.TEXT, undefined);
		} else if (rhs[0] == "processing-instruction") {
			return new NodeTest(NodeTest.PI, undefined);
		} else if (rhs[0] == "node") {
			return new NodeTest(NodeTest.NODE, undefined);
		}
		return new NodeTest(-1, undefined);
	};
	this.reduceActions[60] = function(rhs) {
		return new NodeTest(NodeTest.PI, rhs[2]);
	};
	this.reduceActions[61] = function(rhs) {
		return rhs[1];
	};
	this.reduceActions[63] = function(rhs) {
		rhs[1].absolute = true;
		rhs[1].steps.unshift(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));
		return rhs[1];
	};
	this.reduceActions[64] = function(rhs) {
		rhs[0].steps.push(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));
		rhs[0].steps.push(rhs[2]);
		return rhs[0];
	};
	this.reduceActions[65] = function(rhs) {
		return new Step(Step.SELF, new NodeTest(NodeTest.NODE, undefined), []);
	};
	this.reduceActions[66] = function(rhs) {
		return new Step(Step.PARENT, new NodeTest(NodeTest.NODE, undefined), []);
	};
	this.reduceActions[67] = function(rhs) {
		return new VariableReference(rhs[1]);
	};
	this.reduceActions[68] = function(rhs) {
		return new NodeTest(NodeTest.NAMETESTANY, undefined);
	};
	this.reduceActions[69] = function(rhs) {
		var prefix = rhs[0].substring(0, rhs[0].indexOf(":"));
		return new NodeTest(NodeTest.NAMETESTPREFIXANY, prefix);
	};
	this.reduceActions[70] = function(rhs) {
		return new NodeTest(NodeTest.NAMETESTQNAME, rhs[0]);
	};
};

XPathParser.actionTable = [
	" s s        sssssssss    s ss  s  ss",
	"                 s                  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"                rrrrr               ",
	" s s        sssssssss    s ss  s  ss",
	"rs  rrrrrrrr s  sssssrrrrrr  rrs rs ",
	" s s        sssssssss    s ss  s  ss",
	"                            s       ",
	"                            s       ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"  s                                 ",
	"                            s       ",
	" s           s  sssss          s  s ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"a                                   ",
	"r       s                    rr  r  ",
	"r      sr                    rr  r  ",
	"r   s  rr            s       rr  r  ",
	"r   rssrr            rss     rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrrsss         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrrs  rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r  srrrrrrrr         rrrrrrs rr sr  ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"                sssss               ",
	"r  rrrrrrrrr         rrrrrrr rr sr  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             s      ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"              s                     ",
	"                             s      ",
	"                rrrrr               ",
	" s s        sssssssss    s sss s  ss",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss      ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s           s  sssss          s  s ",
	" s           s  sssss          s  s ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	" s           s  sssss          s  s ",
	" s           s  sssss          s  s ",
	"r  rrrrrrrrr         rrrrrrr rr sr  ",
	"r  rrrrrrrrr         rrrrrrr rr sr  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             s      ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             rr     ",
	"                             s      ",
	"                             rs     ",
	"r      sr                    rr  r  ",
	"r   s  rr            s       rr  r  ",
	"r   rssrr            rss     rr  r  ",
	"r   rssrr            rss     rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrrsss         rrrrr   rr  r  ",
	"r   rrrrrsss         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"                                 r  ",
	"                                 s  ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	" s s        sssssssss    s ss  s  ss",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             r      "
];

XPathParser.actionTableNumber = [
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"                 J                  ",
	"a  aaaaaaaaa         aaaaaaa aa  a  ",
	"                YYYYY               ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"K1  KKKKKKKK .  +*)('KKKKKK  KK# K\" ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"                            N       ",
	"                            O       ",
	"e  eeeeeeeee         eeeeeee ee ee  ",
	"f  fffffffff         fffffff ff ff  ",
	"d  ddddddddd         ddddddd dd dd  ",
	"B  BBBBBBBBB         BBBBBBB BB BB  ",
	"A  AAAAAAAAA         AAAAAAA AA AA  ",
	"  P                                 ",
	"                            Q       ",
	" 1           .  +*)('          #  \" ",
	"b  bbbbbbbbb         bbbbbbb bb  b  ",
	"                                    ",
	"!       S                    !!  !  ",
	"\"      T\"                    \"\"  \"  ",
	"$   V  $$            U       $$  $  ",
	"&   &ZY&&            &XW     &&  &  ",
	")   )))))            )))\\[   ))  )  ",
	".   ....._^]         .....   ..  .  ",
	"1   11111111         11111   11  1  ",
	"5   55555555         55555`  55  5  ",
	"7   77777777         777777  77  7  ",
	"9   99999999         999999  99  9  ",
	":  c::::::::         ::::::b :: a:  ",
	"I  fIIIIIIII         IIIIIIe II  I  ",
	"=  =========         ======= == ==  ",
	"?  ?????????         ??????? ?? ??  ",
	"C  CCCCCCCCC         CCCCCCC CC CC  ",
	"J   JJJJJJJJ         JJJJJJ  JJ  J  ",
	"M   MMMMMMMM         MMMMMM  MM  M  ",
	"N  NNNNNNNNN         NNNNNNN NN  N  ",
	"P  PPPPPPPPP         PPPPPPP PP  P  ",
	"                +*)('               ",
	"R  RRRRRRRRR         RRRRRRR RR aR  ",
	"U  UUUUUUUUU         UUUUUUU UU  U  ",
	"Z  ZZZZZZZZZ         ZZZZZZZ ZZ ZZ  ",
	"c  ccccccccc         ccccccc cc cc  ",
	"                             j      ",
	"L  fLLLLLLLL         LLLLLLe LL  L  ",
	"6   66666666         66666   66  6  ",
	"              k                     ",
	"                             l      ",
	"                XXXXX               ",
	" 1 0        /.-,+*)('    & %$m #  \"!",
	"_  f________         ______e __  _  ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('      %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1           .  +*)('          #  \" ",
	" 1           .  +*)('          #  \" ",
	">  >>>>>>>>>         >>>>>>> >> >>  ",
	" 1           .  +*)('          #  \" ",
	" 1           .  +*)('          #  \" ",
	"Q  QQQQQQQQQ         QQQQQQQ QQ aQ  ",
	"V  VVVVVVVVV         VVVVVVV VV aV  ",
	"T  TTTTTTTTT         TTTTTTT TT  T  ",
	"@  @@@@@@@@@         @@@@@@@ @@ @@  ",
	"                             \x87      ",
	"[  [[[[[[[[[         [[[[[[[ [[ [[  ",
	"D  DDDDDDDDD         DDDDDDD DD DD  ",
	"                             HH     ",
	"                             \x88      ",
	"                             F\x89     ",
	"#      T#                    ##  #  ",
	"%   V  %%            U       %%  %  ",
	"'   'ZY''            'XW     ''  '  ",
	"(   (ZY((            (XW     ((  (  ",
	"+   +++++            +++\\[   ++  +  ",
	"*   *****            ***\\[   **  *  ",
	"-   -----            ---\\[   --  -  ",
	",   ,,,,,            ,,,\\[   ,,  ,  ",
	"0   00000_^]         00000   00  0  ",
	"/   /////_^]         /////   //  /  ",
	"2   22222222         22222   22  2  ",
	"3   33333333         33333   33  3  ",
	"4   44444444         44444   44  4  ",
	"8   88888888         888888  88  8  ",
	"                                 ^  ",
	"                                 \x8a  ",
	";  f;;;;;;;;         ;;;;;;e ;;  ;  ",
	"<  f<<<<<<<<         <<<<<<e <<  <  ",
	"O  OOOOOOOOO         OOOOOOO OO  O  ",
	"`  `````````         ``````` ``  `  ",
	"S  SSSSSSSSS         SSSSSSS SS  S  ",
	"W  WWWWWWWWW         WWWWWWW WW  W  ",
	"\\  \\\\\\\\\\\\\\\\\\         \\\\\\\\\\\\\\ \\\\ \\\\  ",
	"E  EEEEEEEEE         EEEEEEE EE EE  ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"]  ]]]]]]]]]         ]]]]]]] ]] ]]  ",
	"                             G      "
];

XPathParser.gotoTable = [
	"3456789:;<=>?@ AB  CDEFGH IJ ",
	"                             ",
	"                             ",
	"                             ",
	"L456789:;<=>?@ AB  CDEFGH IJ ",
	"            M        EFGH IJ ",
	"       N;<=>?@ AB  CDEFGH IJ ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"            S        EFGH IJ ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"              e              ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                        h  J ",
	"              i          j   ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"o456789:;<=>?@ ABpqCDEFGH IJ ",
	"                             ",
	"  r6789:;<=>?@ AB  CDEFGH IJ ",
	"   s789:;<=>?@ AB  CDEFGH IJ ",
	"    t89:;<=>?@ AB  CDEFGH IJ ",
	"    u89:;<=>?@ AB  CDEFGH IJ ",
	"     v9:;<=>?@ AB  CDEFGH IJ ",
	"     w9:;<=>?@ AB  CDEFGH IJ ",
	"     x9:;<=>?@ AB  CDEFGH IJ ",
	"     y9:;<=>?@ AB  CDEFGH IJ ",
	"      z:;<=>?@ AB  CDEFGH IJ ",
	"      {:;<=>?@ AB  CDEFGH IJ ",
	"       |;<=>?@ AB  CDEFGH IJ ",
	"       };<=>?@ AB  CDEFGH IJ ",
	"       ~;<=>?@ AB  CDEFGH IJ ",
	"         \x7f=>?@ AB  CDEFGH IJ ",
	"\x80456789:;<=>?@ AB  CDEFGH IJ\x81",
	"            \x82        EFGH IJ ",
	"            \x83        EFGH IJ ",
	"                             ",
	"                     \x84 GH IJ ",
	"                     \x85 GH IJ ",
	"              i          \x86   ",
	"              i          \x87   ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"o456789:;<=>?@ AB\x8cqCDEFGH IJ ",
	"                             ",
	"                             "
];

XPathParser.productions = [
	[1, 1, 2],
	[2, 1, 3],
	[3, 1, 4],
	[3, 3, 3, -9, 4],
	[4, 1, 5],
	[4, 3, 4, -8, 5],
	[5, 1, 6],
	[5, 3, 5, -22, 6],
	[5, 3, 5, -5, 6],
	[6, 1, 7],
	[6, 3, 6, -23, 7],
	[6, 3, 6, -24, 7],
	[6, 3, 6, -6, 7],
	[6, 3, 6, -7, 7],
	[7, 1, 8],
	[7, 3, 7, -25, 8],
	[7, 3, 7, -26, 8],
	[8, 1, 9],
	[8, 3, 8, -12, 9],
	[8, 3, 8, -11, 9],
	[8, 3, 8, -10, 9],
	[9, 1, 10],
	[9, 2, -26, 9],
	[10, 1, 11],
	[10, 3, 10, -27, 11],
	[11, 1, 12],
	[11, 1, 13],
	[11, 3, 13, -28, 14],
	[11, 3, 13, -4, 14],
	[13, 1, 15],
	[13, 2, 13, 16],
	[15, 1, 17],
	[15, 3, -29, 2, -30],
	[15, 1, -15],
	[15, 1, -16],
	[15, 1, 18],
	[18, 3, -13, -29, -30],
	[18, 4, -13, -29, 19, -30],
	[19, 1, 20],
	[19, 3, 20, -31, 19],
	[20, 1, 2],
	[12, 1, 14],
	[12, 1, 21],
	[21, 1, -28],
	[21, 2, -28, 14],
	[21, 1, 22],
	[14, 1, 23],
	[14, 3, 14, -28, 23],
	[14, 1, 24],
	[23, 2, 25, 26],
	[23, 1, 26],
	[23, 3, 25, 26, 27],
	[23, 2, 26, 27],
	[23, 1, 28],
	[27, 1, 16],
	[27, 2, 16, 27],
	[25, 2, -14, -3],
	[25, 1, -32],
	[26, 1, 29],
	[26, 3, -20, -29, -30],
	[26, 4, -21, -29, -15, -30],
	[16, 3, -33, 30, -34],
	[30, 1, 2],
	[22, 2, -4, 14],
	[24, 3, 14, -4, 23],
	[28, 1, -35],
	[28, 1, -2],
	[17, 2, -36, -18],
	[29, 1, -17],
	[29, 1, -19],
	[29, 1, -18]
];

XPathParser.DOUBLEDOT = 2;
XPathParser.DOUBLECOLON = 3;
XPathParser.DOUBLESLASH = 4;
XPathParser.NOTEQUAL = 5;
XPathParser.LESSTHANOREQUAL = 6;
XPathParser.GREATERTHANOREQUAL = 7;
XPathParser.AND = 8;
XPathParser.OR = 9;
XPathParser.MOD = 10;
XPathParser.DIV = 11;
XPathParser.MULTIPLYOPERATOR = 12;
XPathParser.FUNCTIONNAME = 13;
XPathParser.AXISNAME = 14;
XPathParser.LITERAL = 15;
XPathParser.NUMBER = 16;
XPathParser.ASTERISKNAMETEST = 17;
XPathParser.QNAME = 18;
XPathParser.NCNAMECOLONASTERISK = 19;
XPathParser.NODETYPE = 20;
XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL = 21;
XPathParser.EQUALS = 22;
XPathParser.LESSTHAN = 23;
XPathParser.GREATERTHAN = 24;
XPathParser.PLUS = 25;
XPathParser.MINUS = 26;
XPathParser.BAR = 27;
XPathParser.SLASH = 28;
XPathParser.LEFTPARENTHESIS = 29;
XPathParser.RIGHTPARENTHESIS = 30;
XPathParser.COMMA = 31;
XPathParser.AT = 32;
XPathParser.LEFTBRACKET = 33;
XPathParser.RIGHTBRACKET = 34;
XPathParser.DOT = 35;
XPathParser.DOLLAR = 36;

XPathParser.prototype.tokenize = function(s1) {
	var types = [];
	var values = [];
	var s = s1 + '\0';

	var pos = 0;
	var c = s.charAt(pos++);
	while (1) {
		while (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
			c = s.charAt(pos++);
		}
		if (c == '\0' || pos >= s.length) {
			break;
		}

		if (c == '(') {
			types.push(XPathParser.LEFTPARENTHESIS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == ')') {
			types.push(XPathParser.RIGHTPARENTHESIS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '[') {
			types.push(XPathParser.LEFTBRACKET);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == ']') {
			types.push(XPathParser.RIGHTBRACKET);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '@') {
			types.push(XPathParser.AT);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == ',') {
			types.push(XPathParser.COMMA);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '|') {
			types.push(XPathParser.BAR);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '+') {
			types.push(XPathParser.PLUS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '-') {
			types.push(XPathParser.MINUS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '=') {
			types.push(XPathParser.EQUALS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '$') {
			types.push(XPathParser.DOLLAR);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}

		if (c == '.') {
			c = s.charAt(pos++);
			if (c == '.') {
				types.push(XPathParser.DOUBLEDOT);
				values.push("..");
				c = s.charAt(pos++);
				continue;
			}
			if (c >= '0' && c <= '9') {
				var number = "." + c;
				c = s.charAt(pos++);
				while (c >= '0' && c <= '9') {
					number += c;
					c = s.charAt(pos++);
				}
				types.push(XPathParser.NUMBER);
				values.push(number);
				continue;
			}
			types.push(XPathParser.DOT);
			values.push('.');
			continue;
		}

		if (c == '\'' || c == '"') {
			var delimiter = c;
			var literal = "";
			while ((c = s.charAt(pos++)) != delimiter) {
				literal += c;
			}
			types.push(XPathParser.LITERAL);
			values.push(literal);
			c = s.charAt(pos++);
			continue;
		}

		if (c >= '0' && c <= '9') {
			var number = c;
			c = s.charAt(pos++);
			while (c >= '0' && c <= '9') {
				number += c;
				c = s.charAt(pos++);
			}
			if (c == '.') {
				if (s.charAt(pos) >= '0' && s.charAt(pos) <= '9') {
					number += c;
					number += s.charAt(pos++);
					c = s.charAt(pos++);
					while (c >= '0' && c <= '9') {
						number += c;
						c = s.charAt(pos++);
					}
				}
			}
			types.push(XPathParser.NUMBER);
			values.push(number);
			continue;
		}

		if (c == '*') {
			if (types.length > 0) {
				var last = types[types.length - 1];
				if (last != XPathParser.AT
						&& last != XPathParser.DOUBLECOLON
						&& last != XPathParser.LEFTPARENTHESIS
						&& last != XPathParser.LEFTBRACKET
						&& last != XPathParser.AND
						&& last != XPathParser.OR
						&& last != XPathParser.MOD
						&& last != XPathParser.DIV
						&& last != XPathParser.MULTIPLYOPERATOR
						&& last != XPathParser.SLASH
						&& last != XPathParser.DOUBLESLASH
						&& last != XPathParser.BAR
						&& last != XPathParser.PLUS
						&& last != XPathParser.MINUS
						&& last != XPathParser.EQUALS
						&& last != XPathParser.NOTEQUAL
						&& last != XPathParser.LESSTHAN
						&& last != XPathParser.LESSTHANOREQUAL
						&& last != XPathParser.GREATERTHAN
						&& last != XPathParser.GREATERTHANOREQUAL) {
					types.push(XPathParser.MULTIPLYOPERATOR);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
			}
			types.push(XPathParser.ASTERISKNAMETEST);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}

		if (c == ':') {
			if (s.charAt(pos) == ':') {
				types.push(XPathParser.DOUBLECOLON);
				values.push("::");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
		}

		if (c == '/') {
			c = s.charAt(pos++);
			if (c == '/') {
				types.push(XPathParser.DOUBLESLASH);
				values.push("//");
				c = s.charAt(pos++);
				continue;
			}
			types.push(XPathParser.SLASH);
			values.push('/');
			continue;
		}

		if (c == '!') {
			if (s.charAt(pos) == '=') {
				types.push(XPathParser.NOTEQUAL);
				values.push("!=");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
		}

		if (c == '<') {
			if (s.charAt(pos) == '=') {
				types.push(XPathParser.LESSTHANOREQUAL);
				values.push("<=");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
			types.push(XPathParser.LESSTHAN);
			values.push('<');
			c = s.charAt(pos++);
			continue;
		}

		if (c == '>') {
			if (s.charAt(pos) == '=') {
				types.push(XPathParser.GREATERTHANOREQUAL);
				values.push(">=");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
			types.push(XPathParser.GREATERTHAN);
			values.push('>');
			c = s.charAt(pos++);
			continue;
		}

		if (c == '_' || Utilities.isLetter(c.charCodeAt(0))) {
			var name = c;
			c = s.charAt(pos++);
			while (Utilities.isNCNameChar(c.charCodeAt(0))) {
				name += c;
				c = s.charAt(pos++);
			}
			if (types.length > 0) {
				var last = types[types.length - 1];
				if (last != XPathParser.AT
						&& last != XPathParser.DOUBLECOLON
						&& last != XPathParser.LEFTPARENTHESIS
						&& last != XPathParser.LEFTBRACKET
						&& last != XPathParser.AND
						&& last != XPathParser.OR
						&& last != XPathParser.MOD
						&& last != XPathParser.DIV
						&& last != XPathParser.MULTIPLYOPERATOR
						&& last != XPathParser.SLASH
						&& last != XPathParser.DOUBLESLASH
						&& last != XPathParser.BAR
						&& last != XPathParser.PLUS
						&& last != XPathParser.MINUS
						&& last != XPathParser.EQUALS
						&& last != XPathParser.NOTEQUAL
						&& last != XPathParser.LESSTHAN
						&& last != XPathParser.LESSTHANOREQUAL
						&& last != XPathParser.GREATERTHAN
						&& last != XPathParser.GREATERTHANOREQUAL) {
					if (name == "and") {
						types.push(XPathParser.AND);
						values.push(name);
						continue;
					}
					if (name == "or") {
						types.push(XPathParser.OR);
						values.push(name);
						continue;
					}
					if (name == "mod") {
						types.push(XPathParser.MOD);
						values.push(name);
						continue;
					}
					if (name == "div") {
						types.push(XPathParser.DIV);
						values.push(name);
						continue;
					}
				}
			}
			if (c == ':') {
				if (s.charAt(pos) == '*') {
					types.push(XPathParser.NCNAMECOLONASTERISK);
					values.push(name + ":*");
					pos++;
					c = s.charAt(pos++);
					continue;
				}
				if (s.charAt(pos) == '_' || Utilities.isLetter(s.charCodeAt(pos))) {
					name += ':';
					c = s.charAt(pos++);
					while (Utilities.isNCNameChar(c.charCodeAt(0))) {
						name += c;
						c = s.charAt(pos++);
					}
					if (c == '(') {
						types.push(XPathParser.FUNCTIONNAME);
						values.push(name);
						continue;
					}
					types.push(XPathParser.QNAME);
					values.push(name);
					continue;
				}
				if (s.charAt(pos) == ':') {
					types.push(XPathParser.AXISNAME);
					values.push(name);
					continue;
				}
			}
			if (c == '(') {
				if (name == "comment" || name == "text" || name == "node") {
					types.push(XPathParser.NODETYPE);
					values.push(name);
					continue;
				}
				if (name == "processing-instruction") {
					if (s.charAt(pos) == ')') {
						types.push(XPathParser.NODETYPE);
					} else {
						types.push(XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL);
					}
					values.push(name);
					continue;
				}
				types.push(XPathParser.FUNCTIONNAME);
				values.push(name);
				continue;
			}
			types.push(XPathParser.QNAME);
			values.push(name);
			continue;
		}

		throw new Error("Unexpected character " + c);
	}
	types.push(1);
	values.push("[EOF]");
	return [types, values];
};

XPathParser.SHIFT = 's';
XPathParser.REDUCE = 'r';
XPathParser.ACCEPT = 'a';

XPathParser.prototype.parse = function(s) {
	var types;
	var values;
	var res = this.tokenize(s);
	if (res == undefined) {
		return undefined;
	}
	types = res[0];
	values = res[1];
	var tokenPos = 0;
	var state = [];
	var tokenType = [];
	var tokenValue = [];
	var s;
	var a;
	var t;

	state.push(0);
	tokenType.push(1);
	tokenValue.push("_S");

	a = types[tokenPos];
	t = values[tokenPos++];
	while (1) {
		s = state[state.length - 1];
		switch (XPathParser.actionTable[s].charAt(a - 1)) {
			case XPathParser.SHIFT:
				tokenType.push(-a);
				tokenValue.push(t);
				state.push(XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32);
				a = types[tokenPos];
				t = values[tokenPos++];
				break;
			case XPathParser.REDUCE:
				var num = XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][1];
				var rhs = [];
				for (var i = 0; i < num; i++) {
					tokenType.pop();
					rhs.unshift(tokenValue.pop());
					state.pop();
				}
				var s_ = state[state.length - 1];
				tokenType.push(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0]);
				if (this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32] == undefined) {
					tokenValue.push(rhs[0]);
				} else {
					tokenValue.push(this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32](rhs));
				}
				state.push(XPathParser.gotoTable[s_].charCodeAt(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0] - 2) - 33);
				break;
			case XPathParser.ACCEPT:
				return new XPath(tokenValue.pop());
			default:
				throw new Error("XPath parse error");
		}
	}
};

// XPath /////////////////////////////////////////////////////////////////////

XPath.prototype = new Object();
XPath.prototype.constructor = XPath;
XPath.superclass = Object.prototype;

function XPath(e) {
	this.expression = e;
}

XPath.prototype.toString = function() {
	return this.expression.toString();
};

XPath.prototype.evaluate = function(c) {
	c.contextNode = c.expressionContextNode;
	c.contextSize = 1;
	c.contextPosition = 1;
	c.caseInsensitive = false;
	if (c.contextNode != null) {
		var doc = c.contextNode;
		if (doc.nodeType != 9 /*Node.DOCUMENT_NODE*/) {
			doc = doc.ownerDocument;
		}
		try {
			c.caseInsensitive = doc.implementation.hasFeature("HTML", "2.0");
		} catch (e) {
			c.caseInsensitive = true;
		}
	}
	return this.expression.evaluate(c);
};

XPath.XML_NAMESPACE_URI = "http://www.w3.org/XML/1998/namespace";
XPath.XMLNS_NAMESPACE_URI = "http://www.w3.org/2000/xmlns/";

// Expression ////////////////////////////////////////////////////////////////

Expression.prototype = new Object();
Expression.prototype.constructor = Expression;
Expression.superclass = Object.prototype;

function Expression() {
}

Expression.prototype.init = function() {
};

Expression.prototype.toString = function() {
	return "<Expression>";
};

Expression.prototype.evaluate = function(c) {
	throw new Error("Could not evaluate expression.");
};

// UnaryOperation ////////////////////////////////////////////////////////////

UnaryOperation.prototype = new Expression();
UnaryOperation.prototype.constructor = UnaryOperation;
UnaryOperation.superclass = Expression.prototype;

function UnaryOperation(rhs) {
	if (arguments.length > 0) {
		this.init(rhs);
	}
}

UnaryOperation.prototype.init = function(rhs) {
	this.rhs = rhs;
};

// UnaryMinusOperation ///////////////////////////////////////////////////////

UnaryMinusOperation.prototype = new UnaryOperation();
UnaryMinusOperation.prototype.constructor = UnaryMinusOperation;
UnaryMinusOperation.superclass = UnaryOperation.prototype;

function UnaryMinusOperation(rhs) {
	if (arguments.length > 0) {
		this.init(rhs);
	}
}

UnaryMinusOperation.prototype.init = function(rhs) {
	UnaryMinusOperation.superclass.init.call(this, rhs);
};

UnaryMinusOperation.prototype.evaluate = function(c) {
	return this.rhs.evaluate(c).number().negate();
};

UnaryMinusOperation.prototype.toString = function() {
	return "-" + this.rhs.toString();
};

// BinaryOperation ///////////////////////////////////////////////////////////

BinaryOperation.prototype = new Expression();
BinaryOperation.prototype.constructor = BinaryOperation;
BinaryOperation.superclass = Expression.prototype;

function BinaryOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

BinaryOperation.prototype.init = function(lhs, rhs) {
	this.lhs = lhs;
	this.rhs = rhs;
};

// OrOperation ///////////////////////////////////////////////////////////////

OrOperation.prototype = new BinaryOperation();
OrOperation.prototype.constructor = OrOperation;
OrOperation.superclass = BinaryOperation.prototype;

function OrOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

OrOperation.prototype.init = function(lhs, rhs) {
	OrOperation.superclass.init.call(this, lhs, rhs);
};

OrOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " or " + this.rhs.toString() + ")";
};

OrOperation.prototype.evaluate = function(c) {
	var b = this.lhs.evaluate(c).bool();
	if (b.booleanValue()) {
		return b;
	}
	return this.rhs.evaluate(c).bool();
};

// AndOperation //////////////////////////////////////////////////////////////

AndOperation.prototype = new BinaryOperation();
AndOperation.prototype.constructor = AndOperation;
AndOperation.superclass = BinaryOperation.prototype;

function AndOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

AndOperation.prototype.init = function(lhs, rhs) {
	AndOperation.superclass.init.call(this, lhs, rhs);
};

AndOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " and " + this.rhs.toString() + ")";
};

AndOperation.prototype.evaluate = function(c) {
	var b = this.lhs.evaluate(c).bool();
	if (!b.booleanValue()) {
		return b;
	}
	return this.rhs.evaluate(c).bool();
};

// EqualsOperation ///////////////////////////////////////////////////////////

EqualsOperation.prototype = new BinaryOperation();
EqualsOperation.prototype.constructor = EqualsOperation;
EqualsOperation.superclass = BinaryOperation.prototype;

function EqualsOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

EqualsOperation.prototype.init = function(lhs, rhs) {
	EqualsOperation.superclass.init.call(this, lhs, rhs);
};

EqualsOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " = " + this.rhs.toString() + ")";
};

EqualsOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).equals(this.rhs.evaluate(c));
};

// NotEqualOperation /////////////////////////////////////////////////////////

NotEqualOperation.prototype = new BinaryOperation();
NotEqualOperation.prototype.constructor = NotEqualOperation;
NotEqualOperation.superclass = BinaryOperation.prototype;

function NotEqualOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

NotEqualOperation.prototype.init = function(lhs, rhs) {
	NotEqualOperation.superclass.init.call(this, lhs, rhs);
};

NotEqualOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " != " + this.rhs.toString() + ")";
};

NotEqualOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).notequal(this.rhs.evaluate(c));
};

// LessThanOperation /////////////////////////////////////////////////////////

LessThanOperation.prototype = new BinaryOperation();
LessThanOperation.prototype.constructor = LessThanOperation;
LessThanOperation.superclass = BinaryOperation.prototype;

function LessThanOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

LessThanOperation.prototype.init = function(lhs, rhs) {
	LessThanOperation.superclass.init.call(this, lhs, rhs);
};

LessThanOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).lessthan(this.rhs.evaluate(c));
};

LessThanOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " < " + this.rhs.toString() + ")";
};

// GreaterThanOperation //////////////////////////////////////////////////////

GreaterThanOperation.prototype = new BinaryOperation();
GreaterThanOperation.prototype.constructor = GreaterThanOperation;
GreaterThanOperation.superclass = BinaryOperation.prototype;

function GreaterThanOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

GreaterThanOperation.prototype.init = function(lhs, rhs) {
	GreaterThanOperation.superclass.init.call(this, lhs, rhs);
};

GreaterThanOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).greaterthan(this.rhs.evaluate(c));
};

GreaterThanOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " > " + this.rhs.toString() + ")";
};

// LessThanOrEqualOperation //////////////////////////////////////////////////

LessThanOrEqualOperation.prototype = new BinaryOperation();
LessThanOrEqualOperation.prototype.constructor = LessThanOrEqualOperation;
LessThanOrEqualOperation.superclass = BinaryOperation.prototype;

function LessThanOrEqualOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

LessThanOrEqualOperation.prototype.init = function(lhs, rhs) {
	LessThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
};

LessThanOrEqualOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).lessthanorequal(this.rhs.evaluate(c));
};

LessThanOrEqualOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " <= " + this.rhs.toString() + ")";
};

// GreaterThanOrEqualOperation ///////////////////////////////////////////////

GreaterThanOrEqualOperation.prototype = new BinaryOperation();
GreaterThanOrEqualOperation.prototype.constructor = GreaterThanOrEqualOperation;
GreaterThanOrEqualOperation.superclass = BinaryOperation.prototype;

function GreaterThanOrEqualOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

GreaterThanOrEqualOperation.prototype.init = function(lhs, rhs) {
	GreaterThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
};

GreaterThanOrEqualOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).greaterthanorequal(this.rhs.evaluate(c));
};

GreaterThanOrEqualOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " >= " + this.rhs.toString() + ")";
};

// PlusOperation /////////////////////////////////////////////////////////////

PlusOperation.prototype = new BinaryOperation();
PlusOperation.prototype.constructor = PlusOperation;
PlusOperation.superclass = BinaryOperation.prototype;

function PlusOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

PlusOperation.prototype.init = function(lhs, rhs) {
	PlusOperation.superclass.init.call(this, lhs, rhs);
};

PlusOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().plus(this.rhs.evaluate(c).number());
};

PlusOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " + " + this.rhs.toString() + ")";
};

// MinusOperation ////////////////////////////////////////////////////////////

MinusOperation.prototype = new BinaryOperation();
MinusOperation.prototype.constructor = MinusOperation;
MinusOperation.superclass = BinaryOperation.prototype;

function MinusOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

MinusOperation.prototype.init = function(lhs, rhs) {
	MinusOperation.superclass.init.call(this, lhs, rhs);
};

MinusOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().minus(this.rhs.evaluate(c).number());
};

MinusOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " - " + this.rhs.toString() + ")";
};

// MultiplyOperation /////////////////////////////////////////////////////////

MultiplyOperation.prototype = new BinaryOperation();
MultiplyOperation.prototype.constructor = MultiplyOperation;
MultiplyOperation.superclass = BinaryOperation.prototype;

function MultiplyOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

MultiplyOperation.prototype.init = function(lhs, rhs) {
	MultiplyOperation.superclass.init.call(this, lhs, rhs);
};

MultiplyOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().multiply(this.rhs.evaluate(c).number());
};

MultiplyOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " * " + this.rhs.toString() + ")";
};

// DivOperation //////////////////////////////////////////////////////////////

DivOperation.prototype = new BinaryOperation();
DivOperation.prototype.constructor = DivOperation;
DivOperation.superclass = BinaryOperation.prototype;

function DivOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

DivOperation.prototype.init = function(lhs, rhs) {
	DivOperation.superclass.init.call(this, lhs, rhs);
};

DivOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().div(this.rhs.evaluate(c).number());
};

DivOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " div " + this.rhs.toString() + ")";
};

// ModOperation //////////////////////////////////////////////////////////////

ModOperation.prototype = new BinaryOperation();
ModOperation.prototype.constructor = ModOperation;
ModOperation.superclass = BinaryOperation.prototype;

function ModOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

ModOperation.prototype.init = function(lhs, rhs) {
	ModOperation.superclass.init.call(this, lhs, rhs);
};

ModOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().mod(this.rhs.evaluate(c).number());
};

ModOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " mod " + this.rhs.toString() + ")";
};

// BarOperation //////////////////////////////////////////////////////////////

BarOperation.prototype = new BinaryOperation();
BarOperation.prototype.constructor = BarOperation;
BarOperation.superclass = BinaryOperation.prototype;

function BarOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

BarOperation.prototype.init = function(lhs, rhs) {
	BarOperation.superclass.init.call(this, lhs, rhs);
};

BarOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).nodeset().union(this.rhs.evaluate(c).nodeset());
};

BarOperation.prototype.toString = function() {
	return this.lhs.toString() + " | " + this.rhs.toString();
};

// PathExpr //////////////////////////////////////////////////////////////////

PathExpr.prototype = new Expression();
PathExpr.prototype.constructor = PathExpr;
PathExpr.superclass = Expression.prototype;

function PathExpr(filter, filterPreds, locpath) {
	if (arguments.length > 0) {
		this.init(filter, filterPreds, locpath);
	}
}

PathExpr.prototype.init = function(filter, filterPreds, locpath) {
	PathExpr.superclass.init.call(this);
	this.filter = filter;
	this.filterPredicates = filterPreds;
	this.locationPath = locpath;
};

PathExpr.prototype.evaluate = function(c) {
	var nodes;
	var xpc = new XPathContext();
	xpc.variableResolver = c.variableResolver;
	xpc.functionResolver = c.functionResolver;
	xpc.namespaceResolver = c.namespaceResolver;
	xpc.expressionContextNode = c.expressionContextNode;
	xpc.virtualRoot = c.virtualRoot;
	xpc.caseInsensitive = c.caseInsensitive;
	if (this.filter == null) {
		nodes = [ c.contextNode ];
	} else {
		var ns = this.filter.evaluate(c);
		if (!Utilities.instance_of(ns, XNodeSet)) {
			if (this.filterPredicates != null && this.filterPredicates.length > 0 || this.locationPath != null) {
				throw new Error("Path expression filter must evaluate to a nodset if predicates or location path are used");
			}
			return ns;
		}
		nodes = ns.toArray();
		if (this.filterPredicates != null) {
			// apply each of the predicates in turn
			for (var j = 0; j < this.filterPredicates.length; j++) {
				var pred = this.filterPredicates[j];
				var newNodes = [];
				xpc.contextSize = nodes.length;
				for (xpc.contextPosition = 1; xpc.contextPosition <= xpc.contextSize; xpc.contextPosition++) {
					xpc.contextNode = nodes[xpc.contextPosition - 1];
					if (this.predicateMatches(pred, xpc)) {
						newNodes.push(xpc.contextNode);
					}
				}
				nodes = newNodes;
			}
		}
	}
	if (this.locationPath != null) {
		if (this.locationPath.absolute) {
			if (nodes[0].nodeType != 9 /*Node.DOCUMENT_NODE*/) {
				if (xpc.virtualRoot != null) {
					nodes = [ xpc.virtualRoot ];
				} else {
					if (nodes[0].ownerDocument == null) {
						// IE 5.5 doesn't have ownerDocument?
						var n = nodes[0];
						while (n.parentNode != null) {
							n = n.parentNode;
						}
						nodes = [ n ];
					} else {
						nodes = [ nodes[0].ownerDocument ];
					}
				}
			} else {
				nodes = [ nodes[0] ];
			}
		}
		for (var i = 0; i < this.locationPath.steps.length; i++) {
			var step = this.locationPath.steps[i];
			var newNodes = [];
			for (var j = 0; j < nodes.length; j++) {
				xpc.contextNode = nodes[j];
				switch (step.axis) {
					case Step.ANCESTOR:
						// look at all the ancestor nodes
						if (xpc.contextNode === xpc.virtualRoot) {
							break;
						}
						var m;
						if (xpc.contextNode.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
							m = this.getOwnerElement(xpc.contextNode);
						} else {
							m = xpc.contextNode.parentNode;
						}
						while (m != null) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
							if (m === xpc.virtualRoot) {
								break;
							}
							m = m.parentNode;
						}
						break;

					case Step.ANCESTORORSELF:
						// look at all the ancestor nodes and the current node
						for (var m = xpc.contextNode; m != null; m = m.nodeType == 2 /*Node.ATTRIBUTE_NODE*/ ? this.getOwnerElement(m) : m.parentNode) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
							if (m === xpc.virtualRoot) {
								break;
							}
						}
						break;

					case Step.ATTRIBUTE:
						// look at the attributes
						var nnm = xpc.contextNode.attributes;
						if (nnm != null) {
							for (var k = 0; k < nnm.length; k++) {
								var m = nnm.item(k);
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.push(m);
								}
							}
						}
						break;

					case Step.CHILD:
						// look at all child elements
						for (var m = xpc.contextNode.firstChild; m != null; m = m.nextSibling) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
						}
						break;

					case Step.DESCENDANT:
						// look at all descendant nodes
						var st = [ xpc.contextNode.firstChild ];
						while (st.length > 0) {
							for (var m = st.pop(); m != null; ) {
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.push(m);
								}
								if (m.firstChild != null) {
									st.push(m.nextSibling);
									m = m.firstChild;
								} else {
									m = m.nextSibling;
								}
							}
						}
						break;

					case Step.DESCENDANTORSELF:
						// look at self
						if (step.nodeTest.matches(xpc.contextNode, xpc)) {
							newNodes.push(xpc.contextNode);
						}
						// look at all descendant nodes
						var st = [ xpc.contextNode.firstChild ];
						while (st.length > 0) {
							for (var m = st.pop(); m != null; ) {
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.push(m);
								}
								if (m.firstChild != null) {
									st.push(m.nextSibling);
									m = m.firstChild;
								} else {
									m = m.nextSibling;
								}
							}
						}
						break;

					case Step.FOLLOWING:
						if (xpc.contextNode === xpc.virtualRoot) {
							break;
						}
						var st = [];
						if (xpc.contextNode.firstChild != null) {
							st.unshift(xpc.contextNode.firstChild);
						} else {
							st.unshift(xpc.contextNode.nextSibling);
						}
						for (var m = xpc.contextNode.parentNode; m != null && m.nodeType != 9 /*Node.DOCUMENT_NODE*/ && m !== xpc.virtualRoot; m = m.parentNode) {
							st.unshift(m.nextSibling);
						}
						do {
							for (var m = st.pop(); m != null; ) {
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.push(m);
								}
								if (m.firstChild != null) {
									st.push(m.nextSibling);
									m = m.firstChild;
								} else {
									m = m.nextSibling;
								}
							}
						} while (st.length > 0);
						break;

					case Step.FOLLOWINGSIBLING:
						if (xpc.contextNode === xpc.virtualRoot) {
							break;
						}
						for (var m = xpc.contextNode.nextSibling; m != null; m = m.nextSibling) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
						}
						break;

					case Step.NAMESPACE:
						var n = {};
						if (xpc.contextNode.nodeType == 1 /*Node.ELEMENT_NODE*/) {
							n["xml"] = XPath.XML_NAMESPACE_URI;
							n["xmlns"] = XPath.XMLNS_NAMESPACE_URI;
							for (var m = xpc.contextNode; m != null && m.nodeType == 1 /*Node.ELEMENT_NODE*/; m = m.parentNode) {
								for (var k = 0; k < m.attributes.length; k++) {
									var attr = m.attributes.item(k);
									var nm = String(attr.name);
									if (nm == "xmlns") {
										if (n[""] == undefined) {
											n[""] = attr.value;
										}
									} else if (nm.length > 6 && nm.substring(0, 6) == "xmlns:") {
										var pre = nm.substring(6, nm.length);
										if (n[pre] == undefined) {
											n[pre] = attr.value;
										}
									}
								}
							}
							for (var pre in n) {
								var nsn = new NamespaceNode(pre, n[pre], xpc.contextNode);
								if (step.nodeTest.matches(nsn, xpc)) {
									newNodes.push(nsn);
								}
							}
						}
						break;

					case Step.PARENT:
						m = null;
						if (xpc.contextNode !== xpc.virtualRoot) {
							if (xpc.contextNode.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
								m = this.getOwnerElement(xpc.contextNode);
							} else {
								m = xpc.contextNode.parentNode;
							}
						}
						if (m != null && step.nodeTest.matches(m, xpc)) {
							newNodes.push(m);
						}
						break;

					case Step.PRECEDING:
						var st;
						if (xpc.virtualRoot != null) {
							st = [ xpc.virtualRoot ];
						} else {
							st = xpc.contextNode.nodeType == 9 /*Node.DOCUMENT_NODE*/
								? [ xpc.contextNode ]
								: [ xpc.contextNode.ownerDocument ];
						}
						outer: while (st.length > 0) {
							for (var m = st.pop(); m != null; ) {
								if (m == xpc.contextNode) {
									break outer;
								}
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.unshift(m);
								}
								if (m.firstChild != null) {
									st.push(m.nextSibling);
									m = m.firstChild;
								} else {
									m = m.nextSibling;
								}
							}
						}
						break;

					case Step.PRECEDINGSIBLING:
						if (xpc.contextNode === xpc.virtualRoot) {
							break;
						}
						for (var m = xpc.contextNode.previousSibling; m != null; m = m.previousSibling) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
						}
						break;

					case Step.SELF:
						if (step.nodeTest.matches(xpc.contextNode, xpc)) {
							newNodes.push(xpc.contextNode);
						}
						break;

					default:
				}
			}
			nodes = newNodes;
			// apply each of the predicates in turn
			for (var j = 0; j < step.predicates.length; j++) {
				var pred = step.predicates[j];
				var newNodes = [];
				xpc.contextSize = nodes.length;
				for (xpc.contextPosition = 1; xpc.contextPosition <= xpc.contextSize; xpc.contextPosition++) {
					xpc.contextNode = nodes[xpc.contextPosition - 1];
					if (this.predicateMatches(pred, xpc)) {
						newNodes.push(xpc.contextNode);
					} else {
					}
				}
				nodes = newNodes;
			}
		}
	}
	var ns = new XNodeSet();
	ns.addArray(nodes);
	return ns;
};

PathExpr.prototype.predicateMatches = function(pred, c) {
	var res = pred.evaluate(c);
	if (Utilities.instance_of(res, XNumber)) {
		return c.contextPosition == res.numberValue();
	}
	return res.booleanValue();
};

PathExpr.prototype.toString = function() {
	if (this.filter != undefined) {
		var s = this.filter.toString();
		if (Utilities.instance_of(this.filter, XString)) {
			s = "'" + s + "'";
		}
		if (this.filterPredicates != undefined) {
			for (var i = 0; i < this.filterPredicates.length; i++) {
				s = s + "[" + this.filterPredicates[i].toString() + "]";
			}
		}
		if (this.locationPath != undefined) {
			if (!this.locationPath.absolute) {
				s += "/";
			}
			s += this.locationPath.toString();
		}
		return s;
	}
	return this.locationPath.toString();
};

PathExpr.prototype.getOwnerElement = function(n) {
	// DOM 2 has ownerElement
	if (n.ownerElement) {
		return n.ownerElement;
	}
	// DOM 1 Internet Explorer can use selectSingleNode (ironically)
	try {
		if (n.selectSingleNode) {
			return n.selectSingleNode("..");
		}
	} catch (e) {
	}
	// Other DOM 1 implementations must use this egregious search
	var doc = n.nodeType == 9 /*Node.DOCUMENT_NODE*/
			? n
			: n.ownerDocument;
	var elts = doc.getElementsByTagName("*");
	for (var i = 0; i < elts.length; i++) {
		var elt = elts.item(i);
		var nnm = elt.attributes;
		for (var j = 0; j < nnm.length; j++) {
			var an = nnm.item(j);
			if (an === n) {
				return elt;
			}
		}
	}
	return null;
};

// LocationPath //////////////////////////////////////////////////////////////

LocationPath.prototype = new Object();
LocationPath.prototype.constructor = LocationPath;
LocationPath.superclass = Object.prototype;

function LocationPath(abs, steps) {
	if (arguments.length > 0) {
		this.init(abs, steps);
	}
}

LocationPath.prototype.init = function(abs, steps) {
	this.absolute = abs;
	this.steps = steps;
};

LocationPath.prototype.toString = function() {
	var s;
	if (this.absolute) {
		s = "/";
	} else {
		s = "";
	}
	for (var i = 0; i < this.steps.length; i++) {
		if (i != 0) {
			s += "/";
		}
		s += this.steps[i].toString();
	}
	return s;
};

// Step //////////////////////////////////////////////////////////////////////

Step.prototype = new Object();
Step.prototype.constructor = Step;
Step.superclass = Object.prototype;

function Step(axis, nodetest, preds) {
	if (arguments.length > 0) {
		this.init(axis, nodetest, preds);
	}
}

Step.prototype.init = function(axis, nodetest, preds) {
	this.axis = axis;
	this.nodeTest = nodetest;
	this.predicates = preds;
};

Step.prototype.toString = function() {
	var s;
	switch (this.axis) {
		case Step.ANCESTOR:
			s = "ancestor";
			break;
		case Step.ANCESTORORSELF:
			s = "ancestor-or-self";
			break;
		case Step.ATTRIBUTE:
			s = "attribute";
			break;
		case Step.CHILD:
			s = "child";
			break;
		case Step.DESCENDANT:
			s = "descendant";
			break;
		case Step.DESCENDANTORSELF:
			s = "descendant-or-self";
			break;
		case Step.FOLLOWING:
			s = "following";
			break;
		case Step.FOLLOWINGSIBLING:
			s = "following-sibling";
			break;
		case Step.NAMESPACE:
			s = "namespace";
			break;
		case Step.PARENT:
			s = "parent";
			break;
		case Step.PRECEDING:
			s = "preceding";
			break;
		case Step.PRECEDINGSIBLING:
			s = "preceding-sibling";
			break;
		case Step.SELF:
			s = "self";
			break;
	}
	s += "::";
	s += this.nodeTest.toString();
	for (var i = 0; i < this.predicates.length; i++) {
		s += "[" + this.predicates[i].toString() + "]";
	}
	return s;
};

Step.ANCESTOR = 0;
Step.ANCESTORORSELF = 1;
Step.ATTRIBUTE = 2;
Step.CHILD = 3;
Step.DESCENDANT = 4;
Step.DESCENDANTORSELF = 5;
Step.FOLLOWING = 6;
Step.FOLLOWINGSIBLING = 7;
Step.NAMESPACE = 8;
Step.PARENT = 9;
Step.PRECEDING = 10;
Step.PRECEDINGSIBLING = 11;
Step.SELF = 12;

// NodeTest //////////////////////////////////////////////////////////////////

NodeTest.prototype = new Object();
NodeTest.prototype.constructor = NodeTest;
NodeTest.superclass = Object.prototype;

function NodeTest(type, value) {
	if (arguments.length > 0) {
		this.init(type, value);
	}
}

NodeTest.prototype.init = function(type, value) {
	this.type = type;
	this.value = value;
};

NodeTest.prototype.toString = function() {
	switch (this.type) {
		case NodeTest.NAMETESTANY:
			return "*";
		case NodeTest.NAMETESTPREFIXANY:
			return this.value + ":*";
		case NodeTest.NAMETESTRESOLVEDANY:
			return "{" + this.value + "}*";
		case NodeTest.NAMETESTQNAME:
			return this.value;
		case NodeTest.NAMETESTRESOLVEDNAME:
			return "{" + this.namespaceURI + "}" + this.value;
		case NodeTest.COMMENT:
			return "comment()";
		case NodeTest.TEXT:
			return "text()";
		case NodeTest.PI:
			if (this.value != undefined) {
				return "processing-instruction(\"" + this.value + "\")";
			}
			return "processing-instruction()";
		case NodeTest.NODE:
			return "node()";
	}
	return "<unknown nodetest type>";
};

NodeTest.prototype.matches = function(n, xpc) {
	switch (this.type) {
		case NodeTest.NAMETESTANY:
			if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/
					|| n.nodeType == 1 /*Node.ELEMENT_NODE*/
					|| n.nodeType == XPathNamespace.XPATH_NAMESPACE_NODE) {
				return true;
			}
			return false;
		case NodeTest.NAMETESTPREFIXANY:
			if ((n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/ || n.nodeType == 1 /*Node.ELEMENT_NODE*/)) {
				var ns = xpc.namespaceResolver.getNamespace(this.value, xpc.expressionContextNode);
				if (ns == null) {
					throw new Error("Cannot resolve QName " + this.value);
				}
				return ns == (n.namespaceURI || '');
			}
			return false;
		case NodeTest.NAMETESTQNAME:
			if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/
					|| n.nodeType == 1 /*Node.ELEMENT_NODE*/
					|| n.nodeType == XPathNamespace.XPATH_NAMESPACE_NODE) {
				var test = Utilities.resolveQName(this.value, xpc.namespaceResolver, xpc.expressionContextNode, false);
				if (test[0] == null) {
					throw new Error("Cannot resolve QName " + this.value);
				}
				test[0] = String(test[0]);
				test[1] = String(test[1]);
				if (test[0] == "") {
					test[0] = null;
				}
				var node = [n.namespaceURI || '', n.localName];
				node[0] = String(node[0]);
				node[1] = String(node[1]);
				if (node[0] == "") {
					node[0] = null;
				}
				if (xpc.caseInsensitive) {
					return test[0] == node[0] && String(test[1]).toLowerCase() == String(node[1]).toLowerCase();
				}
				return test[0] == node[0] && test[1] == node[1];
			}
			return false;
		case NodeTest.COMMENT:
			return n.nodeType == 8 /*Node.COMMENT_NODE*/;
		case NodeTest.TEXT:
			return n.nodeType == 3 /*Node.TEXT_NODE*/ || n.nodeType == 4 /*Node.CDATA_SECTION_NODE*/;
		case NodeTest.PI:
			return n.nodeType == 7 /*Node.PROCESSING_INSTRUCTION_NODE*/
				&& (this.value == null || n.nodeName == this.value);
		case NodeTest.NODE:
			return n.nodeType == 9 /*Node.DOCUMENT_NODE*/
				|| n.nodeType == 1 /*Node.ELEMENT_NODE*/
				|| n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/
				|| n.nodeType == 3 /*Node.TEXT_NODE*/
				|| n.nodeType == 4 /*Node.CDATA_SECTION_NODE*/
				|| n.nodeType == 8 /*Node.COMMENT_NODE*/
				|| n.nodeType == 7 /*Node.PROCESSING_INSTRUCTION_NODE*/;
	}
	return false;
};

NodeTest.NAMETESTANY = 0;
NodeTest.NAMETESTPREFIXANY = 1;
NodeTest.NAMETESTQNAME = 2;
NodeTest.COMMENT = 3;
NodeTest.TEXT = 4;
NodeTest.PI = 5;
NodeTest.NODE = 6;

// VariableReference /////////////////////////////////////////////////////////

VariableReference.prototype = new Expression();
VariableReference.prototype.constructor = VariableReference;
VariableReference.superclass = Expression.prototype;

function VariableReference(v) {
	if (arguments.length > 0) {
		this.init(v);
	}
}

VariableReference.prototype.init = function(v) {
	this.variable = v;
};

VariableReference.prototype.toString = function() {
	return "$" + this.variable;
};

VariableReference.prototype.evaluate = function(c) {
	return c.variableResolver.getVariable(this.variable, c);
};

// FunctionCall //////////////////////////////////////////////////////////////

FunctionCall.prototype = new Expression();
FunctionCall.prototype.constructor = FunctionCall;
FunctionCall.superclass = Expression.prototype;

function FunctionCall(fn, args) {
	if (arguments.length > 0) {
		this.init(fn, args);
	}
}

FunctionCall.prototype.init = function(fn, args) {
	this.functionName = fn;
	this.arguments = args;
};

FunctionCall.prototype.toString = function() {
	var s = this.functionName + "(";
	for (var i = 0; i < this.arguments.length; i++) {
		if (i > 0) {
			s += ", ";
		}
		s += this.arguments[i].toString();
	}
	return s + ")";
};

FunctionCall.prototype.evaluate = function(c) {
	var f = c.functionResolver.getFunction(this.functionName, c);
	if (f == undefined) {
		throw new Error("Unknown function " + this.functionName);
	}
	var a = [c].concat(this.arguments);
	return f.apply(c.functionResolver.thisArg, a);
};

// XString ///////////////////////////////////////////////////////////////////

XString.prototype = new Expression();
XString.prototype.constructor = XString;
XString.superclass = Expression.prototype;

function XString(s) {
	if (arguments.length > 0) {
		this.init(s);
	}
}

XString.prototype.init = function(s) {
	this.str = s;
};

XString.prototype.toString = function() {
	return this.str;
};

XString.prototype.evaluate = function(c) {
	return this;
};

XString.prototype.string = function() {
	return this;
};

XString.prototype.number = function() {
	return new XNumber(this.str);
};

XString.prototype.bool = function() {
	return new XBoolean(this.str);
};

XString.prototype.nodeset = function() {
	throw new Error("Cannot convert string to nodeset");
};

XString.prototype.stringValue = function() {
	return this.str;
};

XString.prototype.numberValue = function() {
	return this.number().numberValue();
};

XString.prototype.booleanValue = function() {
	return this.bool().booleanValue();
};

XString.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().equals(r);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.number().equals(r);
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithString(this, Operators.equals);
	}
	return new XBoolean(this.str == r.str);
};

XString.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().notequal(r);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.number().notequal(r);
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithString(this, Operators.notequal);
	}
	return new XBoolean(this.str != r.str);
};

XString.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.greaterthanorequal);
	}
	return this.number().lessthan(r.number());
};

XString.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.lessthanorequal);
	}
	return this.number().greaterthan(r.number());
};

XString.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.greaterthan);
	}
	return this.number().lessthanorequal(r.number());
};

XString.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.lessthan);
	}
	return this.number().greaterthanorequal(r.number());
};

// XNumber ///////////////////////////////////////////////////////////////////

XNumber.prototype = new Expression();
XNumber.prototype.constructor = XNumber;
XNumber.superclass = Expression.prototype;

function XNumber(n) {
	if (arguments.length > 0) {
		this.init(n);
	}
}

XNumber.prototype.init = function(n) {
	this.num = Number(n);
};

XNumber.prototype.toString = function() {
	return this.num;
};

XNumber.prototype.evaluate = function(c) {
	return this;
};

XNumber.prototype.string = function() {
	return new XString(this.num);
};

XNumber.prototype.number = function() {
	return this;
};

XNumber.prototype.bool = function() {
	return new XBoolean(this.num);
};

XNumber.prototype.nodeset = function() {
	throw new Error("Cannot convert number to nodeset");
};

XNumber.prototype.stringValue = function() {
	return this.string().stringValue();
};

XNumber.prototype.numberValue = function() {
	return this.num;
};

XNumber.prototype.booleanValue = function() {
	return this.bool().booleanValue();
};

XNumber.prototype.negate = function() {
	return new XNumber(-this.num);
};

XNumber.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().equals(r);
	}
	if (Utilities.instance_of(r, XString)) {
		return this.equals(r.number());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.equals);
	}
	return new XBoolean(this.num == r.num);
};

XNumber.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().notequal(r);
	}
	if (Utilities.instance_of(r, XString)) {
		return this.notequal(r.number());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.notequal);
	}
	return new XBoolean(this.num != r.num);
};

XNumber.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.greaterthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.lessthan(r.number());
	}
	return new XBoolean(this.num < r.num);
};

XNumber.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.lessthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.greaterthan(r.number());
	}
	return new XBoolean(this.num > r.num);
};

XNumber.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.greaterthan);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.lessthanorequal(r.number());
	}
	return new XBoolean(this.num <= r.num);
};

XNumber.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.lessthan);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.greaterthanorequal(r.number());
	}
	return new XBoolean(this.num >= r.num);
};

XNumber.prototype.plus = function(r) {
	return new XNumber(this.num + r.num);
};

XNumber.prototype.minus = function(r) {
	return new XNumber(this.num - r.num);
};

XNumber.prototype.multiply = function(r) {
	return new XNumber(this.num * r.num);
};

XNumber.prototype.div = function(r) {
	return new XNumber(this.num / r.num);
};

XNumber.prototype.mod = function(r) {
	return new XNumber(this.num % r.num);
};

// XBoolean //////////////////////////////////////////////////////////////////

XBoolean.prototype = new Expression();
XBoolean.prototype.constructor = XBoolean;
XBoolean.superclass = Expression.prototype;

function XBoolean(b) {
	if (arguments.length > 0) {
		this.init(b);
	}
}

XBoolean.prototype.init = function(b) {
	this.b = Boolean(b);
};

XBoolean.prototype.toString = function() {
	return this.b.toString();
};

XBoolean.prototype.evaluate = function(c) {
	return this;
};

XBoolean.prototype.string = function() {
	return new XString(this.b);
};

XBoolean.prototype.number = function() {
	return new XNumber(this.b);
};

XBoolean.prototype.bool = function() {
	return this;
};

XBoolean.prototype.nodeset = function() {
	throw new Error("Cannot convert boolean to nodeset");
};

XBoolean.prototype.stringValue = function() {
	return this.string().stringValue();
};

XBoolean.prototype.numberValue = function() {
	return this.num().numberValue();
};

XBoolean.prototype.booleanValue = function() {
	return this.b;
};

XBoolean.prototype.not = function() {
	return new XBoolean(!this.b);
};

XBoolean.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {
		return this.equals(r.bool());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithBoolean(this, Operators.equals);
	}
	return new XBoolean(this.b == r.b);
};

XBoolean.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {
		return this.notequal(r.bool());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithBoolean(this, Operators.notequal);
	}
	return new XBoolean(this.b != r.b);
};

XBoolean.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.greaterthanorequal);
	}
	return this.number().lessthan(r.number());
};

XBoolean.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.lessthanorequal);
	}
	return this.number().greaterthan(r.number());
};

XBoolean.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.greaterthan);
	}
	return this.number().lessthanorequal(r.number());
};

XBoolean.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.lessthan);
	}
	return this.number().greaterthanorequal(r.number());
};

// AVLTree ///////////////////////////////////////////////////////////////////

AVLTree.prototype = new Object();
AVLTree.prototype.constructor = AVLTree;
AVLTree.superclass = Object.prototype;

function AVLTree(n) {
	this.init(n);
}

AVLTree.prototype.init = function(n) {
	this.left = null;
    this.right = null;
	this.node = n;
	this.depth = 1;
};

AVLTree.prototype.balance = function() {
    var ldepth = this.left  == null ? 0 : this.left.depth;
    var rdepth = this.right == null ? 0 : this.right.depth;

	if (ldepth > rdepth + 1) {
        // LR or LL rotation
        var lldepth = this.left.left  == null ? 0 : this.left.left.depth;
        var lrdepth = this.left.right == null ? 0 : this.left.right.depth;

        if (lldepth < lrdepth) {
            // LR rotation consists of a RR rotation of the left child
            this.left.rotateRR();
            // plus a LL rotation of this node, which happens anyway
        }
        this.rotateLL();
    } else if (ldepth + 1 < rdepth) {
        // RR or RL rorarion
		var rrdepth = this.right.right == null ? 0 : this.right.right.depth;
		var rldepth = this.right.left  == null ? 0 : this.right.left.depth;

        if (rldepth > rrdepth) {
            // RR rotation consists of a LL rotation of the right child
            this.right.rotateLL();
            // plus a RR rotation of this node, which happens anyway
        }
        this.rotateRR();
    }
};

AVLTree.prototype.rotateLL = function() {
    // the left side is too long => rotate from the left (_not_ leftwards)
    var nodeBefore = this.node;
    var rightBefore = this.right;
    this.node = this.left.node;
    this.right = this.left;
    this.left = this.left.left;
    this.right.left = this.right.right;
    this.right.right = rightBefore;
    this.right.node = nodeBefore;
    this.right.updateInNewLocation();
    this.updateInNewLocation();
};

AVLTree.prototype.rotateRR = function() {
    // the right side is too long => rotate from the right (_not_ rightwards)
    var nodeBefore = this.node;
    var leftBefore = this.left;
    this.node = this.right.node;
    this.left = this.right;
    this.right = this.right.right;
    this.left.right = this.left.left;
    this.left.left = leftBefore;
    this.left.node = nodeBefore;
    this.left.updateInNewLocation();
    this.updateInNewLocation();
};

AVLTree.prototype.updateInNewLocation = function() {
    this.getDepthFromChildren();
};

AVLTree.prototype.getDepthFromChildren = function() {
    this.depth = this.node == null ? 0 : 1;
    if (this.left != null) {
        this.depth = this.left.depth + 1;
    }
    if (this.right != null && this.depth <= this.right.depth) {
        this.depth = this.right.depth + 1;
    }
};

AVLTree.prototype.order = function(n1, n2) {
	if (n1 === n2) {
		return 0;
	}
	var d1 = 0;
	var d2 = 0;
	for (var m1 = n1; m1 != null; m1 = m1.parentNode) {
		d1++;
	}
	for (var m2 = n2; m2 != null; m2 = m2.parentNode) {
		d2++;
	}
	if (d1 > d2) {
		while (d1 > d2) {
			n1 = n1.parentNode;
			d1--;
		}
		if (n1 == n2) {
			return 1;
		}
	} else if (d2 > d1) {
		while (d2 > d1) {
			n2 = n2.parentNode;
			d2--;
		}
		if (n1 == n2) {
			return -1;
		}
	}
	while (n1.parentNode != n2.parentNode) {
		n1 = n1.parentNode;
		n2 = n2.parentNode;
	}
	while (n1.previousSibling != null && n2.previousSibling != null) {
		n1 = n1.previousSibling;
		n2 = n2.previousSibling;
	}
	if (n1.previousSibling == null) {
		return -1;
	}
	return 1;
};

AVLTree.prototype.add = function(n)  {
	if (n === this.node) {
        return false;
    }

	var o = this.order(n, this.node);

    var ret = false;
    if (o == -1) {
        if (this.left == null) {
            this.left = new AVLTree(n);
            ret = true;
        } else {
            ret = this.left.add(n);
            if (ret) {
                this.balance();
            }
        }
    } else if (o == 1) {
        if (this.right == null) {
            this.right = new AVLTree(n);
            ret = true;
        } else {
            ret = this.right.add(n);
            if (ret) {
                this.balance();
            }
        }
    }

    if (ret) {
        this.getDepthFromChildren();
    }
    return ret;
};

// XNodeSet //////////////////////////////////////////////////////////////////

XNodeSet.prototype = new Expression();
XNodeSet.prototype.constructor = XNodeSet;
XNodeSet.superclass = Expression.prototype;

function XNodeSet() {
	this.init();
}

XNodeSet.prototype.init = function() {
	this.tree = null;
	this.size = 0;
};

XNodeSet.prototype.toString = function() {
	var p = this.first();
	if (p == null) {
		return "";
	}
	return this.stringForNode(p);
};

XNodeSet.prototype.evaluate = function(c) {
	return this;
};

XNodeSet.prototype.string = function() {
	return new XString(this.toString());
};

XNodeSet.prototype.stringValue = function() {
	return this.toString();
};

XNodeSet.prototype.number = function() {
	return new XNumber(this.string());
};

XNodeSet.prototype.numberValue = function() {
	return Number(this.string());
};

XNodeSet.prototype.bool = function() {
	return new XBoolean(this.tree != null);
};

XNodeSet.prototype.booleanValue = function() {
	return this.tree != null;
};

XNodeSet.prototype.nodeset = function() {
	return this;
};

XNodeSet.prototype.stringForNode = function(n) {
	if (n.nodeType == 9 /*Node.DOCUMENT_NODE*/) {
		n = n.documentElement;
	}
	if (n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
		return this.stringForNodeRec(n);
	}
	if (n.isNamespaceNode) {
		return n.namespace;
	}
	return n.nodeValue;
};

XNodeSet.prototype.stringForNodeRec = function(n) {
	var s = "";
	for (var n2 = n.firstChild; n2 != null; n2 = n2.nextSibling) {
		if (n2.nodeType == 3 /*Node.TEXT_NODE*/) {
			s += n2.nodeValue;
		} else if (n2.nodeType == 1 /*Node.ELEMENT_NODE*/) {
			s += this.stringForNodeRec(n2);
		}
	}
	return s;
};

XNodeSet.prototype.first = function() {
	var p = this.tree;
	if (p == null) {
		return null;
	}
	while (p.left != null) {
		p = p.left;
	}
	return p.node;
};

XNodeSet.prototype.add = function(n) {
    var added;
    if (this.tree == null) {
        this.tree = new AVLTree(n);
        added = true;
    } else {
        added = this.tree.add(n);
    }
    if (added) {
        this.size++;
    }
};

XNodeSet.prototype.addArray = function(ns) {
	for (var i = 0; i < ns.length; i++) {
		this.add(ns[i]);
	}
};

XNodeSet.prototype.toArray = function() {
	var a = [];
	this.toArrayRec(this.tree, a);
	return a;
};

XNodeSet.prototype.toArrayRec = function(t, a) {
	if (t != null) {
		this.toArrayRec(t.left, a);
		a.push(t.node);
		this.toArrayRec(t.right, a);
	}
};

XNodeSet.prototype.compareWithString = function(r, o) {
	var a = this.toArray();
	for (var i = 0; i < a.length; i++) {
		var n = a[i];
		var l = new XString(this.stringForNode(n));
		var res = o(l, r);
		if (res.booleanValue()) {
			return res;
		}
	}
	return new XBoolean(false);
};

XNodeSet.prototype.compareWithNumber = function(r, o) {
	var a = this.toArray();
	for (var i = 0; i < a.length; i++) {
		var n = a[i];
		var l = new XNumber(this.stringForNode(n));
		var res = o(l, r);
		if (res.booleanValue()) {
			return res;
		}
	}
	return new XBoolean(false);
};

XNodeSet.prototype.compareWithBoolean = function(r, o) {
	return o(this.bool(), r);
};

XNodeSet.prototype.compareWithNodeSet = function(r, o) {
	var a = this.toArray();
	for (var i = 0; i < a.length; i++) {
		var n = a[i];
		var l = new XString(this.stringForNode(n));
		var b = r.toArray();
		for (var j = 0; j < b.length; j++) {
			var n2 = b[j];
			var r = new XString(this.stringForNode(n2));
			var res = o(l, r);
			if (res.booleanValue()) {
				return res;
			}
		}
	}
	return new XBoolean(false);
};

XNodeSet.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithString(r, Operators.equals);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.equals);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.equals);
	}
	return this.compareWithNodeSet(r, Operators.equals);
};

XNodeSet.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithString(r, Operators.notequal);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.notequal);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.notequal);
	}
	return this.compareWithNodeSet(r, Operators.notequal);
};

XNodeSet.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithNumber(r.number(), Operators.lessthan);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.lessthan);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.lessthan);
	}
	return this.compareWithNodeSet(r, Operators.lessthan);
};

XNodeSet.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithNumber(r.number(), Operators.greaterthan);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.greaterthan);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.greaterthan);
	}
	return this.compareWithNodeSet(r, Operators.greaterthan);
};

XNodeSet.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithNumber(r.number(), Operators.lessthanorequal);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.lessthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.lessthanorequal);
	}
	return this.compareWithNodeSet(r, Operators.lessthanorequal);
};

XNodeSet.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithNumber(r.number(), Operators.greaterthanorequal);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.greaterthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.greaterthanorequal);
	}
	return this.compareWithNodeSet(r, Operators.greaterthanorequal);
};

XNodeSet.prototype.union = function(r) {
	var ns = new XNodeSet();
	ns.tree = this.tree;
	ns.size = this.size;
	ns.addArray(r.toArray());
	return ns;
};

// XPathNamespace ////////////////////////////////////////////////////////////

XPathNamespace.prototype = new Object();
XPathNamespace.prototype.constructor = XPathNamespace;
XPathNamespace.superclass = Object.prototype;

function XPathNamespace(pre, ns, p) {
	this.isXPathNamespace = true;
	this.ownerDocument = p.ownerDocument;
	this.nodeName = "#namespace";
	this.prefix = pre;
	this.localName = pre;
	this.namespaceURI = ns;
	this.nodeValue = ns;
	this.ownerElement = p;
	this.nodeType = XPathNamespace.XPATH_NAMESPACE_NODE;
}

XPathNamespace.prototype.toString = function() {
	return "{ \"" + this.prefix + "\", \"" + this.namespaceURI + "\" }";
};

// Operators /////////////////////////////////////////////////////////////////

var Operators = new Object();

Operators.equals = function(l, r) {
	return l.equals(r);
};

Operators.notequal = function(l, r) {
	return l.notequal(r);
};

Operators.lessthan = function(l, r) {
	return l.lessthan(r);
};

Operators.greaterthan = function(l, r) {
	return l.greaterthan(r);
};

Operators.lessthanorequal = function(l, r) {
	return l.lessthanorequal(r);
};

Operators.greaterthanorequal = function(l, r) {
	return l.greaterthanorequal(r);
};

// XPathContext //////////////////////////////////////////////////////////////

XPathContext.prototype = new Object();
XPathContext.prototype.constructor = XPathContext;
XPathContext.superclass = Object.prototype;

function XPathContext(vr, nr, fr) {
	this.variableResolver = vr != null ? vr : new VariableResolver();
	this.namespaceResolver = nr != null ? nr : new NamespaceResolver();
	this.functionResolver = fr != null ? fr : new FunctionResolver();
}

// VariableResolver //////////////////////////////////////////////////////////

VariableResolver.prototype = new Object();
VariableResolver.prototype.constructor = VariableResolver;
VariableResolver.superclass = Object.prototype;

function VariableResolver() {
}

VariableResolver.prototype.getVariable = function(vn, c) {
	var parts = Utilities.splitQName(vn);
	if (parts[0] != null) {
		parts[0] = c.namespaceResolver.getNamespace(parts[0], c.expressionContextNode);
        if (parts[0] == null) {
            throw new Error("Cannot resolve QName " + fn);
        }
	}
	return this.getVariableWithName(parts[0], parts[1], c.expressionContextNode);
};

VariableResolver.prototype.getVariableWithName = function(ns, ln, c) {
	return null;
};

// FunctionResolver //////////////////////////////////////////////////////////

FunctionResolver.prototype = new Object();
FunctionResolver.prototype.constructor = FunctionResolver;
FunctionResolver.superclass = Object.prototype;

function FunctionResolver(thisArg) {
	this.thisArg = thisArg != null ? thisArg : Functions;
	this.functions = new Object();
	this.addStandardFunctions();
}

FunctionResolver.prototype.addStandardFunctions = function() {
	this.functions["{}last"] = Functions.last;
	this.functions["{}position"] = Functions.position;
	this.functions["{}count"] = Functions.count;
	this.functions["{}id"] = Functions.id;
	this.functions["{}local-name"] = Functions.localName;
	this.functions["{}namespace-uri"] = Functions.namespaceURI;
	this.functions["{}name"] = Functions.name;
	this.functions["{}string"] = Functions.string;
	this.functions["{}concat"] = Functions.concat;
	this.functions["{}starts-with"] = Functions.startsWith;
	this.functions["{}contains"] = Functions.contains;
	this.functions["{}substring-before"] = Functions.substringBefore;
	this.functions["{}substring-after"] = Functions.substringAfter;
	this.functions["{}substring"] = Functions.substring;
	this.functions["{}string-length"] = Functions.stringLength;
	this.functions["{}normalize-space"] = Functions.normalizeSpace;
	this.functions["{}translate"] = Functions.translate;
	this.functions["{}boolean"] = Functions.boolean_;
	this.functions["{}not"] = Functions.not;
	this.functions["{}true"] = Functions.true_;
	this.functions["{}false"] = Functions.false_;
	this.functions["{}lang"] = Functions.lang;
	this.functions["{}number"] = Functions.number;
	this.functions["{}sum"] = Functions.sum;
	this.functions["{}floor"] = Functions.floor;
	this.functions["{}ceiling"] = Functions.ceiling;
	this.functions["{}round"] = Functions.round;
};

FunctionResolver.prototype.addFunction = function(ns, ln, f) {
	this.functions["{" + ns + "}" + ln] = f;
};

FunctionResolver.prototype.getFunction = function(fn, c) {
	var parts = Utilities.resolveQName(fn, c.namespaceResolver, c.contextNode, false);
    if (parts[0] == null) {
        throw new Error("Cannot resolve QName " + fn);
    }
	return this.getFunctionWithName(parts[0], parts[1], c.contextNode);
};

FunctionResolver.prototype.getFunctionWithName = function(ns, ln, c) {
	return this.functions["{" + ns + "}" + ln];
};

// NamespaceResolver /////////////////////////////////////////////////////////

NamespaceResolver.prototype = new Object();
NamespaceResolver.prototype.constructor = NamespaceResolver;
NamespaceResolver.superclass = Object.prototype;

function NamespaceResolver() {
}

NamespaceResolver.prototype.getNamespace = function(prefix, n) {
	if (prefix == "xml") {
		return XPath.XML_NAMESPACE_URI;
	} else if (prefix == "xmlns") {
		return XPath.XMLNS_NAMESPACE_URI;
	}
	if (n.nodeType == 9 /*Node.DOCUMENT_NODE*/) {
		n = n.documentElement;
	} else if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
		n = PathExpr.prototype.getOwnerElement(n);
	} else if (n.nodeType != 1 /*Node.ELEMENT_NODE*/) {
		n = n.parentNode;
	}
	while (n != null && n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
		var nnm = n.attributes;
		for (var i = 0; i < nnm.length; i++) {
			var a = nnm.item(i);
			var aname = a.nodeName;
			if (aname == "xmlns" && prefix == ""
					|| aname == "xmlns:" + prefix) {
				return String(a.nodeValue);
			}
		}
		n = n.parentNode;
	}
	return null;
};

// Functions /////////////////////////////////////////////////////////////////

Functions = new Object();

Functions.last = function() {
	var c = arguments[0];
	if (arguments.length != 1) {
		throw new Error("Function last expects ()");
	}
	return new XNumber(c.contextSize);
};

Functions.position = function() {
	var c = arguments[0];
	if (arguments.length != 1) {
		throw new Error("Function position expects ()");
	}
	return new XNumber(c.contextPosition);
};

Functions.count = function() {
	var c = arguments[0];
	var ns;
	if (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c), XNodeSet)) {
		throw new Error("Function count expects (node-set)");
	}
	return new XNumber(ns.size);
};

Functions.id = function() {
	var c = arguments[0];
	var id;
	if (arguments.length != 2) {
		throw new Error("Function id expects (object)");
	}
	id = arguments[1].evaluate(c);
	if (Utilities.instance_of(id, XNodeSet)) {
		id = id.toArray().join(" ");
	} else {
		id = id.stringValue();
	}
	var ids = id.split(/[\x0d\x0a\x09\x20]+/);
	var count = 0;
	var ns = new XNodeSet();
	var doc = c.contextNode.nodeType == 9 /*Node.DOCUMENT_NODE*/
			? c.contextNode
			: c.contextNode.ownerDocument;
	for (var i = 0; i < ids.length; i++) {
		var n;
		if (doc.getElementById) {
			n = doc.getElementById(ids[i]);
		} else {
			n = Utilities.getElementById(doc, ids[i]);
		}
		if (n != null) {
			ns.add(n);
			count++;
		}
	}
	return ns;
};

Functions.localName = function() {
	var c = arguments[0];
	var n;
	if (arguments.length == 1) {
		n = c.contextNode;
	} else if (arguments.length == 2) {
		n = arguments[1].evaluate(c).first();
	} else {
		throw new Error("Function local-name expects (node-set?)");
	}
	if (n == null) {
		return new XString("");
	}
	return new XString(n.localName ? n.localName : n.baseName);
};

Functions.namespaceURI = function() {
	var c = arguments[0];
	var n;
	if (arguments.length == 1) {
		n = c.contextNode;
	} else if (arguments.length == 2) {
		n = arguments[1].evaluate(c).first();
	} else {
		throw new Error("Function namespace-uri expects (node-set?)");
	}
	if (n == null) {
		return new XString("");
	}
	return new XString(n.namespaceURI);
};

Functions.name = function() {
	var c = arguments[0];
	var n;
	if (arguments.length == 1) {
		n = c.contextNode;
	} else if (arguments.length == 2) {
		n = arguments[1].evaluate(c).first();
	} else {
		throw new Error("Function name expects (node-set?)");
	}
	if (n == null) {
		return new XString("");
	}
	if (n.nodeType == 1 /*Node.ELEMENT_NODE*/ || n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
		return new XString(n.nodeName);
	} else if (n.localName == null) {
		return new XString("");
	} else {
		return new XString(n.localName);
	}
};

Functions.string = function() {
	var c = arguments[0];
	if (arguments.length == 1) {
		return XNodeSet.prototype.stringForNode(c.contextNode);
	} else if (arguments.length == 2) {
		return arguments[1].evaluate(c).string();
	}
	throw new Error("Function string expects (object?)");
};

Functions.concat = function() {
	var c = arguments[0];
	if (arguments.length < 3) {
		throw new Error("Function concat expects (string, string, string*)");
	}
	var s = "";
	for (var i = 1; i < arguments.length; i++) {
		s += arguments[i].evaluate(c).stringValue();
	}
	return new XString(s);
};

Functions.startsWith = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function startsWith expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	return new XBoolean(s1.substring(0, s2.length) == s2);
};

Functions.contains = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function contains expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	return new XBoolean(s1.indexOf(s2) != -1);
};

Functions.substringBefore = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function substring-before expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	return new XString(s1.substring(0, s1.indexOf(s2)));
};

Functions.substringAfter = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function substring-after expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	if (s2.length == 0) {
		return new XString(s1);
	}
	var i = s1.indexOf(s2);
	if (i == -1) {
		return new XString("");
	}
	return new XString(s1.substring(s1.indexOf(s2) + 1));
};

Functions.substring = function() {
	var c = arguments[0];
	if (!(arguments.length == 3 || arguments.length == 4)) {
		throw new Error("Function substring expects (string, number, number?)");
	}
	var s = arguments[1].evaluate(c).stringValue();
	var n1 = Math.round(arguments[2].evaluate(c).numberValue()) - 1;
	var n2 = arguments.length == 4 ? n1 + Math.round(arguments[3].evaluate(c).numberValue()) : undefined;
	return new XString(s.substring(n1, n2));
};

Functions.stringLength = function() {
	var c = arguments[0];
	var s;
	if (arguments.length == 1) {
		s = XNodeSet.prototype.stringForNode(c.contextNode);
	} else if (arguments.length == 2) {
		s = arguments[1].evaluate(c).stringValue();
	} else {
		throw new Error("Function string-length expects (string?)");
	}
	return new XNumber(s.length);
};

Functions.normalizeSpace = function() {
	var c = arguments[0];
	var s;
	if (arguments.length == 1) {
		s = XNodeSet.prototype.stringForNode(c.contextNode);
	} else if (arguments.length == 2) {
		s = arguments[1].evaluate(c).stringValue();
	} else {
		throw new Error("Function normalize-space expects (string?)");
	}
	var i = 0;
	var j = s.length - 1;
	while (Utilities.isSpace(s.charCodeAt(j))) {
		j--;
	}
	var t = "";
	while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {
		i++;
	}
	while (i <= j) {
		if (Utilities.isSpace(s.charCodeAt(i))) {
			t += " ";
			while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {
				i++;
			}
		} else {
			t += s.charAt(i);
			i++;
		}
	}
	return new XString(t);
};

Functions.translate = function() {
	var c = arguments[0];
	if (arguments.length != 4) {
		throw new Error("Function translate expects (string, string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	var s3 = arguments[3].evaluate(c).stringValue();
	var map = [];
	for (var i = 0; i < s2.length; i++) {
		var j = s2.charCodeAt(i);
		if (map[j] == undefined) {
			var k = i > s3.length ? "" : s3.charAt(i);
			map[j] = k;
		}
	}
	var t = "";
	for (var i = 0; i < s1.length; i++) {
		var c = s1.charCodeAt(i);
		var r = map[c];
		if (r == undefined) {
			t += s1.charAt(i);
		} else {
			t += r;
		}
	}
	return new XString(t);
};

Functions.boolean_ = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function boolean expects (object)");
	}
	return arguments[1].evaluate(c).bool();
};

Functions.not = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function not expects (object)");
	}
	return arguments[1].evaluate(c).bool().not();
};

Functions.true_ = function() {
	if (arguments.length != 1) {
		throw new Error("Function true expects ()");
	}
	return new XBoolean(true);
};

Functions.false_ = function() {
	if (arguments.length != 1) {
		throw new Error("Function false expects ()");
	}
	return new XBoolean(false);
};

Functions.lang = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function lang expects (string)");
	}
	var lang;
	for (var n = c.contextNode; n != null && n.nodeType != 9 /*Node.DOCUMENT_NODE*/; n = n.parentNode) {
		var a = n.getAttributeNS(XPath.XML_NAMESPACE_URI, "lang");
		if (a != null) {
			lang = String(a);
			break;
		}
	}
	if (lang == null) {
		return new XBoolean(false);
	}
	var s = arguments[1].evaluate(c).stringValue();
	return new XBoolean(lang.substring(0, s.length) == s
				&& (lang.length == s.length || lang.charAt(s.length) == '-'));
};

Functions.number = function() {
	var c = arguments[0];
	if (!(arguments.length == 1 || arguments.length == 2)) {
		throw new Error("Function number expects (object?)");
	}
	if (arguments.length == 1) {
		return new XNumber(XNodeSet.prototype.stringForNode(c.contextNode));
	}
	return arguments[1].evaluate(c).number();
};

Functions.sum = function() {
	var c = arguments[0];
	var ns;
	if (arguments.length != 2 || !Utilities.instance_of((ns = arguments[1].evaluate(c)), XNodeSet)) {
		throw new Error("Function sum expects (node-set)");
	}
	ns = ns.toArray();
	var n = 0;
	for (var i = 0; i < ns.length; i++) {
		n += new XNumber(XNodeSet.prototype.stringForNode(ns[i])).numberValue();
	}
	return new XNumber(n);
};

Functions.floor = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function floor expects (number)");
	}
	return new XNumber(Math.floor(arguments[1].evaluate(c).numberValue()));
};

Functions.ceiling = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function ceiling expects (number)");
	}
	return new XNumber(Math.ceil(arguments[1].evaluate(c).numberValue()));
};

Functions.round = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function round expects (number)");
	}
	return new XNumber(Math.round(arguments[1].evaluate(c).numberValue()));
};

// Utilities /////////////////////////////////////////////////////////////////

Utilities = new Object();

Utilities.splitQName = function(qn) {
	var i = qn.indexOf(":");
	if (i == -1) {
		return [ null, qn ];
	}
	return [ qn.substring(0, i), qn.substring(i + 1) ];
};

Utilities.resolveQName = function(qn, nr, n, useDefault) {
	var parts = Utilities.splitQName(qn);
	if (parts[0] != null) {
		parts[0] = nr.getNamespace(parts[0], n);
	} else {
		if (useDefault) {
			parts[0] = nr.getNamespace("", n);
			if (parts[0] == null) {
				parts[0] = "";
			}
		} else {
			parts[0] = "";
		}
	}
	return parts;
};

Utilities.isSpace = function(c) {
	return c == 0x9 || c == 0xd || c == 0xa || c == 0x20;
};

Utilities.isLetter = function(c) {
	return c >= 0x0041 && c <= 0x005A ||
		c >= 0x0061 && c <= 0x007A ||
		c >= 0x00C0 && c <= 0x00D6 ||
		c >= 0x00D8 && c <= 0x00F6 ||
		c >= 0x00F8 && c <= 0x00FF ||
		c >= 0x0100 && c <= 0x0131 ||
		c >= 0x0134 && c <= 0x013E ||
		c >= 0x0141 && c <= 0x0148 ||
		c >= 0x014A && c <= 0x017E ||
		c >= 0x0180 && c <= 0x01C3 ||
		c >= 0x01CD && c <= 0x01F0 ||
		c >= 0x01F4 && c <= 0x01F5 ||
		c >= 0x01FA && c <= 0x0217 ||
		c >= 0x0250 && c <= 0x02A8 ||
		c >= 0x02BB && c <= 0x02C1 ||
		c == 0x0386 ||
		c >= 0x0388 && c <= 0x038A ||
		c == 0x038C ||
		c >= 0x038E && c <= 0x03A1 ||
		c >= 0x03A3 && c <= 0x03CE ||
		c >= 0x03D0 && c <= 0x03D6 ||
		c == 0x03DA ||
		c == 0x03DC ||
		c == 0x03DE ||
		c == 0x03E0 ||
		c >= 0x03E2 && c <= 0x03F3 ||
		c >= 0x0401 && c <= 0x040C ||
		c >= 0x040E && c <= 0x044F ||
		c >= 0x0451 && c <= 0x045C ||
		c >= 0x045E && c <= 0x0481 ||
		c >= 0x0490 && c <= 0x04C4 ||
		c >= 0x04C7 && c <= 0x04C8 ||
		c >= 0x04CB && c <= 0x04CC ||
		c >= 0x04D0 && c <= 0x04EB ||
		c >= 0x04EE && c <= 0x04F5 ||
		c >= 0x04F8 && c <= 0x04F9 ||
		c >= 0x0531 && c <= 0x0556 ||
		c == 0x0559 ||
		c >= 0x0561 && c <= 0x0586 ||
		c >= 0x05D0 && c <= 0x05EA ||
		c >= 0x05F0 && c <= 0x05F2 ||
		c >= 0x0621 && c <= 0x063A ||
		c >= 0x0641 && c <= 0x064A ||
		c >= 0x0671 && c <= 0x06B7 ||
		c >= 0x06BA && c <= 0x06BE ||
		c >= 0x06C0 && c <= 0x06CE ||
		c >= 0x06D0 && c <= 0x06D3 ||
		c == 0x06D5 ||
		c >= 0x06E5 && c <= 0x06E6 ||
		c >= 0x0905 && c <= 0x0939 ||
		c == 0x093D ||
		c >= 0x0958 && c <= 0x0961 ||
		c >= 0x0985 && c <= 0x098C ||
		c >= 0x098F && c <= 0x0990 ||
		c >= 0x0993 && c <= 0x09A8 ||
		c >= 0x09AA && c <= 0x09B0 ||
		c == 0x09B2 ||
		c >= 0x09B6 && c <= 0x09B9 ||
		c >= 0x09DC && c <= 0x09DD ||
		c >= 0x09DF && c <= 0x09E1 ||
		c >= 0x09F0 && c <= 0x09F1 ||
		c >= 0x0A05 && c <= 0x0A0A ||
		c >= 0x0A0F && c <= 0x0A10 ||
		c >= 0x0A13 && c <= 0x0A28 ||
		c >= 0x0A2A && c <= 0x0A30 ||
		c >= 0x0A32 && c <= 0x0A33 ||
		c >= 0x0A35 && c <= 0x0A36 ||
		c >= 0x0A38 && c <= 0x0A39 ||
		c >= 0x0A59 && c <= 0x0A5C ||
		c == 0x0A5E ||
		c >= 0x0A72 && c <= 0x0A74 ||
		c >= 0x0A85 && c <= 0x0A8B ||
		c == 0x0A8D ||
		c >= 0x0A8F && c <= 0x0A91 ||
		c >= 0x0A93 && c <= 0x0AA8 ||
		c >= 0x0AAA && c <= 0x0AB0 ||
		c >= 0x0AB2 && c <= 0x0AB3 ||
		c >= 0x0AB5 && c <= 0x0AB9 ||
		c == 0x0ABD ||
		c == 0x0AE0 ||
		c >= 0x0B05 && c <= 0x0B0C ||
		c >= 0x0B0F && c <= 0x0B10 ||
		c >= 0x0B13 && c <= 0x0B28 ||
		c >= 0x0B2A && c <= 0x0B30 ||
		c >= 0x0B32 && c <= 0x0B33 ||
		c >= 0x0B36 && c <= 0x0B39 ||
		c == 0x0B3D ||
		c >= 0x0B5C && c <= 0x0B5D ||
		c >= 0x0B5F && c <= 0x0B61 ||
		c >= 0x0B85 && c <= 0x0B8A ||
		c >= 0x0B8E && c <= 0x0B90 ||
		c >= 0x0B92 && c <= 0x0B95 ||
		c >= 0x0B99 && c <= 0x0B9A ||
		c == 0x0B9C ||
		c >= 0x0B9E && c <= 0x0B9F ||
		c >= 0x0BA3 && c <= 0x0BA4 ||
		c >= 0x0BA8 && c <= 0x0BAA ||
		c >= 0x0BAE && c <= 0x0BB5 ||
		c >= 0x0BB7 && c <= 0x0BB9 ||
		c >= 0x0C05 && c <= 0x0C0C ||
		c >= 0x0C0E && c <= 0x0C10 ||
		c >= 0x0C12 && c <= 0x0C28 ||
		c >= 0x0C2A && c <= 0x0C33 ||
		c >= 0x0C35 && c <= 0x0C39 ||
		c >= 0x0C60 && c <= 0x0C61 ||
		c >= 0x0C85 && c <= 0x0C8C ||
		c >= 0x0C8E && c <= 0x0C90 ||
		c >= 0x0C92 && c <= 0x0CA8 ||
		c >= 0x0CAA && c <= 0x0CB3 ||
		c >= 0x0CB5 && c <= 0x0CB9 ||
		c == 0x0CDE ||
		c >= 0x0CE0 && c <= 0x0CE1 ||
		c >= 0x0D05 && c <= 0x0D0C ||
		c >= 0x0D0E && c <= 0x0D10 ||
		c >= 0x0D12 && c <= 0x0D28 ||
		c >= 0x0D2A && c <= 0x0D39 ||
		c >= 0x0D60 && c <= 0x0D61 ||
		c >= 0x0E01 && c <= 0x0E2E ||
		c == 0x0E30 ||
		c >= 0x0E32 && c <= 0x0E33 ||
		c >= 0x0E40 && c <= 0x0E45 ||
		c >= 0x0E81 && c <= 0x0E82 ||
		c == 0x0E84 ||
		c >= 0x0E87 && c <= 0x0E88 ||
		c == 0x0E8A ||
		c == 0x0E8D ||
		c >= 0x0E94 && c <= 0x0E97 ||
		c >= 0x0E99 && c <= 0x0E9F ||
		c >= 0x0EA1 && c <= 0x0EA3 ||
		c == 0x0EA5 ||
		c == 0x0EA7 ||
		c >= 0x0EAA && c <= 0x0EAB ||
		c >= 0x0EAD && c <= 0x0EAE ||
		c == 0x0EB0 ||
		c >= 0x0EB2 && c <= 0x0EB3 ||
		c == 0x0EBD ||
		c >= 0x0EC0 && c <= 0x0EC4 ||
		c >= 0x0F40 && c <= 0x0F47 ||
		c >= 0x0F49 && c <= 0x0F69 ||
		c >= 0x10A0 && c <= 0x10C5 ||
		c >= 0x10D0 && c <= 0x10F6 ||
		c == 0x1100 ||
		c >= 0x1102 && c <= 0x1103 ||
		c >= 0x1105 && c <= 0x1107 ||
		c == 0x1109 ||
		c >= 0x110B && c <= 0x110C ||
		c >= 0x110E && c <= 0x1112 ||
		c == 0x113C ||
		c == 0x113E ||
		c == 0x1140 ||
		c == 0x114C ||
		c == 0x114E ||
		c == 0x1150 ||
		c >= 0x1154 && c <= 0x1155 ||
		c == 0x1159 ||
		c >= 0x115F && c <= 0x1161 ||
		c == 0x1163 ||
		c == 0x1165 ||
		c == 0x1167 ||
		c == 0x1169 ||
		c >= 0x116D && c <= 0x116E ||
		c >= 0x1172 && c <= 0x1173 ||
		c == 0x1175 ||
		c == 0x119E ||
		c == 0x11A8 ||
		c == 0x11AB ||
		c >= 0x11AE && c <= 0x11AF ||
		c >= 0x11B7 && c <= 0x11B8 ||
		c == 0x11BA ||
		c >= 0x11BC && c <= 0x11C2 ||
		c == 0x11EB ||
		c == 0x11F0 ||
		c == 0x11F9 ||
		c >= 0x1E00 && c <= 0x1E9B ||
		c >= 0x1EA0 && c <= 0x1EF9 ||
		c >= 0x1F00 && c <= 0x1F15 ||
		c >= 0x1F18 && c <= 0x1F1D ||
		c >= 0x1F20 && c <= 0x1F45 ||
		c >= 0x1F48 && c <= 0x1F4D ||
		c >= 0x1F50 && c <= 0x1F57 ||
		c == 0x1F59 ||
		c == 0x1F5B ||
		c == 0x1F5D ||
		c >= 0x1F5F && c <= 0x1F7D ||
		c >= 0x1F80 && c <= 0x1FB4 ||
		c >= 0x1FB6 && c <= 0x1FBC ||
		c == 0x1FBE ||
		c >= 0x1FC2 && c <= 0x1FC4 ||
		c >= 0x1FC6 && c <= 0x1FCC ||
		c >= 0x1FD0 && c <= 0x1FD3 ||
		c >= 0x1FD6 && c <= 0x1FDB ||
		c >= 0x1FE0 && c <= 0x1FEC ||
		c >= 0x1FF2 && c <= 0x1FF4 ||
		c >= 0x1FF6 && c <= 0x1FFC ||
		c == 0x2126 ||
		c >= 0x212A && c <= 0x212B ||
		c == 0x212E ||
		c >= 0x2180 && c <= 0x2182 ||
		c >= 0x3041 && c <= 0x3094 ||
		c >= 0x30A1 && c <= 0x30FA ||
		c >= 0x3105 && c <= 0x312C ||
		c >= 0xAC00 && c <= 0xD7A3 ||
		c >= 0x4E00 && c <= 0x9FA5 ||
		c == 0x3007 ||
		c >= 0x3021 && c <= 0x3029;
};

Utilities.isNCNameChar = function(c) {
	return c >= 0x0030 && c <= 0x0039
		|| c >= 0x0660 && c <= 0x0669
		|| c >= 0x06F0 && c <= 0x06F9
		|| c >= 0x0966 && c <= 0x096F
		|| c >= 0x09E6 && c <= 0x09EF
		|| c >= 0x0A66 && c <= 0x0A6F
		|| c >= 0x0AE6 && c <= 0x0AEF
		|| c >= 0x0B66 && c <= 0x0B6F
		|| c >= 0x0BE7 && c <= 0x0BEF
		|| c >= 0x0C66 && c <= 0x0C6F
		|| c >= 0x0CE6 && c <= 0x0CEF
		|| c >= 0x0D66 && c <= 0x0D6F
		|| c >= 0x0E50 && c <= 0x0E59
		|| c >= 0x0ED0 && c <= 0x0ED9
		|| c >= 0x0F20 && c <= 0x0F29
		|| c == 0x002E
		|| c == 0x002D
		|| c == 0x005F
		|| Utilities.isLetter(c)
		|| c >= 0x0300 && c <= 0x0345
		|| c >= 0x0360 && c <= 0x0361
		|| c >= 0x0483 && c <= 0x0486
		|| c >= 0x0591 && c <= 0x05A1
		|| c >= 0x05A3 && c <= 0x05B9
		|| c >= 0x05BB && c <= 0x05BD
		|| c == 0x05BF
		|| c >= 0x05C1 && c <= 0x05C2
		|| c == 0x05C4
		|| c >= 0x064B && c <= 0x0652
		|| c == 0x0670
		|| c >= 0x06D6 && c <= 0x06DC
		|| c >= 0x06DD && c <= 0x06DF
		|| c >= 0x06E0 && c <= 0x06E4
		|| c >= 0x06E7 && c <= 0x06E8
		|| c >= 0x06EA && c <= 0x06ED
		|| c >= 0x0901 && c <= 0x0903
		|| c == 0x093C
		|| c >= 0x093E && c <= 0x094C
		|| c == 0x094D
		|| c >= 0x0951 && c <= 0x0954
		|| c >= 0x0962 && c <= 0x0963
		|| c >= 0x0981 && c <= 0x0983
		|| c == 0x09BC
		|| c == 0x09BE
		|| c == 0x09BF
		|| c >= 0x09C0 && c <= 0x09C4
		|| c >= 0x09C7 && c <= 0x09C8
		|| c >= 0x09CB && c <= 0x09CD
		|| c == 0x09D7
		|| c >= 0x09E2 && c <= 0x09E3
		|| c == 0x0A02
		|| c == 0x0A3C
		|| c == 0x0A3E
		|| c == 0x0A3F
		|| c >= 0x0A40 && c <= 0x0A42
		|| c >= 0x0A47 && c <= 0x0A48
		|| c >= 0x0A4B && c <= 0x0A4D
		|| c >= 0x0A70 && c <= 0x0A71
		|| c >= 0x0A81 && c <= 0x0A83
		|| c == 0x0ABC
		|| c >= 0x0ABE && c <= 0x0AC5
		|| c >= 0x0AC7 && c <= 0x0AC9
		|| c >= 0x0ACB && c <= 0x0ACD
		|| c >= 0x0B01 && c <= 0x0B03
		|| c == 0x0B3C
		|| c >= 0x0B3E && c <= 0x0B43
		|| c >= 0x0B47 && c <= 0x0B48
		|| c >= 0x0B4B && c <= 0x0B4D
		|| c >= 0x0B56 && c <= 0x0B57
		|| c >= 0x0B82 && c <= 0x0B83
		|| c >= 0x0BBE && c <= 0x0BC2
		|| c >= 0x0BC6 && c <= 0x0BC8
		|| c >= 0x0BCA && c <= 0x0BCD
		|| c == 0x0BD7
		|| c >= 0x0C01 && c <= 0x0C03
		|| c >= 0x0C3E && c <= 0x0C44
		|| c >= 0x0C46 && c <= 0x0C48
		|| c >= 0x0C4A && c <= 0x0C4D
		|| c >= 0x0C55 && c <= 0x0C56
		|| c >= 0x0C82 && c <= 0x0C83
		|| c >= 0x0CBE && c <= 0x0CC4
		|| c >= 0x0CC6 && c <= 0x0CC8
		|| c >= 0x0CCA && c <= 0x0CCD
		|| c >= 0x0CD5 && c <= 0x0CD6
		|| c >= 0x0D02 && c <= 0x0D03
		|| c >= 0x0D3E && c <= 0x0D43
		|| c >= 0x0D46 && c <= 0x0D48
		|| c >= 0x0D4A && c <= 0x0D4D
		|| c == 0x0D57
		|| c == 0x0E31
		|| c >= 0x0E34 && c <= 0x0E3A
		|| c >= 0x0E47 && c <= 0x0E4E
		|| c == 0x0EB1
		|| c >= 0x0EB4 && c <= 0x0EB9
		|| c >= 0x0EBB && c <= 0x0EBC
		|| c >= 0x0EC8 && c <= 0x0ECD
		|| c >= 0x0F18 && c <= 0x0F19
		|| c == 0x0F35
		|| c == 0x0F37
		|| c == 0x0F39
		|| c == 0x0F3E
		|| c == 0x0F3F
		|| c >= 0x0F71 && c <= 0x0F84
		|| c >= 0x0F86 && c <= 0x0F8B
		|| c >= 0x0F90 && c <= 0x0F95
		|| c == 0x0F97
		|| c >= 0x0F99 && c <= 0x0FAD
		|| c >= 0x0FB1 && c <= 0x0FB7
		|| c == 0x0FB9
		|| c >= 0x20D0 && c <= 0x20DC
		|| c == 0x20E1
		|| c >= 0x302A && c <= 0x302F
		|| c == 0x3099
		|| c == 0x309A
		|| c == 0x00B7
		|| c == 0x02D0
		|| c == 0x02D1
		|| c == 0x0387
		|| c == 0x0640
		|| c == 0x0E46
		|| c == 0x0EC6
		|| c == 0x3005
		|| c >= 0x3031 && c <= 0x3035
		|| c >= 0x309D && c <= 0x309E
		|| c >= 0x30FC && c <= 0x30FE;
};

Utilities.coalesceText = function(n) {
	for (var m = n.firstChild; m != null; m = m.nextSibling) {
		if (m.nodeType == 3 /*Node.TEXT_NODE*/ || m.nodeType == 4 /*Node.CDATA_SECTION_NODE*/) {
			var s = m.nodeValue;
			var first = m;
			m = m.nextSibling;
			while (m != null && (m.nodeType == 3 /*Node.TEXT_NODE*/ || m.nodeType == 4 /*Node.CDATA_SECTION_NODE*/)) {
				s += m.nodeValue;
				var del = m;
				m = m.nextSibling;
				del.parentNode.removeChild(del);
			}
			if (first.nodeType == 4 /*Node.CDATA_SECTION_NODE*/) {
				var p = first.parentNode;
				if (first.nextSibling == null) {
					p.removeChild(first);
					p.appendChild(p.ownerDocument.createTextNode(s));
				} else {
					var next = first.nextSibling;
					p.removeChild(first);
					p.insertBefore(p.ownerDocument.createTextNode(s), next);
				}
			} else {
				first.nodeValue = s;
			}
			if (m == null) {
				break;
			}
		} else if (m.nodeType == 1 /*Node.ELEMENT_NODE*/) {
			Utilities.coalesceText(m);
		}
	}
};

Utilities.instance_of = function(o, c) {
	while (o != null) {
		if (o.constructor === c) {
			return true;
		}
		if (o === Object) {
			return false;
		}
		o = o.constructor.superclass;
	}
	return false;
};

Utilities.getElementById = function(n, id) {
	// Note that this does not check the DTD to check for actual
	// attributes of type ID, so this may be a bit wrong.
	if (n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
		if (n.getAttribute("id") == id
				|| n.getAttributeNS(null, "id") == id) {
			return n;
		}
	}
	for (var m = n.firstChild; m != null; m = m.nextSibling) {
		var res = Utilities.getElementById(m, id);
		if (res != null) {
			return res;
		}
	}
	return null;
};

// XPathException ////////////////////////////////////////////////////////////

XPathException.prototype = {};
XPathException.prototype.constructor = XPathException;
XPathException.superclass = Object.prototype;

function XPathException(c, e) {
	this.code = c;
	this.exception = e;
}

XPathException.prototype.toString = function() {
	var msg = this.exception ? ": " + this.exception.toString() : "";
	switch (this.code) {
		case XPathException.INVALID_EXPRESSION_ERR:
			return "Invalid expression" + msg;
		case XPathException.TYPE_ERR:
			return "Type error" + msg;
	}
};

XPathException.INVALID_EXPRESSION_ERR = 51;
XPathException.TYPE_ERR = 52;

// XPathExpression ///////////////////////////////////////////////////////////

XPathExpression.prototype = {};
XPathExpression.prototype.constructor = XPathExpression;
XPathExpression.superclass = Object.prototype;

function XPathExpression(e, r, p) {
	this.xpath = p.parse(e);
	this.context = new XPathContext();
	this.context.namespaceResolver = new XPathNSResolverWrapper(r);
}

XPathExpression.prototype.evaluate = function(n, t, res) {
	this.context.expressionContextNode = n;
	var result = this.xpath.evaluate(this.context);
	return new XPathResult(result, t);
}

// XPathNSResolverWrapper ////////////////////////////////////////////////////

XPathNSResolverWrapper.prototype = {};
XPathNSResolverWrapper.prototype.constructor = XPathNSResolverWrapper;
XPathNSResolverWrapper.superclass = Object.prototype;

function XPathNSResolverWrapper(r) {
	this.xpathNSResolver = r;
}

XPathNSResolverWrapper.prototype.getNamespace = function(prefix, n) {
    if (this.xpathNSResolver == null) {
        return null;
    }
	return this.xpathNSResolver.lookupNamespaceURI(prefix);
};

// NodeXPathNSResolver ///////////////////////////////////////////////////////

NodeXPathNSResolver.prototype = {};
NodeXPathNSResolver.prototype.constructor = NodeXPathNSResolver;
NodeXPathNSResolver.superclass = Object.prototype;

function NodeXPathNSResolver(n) {
	this.node = n;
	this.namespaceResolver = new NamespaceResolver();
}

NodeXPathNSResolver.prototype.lookupNamespaceURI = function(prefix) {
	return this.namespaceResolver.getNamespace(prefix, this.node);
};

// XPathResult ///////////////////////////////////////////////////////////////

XPathResult.prototype = {};
XPathResult.prototype.constructor = XPathResult;
XPathResult.superclass = Object.prototype;

function XPathResult(v, t) {
	if (t == XPathResult.ANY_TYPE) {
		if (v.constructor === XString) {
			t = XPathResult.STRING_TYPE;
		} else if (v.constructor === XNumber) {
			t = XPathResult.NUMBER_TYPE;
		} else if (v.constructor === XBoolean) {
			t = XPathResult.BOOLEAN_TYPE;
		} else if (v.constructor === XNodeSet) {
			t = XPathResult.UNORDERED_NODE_ITERATOR_TYPE;
		}
	}
	this.resultType = t;
	switch (t) {
		case XPathResult.NUMBER_TYPE:
			this.numberValue = v.numberValue();
			return;
		case XPathResult.STRING_TYPE:
			this.stringValue = v.stringValue();
			return;
		case XPathResult.BOOLEAN_TYPE:
			this.booleanValue = v.booleanValue();
			return;
		case XPathResult.ANY_UNORDERED_NODE_TYPE:
		case XPathResult.FIRST_ORDERED_NODE_TYPE:
			if (v.constructor === XNodeSet) {
				this.singleNodeValue = v.first();
				return;
			}
			break;
		case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
		case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
			if (v.constructor === XNodeSet) {
				this.invalidIteratorState = false;
				this.nodes = v.toArray();
				this.iteratorIndex = 0;
				return;
			}
			break;
		case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
		case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
			if (v.constructor === XNodeSet) {
				this.nodes = v.toArray();
				this.snapshotLength = this.nodes.length;
				return;
			}
			break;
	}
	throw new XPathException(XPathException.TYPE_ERR);
};

XPathResult.prototype.iterateNext = function() {
	if (this.resultType != XPathResult.UNORDERED_NODE_ITERATOR_TYPE
			&& this.resultType != XPathResult.ORDERED_NODE_ITERATOR_TYPE) {
		throw new XPathException(XPathException.TYPE_ERR);
	}
	return this.nodes[this.iteratorIndex++];
};

XPathResult.prototype.snapshotItem = function(i) {
	if (this.resultType != XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE
			&& this.resultType != XPathResult.ORDERED_NODE_SNAPSHOT_TYPE) {
		throw new XPathException(XPathException.TYPE_ERR);
	}
	return this.nodes[i];
};

XPathResult.ANY_TYPE = 0;
XPathResult.NUMBER_TYPE = 1;
XPathResult.STRING_TYPE = 2;
XPathResult.BOOLEAN_TYPE = 3;
XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
XPathResult.FIRST_ORDERED_NODE_TYPE = 9;

// DOM 3 XPath support ///////////////////////////////////////////////////////

function installDOM3XPathSupport(doc, p) {
	doc.createExpression = function(e, r) {
		try {
			return new XPathExpression(e, r, p);
		} catch (e) {
			throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, e);
		}
	};
	doc.createNSResolver = function(n) {
		return new NodeXPathNSResolver(n);
	};
	doc.evaluate = function(e, cn, r, t, res) {
		if (t < 0 || t > 9) {
			throw { code: 0, toString: function() { return "Request type not supported"; } };
		}
        return doc.createExpression(e, r, p).evaluate(cn, t, res);
	};
};

// ---------------------------------------------------------------------------

// Install DOM 3 XPath support for the current document.
try {
	var shouldInstall = true;
	try {
		if (document.implementation
				&& document.implementation.hasFeature
				&& document.implementation.hasFeature("XPath", null)) {
			shouldInstall = false;
		}
	} catch (e) {
	}
	if (shouldInstall) {
		installDOM3XPathSupport(document, new XPathParser());
	}
} catch (e) {
}

// ---------------------------------------------------------------------------
// exports for node.js

installDOM3XPathSupport(exports, new XPathParser());

exports.XPathResult = XPathResult;

// helper
exports.select = function(e, doc, single) {
	return exports.selectWithResolver(e, doc, null, single);
};

exports.useNamespaces = function(mappings) {
	var resolver = {
		mappings: mappings || {},
		lookupNamespaceURI: function(prefix) {
			return this.mappings[prefix];
		}
	};

	return function(e, doc, single) {
		return exports.selectWithResolver(e, doc, resolver, single);
	};
};

exports.selectWithResolver = function(e, doc, resolver, single) {
	var expression = new XPathExpression(e, resolver, new XPathParser());
	var type = XPathResult.ANY_TYPE;

	var result = expression.evaluate(doc, type, null);

	if (result.resultType == XPathResult.STRING_TYPE) {
		result = result.stringValue;
	}
	else if (result.resultType == XPathResult.NUMBER_TYPE) {
		result = result.numberValue;
	}
	else if (result.resultType == XPathResult.BOOLEAN_TYPE) {
		result = result.booleanValue;
	}
	else {
		result = result.nodes;
		if (single) {
			result = result[0];
		}
	}

	return result;
};

exports.select1 = function(e, doc) {
	return exports.select(e, doc, true);
};

// end non-node wrapper
})(typeof exports !== 'undefined' ? exports : xpath);

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/events/events.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/flux/index.js":[function(require,module,exports){
/**
 * Copyright (c) 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

module.exports.Dispatcher = require('./lib/Dispatcher');

},{"./lib/Dispatcher":"/Users/Jacob/workspace/scheduler/front-end/node_modules/flux/lib/Dispatcher.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/flux/lib/Dispatcher.js":[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Dispatcher
 * 
 * @preventMunge
 */

'use strict';

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var invariant = require('fbjs/lib/invariant');

var _prefix = 'ID_';

/**
 * Dispatcher is used to broadcast payloads to registered callbacks. This is
 * different from generic pub-sub systems in two ways:
 *
 *   1) Callbacks are not subscribed to particular events. Every payload is
 *      dispatched to every registered callback.
 *   2) Callbacks can be deferred in whole or part until other callbacks have
 *      been executed.
 *
 * For example, consider this hypothetical flight destination form, which
 * selects a default city when a country is selected:
 *
 *   var flightDispatcher = new Dispatcher();
 *
 *   // Keeps track of which country is selected
 *   var CountryStore = {country: null};
 *
 *   // Keeps track of which city is selected
 *   var CityStore = {city: null};
 *
 *   // Keeps track of the base flight price of the selected city
 *   var FlightPriceStore = {price: null}
 *
 * When a user changes the selected city, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'city-update',
 *     selectedCity: 'paris'
 *   });
 *
 * This payload is digested by `CityStore`:
 *
 *   flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'city-update') {
 *       CityStore.city = payload.selectedCity;
 *     }
 *   });
 *
 * When the user selects a country, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'country-update',
 *     selectedCountry: 'australia'
 *   });
 *
 * This payload is digested by both stores:
 *
 *   CountryStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       CountryStore.country = payload.selectedCountry;
 *     }
 *   });
 *
 * When the callback to update `CountryStore` is registered, we save a reference
 * to the returned token. Using this token with `waitFor()`, we can guarantee
 * that `CountryStore` is updated before the callback that updates `CityStore`
 * needs to query its data.
 *
 *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       // `CountryStore.country` may not be updated.
 *       flightDispatcher.waitFor([CountryStore.dispatchToken]);
 *       // `CountryStore.country` is now guaranteed to be updated.
 *
 *       // Select the default city for the new country
 *       CityStore.city = getDefaultCityForCountry(CountryStore.country);
 *     }
 *   });
 *
 * The usage of `waitFor()` can be chained, for example:
 *
 *   FlightPriceStore.dispatchToken =
 *     flightDispatcher.register(function(payload) {
 *       switch (payload.actionType) {
 *         case 'country-update':
 *         case 'city-update':
 *           flightDispatcher.waitFor([CityStore.dispatchToken]);
 *           FlightPriceStore.price =
 *             getFlightPriceStore(CountryStore.country, CityStore.city);
 *           break;
 *     }
 *   });
 *
 * The `country-update` payload will be guaranteed to invoke the stores'
 * registered callbacks in order: `CountryStore`, `CityStore`, then
 * `FlightPriceStore`.
 */

var Dispatcher = (function () {
  function Dispatcher() {
    _classCallCheck(this, Dispatcher);

    this._callbacks = {};
    this._isDispatching = false;
    this._isHandled = {};
    this._isPending = {};
    this._lastID = 1;
  }

  /**
   * Registers a callback to be invoked with every dispatched payload. Returns
   * a token that can be used with `waitFor()`.
   */

  Dispatcher.prototype.register = function register(callback) {
    var id = _prefix + this._lastID++;
    this._callbacks[id] = callback;
    return id;
  };

  /**
   * Removes a callback based on its token.
   */

  Dispatcher.prototype.unregister = function unregister(id) {
    !this._callbacks[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.unregister(...): `%s` does not map to a registered callback.', id) : invariant(false) : undefined;
    delete this._callbacks[id];
  };

  /**
   * Waits for the callbacks specified to be invoked before continuing execution
   * of the current callback. This method should only be used by a callback in
   * response to a dispatched payload.
   */

  Dispatcher.prototype.waitFor = function waitFor(ids) {
    !this._isDispatching ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): Must be invoked while dispatching.') : invariant(false) : undefined;
    for (var ii = 0; ii < ids.length; ii++) {
      var id = ids[ii];
      if (this._isPending[id]) {
        !this._isHandled[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): Circular dependency detected while ' + 'waiting for `%s`.', id) : invariant(false) : undefined;
        continue;
      }
      !this._callbacks[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): `%s` does not map to a registered callback.', id) : invariant(false) : undefined;
      this._invokeCallback(id);
    }
  };

  /**
   * Dispatches a payload to all registered callbacks.
   */

  Dispatcher.prototype.dispatch = function dispatch(payload) {
    !!this._isDispatching ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.') : invariant(false) : undefined;
    this._startDispatching(payload);
    try {
      for (var id in this._callbacks) {
        if (this._isPending[id]) {
          continue;
        }
        this._invokeCallback(id);
      }
    } finally {
      this._stopDispatching();
    }
  };

  /**
   * Is this Dispatcher currently dispatching.
   */

  Dispatcher.prototype.isDispatching = function isDispatching() {
    return this._isDispatching;
  };

  /**
   * Call the callback stored with the given id. Also do some internal
   * bookkeeping.
   *
   * @internal
   */

  Dispatcher.prototype._invokeCallback = function _invokeCallback(id) {
    this._isPending[id] = true;
    this._callbacks[id](this._pendingPayload);
    this._isHandled[id] = true;
  };

  /**
   * Set up bookkeeping needed when dispatching.
   *
   * @internal
   */

  Dispatcher.prototype._startDispatching = function _startDispatching(payload) {
    for (var id in this._callbacks) {
      this._isPending[id] = false;
      this._isHandled[id] = false;
    }
    this._pendingPayload = payload;
    this._isDispatching = true;
  };

  /**
   * Clear bookkeeping used for dispatching.
   *
   * @internal
   */

  Dispatcher.prototype._stopDispatching = function _stopDispatching() {
    delete this._pendingPayload;
    this._isDispatching = false;
  };

  return Dispatcher;
})();

module.exports = Dispatcher;
}).call(this,require('_process'))

},{"_process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js","fbjs/lib/invariant":"/Users/Jacob/workspace/scheduler/front-end/node_modules/flux/node_modules/fbjs/lib/invariant.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/flux/node_modules/fbjs/lib/invariant.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

"use strict";

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function (condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error('Invariant Violation: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;
}).call(this,require('_process'))

},{"_process":"/Users/Jacob/workspace/scheduler/front-end/node_modules/browserify/node_modules/process/browser.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/node-calendar/node-calendar.js":[function(require,module,exports){
/*!
 * node-calendar
 * Copyright(c) 2013 Armin Tamzarian <tamzarian1989@gmail.com>
 * MIT Licensed
 */

(function() {

    var _DAYS_IN_MONTH = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var _DAYS_BEFORE_MONTH = [-1, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];

    try {
      var cldr = require("cldr");
    }
    catch(err) {
      cldr = false;
    }

    /**
     * Adjust the provided weekday index from the Javascript index scheme
     * (SUN=0, MON=1, ...) to the Python scheme (MON=0, TUE=1, ...)
     *
     * @api private
     */
    function _adjustWeekday(weekday) {
      return weekday > 0 ? weekday - 1 : 6
    };

    /**
     * Extracts the wide or abbreviated day names for a specified locale.
     * If cldr is not installed values default to that for locale en_US.
     *
     * @param {Boolean} abbr
     * @param {String} locale
     * @api private
     */
    function _extractLocaleDays(abbr, locale) {
      short = typeof(abbr) === "undefined" ? false : abbr;

      if(abbr) {
        return cldr ? cldr.extractDayNames(locale).format.abbreviated : ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
      }
      else {
        return cldr ? cldr.extractDayNames(locale).format.wide : ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
      }
    };

    /**
     * Extracts the wide or abbreviated month names for a specified locale.
     * If cldr is not installed values default to that for locale en_US.
     *
     * @param {Boolean} abbr
     * @param {String} locale
     * @api private
     */
    function _extractLocaleMonths(abbr, locale) {
      short = typeof(abbr) === "undefined" ? false : abbr;

      var months = []
      if(abbr) {
        months = cldr ? cldr.extractMonthNames(locale).format.abbreviated : ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      }
      else {
        months = cldr ? cldr.extractMonthNames(locale).format.wide : ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
      }

      months.unshift('');
      return months;
    };

    /**
     * Calculates the ordinal time from given year, month, day values.
     *
     * @param {Number} year
     * @param {Number} month
     * @param {Number} day
     * @api private
     */
    function _toordinal(year, month, day) {
      var days_before_year = ((year - 1) * 365) + Math.floor((year - 1) / 4) - Math.floor((year - 1) / 100) + Math.floor((year - 1) / 400);
      var days_before_month = _DAYS_BEFORE_MONTH[month] + (month > 2 && isleap(year) ? 1 : 0);
      return (days_before_year + days_before_month + day);
    }

    /**
     * Return true for leap years, false for non-leap years.
     *
     * @param {Number} year
     * @api public
     */
    function isleap(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    };

    /**
     * Return number of leap years in range [y1, y2).
     * Assumes y1 <= y2.
     *
     * @param {Number} y1
     * @param {Number} y2
     * @api public
     */
    function leapdays(y1, y2) {
      y1--;
      y2--;
      return (Math.floor(y2/4) - Math.floor(y1/4)) - (Math.floor(y2/100) - Math.floor(y1/100)) + (Math.floor(y2/400) - Math.floor(y1/400));
    };

    /**
     * Return starting weekday (0-6 ~ Mon-Sun) and number of days (28-31) for
     * year, month.
     *
     * @param {Number} year
     * @param {Number} month
     * @throws {IllegalMonthError} If the provided month is invalid.
     * @api public
     */
    function monthrange(year, month) {
      if(month < 1 || month > 12) {
        throw new IllegalMonthError();
      }

      var day1 = weekday(year, month, 1);
      var ndays = _DAYS_IN_MONTH[month] + (month === 2 && isleap(year));

      return [day1, ndays];
    };

    /**
     * Sets the locale for use in extracting month and weekday names.
     *
     * @param {String} locale
     * @throws {IllegalLocaleError} If the provided locale is invalid.
     * @api public
     */
    function setlocale(locale) {
      locale = typeof(locale) === "undefined" ? "en_US" : locale;

      if((cldr && (cldr.localeIds.indexOf(locale.replace(/-/g, '_').toLowerCase()) === -1)) || (!cldr && ((locale.replace(/-/g, '_').toLowerCase() !== "en_us")))) {
         throw new IllegalLocaleError();
      }

      this.day_name   = _extractLocaleDays(false, locale);
      this.day_abbr   = _extractLocaleDays(true, locale);
      this.month_name = _extractLocaleMonths(false, locale);
      this.month_abbr = _extractLocaleMonths(true, locale);
    };

    /**
      * Unrelated but handy function to calculate Unix timestamp from GMT.
      *
      * @param {Array} tuple
      * @throws {IllegalMonthError} If the provided month element is invalid.
      * @throws {IllegalDayError} If the provided day element is invalid.
      * @api public
      */
    function timegm(timegmt) {
      var year   = timegmt[0];
      var month  = timegmt[1];
      var day    = timegmt[2];
      var hour   = timegmt[3];
      var minute = timegmt[4];
      var second = timegmt[5];

      if(month < 1 || month > 12) {
        throw new IllegalMonthError();
      }

      if(day < 1 || day > (_DAYS_IN_MONTH[month] + (month === 2 && isleap(year)))) {
        throw new IllegalDayError();
      }

      if(hour < 0 || hour > 23 || minute < 0 || minute > 59 || second < 0 || second > 59) {
        throw new IllegalTimeError();
      }

      var days = _toordinal(year, month, 1) - 719163 + day - 1;
      var hours = (days * 24) + hour;
      var minutes = (hours * 60) + minute;
      var seconds = (minutes * 60) + second;

      return seconds;
    }

    /**
     * Return weekday (0-6 ~ Mon-Sun) for year (1970-...), month (1-12),
     * day (1-31).
     *
     * @param {Number} year
     * @param {Number} month
     * @param {Number} day
     * @throws {IllegalMonthError} If the provided month element is invalid.
     * @throws {IllegalDayError} If the provided day element is invalid.
     * @api public
     */
    function weekday(year, month, day) {
      if(month < 1 || month > 12) {
        throw new IllegalMonthError();
      }

      if(day < 1 || day > (_DAYS_IN_MONTH[month] + (month === 2 && isleap(year)))) {
        throw new IllegalDayError();
      }

      var date = new Date(year, month - 1, day);
      return _adjustWeekday(date.getDay());
    };


    /**
     * Base calendar class. This class doesn't do any formatting. It simply
     * provides data to subclasses.
     *
     * @param {Number} firstweekday
     * @throws {IllegalWeekdayError} If the provided firstweekday is invalid.
     * @api public
     */
    function Calendar(firstweekday) {
      this._firstweekday = typeof(firstweekday) === "undefined" ? 0 : firstweekday;

      if(firstweekday < 0 || firstweekday > 6) {
        throw new IllegalWeekdayError();
      }

      this._oneday = 1000 * 60 * 60 * 24;
      this._onehour = 1000 * 60 * 60;
    };

    /**
     * GET-er for firstweekday
     *
     * @api public
     */
    Calendar.prototype.getfirstweekday = function() {
      return this._firstweekday;
    };

    /**
     * SET-er for firstweekday
     *
     * @param {Number} firstweekday
     * @throws {IllegalWeekdayError} If the provided firstweekday is invalid.
     * @api public
     */
    Calendar.prototype.setfirstweekday = function(firstweekday) {
      if(firstweekday < 0 || firstweekday > 6) {
        throw new IllegalWeekdayError();
      }

      this._firstweekday = firstweekday;
    };

    /**
     * Return an array for one week of weekday numbers starting with the
     * configured first one.
     *
     * @api public
     */
    Calendar.prototype.iterweekdays = function() {
      var weekdays = [];
      for(var i = this._firstweekday; i < this._firstweekday + 7; i++) {
        weekdays.push(i % 7);
      }

      return weekdays;
    };

    /**
     * Return an array for one month. The array will contain Date
     * values and will always iterate through complete weeks, so it will yield
     * dates outside the specified month.
     *
     * @param {Number} year
     * @param {Number} month
     * @api public
     */

    Calendar.prototype.itermonthdates = function(year, month) {
      if(month < 1 || month > 12) {
        throw new IllegalMonthError();
      }

      var date = new Date(year, month - 1, 1);
      var day = _adjustWeekday(date.getDay());
      var days = (day - this._firstweekday)  >= 0 ? (day - this._firstweekday) % 7 : 7 + (day - this._firstweekday);

      date.setTime(date.getTime() - (days * this._oneday));

      var dates = [];
      while(true) {
        dates.push(new Date(date.getTime()));

        var currentDate = date.getDate();
        date.setTime(date.getTime() + this._oneday);

        // Hack to account for DST
        while(date.getDate() === currentDate) {
          date.setTime(date.getTime() + this._onehour);
        }

        if(date.getMonth() !== month - 1 && _adjustWeekday(date.getDay()) === this._firstweekday) {
          break;
        }
      }

      return dates;
    };
    /**
     * Like itermonthdates(), but will yield day numbers. For days outside
     * the specified month the day number is 0.
     *
     * @param {Number} year
     * @param {Number} month
     * @api public
     */
    Calendar.prototype.itermonthdays = function(year, month) {
      return this.itermonthdates(year, month).map(function(value){
        return value.getMonth() === month - 1 ? value.getDate() : 0;
      });
    };

    /**
     * Like itermonthdates(), but will yield [day number, weekday number]
     * arrays. For days outside the specified month the day number is 0.
     *
     * @param {Number} year
     * @param {Number} month
     * @api public
     */
    Calendar.prototype.itermonthdays2 = function(year, month) {
      return this.itermonthdates(year, month).map(function(value){
        return value.getMonth() === month - 1 ? [value.getDate(), _adjustWeekday(value.getDay())] : [0, _adjustWeekday(value.getDay())];
      }, this);
    };

    /**
     * Return a matrix (array of array) representing a month's calendar.
     * Each row represents a week; week entries are Date values.
     *
     * @param {Number} year
     * @param {Number} month
     * @api public
     */
    Calendar.prototype.monthdatescalendar = function(year, month) {
      var days = [];
      dates = this.itermonthdates(year, month);
      for(var i = 0; i < dates.length; i += 7) {
        days.push(dates.slice(i, i + 7));
      }

      return days;
    };

    /**
     * Return a matrix representing a month's calendar.
     * Each row represents a week; days outside this month are zero.
     *
     * @param {Number} year
     * @param {Number} month
     * @api public
     */
    Calendar.prototype.monthdayscalendar = function(year, month) {
      var days = [];
      dates = this.itermonthdays(year, month);
      for(var i = 0; i < dates.length; i += 7) {
        days.push(dates.slice(i, i + 7));
      }

      return days;
    };

    /**
     * Return a matrix representing a month's calendar.
     * Each row represents a week; week entries are
     * [day number, weekday number] arrays. Day numbers outside this month
     * are zero.
     *
     * @param {Number} year
     * @param {Number} month
     * @api public
     */
    Calendar.prototype.monthdays2calendar = function(year, month) {
      var days = [];
      dates = this.itermonthdays2(year, month);
      for(var i = 0; i < dates.length; i += 7) {
        days.push(dates.slice(i, i + 7));
      }

      return days;
    };

    /**
     * Return the data for the specified year ready for formatting. The return
     * value is an array of month rows. Each month row contains up to width months.
     * Each month contains between 4 and 6 weeks and each week contains 1-7
     * days. Days are Date objects.
     *
     * @param {Number} year
     * @param {Number} width
     * @api public
     */
    Calendar.prototype.yeardatescalendar = function(year, width) {
      width = typeof(width) === "undefined" ? 3 : width;

      var months = [];
      for(var month = 1; month <= 12; month++) {
        months.push(this.monthdatescalendar(year, month));
      }

      var rows = [];
      for(var i = 0; i < months.length; i += width) {
        rows.push(months.slice(i, i + width));
      }
      return rows;
    };

    /**
     * Return the data for the specified year ready for formatting (similar to
     * yeardatescalendar()). Entries in the week arrays are day numbers.
     * Day numbers outside this month are zero.
     *
     * @param {Number} year
     * @param {Number} width
     * @api public
     */
    Calendar.prototype.yeardayscalendar = function(year, width) {
      width = typeof(width) === "undefined" ? 3 : width;

      var months = [];
      for(var month = 1; month <= 12; month++) {
        months.push(this.monthdayscalendar(year, month));
      }

      var rows = [];
      for(var i = 0; i < months.length; i += width) {
        rows.push(months.slice(i, i + width));
      }
      return rows;
    };

    /**
     * Return the data for the specified year ready for formatting (similar to
     * yeardatescalendar()). Entries in the week arrays are
     * [day number, weekday number] arrays. Day numbers outside this month are
     * zero.
     *
     * @param {Number} year
     * @param {Number} width
     * @api public
     */
    Calendar.prototype.yeardays2calendar = function(year, width) {
      width = typeof(width) === "undefined" ? 3 : width;

      var months = [];
      for(var month = 1; month <= 12; month++) {
        months.push(this.monthdays2calendar(year, month));
      }

      var rows = [];
      for(var i = 0; i < months.length; i += width) {
        rows.push(months.slice(i, i + width));
      }
      return rows;
    };

    /**
     * Error indicating a nonexistent or unsupported locale specified.
     *
     * @param {String} message
     * @api public
     */
    function IllegalLocaleError(message) {
      this.name = "IllegalLocaleError";
      this.message = typeof(message) === "undefined" ? "Invalid locale specified." : message;
    };
    IllegalLocaleError.prototype = new Error();
    IllegalLocaleError.prototype.constructor = IllegalLocaleError;

    /**
     * Error indicating a day index specified outside of the valid range.
     *
     * @param {String} message
     * @api public
     */
    function IllegalDayError(message) {
      this.name = "IllegalDayError";
      this.message = typeof(message) === "undefined" ? "Invalid day specified." : message;
    };
    IllegalDayError.prototype = new Error();
    IllegalDayError.prototype.constructor = IllegalDayError;

    /**
     * Error indicating a month index specified outside of the expected range (1-12 ~ Jan-Dec).
     *
     * @param {String} message
     * @api public
     */
    function IllegalMonthError(message) {
      this.name = "IllegalMonthError";
      this.message = typeof(message) === "undefined" ? "Invalid month specified." : message;
    };
    IllegalMonthError.prototype = new Error();
    IllegalMonthError.prototype.constructor = IllegalMonthError;

    /**
     * Error indicating a time element is outside of the valid range.
     *
     * @param {String} message
     * @api public
     */
    function IllegalTimeError(message) {
      this.name = "IllegalTimeError";
      this.message = typeof(message) === "undefined" ? "Invalid time element specified." : message;
    };
    IllegalTimeError.prototype = new Error();
    IllegalTimeError.prototype.constructor = IllegalTimeError;

    /**
     * Error indicating a weekday index specified outside of the expected range (0-6 ~ Mon-Sun).
     *
     * @param {String} message
     * @api public
     */
    function IllegalWeekdayError(message) {
      this.name = "IllegalWeekdayError";
      this.message = typeof(message) === "undefined" ? "Invalid weekday specified." : message;
    };
    IllegalWeekdayError .prototype = new Error();
    IllegalWeekdayError .prototype.constructor = IllegalWeekdayError ;

    // export of package-like object with explicit public API
    var calendar = function() {};

    calendar.isleap     = isleap;
    calendar.leapdays   = leapdays;
    calendar.monthrange = monthrange;
    calendar.weekday    = weekday;
    calendar.setlocale  = setlocale;
    calendar.timegm     = timegm;
    calendar.Calendar   = Calendar;

    calendar.IllegalLocaleError  = IllegalLocaleError;
    calendar.IllegalDayError     = IllegalDayError;
    calendar.IllegalMonthError   = IllegalMonthError;
    calendar.IllegalTimeError    = IllegalTimeError;
    calendar.IllegalWeekdayError = IllegalWeekdayError;

    calendar.MONDAY     = 0;
    calendar.TUESDAY    = 1;
    calendar.WEDNESDAY  = 2;
    calendar.THURSDAY   = 3;
    calendar.FRIDAY     = 4;
    calendar.SATURDAY   = 5;
    calendar.SUNDAY     = 6;

    calendar.JANUARY    =  1;
    calendar.FEBRUARY   =  2;
    calendar.MARCH      =  3;
    calendar.APRIL      =  4;
    calendar.MAY        =  5;
    calendar.JUNE       =  6;
    calendar.JULY       =  7;
    calendar.AUGUST     =  8;
    calendar.SEPTEMBER  =  9;
    calendar.OCTOBER    = 10;
    calendar.NOVEMBER   = 11;
    calendar.DECEMBER   = 12;

    calendar.setlocale();

    // Initialization methodology and noConflict courtesy node-uuid:
    // https://github.com/broofa/node-uuid

    var _global = this;

    // Publish as node.js module
    if (typeof(module) != 'undefined' && module.exports) {
      module.exports = calendar;
    }

    // Publish as global (in browsers)
    else {
      var _previousRoot = _global.calendar;

      /**
        * Reset global 'calendar' variable
        *
        * @api public
        */
      calendar.noconflict = function() {
        _global.calendar = _previousRoot;
        return calendar;
      };

      _global.calendar = calendar;
    }

}).call(this);

},{"cldr":"/Users/Jacob/workspace/scheduler/front-end/node_modules/cldr/lib/cldr.js"}],"/Users/Jacob/workspace/scheduler/front-end/node_modules/react/lib/Object.assign.js":[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Object.assign
 */

// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign

'use strict';

function assign(target, sources) {
  if (target == null) {
    throw new TypeError('Object.assign target cannot be null or undefined');
  }

  var to = Object(target);
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
    var nextSource = arguments[nextIndex];
    if (nextSource == null) {
      continue;
    }

    var from = Object(nextSource);

    // We don't currently support accessors nor proxies. Therefore this
    // copy cannot throw. If we ever supported this then we must handle
    // exceptions and side-effects. We don't support symbols so they won't
    // be transferred.

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
  }

  return to;
}

module.exports = assign;

},{}],"/Users/Jacob/workspace/scheduler/front-end/src/js/Action.js":[function(require,module,exports){
var AppDispatcher = require('./Dispatcher.js');
var appConstants = require('./Constants.js');

var plannerActions = {
  newMonth: function (date) {
    AppDispatcher.handleViewAction({
      actionType: appConstants.NEW_MONTH,
      data: date
    });
  },
  findMonth: function (direction) {
    AppDispatcher.handleViewAction({
      actionType: appConstants.FIND_MONTH,
      data: direction
    });
  },
  selectedDay: function (dayNum) {
    AppDispatcher.handleViewAction({
      actionType: appConstants.SELECTED_DAY,
      data: dayNum
    });
  },
  addEvents: function (evt) {
    AppDispatcher.handleViewAction({
      actionType: appConstants.ADD_EVENTS,
      data: evt
    });
  }
};

module.exports = plannerActions;

},{"./Constants.js":"/Users/Jacob/workspace/scheduler/front-end/src/js/Constants.js","./Dispatcher.js":"/Users/Jacob/workspace/scheduler/front-end/src/js/Dispatcher.js"}],"/Users/Jacob/workspace/scheduler/front-end/src/js/Constants.js":[function(require,module,exports){
var appConstants = {
  NEW_MONTH: 'NEW_MONTH',
  FIND_MONTH: 'FIND_MONTH',
  SELECTED_DAY: 'SELECTED_DAY',
  ADD_EVENTS: 'ADD_EVENTS'
};

module.exports = appConstants;

},{}],"/Users/Jacob/workspace/scheduler/front-end/src/js/Dispatcher.js":[function(require,module,exports){
var Dispatcher = require('flux').Dispatcher;
var AppDispatcher = new Dispatcher();

AppDispatcher.handleViewAction = function(action) {
  this.dispatch({
    source: 'VIEW_ACTION',
    action: action
  });
}

module.exports = AppDispatcher;

},{"flux":"/Users/Jacob/workspace/scheduler/front-end/node_modules/flux/index.js"}],"/Users/Jacob/workspace/scheduler/front-end/src/js/assets/calendarConversions.js":[function(require,module,exports){
var monthConversion = {
  Jan : [1, 'January'],
  Feb : [2, 'February'],
  Mar : [3, 'March'],
  Apr : [4, 'April'],
  May : [5, 'May'],
  Jun : [6, 'June'],
  Jul : [7, 'July'],
  Aug : [8, 'August'],
  Sep : [9, 'September'],
  Oct : [10, 'October'],
  Nov : [11, 'November'],
  Dec : [12, 'December'],
  1 : 'Jan',
  2 : 'Feb',
  3 : 'Mar',
  4 : 'Apr',
  5 : 'May',
  6 : 'Jun',
  7 : 'Jul',
  8 : 'Aug',
  9 : 'Sep',
  10 : 'Oct',
  11 : 'Nov',
  12 : 'Dec',
}

var monthAnimation = function () {
  var mon = document.getElementsByClassName('monthGrid')[0].classList;
  mon.add('animated', 'zoomIn');
  setTimeout(function(){ mon.remove('animated', 'zoomIn') }, 1000);
}

var sortedEvents = function (evt1, evt2) {
  return parseInt(evt1.time.start) - parseInt(evt2.time.start);
}

module.exports = {
  monthConversion: monthConversion,
  monthAnimation: monthAnimation,
  sortedEvents: sortedEvents
}

},{}],"/Users/Jacob/workspace/scheduler/front-end/src/js/components/Day.jsx":[function(require,module,exports){
var Day = React.createClass({displayName: "Day",
  render: function () {
    return (
      React.createElement("div", null, 
        
         this.props.currentMonth.items.events[parseInt(this.props.day)]
         ? this.props.currentMonth.items.events[parseInt(this.props.day)].map(function (evt) {
            return React.createElement("p", null, evt.title)
           })
         : null
        
      )
    )
  }
})

module.exports = Day;

},{}],"/Users/Jacob/workspace/scheduler/front-end/src/js/components/events.jsx":[function(require,module,exports){
var Events = React.createClass({displayName: "Events",
  render: function () {
    return (
      React.createElement("div", {className: "animated zoomIn"}, 
        React.createElement("h1", null, "Your Events")
      )
    )
  }
})

module.exports = Events;

},{}],"/Users/Jacob/workspace/scheduler/front-end/src/js/components/month.jsx":[function(require,module,exports){
var Day = require('./Day.jsx');

var Month = React.createClass({displayName: "Month",
  render: function () {
    var that = this;
    return (
      React.createElement("section", null, 
        React.createElement("div", {className: "calendarHeader"}, 
          React.createElement("button", {className: "btn btn-primary", onClick: this.props.handlers.displayMonth}, "Back"), 
          React.createElement("div", {className: "monthName"}, 
            React.createElement("h1", null, this.props.currentMonth.name), 
            React.createElement("h4", null, this.props.currentMonth.year)
          ), 
          React.createElement("button", {className: "btn btn-primary", onClick: this.props.handlers.displayMonth}, "Forward")
        ), 
        React.createElement("table", {className: "monthGrid table-bordered"}, 
          React.createElement("thead", null, 
            React.createElement("tr", null, 
              React.createElement("th", null, "Sunday"), " ", React.createElement("th", null, "Monday"), " ", React.createElement("th", null, "Tuesday"), " ", React.createElement("th", null, "Wednesday"), " ", React.createElement("th", null, "Thursday"), " ", React.createElement("th", null, "Friday"), " ", React.createElement("th", null, "Saturday")
            )
          ), 
          React.createElement("tbody", null, 
            this.props.currentMonth.monthMatrix.map(function(week) {
              return (
                React.createElement("tr", {key: week}, 
                  week.map(function(day, i) {
                    return day == parseInt(this.props.currentMonth.selectedDay)
                      ? React.createElement("td", {className: "selectedDay", key: i}, 
                          React.createElement("b", null, React.createElement("p", null, day)), 
                          React.createElement(Day, {day: day, currentMonth: this.props.currentMonth})
                        )
                      : React.createElement("td", {onClick: this.props.handlers.selectedDay.bind(this, day), key: i}, 
                          React.createElement("b", null, React.createElement("p", null, day)), 
                          React.createElement(Day, {day: day, currentMonth: this.props.currentMonth})
                        )
                  },this)
                )
              );
            },this)
          )
        )
      )
    );
  }
})

module.exports = Month;

},{"./Day.jsx":"/Users/Jacob/workspace/scheduler/front-end/src/js/components/Day.jsx"}],"/Users/Jacob/workspace/scheduler/front-end/src/js/components/planner.jsx":[function(require,module,exports){
var Month = require('./month.jsx');
var SelectedDay = require('./selectedDay.jsx');
var TaskManager = require('./taskManager.jsx');
var plannerStore = require('../stores/plannerStore.js');
var plannerActions = require('../Action.js');
var monthAnimation = require('../assets/calendarConversions').monthAnimation;

var Planner = React.createClass({displayName: "Planner",

  getInitialState: function () {
    var now = new Date().toString().split(' ');
    plannerActions.newMonth([now[1], now[3], now[2]]);
    return {
      currentMonth: plannerStore.getCurrentMonth(),
    }
  },
  componentDidMount: function () {
    plannerStore.addChangeListener(this._onChange);
  },
  componentWillUnmount: function () {
    plannerStore.removeChangeListener(this._onChange);
  },
  handlers: {
    selectedDay:  function (day) {
      plannerActions.selectedDay(day);
    },
    displayMonth: function (e) {
      monthAnimation();
      e.target.innerHTML == 'Forward' ? plannerActions.findMonth(true) : plannerActions.findMonth(false);
    },
    addEvents: function (e) {
      plannerActions.addEvents(e);
    }
  },
  _onChange: function () {
    this.setState({
      currentMonth: plannerStore.getCurrentMonth()
    })
  },
  render: function() {
    return (
      React.createElement("div", {className: "animated zoomIn container-fluid"}, 
        React.createElement("div", {className: "row text-center"}, 
          React.createElement("div", {className: "col-md-8"}, 
            React.createElement(Month, {currentMonth: this.state.currentMonth, handlers: this.handlers})
          ), 
          React.createElement("div", {className: "col-md-4"}, 
            React.createElement(TaskManager, {currentMonth: this.state.currentMonth, addEvents: this.handlers.addEvents})
          )
        )
      )
    );
  }

});


React.render(React.createElement(Planner, null), document.getElementById('app'));

},{"../Action.js":"/Users/Jacob/workspace/scheduler/front-end/src/js/Action.js","../assets/calendarConversions":"/Users/Jacob/workspace/scheduler/front-end/src/js/assets/calendarConversions.js","../stores/plannerStore.js":"/Users/Jacob/workspace/scheduler/front-end/src/js/stores/plannerStore.js","./month.jsx":"/Users/Jacob/workspace/scheduler/front-end/src/js/components/month.jsx","./selectedDay.jsx":"/Users/Jacob/workspace/scheduler/front-end/src/js/components/selectedDay.jsx","./taskManager.jsx":"/Users/Jacob/workspace/scheduler/front-end/src/js/components/taskManager.jsx"}],"/Users/Jacob/workspace/scheduler/front-end/src/js/components/selectedDay.jsx":[function(require,module,exports){
var SelectedDay = React.createClass ({displayName: "SelectedDay",
  handleSubmit: function () {
    var form = document.getElementsByName('newEvent');
    this.props.addEvents({
      day: this.props.currentMonth.selectedDay, time: {start: form[1].value, end: form[2].value}, title: form[0].value, description: form[3].value
    });
    for (var i = 0; i < form.length; i++) {
      form[i].value = null;
    }
  },
  render: function () {
    return (
      React.createElement("div", {className: "animated zoomIn selectedDayHeader"}, 
        React.createElement("h4", null, "Add Event"), 
        React.createElement("form", null, 
          React.createElement("input", {type: "text", placeholder: "Title", name: "newEvent"}), 
          React.createElement("input", {type: "time", placeholder: "Start", name: "newEvent"}), 
          React.createElement("input", {type: "time", placeholder: "End", name: "newEvent"}), 
          React.createElement("textarea", {defaultValue: "Description", name: "newEvent"}), 
          React.createElement("span", {className: "glyphicon glyphicon-plus-sign", onClick: this.handleSubmit})
        )
      )
    )
  }

})

module.exports = SelectedDay

},{}],"/Users/Jacob/workspace/scheduler/front-end/src/js/components/taskManager.jsx":[function(require,module,exports){
var SelectedDay = require('./selectedDay.jsx');
var Events = require('./events.jsx');

var TaskManager = React.createClass({displayName: "TaskManager",

  getInitialState: function () {
    return {
      dateToggle: true,
      eventsToggle: false,
      toDoToggle: false
    }
  },
  handlers: {
    dateToggle: function () {
      this.setState({
        dateToggle: this.state.dateToggle ? this.state.dateToggle = false : this.state.dateToggle = true
      })
    },
    eventsToggle: function () {
      this.setState({
        eventsToggle: this.state.eventsToggle ? this.state.eventsToggle = false : this.state.eventsToggle = true
      })
    },
    toDoToggle: function () {

    }
  },
  render: function () {
    return (
      React.createElement("section", null, 
        React.createElement("h1", {className: "taskHeader"}, "Task Manager"), 
        React.createElement("div", {className: "taskContainer"}, 
          React.createElement("div", {className: "taskSection"}, 
            React.createElement("div", {onClick: this.handlers.dateToggle.bind(this)}, 
              React.createElement("span", {className: "taskIcon glyphicon glyphicon-triangle-" + (this.state.dateToggle ? "bottom" : "right")}), 
              React.createElement("h3", null, this.props.currentMonth.name +" "+ this.props.currentMonth.selectedDay +", "+ this.props.currentMonth.year)
            ), 
            this.state.dateToggle ? React.createElement(SelectedDay, {currentMonth: this.props.currentMonth, addEvents: this.props.addEvents}) : null
          ), 
          React.createElement("div", {className: "taskSection"}, 
            React.createElement("div", {onClick: this.handlers.eventsToggle.bind(this)}, 
              React.createElement("span", {className: "taskIcon glyphicon glyphicon-triangle-" + (this.state.eventsToggle ? "bottom" : "right")}), 
              React.createElement("h3", null, "Events")
            ), 
            this.state.eventsToggle ? React.createElement(Events, {currentMonth: this.props.currentMonth}) : null
          ), 
          React.createElement("div", {className: "taskSection"}, 
            React.createElement("span", {className: "taskIcon glyphicon glyphicon-triangle-right"}), 
            React.createElement("h3", null, "ToDo's")
          )
        )
      )
    )
  }
})

module.exports = TaskManager;

},{"./events.jsx":"/Users/Jacob/workspace/scheduler/front-end/src/js/components/events.jsx","./selectedDay.jsx":"/Users/Jacob/workspace/scheduler/front-end/src/js/components/selectedDay.jsx"}],"/Users/Jacob/workspace/scheduler/front-end/src/js/stores/plannerStore.js":[function(require,module,exports){
var AppDispatcher = require('../Dispatcher.js');
var appConstants = require('../Constants.js');
var objectAssign = require('react/lib/Object.assign');
var EventEmitter = require('events').EventEmitter;
var calendar = require('node-calendar');
var assets = require('../assets/calendarConversions');

var CHANGE_EVENT = 'change';

var years = {};
var current = {};

function Month(date) {
  this.name = assets.monthConversion[date[0]][1];
  this.monthKey = assets.monthConversion[date[0]][0];
  this.year = parseInt(date[1]);
  this.monthMatrix = date;
  this.selectedDay = date[2] || 1;
  this.items = {
    events: {},
    todos: {}
  };
}

Month.prototype.newMonth = function () {
  this.monthMatrix = new calendar.Calendar(calendar.SUNDAY).monthdayscalendar(this.monthMatrix[1], assets.monthConversion[this.monthMatrix[0]][0]);
};

var newMonth = function (date) {
  current = new Month(date);
  current.newMonth();
  years[current.year] ? years[current.year].push(current) : years[current.year] = [current];
}

var findMonth = function (direction) {
  if(direction)
    current.monthKey +1 < 13 ? newCurrent = [current.monthKey +1, current.year] : newCurrent = [1, current.year +1];
  else
    current.monthKey -1 > 0 ? newCurrent = [current.monthKey -1, current.year] : newCurrent = [12, current.year -1];
  if(years[newCurrent[1]]){
    var checker = years[newCurrent[1]].filter(function (mon) {
      if(mon.monthKey === newCurrent[0])
        return mon;
    })
    checker.length > 0 ? current = checker[0] : newMonth([assets.monthConversion[newCurrent[0]], newCurrent[1]]);
  } else {
    newMonth([assets.monthConversion[newCurrent[0]], newCurrent[1]]);
  }
}

var selectedDay = function (dayNum) {
  current.selectedDay = dayNum;
}

var addEvents = function (evt) {
  current.items.events[evt.day] ? current.items.events[evt.day].push(evt) : current.items.events[evt.day] = [evt];
  current.items.events[evt.day].sort(assets.sortedEvents);  
}

var plannerStore = objectAssign({}, EventEmitter.prototype, {
  addChangeListener: function (cb) {
    this.on(CHANGE_EVENT, cb);
  },
  removeChangeListener: function (cb) {
    this.removeListener(CHANGE_EVENT, cb);
  },
  getCurrentMonth: function () {
    console.log(years, current);
    return current;
  }
});

AppDispatcher.register(function (payload) {
  var action = payload.action;
  switch(action.actionType){
    case appConstants.NEW_MONTH:
      newMonth(action.data);
      plannerStore.emit(CHANGE_EVENT);
      break;
    case appConstants.FIND_MONTH:
      findMonth(action.data);
      plannerStore.emit(CHANGE_EVENT);
      break;
    case appConstants.SELECTED_DAY:
      selectedDay(action.data);
      plannerStore.emit(CHANGE_EVENT);
      break;
    case appConstants.ADD_EVENTS:
      addEvents(action.data);
      plannerStore.emit(CHANGE_EVENT);
    default:
      return true;
  }
});

module.exports = plannerStore;

},{"../Constants.js":"/Users/Jacob/workspace/scheduler/front-end/src/js/Constants.js","../Dispatcher.js":"/Users/Jacob/workspace/scheduler/front-end/src/js/Dispatcher.js","../assets/calendarConversions":"/Users/Jacob/workspace/scheduler/front-end/src/js/assets/calendarConversions.js","events":"/Users/Jacob/workspace/scheduler/front-end/node_modules/events/events.js","node-calendar":"/Users/Jacob/workspace/scheduler/front-end/node_modules/node-calendar/node-calendar.js","react/lib/Object.assign":"/Users/Jacob/workspace/scheduler/front-end/node_modules/react/lib/Object.assign.js"}]},{},["/Users/Jacob/workspace/scheduler/front-end/src/js/components/planner.jsx"])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvY2xkci9saWIvQ2xkclBsdXJhbFJ1bGUuanMiLCJub2RlX21vZHVsZXMvY2xkci9saWIvQ2xkclBsdXJhbFJ1bGVTZXQuanMiLCJub2RlX21vZHVsZXMvY2xkci9saWIvQ2xkclJibmZSdWxlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbGliL2NsZHIuanMiLCJub2RlX21vZHVsZXMvY2xkci9saWIvY2xkclBsdXJhbFJ1bGVUZXJtRnVuY3Rpb25CeU5hbWUuanMiLCJub2RlX21vZHVsZXMvY2xkci9saWIvY29udmVydE9iamVjdHNXaXRoSW50ZWdlcktleXNUb0FycmF5cy5qcyIsIm5vZGVfbW9kdWxlcy9jbGRyL2xpYi9tZW1vaXplQXN5bmMuanMiLCJub2RlX21vZHVsZXMvY2xkci9saWIvbm9ybWFsaXplTG9jYWxlSWQuanMiLCJub2RlX21vZHVsZXMvY2xkci9saWIvbm9ybWFsaXplUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY2xkci9ub2RlX21vZHVsZXMvcGFzc2Vycm9yL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jbGRyL25vZGVfbW9kdWxlcy9wZWdqcy9saWIvcGVnLmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3NlcS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jbGRyL25vZGVfbW9kdWxlcy9zZXEvbm9kZV9tb2R1bGVzL2NoYWluc2F3L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3NlcS9ub2RlX21vZHVsZXMvY2hhaW5zYXcvbm9kZV9tb2R1bGVzL3RyYXZlcnNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3NlcS9ub2RlX21vZHVsZXMvaGFzaGlzaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jbGRyL25vZGVfbW9kdWxlcy9zZXEvbm9kZV9tb2R1bGVzL2hhc2hpc2gvbm9kZV9tb2R1bGVzL3RyYXZlcnNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9saWIvY29uc29saWRhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9saWIvcGFyc2UtanMuanMiLCJub2RlX21vZHVsZXMvY2xkci9ub2RlX21vZHVsZXMvdWdsaWZ5LWpzL2xpYi9wcm9jZXNzLmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9saWIvc3F1ZWV6ZS1tb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy91Z2xpZnktanMuanMiLCJub2RlX21vZHVsZXMvY2xkci9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3VuaWNvZGVyZWdleHAvbGliL3VuaWNvZGVSZWdFeHAuanMiLCJub2RlX21vZHVsZXMvY2xkci9ub2RlX21vZHVsZXMveG1sZG9tL2RvbS1wYXJzZXIuanMiLCJub2RlX21vZHVsZXMvY2xkci9ub2RlX21vZHVsZXMveG1sZG9tL2RvbS5qcyIsIm5vZGVfbW9kdWxlcy9jbGRyL25vZGVfbW9kdWxlcy94bWxkb20vc2F4LmpzIiwibm9kZV9tb2R1bGVzL2NsZHIvbm9kZV9tb2R1bGVzL3hwYXRoL3hwYXRoLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvZmx1eC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mbHV4L2xpYi9EaXNwYXRjaGVyLmpzIiwibm9kZV9tb2R1bGVzL2ZsdXgvbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWNhbGVuZGFyL25vZGUtY2FsZW5kYXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL09iamVjdC5hc3NpZ24uanMiLCIvVXNlcnMvSmFjb2Ivd29ya3NwYWNlL3NjaGVkdWxlci9mcm9udC1lbmQvc3JjL2pzL0FjdGlvbi5qcyIsIi9Vc2Vycy9KYWNvYi93b3Jrc3BhY2Uvc2NoZWR1bGVyL2Zyb250LWVuZC9zcmMvanMvQ29uc3RhbnRzLmpzIiwiL1VzZXJzL0phY29iL3dvcmtzcGFjZS9zY2hlZHVsZXIvZnJvbnQtZW5kL3NyYy9qcy9EaXNwYXRjaGVyLmpzIiwiL1VzZXJzL0phY29iL3dvcmtzcGFjZS9zY2hlZHVsZXIvZnJvbnQtZW5kL3NyYy9qcy9hc3NldHMvY2FsZW5kYXJDb252ZXJzaW9ucy5qcyIsIi9Vc2Vycy9KYWNvYi93b3Jrc3BhY2Uvc2NoZWR1bGVyL2Zyb250LWVuZC9zcmMvanMvY29tcG9uZW50cy9EYXkuanN4IiwiL1VzZXJzL0phY29iL3dvcmtzcGFjZS9zY2hlZHVsZXIvZnJvbnQtZW5kL3NyYy9qcy9jb21wb25lbnRzL2V2ZW50cy5qc3giLCIvVXNlcnMvSmFjb2Ivd29ya3NwYWNlL3NjaGVkdWxlci9mcm9udC1lbmQvc3JjL2pzL2NvbXBvbmVudHMvbW9udGguanN4IiwiL1VzZXJzL0phY29iL3dvcmtzcGFjZS9zY2hlZHVsZXIvZnJvbnQtZW5kL3NyYy9qcy9jb21wb25lbnRzL3BsYW5uZXIuanN4IiwiL1VzZXJzL0phY29iL3dvcmtzcGFjZS9zY2hlZHVsZXIvZnJvbnQtZW5kL3NyYy9qcy9jb21wb25lbnRzL3NlbGVjdGVkRGF5LmpzeCIsIi9Vc2Vycy9KYWNvYi93b3Jrc3BhY2Uvc2NoZWR1bGVyL2Zyb250LWVuZC9zcmMvanMvY29tcG9uZW50cy90YXNrTWFuYWdlci5qc3giLCIvVXNlcnMvSmFjb2Ivd29ya3NwYWNlL3NjaGVkdWxlci9mcm9udC1lbmQvc3JjL2pzL3N0b3Jlcy9wbGFubmVyU3RvcmUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzkyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeGdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwc0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3gxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwa0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4a0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBLElBQUksYUFBYSxHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0FBQy9DLElBQUksWUFBWSxHQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDOztBQUU3QyxJQUFJLGNBQWMsR0FBRztFQUNuQixRQUFRLEVBQUUsVUFBVSxJQUFJLEVBQUU7SUFDeEIsYUFBYSxDQUFDLGdCQUFnQixDQUFDO01BQzdCLFVBQVUsRUFBRSxZQUFZLENBQUMsU0FBUztNQUNsQyxJQUFJLEVBQUUsSUFBSTtLQUNYLENBQUMsQ0FBQztHQUNKO0VBQ0QsU0FBUyxFQUFFLFVBQVUsU0FBUyxFQUFFO0lBQzlCLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQztNQUM3QixVQUFVLEVBQUUsWUFBWSxDQUFDLFVBQVU7TUFDbkMsSUFBSSxFQUFFLFNBQVM7S0FDaEIsQ0FBQyxDQUFDO0dBQ0o7RUFDRCxXQUFXLEVBQUUsVUFBVSxNQUFNLEVBQUU7SUFDN0IsYUFBYSxDQUFDLGdCQUFnQixDQUFDO01BQzdCLFVBQVUsRUFBRSxZQUFZLENBQUMsWUFBWTtNQUNyQyxJQUFJLEVBQUUsTUFBTTtLQUNiLENBQUMsQ0FBQztHQUNKO0VBQ0QsU0FBUyxFQUFFLFVBQVUsR0FBRyxFQUFFO0lBQ3hCLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQztNQUM3QixVQUFVLEVBQUUsWUFBWSxDQUFDLFVBQVU7TUFDbkMsSUFBSSxFQUFFLEdBQUc7S0FDVixDQUFDLENBQUM7R0FDSjtBQUNILENBQUMsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLGNBQWMsQ0FBQzs7O0FDOUJoQyxJQUFJLFlBQVksR0FBRztFQUNqQixTQUFTLEVBQUUsV0FBVztFQUN0QixVQUFVLEVBQUUsWUFBWTtFQUN4QixZQUFZLEVBQUUsY0FBYztFQUM1QixVQUFVLEVBQUUsWUFBWTtBQUMxQixDQUFDLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxZQUFZLENBQUM7OztBQ1A5QixJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsVUFBVSxDQUFDO0FBQzVDLElBQUksYUFBYSxHQUFHLElBQUksVUFBVSxFQUFFLENBQUM7O0FBRXJDLGFBQWEsQ0FBQyxnQkFBZ0IsR0FBRyxTQUFTLE1BQU0sRUFBRTtFQUNoRCxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ1osTUFBTSxFQUFFLGFBQWE7SUFDckIsTUFBTSxFQUFFLE1BQU07R0FDZixDQUFDLENBQUM7QUFDTCxDQUFDOztBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUcsYUFBYSxDQUFDOzs7QUNWL0IsSUFBSSxlQUFlLEdBQUc7RUFDcEIsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQztFQUNwQixHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDO0VBQ3JCLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUM7RUFDbEIsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQztFQUNsQixHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDO0VBQ2hCLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUM7RUFDakIsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQztFQUNqQixHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDO0VBQ25CLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxXQUFXLENBQUM7RUFDdEIsR0FBRyxHQUFHLENBQUMsRUFBRSxFQUFFLFNBQVMsQ0FBQztFQUNyQixHQUFHLEdBQUcsQ0FBQyxFQUFFLEVBQUUsVUFBVSxDQUFDO0VBQ3RCLEdBQUcsR0FBRyxDQUFDLEVBQUUsRUFBRSxVQUFVLENBQUM7RUFDdEIsQ0FBQyxHQUFHLEtBQUs7RUFDVCxDQUFDLEdBQUcsS0FBSztFQUNULENBQUMsR0FBRyxLQUFLO0VBQ1QsQ0FBQyxHQUFHLEtBQUs7RUFDVCxDQUFDLEdBQUcsS0FBSztFQUNULENBQUMsR0FBRyxLQUFLO0VBQ1QsQ0FBQyxHQUFHLEtBQUs7RUFDVCxDQUFDLEdBQUcsS0FBSztFQUNULENBQUMsR0FBRyxLQUFLO0VBQ1QsRUFBRSxHQUFHLEtBQUs7RUFDVixFQUFFLEdBQUcsS0FBSztFQUNWLEVBQUUsR0FBRyxLQUFLO0FBQ1osQ0FBQzs7QUFFRCxJQUFJLGNBQWMsR0FBRyxZQUFZO0VBQy9CLElBQUksR0FBRyxHQUFHLFFBQVEsQ0FBQyxzQkFBc0IsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7RUFDcEUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUM7RUFDOUIsVUFBVSxDQUFDLFVBQVUsRUFBRSxHQUFHLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDbkUsQ0FBQzs7QUFFRCxJQUFJLFlBQVksR0FBRyxVQUFVLElBQUksRUFBRSxJQUFJLEVBQUU7RUFDdkMsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMvRCxDQUFDOztBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUc7RUFDZixlQUFlLEVBQUUsZUFBZTtFQUNoQyxjQUFjLEVBQUUsY0FBYztFQUM5QixZQUFZLEVBQUUsWUFBWTtDQUMzQjs7O0FDekNELElBQUkseUJBQXlCLG1CQUFBO0VBQzNCLE1BQU0sRUFBRSxZQUFZO0lBQ2xCO01BQ0Usb0JBQUEsS0FBSSxFQUFBLElBQUMsRUFBQTtRQUNGO1NBQ0EsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztXQUM1RCxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQVUsR0FBRyxFQUFFO1lBQ2pGLE9BQU8sb0JBQUEsR0FBRSxFQUFBLElBQUMsRUFBQyxHQUFHLENBQUMsS0FBVSxDQUFBO1lBQ3pCLENBQUM7V0FDRixJQUFJO1FBQ047TUFDRyxDQUFBO0tBQ1A7R0FDRjtBQUNILENBQUMsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLEdBQUcsQ0FBQzs7O0FDaEJyQixJQUFJLDRCQUE0QixzQkFBQTtFQUM5QixNQUFNLEVBQUUsWUFBWTtJQUNsQjtNQUNFLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsaUJBQWtCLENBQUEsRUFBQTtRQUMvQixvQkFBQSxJQUFHLEVBQUEsSUFBQyxFQUFBLGFBQWdCLENBQUE7TUFDaEIsQ0FBQTtLQUNQO0dBQ0Y7QUFDSCxDQUFDLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7OztBQ1Z4QixJQUFJLEdBQUcsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7O0FBRS9CLElBQUksMkJBQTJCLHFCQUFBO0VBQzdCLE1BQU0sRUFBRSxZQUFZO0lBQ2xCLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQztJQUNoQjtNQUNFLG9CQUFBLFNBQVEsRUFBQSxJQUFDLEVBQUE7UUFDUCxvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLGdCQUFpQixDQUFBLEVBQUE7VUFDOUIsb0JBQUEsUUFBTyxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxpQkFBQSxFQUFpQixDQUFDLE9BQUEsRUFBTyxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFlBQWMsQ0FBQSxFQUFBLE1BQWEsQ0FBQSxFQUFBO1VBQzVGLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsV0FBWSxDQUFBLEVBQUE7WUFDekIsb0JBQUEsSUFBRyxFQUFBLElBQUMsRUFBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxJQUFVLENBQUEsRUFBQTtZQUN2QyxvQkFBQSxJQUFHLEVBQUEsSUFBQyxFQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLElBQVUsQ0FBQTtVQUNuQyxDQUFBLEVBQUE7VUFDTixvQkFBQSxRQUFPLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLGlCQUFBLEVBQWlCLENBQUMsT0FBQSxFQUFPLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsWUFBYyxDQUFBLEVBQUEsU0FBZ0IsQ0FBQTtRQUMzRixDQUFBLEVBQUE7UUFDTixvQkFBQSxPQUFNLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLDBCQUEyQixDQUFBLEVBQUE7VUFDMUMsb0JBQUEsT0FBTSxFQUFBLElBQUMsRUFBQTtZQUNMLG9CQUFBLElBQUcsRUFBQSxJQUFDLEVBQUE7Y0FDRixvQkFBQSxJQUFHLEVBQUEsSUFBQyxFQUFBLFFBQVcsQ0FBQSxFQUFBLEdBQUEsRUFBQyxvQkFBQSxJQUFHLEVBQUEsSUFBQyxFQUFBLFFBQVcsQ0FBQSxFQUFBLEdBQUEsRUFBQyxvQkFBQSxJQUFHLEVBQUEsSUFBQyxFQUFBLFNBQVksQ0FBQSxFQUFBLEdBQUEsRUFBQyxvQkFBQSxJQUFHLEVBQUEsSUFBQyxFQUFBLFdBQWMsQ0FBQSxFQUFBLEdBQUEsRUFBQyxvQkFBQSxJQUFHLEVBQUEsSUFBQyxFQUFBLFVBQWEsQ0FBQSxFQUFBLEdBQUEsRUFBQyxvQkFBQSxJQUFHLEVBQUEsSUFBQyxFQUFBLFFBQVcsQ0FBQSxFQUFBLEdBQUEsRUFBQyxvQkFBQSxJQUFHLEVBQUEsSUFBQyxFQUFBLFVBQWEsQ0FBQTtZQUNwSCxDQUFBO1VBQ0MsQ0FBQSxFQUFBO1VBQ1Isb0JBQUEsT0FBTSxFQUFBLElBQUMsRUFBQTtZQUNKLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsU0FBUyxJQUFJLEVBQUU7Y0FDdEQ7Z0JBQ0Usb0JBQUEsSUFBRyxFQUFBLENBQUEsQ0FBQyxHQUFBLEVBQUcsQ0FBRSxJQUFNLENBQUEsRUFBQTtrQkFDWixJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUMsRUFBRTtvQkFDekIsT0FBTyxHQUFHLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQzt3QkFDdkQsb0JBQUEsSUFBRyxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxhQUFBLEVBQWEsQ0FBQyxHQUFBLEVBQUcsQ0FBRSxDQUFHLENBQUEsRUFBQTswQkFDbEMsb0JBQUEsR0FBRSxFQUFBLElBQUMsRUFBQSxvQkFBQSxHQUFFLEVBQUEsSUFBQyxFQUFDLEdBQVEsQ0FBSSxDQUFBLEVBQUE7MEJBQ25CLG9CQUFDLEdBQUcsRUFBQSxDQUFBLENBQUMsR0FBQSxFQUFHLENBQUUsR0FBRyxFQUFDLENBQUMsWUFBQSxFQUFZLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFhLENBQUEsQ0FBRyxDQUFBO3dCQUNyRCxDQUFBO3dCQUNMLG9CQUFBLElBQUcsRUFBQSxDQUFBLENBQUMsT0FBQSxFQUFPLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUMsQ0FBQyxHQUFBLEVBQUcsQ0FBRSxDQUFHLENBQUEsRUFBQTswQkFDcEUsb0JBQUEsR0FBRSxFQUFBLElBQUMsRUFBQSxvQkFBQSxHQUFFLEVBQUEsSUFBQyxFQUFDLEdBQVEsQ0FBSSxDQUFBLEVBQUE7MEJBQ25CLG9CQUFDLEdBQUcsRUFBQSxDQUFBLENBQUMsR0FBQSxFQUFHLENBQUUsR0FBRyxFQUFDLENBQUMsWUFBQSxFQUFZLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFhLENBQUEsQ0FBRyxDQUFBO3dCQUNyRCxDQUFBO21CQUNWLENBQUMsSUFBSSxDQUFFO2dCQUNMLENBQUE7Z0JBQ0w7YUFDSCxDQUFDLElBQUksQ0FBRTtVQUNGLENBQUE7UUFDRixDQUFBO01BQ0EsQ0FBQTtNQUNWO0dBQ0g7QUFDSCxDQUFDLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7OztBQzlDdkIsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ25DLElBQUksV0FBVyxHQUFHLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQy9DLElBQUksV0FBVyxHQUFHLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQy9DLElBQUksWUFBWSxHQUFHLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO0FBQ3hELElBQUksY0FBYyxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUM3QyxJQUFJLGNBQWMsR0FBRyxPQUFPLENBQUMsK0JBQStCLENBQUMsQ0FBQyxjQUFjLENBQUM7O0FBRTdFLElBQUksNkJBQTZCLHVCQUFBOztFQUUvQixlQUFlLEVBQUUsWUFBWTtJQUMzQixJQUFJLEdBQUcsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMzQyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2xELE9BQU87TUFDTCxZQUFZLEVBQUUsWUFBWSxDQUFDLGVBQWUsRUFBRTtLQUM3QztHQUNGO0VBQ0QsaUJBQWlCLEVBQUUsWUFBWTtJQUM3QixZQUFZLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0dBQ2hEO0VBQ0Qsb0JBQW9CLEVBQUUsWUFBWTtJQUNoQyxZQUFZLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0dBQ25EO0VBQ0QsUUFBUSxFQUFFO0lBQ1IsV0FBVyxHQUFHLFVBQVUsR0FBRyxFQUFFO01BQzNCLGNBQWMsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDakM7SUFDRCxZQUFZLEVBQUUsVUFBVSxDQUFDLEVBQUU7TUFDekIsY0FBYyxFQUFFLENBQUM7TUFDakIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLElBQUksU0FBUyxHQUFHLGNBQWMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsY0FBYyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUNwRztJQUNELFNBQVMsRUFBRSxVQUFVLENBQUMsRUFBRTtNQUN0QixjQUFjLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQzdCO0dBQ0Y7RUFDRCxTQUFTLEVBQUUsWUFBWTtJQUNyQixJQUFJLENBQUMsUUFBUSxDQUFDO01BQ1osWUFBWSxFQUFFLFlBQVksQ0FBQyxlQUFlLEVBQUU7S0FDN0MsQ0FBQztHQUNIO0VBQ0QsTUFBTSxFQUFFLFdBQVc7SUFDakI7TUFDRSxvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLGlDQUFrQyxDQUFBLEVBQUE7UUFDL0Msb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxpQkFBa0IsQ0FBQSxFQUFBO1VBQy9CLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsVUFBVyxDQUFBLEVBQUE7WUFDeEIsb0JBQUMsS0FBSyxFQUFBLENBQUEsQ0FBQyxZQUFBLEVBQVksQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksRUFBQyxDQUFDLFFBQUEsRUFBUSxDQUFFLElBQUksQ0FBQyxRQUFTLENBQUEsQ0FBRyxDQUFBO1VBQ3JFLENBQUEsRUFBQTtVQUNOLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsVUFBVyxDQUFBLEVBQUE7WUFDeEIsb0JBQUMsV0FBVyxFQUFBLENBQUEsQ0FBQyxZQUFBLEVBQVksQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksRUFBQyxDQUFDLFNBQUEsRUFBUyxDQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBVSxDQUFBLENBQUcsQ0FBQTtVQUN0RixDQUFBO1FBQ0YsQ0FBQTtNQUNGLENBQUE7TUFDTjtBQUNOLEdBQUc7O0FBRUgsQ0FBQyxDQUFDLENBQUM7QUFDSDs7QUFFQSxLQUFLLENBQUMsTUFBTSxDQUFDLG9CQUFDLE9BQU8sRUFBQSxJQUFBLENBQUcsQ0FBQSxFQUFFLFFBQVEsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQzs7O0FDekQxRCxJQUFJLGtDQUFrQywyQkFBQTtFQUNwQyxZQUFZLEVBQUUsWUFBWTtJQUN4QixJQUFJLElBQUksR0FBRyxRQUFRLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDbEQsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUM7TUFDbkIsR0FBRyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFdBQVcsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSztLQUM3SSxDQUFDLENBQUM7SUFDSCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtNQUNwQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztLQUN0QjtHQUNGO0VBQ0QsTUFBTSxFQUFFLFlBQVk7SUFDbEI7TUFDRSxvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLG1DQUFvQyxDQUFBLEVBQUE7UUFDakQsb0JBQUEsSUFBRyxFQUFBLElBQUMsRUFBQSxXQUFjLENBQUEsRUFBQTtRQUNsQixvQkFBQSxNQUFLLEVBQUEsSUFBQyxFQUFBO1VBQ0osb0JBQUEsT0FBTSxFQUFBLENBQUEsQ0FBQyxJQUFBLEVBQUksQ0FBQyxNQUFBLEVBQU0sQ0FBQyxXQUFBLEVBQVcsQ0FBQyxPQUFBLEVBQU8sQ0FBQyxJQUFBLEVBQUksQ0FBQyxVQUFXLENBQVEsQ0FBQSxFQUFBO1VBQy9ELG9CQUFBLE9BQU0sRUFBQSxDQUFBLENBQUMsSUFBQSxFQUFJLENBQUMsTUFBQSxFQUFNLENBQUMsV0FBQSxFQUFXLENBQUMsT0FBQSxFQUFPLENBQUMsSUFBQSxFQUFJLENBQUMsVUFBVyxDQUFRLENBQUEsRUFBQTtVQUMvRCxvQkFBQSxPQUFNLEVBQUEsQ0FBQSxDQUFDLElBQUEsRUFBSSxDQUFDLE1BQUEsRUFBTSxDQUFDLFdBQUEsRUFBVyxDQUFDLEtBQUEsRUFBSyxDQUFDLElBQUEsRUFBSSxDQUFDLFVBQVcsQ0FBUSxDQUFBLEVBQUE7VUFDN0Qsb0JBQUEsVUFBUyxFQUFBLENBQUEsQ0FBQyxZQUFBLEVBQVksQ0FBQyxhQUFBLEVBQWEsQ0FBQyxJQUFBLEVBQUksQ0FBQyxVQUFXLENBQVcsQ0FBQSxFQUFBO1VBQ2hFLG9CQUFBLE1BQUssRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsK0JBQUEsRUFBK0IsQ0FBQyxPQUFBLEVBQU8sQ0FBRSxJQUFJLENBQUMsWUFBYyxDQUFPLENBQUE7UUFDOUUsQ0FBQTtNQUNILENBQUE7S0FDUDtBQUNMLEdBQUc7O0FBRUgsQ0FBQyxDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsV0FBVzs7O0FDM0I1QixJQUFJLFdBQVcsR0FBRyxPQUFPLENBQUMsbUJBQW1CLENBQUMsQ0FBQztBQUMvQyxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUM7O0FBRXJDLElBQUksaUNBQWlDLDJCQUFBOztFQUVuQyxlQUFlLEVBQUUsWUFBWTtJQUMzQixPQUFPO01BQ0wsVUFBVSxFQUFFLElBQUk7TUFDaEIsWUFBWSxFQUFFLEtBQUs7TUFDbkIsVUFBVSxFQUFFLEtBQUs7S0FDbEI7R0FDRjtFQUNELFFBQVEsRUFBRTtJQUNSLFVBQVUsRUFBRSxZQUFZO01BQ3RCLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDWixVQUFVLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLElBQUk7T0FDakcsQ0FBQztLQUNIO0lBQ0QsWUFBWSxFQUFFLFlBQVk7TUFDeEIsSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUNaLFlBQVksRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEdBQUcsSUFBSTtPQUN6RyxDQUFDO0tBQ0g7QUFDTCxJQUFJLFVBQVUsRUFBRSxZQUFZOztLQUV2QjtHQUNGO0VBQ0QsTUFBTSxFQUFFLFlBQVk7SUFDbEI7TUFDRSxvQkFBQSxTQUFRLEVBQUEsSUFBQyxFQUFBO1FBQ1Asb0JBQUEsSUFBRyxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxZQUFhLENBQUEsRUFBQSxjQUFpQixDQUFBLEVBQUE7UUFDNUMsb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxlQUFnQixDQUFBLEVBQUE7VUFDN0Isb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxhQUFjLENBQUEsRUFBQTtZQUMzQixvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLE9BQUEsRUFBTyxDQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUcsQ0FBQSxFQUFBO2NBQ2pELG9CQUFBLE1BQUssRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUUsd0NBQXdDLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsUUFBUSxHQUFHLE9BQU8sQ0FBRyxDQUFPLENBQUEsRUFBQTtjQUNqSCxvQkFBQSxJQUFHLEVBQUEsSUFBQyxFQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxJQUFVLENBQUE7WUFDakgsQ0FBQSxFQUFBO1lBQ0wsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsb0JBQUMsV0FBVyxFQUFBLENBQUEsQ0FBQyxZQUFBLEVBQVksQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksRUFBQyxDQUFDLFNBQUEsRUFBUyxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBVSxDQUFBLENBQUcsQ0FBQSxHQUFHLElBQUs7VUFDcEgsQ0FBQSxFQUFBO1VBQ04sb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxhQUFjLENBQUEsRUFBQTtZQUMzQixvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLE9BQUEsRUFBTyxDQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUcsQ0FBQSxFQUFBO2NBQ25ELG9CQUFBLE1BQUssRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUUsd0NBQXdDLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEdBQUcsUUFBUSxHQUFHLE9BQU8sQ0FBRyxDQUFPLENBQUEsRUFBQTtjQUNuSCxvQkFBQSxJQUFHLEVBQUEsSUFBQyxFQUFBLFFBQVcsQ0FBQTtZQUNYLENBQUEsRUFBQTtZQUNMLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxHQUFHLG9CQUFDLE1BQU0sRUFBQSxDQUFBLENBQUMsWUFBQSxFQUFZLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFhLENBQUUsQ0FBQSxHQUFHLElBQUs7VUFDL0UsQ0FBQSxFQUFBO1VBQ04sb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxhQUFjLENBQUEsRUFBQTtZQUMzQixvQkFBQSxNQUFLLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLDZDQUE4QyxDQUFPLENBQUEsRUFBQTtZQUNyRSxvQkFBQSxJQUFHLEVBQUEsSUFBQyxFQUFBLFFBQVcsQ0FBQTtVQUNYLENBQUE7UUFDRixDQUFBO01BQ0UsQ0FBQTtLQUNYO0dBQ0Y7QUFDSCxDQUFDLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxXQUFXLENBQUM7OztBQ3hEN0IsSUFBSSxhQUFhLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDaEQsSUFBSSxZQUFZLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUM7QUFDOUMsSUFBSSxZQUFZLEdBQUcsT0FBTyxDQUFDLHlCQUF5QixDQUFDLENBQUM7QUFDdEQsSUFBSSxZQUFZLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLFlBQVksQ0FBQztBQUNsRCxJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDeEMsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLCtCQUErQixDQUFDLENBQUM7O0FBRXRELElBQUksWUFBWSxHQUFHLFFBQVEsQ0FBQzs7QUFFNUIsSUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDO0FBQ2YsSUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDOztBQUVqQixTQUFTLEtBQUssQ0FBQyxJQUFJLEVBQUU7RUFDbkIsSUFBSSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQy9DLElBQUksQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUNuRCxJQUFJLENBQUMsSUFBSSxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUM5QixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztFQUN4QixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7RUFDaEMsSUFBSSxDQUFDLEtBQUssR0FBRztJQUNYLE1BQU0sRUFBRSxFQUFFO0lBQ1YsS0FBSyxFQUFFLEVBQUU7R0FDVixDQUFDO0FBQ0osQ0FBQzs7QUFFRCxLQUFLLENBQUMsU0FBUyxDQUFDLFFBQVEsR0FBRyxZQUFZO0VBQ3JDLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxRQUFRLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbkosQ0FBQyxDQUFDOztBQUVGLElBQUksUUFBUSxHQUFHLFVBQVUsSUFBSSxFQUFFO0VBQzdCLE9BQU8sR0FBRyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztFQUMxQixPQUFPLENBQUMsUUFBUSxFQUFFLENBQUM7RUFDbkIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDNUYsQ0FBQzs7QUFFRCxJQUFJLFNBQVMsR0FBRyxVQUFVLFNBQVMsRUFBRTtFQUNuQyxHQUFHLFNBQVM7QUFDZCxJQUFJLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxHQUFHLEVBQUUsR0FBRyxVQUFVLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsVUFBVSxHQUFHLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7O0lBRWhILE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxVQUFVLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsVUFBVSxHQUFHLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7RUFDbEgsR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEIsSUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEdBQUcsRUFBRTtNQUN2RCxHQUFHLEdBQUcsQ0FBQyxRQUFRLEtBQUssVUFBVSxDQUFDLENBQUMsQ0FBQztRQUMvQixPQUFPLEdBQUcsQ0FBQztLQUNkLENBQUM7SUFDRixPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsR0FBRyxPQUFPLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUM5RyxNQUFNO0lBQ0wsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0dBQ2xFO0FBQ0gsQ0FBQzs7QUFFRCxJQUFJLFdBQVcsR0FBRyxVQUFVLE1BQU0sRUFBRTtFQUNsQyxPQUFPLENBQUMsV0FBVyxHQUFHLE1BQU0sQ0FBQztBQUMvQixDQUFDOztBQUVELElBQUksU0FBUyxHQUFHLFVBQVUsR0FBRyxFQUFFO0VBQzdCLE9BQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0VBQ2hILE9BQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQzFELENBQUM7O0FBRUQsSUFBSSxZQUFZLEdBQUcsWUFBWSxDQUFDLEVBQUUsRUFBRSxZQUFZLENBQUMsU0FBUyxFQUFFO0VBQzFELGlCQUFpQixFQUFFLFVBQVUsRUFBRSxFQUFFO0lBQy9CLElBQUksQ0FBQyxFQUFFLENBQUMsWUFBWSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0dBQzNCO0VBQ0Qsb0JBQW9CLEVBQUUsVUFBVSxFQUFFLEVBQUU7SUFDbEMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLEVBQUUsRUFBRSxDQUFDLENBQUM7R0FDdkM7RUFDRCxlQUFlLEVBQUUsWUFBWTtJQUMzQixPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQztJQUM1QixPQUFPLE9BQU8sQ0FBQztHQUNoQjtBQUNILENBQUMsQ0FBQyxDQUFDOztBQUVILGFBQWEsQ0FBQyxRQUFRLENBQUMsVUFBVSxPQUFPLEVBQUU7RUFDeEMsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQztFQUM1QixPQUFPLE1BQU0sQ0FBQyxVQUFVO0lBQ3RCLEtBQUssWUFBWSxDQUFDLFNBQVM7TUFDekIsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztNQUN0QixZQUFZLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO01BQ2hDLE1BQU07SUFDUixLQUFLLFlBQVksQ0FBQyxVQUFVO01BQzFCLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7TUFDdkIsWUFBWSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztNQUNoQyxNQUFNO0lBQ1IsS0FBSyxZQUFZLENBQUMsWUFBWTtNQUM1QixXQUFXLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO01BQ3pCLFlBQVksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7TUFDaEMsTUFBTTtJQUNSLEtBQUssWUFBWSxDQUFDLFVBQVU7TUFDMUIsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztNQUN2QixZQUFZLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ2xDO01BQ0UsT0FBTyxJQUFJLENBQUM7R0FDZjtBQUNILENBQUMsQ0FBQyxDQUFDOztBQUVILE1BQU0sQ0FBQyxPQUFPLEdBQUcsWUFBWSxDQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsbnVsbCwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG52YXIgc3BsaXRQYXRoUmUgPVxuICAgIC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xudmFyIHNwbGl0UGF0aCA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbn07XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IHNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG5cbiAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gcm9vdCArIGRpcjtcbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aChwYXRoKVsyXTtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBzcGxpdFBhdGgocGF0aClbM107XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsInZhciBmcyA9IHJlcXVpcmUoJ2ZzJyksXG4gICAgUGF0aCA9IHJlcXVpcmUoJ3BhdGgnKSxcbiAgICBQRUcgPSByZXF1aXJlKCdwZWdqcycpLFxuICAgIHBhcnNlciA9IFBFRy5idWlsZFBhcnNlcihmcy5yZWFkRmlsZVN5bmMoUGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJ2NsZHJQbHVyYWxSdWxlLnBlZ2pzJyksICd1dGYtOCcpKTtcblxuZnVuY3Rpb24gcmFuZ2VMaXN0VG9KYXZhU2NyaXB0QXN0KHJhbmdlTGlzdE5vZGUsIGxoc0phdmFTY3JpcHRBc3QsIHdpdGhpblNlbWFudGljcykge1xuICAgIHZhciBqYXZhU2NyaXB0QXN0LFxuICAgICAgICBzZWVuUmFuZ2UgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gcmFuZ2VMaXN0Tm9kZS5yYW5nZXMubGVuZ3RoIC0gMSA7IGkgPj0gMCA7IGkgLT0gMSkge1xuICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZUxpc3ROb2RlLnJhbmdlc1tpXSxcbiAgICAgICAgICAgIGl0ZW1KYXZhU2NyaXB0QXN0O1xuICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGl0ZW1KYXZhU2NyaXB0QXN0ID0gWydiaW5hcnknLCAnPT09JywgbGhzSmF2YVNjcmlwdEFzdCwgWydudW0nLCByYW5nZS52YWx1ZV1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcmFuZ2UudHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgICAgICAgc2VlblJhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIGl0ZW1KYXZhU2NyaXB0QXN0ID0gWydiaW5hcnknLCAnJiYnLCBbJ2JpbmFyeScsICc+PScsIGxoc0phdmFTY3JpcHRBc3QsIFsnbnVtJywgcmFuZ2UubWluLnZhbHVlXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWydiaW5hcnknLCAnPD0nLCBsaHNKYXZhU2NyaXB0QXN0LCBbJ251bScsIHJhbmdlLm1heC52YWx1ZV1dXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoamF2YVNjcmlwdEFzdCkge1xuICAgICAgICAgICAgamF2YVNjcmlwdEFzdCA9IFsnYmluYXJ5JywgJ3x8JywgaXRlbUphdmFTY3JpcHRBc3QsIGphdmFTY3JpcHRBc3RdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgamF2YVNjcmlwdEFzdCA9IGl0ZW1KYXZhU2NyaXB0QXN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzZWVuUmFuZ2UgJiYgIXdpdGhpblNlbWFudGljcykge1xuICAgICAgICBqYXZhU2NyaXB0QXN0ID0gWydiaW5hcnknLCAnJiYnLCBbJ2JpbmFyeScsICc9PT0nLCBsaHNKYXZhU2NyaXB0QXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbJ2NhbGwnLCBbJ2RvdCcsIFsnbmFtZScsICdNYXRoJ10sICdmbG9vciddLCBbbGhzSmF2YVNjcmlwdEFzdF1dXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgamF2YVNjcmlwdEFzdF07XG4gICAgfVxuICAgIHJldHVybiBqYXZhU2NyaXB0QXN0O1xufVxuXG5mdW5jdGlvbiBub2RlVG9KYXZhU2NyaXB0QXN0KG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHJldHVybiBbJ251bScsIG5vZGUudmFsdWVdO1xuICAgIGNhc2UgJ24nOlxuICAgIGNhc2UgJ2knOlxuICAgIGNhc2UgJ3YnOlxuICAgIGNhc2UgJ3cnOlxuICAgIGNhc2UgJ2YnOlxuICAgIGNhc2UgJ3QnOlxuICAgICAgICByZXR1cm4gWyduYW1lJywgbm9kZS50eXBlXTtcbiAgICBjYXNlICdpcyc6XG4gICAgICAgIHJldHVybiBbJ2JpbmFyeScsICc9PT0nXS5jb25jYXQobm9kZS5vcGVyYW5kcy5tYXAobm9kZVRvSmF2YVNjcmlwdEFzdCkpO1xuICAgIGNhc2UgJ2lzbm90JzpcbiAgICAgICAgcmV0dXJuIFsnYmluYXJ5JywgJyE9PSddLmNvbmNhdChub2RlLm9wZXJhbmRzLm1hcChub2RlVG9KYXZhU2NyaXB0QXN0KSk7XG4gICAgY2FzZSAnbW9kJzpcbiAgICAgICAgcmV0dXJuIFsnYmluYXJ5JywgJyUnXS5jb25jYXQobm9kZS5vcGVyYW5kcy5tYXAobm9kZVRvSmF2YVNjcmlwdEFzdCkpO1xuICAgIGNhc2UgJ2FuZCc6XG4gICAgICAgIHJldHVybiBbJ2JpbmFyeScsICcmJiddLmNvbmNhdChub2RlLm9wZXJhbmRzLm1hcChub2RlVG9KYXZhU2NyaXB0QXN0KSk7XG4gICAgY2FzZSAnb3InOlxuICAgICAgICByZXR1cm4gWydiaW5hcnknLCAnfHwnXS5jb25jYXQobm9kZS5vcGVyYW5kcy5tYXAobm9kZVRvSmF2YVNjcmlwdEFzdCkpO1xuICAgIGNhc2UgJ25vdCc6XG4gICAgICAgIHJldHVybiBbJ3VuYXJ5LXByZWZpeCcsICchJywgbm9kZVRvSmF2YVNjcmlwdEFzdChub2RlLm9wZXJhbmRzKV07XG4gICAgY2FzZSAnaXNub3QnOlxuICAgICAgICByZXR1cm4gWydiaW5hcnknLCAnIT09J10uY29uY2F0KG5vZGUub3BlcmFuZHMubWFwKG5vZGVUb0phdmFTY3JpcHRBc3QpKTtcbiAgICBjYXNlICd3aXRoaW4nOlxuICAgICAgICByZXR1cm4gcmFuZ2VMaXN0VG9KYXZhU2NyaXB0QXN0KG5vZGUub3BlcmFuZHNbMV0sIG5vZGVUb0phdmFTY3JpcHRBc3Qobm9kZS5vcGVyYW5kc1swXSksIHRydWUpO1xuICAgIGNhc2UgJ25vdHdpdGhpbic6XG4gICAgICAgIHJldHVybiBbJ3VuYXJ5LXByZWZpeCcsICchJywgcmFuZ2VMaXN0VG9KYXZhU2NyaXB0QXN0KG5vZGUub3BlcmFuZHNbMV0sIG5vZGVUb0phdmFTY3JpcHRBc3Qobm9kZS5vcGVyYW5kc1swXSksIHRydWUpXTtcbiAgICBjYXNlICdpbic6XG4gICAgICAgIHJldHVybiByYW5nZUxpc3RUb0phdmFTY3JpcHRBc3Qobm9kZS5vcGVyYW5kc1sxXSwgbm9kZVRvSmF2YVNjcmlwdEFzdChub2RlLm9wZXJhbmRzWzBdKSwgZmFsc2UpO1xuICAgIGNhc2UgJ25vdGluJzpcbiAgICAgICAgcmV0dXJuIFsndW5hcnktcHJlZml4JywgJyEnLCByYW5nZUxpc3RUb0phdmFTY3JpcHRBc3Qobm9kZS5vcGVyYW5kc1sxXSwgbm9kZVRvSmF2YVNjcmlwdEFzdChub2RlLm9wZXJhbmRzWzBdKSwgZmFsc2UpXTtcbiAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vZGVUb0phdmFTY3JpcHRBc3Q6IFVua25vd24gbm9kZSB0eXBlOiAnICsgbm9kZS50eXBlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyYXZlcnNlKG5vZGUsIGxhbWJkYSkge1xuICAgIGxhbWJkYShub2RlKTtcbiAgICBpZiAobm9kZS5vcGVyYW5kcykge1xuICAgICAgICBub2RlLm9wZXJhbmRzLmZvckVhY2goZnVuY3Rpb24gKG9wZXJhbmQpIHtcbiAgICAgICAgICAgIHRyYXZlcnNlKG9wZXJhbmQsIGxhbWJkYSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gQ2xkclBsdXJhbFJ1bGUoc3JjKSB7XG4gICAgdGhpcy50b3BMZXZlbE5vZGUgPSBwYXJzZXIucGFyc2Uoc3JjLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKS5yZXBsYWNlKC9cXHN7Mix9L2csICcgJykpO1xufVxuXG5DbGRyUGx1cmFsUnVsZS5wcm90b3R5cGUgPSB7XG4gICAgdG9KYXZhU2NyaXB0QXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBub2RlVG9KYXZhU2NyaXB0QXN0KHRoaXMudG9wTGV2ZWxOb2RlKTtcbiAgICB9LFxuXG4gICAgZWFjaE5vZGU6IGZ1bmN0aW9uIChsYW1iZGEpIHtcbiAgICAgICAgdHJhdmVyc2UodGhpcy50b3BMZXZlbE5vZGUsIGxhbWJkYSk7XG4gICAgfSxcblxuICAgIHVwZGF0ZUlzVXNlZEJ5VGVybTogZnVuY3Rpb24gKGlzVXNlZEJ5VGVybSkge1xuICAgICAgICB0aGlzLmVhY2hOb2RlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAoWydpJywgJ3YnLCAndycsICdmJywgJ3QnLCAnbiddLmluZGV4T2Yobm9kZS50eXBlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpc1VzZWRCeVRlcm1bbm9kZS50eXBlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXNVc2VkQnlUZXJtO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xkclBsdXJhbFJ1bGU7XG4iLCJ2YXIgQ2xkclBsdXJhbFJ1bGUgPSByZXF1aXJlKCcuL0NsZHJQbHVyYWxSdWxlJyksXG4gICAgY2xkclBsdXJhbFJ1bGVUZXJtRnVuY3Rpb25CeU5hbWUgPSByZXF1aXJlKCcuL2NsZHJQbHVyYWxSdWxlVGVybUZ1bmN0aW9uQnlOYW1lJyksXG4gICAgdWdsaWZ5SnMgPSByZXF1aXJlKCd1Z2xpZnktanMnKTtcblxuZnVuY3Rpb24gQ2xkclBsdXJhbFJ1bGVTZXQoKSB7XG4gICAgdGhpcy5jbGRyUGx1cmFsUnVsZUJ5Q291bnQgPSB7fTtcbn1cblxuQ2xkclBsdXJhbFJ1bGVTZXQucHJvdG90eXBlID0ge1xuICAgIGFkZFJ1bGU6IGZ1bmN0aW9uIChjbGRyUGx1cmFsUnVsZSwgY291bnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGRyUGx1cmFsUnVsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNsZHJQbHVyYWxSdWxlID0gY2xkclBsdXJhbFJ1bGUucmVwbGFjZSgvXFxzKkAoPzpkZWNpbWFsfGludGVnZXIpLiokLywgJycpO1xuICAgICAgICAgICAgLy8gU29tZSBjb3VudD1cIm90aGVyXCIgbm9kZXMgaW4gQ0xEUiAyNCsgY29uc2lzdCBwdXJlbHkgb2Ygc2FtcGxlIHRleHQuXG4gICAgICAgICAgICAvLyBEb24ndCBhZGQgdGhvc2UuXG4gICAgICAgICAgICBpZiAoY2xkclBsdXJhbFJ1bGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xkclBsdXJhbFJ1bGUgPSBuZXcgQ2xkclBsdXJhbFJ1bGUoY2xkclBsdXJhbFJ1bGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xkclBsdXJhbFJ1bGVCeUNvdW50W2NvdW50XSA9IGNsZHJQbHVyYWxSdWxlO1xuICAgIH0sXG5cbiAgICB0b0phdmFTY3JpcHRGdW5jdGlvbkJvZHlBc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlbWVudEFzdHMgPSBbXSxcbiAgICAgICAgICAgIGlzVXNlZEJ5VGVybSA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmNsZHJQbHVyYWxSdWxlQnlDb3VudCkuZm9yRWFjaChmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgICAgIHZhciBjbGRyUGx1cmFsUnVsZSA9IHRoaXMuY2xkclBsdXJhbFJ1bGVCeUNvdW50W2NvdW50XTtcbiAgICAgICAgICAgIGNsZHJQbHVyYWxSdWxlLnVwZGF0ZUlzVXNlZEJ5VGVybShpc1VzZWRCeVRlcm0pO1xuICAgICAgICAgICAgc3RhdGVtZW50QXN0cy5wdXNoKFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgJ2lmJyxcbiAgICAgICAgICAgICAgICAgICAgY2xkclBsdXJhbFJ1bGUudG9KYXZhU2NyaXB0QXN0KCksXG4gICAgICAgICAgICAgICAgICAgIFsncmV0dXJuJywgWydzdHJpbmcnLCBjb3VudF1dXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHN0YXRlbWVudEFzdHMucHVzaChbJ3JldHVybicsIFsnc3RyaW5nJywgJ290aGVyJ11dKTtcbiAgICAgICAgdmFyIHZhckFzdHMgPSBbXTtcblxuICAgICAgICBbJ2knLCAndicsICd3JywgJ2YnLCAndCddLmZvckVhY2goZnVuY3Rpb24gKHRlcm0pIHtcbiAgICAgICAgICAgIGlmIChpc1VzZWRCeVRlcm1bdGVybV0pIHtcbiAgICAgICAgICAgICAgICB2YXJBc3RzLnB1c2goW3Rlcm0sIHVnbGlmeUpzLnBhcnNlci5wYXJzZShjbGRyUGx1cmFsUnVsZVRlcm1GdW5jdGlvbkJ5TmFtZVt0ZXJtXS50b1N0cmluZygpKVsxXVswXVszXVswXVsxXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoaXNVc2VkQnlUZXJtKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHN0YXRlbWVudEFzdHMudW5zaGlmdChcbiAgICAgICAgICAgICAgICAvLyBpZiAodHlwZW9mIG4gPT09ICdzdHJpbmcnKSBuID0gcGFyc2VJbnQobiwgMTApO1xuICAgICAgICAgICAgICAgIFsgJ2lmJyxcbiAgICAgICAgICAgICAgICAgICAgICBbICdiaW5hcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJz09PScsXG4gICAgICAgICAgICAgICAgICAgICAgICBbICd1bmFyeS1wcmVmaXgnLCAndHlwZW9mJywgWyAnbmFtZScsICduJyBdIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbICdzdHJpbmcnLCAnc3RyaW5nJyBdIF0sXG4gICAgICAgICAgICAgICAgICAgICAgWyAnc3RhdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBbICdhc3NpZ24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBbICduYW1lJywgJ24nIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFsgJ2NhbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgJ25hbWUnLCAncGFyc2VJbnQnIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBbICduYW1lJywgJ24nIF0sIFsgJ251bScsIDEwIF0gXSBdIF0gXSxcbiAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQgXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YXJBc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHN0YXRlbWVudEFzdHMudW5zaGlmdChbJ3ZhcicsIHZhckFzdHNdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGVtZW50QXN0cztcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsZHJQbHVyYWxSdWxlU2V0O1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbmZ1bmN0aW9uIENsZHJSYm5mUnVsZVNldChjb25maWcpIHtcbiAgICBfLmV4dGVuZCh0aGlzLCBjb25maWcpO1xuICAgIHRoaXMucnVsZUJ5VmFsdWUgPSB7fTtcbn1cblxuQ2xkclJibmZSdWxlU2V0LmdldFNhZmVSZW5kZXJlck5hbWUgPSBmdW5jdGlvbiAocmVuZGVyZXJOYW1lKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgKFwicmVuZGVyLVwiICsgcmVuZGVyZXJOYW1lKVxuICAgICAgICAucmVwbGFjZSgvW15cXHctXS9nLCAnLScpXG4gICAgICAgIC5yZXBsYWNlKC9bLV9dKyhbMC05YS16XSkvZ2ksIGZ1bmN0aW9uICgkMCwgY2gpIHtcbiAgICAgICAgICAgIHJldHVybiBjaC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9KVxuICAgICAgICAucmVwbGFjZSgnR1JFRUtOVU1FUkFMTUFKVVNDVUxFUycsICdHcmVla051bWVyYWxNYWp1c2N1bGVzJylcbiAgICApO1xufTtcblxuQ2xkclJibmZSdWxlU2V0LnByb3RvdHlwZSA9IHtcbiAgICB0b0Z1bmN0aW9uQXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIGlzU2VlbkJ5UnVsZVNldFR5cGUgPSB7fTtcblxuICAgICAgICBmdW5jdGlvbiBydWxlVG9FeHByZXNzaW9uQXN0KHJ1bGUpIHtcbiAgICAgICAgICAgIHZhciBleHByZXNzaW9uQXN0cyA9IFtdLFxuICAgICAgICAgICAgICAgIHJibmYgPSBydWxlLnJibmY7XG5cbiAgICAgICAgICAgIC8vIFwiSWYgYSBydWxlIGJvZHkgYmVnaW5zIHdpdGggYW4gYXBvc3Ryb3BoZSwgdGhlIGFwb3N0cm9waGUgaXMgaWdub3JlZCwgYnV0IGFsbCB0ZXh0IGFmdGVyIGl0IGJlY29tZXNcbiAgICAgICAgICAgIC8vIHNpZ25pZmljYW50ICh0aGlzIGlzIGhvdyB5b3UgY2FuIGhhdmUgYSBydWxlJ3MgcnVsZSB0ZXh0IGJlZ2luIHdpdGggd2hpdGVzcGFjZSkuXCJcbiAgICAgICAgICAgIC8vIC0tIGh0dHA6Ly93d3cuaWN1LXByb2plY3Qub3JnL2FwaXJlZi9pY3U0Yy9jbGFzc1J1bGVCYXNlZE51bWJlckZvcm1hdC5odG1sXG4gICAgICAgICAgICByYm5mID0gcmJuZi5yZXBsYWNlKC9eJy8sICcnKTtcblxuICAgICAgICAgICAgdmFyIHJhZGl4ID0gcnVsZS5yYWRpeCB8fCAxMDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0RGl2aXNvcigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGl2aXNvciA9IDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEwICogZGl2aXNvciA8PSBwYXJzZUludChydWxlLnZhbHVlLCAxMCkpIHsgLy8gSW5lZmZpY2llbnQsIGJ1dCB3b24ndCBzdWZmZXIgZnJvbSBNYXRoLmxvZyByb3VuZGluZyBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgZGl2aXNvciAqPSAxMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlcGxhY2UgaXMgdXNlZCBmb3IgdG9rZW5pemF0aW9uLCB0aGUgcmV0dXJuIHZhbHVlIGlzbid0IHVzZWQ6XG4gICAgICAgICAgICByYm5mLnJlcGxhY2UoLyg/OihbXFw8XFw+XFw9XSkoPzooJSU/W1xcd1xcLV0rKXwoWyMsMC5dKykpP1xcMSl8KD86XFxbKFteXFxdXSspXFxdKXwoW1xceDdmLVxcdWZmZmY6J1xcLlxcc1xcd1xcZFxcLV0rKS9naSwgZnVuY3Rpb24gKCQwLCBzcGVjaWFsQ2hhciwgb3RoZXJGb3JtYXQsIGRlY2ltYWxGb3JtYXQsIG9wdGlvbmFsLCBsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG1lYW5pbmdzIG9mIHRoZSBzdWJzdGl0dXRpb24gdG9rZW4gY2hhcmFjdGVycyBhcmUgYXMgZm9sbG93czpcbiAgICAgICAgICAgICAgICBpZiAoc3BlY2lhbENoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGVjaWFsQ2hhciA9PT0gJzwnKSB7IC8vIDw8XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoL15cXGQrJC8udGVzdChydWxlLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIG5vcm1hbCBydWxlOiBEaXZpZGUgdGhlIG51bWJlciBieSB0aGUgcnVsZSdzIGRpdmlzb3IgYW5kIGZvcm1hdCB0aGUgcXVvdGllbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gWydjYWxsJywgWydkb3QnLCBbJ25hbWUnLCAnTWF0aCddLCAnZmxvb3InXSwgW1snYmluYXJ5JywgJy8nLCBbJ25hbWUnLCAnbiddLCBbJ251bScsIGdldERpdmlzb3IoKV1dXV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJ1bGUudmFsdWUgPT09ICcteCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzw8IG5vdCBhbGxvd2VkIGluIG5lZ2F0aXZlIG51bWJlciBydWxlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIGZyYWN0aW9uIG9yIG1hc3RlciBydWxlOiBJc29sYXRlIHRoZSBudW1iZXIncyBpbnRlZ3JhbCBwYXJ0IGFuZCBmb3JtYXQgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IFsnY2FsbCcsIFsnZG90JywgWyduYW1lJywgJ01hdGgnXSwgJ2Zsb29yJ10sIFtbJ25hbWUnLCAnbiddXV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY2lhbENoYXIgPT09ICc+JykgeyAvLyA+PlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9cXC4vLnRlc3QocnVsZS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGcmFjdGlvbiBvciBtYXN0ZXIgcnVsZSA9PiBwYXJzZUludChTdHJpbmcobikucmVwbGFjZSgvXFxkKlxcLi8sICcnKSwgMTApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IFsnY2FsbCcsIFsnbmFtZScsICdwYXJzZUludCddLCBbWydjYWxsJywgWydkb3QnLCBbJ2NhbGwnLCBbJ25hbWUnLCAnU3RyaW5nJ10sIFtbJ25hbWUnLCAnbiddXV0sICdyZXBsYWNlJ10sIFtbJ3JlZ2V4cCcsICdcXFxcZCpcXFxcLicsICcnXSwgWydzdHJpbmcnLCAnJ11dXSwgWydudW0nLCAxMF1dXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocnVsZS52YWx1ZSA9PT0gJy14Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSBbJ3VuYXJ5LXByZWZpeCcsICctJywgWyduYW1lJywgJ24nXV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSBbJ2JpbmFyeScsICclJywgWyduYW1lJywgJ24nXSwgWydudW0nLCBnZXREaXZpc29yKCldXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzcGVjaWFsQ2hhciA9PT0gJz0nKSB7IC8vID09XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByID0gWyduYW1lJywgJ24nXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogPj4+IG5vdCBzdXBwb3J0ZWRcblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc3Vic3RpdHV0aW9uIGRlc2NyaXB0b3IgKGkuZS4sIHRoZSB0ZXh0IGJldHdlZW4gdGhlIHRva2VuIGNoYXJhY3RlcnMpIG1heSB0YWtlIG9uZSBvZiB0aHJlZSBmb3JtczpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyRm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHJ1bGUgc2V0IG5hbWU6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIHRoZSBtYXRoZW1hdGljYWwgb3BlcmF0aW9uIG9uIHRoZSBudW1iZXIsIGFuZCBmb3JtYXQgdGhlIHJlc3VsdCB1c2luZyB0aGUgbmFtZWQgcnVsZSBzZXQuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJGb3JtYXROYW1lID0gQ2xkclJibmZSdWxlU2V0LmdldFNhZmVSZW5kZXJlck5hbWUob3RoZXJGb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNTZWVuQnlSdWxlU2V0VHlwZVtvdGhlckZvcm1hdE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFR1cm4gaW50byB0aGlzLjxvdGhlckZvcm1hdE5hbWU+KDxleHByPilcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25Bc3RzLnB1c2goWydjYWxsJywgWydkb3QnLCBbJ25hbWUnLCAndGhpcyddLCBvdGhlckZvcm1hdE5hbWVdLCBbZXhwcl1dKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZWNpbWFsRm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBIERlY2ltYWxGb3JtYXQgcGF0dGVybjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gdGhlIG1hdGhlbWF0aWNhbCBvcGVyYXRpb24gb24gdGhlIG51bWJlciwgYW5kIGZvcm1hdCB0aGUgcmVzdWx0IHVzaW5nIGEgRGVjaW1hbEZvcm1hdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCB0aGUgc3BlY2lmaWVkIHBhdHRlcm4uIFRoZSBwYXR0ZXJuIG11c3QgYmVnaW4gd2l0aCAwIG9yICMuXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uQXN0cy5wdXNoKFsnY2FsbCcsIFsnZG90JywgWyduYW1lJywgJ3RoaXMnXSwgJ3JlbmRlck51bWJlciddLCBbZXhwciwgWydzdHJpbmcnLCBkZWNpbWFsRm9ybWF0XV1dKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGhpbmc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BlY2lhbENoYXIgPT09ICc+Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHlvdSBvbWl0IHRoZSBzdWJzdGl0dXRpb24gZGVzY3JpcHRvciBpbiBhID4+IHN1YnN0aXR1dGlvbiBpbiBhIGZyYWN0aW9uIHJ1bGUsIGZvcm1hdCB0aGUgcmVzdWx0IG9uZSBkaWdpdCBhdCBhIHRpbWUgdXNpbmcgdGhlIHJ1bGUgc2V0IGNvbnRhaW5pbmcgdGhlIGN1cnJlbnQgcnVsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uQXN0cy5wdXNoKFsnY2FsbCcsIFsnZG90JywgWyduYW1lJywgJ3RoaXMnXSwgdGhhdC50eXBlXSwgW2V4cHJdXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNpYWxDaGFyID09PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB5b3Ugb21pdCB0aGUgc3Vic3RpdHV0aW9uIGRlc2NyaXB0b3IgaW4gYSA8PCBzdWJzdGl0dXRpb24gaW4gYSBydWxlIGluIGEgZnJhY3Rpb24gcnVsZSBzZXQsIGZvcm1hdCB0aGUgcmVzdWx0IHVzaW5nIHRoZSBkZWZhdWx0IHJ1bGUgc2V0IGZvciB0aGlzIHJlbmRlcmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBTaG91bGQgYmUgdGhlIGRlZmF1bHQgcnVsZSBzZXQgZm9yIHRoaXMgcmVuZGVyZXIhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbkFzdHMucHVzaChbJ2NhbGwnLCBbJ2RvdCcsIFsnbmFtZScsICd0aGlzJ10sIHRoYXQudHlwZV0sIFtleHByXV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJz09IG5vdCBzdXBwb3J0ZWQhJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9uYWwpIHsgLy8gWyAuLi4gXVxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9uYWxSdWxlRXhwcmVzc2lvbkFzdCA9IHJ1bGVUb0V4cHJlc3Npb25Bc3Qoe3JhZGl4OiBydWxlLnJhZGl4LCByYm5mOiBvcHRpb25hbCwgdmFsdWU6IHJ1bGUudmFsdWV9KTtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbkFzdHMucHVzaChbJ2NvbmRpdGlvbmFsJywgWydiaW5hcnknLCAnPT09JywgWyduYW1lJywgJ24nXSwgWydudW0nLCBwYXJzZUludChydWxlLnZhbHVlLCAxMCldXSwgWydzdHJpbmcnLCAnJ10sIG9wdGlvbmFsUnVsZUV4cHJlc3Npb25Bc3RdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbkFzdHMucHVzaChbJ3N0cmluZycsIGxpdGVyYWxdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHRva2VuIGluIFwiICsgcnVsZS5yYm5mKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChleHByZXNzaW9uQXN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uQXN0cyA9IFtbJ3N0cmluZycsICcnXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXhwcmVzc2lvbkFzdCA9IGV4cHJlc3Npb25Bc3RzLnNoaWZ0KCk7XG4gICAgICAgICAgICB3aGlsZSAoZXhwcmVzc2lvbkFzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25Bc3QgPSBbJ2JpbmFyeScsICcrJywgZXhwcmVzc2lvbkFzdCwgZXhwcmVzc2lvbkFzdHMuc2hpZnQoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbkFzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbmRpdGlvblRvU3RhdGVtZW50QXN0KGNvbmRpdGlvbkFzdCwgcnVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIFsnaWYnLCBjb25kaXRpb25Bc3QsIFsncmV0dXJuJywgcnVsZVRvRXhwcmVzc2lvbkFzdChydWxlKV0sIG51bGxdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXRlbWVudEFzdHMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMucnVsZUJ5VmFsdWVbJ3guMCddIHx8IHRoaXMucnVsZUJ5VmFsdWVbJ3gueCddKSB7XG4gICAgICAgICAgICAvLyB2YXIgaXNGcmFjdGlvbmFsID0gbiAhPT0gTWF0aC5mbG9vcihuKTtcbiAgICAgICAgICAgIHN0YXRlbWVudEFzdHMucHVzaChbJ3ZhcicsIFtbJ2lzRnJhY3Rpb25hbCcsIFsnYmluYXJ5JywgJyE9PScsIFsnbmFtZScsICduJ10sIFsnY2FsbCcsIFsnZG90JywgWyduYW1lJywgJ01hdGgnXSwgJ2Zsb29yJ10sIFtbJ25hbWUnLCAnbiddXV1dXV1dKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ydWxlQnlWYWx1ZVsneC4wJ10pIHtcbiAgICAgICAgICAgIHN0YXRlbWVudEFzdHMucHVzaChjb25kaXRpb25Ub1N0YXRlbWVudEFzdChbJ25hbWUnLCAnaXNGcmFjdGlvbmFsJ10sIHRoaXMucnVsZUJ5VmFsdWVbJ3guMCddKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucnVsZUJ5VmFsdWVbJy14J10pIHtcbiAgICAgICAgICAgIHN0YXRlbWVudEFzdHMucHVzaChjb25kaXRpb25Ub1N0YXRlbWVudEFzdChbJ2JpbmFyeScsICc8JywgWyduYW1lJywgJ24nXSwgWydudW0nLCAwXV0sIHRoaXMucnVsZUJ5VmFsdWVbJy14J10pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ydWxlQnlWYWx1ZVsneC54J10pIHtcbiAgICAgICAgICAgIHN0YXRlbWVudEFzdHMucHVzaChjb25kaXRpb25Ub1N0YXRlbWVudEFzdChbJ2JpbmFyeScsICcmJicsIFsnbmFtZScsICdpc0ZyYWN0aW9uYWwnXSwgWydiaW5hcnknLCAnPicsIFsnbmFtZScsICduJ10sIFsnbnVtJywgMV1dXSwgdGhpcy5ydWxlQnlWYWx1ZVsneC54J10pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ydWxlQnlWYWx1ZVsnMC54J10pIHtcbiAgICAgICAgICAgIHN0YXRlbWVudEFzdHMucHVzaChjb25kaXRpb25Ub1N0YXRlbWVudEFzdChbJ2JpbmFyeScsICcmJicsIFsnYmluYXJ5JywgJz4nLCBbJ25hbWUnLCAnbiddLCBbJ251bScsIDBdXSwgWydiaW5hcnknLCAnPCcsIFsnbmFtZScsICduJ10sIFsnbnVtJywgMV1dXSwgdGhpcy5ydWxlQnlWYWx1ZVsnMC54J10pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMucnVsZUJ5VmFsdWUpLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAvXlxcZCskLy50ZXN0KHZhbHVlKTtcbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiIC0gYTtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAobnVtZXJpY2FsVmFsdWUpIHtcbiAgICAgICAgICAgIHN0YXRlbWVudEFzdHMucHVzaChjb25kaXRpb25Ub1N0YXRlbWVudEFzdChbJ2JpbmFyeScsICc+PScsIFsnbmFtZScsICduJ10sIFsnbnVtJywgbnVtZXJpY2FsVmFsdWVdXSwgdGhpcy5ydWxlQnlWYWx1ZVtudW1lcmljYWxWYWx1ZV0pKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHtmdW5jdGlvbkFzdDogWydmdW5jdGlvbicsIG51bGwsIFsnbiddLCBzdGF0ZW1lbnRBc3RzXSwgZGVwZW5kZW5jaWVzOiBPYmplY3Qua2V5cyhpc1NlZW5CeVJ1bGVTZXRUeXBlKX07XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGRyUmJuZlJ1bGVTZXQ7XG4iLCJ2YXIgUGF0aCA9IHJlcXVpcmUoJ3BhdGgnKSxcbiAgICBmcyA9IHJlcXVpcmUoJ2ZzJyksXG4gICAgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKSxcbiAgICBwYXNzRXJyb3IgPSByZXF1aXJlKCdwYXNzZXJyb3InKSxcbiAgICBtZW1vaXplQXN5bmMgPSByZXF1aXJlKCcuL21lbW9pemVBc3luYycpLFxuICAgIGRvbSA9IHJlcXVpcmUoJ3htbGRvbScpLkRPTVBhcnNlcixcbiAgICB4cGF0aCA9IHJlcXVpcmUoJ3hwYXRoJyksXG4gICAgc2VxID0gcmVxdWlyZSgnc2VxJyksXG4gICAgbm9ybWFsaXplTG9jYWxlSWQgPSByZXF1aXJlKCcuL25vcm1hbGl6ZUxvY2FsZUlkJyksXG4gICAgbm9ybWFsaXplUHJvcGVydHkgPSByZXF1aXJlKCcuL25vcm1hbGl6ZVByb3BlcnR5JyksXG4gICAgY29udmVydE9iamVjdHNXaXRoSW50ZWdlcktleXNUb0FycmF5cyA9IHJlcXVpcmUoJy4vY29udmVydE9iamVjdHNXaXRoSW50ZWdlcktleXNUb0FycmF5cycpLFxuICAgIENsZHJQbHVyYWxSdWxlU2V0ID0gcmVxdWlyZSgnLi9DbGRyUGx1cmFsUnVsZVNldCcpLFxuICAgIENsZHJSYm5mUnVsZVNldCA9IHJlcXVpcmUoJy4vQ2xkclJibmZSdWxlU2V0JyksXG4gICAgdWdsaWZ5SnMgPSByZXF1aXJlKCd1Z2xpZnktanMnKSxcbiAgICB1bmljb2RlcmVnZXhwID0gcmVxdWlyZSgndW5pY29kZXJlZ2V4cCcpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVYUGF0aFF1ZXJ5KHhwYXRoUXVlcnkpIHtcbiAgICB2YXIgeHBhdGhRdWVyeUZyYWdtZW50cyA9IHhwYXRoUXVlcnkuc3BsaXQoJy8nKTtcbiAgICBmb3IgKHZhciBpID0gMCA7IGkgPCB4cGF0aFF1ZXJ5RnJhZ21lbnRzLmxlbmd0aCA7IGkgKz0gMSkge1xuICAgICAgICBpZiAoaSA+IDAgJiYgeHBhdGhRdWVyeUZyYWdtZW50c1tpXSA9PT0gJy4uJyAmJiB4cGF0aFF1ZXJ5RnJhZ21lbnRzW2kgLSAxXSAhPT0gJy4uJykge1xuICAgICAgICAgICAgeHBhdGhRdWVyeUZyYWdtZW50cy5zcGxpY2UoaSAtIDEsIDIpO1xuICAgICAgICAgICAgaSAtPSAyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4cGF0aFF1ZXJ5RnJhZ21lbnRzLmpvaW4oJy8nKTtcbn1cblxuZnVuY3Rpb24gZXhwYW5kTG9jYWxlSWRUb1ByaW9yaXRpemVkTGlzdChsb2NhbGVJZCkge1xuICAgIGxvY2FsZUlkID0gbm9ybWFsaXplTG9jYWxlSWQobG9jYWxlSWQpO1xuICAgIGlmICghbG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB2YXIgbG9jYWxlSWRzID0gW2xvY2FsZUlkXTtcbiAgICB3aGlsZSAoL19bXl9dKyQvLnRlc3QobG9jYWxlSWQpKSB7XG4gICAgICAgIGxvY2FsZUlkID0gbG9jYWxlSWQucmVwbGFjZSgvX1teX10rJC8sICcnKTtcbiAgICAgICAgbG9jYWxlSWRzLnB1c2gobG9jYWxlSWQpO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlSWRzO1xufVxuXG5mdW5jdGlvbiBDbGRyKGNsZHJQYXRoKSB7XG4gICAgLy8gU3VwcG9ydCBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIG9wZXJhdG9yOlxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDbGRyKSkge1xuICAgICAgICByZXR1cm4gbmV3IENsZHIoY2xkclBhdGgpO1xuICAgIH1cbiAgICB0aGlzLmNsZHJQYXRoID0gY2xkclBhdGg7XG4gICAgdGhpcy5kb2N1bWVudEJ5RmlsZU5hbWUgPSB7fTtcbiAgICB0aGlzLm1lbW9pemVyQnlGaWxlTmFtZSA9IHt9O1xufVxuXG5DbGRyLnByb3RvdHlwZSA9IHtcbiAgICBnZXQgZmlsZU5hbWVzQnlUeXBlQW5kTm9ybWFsaXplZExvY2FsZUlkKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2ZpbGVOYW1lc0J5VHlwZUFuZE5vcm1hbGl6ZWRMb2NhbGVJZCkge1xuICAgICAgICAgICAgdGhpcy5fZmlsZU5hbWVzQnlUeXBlQW5kTm9ybWFsaXplZExvY2FsZUlkID0ge307XG4gICAgICAgICAgICBbJ21haW4nLCAncmJuZiddLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxlTmFtZXNCeVR5cGVBbmROb3JtYWxpemVkTG9jYWxlSWRbdHlwZV0gPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWVzO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lcyA9IGZzLnJlYWRkaXJTeW5jKFBhdGgucmVzb2x2ZSh0aGlzLmNsZHJQYXRoLCBcImNvbW1vblwiLCB0eXBlKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlyZWN0b3J5IGRvZXNuJ3QgZXhpc3QsIGp1c3QgcHJldGVuZCBpdCdzIGVtcHR5LlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hGaWxlTmFtZSA9IGZpbGVOYW1lLm1hdGNoKC9eKC4qKVxcLnhtbCQvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoRmlsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGVOYW1lc0J5VHlwZUFuZE5vcm1hbGl6ZWRMb2NhbGVJZFt0eXBlXVtub3JtYWxpemVMb2NhbGVJZChtYXRjaEZpbGVOYW1lWzFdKV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBhdGgucmVzb2x2ZSh0aGlzLmNsZHJQYXRoLCBcImNvbW1vblwiLCB0eXBlLCBmaWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9maWxlTmFtZXNCeVR5cGVBbmROb3JtYWxpemVkTG9jYWxlSWQ7XG4gICAgfSxcblxuICAgIGdldCBsb2NhbGVJZHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9jYWxlSWRzKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGVJZHMgPSBPYmplY3Qua2V5cyh0aGlzLmZpbGVOYW1lc0J5VHlwZUFuZE5vcm1hbGl6ZWRMb2NhbGVJZC5tYWluKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlSWRzO1xuICAgIH0sXG5cbiAgICBnZXQgY2FsZW5kYXJJZHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FsZW5kYXJJZHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGVuZGFySWRzID0gW107XG4gICAgICAgICAgICB4cGF0aC5zZWxlY3QoJy9sZG1sQkNQNDcva2V5d29yZC9rZXlbQG5hbWU9XCJjYVwiXS90eXBlJywgdGhpcy5nZXREb2N1bWVudChQYXRoLnJlc29sdmUodGhpcy5jbGRyUGF0aCwgJ2NvbW1vbicsICdiY3A0NycsICdjYWxlbmRhci54bWwnKSkpLmZvckVhY2goZnVuY3Rpb24gKGtleU5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FsZW5kYXJJZCA9IGtleU5vZGUuZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGVuZGFySWQgPT09ICdncmVnb3J5Jykge1xuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhcklkID0gJ2dyZWdvcmlhbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGVuZGFySWRzLnB1c2goY2FsZW5kYXJJZCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FsZW5kYXJJZHM7XG4gICAgfSxcblxuICAgIGdldCBudW1iZXJTeXN0ZW1JZHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbnVtYmVyU3lzdGVtSWRzKSB7XG4gICAgICAgICAgICB0aGlzLl9udW1iZXJTeXN0ZW1JZHMgPSBbXTtcbiAgICAgICAgICAgIHhwYXRoLnNlbGVjdCgnL2xkbWxCQ1A0Ny9rZXl3b3JkL2tleVtAbmFtZT1cIm51XCJdL3R5cGUnLCB0aGlzLmdldERvY3VtZW50KFBhdGgucmVzb2x2ZSh0aGlzLmNsZHJQYXRoLCAnY29tbW9uJywgJ2JjcDQ3JywgJ251bWJlci54bWwnKSkpLmZvckVhY2goZnVuY3Rpb24gKGtleU5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9udW1iZXJTeXN0ZW1JZHMucHVzaChrZXlOb2RlLmdldEF0dHJpYnV0ZSgnbmFtZScpKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9udW1iZXJTeXN0ZW1JZHM7XG4gICAgfSxcblxuICAgIC8vIFdvcmtzIGJvdGggYXN5bmMgYW5kIHN5bmMgKG9taXQgY2IpOlxuICAgIGdldERvY3VtZW50OiBmdW5jdGlvbiAoZmlsZU5hbWUsIGNiKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgaWYgKHRoYXQuZG9jdW1lbnRCeUZpbGVOYW1lW2ZpbGVOYW1lXSkge1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIHRoYXQuZG9jdW1lbnRCeUZpbGVOYW1lW2ZpbGVOYW1lXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmRvY3VtZW50QnlGaWxlTmFtZVtmaWxlTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgbm90IHRvIGxvYWQgZmlsZSBtb3JlIHRoYW4gb25jZSBpZiBpdCdzIGJlaW5nIGxvYWRlZCB3aGVuIGdldERvY3VtZW50IGlzIGNhbGxlZCBmb3IgdGhlIHNlY29uZCB0aW1lOlxuICAgICAgICAgICAgICAgIHRoYXQubWVtb2l6ZXJCeUZpbGVOYW1lW2ZpbGVOYW1lXSA9IHRoYXQubWVtb2l6ZXJCeUZpbGVOYW1lW2ZpbGVOYW1lXSB8fCBtZW1vaXplQXN5bmMoZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZzLnJlYWRGaWxlKGZpbGVOYW1lLCAndXRmLTgnLCBwYXNzRXJyb3IoY2IsIGZ1bmN0aW9uICh4bWxTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb2N1bWVudCA9IG5ldyBkb20oKS5wYXJzZUZyb21TdHJpbmcoeG1sU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZG9jdW1lbnRCeUZpbGVOYW1lW2ZpbGVOYW1lXSA9IGRvY3VtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IobnVsbCwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhhdC5tZW1vaXplckJ5RmlsZU5hbWVbZmlsZU5hbWVdKGNiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuZG9jdW1lbnRCeUZpbGVOYW1lW2ZpbGVOYW1lXSA9IG5ldyBkb20oKS5wYXJzZUZyb21TdHJpbmcoZnMucmVhZEZpbGVTeW5jKGZpbGVOYW1lLCAndXRmLTgnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGU6IGZ1bmN0aW9uIChsb2NhbGVJZCwgdHlwZSkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHJldHVybiBleHBhbmRMb2NhbGVJZFRvUHJpb3JpdGl6ZWRMaXN0KGxvY2FsZUlkKS5jb25jYXQoJ3Jvb3QnKS5tYXAoZnVuY3Rpb24gKHN1YkxvY2FsZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhhdC5maWxlTmFtZXNCeVR5cGVBbmROb3JtYWxpemVkTG9jYWxlSWRbdHlwZV1bbm9ybWFsaXplTG9jYWxlSWQoc3ViTG9jYWxlSWQpXTtcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChmaWxlTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuICEhZmlsZU5hbWU7XG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAoZmlsZU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGF0LmdldERvY3VtZW50KGZpbGVOYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHByZWxvYWQ6IGZ1bmN0aW9uIChsb2NhbGVJZHMsIGNiKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGVJZHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNiID0gbG9jYWxlSWRzO1xuICAgICAgICAgICAgbG9jYWxlSWRzID0gdGhhdC5sb2NhbGVJZHM7XG4gICAgICAgIH1cbiAgICAgICAgbG9jYWxlSWRzID0gKEFycmF5LmlzQXJyYXkobG9jYWxlSWRzKSA/IGxvY2FsZUlkcyA6IFtsb2NhbGVJZHNdKS5tYXAobm9ybWFsaXplTG9jYWxlSWQpO1xuICAgICAgICB2YXIgbmVlZGVkTG9jYWxlQnlJZCA9IHtyb290OiB0cnVlfTtcbiAgICAgICAgbG9jYWxlSWRzLmZvckVhY2goZnVuY3Rpb24gKGxvY2FsZUlkKSB7XG4gICAgICAgICAgICBleHBhbmRMb2NhbGVJZFRvUHJpb3JpdGl6ZWRMaXN0KGxvY2FsZUlkKS5mb3JFYWNoKGZ1bmN0aW9uIChzdWJMb2NhbGVJZCkge1xuICAgICAgICAgICAgICAgIG5lZWRlZExvY2FsZUJ5SWRbc3ViTG9jYWxlSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGZpbGVOYW1lcyA9IFtcbiAgICAgICAgICAgIFBhdGgucmVzb2x2ZSh0aGF0LmNsZHJQYXRoLCAnY29tbW9uJywgJ3N1cHBsZW1lbnRhbCcsICdwbHVyYWxzLnhtbCcpLFxuICAgICAgICAgICAgUGF0aC5yZXNvbHZlKHRoYXQuY2xkclBhdGgsICdjb21tb24nLCAnc3VwcGxlbWVudGFsJywgJ251bWJlcmluZ1N5c3RlbXMueG1sJylcbiAgICAgICAgXTtcbiAgICAgICAgT2JqZWN0LmtleXMobmVlZGVkTG9jYWxlQnlJZCkuZm9yRWFjaChmdW5jdGlvbiAobG9jYWxlSWQpIHtcbiAgICAgICAgICAgIFsnbWFpbicsICdyYm5mJ10uZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IHRoYXQuZmlsZU5hbWVzQnlUeXBlQW5kTm9ybWFsaXplZExvY2FsZUlkW3R5cGVdW2xvY2FsZUlkXTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWVzLnB1c2goZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc2VxKGZpbGVOYW1lcylcbiAgICAgICAgICAgIC5wYXJFYWNoKDIwLCBmdW5jdGlvbiAoZmlsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmdldERvY3VtZW50KGZpbGVOYW1lLCB0aGlzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc2VxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChjYik7XG4gICAgfSxcblxuICAgIGNyZWF0ZUZpbmRlcjogZnVuY3Rpb24gKHByaW9yaXRpemVkRG9jdW1lbnRzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBmaW5kZXIoeHBhdGhRdWVyeSkge1xuICAgICAgICAgICAgdmFyIHByaW9yaXRpemVkUmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgcHJpb3JpdGl6ZWREb2N1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZG9jdW1lbnQsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0c0ZvckxvY2FsZURvY3VtZW50ID0geHBhdGguc2VsZWN0KHhwYXRoUXVlcnksIGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0c0ZvckxvY2FsZURvY3VtZW50Lmxlbmd0aCA9PT0gMCAmJiBpID09PSAocHJpb3JpdGl6ZWREb2N1bWVudHMubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgaW4gcm9vdCBhbmQgdGhlcmUgd2VyZSBubyByZXN1bHRzLCBsb29rIGZvciBhbGlhcyBlbGVtZW50cyBpbiBwYXRoOlxuICAgICAgICAgICAgICAgICAgICB2YXIgcXVlcnlGcmFnbWVudHMgPSB4cGF0aFF1ZXJ5LnNwbGl0KCcvJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3BwZWRRdWVyeUZyYWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocXVlcnlGcmFnbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsaWFzTm9kZXMgPSB4cGF0aC5zZWxlY3QocXVlcnlGcmFnbWVudHMuam9pbignLycpICsgJy9hbGlhcycsIGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGlhc05vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxpYXNTcGVjaWZpZWRRdWVyeSA9IG5vcm1hbGl6ZVhQYXRoUXVlcnkocXVlcnlGcmFnbWVudHMuam9pbignLycpICsgJy8nICsgYWxpYXNOb2Rlc1swXS5nZXRBdHRyaWJ1dGUoJ3BhdGgnKSArICcvJyArIHBvcHBlZFF1ZXJ5RnJhZ21lbnRzLmpvaW4oJy8nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocHJpb3JpdGl6ZWRSZXN1bHRzLCBmaW5kZXIoYWxpYXNTcGVjaWZpZWRRdWVyeSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9wcGVkUXVlcnlGcmFnbWVudHMudW5zaGlmdChxdWVyeUZyYWdtZW50cy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShwcmlvcml0aXplZFJlc3VsdHMsIHJlc3VsdHNGb3JMb2NhbGVEb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcHJpb3JpdGl6ZWRSZXN1bHRzO1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBleHRyYWN0TG9jYWxlRGlzcGxheVBhdHRlcm46IGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBsb2NhbGVEaXNwbGF5UGF0dGVybiA9IHt9O1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC9sb2NhbGVEaXNwbGF5TmFtZXMvbG9jYWxlRGlzcGxheVBhdHRlcm4vKlwiKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBsb2NhbGVEaXNwbGF5UGF0dGVybltub2RlLm5vZGVOYW1lXSA9IG5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbG9jYWxlRGlzcGxheVBhdHRlcm47XG4gICAgfSxcblxuICAgIGV4dHJhY3RMYW5ndWFnZURpc3BsYXlOYW1lczogZnVuY3Rpb24gKGxvY2FsZUlkKSB7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIGxhbmd1YWdlRGlzcGxheU5hbWVzID0ge307XG4gICAgICAgIGZpbmRlcignL2xkbWwvbG9jYWxlRGlzcGxheU5hbWVzL2xhbmd1YWdlcy9sYW5ndWFnZScpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IG5vcm1hbGl6ZUxvY2FsZUlkKG5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJykpO1xuICAgICAgICAgICAgbGFuZ3VhZ2VEaXNwbGF5TmFtZXNbaWRdID0gbGFuZ3VhZ2VEaXNwbGF5TmFtZXNbaWRdIHx8IG5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VEaXNwbGF5TmFtZXM7XG4gICAgfSxcblxuICAgIGV4dHJhY3RUaW1lWm9uZURpc3BsYXlOYW1lczogZnVuY3Rpb24gKGxvY2FsZUlkKSB7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIHRpbWVab25lRGlzcGxheU5hbWVzID0ge307XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2RhdGVzL3RpbWVab25lTmFtZXMvem9uZVwiKS5mb3JFYWNoKGZ1bmN0aW9uICh6b25lTm9kZSkge1xuICAgICAgICAgICAgdmFyIHRpbWVab25lSWQgPSB6b25lTm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSxcbiAgICAgICAgICAgICAgICBleGVtcGxhckNpdHlOb2RlcyA9IHhwYXRoLnNlbGVjdChcImV4ZW1wbGFyQ2l0eVwiLCB6b25lTm9kZSksXG4gICAgICAgICAgICAgICAgdHpOYW1lTG9jYWxlO1xuICAgICAgICAgICAgaWYgKGV4ZW1wbGFyQ2l0eU5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0ek5hbWVMb2NhbGUgPSBleGVtcGxhckNpdHlOb2Rlc1swXS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGdlbmVyaWNEaXNwbGF5TmFtZU5vZGVzID0geHBhdGguc2VsZWN0KFwibG9uZy9nZW5lcmljXCIsIHpvbmVOb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJpY0Rpc3BsYXlOYW1lTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0ek5hbWVMb2NhbGUgPSBnZW5lcmljRGlzcGxheU5hbWVOb2Rlc1swXS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZ0Rpc3BsYXlOYW1lTm9kZXMgPSB4cGF0aC5zZWxlY3QoXCJsb25nL3N0YW5kYXJkXCIsIHpvbmVOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvbmdEaXNwbGF5TmFtZU5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR6TmFtZUxvY2FsZSA9IGxvbmdEaXNwbGF5TmFtZU5vZGVzWzBdLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR6TmFtZUxvY2FsZSkge1xuICAgICAgICAgICAgICAgIHRpbWVab25lRGlzcGxheU5hbWVzW3RpbWVab25lSWRdID0gdGltZVpvbmVEaXNwbGF5TmFtZXNbdGltZVpvbmVJZF0gfHwgdHpOYW1lTG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRpbWVab25lRGlzcGxheU5hbWVzO1xuICAgIH0sXG5cbiAgICBleHRyYWN0VGltZVpvbmVGb3JtYXRzOiBmdW5jdGlvbiAobG9jYWxlSWQpIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgdGltZVpvbmVGb3JtYXRzID0ge307XG4gICAgICAgIFsnaG91ckZvcm1hdCcsICdnbXRGb3JtYXQnLCAnZ210WmVyb0Zvcm1hdCcsICdyZWdpb25Gb3JtYXQnLCAnZmFsbGJhY2tGb3JtYXQnLCAnZmFsbGJhY2tSZWdpb25Gb3JtYXQnXS5mb3JFYWNoKGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgICAgICAgICBmaW5kZXIoXCIvbGRtbC9kYXRlcy90aW1lWm9uZU5hbWVzL1wiICsgdGFnTmFtZSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXROYW1lID0gbm9kZS5ub2RlTmFtZS5yZXBsYWNlKC9Gb3JtYXQkLywgJycpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdE5hbWUgPT09ICdob3VyJykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCc7Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbWVab25lRm9ybWF0c1tmb3JtYXROYW1lXSA9IHRpbWVab25lRm9ybWF0c1tmb3JtYXROYW1lXSB8fCB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvZGF0ZXMvdGltZVpvbmVOYW1lcy9yZWdpb25Gb3JtYXRbQHR5cGVdXCIpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgICAgIHRpbWVab25lRm9ybWF0cy5yZWdpb25zID0gdGltZVpvbmVGb3JtYXRzLnJlZ2lvbnMgfHwge307XG4gICAgICAgICAgICB0aW1lWm9uZUZvcm1hdHMucmVnaW9uc1t0eXBlXSA9IHRpbWVab25lRm9ybWF0cy5yZWdpb25zW3R5cGVdIHx8IG5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGltZVpvbmVGb3JtYXRzO1xuICAgIH0sXG5cbiAgICBleHRyYWN0VGVycml0b3J5RGlzcGxheU5hbWVzOiBmdW5jdGlvbiAobG9jYWxlSWQpIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgdGVycml0b3J5RGlzcGxheU5hbWVzID0ge307XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2xvY2FsZURpc3BsYXlOYW1lcy90ZXJyaXRvcmllcy90ZXJyaXRvcnlcIikuZm9yRWFjaChmdW5jdGlvbiAodGVycml0b3J5Tm9kZSkge1xuICAgICAgICAgICAgdmFyIHRlcnJpdG9yeUlkID0gdGVycml0b3J5Tm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgICAgIHRlcnJpdG9yeURpc3BsYXlOYW1lc1t0ZXJyaXRvcnlJZF0gPSB0ZXJyaXRvcnlEaXNwbGF5TmFtZXNbdGVycml0b3J5SWRdIHx8IHRlcnJpdG9yeU5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGVycml0b3J5RGlzcGxheU5hbWVzO1xuICAgIH0sXG5cbiAgICBleHRyYWN0Q3VycmVuY3lJbmZvQnlJZDogZnVuY3Rpb24gKGxvY2FsZUlkKSB7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIGN1cnJlbmN5RGlzcGxheU5hbWVCeUN1cnJlbmN5SWQgPSB7fSxcbiAgICAgICAgICAgIGN1cnJlbmN5RGlzcGxheU5hbWVCeUN1cnJlbmN5SWRBbmRDb3VudCA9IHt9LFxuICAgICAgICAgICAgY3VycmVuY3lTeW1ib2xCeUN1cnJlbmN5SWQgPSB7fTtcblxuICAgICAgICBmaW5kZXIoXCIvbGRtbC9udW1iZXJzL2N1cnJlbmNpZXMvY3VycmVuY3kvZGlzcGxheU5hbWVcIikuZm9yRWFjaChmdW5jdGlvbiAoZGlzcGxheU5hbWVOb2RlKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVuY3lJZCA9IGRpc3BsYXlOYW1lTm9kZS5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpLFxuICAgICAgICAgICAgICAgIGNvdW50QXR0cmlidXRlID0gZGlzcGxheU5hbWVOb2RlLmdldEF0dHJpYnV0ZSgnY291bnQnKTtcbiAgICAgICAgICAgIGlmIChjb3VudEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbmN5RGlzcGxheU5hbWVCeUN1cnJlbmN5SWRBbmRDb3VudFtjdXJyZW5jeUlkXSA9IGN1cnJlbmN5RGlzcGxheU5hbWVCeUN1cnJlbmN5SWRBbmRDb3VudFtjdXJyZW5jeUlkXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBjdXJyZW5jeURpc3BsYXlOYW1lQnlDdXJyZW5jeUlkQW5kQ291bnRbY3VycmVuY3lJZF1bY291bnRBdHRyaWJ1dGVdID0gZGlzcGxheU5hbWVOb2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW5jeURpc3BsYXlOYW1lQnlDdXJyZW5jeUlkW2N1cnJlbmN5SWRdID0gY3VycmVuY3lEaXNwbGF5TmFtZUJ5Q3VycmVuY3lJZFtjdXJyZW5jeUlkXSB8fCBkaXNwbGF5TmFtZU5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZpbmRlcihcIi9sZG1sL251bWJlcnMvY3VycmVuY2llcy9jdXJyZW5jeS9zeW1ib2xcIikuZm9yRWFjaChmdW5jdGlvbiAoc3ltYm9sTm9kZSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbmN5SWQgPSBzeW1ib2xOb2RlLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgICAgICBjdXJyZW5jeVN5bWJvbEJ5Q3VycmVuY3lJZFtjdXJyZW5jeUlkXSA9IGN1cnJlbmN5U3ltYm9sQnlDdXJyZW5jeUlkW2N1cnJlbmN5SWRdIHx8IHN5bWJvbE5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBjdXJyZW5jeUluZm9CeUlkID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGN1cnJlbmN5RGlzcGxheU5hbWVCeUN1cnJlbmN5SWQpLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbmN5SWQpIHtcbiAgICAgICAgICAgIGN1cnJlbmN5SW5mb0J5SWRbY3VycmVuY3lJZF0gPSBfLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IGN1cnJlbmN5RGlzcGxheU5hbWVCeUN1cnJlbmN5SWRbY3VycmVuY3lJZF0sXG4gICAgICAgICAgICAgICAgc3ltYm9sOiBjdXJyZW5jeVN5bWJvbEJ5Q3VycmVuY3lJZFtjdXJyZW5jeUlkXVxuICAgICAgICAgICAgfSwgY3VycmVuY3lEaXNwbGF5TmFtZUJ5Q3VycmVuY3lJZEFuZENvdW50W2N1cnJlbmN5SWRdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjdXJyZW5jeUluZm9CeUlkO1xuICAgIH0sXG5cbiAgICBleHRyYWN0U2NyaXB0RGlzcGxheU5hbWVzOiBmdW5jdGlvbiAobG9jYWxlSWQpIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgc2NyaXB0RGlzcGxheU5hbWVzID0ge307XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2xvY2FsZURpc3BsYXlOYW1lcy9zY3JpcHRzL3NjcmlwdFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChzY3JpcHROb2RlKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBzY3JpcHROb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICAgICAgc2NyaXB0RGlzcGxheU5hbWVzW2lkXSA9IHNjcmlwdERpc3BsYXlOYW1lc1tpZF0gfHwgc2NyaXB0Tm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzY3JpcHREaXNwbGF5TmFtZXM7XG4gICAgfSxcblxuICAgIGV4dHJhY3RLZXlUeXBlczogZnVuY3Rpb24gKGxvY2FsZUlkKSB7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIGtleVR5cGVzID0ge307XG4gICAgICAgIGZpbmRlcignL2xkbWwvbG9jYWxlRGlzcGxheU5hbWVzL2tleXMva2V5JykuZm9yRWFjaChmdW5jdGlvbiAoa2V5Tm9kZSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBrZXlOb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICAgICAga2V5VHlwZXNbdHlwZV0gPSB7IGRpc3BsYXlOYW1lOiBrZXlOb2RlLnRleHRDb250ZW50IH07XG4gICAgICAgIH0pO1xuICAgICAgICBmaW5kZXIoJy9sZG1sL2xvY2FsZURpc3BsYXlOYW1lcy90eXBlcy90eXBlJykuZm9yRWFjaChmdW5jdGlvbiAodHlwZU5vZGUpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0eXBlTm9kZS5nZXRBdHRyaWJ1dGUoJ2tleScpLFxuICAgICAgICAgICAgICAgIHR5cGUgPSBub3JtYWxpemVQcm9wZXJ0eSh0eXBlTm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSk7XG4gICAgICAgICAgICBrZXlUeXBlc1trZXldID0ga2V5VHlwZXNba2V5XSB8fCB7fTtcbiAgICAgICAgICAgIGtleVR5cGVzW2tleV0udHlwZXMgPSBrZXlUeXBlc1trZXldLnR5cGVzIHx8IHt9O1xuICAgICAgICAgICAga2V5VHlwZXNba2V5XS50eXBlc1t0eXBlXSA9IHR5cGVOb2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGtleVR5cGVzO1xuICAgIH0sXG5cbiAgICBleHRyYWN0VHJhbnNmb3JtTmFtZXM6IGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICB0cmFuc2Zvcm1OYW1lcyA9IHt9O1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC9sb2NhbGVEaXNwbGF5TmFtZXMvdHJhbnNmb3JtTmFtZXMvdHJhbnNmb3JtTmFtZVwiKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFuc2Zvcm1OYW1lTm9kZSkge1xuICAgICAgICAgICAgdmFyIGlkID0gdHJhbnNmb3JtTmFtZU5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgICAgICB0cmFuc2Zvcm1OYW1lc1tpZF0gPSB0cmFuc2Zvcm1OYW1lc1tpZF0gfHwgdHJhbnNmb3JtTmFtZU5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtTmFtZXM7XG4gICAgfSxcblxuICAgIGV4dHJhY3RNZWFzdXJlbWVudFN5c3RlbU5hbWVzOiBmdW5jdGlvbiAobG9jYWxlSWQpIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgbWVhc3VyZW1lbnRTeXN0ZW1OYW1lcyA9IHt9O1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC9sb2NhbGVEaXNwbGF5TmFtZXMvbWVhc3VyZW1lbnRTeXN0ZW1OYW1lcy9tZWFzdXJlbWVudFN5c3RlbU5hbWVcIikuZm9yRWFjaChmdW5jdGlvbiAobWVhc3VyZW1lbnRTeXN0ZW1OYW1lTm9kZSkge1xuICAgICAgICAgICAgdmFyIGlkID0gbWVhc3VyZW1lbnRTeXN0ZW1OYW1lTm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgICAgIG1lYXN1cmVtZW50U3lzdGVtTmFtZXNbaWRdID0gbWVhc3VyZW1lbnRTeXN0ZW1OYW1lc1tpZF0gfHwgbWVhc3VyZW1lbnRTeXN0ZW1OYW1lTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZWFzdXJlbWVudFN5c3RlbU5hbWVzO1xuICAgIH0sXG5cbiAgICBleHRyYWN0Q29kZVBhdHRlcm5zOiBmdW5jdGlvbiAobG9jYWxlSWQpIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgY29kZVBhdHRlcm5zID0ge307XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2xvY2FsZURpc3BsYXlOYW1lcy9jb2RlUGF0dGVybnMvY29kZVBhdHRlcm5cIikuZm9yRWFjaChmdW5jdGlvbiAoY29kZVBhdHRlcm5Ob2RlKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBjb2RlUGF0dGVybk5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgICAgICBjb2RlUGF0dGVybnNbaWRdID0gY29kZVBhdHRlcm5zW2lkXSB8fCBjb2RlUGF0dGVybk5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29kZVBhdHRlcm5zO1xuICAgIH0sXG5cbiAgICAvLyBDYWxlbmRhciBleHRyYWN0aW9uIG1ldGhvZHM6XG5cbiAgICBleHRyYWN0RXJhTmFtZXM6IGZ1bmN0aW9uIChsb2NhbGVJZCwgY2FsZW5kYXJJZCkge1xuICAgICAgICBjYWxlbmRhcklkID0gY2FsZW5kYXJJZCB8fCAnZ3JlZ29yaWFuJztcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgZXJhTmFtZXM7XG4gICAgICAgIFsnZXJhTmFtZXMnLCAnZXJhQWJiciddLmZvckVhY2goZnVuY3Rpb24gKGVyYVR5cGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlSW5PdXRwdXQgPSB7ZXJhTmFtZXM6ICd3aWRlJywgZXJhQWJicjogJ2FiYnJldmlhdGVkJ31bZXJhVHlwZV07XG4gICAgICAgICAgICBmaW5kZXIoXCIvbGRtbC9kYXRlcy9jYWxlbmRhcnMvY2FsZW5kYXJbQHR5cGU9J1wiICsgY2FsZW5kYXJJZCArIFwiJ10vZXJhcy9cIiArIGVyYVR5cGUgKyBcIi9lcmFcIikuZm9yRWFjaChmdW5jdGlvbiAoZXJhTm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gcGFyc2VJbnQoZXJhTm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSwgMTApO1xuICAgICAgICAgICAgICAgIGVyYU5hbWVzID0gZXJhTmFtZXMgfHwge307XG4gICAgICAgICAgICAgICAgZXJhTmFtZXNbdHlwZUluT3V0cHV0XSA9IGVyYU5hbWVzW3R5cGVJbk91dHB1dF0gfHwge307XG4gICAgICAgICAgICAgICAgZXJhTmFtZXNbdHlwZUluT3V0cHV0XVt0eXBlXSA9IGVyYU5hbWVzW3R5cGVJbk91dHB1dF1bdHlwZV0gfHwgZXJhTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRPYmplY3RzV2l0aEludGVnZXJLZXlzVG9BcnJheXMoZXJhTmFtZXMpO1xuICAgIH0sXG5cbiAgICBleHRyYWN0UXVhcnRlck5hbWVzOiBmdW5jdGlvbiAobG9jYWxlSWQsIGNhbGVuZGFySWQpIHtcbiAgICAgICAgY2FsZW5kYXJJZCA9IGNhbGVuZGFySWQgfHwgJ2dyZWdvcmlhbic7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIHF1YXJ0ZXJOYW1lcztcbiAgICAgICAgWydmb3JtYXQnLCAnc3RhbmQtYWxvbmUnXS5mb3JFYWNoKGZ1bmN0aW9uIChxdWFydGVyQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHF1YXJ0ZXJDb250ZXh0Q2FtZWxDYXNlID0gbm9ybWFsaXplUHJvcGVydHkocXVhcnRlckNvbnRleHQpOyAvLyBzdGFuZC1hbG9uZSA9PiBzdGFuZEFsb25lXG4gICAgICAgICAgICBbJ2FiYnJldmlhdGVkJywgJ25hcnJvdycsICd3aWRlJ10uZm9yRWFjaChmdW5jdGlvbiAocXVhcnRlcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgZmluZGVyKFwiL2xkbWwvZGF0ZXMvY2FsZW5kYXJzL2NhbGVuZGFyW0B0eXBlPSdcIiArIGNhbGVuZGFySWQgKyBcIiddL3F1YXJ0ZXJzL3F1YXJ0ZXJDb250ZXh0W0B0eXBlPSdcIiArIHF1YXJ0ZXJDb250ZXh0ICsgXCInXS9xdWFydGVyV2lkdGhbQHR5cGU9J1wiICsgcXVhcnRlcldpZHRoICsgXCInXS9xdWFydGVyXCIpLmZvckVhY2goZnVuY3Rpb24gKHF1YXJ0ZXJOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxdWFydGVyTm8gPSBwYXJzZUludChxdWFydGVyTm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSwgMTApIC0gMTtcblxuICAgICAgICAgICAgICAgICAgICBxdWFydGVyTmFtZXMgPSBxdWFydGVyTmFtZXMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIHF1YXJ0ZXJOYW1lc1txdWFydGVyQ29udGV4dENhbWVsQ2FzZV0gPSBxdWFydGVyTmFtZXNbcXVhcnRlckNvbnRleHRDYW1lbENhc2VdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBxdWFydGVyTmFtZXNbcXVhcnRlckNvbnRleHRDYW1lbENhc2VdW3F1YXJ0ZXJXaWR0aF0gPSBxdWFydGVyTmFtZXNbcXVhcnRlckNvbnRleHRDYW1lbENhc2VdW3F1YXJ0ZXJXaWR0aF0gfHwge307XG4gICAgICAgICAgICAgICAgICAgIHF1YXJ0ZXJOYW1lc1txdWFydGVyQ29udGV4dENhbWVsQ2FzZV1bcXVhcnRlcldpZHRoXVtxdWFydGVyTm9dID0gcXVhcnRlck5hbWVzW3F1YXJ0ZXJDb250ZXh0Q2FtZWxDYXNlXVtxdWFydGVyV2lkdGhdW3F1YXJ0ZXJOb10gfHwgcXVhcnRlck5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb252ZXJ0T2JqZWN0c1dpdGhJbnRlZ2VyS2V5c1RvQXJyYXlzKHF1YXJ0ZXJOYW1lcyk7XG4gICAgfSxcblxuICAgIGV4dHJhY3REYXlQZXJpb2RzOiBmdW5jdGlvbiAobG9jYWxlSWQsIGNhbGVuZGFySWQpIHtcbiAgICAgICAgY2FsZW5kYXJJZCA9IGNhbGVuZGFySWQgfHwgJ2dyZWdvcmlhbic7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIGRheVBlcmlvZHM7XG4gICAgICAgIFsnZm9ybWF0JywgJ3N0YW5kLWFsb25lJ10uZm9yRWFjaChmdW5jdGlvbiAoZGF5UGVyaW9kQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGRheVBlcmlvZENvbnRleHRDYW1lbENhc2UgPSBub3JtYWxpemVQcm9wZXJ0eShkYXlQZXJpb2RDb250ZXh0KTsgLy8gc3RhbmQtYWxvbmUgPT4gc3RhbmRBbG9uZVxuICAgICAgICAgICAgWydhYmJyZXZpYXRlZCcsICduYXJyb3cnLCAnd2lkZScsICdzaG9ydCddLmZvckVhY2goZnVuY3Rpb24gKGRheVBlcmlvZFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgZmluZGVyKFwiL2xkbWwvZGF0ZXMvY2FsZW5kYXJzL2NhbGVuZGFyW0B0eXBlPSdcIiArIGNhbGVuZGFySWQgKyBcIiddL2RheVBlcmlvZHMvZGF5UGVyaW9kQ29udGV4dFtAdHlwZT0nXCIgKyBkYXlQZXJpb2RDb250ZXh0ICsgXCInXS9kYXlQZXJpb2RXaWR0aFtAdHlwZT0nXCIgKyBkYXlQZXJpb2RXaWR0aCArIFwiJ10vZGF5UGVyaW9kXCIpLmZvckVhY2goZnVuY3Rpb24gKGRheVBlcmlvZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBkYXlQZXJpb2ROb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuXG4gICAgICAgICAgICAgICAgICAgIGRheVBlcmlvZHMgPSBkYXlQZXJpb2RzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBkYXlQZXJpb2RzW2RheVBlcmlvZENvbnRleHRDYW1lbENhc2VdID0gZGF5UGVyaW9kc1tkYXlQZXJpb2RDb250ZXh0Q2FtZWxDYXNlXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgZGF5UGVyaW9kc1tkYXlQZXJpb2RDb250ZXh0Q2FtZWxDYXNlXVtkYXlQZXJpb2RXaWR0aF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF5UGVyaW9kc1tkYXlQZXJpb2RDb250ZXh0Q2FtZWxDYXNlXVtkYXlQZXJpb2RXaWR0aF0gfHwge307XG4gICAgICAgICAgICAgICAgICAgIGRheVBlcmlvZHNbZGF5UGVyaW9kQ29udGV4dENhbWVsQ2FzZV1bZGF5UGVyaW9kV2lkdGhdW3R5cGVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRheVBlcmlvZHNbZGF5UGVyaW9kQ29udGV4dENhbWVsQ2FzZV1bZGF5UGVyaW9kV2lkdGhdW3R5cGVdIHx8IGRheVBlcmlvZE5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXlQZXJpb2RzO1xuICAgIH0sXG5cbiAgICBleHRyYWN0Q3ljbGljTmFtZXM6IGZ1bmN0aW9uIChsb2NhbGVJZCwgY2FsZW5kYXJJZCkge1xuICAgICAgICBjYWxlbmRhcklkID0gY2FsZW5kYXJJZCB8fCAnZ3JlZ29yaWFuJztcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgY3ljbGljTmFtZXM7XG4gICAgICAgIFsnZGF5UGFydHMnLCAnZGF5cycsICdtb250aHMnLCAneWVhcnMnLCAnem9kaWFjcyddLmZvckVhY2goZnVuY3Rpb24gKGN5Y2xpY05hbWVTZXQpIHtcbiAgICAgICAgICAgIFsnZm9ybWF0J10uZm9yRWFjaChmdW5jdGlvbiAoY3ljbGljTmFtZUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBbJ2FiYnJldmlhdGVkJywgJ25hcnJvdycsICd3aWRlJ10uZm9yRWFjaChmdW5jdGlvbiAoY3ljbGljTmFtZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmRlcihcIi9sZG1sL2RhdGVzL2NhbGVuZGFycy9jYWxlbmRhcltAdHlwZT0nXCIgKyBjYWxlbmRhcklkICsgXCInXS9jeWNsaWNOYW1lU2V0cy9jeWNsaWNOYW1lU2V0W0B0eXBlPSdcIiArIGN5Y2xpY05hbWVTZXQgKyBcIiddL2N5Y2xpY05hbWVDb250ZXh0W0B0eXBlPSdcIiArIGN5Y2xpY05hbWVDb250ZXh0ICsgXCInXS9jeWNsaWNOYW1lV2lkdGhbQHR5cGU9J1wiICsgY3ljbGljTmFtZVdpZHRoICsgXCInXS9jeWNsaWNOYW1lXCIpLmZvckVhY2goZnVuY3Rpb24gKGN5Y2xpY05hbWVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGN5Y2xpY05hbWVOb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3ljbGljTmFtZXMgPSBjeWNsaWNOYW1lcyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5Y2xpY05hbWVzW2N5Y2xpY05hbWVTZXRdID0gY3ljbGljTmFtZXNbY3ljbGljTmFtZVNldF0gfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICBjeWNsaWNOYW1lc1tjeWNsaWNOYW1lU2V0XVtjeWNsaWNOYW1lQ29udGV4dF0gPSBjeWNsaWNOYW1lc1tjeWNsaWNOYW1lU2V0XVtjeWNsaWNOYW1lQ29udGV4dF0gfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICBjeWNsaWNOYW1lc1tjeWNsaWNOYW1lU2V0XVtjeWNsaWNOYW1lQ29udGV4dF1bY3ljbGljTmFtZVdpZHRoXSA9IGN5Y2xpY05hbWVzW2N5Y2xpY05hbWVTZXRdW2N5Y2xpY05hbWVDb250ZXh0XVtjeWNsaWNOYW1lV2lkdGhdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3ljbGljTmFtZXNbY3ljbGljTmFtZVNldF1bY3ljbGljTmFtZUNvbnRleHRdW2N5Y2xpY05hbWVXaWR0aF1bdHlwZV0gPSBjeWNsaWNOYW1lc1tjeWNsaWNOYW1lU2V0XVtjeWNsaWNOYW1lQ29udGV4dF1bY3ljbGljTmFtZVdpZHRoXVt0eXBlXSB8fCBjeWNsaWNOYW1lTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb252ZXJ0T2JqZWN0c1dpdGhJbnRlZ2VyS2V5c1RvQXJyYXlzKGN5Y2xpY05hbWVzKTtcbiAgICB9LFxuXG4gICAgZXh0cmFjdE1vbnRoTmFtZXM6IGZ1bmN0aW9uIChsb2NhbGVJZCwgY2FsZW5kYXJJZCkge1xuICAgICAgICBjYWxlbmRhcklkID0gY2FsZW5kYXJJZCB8fCAnZ3JlZ29yaWFuJztcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgbW9udGhOYW1lcztcbiAgICAgICAgWydmb3JtYXQnLCAnc3RhbmQtYWxvbmUnXS5mb3JFYWNoKGZ1bmN0aW9uIChtb250aENvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBtb250aENvbnRleHRDYW1lbENhc2UgPSBub3JtYWxpemVQcm9wZXJ0eShtb250aENvbnRleHQpOyAvLyBzdGFuZC1hbG9uZSA9PiBzdGFuZEFsb25lXG4gICAgICAgICAgICBbJ2FiYnJldmlhdGVkJywgJ25hcnJvdycsICd3aWRlJ10uZm9yRWFjaChmdW5jdGlvbiAobW9udGhXaWR0aCkge1xuICAgICAgICAgICAgICAgIGZpbmRlcihcIi9sZG1sL2RhdGVzL2NhbGVuZGFycy9jYWxlbmRhcltAdHlwZT0nXCIgKyBjYWxlbmRhcklkICsgXCInXS9tb250aHMvbW9udGhDb250ZXh0W0B0eXBlPSdcIiArIG1vbnRoQ29udGV4dCArIFwiJ10vbW9udGhXaWR0aFtAdHlwZT0nXCIgKyBtb250aFdpZHRoICsgXCInXS9tb250aFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChtb250aE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vbnRoTm8gPSBwYXJzZUludChtb250aE5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyksIDEwKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoTmFtZXMgPSBtb250aE5hbWVzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBtb250aE5hbWVzW21vbnRoQ29udGV4dENhbWVsQ2FzZV0gPSBtb250aE5hbWVzW21vbnRoQ29udGV4dENhbWVsQ2FzZV0gfHwge307XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoTmFtZXNbbW9udGhDb250ZXh0Q2FtZWxDYXNlXVttb250aFdpZHRoXSA9IG1vbnRoTmFtZXNbbW9udGhDb250ZXh0Q2FtZWxDYXNlXVttb250aFdpZHRoXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgbW9udGhOYW1lc1ttb250aENvbnRleHRDYW1lbENhc2VdW21vbnRoV2lkdGhdW21vbnRoTm9dID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoTmFtZXNbbW9udGhDb250ZXh0Q2FtZWxDYXNlXVttb250aFdpZHRoXVttb250aE5vXSB8fCBtb250aE5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb252ZXJ0T2JqZWN0c1dpdGhJbnRlZ2VyS2V5c1RvQXJyYXlzKG1vbnRoTmFtZXMpO1xuICAgIH0sXG5cbiAgICBleHRyYWN0TW9udGhQYXR0ZXJuczogZnVuY3Rpb24gKGxvY2FsZUlkLCBjYWxlbmRhcklkKSB7XG4gICAgICAgIGNhbGVuZGFySWQgPSBjYWxlbmRhcklkIHx8ICdncmVnb3JpYW4nO1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBtb250aFBhdHRlcm5zO1xuICAgICAgICBbJ2Zvcm1hdCcsICdudW1lcmljJywgJ3N0YW5kLWFsb25lJ10uZm9yRWFjaChmdW5jdGlvbiAobW9udGhQYXR0ZXJuQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIG1vbnRoUGF0dGVybkNvbnRleHRDYW1lbENhc2UgPSBub3JtYWxpemVQcm9wZXJ0eShtb250aFBhdHRlcm5Db250ZXh0KTsgLy8gc3RhbmQtYWxvbmUgPT4gc3RhbmRBbG9uZVxuICAgICAgICAgICAgWydhYmJyZXZpYXRlZCcsICduYXJyb3cnLCAnd2lkZScsICdhbGwnXS5mb3JFYWNoKGZ1bmN0aW9uIChtb250aFBhdHRlcm5XaWR0aCkge1xuICAgICAgICAgICAgICAgIGZpbmRlcihcIi9sZG1sL2RhdGVzL2NhbGVuZGFycy9jYWxlbmRhcltAdHlwZT0nXCIgKyBjYWxlbmRhcklkICsgXCInXS9tb250aFBhdHRlcm5zL21vbnRoUGF0dGVybkNvbnRleHRbQHR5cGU9J1wiICsgbW9udGhQYXR0ZXJuQ29udGV4dCArIFwiJ10vbW9udGhQYXR0ZXJuV2lkdGhbQHR5cGU9J1wiICsgbW9udGhQYXR0ZXJuV2lkdGggKyBcIiddL21vbnRoUGF0dGVyblwiKS5mb3JFYWNoKGZ1bmN0aW9uIChtb250aFBhdHRlcm5Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gbW9udGhQYXR0ZXJuTm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgICAgICAgICAgICAgbW9udGhQYXR0ZXJucyA9IG1vbnRoUGF0dGVybnMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoUGF0dGVybnNbbW9udGhQYXR0ZXJuQ29udGV4dENhbWVsQ2FzZV0gPSBtb250aFBhdHRlcm5zW21vbnRoUGF0dGVybkNvbnRleHRDYW1lbENhc2VdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBtb250aFBhdHRlcm5zW21vbnRoUGF0dGVybkNvbnRleHRDYW1lbENhc2VdW21vbnRoUGF0dGVybldpZHRoXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBtb250aFBhdHRlcm5zW21vbnRoUGF0dGVybkNvbnRleHRDYW1lbENhc2VdW21vbnRoUGF0dGVybldpZHRoXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgbW9udGhQYXR0ZXJuc1ttb250aFBhdHRlcm5Db250ZXh0Q2FtZWxDYXNlXVttb250aFBhdHRlcm5XaWR0aF1bdHlwZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgbW9udGhQYXR0ZXJuc1ttb250aFBhdHRlcm5Db250ZXh0Q2FtZWxDYXNlXVttb250aFBhdHRlcm5XaWR0aF1bdHlwZV0gfHwgbW9udGhQYXR0ZXJuTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1vbnRoUGF0dGVybnM7XG4gICAgfSxcblxuICAgIGV4dHJhY3REYXlOYW1lczogZnVuY3Rpb24gKGxvY2FsZUlkLCBjYWxlbmRhcklkKSB7XG4gICAgICAgIGNhbGVuZGFySWQgPSBjYWxlbmRhcklkIHx8ICdncmVnb3JpYW4nO1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBkYXlOb0J5Q2xkcklkID0ge3N1bjogMCwgbW9uOiAxLCB0dWU6IDIsIHdlZDogMywgdGh1OiA0LCBmcmk6IDUsIHNhdDogNn0sXG4gICAgICAgICAgICBkYXlOYW1lcztcbiAgICAgICAgWydmb3JtYXQnLCAnbnVtZXJpYycsICdzdGFuZC1hbG9uZSddLmZvckVhY2goZnVuY3Rpb24gKGRheUNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBkYXlDb250ZXh0Q2FtZWxDYXNlID0gbm9ybWFsaXplUHJvcGVydHkoZGF5Q29udGV4dCk7IC8vIHN0YW5kLWFsb25lID0+IHN0YW5kQWxvbmVcbiAgICAgICAgICAgIFsnYWJicmV2aWF0ZWQnLCAnbmFycm93JywgJ3dpZGUnLCAnc2hvcnQnXS5mb3JFYWNoKGZ1bmN0aW9uIChkYXlXaWR0aCkge1xuICAgICAgICAgICAgICAgIGZpbmRlcihcIi9sZG1sL2RhdGVzL2NhbGVuZGFycy9jYWxlbmRhcltAdHlwZT0nXCIgKyBjYWxlbmRhcklkICsgXCInXS9kYXlzL2RheUNvbnRleHRbQHR5cGU9J1wiICsgZGF5Q29udGV4dCArIFwiJ10vZGF5V2lkdGhbQHR5cGU9J1wiICsgZGF5V2lkdGggKyBcIiddL2RheVwiKS5mb3JFYWNoKGZ1bmN0aW9uIChkYXlOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXlObyA9IGRheU5vQnlDbGRySWRbZGF5Tm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKV07XG4gICAgICAgICAgICAgICAgICAgIGRheU5hbWVzID0gZGF5TmFtZXMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGRheU5hbWVzW2RheUNvbnRleHRDYW1lbENhc2VdID0gZGF5TmFtZXNbZGF5Q29udGV4dENhbWVsQ2FzZV0gfHwge307XG4gICAgICAgICAgICAgICAgICAgIGRheU5hbWVzW2RheUNvbnRleHRDYW1lbENhc2VdW2RheVdpZHRoXSA9IGRheU5hbWVzW2RheUNvbnRleHRDYW1lbENhc2VdW2RheVdpZHRoXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgZGF5TmFtZXNbZGF5Q29udGV4dENhbWVsQ2FzZV1bZGF5V2lkdGhdW2RheU5vXSA9IGRheU5hbWVzW2RheUNvbnRleHRDYW1lbENhc2VdW2RheVdpZHRoXVtkYXlOb10gfHwgZGF5Tm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRPYmplY3RzV2l0aEludGVnZXJLZXlzVG9BcnJheXMoZGF5TmFtZXMpO1xuICAgIH0sXG5cbiAgICBleHRyYWN0RmllbGRzOiBmdW5jdGlvbiAobG9jYWxlSWQpIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgZmllbGRzO1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC9kYXRlcy9maWVsZHMvZmllbGQvZGlzcGxheU5hbWVcIikuZm9yRWFjaChmdW5jdGlvbiAoZmllbGREaXNwbGF5TmFtZU5vZGUpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZE5hbWUgPSBmaWVsZERpc3BsYXlOYW1lTm9kZS5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICAgICAgZmllbGRzID0gZmllbGRzIHx8IHt9O1xuICAgICAgICAgICAgZmllbGRzW2ZpZWxkTmFtZV0gPSBmaWVsZHNbZmllbGROYW1lXSB8fCB7fTtcbiAgICAgICAgICAgIGZpZWxkc1tmaWVsZE5hbWVdLmRpc3BsYXlOYW1lID0gZmllbGRzW2ZpZWxkTmFtZV0uZGlzcGxheU5hbWUgfHwgZmllbGREaXNwbGF5TmFtZU5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2RhdGVzL2ZpZWxkcy9maWVsZC9yZWxhdGl2ZVwiKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZFJlbGF0aXZlTm9kZSkge1xuICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkUmVsYXRpdmVOb2RlLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyksXG4gICAgICAgICAgICAgICAgdHlwZSA9IGZpZWxkUmVsYXRpdmVOb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICAgICAgZmllbGRzID0gZmllbGRzIHx8IHt9O1xuICAgICAgICAgICAgZmllbGRzW2ZpZWxkTmFtZV0gPSBmaWVsZHNbZmllbGROYW1lXSB8fCB7fTtcbiAgICAgICAgICAgIGZpZWxkc1tmaWVsZE5hbWVdLnJlbGF0aXZlID0gZmllbGRzW2ZpZWxkTmFtZV0ucmVsYXRpdmUgfHwge307XG4gICAgICAgICAgICBmaWVsZHNbZmllbGROYW1lXS5yZWxhdGl2ZVt0eXBlXSA9IGZpZWxkc1tmaWVsZE5hbWVdLnJlbGF0aXZlW3R5cGVdIHx8IGZpZWxkUmVsYXRpdmVOb2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcblxuICAgICAgICBmaW5kZXIoXCIvbGRtbC9kYXRlcy9maWVsZHMvZmllbGQvcmVsYXRpdmVUaW1lL3JlbGF0aXZlVGltZVBhdHRlcm5cIikuZm9yRWFjaChmdW5jdGlvbiAocmVsYXRpdmVUaW1lUGF0dGVybk5vZGUpIHtcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZVRpbWVOb2RlID0gcmVsYXRpdmVUaW1lUGF0dGVybk5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWUgPSByZWxhdGl2ZVRpbWVOb2RlLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyksXG4gICAgICAgICAgICAgICAgdHlwZSA9IHJlbGF0aXZlVGltZU5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyksXG4gICAgICAgICAgICAgICAgY291bnQgPSByZWxhdGl2ZVRpbWVQYXR0ZXJuTm9kZS5nZXRBdHRyaWJ1dGUoJ2NvdW50Jyk7XG4gICAgICAgICAgICBmaWVsZHMgPSBmaWVsZHMgfHwge307XG4gICAgICAgICAgICBmaWVsZHNbZmllbGROYW1lXSA9IGZpZWxkc1tmaWVsZE5hbWVdIHx8IHt9O1xuICAgICAgICAgICAgZmllbGRzW2ZpZWxkTmFtZV0ucmVsYXRpdmVUaW1lID0gZmllbGRzW2ZpZWxkTmFtZV0ucmVsYXRpdmVUaW1lIHx8IHt9O1xuICAgICAgICAgICAgZmllbGRzW2ZpZWxkTmFtZV0ucmVsYXRpdmVUaW1lW3R5cGVdID0gZmllbGRzW2ZpZWxkTmFtZV0ucmVsYXRpdmVUaW1lW3R5cGVdIHx8IHt9O1xuICAgICAgICAgICAgZmllbGRzW2ZpZWxkTmFtZV0ucmVsYXRpdmVUaW1lW3R5cGVdW2NvdW50XSA9IGZpZWxkc1tmaWVsZE5hbWVdLnJlbGF0aXZlVGltZVt0eXBlXVtjb3VudF0gfHwgcmVsYXRpdmVUaW1lUGF0dGVybk5vZGUudGV4dENvbnRlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgfSxcblxuICAgIGV4dHJhY3REYXRlVGltZVBhdHRlcm5zOiBmdW5jdGlvbiAobG9jYWxlSWQsIGNhbGVuZGFySWQpIHtcbiAgICAgICAgY2FsZW5kYXJJZCA9IGNhbGVuZGFySWQgfHwgJ2dyZWdvcmlhbic7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIGRhdGVUaW1lUGF0dGVybnM7XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2RhdGVzL2NhbGVuZGFycy9jYWxlbmRhcltAdHlwZT0nXCIgKyBjYWxlbmRhcklkICsgXCInXS9kYXRlVGltZUZvcm1hdHMvZGF0ZVRpbWVGb3JtYXRMZW5ndGgvZGF0ZVRpbWVGb3JtYXRcIikuZm9yRWFjaChmdW5jdGlvbiAoZGF0ZVRpbWVGb3JtYXROb2RlKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZVRpbWVGb3JtYXRMZW5ndGhUeXBlID0gZGF0ZVRpbWVGb3JtYXROb2RlLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyksXG4gICAgICAgICAgICAgICAgcGF0dGVybk5vZGVzID0geHBhdGguc2VsZWN0KFwicGF0dGVyblwiLCBkYXRlVGltZUZvcm1hdE5vZGUpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm5Ob2Rlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGV4YWN0bHkgb25lIHBhdHRlcm4gaW4gZGF0ZVRpbWVGb3JtYXROb2RlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRlVGltZVBhdHRlcm5zID0gZGF0ZVRpbWVQYXR0ZXJucyB8fCB7fTtcbiAgICAgICAgICAgIGRhdGVUaW1lUGF0dGVybnNbZGF0ZVRpbWVGb3JtYXRMZW5ndGhUeXBlXSA9IGRhdGVUaW1lUGF0dGVybnNbZGF0ZVRpbWVGb3JtYXRMZW5ndGhUeXBlXSB8fCBwYXR0ZXJuTm9kZXNbMF0udGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0ZVRpbWVQYXR0ZXJucztcbiAgICB9LFxuXG4gICAgZXh0cmFjdERhdGVPclRpbWVGb3JtYXRzOiBmdW5jdGlvbiAobG9jYWxlSWQsIGNhbGVuZGFySWQsIGRhdGVPclRpbWUpIHtcbiAgICAgICAgY2FsZW5kYXJJZCA9IGNhbGVuZGFySWQgfHwgJ2dyZWdvcmlhbic7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIGZvcm1hdHM7XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2RhdGVzL2NhbGVuZGFycy9jYWxlbmRhcltAdHlwZT0nXCIgKyBjYWxlbmRhcklkICsgXCInXS9cIiArIGRhdGVPclRpbWUgKyBcIkZvcm1hdHMvXCIgKyBkYXRlT3JUaW1lICsgXCJGb3JtYXRMZW5ndGgvXCIgKyBkYXRlT3JUaW1lICsgXCJGb3JtYXQvKlwiKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXR0ZXJuTm9kZSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBwYXR0ZXJuTm9kZS5wYXJlbnROb2RlLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgICAgICBmb3JtYXRzID0gZm9ybWF0cyB8fCB7fTtcbiAgICAgICAgICAgIGZvcm1hdHNbdHlwZV0gPSBmb3JtYXRzW3R5cGVdIHx8IHBhdHRlcm5Ob2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHM7XG4gICAgfSxcblxuICAgIGV4dHJhY3REYXRlRm9ybWF0czogZnVuY3Rpb24gKGxvY2FsZUlkLCBjYWxlbmRhcklkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3REYXRlT3JUaW1lRm9ybWF0cyhsb2NhbGVJZCwgY2FsZW5kYXJJZCwgJ2RhdGUnKTtcbiAgICB9LFxuXG4gICAgZXh0cmFjdFRpbWVGb3JtYXRzOiBmdW5jdGlvbiAobG9jYWxlSWQsIGNhbGVuZGFySWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdERhdGVPclRpbWVGb3JtYXRzKGxvY2FsZUlkLCBjYWxlbmRhcklkLCAndGltZScpO1xuICAgIH0sXG5cbiAgICBleHRyYWN0RGF0ZUZvcm1hdEl0ZW1zOiBmdW5jdGlvbiAobG9jYWxlSWQsIGNhbGVuZGFySWQpIHtcbiAgICAgICAgY2FsZW5kYXJJZCA9IGNhbGVuZGFySWQgfHwgJ2dyZWdvcmlhbic7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIGRhdGVGb3JtYXRJdGVtcztcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvZGF0ZXMvY2FsZW5kYXJzL2NhbGVuZGFyW0B0eXBlPSdcIiArIGNhbGVuZGFySWQgKyBcIiddL2RhdGVUaW1lRm9ybWF0cy9hdmFpbGFibGVGb3JtYXRzL2RhdGVGb3JtYXRJdGVtXCIpLmZvckVhY2goZnVuY3Rpb24gKGRhdGVGb3JtYXRJdGVtTm9kZSkge1xuICAgICAgICAgICAgdmFyIGlkID0gZGF0ZUZvcm1hdEl0ZW1Ob2RlLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgICAgIGRhdGVGb3JtYXRJdGVtcyA9IGRhdGVGb3JtYXRJdGVtcyB8fCB7fTtcbiAgICAgICAgICAgIGRhdGVGb3JtYXRJdGVtc1tpZF0gPSBkYXRlRm9ybWF0SXRlbXNbaWRdIHx8IGRhdGVGb3JtYXRJdGVtTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRlRm9ybWF0SXRlbXM7XG4gICAgfSxcblxuICAgIGV4dHJhY3REYXRlSW50ZXJ2YWxGb3JtYXRzOiBmdW5jdGlvbiAobG9jYWxlSWQsIGNhbGVuZGFySWQpIHtcbiAgICAgICAgY2FsZW5kYXJJZCA9IGNhbGVuZGFySWQgfHwgJ2dyZWdvcmlhbic7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIGRhdGVJbnRlcnZhbEZvcm1hdHM7XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2RhdGVzL2NhbGVuZGFycy9jYWxlbmRhcltAdHlwZT0nXCIgKyBjYWxlbmRhcklkICsgXCInXS9kYXRlVGltZUZvcm1hdHMvaW50ZXJ2YWxGb3JtYXRzL2ludGVydmFsRm9ybWF0SXRlbVwiKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcnZhbEZvcm1hdEl0ZW1Ob2RlKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZUludGVydmFsRm9ybWF0ID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBpbnRlcnZhbEZvcm1hdEl0ZW1Ob2RlLmNoaWxkTm9kZXMubGVuZ3RoIDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyZWF0ZXN0RGlmZmVyZW5jZU5vZGUgPSBpbnRlcnZhbEZvcm1hdEl0ZW1Ob2RlLmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGdyZWF0ZXN0RGlmZmVyZW5jZU5vZGUubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBncmVhdGVzdERpZmZlcmVuY2VJZEF0dHJpYnV0ZSA9IGdyZWF0ZXN0RGlmZmVyZW5jZU5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgICAgIHZhciBncmVhdGVzdERpZmZlcmVuY2VJZCA9IGdyZWF0ZXN0RGlmZmVyZW5jZUlkQXR0cmlidXRlO1xuICAgICAgICAgICAgICAgIGRhdGVJbnRlcnZhbEZvcm1hdFtncmVhdGVzdERpZmZlcmVuY2VJZF0gPSBkYXRlSW50ZXJ2YWxGb3JtYXRbZ3JlYXRlc3REaWZmZXJlbmNlSWRdIHx8IGdyZWF0ZXN0RGlmZmVyZW5jZU5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaWQgPSBpbnRlcnZhbEZvcm1hdEl0ZW1Ob2RlLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgICAgIGRhdGVJbnRlcnZhbEZvcm1hdHMgPSBkYXRlSW50ZXJ2YWxGb3JtYXRzIHx8IHt9O1xuICAgICAgICAgICAgZGF0ZUludGVydmFsRm9ybWF0c1tpZF0gPSBkYXRlSW50ZXJ2YWxGb3JtYXRzW2lkXSB8fCBkYXRlSW50ZXJ2YWxGb3JtYXQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0ZUludGVydmFsRm9ybWF0cztcbiAgICB9LFxuXG4gICAgZXh0cmFjdERhdGVJbnRlcnZhbEZhbGxiYWNrRm9ybWF0OiBmdW5jdGlvbiAobG9jYWxlSWQsIGNhbGVuZGFySWQpIHtcbiAgICAgICAgY2FsZW5kYXJJZCA9IGNhbGVuZGFySWQgfHwgJ2dyZWdvcmlhbic7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIGRhdGVJbnRlcnZhbEZhbGxiYWNrRm9ybWF0O1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC9kYXRlcy9jYWxlbmRhcnMvY2FsZW5kYXJbQHR5cGU9J1wiICsgY2FsZW5kYXJJZCArIFwiJ10vZGF0ZVRpbWVGb3JtYXRzL2ludGVydmFsRm9ybWF0cy9pbnRlcnZhbEZvcm1hdEZhbGxiYWNrXCIpLmZvckVhY2goZnVuY3Rpb24gKGludGVydmFsRm9ybWF0RmFsbGJhY2tOb2RlKSB7XG4gICAgICAgICAgICBkYXRlSW50ZXJ2YWxGYWxsYmFja0Zvcm1hdCA9IGRhdGVJbnRlcnZhbEZhbGxiYWNrRm9ybWF0IHx8IGludGVydmFsRm9ybWF0RmFsbGJhY2tOb2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGVJbnRlcnZhbEZhbGxiYWNrRm9ybWF0O1xuICAgIH0sXG5cbiAgICAvLyBOdW1iZXIgZXh0cmFjdGlvbiBjb2RlOlxuXG4gICAgZXh0cmFjdE51bWJlclN5bWJvbHM6IGZ1bmN0aW9uIChsb2NhbGVJZCwgbnVtYmVyU3lzdGVtSWQpIHtcbiAgICAgICAgbnVtYmVyU3lzdGVtSWQgPSBudW1iZXJTeXN0ZW1JZCB8fCAnbGF0bic7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIG51bWJlclN5bWJvbHM7XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL251bWJlcnMvc3ltYm9sc1tAbnVtYmVyU3lzdGVtID0gJ1wiICsgbnVtYmVyU3lzdGVtSWQgKyBcIiddLypbbmFtZSgpICE9ICdhbGlhcyddXCIpLmNvbmNhdChmaW5kZXIoXCIvbGRtbC9udW1iZXJzL3N5bWJvbHMvKltuYW1lKCkgIT0gJ2FsaWFzJ11cIikpLmZvckVhY2goZnVuY3Rpb24gKG51bWJlclN5bWJvbE5vZGUpIHtcbiAgICAgICAgICAgIHZhciBzeW1ib2xJZCA9IG51bWJlclN5bWJvbE5vZGUubm9kZU5hbWU7XG4gICAgICAgICAgICBudW1iZXJTeW1ib2xzID0gbnVtYmVyU3ltYm9scyB8fCB7fTtcbiAgICAgICAgICAgIG51bWJlclN5bWJvbHNbc3ltYm9sSWRdID0gbnVtYmVyU3ltYm9sc1tzeW1ib2xJZF0gfHwgbnVtYmVyU3ltYm9sTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBudW1iZXJTeW1ib2xzO1xuICAgIH0sXG5cbiAgICBleHRyYWN0TnVtYmVyRm9ybWF0czogZnVuY3Rpb24gKGxvY2FsZUlkLCBudW1iZXJTeXN0ZW1JZCkge1xuICAgICAgICBudW1iZXJTeXN0ZW1JZCA9IG51bWJlclN5c3RlbUlkIHx8ICdsYXRuJztcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgbnVtYmVyRm9ybWF0cztcbiAgICAgICAgWydzY2llbnRpZmljJywgJ2RlY2ltYWwnLCAnY3VycmVuY3knLCAncGVyY2VudCddLmZvckVhY2goZnVuY3Rpb24gKGZvcm1hdFR5cGUpIHtcbiAgICAgICAgICAgIFsnZnVsbCcsICdsb25nJywgJ21lZGl1bScsICdzaG9ydCddLmZvckVhY2goZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZpbmRlcihcIi9sZG1sL251bWJlcnMvXCIgKyBmb3JtYXRUeXBlICsgXCJGb3JtYXRzW0BudW1iZXJTeXN0ZW0gPSAnXCIgKyBudW1iZXJTeXN0ZW1JZCArIFwiJ10vXCIgKyBmb3JtYXRUeXBlICsgXCJGb3JtYXRMZW5ndGhbQHR5cGU9J1wiICsgbGVuZ3RoICsgXCInXS9cIiArIGZvcm1hdFR5cGUgKyBcIkZvcm1hdC9wYXR0ZXJuXCIpLmZvckVhY2goZnVuY3Rpb24gKHBhdHRlcm5Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gcGF0dGVybk5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IHBhdHRlcm5Ob2RlLmdldEF0dHJpYnV0ZSgnY291bnQnKTtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyRm9ybWF0cyA9IG51bWJlckZvcm1hdHMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIG51bWJlckZvcm1hdHNbZm9ybWF0VHlwZV0gPSBudW1iZXJGb3JtYXRzW2Zvcm1hdFR5cGVdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBudW1iZXJGb3JtYXRzW2Zvcm1hdFR5cGVdW2xlbmd0aF0gPSBudW1iZXJGb3JtYXRzW2Zvcm1hdFR5cGVdW2xlbmd0aF0gfHwge307XG4gICAgICAgICAgICAgICAgICAgIG51bWJlckZvcm1hdHNbZm9ybWF0VHlwZV1bbGVuZ3RoXVt0eXBlXSA9IG51bWJlckZvcm1hdHNbZm9ybWF0VHlwZV1bbGVuZ3RoXVt0eXBlXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyRm9ybWF0c1tmb3JtYXRUeXBlXVtsZW5ndGhdW3R5cGVdW2NvdW50XSA9IG51bWJlckZvcm1hdHNbZm9ybWF0VHlwZV1bbGVuZ3RoXVt0eXBlXVtjb3VudF0gfHwgcGF0dGVybk5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpbmRlcihcIi9sZG1sL251bWJlcnMvXCIgKyBmb3JtYXRUeXBlICsgXCJGb3JtYXRzW0BudW1iZXJTeXN0ZW0gPSAnXCIgKyBudW1iZXJTeXN0ZW1JZCArIFwiJ10vXCIgKyBmb3JtYXRUeXBlICsgXCJGb3JtYXRMZW5ndGhbbm90KEB0eXBlKV0vXCIgKyBmb3JtYXRUeXBlICsgXCJGb3JtYXQvcGF0dGVyblwiKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXR0ZXJuTm9kZSkge1xuICAgICAgICAgICAgICAgIG51bWJlckZvcm1hdHMgPSBudW1iZXJGb3JtYXRzIHx8IHt9O1xuICAgICAgICAgICAgICAgIG51bWJlckZvcm1hdHNbZm9ybWF0VHlwZV0gPSBudW1iZXJGb3JtYXRzW2Zvcm1hdFR5cGVdIHx8IHt9O1xuICAgICAgICAgICAgICAgIG51bWJlckZvcm1hdHNbZm9ybWF0VHlwZV0uZGVmYXVsdCA9IG51bWJlckZvcm1hdHNbZm9ybWF0VHlwZV0uZGVmYXVsdCB8fCBwYXR0ZXJuTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmluZGVyKFwiL2xkbWwvbnVtYmVycy9cIiArIGZvcm1hdFR5cGUgKyBcIkZvcm1hdHNbQG51bWJlclN5c3RlbSA9ICdcIiArIG51bWJlclN5c3RlbUlkICsgXCInXS91bml0UGF0dGVyblwiKS5mb3JFYWNoKGZ1bmN0aW9uICh1bml0UGF0dGVybk5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSB1bml0UGF0dGVybk5vZGUuZ2V0QXR0cmlidXRlKCdjb3VudCcpO1xuICAgICAgICAgICAgICAgIG51bWJlckZvcm1hdHMgPSBudW1iZXJGb3JtYXRzIHx8IHt9O1xuICAgICAgICAgICAgICAgIG51bWJlckZvcm1hdHNbZm9ybWF0VHlwZV0gPSBudW1iZXJGb3JtYXRzW2Zvcm1hdFR5cGVdIHx8IHt9O1xuICAgICAgICAgICAgICAgIG51bWJlckZvcm1hdHNbZm9ybWF0VHlwZV1bY291bnRdID0gbnVtYmVyRm9ybWF0c1tmb3JtYXRUeXBlXVtjb3VudF0gfHwgdW5pdFBhdHRlcm5Ob2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZpbmRlcihcIi9sZG1sL251bWJlcnMvY3VycmVuY3lGb3JtYXRzW0BudW1iZXJTeXN0ZW0gPSAnXCIgKyBudW1iZXJTeXN0ZW1JZCArIFwiJ10vY3VycmVuY3lTcGFjaW5nXCIpLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbmN5U3BhY2luZ05vZGUpIHtcbiAgICAgICAgICAgIG51bWJlckZvcm1hdHMgPSBudW1iZXJGb3JtYXRzIHx8IHt9O1xuICAgICAgICAgICAgbnVtYmVyRm9ybWF0cy5jdXJyZW5jeSA9IG51bWJlckZvcm1hdHMuY3VycmVuY3kgfHwge307XG4gICAgICAgICAgICBudW1iZXJGb3JtYXRzLmN1cnJlbmN5LmN1cnJlbmN5U3BhY2luZyA9IG51bWJlckZvcm1hdHMuY3VycmVuY3kuY3VycmVuY3lTcGFjaW5nIHx8IHt9O1xuXG4gICAgICAgICAgICBbJ2JlZm9yZScsICdhZnRlciddLmZvckVhY2goZnVuY3Rpb24gKHBsYWNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBsYWNlRGF0YSA9IG51bWJlckZvcm1hdHMuY3VycmVuY3kuY3VycmVuY3lTcGFjaW5nW3BsYWNlICsgJ0N1cnJlbmN5J10gPSBudW1iZXJGb3JtYXRzLmN1cnJlbmN5LmN1cnJlbmN5U3BhY2luZ1twbGFjZSArICdDdXJyZW5jeSddIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgWydjdXJyZW5jeU1hdGNoJywgJ3N1cnJvdW5kaW5nTWF0Y2gnLCAnaW5zZXJ0QmV0d2VlbiddLmZvckVhY2goZnVuY3Rpb24gKHNwYWNpbmdQcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0geHBhdGguc2VsZWN0KHBsYWNlICsgXCJDdXJyZW5jeS9cIiArIHNwYWNpbmdQcm9wZXJ0eU5hbWUsIGN1cnJlbmN5U3BhY2luZ05vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyRm9ybWF0cy5jdXJyZW5jeS5jdXJyZW5jeVNwYWNpbmdbcGxhY2UgKyAnQ3VycmVuY3knXVtzcGFjaW5nUHJvcGVydHlOYW1lXSA9IG1hdGNoWzBdLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBbJ2N1cnJlbmN5TWF0Y2gnLCAnc3Vycm91bmRpbmdNYXRjaCddLmZvckVhY2goZnVuY3Rpb24gKHNwYWNpbmdQcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsYWNlRGF0YVtzcGFjaW5nUHJvcGVydHlOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VEYXRhW3NwYWNpbmdQcm9wZXJ0eU5hbWVdID0gdW5pY29kZXJlZ2V4cC5leHBhbmRDbGRyVW5pY29kZVNldElkVG9DaGFyYWN0ZXJDbGFzcyhwbGFjZURhdGFbc3BhY2luZ1Byb3BlcnR5TmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG51bWJlckZvcm1hdHM7XG4gICAgfSxcblxuICAgIGV4dHJhY3REZWZhdWx0TnVtYmVyU3lzdGVtSWQ6IGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICBkZWZhdWx0TnVtYmVyU3lzdGVtSWQ7XG4gICAgICAgIGZpbmRlcignL2xkbWwvbnVtYmVycy9kZWZhdWx0TnVtYmVyaW5nU3lzdGVtJykuZm9yRWFjaChmdW5jdGlvbiAoZGVmYXVsdE51bWJlcmluZ1N5c3RlbU5vZGUpIHtcbiAgICAgICAgICAgIGRlZmF1bHROdW1iZXJTeXN0ZW1JZCA9IGRlZmF1bHROdW1iZXJTeXN0ZW1JZCB8fCBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZWZhdWx0TnVtYmVyU3lzdGVtSWQ7XG4gICAgfSxcblxuICAgIGV4dHJhY3RVbml0UGF0dGVybnM6IGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuICAgICAgICB2YXIgZmluZGVyID0gdGhpcy5jcmVhdGVGaW5kZXIodGhpcy5nZXRQcmlvcml0aXplZERvY3VtZW50c0ZvckxvY2FsZShsb2NhbGVJZCwgJ21haW4nKSksXG4gICAgICAgICAgICB1bml0UGF0dGVybnMgPSB7fTtcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvdW5pdHMvdW5pdExlbmd0aC91bml0L3VuaXRQYXR0ZXJuXCIpLmZvckVhY2goZnVuY3Rpb24gKHVuaXRQYXR0ZXJuTm9kZSkge1xuICAgICAgICAgICAgdmFyIHVuaXROb2RlID0gdW5pdFBhdHRlcm5Ob2RlLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgdW5pdExlbmd0aCA9IHVuaXROb2RlLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyksXG4gICAgICAgICAgICAgICAgdW5pdElkID0gbm9ybWFsaXplUHJvcGVydHkodW5pdE5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJykpO1xuICAgICAgICAgICAgdW5pdFBhdHRlcm5zW3VuaXRMZW5ndGhdID0gdW5pdFBhdHRlcm5zW3VuaXRMZW5ndGhdIHx8IHt9O1xuICAgICAgICAgICAgdW5pdFBhdHRlcm5zW3VuaXRMZW5ndGhdLnVuaXQgPSB1bml0UGF0dGVybnNbdW5pdExlbmd0aF0udW5pdCB8fCB7fTtcbiAgICAgICAgICAgIHVuaXRQYXR0ZXJuc1t1bml0TGVuZ3RoXS51bml0W3VuaXRJZF0gPSB1bml0UGF0dGVybnNbdW5pdExlbmd0aF0udW5pdFt1bml0SWRdIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gdW5pdFBhdHRlcm5Ob2RlLmdldEF0dHJpYnV0ZSgnY291bnQnKTtcbiAgICAgICAgICAgIHVuaXRQYXR0ZXJuc1t1bml0TGVuZ3RoXS51bml0W3VuaXRJZF1bY291bnRdID0gdW5pdFBhdHRlcm5zW3VuaXRMZW5ndGhdLnVuaXRbdW5pdElkXVtjb3VudF0gfHwgdW5pdFBhdHRlcm5Ob2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvdW5pdHMvdW5pdExlbmd0aC9jb21wb3VuZFVuaXQvY29tcG91bmRVbml0UGF0dGVyblwiKS5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb3VuZFVuaXRQYXR0ZXJuTm9kZSkge1xuICAgICAgICAgICAgdmFyIGNvbXBvdW5kVW5pdE5vZGUgPSBjb21wb3VuZFVuaXRQYXR0ZXJuTm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgIHVuaXRMZW5ndGggPSBjb21wb3VuZFVuaXROb2RlLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyksXG4gICAgICAgICAgICAgICAgY29tcG91bmRVbml0SWQgPSBjb21wb3VuZFVuaXROb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuXG4gICAgICAgICAgICB1bml0UGF0dGVybnNbdW5pdExlbmd0aF0uY29tcG91bmRVbml0ID0gdW5pdFBhdHRlcm5zW3VuaXRMZW5ndGhdLmNvbXBvdW5kVW5pdCB8fCB7fTtcbiAgICAgICAgICAgIHVuaXRQYXR0ZXJuc1t1bml0TGVuZ3RoXS5jb21wb3VuZFVuaXRbY29tcG91bmRVbml0SWRdID0gY29tcG91bmRVbml0UGF0dGVybk5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pdFBhdHRlcm5zO1xuICAgIH0sXG5cbiAgICBleHRyYWN0RGVsaW1pdGVyczogZnVuY3Rpb24gKGxvY2FsZUlkKSB7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIGRlbGltaXRlcnMgPSB7fTtcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvZGVsaW1pdGVycy8qXCIpLmZvckVhY2goZnVuY3Rpb24gKGRlbGltaXRlck5vZGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZGVsaW1pdGVyTm9kZS5ub2RlTmFtZTtcbiAgICAgICAgICAgIGRlbGltaXRlcnNbdHlwZV0gPSBkZWxpbWl0ZXJzW3R5cGVdIHx8IGRlbGltaXRlck5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVsaW1pdGVycztcbiAgICB9LFxuXG4gICAgZXh0cmFjdExpc3RQYXR0ZXJuczogZnVuY3Rpb24gKGxvY2FsZUlkKSB7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAnbWFpbicpKSxcbiAgICAgICAgICAgIGxpc3RQYXR0ZXJucyA9IHt9O1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC9saXN0UGF0dGVybnMvbGlzdFBhdHRlcm4vbGlzdFBhdHRlcm5QYXJ0XCIpLmZvckVhY2goZnVuY3Rpb24gKGxpc3RQYXR0ZXJuUGFydE5vZGUpIHtcbiAgICAgICAgICAgIHZhciBsaXN0UGF0dGVyblR5cGVBdHRyaWJ1dGUgPSBsaXN0UGF0dGVyblBhcnROb2RlLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyksXG4gICAgICAgICAgICAgICAgdHlwZSA9IGxpc3RQYXR0ZXJuVHlwZUF0dHJpYnV0ZSA/IG5vcm1hbGl6ZVByb3BlcnR5KGxpc3RQYXR0ZXJuVHlwZUF0dHJpYnV0ZSkgOiAnZGVmYXVsdCcsXG4gICAgICAgICAgICAgICAgcGFydCA9IGxpc3RQYXR0ZXJuUGFydE5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgICAgICBsaXN0UGF0dGVybnNbdHlwZV0gPSBsaXN0UGF0dGVybnNbdHlwZV0gfHwge307XG4gICAgICAgICAgICBsaXN0UGF0dGVybnNbdHlwZV1bcGFydF0gPSBsaXN0UGF0dGVybnNbdHlwZV1bcGFydF0gfHwgbGlzdFBhdHRlcm5QYXJ0Tm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsaXN0UGF0dGVybnM7XG4gICAgfSxcblxuICAgIGV4dHJhY3RDaGFyYWN0ZXJzOiBmdW5jdGlvbiAobG9jYWxlSWQpIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgY2hhcmFjdGVycyA9IHtcbiAgICAgICAgICAgICAgICBleGVtcGxhcjoge30sXG4gICAgICAgICAgICAgICAgZWxsaXBzaXM6IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICBmaW5kZXIoXCIvbGRtbC9jaGFyYWN0ZXJzL2V4ZW1wbGFyQ2hhcmFjdGVyc1wiKS5mb3JFYWNoKGZ1bmN0aW9uIChleGVtcGxhckNoYXJhY3RlcnNOb2RlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZUF0dHIgPSBleGVtcGxhckNoYXJhY3RlcnNOb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpLFxuICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlQXR0ciB8fCAnZGVmYXVsdCc7XG4gICAgICAgICAgICBjaGFyYWN0ZXJzLmV4ZW1wbGFyW3R5cGVdID0gY2hhcmFjdGVycy5leGVtcGxhclt0eXBlXSB8fCBleGVtcGxhckNoYXJhY3RlcnNOb2RlLnRleHRDb250ZW50LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJykuc3BsaXQoXCIgXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvY2hhcmFjdGVycy9lbGxpcHNpc1wiKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGxpcHNpc05vZGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZWxsaXBzaXNOb2RlLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICAgICAgY2hhcmFjdGVycy5lbGxpcHNpc1t0eXBlXSA9IGNoYXJhY3RlcnMuZWxsaXBzaXNbdHlwZV0gfHwgZWxsaXBzaXNOb2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgZmluZGVyKFwiL2xkbWwvY2hhcmFjdGVycy9tb3JlSW5mb3JtYXRpb25cIikuZm9yRWFjaChmdW5jdGlvbiAobW9yZUluZm9ybWF0aW9uTm9kZSkge1xuICAgICAgICAgICAgY2hhcmFjdGVycy5tb3JlSW5mb3JtYXRpb24gPSBjaGFyYWN0ZXJzLm1vcmVJbmZvcm1hdGlvbiB8fCBtb3JlSW5mb3JtYXRpb25Ob2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNoYXJhY3RlcnM7XG4gICAgfSxcblxuICAgIGV4dHJhY3RQbHVyYWxSdWxlRnVuY3Rpb246IGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICBkb2N1bWVudCA9IHRoYXQuZ2V0RG9jdW1lbnQoUGF0aC5yZXNvbHZlKHRoYXQuY2xkclBhdGgsICdjb21tb24nLCAnc3VwcGxlbWVudGFsJywgJ3BsdXJhbHMueG1sJykpLFxuICAgICAgICAgICAgc3ViTG9jYWxlSWRzID0gZXhwYW5kTG9jYWxlSWRUb1ByaW9yaXRpemVkTGlzdChsb2NhbGVJZCksXG4gICAgICAgICAgICBzdGF0ZW1lbnRBc3RzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IHN1YkxvY2FsZUlkcy5sZW5ndGggOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBzdWJMb2NhbGVJZCA9IHN1YkxvY2FsZUlkc1tpXSxcbiAgICAgICAgICAgICAgICBtYXRjaExvY2FsZXNYUGF0aEV4cHIgPVxuICAgICAgICAgICAgICAgICAgICBcIkBsb2NhbGVzID0gJ1wiICsgc3ViTG9jYWxlSWQgKyBcIicgb3IgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInN0YXJ0cy13aXRoKEBsb2NhbGVzLCAnXCIgKyBzdWJMb2NhbGVJZCArIFwiJykgb3IgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImNvbnRhaW5zKEBsb2NhbGVzLCAnIFwiICsgc3ViTG9jYWxlSWQgKyBcIiAnKSBvciBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwic3Vic3RyaW5nKEBsb2NhbGVzLCBzdHJpbmctbGVuZ3RoKEBsb2NhbGVzKSAtIHN0cmluZy1sZW5ndGgoJyBcIiArIHN1YkxvY2FsZUlkICsgXCInKSArIDEpID0gJyBcIiArIHN1YkxvY2FsZUlkICsgXCInXCIsXG4gICAgICAgICAgICAgICAgcGx1cmFsUnVsZXNOb2RlcyA9IHhwYXRoLnNlbGVjdChcIi9zdXBwbGVtZW50YWxEYXRhL3BsdXJhbHMvcGx1cmFsUnVsZXNbXCIgKyBtYXRjaExvY2FsZXNYUGF0aEV4cHIgKyBcIl1cIiwgZG9jdW1lbnQpLFxuICAgICAgICAgICAgICAgIGNsZHJQbHVyYWxSdWxlU2V0ID0gbmV3IENsZHJQbHVyYWxSdWxlU2V0KCk7XG4gICAgICAgICAgICBpZiAocGx1cmFsUnVsZXNOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgeHBhdGguc2VsZWN0KFwicGx1cmFsUnVsZVwiLCBwbHVyYWxSdWxlc05vZGVzWzBdKS5mb3JFYWNoKGZ1bmN0aW9uIChwbHVyYWxSdWxlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjbGRyUGx1cmFsUnVsZVNldC5hZGRSdWxlKHBsdXJhbFJ1bGVOb2RlLnRleHRDb250ZW50LCBwbHVyYWxSdWxlTm9kZS5nZXRBdHRyaWJ1dGUoJ2NvdW50JykpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXRlbWVudEFzdHMgPSBjbGRyUGx1cmFsUnVsZVNldC50b0phdmFTY3JpcHRGdW5jdGlvbkJvZHlBc3QoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwiblwiLCB1Z2xpZnlKcy51Z2xpZnkuZ2VuX2NvZGUoWyd0b3BsZXZlbCcsIHN0YXRlbWVudEFzdHNdKSk7XG4gICAgfSxcblxuICAgIC8vICd0eXBlcycgaXMgb3B0aW9uYWwsIGRlZmF1bHRzIHRvIGFsbCBhdmFpbGFibGVcbiAgICBleHRyYWN0UmJuZkZ1bmN0aW9uQnlUeXBlOiBmdW5jdGlvbiAobG9jYWxlSWQsIHR5cGVzKSB7XG4gICAgICAgIHZhciBmaW5kZXIgPSB0aGlzLmNyZWF0ZUZpbmRlcih0aGlzLmdldFByaW9yaXRpemVkRG9jdW1lbnRzRm9yTG9jYWxlKGxvY2FsZUlkLCAncmJuZicpKSxcbiAgICAgICAgICAgIGNsZHJSYm5mUnVsZVNldEJ5VHlwZSA9IHt9O1xuICAgICAgICBmaW5kZXIoJy9sZG1sL3JibmYvcnVsZXNldEdyb3VwaW5nL3J1bGVzZXQvcmJuZnJ1bGUnKS5mb3JFYWNoKGZ1bmN0aW9uIChyYm5mUnVsZU5vZGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gQ2xkclJibmZSdWxlU2V0LmdldFNhZmVSZW5kZXJlck5hbWUocmJuZlJ1bGVOb2RlLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJykpLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gcmJuZlJ1bGVOb2RlLmdldEF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgICAgICAgIGNsZHJSYm5mUnVsZVNldEJ5VHlwZVt0eXBlXSA9IGNsZHJSYm5mUnVsZVNldEJ5VHlwZVt0eXBlXSB8fCBuZXcgQ2xkclJibmZSdWxlU2V0KHt0eXBlOiB0eXBlfSk7XG4gICAgICAgICAgICBpZiAoIWNsZHJSYm5mUnVsZVNldEJ5VHlwZVt0eXBlXS5ydWxlQnlWYWx1ZVt2YWx1ZV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFkaXhBdHRyaWJ1dGUgPSByYm5mUnVsZU5vZGUuZ2V0QXR0cmlidXRlKCdyYWRpeCcpO1xuICAgICAgICAgICAgICAgIGNsZHJSYm5mUnVsZVNldEJ5VHlwZVt0eXBlXS5ydWxlQnlWYWx1ZVt2YWx1ZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmJuZjogcmJuZlJ1bGVOb2RlLnRleHRDb250ZW50LnJlcGxhY2UoLzskLywgJycpLnJlcGxhY2UoL+KGkC9nLCAnPCcpLnJlcGxhY2UoL+KGki9nLCAnPicpLFxuICAgICAgICAgICAgICAgICAgICByYWRpeDogcmFkaXhBdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGlzQWRkZWRCeVR5cGUgPSB7fSxcbiAgICAgICAgICAgIHR5cGVzVG9BZGQgPSB0eXBlcyA/IFtdLmNvbmNhdCh0eXBlcykgOiBPYmplY3Qua2V5cyhjbGRyUmJuZlJ1bGVTZXRCeVR5cGUpLFxuICAgICAgICAgICAgcmJuZkZ1bmN0aW9uQnlUeXBlID0ge1xuICAgICAgICAgICAgICAgIHJlbmRlck51bWJlcjogU3RyaW5nIC8vIFByb3ZpZGUgYSAoYmFkKSBkZWZhdWx0IG51bWJlciByZW5kZXJpbmcgaW1wbGVtZW50YXRpb24gdG8gYXZvaWQgIzEzXG4gICAgICAgICAgICB9O1xuICAgICAgICB3aGlsZSAodHlwZXNUb0FkZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVzVG9BZGQuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICghKHR5cGUgaW4gaXNBZGRlZEJ5VHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpc0FkZGVkQnlUeXBlW3R5cGVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgY2xkclJibmZSdWxlU2V0ID0gY2xkclJibmZSdWxlU2V0QnlUeXBlW3R5cGVdO1xuICAgICAgICAgICAgICAgIC8vIFNvbWUgcnVsZXMgYXJlbid0IGF2YWlsYWJsZSBpbiBzb21lIGxvY2FsZXMgKHN1Y2ggYXMgc3BlbGxvdXQtY2FyZGluYWwtZmluYW5jaWFsKS5cbiAgICAgICAgICAgICAgICAvLyBUaGUgZWFzaWVzdCB0aGluZyBpcyBqdXN0IHRvIHNraXAgdGhlIG1pc3Npbmcgb25lcyBoZXJlLCBldmVuIHRob3VnaCBpdCBjYW4gcHJvZHVjZVxuICAgICAgICAgICAgICAgIC8vIHNvbWUgYnJva2VuIGZ1bmN0aW9uIHNldHM6XG4gICAgICAgICAgICAgICAgaWYgKGNsZHJSYm5mUnVsZVNldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY2xkclJibmZSdWxlU2V0LnRvRnVuY3Rpb25Bc3QoKTtcblxuICAgICAgICAgICAgICAgICAgICByYm5mRnVuY3Rpb25CeVR5cGVbdHlwZV0gPSBuZXcgRnVuY3Rpb24oXCJuXCIsIHVnbGlmeUpzLnVnbGlmeS5nZW5fY29kZShbJ3RvcGxldmVsJywgcmVzdWx0LmZ1bmN0aW9uQXN0WzNdXSkpO1xuICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0eXBlc1RvQWRkLCByZXN1bHQuZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJibmZGdW5jdGlvbkJ5VHlwZTtcbiAgICB9LFxuXG4gICAgZXh0cmFjdERpZ2l0c0J5TnVtYmVyU3lzdGVtSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudChQYXRoLnJlc29sdmUodGhpcy5jbGRyUGF0aCwgJ2NvbW1vbicsICdzdXBwbGVtZW50YWwnLCAnbnVtYmVyaW5nU3lzdGVtcy54bWwnKSksXG4gICAgICAgICAgICBkaWdpdHNCeU51bWJlclN5c3RlbUlkID0ge307XG5cbiAgICAgICAgeHBhdGguc2VsZWN0KCcvc3VwcGxlbWVudGFsRGF0YS9udW1iZXJpbmdTeXN0ZW1zL251bWJlcmluZ1N5c3RlbScsIGRvY3VtZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChudW1iZXJpbmdTeXN0ZW1Ob2RlKSB7XG4gICAgICAgICAgICB2YXIgbnVtYmVyU3lzdGVtSWQgPSBudW1iZXJpbmdTeXN0ZW1Ob2RlLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgICAgIGlmIChudW1iZXJpbmdTeXN0ZW1Ob2RlLmdldEF0dHJpYnV0ZSgndHlwZScpID09PSAnbnVtZXJpYycpIHtcbiAgICAgICAgICAgICAgICBkaWdpdHNCeU51bWJlclN5c3RlbUlkW251bWJlclN5c3RlbUlkXSA9IG51bWJlcmluZ1N5c3RlbU5vZGUuZ2V0QXR0cmlidXRlKCdkaWdpdHMnKS5zcGxpdCgvKD86KS8pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0eXBlPSdhbGdvcml0aG1pYydcbiAgICAgICAgICAgICAgICB2YXIgcnVsZXNBdHRyaWJ1dGVGcmFnbWVudHMgPSBudW1iZXJpbmdTeXN0ZW1Ob2RlLmdldEF0dHJpYnV0ZSgncnVsZXMnKS5zcGxpdCgnLycpLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VMb2NhbGVJZCA9IHJ1bGVzQXR0cmlidXRlRnJhZ21lbnRzLmxlbmd0aCA9PT0gMyA/IG5vcm1hbGl6ZUxvY2FsZUlkKHJ1bGVzQXR0cmlidXRlRnJhZ21lbnRzWzBdKSA6ICdyb290JyxcbiAgICAgICAgICAgICAgICAgICAgcnVsZVR5cGUgPSBDbGRyUmJuZlJ1bGVTZXQuZ2V0U2FmZVJlbmRlcmVyTmFtZShydWxlc0F0dHJpYnV0ZUZyYWdtZW50c1tydWxlc0F0dHJpYnV0ZUZyYWdtZW50cy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgZGlnaXRzQnlOdW1iZXJTeXN0ZW1JZFtudW1iZXJTeXN0ZW1JZF0gPSBydWxlVHlwZTsgLy8gQSBzdHJpbmcgdmFsdWUgbWVhbnMgXCJ1c2UgdGhpcyByYm5mIHJlbmRlcmVyIGZvciB0aGUgZGlnaXRzXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHJldHVybiBkaWdpdHNCeU51bWJlclN5c3RlbUlkO1xuICAgIH0sXG5cbiAgICBleHRyYWN0TGF5b3V0OiBmdW5jdGlvbiAobG9jYWxlSWQpIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IHRoaXMuY3JlYXRlRmluZGVyKHRoaXMuZ2V0UHJpb3JpdGl6ZWREb2N1bWVudHNGb3JMb2NhbGUobG9jYWxlSWQsICdtYWluJykpLFxuICAgICAgICAgICAgbGF5b3V0ID0ge307XG4gICAgICAgIGZpbmRlcihcIi9sZG1sL2xheW91dC8qLypcIikuZm9yRWFjaChmdW5jdGlvbiAobGVhZk5vZGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gbGVhZk5vZGUubm9kZU5hbWUsXG4gICAgICAgICAgICAgICAgcGFyZW50VHlwZSA9IGxlYWZOb2RlLnBhcmVudE5vZGUubm9kZU5hbWU7XG4gICAgICAgICAgICBsYXlvdXRbcGFyZW50VHlwZV0gPSBsYXlvdXRbcGFyZW50VHlwZV0gfHwge307XG4gICAgICAgICAgICBsYXlvdXRbcGFyZW50VHlwZV1bdHlwZV0gPSBsYXlvdXRbcGFyZW50VHlwZV1bdHlwZV0gfHwgbGVhZk5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGF5b3V0O1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IENsZHIoUGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJy4uLzNyZHBhcnR5L2NsZHIvJykpO1xubW9kdWxlLmV4cG9ydHMubG9hZCA9IGZ1bmN0aW9uIChjbGRyUGF0aCkge1xuICAgIHJldHVybiBuZXcgQ2xkcihjbGRyUGF0aCk7XG59O1xuIiwiZXhwb3J0cy5pID0gZnVuY3Rpb24gaShuKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xufTtcblxuZXhwb3J0cy52ID0gZnVuY3Rpb24gdihuKSB7XG4gICAgcmV0dXJuIG4udG9TdHJpbmcoKS5yZXBsYWNlKC9eW14uXSpcXC4/LywgJycpLmxlbmd0aDtcbn07XG5cbmV4cG9ydHMudyA9IGZ1bmN0aW9uIHcobikge1xuICAgIHJldHVybiBuLnRvU3RyaW5nKCkucmVwbGFjZSgvXlteLl0qXFwuP3wwKyQvZywgJycpLmxlbmd0aDtcbn07XG5cbmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGYobikge1xuICAgIHJldHVybiBwYXJzZUludChuLnRvU3RyaW5nKCkucmVwbGFjZSgvXlteLl0qXFwuPy8sICcnKSwgMTApIHx8IDA7XG59O1xuXG5leHBvcnRzLnQgPSBmdW5jdGlvbiB0KG4pIHtcbiAgICByZXR1cm4gcGFyc2VJbnQobi50b1N0cmluZygpLnJlcGxhY2UoL15bXi5dKlxcLj98MCskL2csICcnKSwgMTApIHx8IDA7XG59O1xuIiwiLy8gQ29udmVydCBvYmplY3RzIHdpdGggYWxsIGludGVnZXIga2V5cyBzdGFydGluZyBmcm9tIDAgdG8gYXJyYXlzIGFuZCByZW1vdmUgdW5kZWZpbmVkIHZhbHVlczpcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29udmVydE9iamVjdHNXaXRoSW50ZWdlcktleXNUb0FycmF5cyhvYmopIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHJldHVybiBvYmoubWFwKGNvbnZlcnRPYmplY3RzV2l0aEludGVnZXJLZXlzVG9BcnJheXMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgaWYgKDAgaW4gb2JqIHx8IDEgaW4gb2JqKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3ROdW1lcmljS2V5TnVtYmVyID0gMCBpbiBvYmogPyAwIDogMSxcbiAgICAgICAgICAgICAgICBuZXh0TnVtZXJpY0tleU51bWJlciA9IGZpcnN0TnVtZXJpY0tleU51bWJlciArIDE7XG4gICAgICAgICAgICB3aGlsZSAobmV4dE51bWVyaWNLZXlOdW1iZXIgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgbmV4dE51bWVyaWNLZXlOdW1iZXIgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDAgJiYgbmV4dE51bWVyaWNLZXlOdW1iZXIgPT09IGtleXMubGVuZ3RoICsgZmlyc3ROdW1lcmljS2V5TnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFycmF5ID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCA7IGkgPCBmaXJzdE51bWVyaWNLZXlOdW1iZXIgOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXkucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBmaXJzdE51bWVyaWNLZXlOdW1iZXIgOyBpIDwga2V5cy5sZW5ndGggOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXkucHVzaChjb252ZXJ0T2JqZWN0c1dpdGhJbnRlZ2VyS2V5c1RvQXJyYXlzKG9ialtpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdE9iaiA9IHt9O1xuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmpba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRPYmpba2V5XSA9IGNvbnZlcnRPYmplY3RzV2l0aEludGVnZXJLZXlzVG9BcnJheXMob2JqW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdE9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbn07XG4iLCIvLyBDcmVhdGUgYSBtZW1vaXplciBmb3IgYW4gYXN5bmMgZnVuY3Rpb25cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWVtb2l6ZUFzeW5jKGZuKSB7XG4gICAgdmFyIHJlc3VsdEFyZ3VtZW50cyxcbiAgICAgICAgd2FpdGluZ0NhbGxiYWNrcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgaWYgKHJlc3VsdEFyZ3VtZW50cykge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgcmVzdWx0QXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHdhaXRpbmdDYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICB3YWl0aW5nQ2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3YWl0aW5nQ2FsbGJhY2tzID0gW2NiXTtcbiAgICAgICAgICAgICAgICBmbihmdW5jdGlvbiAoKSB7IC8vIC4uLlxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0QXJndW1lbnRzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICB3YWl0aW5nQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHdhaXRpbmdDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FpdGluZ0NhbGxiYWNrLmFwcGx5KHRoaXMsIHJlc3VsdEFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB3YWl0aW5nQ2FsbGJhY2tzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuIiwiLypcbiAqIFJlcGxhY2UgLSB3aXRoIF8gYW5kIGNvbnZlcnQgdG8gbG93ZXIgY2FzZTogZW4tR0IgPT4gZW5fZ2JcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGVJZChsb2NhbGVJZCkge1xuICAgIHJldHVybiBsb2NhbGVJZCAmJiBsb2NhbGVJZC5yZXBsYWNlKC8tL2csICdfJykudG9Mb3dlckNhc2UoKTtcbn07XG4iLCIvKlxuICogQ29udmVydCBmb28tYmFyIGF0dHJpYnV0ZSB2YWx1ZXMgdG8gZm9vQmFyIEphdmFTY3JpcHQga2V5c1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BlcnR5KHN0cikge1xuXHRyZXR1cm4gc3RyLnJlcGxhY2UoLy0oW2Etel0pL2csIGZ1bmN0aW9uICgkMCwgY2gpIHtcbiAgICAgICAgcmV0dXJuIGNoLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXNzRXJyb3IoZXJyb3JDYWxsYmFjaywgc3VjY2Vzc0NhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHsgLy8gLi4uXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdWNjZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjay5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4iLCIvKlxuICogUEVHLmpzIDAuNy4wXG4gKlxuICogaHR0cDovL3BlZ2pzLm1hamRhLmN6L1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEyIERhdmlkIE1hamRhXG4gKiBMaWNlbnNlbmQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG52YXIgUEVHID0gKGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuXG52YXIgUEVHID0ge1xuICAvKiBQRUcuanMgdmVyc2lvbiAodXNlcyBzZW1hbnRpYyB2ZXJzaW9uaW5nKS4gKi9cbiAgVkVSU0lPTjogXCIwLjcuMFwiLFxuXG4gIC8qXG4gICAqIEdlbmVyYXRlcyBhIHBhcnNlciBmcm9tIGEgc3BlY2lmaWVkIGdyYW1tYXIgYW5kIHJldHVybnMgaXQuXG4gICAqXG4gICAqIFRoZSBncmFtbWFyIG11c3QgYmUgYSBzdHJpbmcgaW4gdGhlIGZvcm1hdCBkZXNjcmliZWQgYnkgdGhlIG1ldGFncmFtYXIgaW5cbiAgICogdGhlIHBhcnNlci5wZWdqcyBmaWxlLlxuICAgKlxuICAgKiBUaHJvd3MgfFBFRy5wYXJzZXIuU3ludGF4RXJyb3J8IGlmIHRoZSBncmFtbWFyIGNvbnRhaW5zIGEgc3ludGF4IGVycm9yIG9yXG4gICAqIHxQRUcuR3JhbW1hckVycm9yfCBpZiBpdCBjb250YWlucyBhIHNlbWFudGljIGVycm9yLiBOb3RlIHRoYXQgbm90IGFsbFxuICAgKiBlcnJvcnMgYXJlIGRldGVjdGVkIGR1cmluZyB0aGUgZ2VuZXJhdGlvbiBhbmQgc29tZSBtYXkgcHJvdHJ1ZGUgdG8gdGhlXG4gICAqIGdlbmVyYXRlZCBwYXJzZXIgYW5kIGNhdXNlIGl0cyBtYWxmdW5jdGlvbi5cbiAgICovXG4gIGJ1aWxkUGFyc2VyOiBmdW5jdGlvbihncmFtbWFyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFBFRy5jb21waWxlci5jb21waWxlKFBFRy5wYXJzZXIucGFyc2UoZ3JhbW1hciksIG9wdGlvbnMpO1xuICB9XG59O1xuXG4vKiBUaHJvd24gd2hlbiB0aGUgZ3JhbW1hciBjb250YWlucyBhbiBlcnJvci4gKi9cblxuUEVHLkdyYW1tYXJFcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgdGhpcy5uYW1lID0gXCJQRUcuR3JhbW1hckVycm9yXCI7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59O1xuXG5QRUcuR3JhbW1hckVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuLyogTGlrZSBQeXRob24ncyB8cmFuZ2V8LCBidXQgd2l0aG91dCB8c3RlcHwuICovXG5mdW5jdGlvbiByYW5nZShzdGFydCwgc3RvcCkge1xuICBpZiAoc3RvcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RvcCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoTWF0aC5tYXgoMCwgc3RvcCAtIHN0YXJ0KSk7XG4gIGZvciAodmFyIGkgPSAwLCBqID0gc3RhcnQ7IGogPCBzdG9wOyBpKyssIGorKykge1xuICAgIHJlc3VsdFtpXSA9IGo7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZmluZChhcnJheSwgY2FsbGJhY2spIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChjYWxsYmFjayhhcnJheVtpXSkpIHtcbiAgICAgIHJldHVybiBhcnJheVtpXTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29udGFpbnMoYXJyYXksIHZhbHVlKSB7XG4gIC8qXG4gICAqIFN0dXBpZCBJRSBkb2VzIG5vdCBoYXZlIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLCBvdGhlcndpc2UgdGhpcyBmdW5jdGlvblxuICAgKiB3b3VsZCBiZSBhIG9uZS1saW5lci5cbiAgICovXG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBlYWNoKGFycmF5LCBjYWxsYmFjaykge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY2FsbGJhY2soYXJyYXlbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcChhcnJheSwgY2FsbGJhY2spIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0W2ldID0gY2FsbGJhY2soYXJyYXlbaV0sIGkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBsdWNrKGFycmF5LCBrZXkpIHtcbiAgcmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGVba2V5XTsgfSk7XG59XG5cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICByZXN1bHQucHVzaChvYmplY3Rba2V5XSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLypcbiAqIFJldHVybnMgYSBzdHJpbmcgcGFkZGVkIG9uIHRoZSBsZWZ0IHRvIGEgZGVzaXJlZCBsZW5ndGggd2l0aCBhIGNoYXJhY3Rlci5cbiAqXG4gKiBUaGUgY29kZSBuZWVkcyB0byBiZSBpbiBzeW5jIHdpdGggdGhlIGNvZGUgdGVtcGxhdGUgaW4gdGhlIGNvbXBpbGF0aW9uXG4gKiBmdW5jdGlvbiBmb3IgXCJhY3Rpb25cIiBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gcGFkTGVmdChpbnB1dCwgcGFkZGluZywgbGVuZ3RoKSB7XG4gIHZhciByZXN1bHQgPSBpbnB1dDtcblxuICB2YXIgcGFkTGVuZ3RoID0gbGVuZ3RoIC0gaW5wdXQubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZExlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0ID0gcGFkZGluZyArIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qXG4gKiBSZXR1cm5zIGFuIGVzY2FwZSBzZXF1ZW5jZSBmb3IgZ2l2ZW4gY2hhcmFjdGVyLiBVc2VzIFxceCBmb3IgY2hhcmFjdGVycyA8PVxuICogMHhGRiB0byBzYXZlIHNwYWNlLCBcXHUgZm9yIHRoZSByZXN0LlxuICpcbiAqIFRoZSBjb2RlIG5lZWRzIHRvIGJlIGluIHN5bmMgd2l0aCB0aGUgY29kZSB0ZW1wbGF0ZSBpbiB0aGUgY29tcGlsYXRpb25cbiAqIGZ1bmN0aW9uIGZvciBcImFjdGlvblwiIG5vZGVzLlxuICovXG5mdW5jdGlvbiBlc2NhcGUoY2gpIHtcbiAgdmFyIGNoYXJDb2RlID0gY2guY2hhckNvZGVBdCgwKTtcbiAgdmFyIGVzY2FwZUNoYXI7XG4gIHZhciBsZW5ndGg7XG5cbiAgaWYgKGNoYXJDb2RlIDw9IDB4RkYpIHtcbiAgICBlc2NhcGVDaGFyID0gJ3gnO1xuICAgIGxlbmd0aCA9IDI7XG4gIH0gZWxzZSB7XG4gICAgZXNjYXBlQ2hhciA9ICd1JztcbiAgICBsZW5ndGggPSA0O1xuICB9XG5cbiAgcmV0dXJuICdcXFxcJyArIGVzY2FwZUNoYXIgKyBwYWRMZWZ0KGNoYXJDb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLCAnMCcsIGxlbmd0aCk7XG59XG5cbi8qXG4gKiBTdXJyb3VuZHMgdGhlIHN0cmluZyB3aXRoIHF1b3RlcyBhbmQgZXNjYXBlcyBjaGFyYWN0ZXJzIGluc2lkZSBzbyB0aGF0IHRoZVxuICogcmVzdWx0IGlzIGEgdmFsaWQgSmF2YVNjcmlwdCBzdHJpbmcuXG4gKlxuICogVGhlIGNvZGUgbmVlZHMgdG8gYmUgaW4gc3luYyB3aXRoIHRoZSBjb2RlIHRlbXBsYXRlIGluIHRoZSBjb21waWxhdGlvblxuICogZnVuY3Rpb24gZm9yIFwiYWN0aW9uXCIgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIHF1b3RlKHMpIHtcbiAgLypcbiAgICogRUNNQS0yNjIsIDV0aCBlZC4sIDcuOC40OiBBbGwgY2hhcmFjdGVycyBtYXkgYXBwZWFyIGxpdGVyYWxseSBpbiBhIHN0cmluZ1xuICAgKiBsaXRlcmFsIGV4Y2VwdCBmb3IgdGhlIGNsb3NpbmcgcXVvdGUgY2hhcmFjdGVyLCBiYWNrc2xhc2gsIGNhcnJpYWdlIHJldHVybixcbiAgICogbGluZSBzZXBhcmF0b3IsIHBhcmFncmFwaCBzZXBhcmF0b3IsIGFuZCBsaW5lIGZlZWQuIEFueSBjaGFyYWN0ZXIgbWF5XG4gICAqIGFwcGVhciBpbiB0aGUgZm9ybSBvZiBhbiBlc2NhcGUgc2VxdWVuY2UuXG4gICAqXG4gICAqIEZvciBwb3J0YWJpbGl0eSwgd2UgYWxzbyBlc2NhcGUgZXNjYXBlIGFsbCBjb250cm9sIGFuZCBub24tQVNDSUlcbiAgICogY2hhcmFjdGVycy4gTm90ZSB0aGF0IFwiXFwwXCIgYW5kIFwiXFx2XCIgZXNjYXBlIHNlcXVlbmNlcyBhcmUgbm90IHVzZWQgYmVjYXVzZVxuICAgKiBKU0hpbnQgZG9lcyBub3QgbGlrZSB0aGUgZmlyc3QgYW5kIElFIHRoZSBzZWNvbmQuXG4gICAqL1xuICByZXR1cm4gJ1wiJyArIHNcbiAgICAucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKSAgLy8gYmFja3NsYXNoXG4gICAgLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSAgICAvLyBjbG9zaW5nIHF1b3RlIGNoYXJhY3RlclxuICAgIC5yZXBsYWNlKC9cXHgwOC9nLCAnXFxcXGInKSAvLyBiYWNrc3BhY2VcbiAgICAucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpICAgLy8gaG9yaXpvbnRhbCB0YWJcbiAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpICAgLy8gbGluZSBmZWVkXG4gICAgLnJlcGxhY2UoL1xcZi9nLCAnXFxcXGYnKSAgIC8vIGZvcm0gZmVlZFxuICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJykgICAvLyBjYXJyaWFnZSByZXR1cm5cbiAgICAucmVwbGFjZSgvW1xceDAwLVxceDA3XFx4MEJcXHgwRS1cXHgxRlxceDgwLVxcdUZGRkZdL2csIGVzY2FwZSlcbiAgICArICdcIic7XG59XG5cbi8qXG4gKiBFc2NhcGVzIGNoYXJhY3RlcnMgaW5zaWRlIHRoZSBzdHJpbmcgc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBhcyBhIGxpc3Qgb2ZcbiAqIGNoYXJhY3RlcnMgaW4gYSBjaGFyYWN0ZXIgY2xhc3Mgb2YgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKi9cbmZ1bmN0aW9uIHF1b3RlRm9yUmVnZXhwQ2xhc3Mocykge1xuICAvKlxuICAgKiBCYXNlZCBvbiBFQ01BLTI2MiwgNXRoIGVkLiwgNy44LjUgJiAxNS4xMC4xLlxuICAgKlxuICAgKiBGb3IgcG9ydGFiaWxpdHksIHdlIGFsc28gZXNjYXBlIGVzY2FwZSBhbGwgY29udHJvbCBhbmQgbm9uLUFTQ0lJXG4gICAqIGNoYXJhY3RlcnMuXG4gICAqL1xuICByZXR1cm4gc1xuICAgIC5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpICAvLyBiYWNrc2xhc2hcbiAgICAucmVwbGFjZSgvXFwvL2csICdcXFxcLycpICAgLy8gY2xvc2luZyBzbGFzaFxuICAgIC5yZXBsYWNlKC9cXF0vZywgJ1xcXFxdJykgICAvLyBjbG9zaW5nIGJyYWNrZXRcbiAgICAucmVwbGFjZSgvLS9nLCAnXFxcXC0nKSAgICAvLyBkYXNoXG4gICAgLnJlcGxhY2UoL1xcMC9nLCAnXFxcXDAnKSAgIC8vIG51bGxcbiAgICAucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpICAgLy8gaG9yaXpvbnRhbCB0YWJcbiAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpICAgLy8gbGluZSBmZWVkXG4gICAgLnJlcGxhY2UoL1xcdi9nLCAnXFxcXHgwQicpIC8vIHZlcnRpY2FsIHRhYlxuICAgIC5yZXBsYWNlKC9cXGYvZywgJ1xcXFxmJykgICAvLyBmb3JtIGZlZWRcbiAgICAucmVwbGFjZSgvXFxyL2csICdcXFxccicpICAgLy8gY2FycmlhZ2UgcmV0dXJuXG4gICAgLnJlcGxhY2UoL1tcXHgwMS1cXHgwOFxceDBFLVxceDFGXFx4ODAtXFx1RkZGRl0vZywgZXNjYXBlKTtcbn1cblxuLypcbiAqIEJ1aWxkcyBhIG5vZGUgdmlzaXRvciAtLSBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzIGEgbm9kZSBhbmQgYW55IG51bWJlciBvZlxuICogb3RoZXIgcGFyYW1ldGVycywgY2FsbHMgYW4gYXBwcm9wcmlhdGUgZnVuY3Rpb24gYWNjb3JkaW5nIHRvIHRoZSBub2RlIHR5cGUsXG4gKiBwYXNzZXMgaXQgYWxsIGl0cyBwYXJhbWV0ZXJzIGFuZCByZXR1cm5zIGl0cyB2YWx1ZS4gVGhlIGZ1bmN0aW9ucyBmb3IgdmFyaW91c1xuICogbm9kZSB0eXBlcyBhcmUgcGFzc2VkIGluIGEgcGFyYW1ldGVyIHRvIHxidWlsZE5vZGVWaXNpdG9yfCBhcyBhIGhhc2guXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkTm9kZVZpc2l0b3IoZnVuY3Rpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uc1tub2RlLnR5cGVdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRSdWxlQnlOYW1lKGFzdCwgbmFtZSkge1xuICByZXR1cm4gZmluZChhc3QucnVsZXMsIGZ1bmN0aW9uKHIpIHsgcmV0dXJuIHIubmFtZSA9PT0gbmFtZTsgfSk7XG59XG5QRUcucGFyc2VyID0gKGZ1bmN0aW9uKCl7XG4gIC8qXG4gICAqIEdlbmVyYXRlZCBieSBQRUcuanMgMC43LjAuXG4gICAqXG4gICAqIGh0dHA6Ly9wZWdqcy5tYWpkYS5jei9cbiAgICovXG4gIFxuICBmdW5jdGlvbiBxdW90ZShzKSB7XG4gICAgLypcbiAgICAgKiBFQ01BLTI2MiwgNXRoIGVkLiwgNy44LjQ6IEFsbCBjaGFyYWN0ZXJzIG1heSBhcHBlYXIgbGl0ZXJhbGx5IGluIGFcbiAgICAgKiBzdHJpbmcgbGl0ZXJhbCBleGNlcHQgZm9yIHRoZSBjbG9zaW5nIHF1b3RlIGNoYXJhY3RlciwgYmFja3NsYXNoLFxuICAgICAqIGNhcnJpYWdlIHJldHVybiwgbGluZSBzZXBhcmF0b3IsIHBhcmFncmFwaCBzZXBhcmF0b3IsIGFuZCBsaW5lIGZlZWQuXG4gICAgICogQW55IGNoYXJhY3RlciBtYXkgYXBwZWFyIGluIHRoZSBmb3JtIG9mIGFuIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgKlxuICAgICAqIEZvciBwb3J0YWJpbGl0eSwgd2UgYWxzbyBlc2NhcGUgZXNjYXBlIGFsbCBjb250cm9sIGFuZCBub24tQVNDSUlcbiAgICAgKiBjaGFyYWN0ZXJzLiBOb3RlIHRoYXQgXCJcXDBcIiBhbmQgXCJcXHZcIiBlc2NhcGUgc2VxdWVuY2VzIGFyZSBub3QgdXNlZFxuICAgICAqIGJlY2F1c2UgSlNIaW50IGRvZXMgbm90IGxpa2UgdGhlIGZpcnN0IGFuZCBJRSB0aGUgc2Vjb25kLlxuICAgICAqL1xuICAgICByZXR1cm4gJ1wiJyArIHNcbiAgICAgIC5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpICAvLyBiYWNrc2xhc2hcbiAgICAgIC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykgICAgLy8gY2xvc2luZyBxdW90ZSBjaGFyYWN0ZXJcbiAgICAgIC5yZXBsYWNlKC9cXHgwOC9nLCAnXFxcXGInKSAvLyBiYWNrc3BhY2VcbiAgICAgIC5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0JykgICAvLyBob3Jpem9udGFsIHRhYlxuICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKSAgIC8vIGxpbmUgZmVlZFxuICAgICAgLnJlcGxhY2UoL1xcZi9nLCAnXFxcXGYnKSAgIC8vIGZvcm0gZmVlZFxuICAgICAgLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKSAgIC8vIGNhcnJpYWdlIHJldHVyblxuICAgICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgwN1xceDBCXFx4MEUtXFx4MUZcXHg4MC1cXHVGRkZGXS9nLCBlc2NhcGUpXG4gICAgICArICdcIic7XG4gIH1cbiAgXG4gIHZhciByZXN1bHQgPSB7XG4gICAgLypcbiAgICAgKiBQYXJzZXMgdGhlIGlucHV0IHdpdGggYSBnZW5lcmF0ZWQgcGFyc2VyLiBJZiB0aGUgcGFyc2luZyBpcyBzdWNjZXNzZnVsbCxcbiAgICAgKiByZXR1cm5zIGEgdmFsdWUgZXhwbGljaXRseSBvciBpbXBsaWNpdGx5IHNwZWNpZmllZCBieSB0aGUgZ3JhbW1hciBmcm9tXG4gICAgICogd2hpY2ggdGhlIHBhcnNlciB3YXMgZ2VuZXJhdGVkIChzZWUgfFBFRy5idWlsZFBhcnNlcnwpLiBJZiB0aGUgcGFyc2luZyBpc1xuICAgICAqIHVuc3VjY2Vzc2Z1bCwgdGhyb3dzIHxQRUcucGFyc2VyLlN5bnRheEVycm9yfCBkZXNjcmliaW5nIHRoZSBlcnJvci5cbiAgICAgKi9cbiAgICBwYXJzZTogZnVuY3Rpb24oaW5wdXQsIHN0YXJ0UnVsZSkge1xuICAgICAgdmFyIHBhcnNlRnVuY3Rpb25zID0ge1xuICAgICAgICBcImdyYW1tYXJcIjogcGFyc2VfZ3JhbW1hcixcbiAgICAgICAgXCJpbml0aWFsaXplclwiOiBwYXJzZV9pbml0aWFsaXplcixcbiAgICAgICAgXCJydWxlXCI6IHBhcnNlX3J1bGUsXG4gICAgICAgIFwiY2hvaWNlXCI6IHBhcnNlX2Nob2ljZSxcbiAgICAgICAgXCJzZXF1ZW5jZVwiOiBwYXJzZV9zZXF1ZW5jZSxcbiAgICAgICAgXCJsYWJlbGVkXCI6IHBhcnNlX2xhYmVsZWQsXG4gICAgICAgIFwicHJlZml4ZWRcIjogcGFyc2VfcHJlZml4ZWQsXG4gICAgICAgIFwic3VmZml4ZWRcIjogcGFyc2Vfc3VmZml4ZWQsXG4gICAgICAgIFwicHJpbWFyeVwiOiBwYXJzZV9wcmltYXJ5LFxuICAgICAgICBcImFjdGlvblwiOiBwYXJzZV9hY3Rpb24sXG4gICAgICAgIFwiYnJhY2VkXCI6IHBhcnNlX2JyYWNlZCxcbiAgICAgICAgXCJub25CcmFjZUNoYXJhY3RlcnNcIjogcGFyc2Vfbm9uQnJhY2VDaGFyYWN0ZXJzLFxuICAgICAgICBcIm5vbkJyYWNlQ2hhcmFjdGVyXCI6IHBhcnNlX25vbkJyYWNlQ2hhcmFjdGVyLFxuICAgICAgICBcImVxdWFsc1wiOiBwYXJzZV9lcXVhbHMsXG4gICAgICAgIFwiY29sb25cIjogcGFyc2VfY29sb24sXG4gICAgICAgIFwic2VtaWNvbG9uXCI6IHBhcnNlX3NlbWljb2xvbixcbiAgICAgICAgXCJzbGFzaFwiOiBwYXJzZV9zbGFzaCxcbiAgICAgICAgXCJhbmRcIjogcGFyc2VfYW5kLFxuICAgICAgICBcIm5vdFwiOiBwYXJzZV9ub3QsXG4gICAgICAgIFwicXVlc3Rpb25cIjogcGFyc2VfcXVlc3Rpb24sXG4gICAgICAgIFwic3RhclwiOiBwYXJzZV9zdGFyLFxuICAgICAgICBcInBsdXNcIjogcGFyc2VfcGx1cyxcbiAgICAgICAgXCJscGFyZW5cIjogcGFyc2VfbHBhcmVuLFxuICAgICAgICBcInJwYXJlblwiOiBwYXJzZV9ycGFyZW4sXG4gICAgICAgIFwiZG90XCI6IHBhcnNlX2RvdCxcbiAgICAgICAgXCJpZGVudGlmaWVyXCI6IHBhcnNlX2lkZW50aWZpZXIsXG4gICAgICAgIFwibGl0ZXJhbFwiOiBwYXJzZV9saXRlcmFsLFxuICAgICAgICBcInN0cmluZ1wiOiBwYXJzZV9zdHJpbmcsXG4gICAgICAgIFwiZG91YmxlUXVvdGVkU3RyaW5nXCI6IHBhcnNlX2RvdWJsZVF1b3RlZFN0cmluZyxcbiAgICAgICAgXCJkb3VibGVRdW90ZWRDaGFyYWN0ZXJcIjogcGFyc2VfZG91YmxlUXVvdGVkQ2hhcmFjdGVyLFxuICAgICAgICBcInNpbXBsZURvdWJsZVF1b3RlZENoYXJhY3RlclwiOiBwYXJzZV9zaW1wbGVEb3VibGVRdW90ZWRDaGFyYWN0ZXIsXG4gICAgICAgIFwic2luZ2xlUXVvdGVkU3RyaW5nXCI6IHBhcnNlX3NpbmdsZVF1b3RlZFN0cmluZyxcbiAgICAgICAgXCJzaW5nbGVRdW90ZWRDaGFyYWN0ZXJcIjogcGFyc2Vfc2luZ2xlUXVvdGVkQ2hhcmFjdGVyLFxuICAgICAgICBcInNpbXBsZVNpbmdsZVF1b3RlZENoYXJhY3RlclwiOiBwYXJzZV9zaW1wbGVTaW5nbGVRdW90ZWRDaGFyYWN0ZXIsXG4gICAgICAgIFwiY2xhc3NcIjogcGFyc2VfY2xhc3MsXG4gICAgICAgIFwiY2xhc3NDaGFyYWN0ZXJSYW5nZVwiOiBwYXJzZV9jbGFzc0NoYXJhY3RlclJhbmdlLFxuICAgICAgICBcImNsYXNzQ2hhcmFjdGVyXCI6IHBhcnNlX2NsYXNzQ2hhcmFjdGVyLFxuICAgICAgICBcImJyYWNrZXREZWxpbWl0ZWRDaGFyYWN0ZXJcIjogcGFyc2VfYnJhY2tldERlbGltaXRlZENoYXJhY3RlcixcbiAgICAgICAgXCJzaW1wbGVCcmFja2V0RGVsaW1pdGVkQ2hhcmFjdGVyXCI6IHBhcnNlX3NpbXBsZUJyYWNrZXREZWxpbWl0ZWRDaGFyYWN0ZXIsXG4gICAgICAgIFwic2ltcGxlRXNjYXBlU2VxdWVuY2VcIjogcGFyc2Vfc2ltcGxlRXNjYXBlU2VxdWVuY2UsXG4gICAgICAgIFwiemVyb0VzY2FwZVNlcXVlbmNlXCI6IHBhcnNlX3plcm9Fc2NhcGVTZXF1ZW5jZSxcbiAgICAgICAgXCJoZXhFc2NhcGVTZXF1ZW5jZVwiOiBwYXJzZV9oZXhFc2NhcGVTZXF1ZW5jZSxcbiAgICAgICAgXCJ1bmljb2RlRXNjYXBlU2VxdWVuY2VcIjogcGFyc2VfdW5pY29kZUVzY2FwZVNlcXVlbmNlLFxuICAgICAgICBcImVvbEVzY2FwZVNlcXVlbmNlXCI6IHBhcnNlX2VvbEVzY2FwZVNlcXVlbmNlLFxuICAgICAgICBcImRpZ2l0XCI6IHBhcnNlX2RpZ2l0LFxuICAgICAgICBcImhleERpZ2l0XCI6IHBhcnNlX2hleERpZ2l0LFxuICAgICAgICBcImxldHRlclwiOiBwYXJzZV9sZXR0ZXIsXG4gICAgICAgIFwibG93ZXJDYXNlTGV0dGVyXCI6IHBhcnNlX2xvd2VyQ2FzZUxldHRlcixcbiAgICAgICAgXCJ1cHBlckNhc2VMZXR0ZXJcIjogcGFyc2VfdXBwZXJDYXNlTGV0dGVyLFxuICAgICAgICBcIl9fXCI6IHBhcnNlX19fLFxuICAgICAgICBcImNvbW1lbnRcIjogcGFyc2VfY29tbWVudCxcbiAgICAgICAgXCJzaW5nbGVMaW5lQ29tbWVudFwiOiBwYXJzZV9zaW5nbGVMaW5lQ29tbWVudCxcbiAgICAgICAgXCJtdWx0aUxpbmVDb21tZW50XCI6IHBhcnNlX211bHRpTGluZUNvbW1lbnQsXG4gICAgICAgIFwiZW9sXCI6IHBhcnNlX2VvbCxcbiAgICAgICAgXCJlb2xDaGFyXCI6IHBhcnNlX2VvbENoYXIsXG4gICAgICAgIFwid2hpdGVzcGFjZVwiOiBwYXJzZV93aGl0ZXNwYWNlXG4gICAgICB9O1xuICAgICAgXG4gICAgICBpZiAoc3RhcnRSdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHBhcnNlRnVuY3Rpb25zW3N0YXJ0UnVsZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcnVsZSBuYW1lOiBcIiArIHF1b3RlKHN0YXJ0UnVsZSkgKyBcIi5cIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0UnVsZSA9IFwiZ3JhbW1hclwiO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgcG9zID0gMDtcbiAgICAgIHZhciByZXBvcnRGYWlsdXJlcyA9IDA7XG4gICAgICB2YXIgcmlnaHRtb3N0RmFpbHVyZXNQb3MgPSAwO1xuICAgICAgdmFyIHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWQgPSBbXTtcbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFkTGVmdChpbnB1dCwgcGFkZGluZywgbGVuZ3RoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBpbnB1dDtcbiAgICAgICAgXG4gICAgICAgIHZhciBwYWRMZW5ndGggPSBsZW5ndGggLSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFkTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByZXN1bHQgPSBwYWRkaW5nICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBlc2NhcGUoY2gpIHtcbiAgICAgICAgdmFyIGNoYXJDb2RlID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgdmFyIGVzY2FwZUNoYXI7XG4gICAgICAgIHZhciBsZW5ndGg7XG4gICAgICAgIFxuICAgICAgICBpZiAoY2hhckNvZGUgPD0gMHhGRikge1xuICAgICAgICAgIGVzY2FwZUNoYXIgPSAneCc7XG4gICAgICAgICAgbGVuZ3RoID0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlc2NhcGVDaGFyID0gJ3UnO1xuICAgICAgICAgIGxlbmd0aCA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiAnXFxcXCcgKyBlc2NhcGVDaGFyICsgcGFkTGVmdChjaGFyQ29kZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSwgJzAnLCBsZW5ndGgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBtYXRjaEZhaWxlZChmYWlsdXJlKSB7XG4gICAgICAgIGlmIChwb3MgPCByaWdodG1vc3RGYWlsdXJlc1Bvcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHBvcyA+IHJpZ2h0bW9zdEZhaWx1cmVzUG9zKSB7XG4gICAgICAgICAgcmlnaHRtb3N0RmFpbHVyZXNQb3MgPSBwb3M7XG4gICAgICAgICAgcmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkLnB1c2goZmFpbHVyZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2dyYW1tYXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV9fXygpO1xuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9pbml0aWFsaXplcigpO1xuICAgICAgICAgIHJlc3VsdDEgPSByZXN1bHQxICE9PSBudWxsID8gcmVzdWx0MSA6IFwiXCI7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDMgPSBwYXJzZV9ydWxlKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQyID0gW107XG4gICAgICAgICAgICAgIHdoaWxlIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKHJlc3VsdDMpO1xuICAgICAgICAgICAgICAgIHJlc3VsdDMgPSBwYXJzZV9ydWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgaW5pdGlhbGl6ZXIsIHJ1bGVzKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogICAgICAgIFwiZ3JhbW1hclwiLFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVyOiBpbml0aWFsaXplciAhPT0gXCJcIiA/IGluaXRpYWxpemVyIDogbnVsbCxcbiAgICAgICAgICAgICAgICBydWxlczogICAgICAgcnVsZXMsXG4gICAgICAgICAgICAgICAgc3RhcnRSdWxlOiAgIHJ1bGVzWzBdLm5hbWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMV0sIHJlc3VsdDBbMl0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfaW5pdGlhbGl6ZXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV9hY3Rpb24oKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2Vfc2VtaWNvbG9uKCk7XG4gICAgICAgICAgcmVzdWx0MSA9IHJlc3VsdDEgIT09IG51bGwgPyByZXN1bHQxIDogXCJcIjtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGNvZGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImluaXRpYWxpemVyXCIsXG4gICAgICAgICAgICAgICAgY29kZTogY29kZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9ydWxlKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MywgcmVzdWx0NDtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICByZXN1bHQwID0gcGFyc2VfaWRlbnRpZmllcigpO1xuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9zdHJpbmcoKTtcbiAgICAgICAgICByZXN1bHQxID0gcmVzdWx0MSAhPT0gbnVsbCA/IHJlc3VsdDEgOiBcIlwiO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfZXF1YWxzKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQzID0gcGFyc2VfY2hvaWNlKCk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0NCA9IHBhcnNlX3NlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgIHJlc3VsdDQgPSByZXN1bHQ0ICE9PSBudWxsID8gcmVzdWx0NCA6IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MywgcmVzdWx0NF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBuYW1lLCBkaXNwbGF5TmFtZSwgZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgICBcInJ1bGVcIixcbiAgICAgICAgICAgICAgICBuYW1lOiAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUgIT09IFwiXCIgPyBkaXNwbGF5TmFtZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMF0sIHJlc3VsdDBbMV0sIHJlc3VsdDBbM10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfY2hvaWNlKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MztcbiAgICAgICAgdmFyIHBvczAsIHBvczEsIHBvczI7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICByZXN1bHQwID0gcGFyc2Vfc2VxdWVuY2UoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gW107XG4gICAgICAgICAgcG9zMiA9IHBvcztcbiAgICAgICAgICByZXN1bHQyID0gcGFyc2Vfc2xhc2goKTtcbiAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MyA9IHBhcnNlX3NlcXVlbmNlKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQyID0gW3Jlc3VsdDIsIHJlc3VsdDNdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDEucHVzaChyZXN1bHQyKTtcbiAgICAgICAgICAgIHBvczIgPSBwb3M7XG4gICAgICAgICAgICByZXN1bHQyID0gcGFyc2Vfc2xhc2goKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDMgPSBwYXJzZV9zZXF1ZW5jZSgpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBbcmVzdWx0MiwgcmVzdWx0M107XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgICAgcG9zID0gcG9zMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgaGVhZCwgdGFpbCkge1xuICAgICAgICAgICAgICBpZiAodGFpbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFsdGVybmF0aXZlcyA9IFtoZWFkXS5jb25jYXQobWFwKFxuICAgICAgICAgICAgICAgICAgICB0YWlsLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlbGVtZW50KSB7IHJldHVybiBlbGVtZW50WzFdOyB9XG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgICAgXCJjaG9pY2VcIixcbiAgICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlczogYWx0ZXJuYXRpdmVzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVhZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zZXF1ZW5jZSgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgcmVzdWx0MCA9IFtdO1xuICAgICAgICByZXN1bHQxID0gcGFyc2VfbGFiZWxlZCgpO1xuICAgICAgICB3aGlsZSAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAucHVzaChyZXN1bHQxKTtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfbGFiZWxlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2FjdGlvbigpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgZWxlbWVudHMsIGNvZGUpIHtcbiAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBlbGVtZW50cy5sZW5ndGggIT09IDFcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogICAgIFwic2VxdWVuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiBlbGVtZW50c1swXTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAgICAgICBcImFjdGlvblwiLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgY29kZTogICAgICAgY29kZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICByZXN1bHQwID0gW107XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2xhYmVsZWQoKTtcbiAgICAgICAgICB3aGlsZSAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MC5wdXNoKHJlc3VsdDEpO1xuICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2xhYmVsZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50cy5sZW5ndGggIT09IDFcbiAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgICBcInNlcXVlbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIDogZWxlbWVudHNbMF07XG4gICAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2xhYmVsZWQoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV9pZGVudGlmaWVyKCk7XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2NvbG9uKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9wcmVmaXhlZCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgbGFiZWwsIGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAgICAgICBcImxhYmVsZWRcIixcbiAgICAgICAgICAgICAgICBsYWJlbDogICAgICBsYWJlbCxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzBdLCByZXN1bHQwWzJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gcGFyc2VfcHJlZml4ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfcHJlZml4ZWQoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV9hbmQoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfYWN0aW9uKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBjb2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzZW1hbnRpY19hbmRcIixcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2FuZCgpO1xuICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQxID0gcGFyc2Vfc3VmZml4ZWQoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJzaW1wbGVfYW5kXCIsXG4gICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgICByZXN1bHQwID0gcGFyc2Vfbm90KCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQxID0gcGFyc2VfYWN0aW9uKCk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBjb2RlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNlbWFudGljX25vdFwiLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb2RlXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9ub3QoKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQxID0gcGFyc2Vfc3VmZml4ZWQoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAgICAgICBcInNpbXBsZV9ub3RcIixcbiAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2Vfc3VmZml4ZWQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc3VmZml4ZWQoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV9wcmltYXJ5KCk7XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX3F1ZXN0aW9uKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICByZXN1bHQwID0gcGFyc2VfcHJpbWFyeSgpO1xuICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQxID0gcGFyc2Vfc3RhcigpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAgICAgICBcInplcm9fb3JfbW9yZVwiLFxuICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3ByaW1hcnkoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9wbHVzKCk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAgICAgICBcIm9uZV9vcl9tb3JlXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3ByaW1hcnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3ByaW1hcnkoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMSwgcG9zMiwgcG9zMztcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV9pZGVudGlmaWVyKCk7XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcG9zMiA9IHBvcztcbiAgICAgICAgICByZXBvcnRGYWlsdXJlcysrO1xuICAgICAgICAgIHBvczMgPSBwb3M7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX3N0cmluZygpO1xuICAgICAgICAgIHJlc3VsdDEgPSByZXN1bHQxICE9PSBudWxsID8gcmVzdWx0MSA6IFwiXCI7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9lcXVhbHMoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDEgPSBbcmVzdWx0MSwgcmVzdWx0Ml07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXBvcnRGYWlsdXJlcy0tO1xuICAgICAgICAgIGlmIChyZXN1bHQxID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQxID0gXCJcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIG5hbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJ1bGVfcmVmXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2xpdGVyYWwoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9kb3QoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiB7IHR5cGU6IFwiYW55XCIgfTsgfSkocG9zMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2NsYXNzKCk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9scGFyZW4oKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2Nob2ljZSgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX3JwYXJlbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0Ml07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBleHByZXNzaW9uKSB7IHJldHVybiBleHByZXNzaW9uOyB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9hY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHJlcG9ydEZhaWx1cmVzKys7XG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV9icmFjZWQoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfX18oKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGJyYWNlZCkgeyByZXR1cm4gYnJhY2VkLnN1YnN0cigxLCBicmFjZWQubGVuZ3RoIC0gMik7IH0pKHBvczAsIHJlc3VsdDBbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXBvcnRGYWlsdXJlcy0tO1xuICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDAgJiYgcmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIG1hdGNoRmFpbGVkKFwiYWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9icmFjZWQoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDEyMykge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIntcIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIntcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBbXTtcbiAgICAgICAgICByZXN1bHQyID0gcGFyc2VfYnJhY2VkKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9ub25CcmFjZUNoYXJhY3RlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MS5wdXNoKHJlc3VsdDIpO1xuICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX2JyYWNlZCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX25vbkJyYWNlQ2hhcmFjdGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAxMjUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IFwifVwiO1xuICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJ9XFxcIlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgcGFydHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwie1wiICsgcGFydHMuam9pbihcIlwiKSArIFwifVwiO1xuICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9ub25CcmFjZUNoYXJhY3RlcnMoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMDtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHJlc3VsdDEgPSBwYXJzZV9ub25CcmFjZUNoYXJhY3RlcigpO1xuICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBbXTtcbiAgICAgICAgICB3aGlsZSAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MC5wdXNoKHJlc3VsdDEpO1xuICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX25vbkJyYWNlQ2hhcmFjdGVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGNoYXJzKSB7IHJldHVybiBjaGFycy5qb2luKFwiXCIpOyB9KShwb3MwLCByZXN1bHQwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX25vbkJyYWNlQ2hhcmFjdGVyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgXG4gICAgICAgIGlmICgvXltee31dLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgIHJlc3VsdDAgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiW157fV1cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9lcXVhbHMoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDYxKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiPVwiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiPVxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX19fKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIj1cIjsgfSkocG9zMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9jb2xvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNTgpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCI6XCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCI6XFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfX18oKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIFwiOlwiOyB9KShwb3MwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3NlbWljb2xvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNTkpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCI7XCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCI7XFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfX18oKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIFwiO1wiOyB9KShwb3MwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3NsYXNoKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA0Nykge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIi9cIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIi9cXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9fXygpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCIvXCI7IH0pKHBvczApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfYW5kKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAzOCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIiZcIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIiZcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9fXygpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCImXCI7IH0pKHBvczApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfbm90KCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAzMykge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIiFcIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIiFcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9fXygpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCIhXCI7IH0pKHBvczApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfcXVlc3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDYzKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiP1wiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiP1xcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX19fKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIj9cIjsgfSkocG9zMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zdGFyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA0Mikge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIipcIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIipcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9fXygpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCIqXCI7IH0pKHBvczApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfcGx1cygpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDMpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCIrXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIrXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfX18oKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIFwiK1wiOyB9KShwb3MwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2xwYXJlbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDApIHtcbiAgICAgICAgICByZXN1bHQwID0gXCIoXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIoXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfX18oKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIFwiKFwiOyB9KShwb3MwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3JwYXJlbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDEpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCIpXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIpXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfX18oKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIFwiKVwiOyB9KShwb3MwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2RvdCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDYpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCIuXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIuXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfX18oKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIFwiLlwiOyB9KShwb3MwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2lkZW50aWZpZXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHJlcG9ydEZhaWx1cmVzKys7XG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV9sZXR0ZXIoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA5NSkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFwiX1wiO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIl9cXFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMzYpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiJFwiO1xuICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIkXFxcIlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBbXTtcbiAgICAgICAgICByZXN1bHQyID0gcGFyc2VfbGV0dGVyKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9kaWdpdCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gOTUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gXCJfXCI7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJfXFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAzNikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IFwiJFwiO1xuICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIiRcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MS5wdXNoKHJlc3VsdDIpO1xuICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX2xldHRlcigpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX2RpZ2l0KCk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gOTUpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBcIl9cIjtcbiAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJfXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDM2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBcIiRcIjtcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiJFxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9fXygpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgaGVhZCwgdGFpbCkge1xuICAgICAgICAgICAgICByZXR1cm4gaGVhZCArIHRhaWwuam9pbihcIlwiKTtcbiAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMF0sIHJlc3VsdDBbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXBvcnRGYWlsdXJlcy0tO1xuICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDAgJiYgcmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIG1hdGNoRmFpbGVkKFwiaWRlbnRpZmllclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfbGl0ZXJhbCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcmVwb3J0RmFpbHVyZXMrKztcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2RvdWJsZVF1b3RlZFN0cmluZygpO1xuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9zaW5nbGVRdW90ZWRTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDEwNSkge1xuICAgICAgICAgICAgcmVzdWx0MSA9IFwiaVwiO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcImlcXFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQxID0gcmVzdWx0MSAhPT0gbnVsbCA/IHJlc3VsdDEgOiBcIlwiO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfX18oKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0Ml07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIHZhbHVlLCBmbGFncykge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgIFwibGl0ZXJhbFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGlnbm9yZUNhc2U6IGZsYWdzID09PSBcImlcIlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJlcG9ydEZhaWx1cmVzLS07XG4gICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCAmJiByZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgbWF0Y2hGYWlsZWQoXCJsaXRlcmFsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zdHJpbmcoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHJlcG9ydEZhaWx1cmVzKys7XG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV9kb3VibGVRdW90ZWRTdHJpbmcoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gcGFyc2Vfc2luZ2xlUXVvdGVkU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfX18oKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIHN0cmluZykgeyByZXR1cm4gc3RyaW5nOyB9KShwb3MwLCByZXN1bHQwWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmVwb3J0RmFpbHVyZXMtLTtcbiAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwICYmIHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBtYXRjaEZhaWxlZChcInN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfZG91YmxlUXVvdGVkU3RyaW5nKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAzNCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXCJcIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFwiXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gW107XG4gICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX2RvdWJsZVF1b3RlZENoYXJhY3RlcigpO1xuICAgICAgICAgIHdoaWxlIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQxLnB1c2gocmVzdWx0Mik7XG4gICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfZG91YmxlUXVvdGVkQ2hhcmFjdGVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAzNCkge1xuICAgICAgICAgICAgICByZXN1bHQyID0gXCJcXFwiXCI7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgY2hhcnMpIHsgcmV0dXJuIGNoYXJzLmpvaW4oXCJcIik7IH0pKHBvczAsIHJlc3VsdDBbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfZG91YmxlUXVvdGVkQ2hhcmFjdGVyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgXG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV9zaW1wbGVEb3VibGVRdW90ZWRDaGFyYWN0ZXIoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gcGFyc2Vfc2ltcGxlRXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3plcm9Fc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2hleEVzY2FwZVNlcXVlbmNlKCk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3VuaWNvZGVFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfZW9sRXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3NpbXBsZURvdWJsZVF1b3RlZENoYXJhY3RlcigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxLCBwb3MyO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgcG9zMiA9IHBvcztcbiAgICAgICAgcmVwb3J0RmFpbHVyZXMrKztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMzQpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCJcXFwiXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcIlxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gOTIpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXFxcIjtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXFxcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfZW9sQ2hhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXBvcnRGYWlsdXJlcy0tO1xuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gcG9zKSB7XG4gICAgICAgICAgICByZXN1bHQxID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJhbnkgY2hhcmFjdGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGNoYXJfKSB7IHJldHVybiBjaGFyXzsgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zaW5nbGVRdW90ZWRTdHJpbmcoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDM5KSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiJ1wiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiJ1xcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IFtdO1xuICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9zaW5nbGVRdW90ZWRDaGFyYWN0ZXIoKTtcbiAgICAgICAgICB3aGlsZSAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MS5wdXNoKHJlc3VsdDIpO1xuICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX3NpbmdsZVF1b3RlZENoYXJhY3RlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMzkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IFwiJ1wiO1xuICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCInXFxcIlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgY2hhcnMpIHsgcmV0dXJuIGNoYXJzLmpvaW4oXCJcIik7IH0pKHBvczAsIHJlc3VsdDBbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc2luZ2xlUXVvdGVkQ2hhcmFjdGVyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgXG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV9zaW1wbGVTaW5nbGVRdW90ZWRDaGFyYWN0ZXIoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gcGFyc2Vfc2ltcGxlRXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3plcm9Fc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2hleEVzY2FwZVNlcXVlbmNlKCk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3VuaWNvZGVFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfZW9sRXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3NpbXBsZVNpbmdsZVF1b3RlZENoYXJhY3RlcigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxLCBwb3MyO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgcG9zMiA9IHBvcztcbiAgICAgICAgcmVwb3J0RmFpbHVyZXMrKztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMzkpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCInXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCInXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA5Mikge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFwiXFxcXFwiO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxcXFxcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9lb2xDaGFyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcG9ydEZhaWx1cmVzLS07XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGggPiBwb3MpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcImFueSBjaGFyYWN0ZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgY2hhcl8pIHsgcmV0dXJuIGNoYXJfOyB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2NsYXNzKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MywgcmVzdWx0NCwgcmVzdWx0NTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICByZXBvcnRGYWlsdXJlcysrO1xuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA5MSkge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIltcIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIltcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDk0KSB7XG4gICAgICAgICAgICByZXN1bHQxID0gXCJeXCI7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXlxcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdDEgPSByZXN1bHQxICE9PSBudWxsID8gcmVzdWx0MSA6IFwiXCI7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBbXTtcbiAgICAgICAgICAgIHJlc3VsdDMgPSBwYXJzZV9jbGFzc0NoYXJhY3RlclJhbmdlKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQzID0gcGFyc2VfY2xhc3NDaGFyYWN0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIucHVzaChyZXN1bHQzKTtcbiAgICAgICAgICAgICAgcmVzdWx0MyA9IHBhcnNlX2NsYXNzQ2hhcmFjdGVyUmFuZ2UoKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQzID0gcGFyc2VfY2xhc3NDaGFyYWN0ZXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gOTMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQzID0gXCJdXCI7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MyA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJdXFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAxMDUpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDQgPSBcImlcIjtcbiAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQ0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJpXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0NCA9IHJlc3VsdDQgIT09IG51bGwgPyByZXN1bHQ0IDogXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0NCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0NSA9IHBhcnNlX19fKCk7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0NSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDMsIHJlc3VsdDQsIHJlc3VsdDVdO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBpbnZlcnRlZCwgcGFydHMsIGZsYWdzKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0c0NvbnZlcnRlZCA9IG1hcChwYXJ0cywgZnVuY3Rpb24ocGFydCkgeyByZXR1cm4gcGFydC5kYXRhOyB9KTtcbiAgICAgICAgICAgICAgdmFyIHJhd1RleHQgPSBcIltcIlxuICAgICAgICAgICAgICAgICsgaW52ZXJ0ZWRcbiAgICAgICAgICAgICAgICArIG1hcChwYXJ0cywgZnVuY3Rpb24ocGFydCkgeyByZXR1cm4gcGFydC5yYXdUZXh0OyB9KS5qb2luKFwiXCIpXG4gICAgICAgICAgICAgICAgKyBcIl1cIlxuICAgICAgICAgICAgICAgICsgZmxhZ3M7XG4gICAgICAgIFxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgIFwiY2xhc3NcIixcbiAgICAgICAgICAgICAgICBpbnZlcnRlZDogICBpbnZlcnRlZCA9PT0gXCJeXCIsXG4gICAgICAgICAgICAgICAgaWdub3JlQ2FzZTogZmxhZ3MgPT09IFwiaVwiLFxuICAgICAgICAgICAgICAgIHBhcnRzOiAgICAgIHBhcnRzQ29udmVydGVkLFxuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBHZXQgdGhlIHJhdyB0ZXh0IGZyb20gdGhlIGlucHV0IGRpcmVjdGx5LlxuICAgICAgICAgICAgICAgIHJhd1RleHQ6ICAgIHJhd1RleHRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMV0sIHJlc3VsdDBbMl0sIHJlc3VsdDBbNF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXBvcnRGYWlsdXJlcy0tO1xuICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDAgJiYgcmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIG1hdGNoRmFpbGVkKFwiY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9jbGFzc0NoYXJhY3RlclJhbmdlKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICByZXN1bHQwID0gcGFyc2VfY2xhc3NDaGFyYWN0ZXIoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA0NSkge1xuICAgICAgICAgICAgcmVzdWx0MSA9IFwiLVwiO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIi1cXFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX2NsYXNzQ2hhcmFjdGVyKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBiZWdpbiwgZW5kKSB7XG4gICAgICAgICAgICAgIGlmIChiZWdpbi5kYXRhLmNoYXJDb2RlQXQoMCkgPiBlbmQuZGF0YS5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHRoaXMuU3ludGF4RXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkludmFsaWQgY2hhcmFjdGVyIHJhbmdlOiBcIiArIGJlZ2luLnJhd1RleHQgKyBcIi1cIiArIGVuZC5yYXdUZXh0ICsgXCIuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6ICAgIFtiZWdpbi5kYXRhLCBlbmQuZGF0YV0sXG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IEdldCB0aGUgcmF3IHRleHQgZnJvbSB0aGUgaW5wdXQgZGlyZWN0bHkuXG4gICAgICAgICAgICAgICAgcmF3VGV4dDogYmVnaW4ucmF3VGV4dCArIFwiLVwiICsgZW5kLnJhd1RleHRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMF0sIHJlc3VsdDBbMl0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfY2xhc3NDaGFyYWN0ZXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICB2YXIgcG9zMDtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV9icmFja2V0RGVsaW1pdGVkQ2hhcmFjdGVyKCk7XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGNoYXJfKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogICAgY2hhcl8sXG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IEdldCB0aGUgcmF3IHRleHQgZnJvbSB0aGUgaW5wdXQgZGlyZWN0bHkuXG4gICAgICAgICAgICAgICAgcmF3VGV4dDogcXVvdGVGb3JSZWdleHBDbGFzcyhjaGFyXylcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfYnJhY2tldERlbGltaXRlZENoYXJhY3RlcigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgIFxuICAgICAgICByZXN1bHQwID0gcGFyc2Vfc2ltcGxlQnJhY2tldERlbGltaXRlZENoYXJhY3RlcigpO1xuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9zaW1wbGVFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfemVyb0VzY2FwZVNlcXVlbmNlKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfaGV4RXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfdW5pY29kZUVzY2FwZVNlcXVlbmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9lb2xFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc2ltcGxlQnJhY2tldERlbGltaXRlZENoYXJhY3RlcigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxLCBwb3MyO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgcG9zMiA9IHBvcztcbiAgICAgICAgcmVwb3J0RmFpbHVyZXMrKztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gOTMpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCJdXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJdXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA5Mikge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFwiXFxcXFwiO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxcXFxcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9lb2xDaGFyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcG9ydEZhaWx1cmVzLS07XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGggPiBwb3MpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcImFueSBjaGFyYWN0ZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgY2hhcl8pIHsgcmV0dXJuIGNoYXJfOyB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3NpbXBsZUVzY2FwZVNlcXVlbmNlKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgdmFyIHBvczAsIHBvczEsIHBvczI7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA5Mikge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXFxcIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxcXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICBwb3MyID0gcG9zO1xuICAgICAgICAgIHJlcG9ydEZhaWx1cmVzKys7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2RpZ2l0KCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDEyMCkge1xuICAgICAgICAgICAgICByZXN1bHQxID0gXCJ4XCI7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcInhcXFwiXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAxMTcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQxID0gXCJ1XCI7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJ1XFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQxID0gcGFyc2VfZW9sQ2hhcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcG9ydEZhaWx1cmVzLS07XG4gICAgICAgICAgaWYgKHJlc3VsdDEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBcIlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gcG9zKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJhbnkgY2hhcmFjdGVyXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBjaGFyXykge1xuICAgICAgICAgICAgICByZXR1cm4gY2hhcl9cbiAgICAgICAgICAgICAgICAucmVwbGFjZShcImJcIiwgXCJcXGJcIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcImZcIiwgXCJcXGZcIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcIm5cIiwgXCJcXG5cIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcInJcIiwgXCJcXHJcIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcInRcIiwgXCJcXHRcIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcInZcIiwgXCJcXHgwQlwiKTsgLy8gSUUgZG9lcyBub3QgcmVjb2duaXplIFwiXFx2XCIuXG4gICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3plcm9Fc2NhcGVTZXF1ZW5jZSgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxLCBwb3MyO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIlxcXFwwXCIpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCJcXFxcMFwiO1xuICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXFwwXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICBwb3MyID0gcG9zO1xuICAgICAgICAgIHJlcG9ydEZhaWx1cmVzKys7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2RpZ2l0KCk7XG4gICAgICAgICAgcmVwb3J0RmFpbHVyZXMtLTtcbiAgICAgICAgICBpZiAocmVzdWx0MSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MSA9IFwiXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIlxceDAwXCI7IH0pKHBvczApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfaGV4RXNjYXBlU2VxdWVuY2UoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJcXFxceFwiKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiXFxcXHhcIjtcbiAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxceFxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2hleERpZ2l0KCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9oZXhEaWdpdCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgaDEsIGgyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGgxICsgaDIsIDE2KSk7XG4gICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzFdLCByZXN1bHQwWzJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3VuaWNvZGVFc2NhcGVTZXF1ZW5jZSgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDMsIHJlc3VsdDQ7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIlxcXFx1XCIpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCJcXFxcdVwiO1xuICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXFx1XFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfaGV4RGlnaXQoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX2hleERpZ2l0KCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQzID0gcGFyc2VfaGV4RGlnaXQoKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ0ID0gcGFyc2VfaGV4RGlnaXQoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0NCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzLCByZXN1bHQ0XTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGgxLCBoMiwgaDMsIGg0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGgxICsgaDIgKyBoMyArIGg0LCAxNikpO1xuICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFsxXSwgcmVzdWx0MFsyXSwgcmVzdWx0MFszXSwgcmVzdWx0MFs0XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9lb2xFc2NhcGVTZXF1ZW5jZSgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gOTIpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCJcXFxcXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXFxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2VvbCgpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgZW9sKSB7IHJldHVybiBlb2w7IH0pKHBvczAsIHJlc3VsdDBbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfZGlnaXQoKSB7XG4gICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICBcbiAgICAgICAgaWYgKC9eWzAtOV0vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbMC05XVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2hleERpZ2l0KCkge1xuICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgXG4gICAgICAgIGlmICgvXlswLTlhLWZBLUZdLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgIHJlc3VsdDAgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiWzAtOWEtZkEtRl1cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9sZXR0ZXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICBcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2xvd2VyQ2FzZUxldHRlcigpO1xuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV91cHBlckNhc2VMZXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfbG93ZXJDYXNlTGV0dGVyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgXG4gICAgICAgIGlmICgvXlthLXpdLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgIHJlc3VsdDAgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiW2Etel1cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV91cHBlckNhc2VMZXR0ZXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICBcbiAgICAgICAgaWYgKC9eW0EtWl0vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbQS1aXVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX19fKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgXG4gICAgICAgIHJlc3VsdDAgPSBbXTtcbiAgICAgICAgcmVzdWx0MSA9IHBhcnNlX3doaXRlc3BhY2UoKTtcbiAgICAgICAgaWYgKHJlc3VsdDEgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfZW9sKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9jb21tZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MC5wdXNoKHJlc3VsdDEpO1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV93aGl0ZXNwYWNlKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9lb2woKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQxID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9jb21tZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9jb21tZW50KCkge1xuICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgXG4gICAgICAgIHJlcG9ydEZhaWx1cmVzKys7XG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV9zaW5nbGVMaW5lQ29tbWVudCgpO1xuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9tdWx0aUxpbmVDb21tZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVwb3J0RmFpbHVyZXMtLTtcbiAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwICYmIHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBtYXRjaEZhaWxlZChcImNvbW1lbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3NpbmdsZUxpbmVDb21tZW50KCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MztcbiAgICAgICAgdmFyIHBvczAsIHBvczEsIHBvczI7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMikgPT09IFwiLy9cIikge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIi8vXCI7XG4gICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIvL1xcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IFtdO1xuICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgcG9zMiA9IHBvcztcbiAgICAgICAgICByZXBvcnRGYWlsdXJlcysrO1xuICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9lb2xDaGFyKCk7XG4gICAgICAgICAgcmVwb3J0RmFpbHVyZXMtLTtcbiAgICAgICAgICBpZiAocmVzdWx0MiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IFwiXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGggPiBwb3MpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MyA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDMgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcImFueSBjaGFyYWN0ZXJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBbcmVzdWx0MiwgcmVzdWx0M107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MS5wdXNoKHJlc3VsdDIpO1xuICAgICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICAgIHBvczIgPSBwb3M7XG4gICAgICAgICAgICByZXBvcnRGYWlsdXJlcysrO1xuICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX2VvbENoYXIoKTtcbiAgICAgICAgICAgIHJlcG9ydEZhaWx1cmVzLS07XG4gICAgICAgICAgICBpZiAocmVzdWx0MiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQyID0gXCJcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IHBvcykge1xuICAgICAgICAgICAgICAgIHJlc3VsdDMgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiYW55IGNoYXJhY3RlclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gW3Jlc3VsdDIsIHJlc3VsdDNdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9tdWx0aUxpbmVDb21tZW50KCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MztcbiAgICAgICAgdmFyIHBvczAsIHBvczEsIHBvczI7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMikgPT09IFwiLypcIikge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIi8qXCI7XG4gICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIvKlxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IFtdO1xuICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgcG9zMiA9IHBvcztcbiAgICAgICAgICByZXBvcnRGYWlsdXJlcysrO1xuICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCIqL1wiKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gXCIqL1wiO1xuICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIiovXFxcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVwb3J0RmFpbHVyZXMtLTtcbiAgICAgICAgICBpZiAocmVzdWx0MiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IFwiXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGggPiBwb3MpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MyA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDMgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcImFueSBjaGFyYWN0ZXJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBbcmVzdWx0MiwgcmVzdWx0M107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MS5wdXNoKHJlc3VsdDIpO1xuICAgICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICAgIHBvczIgPSBwb3M7XG4gICAgICAgICAgICByZXBvcnRGYWlsdXJlcysrO1xuICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIiovXCIpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IFwiKi9cIjtcbiAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiKi9cXFwiXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXBvcnRGYWlsdXJlcy0tO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IFwiXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGggPiBwb3MpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQzID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MyA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcImFueSBjaGFyYWN0ZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiA9IFtyZXN1bHQyLCByZXN1bHQzXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCIqL1wiKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBcIiovXCI7XG4gICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIiovXFxcIlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2VvbCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgIFxuICAgICAgICByZXBvcnRGYWlsdXJlcysrO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAxMCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIlxcblwiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXG5cXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJcXHJcXG5cIikge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFwiXFxyXFxuXCI7XG4gICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXHJcXFxcblxcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAxMykge1xuICAgICAgICAgICAgICByZXN1bHQwID0gXCJcXHJcIjtcbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXHJcXFwiXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA4MjMyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiXFx1MjAyOFwiO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXHUyMDI4XFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA4MjMzKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gXCJcXHUyMDI5XCI7XG4gICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXHUyMDI5XFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVwb3J0RmFpbHVyZXMtLTtcbiAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwICYmIHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBtYXRjaEZhaWxlZChcImVuZCBvZiBsaW5lXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9lb2xDaGFyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgXG4gICAgICAgIGlmICgvXltcXG5cXHJcXHUyMDI4XFx1MjAyOV0vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOV1cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV93aGl0ZXNwYWNlKCkge1xuICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgXG4gICAgICAgIHJlcG9ydEZhaWx1cmVzKys7XG4gICAgICAgIGlmICgvXlsgXFx0XFx4MEJcXGZcXHhBMFxcdUZFRkZcXHUxNjgwXFx1MTgwRVxcdTIwMDAtXFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMF0vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbIFxcXFx0XFxcXHgwQlxcXFxmXFxcXHhBMFxcXFx1RkVGRlxcXFx1MTY4MFxcXFx1MTgwRVxcXFx1MjAwMC1cXFxcdTIwMEFcXFxcdTIwMkZcXFxcdTIwNUZcXFxcdTMwMDBdXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXBvcnRGYWlsdXJlcy0tO1xuICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDAgJiYgcmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIG1hdGNoRmFpbGVkKFwid2hpdGVzcGFjZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgXG4gICAgICBmdW5jdGlvbiBjbGVhbnVwRXhwZWN0ZWQoZXhwZWN0ZWQpIHtcbiAgICAgICAgZXhwZWN0ZWQuc29ydCgpO1xuICAgICAgICBcbiAgICAgICAgdmFyIGxhc3RFeHBlY3RlZCA9IG51bGw7XG4gICAgICAgIHZhciBjbGVhbkV4cGVjdGVkID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZXhwZWN0ZWRbaV0gIT09IGxhc3RFeHBlY3RlZCkge1xuICAgICAgICAgICAgY2xlYW5FeHBlY3RlZC5wdXNoKGV4cGVjdGVkW2ldKTtcbiAgICAgICAgICAgIGxhc3RFeHBlY3RlZCA9IGV4cGVjdGVkW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xlYW5FeHBlY3RlZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gY29tcHV0ZUVycm9yUG9zaXRpb24oKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoZSBmaXJzdCBpZGVhIHdhcyB0byB1c2UgfFN0cmluZy5zcGxpdHwgdG8gYnJlYWsgdGhlIGlucHV0IHVwIHRvIHRoZVxuICAgICAgICAgKiBlcnJvciBwb3NpdGlvbiBhbG9uZyBuZXdsaW5lcyBhbmQgZGVyaXZlIHRoZSBsaW5lIGFuZCBjb2x1bW4gZnJvbVxuICAgICAgICAgKiB0aGVyZS4gSG93ZXZlciBJRSdzIHxzcGxpdHwgaW1wbGVtZW50YXRpb24gaXMgc28gYnJva2VuIHRoYXQgaXQgd2FzXG4gICAgICAgICAqIGVub3VnaCB0byBwcmV2ZW50IGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgXG4gICAgICAgIHZhciBsaW5lID0gMTtcbiAgICAgICAgdmFyIGNvbHVtbiA9IDE7XG4gICAgICAgIHZhciBzZWVuQ1IgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5tYXgocG9zLCByaWdodG1vc3RGYWlsdXJlc1Bvcyk7IGkrKykge1xuICAgICAgICAgIHZhciBjaCA9IGlucHV0LmNoYXJBdChpKTtcbiAgICAgICAgICBpZiAoY2ggPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGlmICghc2VlbkNSKSB7IGxpbmUrKzsgfVxuICAgICAgICAgICAgY29sdW1uID0gMTtcbiAgICAgICAgICAgIHNlZW5DUiA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiXFxyXCIgfHwgY2ggPT09IFwiXFx1MjAyOFwiIHx8IGNoID09PSBcIlxcdTIwMjlcIikge1xuICAgICAgICAgICAgbGluZSsrO1xuICAgICAgICAgICAgY29sdW1uID0gMTtcbiAgICAgICAgICAgIHNlZW5DUiA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbHVtbisrO1xuICAgICAgICAgICAgc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyBsaW5lOiBsaW5lLCBjb2x1bW46IGNvbHVtbiB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICBcbiAgICAgIHZhciByZXN1bHQgPSBwYXJzZUZ1bmN0aW9uc1tzdGFydFJ1bGVdKCk7XG4gICAgICBcbiAgICAgIC8qXG4gICAgICAgKiBUaGUgcGFyc2VyIGlzIG5vdyBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyB0aHJlZSBzdGF0ZXM6XG4gICAgICAgKlxuICAgICAgICogMS4gVGhlIHBhcnNlciBzdWNjZXNzZnVsbHkgcGFyc2VkIHRoZSB3aG9sZSBpbnB1dC5cbiAgICAgICAqXG4gICAgICAgKiAgICAtIHxyZXN1bHQgIT09IG51bGx8XG4gICAgICAgKiAgICAtIHxwb3MgPT09IGlucHV0Lmxlbmd0aHxcbiAgICAgICAqICAgIC0gfHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWR8IG1heSBvciBtYXkgbm90IGNvbnRhaW4gc29tZXRoaW5nXG4gICAgICAgKlxuICAgICAgICogMi4gVGhlIHBhcnNlciBzdWNjZXNzZnVsbHkgcGFyc2VkIG9ubHkgYSBwYXJ0IG9mIHRoZSBpbnB1dC5cbiAgICAgICAqXG4gICAgICAgKiAgICAtIHxyZXN1bHQgIT09IG51bGx8XG4gICAgICAgKiAgICAtIHxwb3MgPCBpbnB1dC5sZW5ndGh8XG4gICAgICAgKiAgICAtIHxyaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkfCBtYXkgb3IgbWF5IG5vdCBjb250YWluIHNvbWV0aGluZ1xuICAgICAgICpcbiAgICAgICAqIDMuIFRoZSBwYXJzZXIgZGlkIG5vdCBzdWNjZXNzZnVsbHkgcGFyc2UgYW55IHBhcnQgb2YgdGhlIGlucHV0LlxuICAgICAgICpcbiAgICAgICAqICAgLSB8cmVzdWx0ID09PSBudWxsfFxuICAgICAgICogICAtIHxwb3MgPT09IDB8XG4gICAgICAgKiAgIC0gfHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWR8IGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBmYWlsdXJlXG4gICAgICAgKlxuICAgICAgICogQWxsIGNvZGUgZm9sbG93aW5nIHRoaXMgY29tbWVudCAoaW5jbHVkaW5nIGNhbGxlZCBmdW5jdGlvbnMpIG11c3RcbiAgICAgICAqIGhhbmRsZSB0aGVzZSBzdGF0ZXMuXG4gICAgICAgKi9cbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgcG9zICE9PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IE1hdGgubWF4KHBvcywgcmlnaHRtb3N0RmFpbHVyZXNQb3MpO1xuICAgICAgICB2YXIgZm91bmQgPSBvZmZzZXQgPCBpbnB1dC5sZW5ndGggPyBpbnB1dC5jaGFyQXQob2Zmc2V0KSA6IG51bGw7XG4gICAgICAgIHZhciBlcnJvclBvc2l0aW9uID0gY29tcHV0ZUVycm9yUG9zaXRpb24oKTtcbiAgICAgICAgXG4gICAgICAgIHRocm93IG5ldyB0aGlzLlN5bnRheEVycm9yKFxuICAgICAgICAgIGNsZWFudXBFeHBlY3RlZChyaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkKSxcbiAgICAgICAgICBmb3VuZCxcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgZXJyb3JQb3NpdGlvbi5saW5lLFxuICAgICAgICAgIGVycm9yUG9zaXRpb24uY29sdW1uXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBcbiAgICAvKiBSZXR1cm5zIHRoZSBwYXJzZXIgc291cmNlIGNvZGUuICovXG4gICAgdG9Tb3VyY2U6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fc291cmNlOyB9XG4gIH07XG4gIFxuICAvKiBUaHJvd24gd2hlbiBhIHBhcnNlciBlbmNvdW50ZXJzIGEgc3ludGF4IGVycm9yLiAqL1xuICBcbiAgcmVzdWx0LlN5bnRheEVycm9yID0gZnVuY3Rpb24oZXhwZWN0ZWQsIGZvdW5kLCBvZmZzZXQsIGxpbmUsIGNvbHVtbikge1xuICAgIGZ1bmN0aW9uIGJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpIHtcbiAgICAgIHZhciBleHBlY3RlZEh1bWFuaXplZCwgZm91bmRIdW1hbml6ZWQ7XG4gICAgICBcbiAgICAgIHN3aXRjaCAoZXhwZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBleHBlY3RlZEh1bWFuaXplZCA9IFwiZW5kIG9mIGlucHV0XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBleHBlY3RlZEh1bWFuaXplZCA9IGV4cGVjdGVkWzBdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGV4cGVjdGVkSHVtYW5pemVkID0gZXhwZWN0ZWQuc2xpY2UoMCwgZXhwZWN0ZWQubGVuZ3RoIC0gMSkuam9pbihcIiwgXCIpXG4gICAgICAgICAgICArIFwiIG9yIFwiXG4gICAgICAgICAgICArIGV4cGVjdGVkW2V4cGVjdGVkLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmb3VuZEh1bWFuaXplZCA9IGZvdW5kID8gcXVvdGUoZm91bmQpIDogXCJlbmQgb2YgaW5wdXRcIjtcbiAgICAgIFxuICAgICAgcmV0dXJuIFwiRXhwZWN0ZWQgXCIgKyBleHBlY3RlZEh1bWFuaXplZCArIFwiIGJ1dCBcIiArIGZvdW5kSHVtYW5pemVkICsgXCIgZm91bmQuXCI7XG4gICAgfVxuICAgIFxuICAgIHRoaXMubmFtZSA9IFwiU3ludGF4RXJyb3JcIjtcbiAgICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgdGhpcy5mb3VuZCA9IGZvdW5kO1xuICAgIHRoaXMubWVzc2FnZSA9IGJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpO1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gIH07XG4gIFxuICByZXN1bHQuU3ludGF4RXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuICBcbiAgcmV0dXJuIHJlc3VsdDtcbn0pKCk7XG5QRUcuY29tcGlsZXIgPSB7XG4gIC8qXG4gICAqIE5hbWVzIG9mIHBhc3NlcyB0aGF0IHdpbGwgZ2V0IHJ1biBkdXJpbmcgdGhlIGNvbXBpbGF0aW9uIChpbiB0aGUgc3BlY2lmaWVkXG4gICAqIG9yZGVyKS5cbiAgICovXG4gIGFwcGxpZWRQYXNzTmFtZXM6IFtcbiAgICBcInJlcG9ydE1pc3NpbmdSdWxlc1wiLFxuICAgIFwicmVwb3J0TGVmdFJlY3Vyc2lvblwiLFxuICAgIFwicmVtb3ZlUHJveHlSdWxlc1wiLFxuICAgIFwiY29tcHV0ZVZhck5hbWVzXCIsXG4gICAgXCJjb21wdXRlUGFyYW1zXCJcbiAgXSxcblxuICAvKlxuICAgKiBHZW5lcmF0ZXMgYSBwYXJzZXIgZnJvbSBhIHNwZWNpZmllZCBncmFtbWFyIEFTVC4gVGhyb3dzIHxQRUcuR3JhbW1hckVycm9yfFxuICAgKiBpZiB0aGUgQVNUIGNvbnRhaW5zIGEgc2VtYW50aWMgZXJyb3IuIE5vdGUgdGhhdCBub3QgYWxsIGVycm9ycyBhcmUgZGV0ZWN0ZWRcbiAgICogZHVyaW5nIHRoZSBnZW5lcmF0aW9uIGFuZCBzb21lIG1heSBwcm90cnVkZSB0byB0aGUgZ2VuZXJhdGVkIHBhcnNlciBhbmRcbiAgICogY2F1c2UgaXRzIG1hbGZ1bmN0aW9uLlxuICAgKi9cbiAgY29tcGlsZTogZnVuY3Rpb24oYXN0LCBvcHRpb25zKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgZWFjaCh0aGlzLmFwcGxpZWRQYXNzTmFtZXMsIGZ1bmN0aW9uKHBhc3NOYW1lKSB7XG4gICAgICB0aGF0LnBhc3Nlc1twYXNzTmFtZV0oYXN0KTtcbiAgICB9KTtcblxuICAgIHZhciBzb3VyY2UgPSB0aGlzLmVtaXR0ZXIoYXN0LCBvcHRpb25zKTtcbiAgICB2YXIgcmVzdWx0ID0gZXZhbChzb3VyY2UpO1xuICAgIHJlc3VsdC5fc291cmNlID0gc291cmNlO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuLypcbiAqIENvbXBpbGVyIHBhc3Nlcy5cbiAqXG4gKiBFYWNoIHBhc3MgaXMgYSBmdW5jdGlvbiB0aGF0IGlzIHBhc3NlZCB0aGUgQVNULiBJdCBjYW4gcGVyZm9ybSBjaGVja3Mgb24gaXRcbiAqIG9yIG1vZGlmeSBpdCBhcyBuZWVkZWQuIElmIHRoZSBwYXNzIGVuY291bnRlcnMgYSBzZW1hbnRpYyBlcnJvciwgaXQgdGhyb3dzXG4gKiB8UEVHLkdyYW1tYXJFcnJvcnwuXG4gKi9cblBFRy5jb21waWxlci5wYXNzZXMgPSB7XG4gIC8qIENoZWNrcyB0aGF0IGFsbCByZWZlcmVuY2VkIHJ1bGVzIGV4aXN0LiAqL1xuICByZXBvcnRNaXNzaW5nUnVsZXM6IGZ1bmN0aW9uKGFzdCkge1xuICAgIGZ1bmN0aW9uIG5vcCgpIHt9XG5cbiAgICBmdW5jdGlvbiBjaGVja0V4cHJlc3Npb24obm9kZSkgeyBjaGVjayhub2RlLmV4cHJlc3Npb24pOyB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1N1Ym5vZGVzKHByb3BlcnR5TmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHsgZWFjaChub2RlW3Byb3BlcnR5TmFtZV0sIGNoZWNrKTsgfTtcbiAgICB9XG5cbiAgICB2YXIgY2hlY2sgPSBidWlsZE5vZGVWaXNpdG9yKHtcbiAgICAgIGdyYW1tYXI6ICAgICAgY2hlY2tTdWJub2RlcyhcInJ1bGVzXCIpLFxuICAgICAgcnVsZTogICAgICAgICBjaGVja0V4cHJlc3Npb24sXG4gICAgICBjaG9pY2U6ICAgICAgIGNoZWNrU3Vibm9kZXMoXCJhbHRlcm5hdGl2ZXNcIiksXG4gICAgICBzZXF1ZW5jZTogICAgIGNoZWNrU3Vibm9kZXMoXCJlbGVtZW50c1wiKSxcbiAgICAgIGxhYmVsZWQ6ICAgICAgY2hlY2tFeHByZXNzaW9uLFxuICAgICAgc2ltcGxlX2FuZDogICBjaGVja0V4cHJlc3Npb24sXG4gICAgICBzaW1wbGVfbm90OiAgIGNoZWNrRXhwcmVzc2lvbixcbiAgICAgIHNlbWFudGljX2FuZDogbm9wLFxuICAgICAgc2VtYW50aWNfbm90OiBub3AsXG4gICAgICBvcHRpb25hbDogICAgIGNoZWNrRXhwcmVzc2lvbixcbiAgICAgIHplcm9fb3JfbW9yZTogY2hlY2tFeHByZXNzaW9uLFxuICAgICAgb25lX29yX21vcmU6ICBjaGVja0V4cHJlc3Npb24sXG4gICAgICBhY3Rpb246ICAgICAgIGNoZWNrRXhwcmVzc2lvbixcblxuICAgICAgcnVsZV9yZWY6XG4gICAgICAgIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBpZiAoIWZpbmRSdWxlQnlOYW1lKGFzdCwgbm9kZS5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBFRy5HcmFtbWFyRXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVmZXJlbmNlZCBydWxlIFxcXCJcIiArIG5vZGUubmFtZSArIFwiXFxcIiBkb2VzIG5vdCBleGlzdC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgIGxpdGVyYWw6ICAgICAgbm9wLFxuICAgICAgYW55OiAgICAgICAgICBub3AsXG4gICAgICBcImNsYXNzXCI6ICAgICAgbm9wXG4gICAgfSk7XG5cbiAgICBjaGVjayhhc3QpO1xuICB9LFxuXG4gIC8qIENoZWNrcyB0aGF0IG5vIGxlZnQgcmVjdXJzaW9uIGlzIHByZXNlbnQuICovXG4gIHJlcG9ydExlZnRSZWN1cnNpb246IGZ1bmN0aW9uKGFzdCkge1xuICAgIGZ1bmN0aW9uIG5vcCgpIHt9XG5cbiAgICBmdW5jdGlvbiBjaGVja0V4cHJlc3Npb24obm9kZSwgYXBwbGllZFJ1bGVzKSB7XG4gICAgICBjaGVjayhub2RlLmV4cHJlc3Npb24sIGFwcGxpZWRSdWxlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tTdWJub2Rlcyhwcm9wZXJ0eU5hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihub2RlLCBhcHBsaWVkUnVsZXMpIHtcbiAgICAgICAgZWFjaChub2RlW3Byb3BlcnR5TmFtZV0sIGZ1bmN0aW9uKHN1Ym5vZGUpIHtcbiAgICAgICAgICBjaGVjayhzdWJub2RlLCBhcHBsaWVkUnVsZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGNoZWNrID0gYnVpbGROb2RlVmlzaXRvcih7XG4gICAgICBncmFtbWFyOiAgICAgY2hlY2tTdWJub2RlcyhcInJ1bGVzXCIpLFxuXG4gICAgICBydWxlOlxuICAgICAgICBmdW5jdGlvbihub2RlLCBhcHBsaWVkUnVsZXMpIHtcbiAgICAgICAgICBjaGVjayhub2RlLmV4cHJlc3Npb24sIGFwcGxpZWRSdWxlcy5jb25jYXQobm9kZS5uYW1lKSk7XG4gICAgICAgIH0sXG5cbiAgICAgIGNob2ljZTogICAgICBjaGVja1N1Ym5vZGVzKFwiYWx0ZXJuYXRpdmVzXCIpLFxuXG4gICAgICBzZXF1ZW5jZTpcbiAgICAgICAgZnVuY3Rpb24obm9kZSwgYXBwbGllZFJ1bGVzKSB7XG4gICAgICAgICAgaWYgKG5vZGUuZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY2hlY2sobm9kZS5lbGVtZW50c1swXSwgYXBwbGllZFJ1bGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgIGxhYmVsZWQ6ICAgICAgY2hlY2tFeHByZXNzaW9uLFxuICAgICAgc2ltcGxlX2FuZDogICBjaGVja0V4cHJlc3Npb24sXG4gICAgICBzaW1wbGVfbm90OiAgIGNoZWNrRXhwcmVzc2lvbixcbiAgICAgIHNlbWFudGljX2FuZDogbm9wLFxuICAgICAgc2VtYW50aWNfbm90OiBub3AsXG4gICAgICBvcHRpb25hbDogICAgIGNoZWNrRXhwcmVzc2lvbixcbiAgICAgIHplcm9fb3JfbW9yZTogY2hlY2tFeHByZXNzaW9uLFxuICAgICAgb25lX29yX21vcmU6ICBjaGVja0V4cHJlc3Npb24sXG4gICAgICBhY3Rpb246ICAgICAgIGNoZWNrRXhwcmVzc2lvbixcblxuICAgICAgcnVsZV9yZWY6XG4gICAgICAgIGZ1bmN0aW9uKG5vZGUsIGFwcGxpZWRSdWxlcykge1xuICAgICAgICAgIGlmIChjb250YWlucyhhcHBsaWVkUnVsZXMsIG5vZGUubmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQRUcuR3JhbW1hckVycm9yKFxuICAgICAgICAgICAgICBcIkxlZnQgcmVjdXJzaW9uIGRldGVjdGVkIGZvciBydWxlIFxcXCJcIiArIG5vZGUubmFtZSArIFwiXFxcIi5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hlY2soZmluZFJ1bGVCeU5hbWUoYXN0LCBub2RlLm5hbWUpLCBhcHBsaWVkUnVsZXMpO1xuICAgICAgICB9LFxuXG4gICAgICBsaXRlcmFsOiAgICAgIG5vcCxcbiAgICAgIGFueTogICAgICAgICAgbm9wLFxuICAgICAgXCJjbGFzc1wiOiAgICAgIG5vcFxuICAgIH0pO1xuXG4gICAgY2hlY2soYXN0LCBbXSk7XG4gIH0sXG5cbiAgLypcbiAgICogUmVtb3ZlcyBwcm94eSBydWxlcyAtLSB0aGF0IGlzLCBydWxlcyB0aGF0IG9ubHkgZGVsZWdhdGUgdG8gb3RoZXIgcnVsZS5cbiAgICovXG4gIHJlbW92ZVByb3h5UnVsZXM6IGZ1bmN0aW9uKGFzdCkge1xuICAgIGZ1bmN0aW9uIGlzUHJveHlSdWxlKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwicnVsZVwiICYmIG5vZGUuZXhwcmVzc2lvbi50eXBlID09PSBcInJ1bGVfcmVmXCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZVJ1bGVSZWZzKGFzdCwgZnJvbSwgdG8pIHtcbiAgICAgIGZ1bmN0aW9uIG5vcCgpIHt9XG5cbiAgICAgIGZ1bmN0aW9uIHJlcGxhY2VJbkV4cHJlc3Npb24obm9kZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgcmVwbGFjZShub2RlLmV4cHJlc3Npb24sIGZyb20sIHRvKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVwbGFjZUluU3Vibm9kZXMocHJvcGVydHlOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihub2RlLCBmcm9tLCB0bykge1xuICAgICAgICAgIGVhY2gobm9kZVtwcm9wZXJ0eU5hbWVdLCBmdW5jdGlvbihzdWJub2RlKSB7XG4gICAgICAgICAgICByZXBsYWNlKHN1Ym5vZGUsIGZyb20sIHRvKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcGxhY2UgPSBidWlsZE5vZGVWaXNpdG9yKHtcbiAgICAgICAgZ3JhbW1hcjogICAgICByZXBsYWNlSW5TdWJub2RlcyhcInJ1bGVzXCIpLFxuICAgICAgICBydWxlOiAgICAgICAgIHJlcGxhY2VJbkV4cHJlc3Npb24sXG4gICAgICAgIGNob2ljZTogICAgICAgcmVwbGFjZUluU3Vibm9kZXMoXCJhbHRlcm5hdGl2ZXNcIiksXG4gICAgICAgIHNlcXVlbmNlOiAgICAgcmVwbGFjZUluU3Vibm9kZXMoXCJlbGVtZW50c1wiKSxcbiAgICAgICAgbGFiZWxlZDogICAgICByZXBsYWNlSW5FeHByZXNzaW9uLFxuICAgICAgICBzaW1wbGVfYW5kOiAgIHJlcGxhY2VJbkV4cHJlc3Npb24sXG4gICAgICAgIHNpbXBsZV9ub3Q6ICAgcmVwbGFjZUluRXhwcmVzc2lvbixcbiAgICAgICAgc2VtYW50aWNfYW5kOiBub3AsXG4gICAgICAgIHNlbWFudGljX25vdDogbm9wLFxuICAgICAgICBvcHRpb25hbDogICAgIHJlcGxhY2VJbkV4cHJlc3Npb24sXG4gICAgICAgIHplcm9fb3JfbW9yZTogcmVwbGFjZUluRXhwcmVzc2lvbixcbiAgICAgICAgb25lX29yX21vcmU6ICByZXBsYWNlSW5FeHByZXNzaW9uLFxuICAgICAgICBhY3Rpb246ICAgICAgIHJlcGxhY2VJbkV4cHJlc3Npb24sXG5cbiAgICAgICAgcnVsZV9yZWY6XG4gICAgICAgICAgZnVuY3Rpb24obm9kZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5hbWUgPT09IGZyb20pIHtcbiAgICAgICAgICAgICAgbm9kZS5uYW1lID0gdG87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICBsaXRlcmFsOiAgICAgIG5vcCxcbiAgICAgICAgYW55OiAgICAgICAgICBub3AsXG4gICAgICAgIFwiY2xhc3NcIjogICAgICBub3BcbiAgICAgIH0pO1xuXG4gICAgICByZXBsYWNlKGFzdCwgZnJvbSwgdG8pO1xuICAgIH1cblxuICAgIHZhciBpbmRpY2VzID0gW107XG5cbiAgICBlYWNoKGFzdC5ydWxlcywgZnVuY3Rpb24ocnVsZSwgaSkge1xuICAgICAgaWYgKGlzUHJveHlSdWxlKHJ1bGUpKSB7XG4gICAgICAgIHJlcGxhY2VSdWxlUmVmcyhhc3QsIHJ1bGUubmFtZSwgcnVsZS5leHByZXNzaW9uLm5hbWUpO1xuICAgICAgICBpZiAocnVsZS5uYW1lID09PSBhc3Quc3RhcnRSdWxlKSB7XG4gICAgICAgICAgYXN0LnN0YXJ0UnVsZSA9IHJ1bGUuZXhwcmVzc2lvbi5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGluZGljZXMucHVzaChpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGluZGljZXMucmV2ZXJzZSgpO1xuXG4gICAgZWFjaChpbmRpY2VzLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgYXN0LnJ1bGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLypcbiAgICogQ29tcHV0ZXMgbmFtZXMgb2YgdmFyaWFibGVzIHVzZWQgZm9yIHN0b3JpbmcgbWF0Y2ggcmVzdWx0cyBhbmQgcGFyc2VcbiAgICogcG9zaXRpb25zIGluIGdlbmVyYXRlZCBjb2RlLiBUaGVzZSB2YXJpYWJsZXMgYXJlIG9yZ2FuaXplZCBhcyB0d28gc3RhY2tzLlxuICAgKiBUaGUgZm9sbG93aW5nIHdpbGwgaG9sZCBhZnRlciBydW5uaW5nIHRoaXMgcGFzczpcbiAgICpcbiAgICogICAqIEFsbCBub2RlcyBleGNlcHQgXCJncmFtbWFyXCIgYW5kIFwicnVsZVwiIG5vZGVzIHdpbGwgaGF2ZSBhIHxyZXN1bHRWYXJ8XG4gICAqICAgICBwcm9wZXJ0eS4gSXQgd2lsbCBjb250YWluIGEgbmFtZSBvZiB0aGUgdmFyaWFibGUgdGhhdCB3aWxsIHN0b3JlIGFcbiAgICogICAgIG1hdGNoIHJlc3VsdCBvZiB0aGUgZXhwcmVzc2lvbiByZXByZXNlbnRlZCBieSB0aGUgbm9kZSBpbiBnZW5lcmF0ZWRcbiAgICogICAgIGNvZGUuXG4gICAqXG4gICAqICAgKiBTb21lIG5vZGVzIHdpbGwgaGF2ZSBhIHxwb3NWYXJ8IHByb3BlcnR5LiBJdCB3aWxsIGNvbnRhaW4gYSBuYW1lIG9mIHRoZVxuICAgKiAgICAgdmFyaWFibGUgdGhhdCB3aWxsIHN0b3JlIGEgcGFyc2UgcG9zaXRpb24gaW4gZ2VuZXJhdGVkIGNvZGUuXG4gICAqXG4gICAqICAgKiBBbGwgXCJydWxlXCIgbm9kZXMgd2lsbCBjb250YWluIHxyZXN1bHRWYXJzfCBhbmQgfHBvc1ZhcnN8IHByb3BlcnRpZXMuXG4gICAqICAgICBUaGV5IHdpbGwgY29udGFpbiBhIGxpc3Qgb2YgdmFsdWVzIG9mIHxyZXN1bHRWYXJ8IGFuZCB8cG9zVmFyfFxuICAgKiAgICAgcHJvcGVydGllcyB1c2VkIGluIHJ1bGUncyBzdWJub2Rlcy4gKFRoaXMgaXMgdXNlZnVsIHRvIGRlY2xhcmVcbiAgICogICAgIHZhcmlhYmxlcyBpbiBnZW5lcmF0ZWQgY29kZS4pXG4gICAqL1xuICBjb21wdXRlVmFyTmFtZXM6IGZ1bmN0aW9uKGFzdCkge1xuICAgIGZ1bmN0aW9uIHJlc3VsdFZhcihpbmRleCkgeyByZXR1cm4gXCJyZXN1bHRcIiArIGluZGV4OyB9XG4gICAgZnVuY3Rpb24gcG9zVmFyKGluZGV4KSAgICB7IHJldHVybiBcInBvc1wiICAgICsgaW5kZXg7IH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVMZWFmKG5vZGUsIGluZGV4KSB7XG4gICAgICBub2RlLnJlc3VsdFZhciA9IHJlc3VsdFZhcihpbmRleC5yZXN1bHQpO1xuXG4gICAgICByZXR1cm4geyByZXN1bHQ6IDAsIHBvczogMCB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVGcm9tRXhwcmVzc2lvbihkZWx0YSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUsIGluZGV4KSB7XG4gICAgICAgIHZhciBkZXB0aCA9IGNvbXB1dGUoXG4gICAgICAgICAgICAgIG5vZGUuZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogaW5kZXgucmVzdWx0ICsgZGVsdGEucmVzdWx0LFxuICAgICAgICAgICAgICAgIHBvczogICAgaW5kZXgucG9zICAgICsgZGVsdGEucG9zXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgbm9kZS5yZXN1bHRWYXIgPSByZXN1bHRWYXIoaW5kZXgucmVzdWx0KTtcbiAgICAgICAgaWYgKGRlbHRhLnBvcyAhPT0gMCkge1xuICAgICAgICAgIG5vZGUucG9zVmFyID0gcG9zVmFyKGluZGV4LnBvcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdDogZGVwdGgucmVzdWx0ICsgZGVsdGEucmVzdWx0LFxuICAgICAgICAgIHBvczogICAgZGVwdGgucG9zICAgICsgZGVsdGEucG9zXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBjb21wdXRlID0gYnVpbGROb2RlVmlzaXRvcih7XG4gICAgICBncmFtbWFyOlxuICAgICAgICBmdW5jdGlvbihub2RlLCBpbmRleCkge1xuICAgICAgICAgIGVhY2gobm9kZS5ydWxlcywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgY29tcHV0ZShub2RlLCBpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgIHJ1bGU6XG4gICAgICAgIGZ1bmN0aW9uKG5vZGUsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIGRlcHRoID0gY29tcHV0ZShub2RlLmV4cHJlc3Npb24sIGluZGV4KTtcblxuICAgICAgICAgIG5vZGUucmVzdWx0VmFyICA9IHJlc3VsdFZhcihpbmRleC5yZXN1bHQpO1xuICAgICAgICAgIG5vZGUucmVzdWx0VmFycyA9IG1hcChyYW5nZShkZXB0aC5yZXN1bHQgKyAxKSwgcmVzdWx0VmFyKTtcbiAgICAgICAgICBub2RlLnBvc1ZhcnMgICAgPSBtYXAocmFuZ2UoZGVwdGgucG9zKSwgICAgICAgIHBvc1Zhcik7XG4gICAgICAgIH0sXG5cbiAgICAgIGNob2ljZTpcbiAgICAgICAgZnVuY3Rpb24obm9kZSwgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgZGVwdGhzID0gbWFwKG5vZGUuYWx0ZXJuYXRpdmVzLCBmdW5jdGlvbihhbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXB1dGUoYWx0ZXJuYXRpdmUsIGluZGV4KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG5vZGUucmVzdWx0VmFyID0gcmVzdWx0VmFyKGluZGV4LnJlc3VsdCk7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiBNYXRoLm1heC5hcHBseShudWxsLCBwbHVjayhkZXB0aHMsIFwicmVzdWx0XCIpKSxcbiAgICAgICAgICAgIHBvczogICAgTWF0aC5tYXguYXBwbHkobnVsbCwgcGx1Y2soZGVwdGhzLCBcInBvc1wiKSlcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICBzZXF1ZW5jZTpcbiAgICAgICAgZnVuY3Rpb24obm9kZSwgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgZGVwdGhzID0gbWFwKG5vZGUuZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlKFxuICAgICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgICB7IHJlc3VsdDogaW5kZXgucmVzdWx0ICsgaSwgcG9zOiBpbmRleC5wb3MgKyAxIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBub2RlLnJlc3VsdFZhciA9IHJlc3VsdFZhcihpbmRleC5yZXN1bHQpO1xuICAgICAgICAgIG5vZGUucG9zVmFyICAgID0gcG9zVmFyKGluZGV4LnBvcyk7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OlxuICAgICAgICAgICAgICBub2RlLmVsZW1lbnRzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICA/IE1hdGgubWF4LmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtYXAoZGVwdGhzLCBmdW5jdGlvbihkLCBpKSB7IHJldHVybiBpICsgZC5yZXN1bHQ7IH0pXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiAwLFxuXG4gICAgICAgICAgICBwb3M6XG4gICAgICAgICAgICAgIG5vZGUuZWxlbWVudHMubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgID8gMSArIE1hdGgubWF4LmFwcGx5KG51bGwsIHBsdWNrKGRlcHRocywgXCJwb3NcIikpXG4gICAgICAgICAgICAgICAgOiAxXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgbGFiZWxlZDogICAgICBjb21wdXRlRnJvbUV4cHJlc3Npb24oeyByZXN1bHQ6IDAsIHBvczogMCB9KSxcbiAgICAgIHNpbXBsZV9hbmQ6ICAgY29tcHV0ZUZyb21FeHByZXNzaW9uKHsgcmVzdWx0OiAwLCBwb3M6IDEgfSksXG4gICAgICBzaW1wbGVfbm90OiAgIGNvbXB1dGVGcm9tRXhwcmVzc2lvbih7IHJlc3VsdDogMCwgcG9zOiAxIH0pLFxuICAgICAgc2VtYW50aWNfYW5kOiBjb21wdXRlTGVhZixcbiAgICAgIHNlbWFudGljX25vdDogY29tcHV0ZUxlYWYsXG4gICAgICBvcHRpb25hbDogICAgIGNvbXB1dGVGcm9tRXhwcmVzc2lvbih7IHJlc3VsdDogMCwgcG9zOiAwIH0pLFxuICAgICAgemVyb19vcl9tb3JlOiBjb21wdXRlRnJvbUV4cHJlc3Npb24oeyByZXN1bHQ6IDEsIHBvczogMCB9KSxcbiAgICAgIG9uZV9vcl9tb3JlOiAgY29tcHV0ZUZyb21FeHByZXNzaW9uKHsgcmVzdWx0OiAxLCBwb3M6IDAgfSksXG4gICAgICBhY3Rpb246ICAgICAgIGNvbXB1dGVGcm9tRXhwcmVzc2lvbih7IHJlc3VsdDogMCwgcG9zOiAxIH0pLFxuICAgICAgcnVsZV9yZWY6ICAgICBjb21wdXRlTGVhZixcbiAgICAgIGxpdGVyYWw6ICAgICAgY29tcHV0ZUxlYWYsXG4gICAgICBhbnk6ICAgICAgICAgIGNvbXB1dGVMZWFmLFxuICAgICAgXCJjbGFzc1wiOiAgICAgIGNvbXB1dGVMZWFmXG4gICAgfSk7XG5cbiAgICBjb21wdXRlKGFzdCwgeyByZXN1bHQ6IDAsIHBvczogMCB9KTtcbiAgfSxcblxuICAvKlxuICAgKiBUaGlzIHBhc3Mgd2Fsa3MgdGhyb3VnaCB0aGUgQVNUIGFuZCB0cmFja3Mgd2hhdCBsYWJlbHMgYXJlIHZpc2libGUgYXQgZWFjaFxuICAgKiBwb2ludC4gRm9yIFwiYWN0aW9uXCIsIFwic2VtYW50aWNfYW5kXCIgYW5kIFwic2VtYW50aWNfb3JcIiBub2RlcyBpdCBjb21wdXRlc1xuICAgKiBwYXJhbWV0ZXIgbmFtZXMgYW5kIHZhbHVlcyBmb3IgdGhlIGZ1bmN0aW9uIHVzZWQgaW4gZ2VuZXJhdGVkIGNvZGUuIChJbiB0aGVcbiAgICogZW1pdHRlciwgdXNlcidzIGNvZGUgaXMgd3JhcHBlZCBpbnRvIGEgZnVuY3Rpb24gdGhhdCBpcyBpbW1lZGlhdGVseVxuICAgKiBleGVjdXRlZC4gSXRzIHBhcmFtZXRlciBuYW1lcyBjb3JyZXNwb25kIHRvIHZpc2libGUgbGFiZWxzIGFuZCBpdHNcbiAgICogcGFyYW1ldGVyIHZhbHVlcyB0byB0aGVpciBjYXB0dXJlZCB2YWx1ZXMpLiBJbXBsaWNpdGx5LCB0aGlzIHBhc3MgZGVmaW5lc1xuICAgKiBzY29waW5nIHJ1bGVzIGZvciBsYWJlbHMuXG4gICAqXG4gICAqIEFmdGVyIHJ1bm5pbmcgdGhpcyBwYXNzLCBhbGwgXCJhY3Rpb25cIiwgXCJzZW1hbnRpY19hbmRcIiBhbmQgXCJzZW1hbnRpY19vclwiXG4gICAqIG5vZGVzIHdpbGwgaGF2ZSBhIHxwYXJhbXN8IHByb3BlcnR5IGNvbnRhaW5pbmcgYW4gb2JqZWN0IG1hcHBpbmcgcGFyYW1ldGVyXG4gICAqIG5hbWVzIHRvIHRoZSBleHByZXNzaW9ucyB0aGF0IHdpbGwgYmUgdXNlZCBhcyB0aGVpciB2YWx1ZXMuXG4gICAqL1xuICBjb21wdXRlUGFyYW1zOiBmdW5jdGlvbihhc3QpIHtcbiAgICB2YXIgZW52cyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gc2NvcGVkKGYpIHtcbiAgICAgIGVudnMucHVzaCh7fSk7XG4gICAgICBmKCk7XG4gICAgICBlbnZzLnBvcCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcCgpIHt9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlRm9yU2NvcGVkRXhwcmVzc2lvbihub2RlKSB7XG4gICAgICBzY29wZWQoZnVuY3Rpb24oKSB7IGNvbXB1dGUobm9kZS5leHByZXNzaW9uKTsgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVBhcmFtcyhub2RlKSB7XG4gICAgICB2YXIgZW52ID0gZW52c1tlbnZzLmxlbmd0aCAtIDFdLCBwYXJhbXMgPSB7fSwgbmFtZTtcblxuICAgICAgZm9yIChuYW1lIGluIGVudikge1xuICAgICAgICBwYXJhbXNbbmFtZV0gPSBlbnZbbmFtZV07XG4gICAgICB9XG4gICAgICBub2RlLnBhcmFtcyA9IHBhcmFtcztcbiAgICB9XG5cbiAgICB2YXIgY29tcHV0ZSA9IGJ1aWxkTm9kZVZpc2l0b3Ioe1xuICAgICAgZ3JhbW1hcjpcbiAgICAgICAgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIGVhY2gobm9kZS5ydWxlcywgY29tcHV0ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgIHJ1bGU6ICAgICAgICAgY29tcHV0ZUZvclNjb3BlZEV4cHJlc3Npb24sXG5cbiAgICAgIGNob2ljZTpcbiAgICAgICAgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIHNjb3BlZChmdW5jdGlvbigpIHsgZWFjaChub2RlLmFsdGVybmF0aXZlcywgY29tcHV0ZSk7IH0pO1xuICAgICAgICB9LFxuXG4gICAgICBzZXF1ZW5jZTpcbiAgICAgICAgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIHZhciBlbnYgPSBlbnZzW2VudnMubGVuZ3RoIC0gMV0sIG5hbWU7XG5cbiAgICAgICAgICBmdW5jdGlvbiBmaXh1cChuYW1lKSB7XG4gICAgICAgICAgICBlYWNoKHBsdWNrKG5vZGUuZWxlbWVudHMsIFwicmVzdWx0VmFyXCIpLCBmdW5jdGlvbihyZXN1bHRWYXIsIGkpIHtcbiAgICAgICAgICAgICAgaWYgKChuZXcgUmVnRXhwKFwiXlwiICsgcmVzdWx0VmFyICsgXCIoXFxcXFtcXFxcZCtcXFxcXSkqJFwiKSkudGVzdChlbnZbbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgZW52W25hbWVdID0gbm9kZS5yZXN1bHRWYXIgKyBcIltcIiArIGkgKyBcIl1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICArIGVudltuYW1lXS5zdWJzdHIocmVzdWx0VmFyLmxlbmd0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVhY2gobm9kZS5lbGVtZW50cywgY29tcHV0ZSk7XG5cbiAgICAgICAgICBmb3IgKG5hbWUgaW4gZW52KSB7XG4gICAgICAgICAgICBmaXh1cChuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgIGxhYmVsZWQ6XG4gICAgICAgIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBlbnZzW2VudnMubGVuZ3RoIC0gMV1bbm9kZS5sYWJlbF0gPSBub2RlLnJlc3VsdFZhcjtcblxuICAgICAgICAgIHNjb3BlZChmdW5jdGlvbigpIHsgY29tcHV0ZShub2RlLmV4cHJlc3Npb24pOyB9KTtcbiAgICAgICAgfSxcblxuICAgICAgc2ltcGxlX2FuZDogICBjb21wdXRlRm9yU2NvcGVkRXhwcmVzc2lvbixcbiAgICAgIHNpbXBsZV9ub3Q6ICAgY29tcHV0ZUZvclNjb3BlZEV4cHJlc3Npb24sXG4gICAgICBzZW1hbnRpY19hbmQ6IGNvbXB1dGVQYXJhbXMsXG4gICAgICBzZW1hbnRpY19ub3Q6IGNvbXB1dGVQYXJhbXMsXG4gICAgICBvcHRpb25hbDogICAgIGNvbXB1dGVGb3JTY29wZWRFeHByZXNzaW9uLFxuICAgICAgemVyb19vcl9tb3JlOiBjb21wdXRlRm9yU2NvcGVkRXhwcmVzc2lvbixcbiAgICAgIG9uZV9vcl9tb3JlOiAgY29tcHV0ZUZvclNjb3BlZEV4cHJlc3Npb24sXG5cbiAgICAgIGFjdGlvbjpcbiAgICAgICAgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIHNjb3BlZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbXB1dGUobm9kZS5leHByZXNzaW9uKTtcbiAgICAgICAgICAgIGNvbXB1dGVQYXJhbXMobm9kZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgIHJ1bGVfcmVmOiAgICAgbm9wLFxuICAgICAgbGl0ZXJhbDogICAgICBub3AsXG4gICAgICBhbnk6ICAgICAgICAgIG5vcCxcbiAgICAgIFwiY2xhc3NcIjogICAgICBub3BcbiAgICB9KTtcblxuICAgIGNvbXB1dGUoYXN0KTtcbiAgfVxufTtcbi8qIEVtaXRzIHRoZSBnZW5lcmF0ZWQgY29kZSBmb3IgdGhlIEFTVC4gKi9cblBFRy5jb21waWxlci5lbWl0dGVyID0gZnVuY3Rpb24oYXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAob3B0aW9ucy5jYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5jYWNoZSA9IGZhbHNlO1xuICB9XG4gIGlmIChvcHRpb25zLnRyYWNrTGluZUFuZENvbHVtbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy50cmFja0xpbmVBbmRDb2x1bW4gPSBmYWxzZTtcbiAgfVxuXG4gIC8qXG4gICAqIENvZGllIDEuMS4wXG4gICAqXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kbWFqZGEvY29kaWVcbiAgICpcbiAgICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgRGF2aWQgTWFqZGFcbiAgICogTGljZW5zZW5kIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAgICovXG4gIHZhciBDb2RpZSA9IChmdW5jdGlvbih1bmRlZmluZWQpIHtcblxuICBmdW5jdGlvbiBzdHJpbmdFc2NhcGUocykge1xuICAgIGZ1bmN0aW9uIGhleChjaCkgeyByZXR1cm4gY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgfVxuXG4gICAgLypcbiAgICAgKiBFQ01BLTI2MiwgNXRoIGVkLiwgNy44LjQ6IEFsbCBjaGFyYWN0ZXJzIG1heSBhcHBlYXIgbGl0ZXJhbGx5IGluIGFcbiAgICAgKiBzdHJpbmcgbGl0ZXJhbCBleGNlcHQgZm9yIHRoZSBjbG9zaW5nIHF1b3RlIGNoYXJhY3RlciwgYmFja3NsYXNoLFxuICAgICAqIGNhcnJpYWdlIHJldHVybiwgbGluZSBzZXBhcmF0b3IsIHBhcmFncmFwaCBzZXBhcmF0b3IsIGFuZCBsaW5lIGZlZWQuXG4gICAgICogQW55IGNoYXJhY3RlciBtYXkgYXBwZWFyIGluIHRoZSBmb3JtIG9mIGFuIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgKlxuICAgICAqIEZvciBwb3J0YWJpbGl0eSwgd2UgYWxzbyBlc2NhcGUgZXNjYXBlIGFsbCBjb250cm9sIGFuZCBub24tQVNDSUlcbiAgICAgKiBjaGFyYWN0ZXJzLiBOb3RlIHRoYXQgXCJcXDBcIiBhbmQgXCJcXHZcIiBlc2NhcGUgc2VxdWVuY2VzIGFyZSBub3QgdXNlZFxuICAgICAqIGJlY2F1c2UgSlNIaW50IGRvZXMgbm90IGxpa2UgdGhlIGZpcnN0IGFuZCBJRSB0aGUgc2Vjb25kLlxuICAgICAqL1xuICAgIHJldHVybiBzXG4gICAgICAucmVwbGFjZSgvXFxcXC9nLCAgICdcXFxcXFxcXCcpIC8vIGJhY2tzbGFzaFxuICAgICAgLnJlcGxhY2UoL1wiL2csICAgICdcXFxcXCInKSAgLy8gY2xvc2luZyBkb3VibGUgcXVvdGVcbiAgICAgIC5yZXBsYWNlKC9cXHgwOC9nLCAnXFxcXGInKSAgLy8gYmFja3NwYWNlXG4gICAgICAucmVwbGFjZSgvXFx0L2csICAgJ1xcXFx0JykgIC8vIGhvcml6b250YWwgdGFiXG4gICAgICAucmVwbGFjZSgvXFxuL2csICAgJ1xcXFxuJykgIC8vIGxpbmUgZmVlZFxuICAgICAgLnJlcGxhY2UoL1xcZi9nLCAgICdcXFxcZicpICAvLyBmb3JtIGZlZWRcbiAgICAgIC5yZXBsYWNlKC9cXHIvZywgICAnXFxcXHInKSAgLy8gY2FycmlhZ2UgcmV0dXJuXG4gICAgICAucmVwbGFjZSgvW1xceDAwLVxceDA3XFx4MEJcXHgwRVxceDBGXS9nLCBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4MCcgKyBoZXgoY2gpOyB9KVxuICAgICAgLnJlcGxhY2UoL1tcXHgxMC1cXHgxRlxceDgwLVxceEZGXS9nLCAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4JyAgKyBoZXgoY2gpOyB9KVxuICAgICAgLnJlcGxhY2UoL1tcXHUwMTgwLVxcdTBGRkZdL2csICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxcdTAnICsgaGV4KGNoKTsgfSlcbiAgICAgIC5yZXBsYWNlKC9bXFx1MTA4MC1cXHVGRkZGXS9nLCAgICAgICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHUnICArIGhleChjaCk7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaChzKSB7IHJldHVybiAnX19wLnB1c2goJyArIHMgKyAnKTsnOyB9XG5cbiAgZnVuY3Rpb24gcHVzaFJhdyh0ZW1wbGF0ZSwgbGVuZ3RoLCBzdGF0ZSkge1xuICAgIGZ1bmN0aW9uIHVuaW5kZW50KGNvZGUsIGxldmVsLCB1bmluZGVudEZpcnN0KSB7XG4gICAgICByZXR1cm4gY29kZS5yZXBsYWNlKFxuICAgICAgICBuZXcgUmVnRXhwKCdeLnsnICsgbGV2ZWwgKyd9JywgXCJnbVwiKSxcbiAgICAgICAgZnVuY3Rpb24oc3RyLCBvZmZzZXQpIHtcbiAgICAgICAgICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5pbmRlbnRGaXJzdCA/ICcnIDogc3RyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGVzY2FwZWQgPSBzdHJpbmdFc2NhcGUodW5pbmRlbnQoXG4gICAgICAgICAgdGVtcGxhdGUuc3Vic3RyaW5nKDAsIGxlbmd0aCksXG4gICAgICAgICAgc3RhdGUuaW5kZW50TGV2ZWwoKSxcbiAgICAgICAgICBzdGF0ZS5hdEJPTFxuICAgICAgICApKTtcblxuICAgIHJldHVybiBlc2NhcGVkLmxlbmd0aCA+IDAgPyBwdXNoKCdcIicgKyBlc2NhcGVkICsgJ1wiJykgOiAnJztcbiAgfVxuXG5cbiAgdmFyIENvZGllID0ge1xuICAgIC8qIENvZGllIHZlcnNpb24gKHVzZXMgc2VtYW50aWMgdmVyc2lvbmluZykuICovXG4gICAgVkVSU0lPTjogXCIxLjEuMFwiLFxuXG4gICAgLypcbiAgICAgKiBTcGVjaWZpZXMgYnkgaG93IG1hbnkgY2hhcmFjdGVycyBkbyAjaWYvI2Vsc2UgYW5kICNmb3IgdW5pbmRlbnQgdGhlaXJcbiAgICAgKiBjb250ZW50IGluIHRoZSBnZW5lcmF0ZWQgY29kZS5cbiAgICAgKi9cbiAgICBpbmRlbnRTdGVwOiAyLFxuXG4gICAgLyogRGVzY3JpcHRpb24gb2YgIy1jb21tYW5kcy4gRXh0ZW5kIHRvIGRlZmluZSB5b3VyIG93biBjb21tYW5kcy4gKi9cbiAgICBjb21tYW5kczoge1xuICAgICAgXCJpZlwiOiAgIHtcbiAgICAgICAgcGFyYW1zOiAgL14oLiopJC8sXG4gICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKHN0YXRlLCBwcmVmaXgsIHBhcmFtcykge1xuICAgICAgICAgIHJldHVybiBbJ2lmKCcgKyBwYXJhbXNbMF0gKyAnKXsnLCBbXV07XG4gICAgICAgIH0sXG4gICAgICAgIHN0YWNrT3A6IFwicHVzaFwiXG4gICAgICB9LFxuICAgICAgXCJlbHNlXCI6IHtcbiAgICAgICAgcGFyYW1zOiAgL14kLyxcbiAgICAgICAgY29tcGlsZTogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5jb21tYW5kU3RhY2ssXG4gICAgICAgICAgICAgIGluc2lkZUVsc2UgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJlbHNlXCIsXG4gICAgICAgICAgICAgIGluc2lkZUlmICAgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJpZlwiO1xuXG4gICAgICAgICAgaWYgKGluc2lkZUVsc2UpIHsgdGhyb3cgbmV3IEVycm9yKFwiTXVsdGlwbGUgI2Vsc2VzLlwiKTsgfVxuICAgICAgICAgIGlmICghaW5zaWRlSWYpICB7IHRocm93IG5ldyBFcnJvcihcIlVzaW5nICNlbHNlIG91dHNpZGUgb2YgI2lmLlwiKTsgfVxuXG4gICAgICAgICAgcmV0dXJuIFsnfWVsc2V7JywgW11dO1xuICAgICAgICB9LFxuICAgICAgICBzdGFja09wOiBcInJlcGxhY2VcIlxuICAgICAgfSxcbiAgICAgIFwiZm9yXCI6ICB7XG4gICAgICAgIHBhcmFtczogIC9eKFthLXpBLVpfXVthLXpBLVowLTlfXSopWyBcXHRdK2luWyBcXHRdKyguKikkLyxcbiAgICAgICAgaW5pdDogICAgZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5mb3JDdXJyTGV2ZWwgPSAwOyAgLy8gY3VycmVudCBsZXZlbCBvZiAjZm9yIGxvb3AgbmVzdGluZ1xuICAgICAgICAgIHN0YXRlLmZvck1heExldmVsICA9IDA7ICAvLyBtYXhpbXVtIGxldmVsIG9mICNmb3IgbG9vcCBuZXN0aW5nXG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKHN0YXRlLCBwcmVmaXgsIHBhcmFtcykge1xuICAgICAgICAgIHZhciBjID0gJ19fYycgKyBzdGF0ZS5mb3JDdXJyTGV2ZWwsIC8vIF9fYyBmb3IgXCJjb2xsZWN0aW9uXCJcbiAgICAgICAgICAgICAgbCA9ICdfX2wnICsgc3RhdGUuZm9yQ3VyckxldmVsLCAvLyBfX2wgZm9yIFwibGVuZ3RoXCJcbiAgICAgICAgICAgICAgaSA9ICdfX2knICsgc3RhdGUuZm9yQ3VyckxldmVsOyAvLyBfX2kgZm9yIFwiaW5kZXhcIlxuXG4gICAgICAgICAgc3RhdGUuZm9yQ3VyckxldmVsKys7XG4gICAgICAgICAgaWYgKHN0YXRlLmZvck1heExldmVsIDwgc3RhdGUuZm9yQ3VyckxldmVsKSB7XG4gICAgICAgICAgICBzdGF0ZS5mb3JNYXhMZXZlbCA9IHN0YXRlLmZvckN1cnJMZXZlbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgYyArICc9JyArIHBhcmFtc1sxXSArICc7J1xuICAgICAgICAgICAgICArIGwgKyAnPScgKyBjICsgJy5sZW5ndGg7J1xuICAgICAgICAgICAgICArICdmb3IoJyArIGkgKyAnPTA7JyArIGkgKyAnPCcgKyBsICsgJzsnICsgaSArICcrKyl7J1xuICAgICAgICAgICAgICArIHBhcmFtc1swXSArICc9JyArIGMgKyAnWycgKyBpICsgJ107JyxcbiAgICAgICAgICAgIFtwYXJhbXNbMF0sIGMsIGwsIGldXG4gICAgICAgICAgXTtcbiAgICAgICAgfSxcbiAgICAgICAgZXhpdDogICAgZnVuY3Rpb24oc3RhdGUpIHsgc3RhdGUuZm9yQ3VyckxldmVsLS07IH0sXG4gICAgICAgIHN0YWNrT3A6IFwicHVzaFwiXG4gICAgICB9LFxuICAgICAgXCJlbmRcIjogIHtcbiAgICAgICAgcGFyYW1zOiAgL14kLyxcbiAgICAgICAgY29tcGlsZTogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5jb21tYW5kU3RhY2ssIGV4aXQ7XG5cbiAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7IHRocm93IG5ldyBFcnJvcihcIlRvbyBtYW55ICNlbmRzLlwiKTsgfVxuXG4gICAgICAgICAgZXhpdCA9IENvZGllLmNvbW1hbmRzW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXS5leGl0O1xuICAgICAgICAgIGlmIChleGl0KSB7IGV4aXQoc3RhdGUpOyB9XG5cbiAgICAgICAgICByZXR1cm4gWyd9JywgW11dO1xuICAgICAgICB9LFxuICAgICAgICBzdGFja09wOiBcInBvcFwiXG4gICAgICB9LFxuICAgICAgXCJibG9ja1wiOiB7XG4gICAgICAgIHBhcmFtczogL14oLiopJC8sXG4gICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKHN0YXRlLCBwcmVmaXgsIHBhcmFtcykge1xuICAgICAgICAgIHZhciB4ID0gJ19feCcsIC8vIF9feCBmb3IgXCJwcmVmaXhcIixcbiAgICAgICAgICAgICAgbiA9ICdfX24nLCAvLyBfX24gZm9yIFwibGluZXNcIlxuICAgICAgICAgICAgICBsID0gJ19fbCcsIC8vIF9fbCBmb3IgXCJsZW5ndGhcIlxuICAgICAgICAgICAgICBpID0gJ19faSc7IC8vIF9faSBmb3IgXCJpbmRleFwiXG5cbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIE9yaWdpbmFsbHksIHRoZSBnZW5lcmF0ZWQgY29kZSB1c2VkIHxTdHJpbmcucHJvdG90eXBlLnJlcGxhY2V8LCBidXRcbiAgICAgICAgICAgKiBpdCBpcyBidWdneSBpbiBjZXJ0YWluIHZlcnNpb25zIG9mIFY4IHNvIGl0IHdhcyByZXdyaXR0ZW4uIFNlZSB0aGVcbiAgICAgICAgICAgKiB0ZXN0cyBmb3IgZGV0YWlscy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeCArICc9XCInICsgc3RyaW5nRXNjYXBlKHByZWZpeC5zdWJzdHJpbmcoc3RhdGUuaW5kZW50TGV2ZWwoKSkpICsgJ1wiOydcbiAgICAgICAgICAgICAgKyBuICsgJz0oJyArIHBhcmFtc1swXSArICcpLnRvU3RyaW5nKCkuc3BsaXQoXCJcXFxcblwiKTsnXG4gICAgICAgICAgICAgICsgbCArICc9JyArIG4gKyAnLmxlbmd0aDsnXG4gICAgICAgICAgICAgICsgJ2ZvcignICsgaSArICc9MDsnICsgaSArICc8JyArIGwgKyAnOycgKyBpICsgJysrKXsnXG4gICAgICAgICAgICAgICsgbiArICdbJyArIGkgKyddPScgKyB4ICsgJysnICsgbiArICdbJyArIGkgKyAnXStcIlxcXFxuXCI7J1xuICAgICAgICAgICAgICArICd9J1xuICAgICAgICAgICAgICArIHB1c2gobiArICcuam9pbihcIlwiKScpLFxuICAgICAgICAgICAgW3gsIG4sIGwsIGldXG4gICAgICAgICAgXTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RhY2tPcDogXCJub3BcIlxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIENvbXBpbGVzIGEgdGVtcGxhdGUgaW50byBhIGZ1bmN0aW9uLiBXaGVuIGNhbGxlZCwgdGhpcyBmdW5jdGlvbiB3aWxsXG4gICAgICogZXhlY3V0ZSB0aGUgdGVtcGxhdGUgaW4gdGhlIGNvbnRleHQgb2YgYW4gb2JqZWN0IHBhc3NlZCBpbiBhIHBhcmFtZXRlciBhbmRcbiAgICAgKiByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICAgKi9cbiAgICB0ZW1wbGF0ZTogZnVuY3Rpb24odGVtcGxhdGUpIHtcbiAgICAgIHZhciBzdGFja09wcyA9IHtcbiAgICAgICAgcHVzaDogICAgZnVuY3Rpb24oc3RhY2ssIG5hbWUpIHsgc3RhY2sucHVzaChuYW1lKTsgfSxcbiAgICAgICAgcmVwbGFjZTogZnVuY3Rpb24oc3RhY2ssIG5hbWUpIHsgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPSBuYW1lOyB9LFxuICAgICAgICBwb3A6ICAgICBmdW5jdGlvbihzdGFjaykgICAgICAgeyBzdGFjay5wb3AoKTsgfSxcbiAgICAgICAgbm9wOiAgICAgZnVuY3Rpb24oKSAgICAgICAgICAgIHsgfVxuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gY29tcGlsZUV4cHIoc3RhdGUsIGV4cHIpIHtcbiAgICAgICAgc3RhdGUuYXRCT0wgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIFtwdXNoKGV4cHIpLCBbXV07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNvbXBpbGVDb21tYW5kKHN0YXRlLCBwcmVmaXgsIG5hbWUsIHBhcmFtcykge1xuICAgICAgICB2YXIgY29tbWFuZCwgbWF0Y2gsIHJlc3VsdDtcblxuICAgICAgICBjb21tYW5kID0gQ29kaWUuY29tbWFuZHNbbmFtZV07XG4gICAgICAgIGlmICghY29tbWFuZCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNvbW1hbmQ6ICNcIiArIG5hbWUgKyBcIi5cIik7IH1cblxuICAgICAgICBtYXRjaCA9IGNvbW1hbmQucGFyYW1zLmV4ZWMocGFyYW1zKTtcbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIHBhcmFtcyBmb3IgY29tbWFuZCAjXCIgKyBuYW1lICsgXCI6IFwiICsgcGFyYW1zICsgXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gY29tbWFuZC5jb21waWxlKHN0YXRlLCBwcmVmaXgsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgc3RhY2tPcHNbY29tbWFuZC5zdGFja09wXShzdGF0ZS5jb21tYW5kU3RhY2ssIG5hbWUpO1xuICAgICAgICBzdGF0ZS5hdEJPTCA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGF0ZSA9IHsgICAgICAgICAgICAgICAvLyBjb21waWxhdGlvbiBzdGF0ZVxuICAgICAgICAgICAgY29tbWFuZFN0YWNrOiBbXSwgICAgIC8vICAgc3RhY2sgb2YgY29tbWFuZHMgYXMgdGhleSB3ZXJlIG5lc3RlZFxuICAgICAgICAgICAgYXRCT0w6ICAgICAgICB0cnVlLCAgIC8vICAgaXMgdGhlIG5leHQgY2hhcmFjdGVyIHRvIHByb2Nlc3MgYXQgQk9MP1xuICAgICAgICAgICAgaW5kZW50TGV2ZWw6ICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIENvZGllLmluZGVudFN0ZXAgKiB0aGlzLmNvbW1hbmRTdGFjay5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb2RlID0gJycsICAgICAgICAgICAgICAvLyBnZW5lcmF0ZWQgdGVtcGxhdGUgZnVuY3Rpb24gY29kZVxuICAgICAgICAgIHZhcnMgPSBbJ19fcD1bXSddLCAgICAgIC8vIHZhcmlhYmxlcyB1c2VkIGJ5IGdlbmVyYXRlZCBjb2RlXG4gICAgICAgICAgbmFtZSwgbWF0Y2gsIHJlc3VsdCwgaTtcblxuICAgICAgLyogSW5pdGlhbGl6ZSBzdGF0ZS4gKi9cbiAgICAgIGZvciAobmFtZSBpbiBDb2RpZS5jb21tYW5kcykge1xuICAgICAgICBpZiAoQ29kaWUuY29tbWFuZHNbbmFtZV0uaW5pdCkgeyBDb2RpZS5jb21tYW5kc1tuYW1lXS5pbml0KHN0YXRlKTsgfVxuICAgICAgfVxuXG4gICAgICAvKiBDb21waWxlIHRoZSB0ZW1wbGF0ZS4gKi9cbiAgICAgIHdoaWxlICgobWF0Y2ggPSAvXihbIFxcdF0qKSMoW2EtekEtWl9dW2EtekEtWjAtOV9dKikoPzpbIFxcdF0rKFteIFxcdFxcbl1bXlxcbl0qKSk/WyBcXHRdKig/OlxcbnwkKXwjXFx7KFtefV0qKVxcfS9tLmV4ZWModGVtcGxhdGUpKSAhPT0gbnVsbCkge1xuICAgICAgICBjb2RlICs9IHB1c2hSYXcodGVtcGxhdGUsIG1hdGNoLmluZGV4LCBzdGF0ZSk7XG4gICAgICAgIHJlc3VsdCA9IG1hdGNoWzJdICE9PSB1bmRlZmluZWQgJiYgbWF0Y2hbMl0gIT09IFwiXCJcbiAgICAgICAgICA/IGNvbXBpbGVDb21tYW5kKHN0YXRlLCBtYXRjaFsxXSwgbWF0Y2hbMl0sIG1hdGNoWzNdIHx8IFwiXCIpIC8vICMtY29tbWFuZFxuICAgICAgICAgIDogY29tcGlsZUV4cHIoc3RhdGUsIG1hdGNoWzRdKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICN7Li4ufVxuICAgICAgICBjb2RlICs9IHJlc3VsdFswXTtcbiAgICAgICAgdmFycyA9IHZhcnMuY29uY2F0KHJlc3VsdFsxXSk7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuc3Vic3RyaW5nKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGNvZGUgKz0gcHVzaFJhdyh0ZW1wbGF0ZSwgdGVtcGxhdGUubGVuZ3RoLCBzdGF0ZSk7XG5cbiAgICAgIC8qIENoZWNrIHRoZSBmaW5hbCBzdGF0ZS4gKi9cbiAgICAgIGlmIChzdGF0ZS5jb21tYW5kU3RhY2subGVuZ3RoID4gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nICNlbmQuXCIpOyB9XG5cbiAgICAgIC8qIFNhbml0aXplIHRoZSBsaXN0IG9mIHZhcmlhYmxlcyB1c2VkIGJ5IGNvbW1hbmRzLiAqL1xuICAgICAgdmFycy5zb3J0KCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodmFyc1tpXSA9PT0gdmFyc1tpIC0gMV0pIHsgdmFycy5zcGxpY2UoaS0tLCAxKTsgfVxuICAgICAgfVxuXG4gICAgICAvKiBDcmVhdGUgdGhlIHJlc3VsdGluZyBmdW5jdGlvbi4gKi9cbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJfX3ZcIiwgW1xuICAgICAgICAnX192PV9fdnx8e307JyxcbiAgICAgICAgJ3ZhciAnICsgdmFycy5qb2luKCcsJykgKyAnOycsXG4gICAgICAgICd3aXRoKF9fdil7JyxcbiAgICAgICAgY29kZSxcbiAgICAgICAgJ3JldHVybiBfX3Auam9pbihcIlwiKS5yZXBsYWNlKC9eXFxcXG4rfFxcXFxuKyQvZyxcIlwiKTt9OydcbiAgICAgIF0uam9pbignJykpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQ29kaWU7XG5cbiAgfSkoKTtcblxuICB2YXIgdGVtcGxhdGVzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBuYW1lLFxuICAgICAgICB0ZW1wbGF0ZXMgPSB7fSxcbiAgICAgICAgc291cmNlcyA9IHtcbiAgICAgICAgICBncmFtbWFyOiBbXG4gICAgICAgICAgICAnKGZ1bmN0aW9uKCl7JyxcbiAgICAgICAgICAgICcgIC8qJyxcbiAgICAgICAgICAgICcgICAqIEdlbmVyYXRlZCBieSBQRUcuanMgMC43LjAuJyxcbiAgICAgICAgICAgICcgICAqJyxcbiAgICAgICAgICAgICcgICAqIGh0dHA6Ly9wZWdqcy5tYWpkYS5jei8nLFxuICAgICAgICAgICAgJyAgICovJyxcbiAgICAgICAgICAgICcgICcsXG4gICAgICAgICAgICAvKiBUaGlzIG5lZWRzIHRvIGJlIGluIHN5bmMgd2l0aCB8cXVvdGV8IGluIHV0aWxzLmpzLiAqL1xuICAgICAgICAgICAgJyAgZnVuY3Rpb24gcXVvdGUocykgeycsXG4gICAgICAgICAgICAnICAgIC8qJyxcbiAgICAgICAgICAgICcgICAgICogRUNNQS0yNjIsIDV0aCBlZC4sIDcuOC40OiBBbGwgY2hhcmFjdGVycyBtYXkgYXBwZWFyIGxpdGVyYWxseSBpbiBhJyxcbiAgICAgICAgICAgICcgICAgICogc3RyaW5nIGxpdGVyYWwgZXhjZXB0IGZvciB0aGUgY2xvc2luZyBxdW90ZSBjaGFyYWN0ZXIsIGJhY2tzbGFzaCwnLFxuICAgICAgICAgICAgJyAgICAgKiBjYXJyaWFnZSByZXR1cm4sIGxpbmUgc2VwYXJhdG9yLCBwYXJhZ3JhcGggc2VwYXJhdG9yLCBhbmQgbGluZSBmZWVkLicsXG4gICAgICAgICAgICAnICAgICAqIEFueSBjaGFyYWN0ZXIgbWF5IGFwcGVhciBpbiB0aGUgZm9ybSBvZiBhbiBlc2NhcGUgc2VxdWVuY2UuJyxcbiAgICAgICAgICAgICcgICAgIConLFxuICAgICAgICAgICAgJyAgICAgKiBGb3IgcG9ydGFiaWxpdHksIHdlIGFsc28gZXNjYXBlIGVzY2FwZSBhbGwgY29udHJvbCBhbmQgbm9uLUFTQ0lJJyxcbiAgICAgICAgICAgICcgICAgICogY2hhcmFjdGVycy4gTm90ZSB0aGF0IFwiXFxcXDBcIiBhbmQgXCJcXFxcdlwiIGVzY2FwZSBzZXF1ZW5jZXMgYXJlIG5vdCB1c2VkJyxcbiAgICAgICAgICAgICcgICAgICogYmVjYXVzZSBKU0hpbnQgZG9lcyBub3QgbGlrZSB0aGUgZmlyc3QgYW5kIElFIHRoZSBzZWNvbmQuJyxcbiAgICAgICAgICAgICcgICAgICovJyxcbiAgICAgICAgICAgICcgICAgIHJldHVybiBcXCdcIlxcJyArIHMnLFxuICAgICAgICAgICAgJyAgICAgIC5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcXCdcXFxcXFxcXFxcXFxcXFxcXFwnKSAgLy8gYmFja3NsYXNoJyxcbiAgICAgICAgICAgICcgICAgICAucmVwbGFjZSgvXCIvZywgXFwnXFxcXFxcXFxcIlxcJykgICAgLy8gY2xvc2luZyBxdW90ZSBjaGFyYWN0ZXInLFxuICAgICAgICAgICAgJyAgICAgIC5yZXBsYWNlKC9cXFxceDA4L2csIFxcJ1xcXFxcXFxcYlxcJykgLy8gYmFja3NwYWNlJyxcbiAgICAgICAgICAgICcgICAgICAucmVwbGFjZSgvXFxcXHQvZywgXFwnXFxcXFxcXFx0XFwnKSAgIC8vIGhvcml6b250YWwgdGFiJyxcbiAgICAgICAgICAgICcgICAgICAucmVwbGFjZSgvXFxcXG4vZywgXFwnXFxcXFxcXFxuXFwnKSAgIC8vIGxpbmUgZmVlZCcsXG4gICAgICAgICAgICAnICAgICAgLnJlcGxhY2UoL1xcXFxmL2csIFxcJ1xcXFxcXFxcZlxcJykgICAvLyBmb3JtIGZlZWQnLFxuICAgICAgICAgICAgJyAgICAgIC5yZXBsYWNlKC9cXFxcci9nLCBcXCdcXFxcXFxcXHJcXCcpICAgLy8gY2FycmlhZ2UgcmV0dXJuJyxcbiAgICAgICAgICAgICcgICAgICAucmVwbGFjZSgvW1xcXFx4MDAtXFxcXHgwN1xcXFx4MEJcXFxceDBFLVxcXFx4MUZcXFxceDgwLVxcXFx1RkZGRl0vZywgZXNjYXBlKScsXG4gICAgICAgICAgICAnICAgICAgKyBcXCdcIlxcJzsnLFxuICAgICAgICAgICAgJyAgfScsXG4gICAgICAgICAgICAnICAnLFxuICAgICAgICAgICAgJyAgdmFyIHJlc3VsdCA9IHsnLFxuICAgICAgICAgICAgJyAgICAvKicsXG4gICAgICAgICAgICAnICAgICAqIFBhcnNlcyB0aGUgaW5wdXQgd2l0aCBhIGdlbmVyYXRlZCBwYXJzZXIuIElmIHRoZSBwYXJzaW5nIGlzIHN1Y2Nlc3NmdWxsLCcsXG4gICAgICAgICAgICAnICAgICAqIHJldHVybnMgYSB2YWx1ZSBleHBsaWNpdGx5IG9yIGltcGxpY2l0bHkgc3BlY2lmaWVkIGJ5IHRoZSBncmFtbWFyIGZyb20nLFxuICAgICAgICAgICAgJyAgICAgKiB3aGljaCB0aGUgcGFyc2VyIHdhcyBnZW5lcmF0ZWQgKHNlZSB8UEVHLmJ1aWxkUGFyc2VyfCkuIElmIHRoZSBwYXJzaW5nIGlzJyxcbiAgICAgICAgICAgICcgICAgICogdW5zdWNjZXNzZnVsLCB0aHJvd3MgfFBFRy5wYXJzZXIuU3ludGF4RXJyb3J8IGRlc2NyaWJpbmcgdGhlIGVycm9yLicsXG4gICAgICAgICAgICAnICAgICAqLycsXG4gICAgICAgICAgICAnICAgIHBhcnNlOiBmdW5jdGlvbihpbnB1dCwgc3RhcnRSdWxlKSB7JyxcbiAgICAgICAgICAgICcgICAgICB2YXIgcGFyc2VGdW5jdGlvbnMgPSB7JyxcbiAgICAgICAgICAgICcgICAgICAgICNmb3IgcnVsZSBpbiBub2RlLnJ1bGVzJyxcbiAgICAgICAgICAgICcgICAgICAgICAgI3tzdHJpbmcocnVsZS5uYW1lKSArIFwiOiBwYXJzZV9cIiArIHJ1bGUubmFtZSArIChydWxlICE9PSBub2RlLnJ1bGVzW25vZGUucnVsZXMubGVuZ3RoIC0gMV0gPyBcIixcIiA6IFwiXCIpfScsXG4gICAgICAgICAgICAnICAgICAgICAjZW5kJyxcbiAgICAgICAgICAgICcgICAgICB9OycsXG4gICAgICAgICAgICAnICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICBpZiAoc3RhcnRSdWxlICE9PSB1bmRlZmluZWQpIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgaWYgKHBhcnNlRnVuY3Rpb25zW3N0YXJ0UnVsZV0gPT09IHVuZGVmaW5lZCkgeycsXG4gICAgICAgICAgICAnICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcnVsZSBuYW1lOiBcIiArIHF1b3RlKHN0YXJ0UnVsZSkgKyBcIi5cIik7JyxcbiAgICAgICAgICAgICcgICAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgIH0gZWxzZSB7JyxcbiAgICAgICAgICAgICcgICAgICAgIHN0YXJ0UnVsZSA9ICN7c3RyaW5nKG5vZGUuc3RhcnRSdWxlKX07JyxcbiAgICAgICAgICAgICcgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgICN7cG9zSW5pdChcInBvc1wiKX07JyxcbiAgICAgICAgICAgICcgICAgICB2YXIgcmVwb3J0RmFpbHVyZXMgPSAwOycsIC8vIDAgPSByZXBvcnQsIGFueXRoaW5nID4gMCA9IGRvIG5vdCByZXBvcnRcbiAgICAgICAgICAgICcgICAgICAje3Bvc0luaXQoXCJyaWdodG1vc3RGYWlsdXJlc1Bvc1wiKX07JyxcbiAgICAgICAgICAgICcgICAgICB2YXIgcmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZCA9IFtdOycsXG4gICAgICAgICAgICAnICAgICAgI2lmIG9wdGlvbnMuY2FjaGUnLFxuICAgICAgICAgICAgJyAgICAgICAgdmFyIGNhY2hlID0ge307JyxcbiAgICAgICAgICAgICcgICAgICAjZW5kJyxcbiAgICAgICAgICAgICcgICAgICAnLFxuICAgICAgICAgICAgLyogVGhpcyBuZWVkcyB0byBiZSBpbiBzeW5jIHdpdGggfHBhZExlZnR8IGluIHV0aWxzLmpzLiAqL1xuICAgICAgICAgICAgJyAgICAgIGZ1bmN0aW9uIHBhZExlZnQoaW5wdXQsIHBhZGRpbmcsIGxlbmd0aCkgeycsXG4gICAgICAgICAgICAnICAgICAgICB2YXIgcmVzdWx0ID0gaW5wdXQ7JyxcbiAgICAgICAgICAgICcgICAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgICB2YXIgcGFkTGVuZ3RoID0gbGVuZ3RoIC0gaW5wdXQubGVuZ3RoOycsXG4gICAgICAgICAgICAnICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZExlbmd0aDsgaSsrKSB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgcmVzdWx0ID0gcGFkZGluZyArIHJlc3VsdDsnLFxuICAgICAgICAgICAgJyAgICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgICAgcmV0dXJuIHJlc3VsdDsnLFxuICAgICAgICAgICAgJyAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgICcsXG4gICAgICAgICAgICAvKiBUaGlzIG5lZWRzIHRvIGJlIGluIHN5bmMgd2l0aCB8ZXNjYXBlfCBpbiB1dGlscy5qcy4gKi9cbiAgICAgICAgICAgICcgICAgICBmdW5jdGlvbiBlc2NhcGUoY2gpIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgdmFyIGNoYXJDb2RlID0gY2guY2hhckNvZGVBdCgwKTsnLFxuICAgICAgICAgICAgJyAgICAgICAgdmFyIGVzY2FwZUNoYXI7JyxcbiAgICAgICAgICAgICcgICAgICAgIHZhciBsZW5ndGg7JyxcbiAgICAgICAgICAgICcgICAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgICBpZiAoY2hhckNvZGUgPD0gMHhGRikgeycsXG4gICAgICAgICAgICAnICAgICAgICAgIGVzY2FwZUNoYXIgPSBcXCd4XFwnOycsXG4gICAgICAgICAgICAnICAgICAgICAgIGxlbmd0aCA9IDI7JyxcbiAgICAgICAgICAgICcgICAgICAgIH0gZWxzZSB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgZXNjYXBlQ2hhciA9IFxcJ3VcXCc7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgbGVuZ3RoID0gNDsnLFxuICAgICAgICAgICAgJyAgICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgICAgcmV0dXJuIFxcJ1xcXFxcXFxcXFwnICsgZXNjYXBlQ2hhciArIHBhZExlZnQoY2hhckNvZGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCksIFxcJzBcXCcsIGxlbmd0aCk7JyxcbiAgICAgICAgICAgICcgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgICNpZiBvcHRpb25zLnRyYWNrTGluZUFuZENvbHVtbicsXG4gICAgICAgICAgICAnICAgICAgICBmdW5jdGlvbiBjbG9uZShvYmplY3QpIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgICB2YXIgcmVzdWx0ID0ge307JyxcbiAgICAgICAgICAgICcgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkgeycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTsnLFxuICAgICAgICAgICAgJyAgICAgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICAgICAgcmV0dXJuIHJlc3VsdDsnLFxuICAgICAgICAgICAgJyAgICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgICAgZnVuY3Rpb24gYWR2YW5jZShwb3MsIG4pIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gcG9zLm9mZnNldCArIG47JyxcbiAgICAgICAgICAgICcgICAgICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gcG9zLm9mZnNldDsgb2Zmc2V0IDwgZW5kT2Zmc2V0OyBvZmZzZXQrKykgeycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgdmFyIGNoID0gaW5wdXQuY2hhckF0KG9mZnNldCk7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICBpZiAoY2ggPT09IFwiXFxcXG5cIikgeycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgICBpZiAoIXBvcy5zZWVuQ1IpIHsgcG9zLmxpbmUrKzsgfScsXG4gICAgICAgICAgICAnICAgICAgICAgICAgICBwb3MuY29sdW1uID0gMTsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgICAgcG9zLnNlZW5DUiA9IGZhbHNlOycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJcXFxcclwiIHx8IGNoID09PSBcIlxcXFx1MjAyOFwiIHx8IGNoID09PSBcIlxcXFx1MjAyOVwiKSB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICAgIHBvcy5saW5lKys7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICAgIHBvcy5jb2x1bW4gPSAxOycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgICBwb3Muc2VlbkNSID0gdHJ1ZTsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgIH0gZWxzZSB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICAgIHBvcy5jb2x1bW4rKzsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgICAgcG9zLnNlZW5DUiA9IGZhbHNlOycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgICAgICBwb3Mub2Zmc2V0ICs9IG47JyxcbiAgICAgICAgICAgICcgICAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAjZW5kJyxcbiAgICAgICAgICAgICcgICAgICBmdW5jdGlvbiBtYXRjaEZhaWxlZChmYWlsdXJlKSB7JyxcbiAgICAgICAgICAgICcgICAgICAgIGlmICgje3Bvc09mZnNldChcInBvc1wiKX0gPCAje3Bvc09mZnNldChcInJpZ2h0bW9zdEZhaWx1cmVzUG9zXCIpfSkgeycsXG4gICAgICAgICAgICAnICAgICAgICAgIHJldHVybjsnLFxuICAgICAgICAgICAgJyAgICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgICAgaWYgKCN7cG9zT2Zmc2V0KFwicG9zXCIpfSA+ICN7cG9zT2Zmc2V0KFwicmlnaHRtb3N0RmFpbHVyZXNQb3NcIil9KSB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgcmlnaHRtb3N0RmFpbHVyZXNQb3MgPSAje3Bvc0Nsb25lKFwicG9zXCIpfTsnLFxuICAgICAgICAgICAgJyAgICAgICAgICByaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkID0gW107JyxcbiAgICAgICAgICAgICcgICAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAgIHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWQucHVzaChmYWlsdXJlKTsnLFxuICAgICAgICAgICAgJyAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgI2ZvciBydWxlIGluIG5vZGUucnVsZXMnLFxuICAgICAgICAgICAgJyAgICAgICAgI2Jsb2NrIGVtaXQocnVsZSknLFxuICAgICAgICAgICAgJyAgICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAjZW5kJyxcbiAgICAgICAgICAgICcgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgIGZ1bmN0aW9uIGNsZWFudXBFeHBlY3RlZChleHBlY3RlZCkgeycsXG4gICAgICAgICAgICAnICAgICAgICBleHBlY3RlZC5zb3J0KCk7JyxcbiAgICAgICAgICAgICcgICAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgICB2YXIgbGFzdEV4cGVjdGVkID0gbnVsbDsnLFxuICAgICAgICAgICAgJyAgICAgICAgdmFyIGNsZWFuRXhwZWN0ZWQgPSBbXTsnLFxuICAgICAgICAgICAgJyAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZC5sZW5ndGg7IGkrKykgeycsXG4gICAgICAgICAgICAnICAgICAgICAgIGlmIChleHBlY3RlZFtpXSAhPT0gbGFzdEV4cGVjdGVkKSB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICBjbGVhbkV4cGVjdGVkLnB1c2goZXhwZWN0ZWRbaV0pOycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgbGFzdEV4cGVjdGVkID0gZXhwZWN0ZWRbaV07JyxcbiAgICAgICAgICAgICcgICAgICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICAgIHJldHVybiBjbGVhbkV4cGVjdGVkOycsXG4gICAgICAgICAgICAnICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAjaWYgIW9wdGlvbnMudHJhY2tMaW5lQW5kQ29sdW1uJyxcbiAgICAgICAgICAgICcgICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVFcnJvclBvc2l0aW9uKCkgeycsXG4gICAgICAgICAgICAnICAgICAgICAgIC8qJyxcbiAgICAgICAgICAgICcgICAgICAgICAgICogVGhlIGZpcnN0IGlkZWEgd2FzIHRvIHVzZSB8U3RyaW5nLnNwbGl0fCB0byBicmVhayB0aGUgaW5wdXQgdXAgdG8gdGhlJyxcbiAgICAgICAgICAgICcgICAgICAgICAgICogZXJyb3IgcG9zaXRpb24gYWxvbmcgbmV3bGluZXMgYW5kIGRlcml2ZSB0aGUgbGluZSBhbmQgY29sdW1uIGZyb20nLFxuICAgICAgICAgICAgJyAgICAgICAgICAgKiB0aGVyZS4gSG93ZXZlciBJRVxcJ3MgfHNwbGl0fCBpbXBsZW1lbnRhdGlvbiBpcyBzbyBicm9rZW4gdGhhdCBpdCB3YXMnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgKiBlbm91Z2ggdG8gcHJldmVudCBpdC4nLFxuICAgICAgICAgICAgJyAgICAgICAgICAgKi8nLFxuICAgICAgICAgICAgJyAgICAgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgICAgICB2YXIgbGluZSA9IDE7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgdmFyIGNvbHVtbiA9IDE7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgdmFyIHNlZW5DUiA9IGZhbHNlOycsXG4gICAgICAgICAgICAnICAgICAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5tYXgocG9zLCByaWdodG1vc3RGYWlsdXJlc1Bvcyk7IGkrKykgeycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgdmFyIGNoID0gaW5wdXQuY2hhckF0KGkpOycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgaWYgKGNoID09PSBcIlxcXFxuXCIpIHsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgICAgaWYgKCFzZWVuQ1IpIHsgbGluZSsrOyB9JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICAgIGNvbHVtbiA9IDE7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICAgIHNlZW5DUiA9IGZhbHNlOycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJcXFxcclwiIHx8IGNoID09PSBcIlxcXFx1MjAyOFwiIHx8IGNoID09PSBcIlxcXFx1MjAyOVwiKSB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICAgIGxpbmUrKzsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgICAgY29sdW1uID0gMTsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgICAgc2VlbkNSID0gdHJ1ZTsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgIH0gZWxzZSB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICAgIGNvbHVtbisrOycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgICBzZWVuQ1IgPSBmYWxzZTsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAgICAgcmV0dXJuIHsgbGluZTogbGluZSwgY29sdW1uOiBjb2x1bW4gfTsnLFxuICAgICAgICAgICAgJyAgICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgI2VuZCcsXG4gICAgICAgICAgICAnICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAjaWYgbm9kZS5pbml0aWFsaXplcicsXG4gICAgICAgICAgICAnICAgICAgICAjYmxvY2sgZW1pdChub2RlLmluaXRpYWxpemVyKScsXG4gICAgICAgICAgICAnICAgICAgI2VuZCcsXG4gICAgICAgICAgICAnICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VGdW5jdGlvbnNbc3RhcnRSdWxlXSgpOycsXG4gICAgICAgICAgICAnICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICAvKicsXG4gICAgICAgICAgICAnICAgICAgICogVGhlIHBhcnNlciBpcyBub3cgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgdGhyZWUgc3RhdGVzOicsXG4gICAgICAgICAgICAnICAgICAgIConLFxuICAgICAgICAgICAgJyAgICAgICAqIDEuIFRoZSBwYXJzZXIgc3VjY2Vzc2Z1bGx5IHBhcnNlZCB0aGUgd2hvbGUgaW5wdXQuJyxcbiAgICAgICAgICAgICcgICAgICAgKicsXG4gICAgICAgICAgICAnICAgICAgICogICAgLSB8cmVzdWx0ICE9PSBudWxsfCcsXG4gICAgICAgICAgICAnICAgICAgICogICAgLSB8I3twb3NPZmZzZXQoXCJwb3NcIil9ID09PSBpbnB1dC5sZW5ndGh8JyxcbiAgICAgICAgICAgICcgICAgICAgKiAgICAtIHxyaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkfCBtYXkgb3IgbWF5IG5vdCBjb250YWluIHNvbWV0aGluZycsXG4gICAgICAgICAgICAnICAgICAgIConLFxuICAgICAgICAgICAgJyAgICAgICAqIDIuIFRoZSBwYXJzZXIgc3VjY2Vzc2Z1bGx5IHBhcnNlZCBvbmx5IGEgcGFydCBvZiB0aGUgaW5wdXQuJyxcbiAgICAgICAgICAgICcgICAgICAgKicsXG4gICAgICAgICAgICAnICAgICAgICogICAgLSB8cmVzdWx0ICE9PSBudWxsfCcsXG4gICAgICAgICAgICAnICAgICAgICogICAgLSB8I3twb3NPZmZzZXQoXCJwb3NcIil9IDwgaW5wdXQubGVuZ3RofCcsXG4gICAgICAgICAgICAnICAgICAgICogICAgLSB8cmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZHwgbWF5IG9yIG1heSBub3QgY29udGFpbiBzb21ldGhpbmcnLFxuICAgICAgICAgICAgJyAgICAgICAqJyxcbiAgICAgICAgICAgICcgICAgICAgKiAzLiBUaGUgcGFyc2VyIGRpZCBub3Qgc3VjY2Vzc2Z1bGx5IHBhcnNlIGFueSBwYXJ0IG9mIHRoZSBpbnB1dC4nLFxuICAgICAgICAgICAgJyAgICAgICAqJyxcbiAgICAgICAgICAgICcgICAgICAgKiAgIC0gfHJlc3VsdCA9PT0gbnVsbHwnLFxuICAgICAgICAgICAgJyAgICAgICAqICAgLSB8I3twb3NPZmZzZXQoXCJwb3NcIil9ID09PSAwfCcsXG4gICAgICAgICAgICAnICAgICAgICogICAtIHxyaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkfCBjb250YWlucyBhdCBsZWFzdCBvbmUgZmFpbHVyZScsXG4gICAgICAgICAgICAnICAgICAgIConLFxuICAgICAgICAgICAgJyAgICAgICAqIEFsbCBjb2RlIGZvbGxvd2luZyB0aGlzIGNvbW1lbnQgKGluY2x1ZGluZyBjYWxsZWQgZnVuY3Rpb25zKSBtdXN0JyxcbiAgICAgICAgICAgICcgICAgICAgKiBoYW5kbGUgdGhlc2Ugc3RhdGVzLicsXG4gICAgICAgICAgICAnICAgICAgICovJyxcbiAgICAgICAgICAgICcgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8ICN7cG9zT2Zmc2V0KFwicG9zXCIpfSAhPT0gaW5wdXQubGVuZ3RoKSB7JyxcbiAgICAgICAgICAgICcgICAgICAgIHZhciBvZmZzZXQgPSBNYXRoLm1heCgje3Bvc09mZnNldChcInBvc1wiKX0sICN7cG9zT2Zmc2V0KFwicmlnaHRtb3N0RmFpbHVyZXNQb3NcIil9KTsnLFxuICAgICAgICAgICAgJyAgICAgICAgdmFyIGZvdW5kID0gb2Zmc2V0IDwgaW5wdXQubGVuZ3RoID8gaW5wdXQuY2hhckF0KG9mZnNldCkgOiBudWxsOycsXG4gICAgICAgICAgICAnICAgICAgICAjaWYgb3B0aW9ucy50cmFja0xpbmVBbmRDb2x1bW4nLFxuICAgICAgICAgICAgJyAgICAgICAgICB2YXIgZXJyb3JQb3NpdGlvbiA9ICN7cG9zT2Zmc2V0KFwicG9zXCIpfSA+ICN7cG9zT2Zmc2V0KFwicmlnaHRtb3N0RmFpbHVyZXNQb3NcIil9ID8gcG9zIDogcmlnaHRtb3N0RmFpbHVyZXNQb3M7JyxcbiAgICAgICAgICAgICcgICAgICAgICNlbHNlJyxcbiAgICAgICAgICAgICcgICAgICAgICAgdmFyIGVycm9yUG9zaXRpb24gPSBjb21wdXRlRXJyb3JQb3NpdGlvbigpOycsXG4gICAgICAgICAgICAnICAgICAgICAjZW5kJyxcbiAgICAgICAgICAgICcgICAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgICB0aHJvdyBuZXcgdGhpcy5TeW50YXhFcnJvcignLFxuICAgICAgICAgICAgJyAgICAgICAgICBjbGVhbnVwRXhwZWN0ZWQocmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZCksJyxcbiAgICAgICAgICAgICcgICAgICAgICAgZm91bmQsJyxcbiAgICAgICAgICAgICcgICAgICAgICAgb2Zmc2V0LCcsXG4gICAgICAgICAgICAnICAgICAgICAgIGVycm9yUG9zaXRpb24ubGluZSwnLFxuICAgICAgICAgICAgJyAgICAgICAgICBlcnJvclBvc2l0aW9uLmNvbHVtbicsXG4gICAgICAgICAgICAnICAgICAgICApOycsXG4gICAgICAgICAgICAnICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICByZXR1cm4gcmVzdWx0OycsXG4gICAgICAgICAgICAnICAgIH0sJyxcbiAgICAgICAgICAgICcgICAgJyxcbiAgICAgICAgICAgICcgICAgLyogUmV0dXJucyB0aGUgcGFyc2VyIHNvdXJjZSBjb2RlLiAqLycsXG4gICAgICAgICAgICAnICAgIHRvU291cmNlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3NvdXJjZTsgfScsXG4gICAgICAgICAgICAnICB9OycsXG4gICAgICAgICAgICAnICAnLFxuICAgICAgICAgICAgJyAgLyogVGhyb3duIHdoZW4gYSBwYXJzZXIgZW5jb3VudGVycyBhIHN5bnRheCBlcnJvci4gKi8nLFxuICAgICAgICAgICAgJyAgJyxcbiAgICAgICAgICAgICcgIHJlc3VsdC5TeW50YXhFcnJvciA9IGZ1bmN0aW9uKGV4cGVjdGVkLCBmb3VuZCwgb2Zmc2V0LCBsaW5lLCBjb2x1bW4pIHsnLFxuICAgICAgICAgICAgJyAgICBmdW5jdGlvbiBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKSB7JyxcbiAgICAgICAgICAgICcgICAgICB2YXIgZXhwZWN0ZWRIdW1hbml6ZWQsIGZvdW5kSHVtYW5pemVkOycsXG4gICAgICAgICAgICAnICAgICAgJyxcbiAgICAgICAgICAgICcgICAgICBzd2l0Y2ggKGV4cGVjdGVkLmxlbmd0aCkgeycsXG4gICAgICAgICAgICAnICAgICAgICBjYXNlIDA6JyxcbiAgICAgICAgICAgICcgICAgICAgICAgZXhwZWN0ZWRIdW1hbml6ZWQgPSBcImVuZCBvZiBpbnB1dFwiOycsXG4gICAgICAgICAgICAnICAgICAgICAgIGJyZWFrOycsXG4gICAgICAgICAgICAnICAgICAgICBjYXNlIDE6JyxcbiAgICAgICAgICAgICcgICAgICAgICAgZXhwZWN0ZWRIdW1hbml6ZWQgPSBleHBlY3RlZFswXTsnLFxuICAgICAgICAgICAgJyAgICAgICAgICBicmVhazsnLFxuICAgICAgICAgICAgJyAgICAgICAgZGVmYXVsdDonLFxuICAgICAgICAgICAgJyAgICAgICAgICBleHBlY3RlZEh1bWFuaXplZCA9IGV4cGVjdGVkLnNsaWNlKDAsIGV4cGVjdGVkLmxlbmd0aCAtIDEpLmpvaW4oXCIsIFwiKScsXG4gICAgICAgICAgICAnICAgICAgICAgICAgKyBcIiBvciBcIicsXG4gICAgICAgICAgICAnICAgICAgICAgICAgKyBleHBlY3RlZFtleHBlY3RlZC5sZW5ndGggLSAxXTsnLFxuICAgICAgICAgICAgJyAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgICcsXG4gICAgICAgICAgICAnICAgICAgZm91bmRIdW1hbml6ZWQgPSBmb3VuZCA/IHF1b3RlKGZvdW5kKSA6IFwiZW5kIG9mIGlucHV0XCI7JyxcbiAgICAgICAgICAgICcgICAgICAnLFxuICAgICAgICAgICAgJyAgICAgIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZXhwZWN0ZWRIdW1hbml6ZWQgKyBcIiBidXQgXCIgKyBmb3VuZEh1bWFuaXplZCArIFwiIGZvdW5kLlwiOycsXG4gICAgICAgICAgICAnICAgIH0nLFxuICAgICAgICAgICAgJyAgICAnLFxuICAgICAgICAgICAgJyAgICB0aGlzLm5hbWUgPSBcIlN5bnRheEVycm9yXCI7JyxcbiAgICAgICAgICAgICcgICAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkOycsXG4gICAgICAgICAgICAnICAgIHRoaXMuZm91bmQgPSBmb3VuZDsnLFxuICAgICAgICAgICAgJyAgICB0aGlzLm1lc3NhZ2UgPSBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKTsnLFxuICAgICAgICAgICAgJyAgICB0aGlzLm9mZnNldCA9IG9mZnNldDsnLFxuICAgICAgICAgICAgJyAgICB0aGlzLmxpbmUgPSBsaW5lOycsXG4gICAgICAgICAgICAnICAgIHRoaXMuY29sdW1uID0gY29sdW1uOycsXG4gICAgICAgICAgICAnICB9OycsXG4gICAgICAgICAgICAnICAnLFxuICAgICAgICAgICAgJyAgcmVzdWx0LlN5bnRheEVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTsnLFxuICAgICAgICAgICAgJyAgJyxcbiAgICAgICAgICAgICcgIHJldHVybiByZXN1bHQ7JyxcbiAgICAgICAgICAgICd9KSgpJ1xuICAgICAgICAgIF0sXG4gICAgICAgICAgcnVsZTogW1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIHBhcnNlXyN7bm9kZS5uYW1lfSgpIHsnLFxuICAgICAgICAgICAgJyAgI2lmIG9wdGlvbnMuY2FjaGUnLFxuICAgICAgICAgICAgJyAgICB2YXIgY2FjaGVLZXkgPSBcIiN7bm9kZS5uYW1lfUBcIiArICN7cG9zT2Zmc2V0KFwicG9zXCIpfTsnLFxuICAgICAgICAgICAgJyAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldOycsXG4gICAgICAgICAgICAnICAgIGlmIChjYWNoZWRSZXN1bHQpIHsnLFxuICAgICAgICAgICAgJyAgICAgIHBvcyA9ICN7cG9zQ2xvbmUoXCJjYWNoZWRSZXN1bHQubmV4dFBvc1wiKX07JyxcbiAgICAgICAgICAgICcgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDsnLFxuICAgICAgICAgICAgJyAgICB9JyxcbiAgICAgICAgICAgICcgICAgJyxcbiAgICAgICAgICAgICcgICNlbmQnLFxuICAgICAgICAgICAgJyAgI2lmIG5vZGUucmVzdWx0VmFycy5sZW5ndGggPiAwJyxcbiAgICAgICAgICAgICcgICAgdmFyICN7bm9kZS5yZXN1bHRWYXJzLmpvaW4oXCIsIFwiKX07JyxcbiAgICAgICAgICAgICcgICNlbmQnLFxuICAgICAgICAgICAgJyAgI2lmIG5vZGUucG9zVmFycy5sZW5ndGggPiAwJyxcbiAgICAgICAgICAgICcgICAgdmFyICN7bm9kZS5wb3NWYXJzLmpvaW4oXCIsIFwiKX07JyxcbiAgICAgICAgICAgICcgICNlbmQnLFxuICAgICAgICAgICAgJyAgJyxcbiAgICAgICAgICAgICcgICNpZiBub2RlLmRpc3BsYXlOYW1lICE9PSBudWxsJyxcbiAgICAgICAgICAgICcgICAgcmVwb3J0RmFpbHVyZXMrKzsnLFxuICAgICAgICAgICAgJyAgI2VuZCcsXG4gICAgICAgICAgICAnICAjYmxvY2sgZW1pdChub2RlLmV4cHJlc3Npb24pJyxcbiAgICAgICAgICAgICcgICNpZiBub2RlLmRpc3BsYXlOYW1lICE9PSBudWxsJyxcbiAgICAgICAgICAgICcgICAgcmVwb3J0RmFpbHVyZXMtLTsnLFxuICAgICAgICAgICAgJyAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDAgJiYgI3tub2RlLnJlc3VsdFZhcn0gPT09IG51bGwpIHsnLFxuICAgICAgICAgICAgJyAgICAgIG1hdGNoRmFpbGVkKCN7c3RyaW5nKG5vZGUuZGlzcGxheU5hbWUpfSk7JyxcbiAgICAgICAgICAgICcgICAgfScsXG4gICAgICAgICAgICAnICAjZW5kJyxcbiAgICAgICAgICAgICcgICNpZiBvcHRpb25zLmNhY2hlJyxcbiAgICAgICAgICAgICcgICAgJyxcbiAgICAgICAgICAgICcgICAgY2FjaGVbY2FjaGVLZXldID0geycsXG4gICAgICAgICAgICAnICAgICAgbmV4dFBvczogI3twb3NDbG9uZShcInBvc1wiKX0sJyxcbiAgICAgICAgICAgICcgICAgICByZXN1bHQ6ICAje25vZGUucmVzdWx0VmFyfScsXG4gICAgICAgICAgICAnICAgIH07JyxcbiAgICAgICAgICAgICcgICNlbmQnLFxuICAgICAgICAgICAgJyAgcmV0dXJuICN7bm9kZS5yZXN1bHRWYXJ9OycsXG4gICAgICAgICAgICAnfSdcbiAgICAgICAgICBdLFxuICAgICAgICAgIGNob2ljZTogW1xuICAgICAgICAgICAgJyNibG9jayBlbWl0KGFsdGVybmF0aXZlKScsXG4gICAgICAgICAgICAnI2Jsb2NrIG5leHRBbHRlcm5hdGl2ZXNDb2RlJ1xuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJjaG9pY2UubmV4dFwiOiBbXG4gICAgICAgICAgICAnaWYgKCN7bm9kZS5yZXN1bHRWYXJ9ID09PSBudWxsKSB7JyxcbiAgICAgICAgICAgICcgICNibG9jayBjb2RlJyxcbiAgICAgICAgICAgICd9J1xuICAgICAgICAgIF0sXG4gICAgICAgICAgc2VxdWVuY2U6IFtcbiAgICAgICAgICAgICcje3Bvc1NhdmUobm9kZSl9OycsXG4gICAgICAgICAgICAnI2Jsb2NrIGNvZGUnXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcInNlcXVlbmNlLml0ZXJhdGlvblwiOiBbXG4gICAgICAgICAgICAnI2Jsb2NrIGVtaXQoZWxlbWVudCknLFxuICAgICAgICAgICAgJ2lmICgje2VsZW1lbnQucmVzdWx0VmFyfSAhPT0gbnVsbCkgeycsXG4gICAgICAgICAgICAnICAjYmxvY2sgY29kZScsXG4gICAgICAgICAgICAnfSBlbHNlIHsnLFxuICAgICAgICAgICAgJyAgI3tub2RlLnJlc3VsdFZhcn0gPSBudWxsOycsXG4gICAgICAgICAgICAnICAje3Bvc1Jlc3RvcmUobm9kZSl9OycsXG4gICAgICAgICAgICAnfSdcbiAgICAgICAgICBdLFxuICAgICAgICAgIFwic2VxdWVuY2UuaW5uZXJcIjogW1xuICAgICAgICAgICAgJyN7bm9kZS5yZXN1bHRWYXJ9ID0gWyN7cGx1Y2sobm9kZS5lbGVtZW50cywgXCJyZXN1bHRWYXJcIikuam9pbihcIiwgXCIpfV07J1xuICAgICAgICAgIF0sXG4gICAgICAgICAgc2ltcGxlX2FuZDogW1xuICAgICAgICAgICAgJyN7cG9zU2F2ZShub2RlKX07JyxcbiAgICAgICAgICAgICdyZXBvcnRGYWlsdXJlcysrOycsXG4gICAgICAgICAgICAnI2Jsb2NrIGVtaXQobm9kZS5leHByZXNzaW9uKScsXG4gICAgICAgICAgICAncmVwb3J0RmFpbHVyZXMtLTsnLFxuICAgICAgICAgICAgJ2lmICgje25vZGUucmVzdWx0VmFyfSAhPT0gbnVsbCkgeycsXG4gICAgICAgICAgICAnICAje25vZGUucmVzdWx0VmFyfSA9IFwiXCI7JyxcbiAgICAgICAgICAgICcgICN7cG9zUmVzdG9yZShub2RlKX07JyxcbiAgICAgICAgICAgICd9IGVsc2UgeycsXG4gICAgICAgICAgICAnICAje25vZGUucmVzdWx0VmFyfSA9IG51bGw7JyxcbiAgICAgICAgICAgICd9J1xuICAgICAgICAgIF0sXG4gICAgICAgICAgc2ltcGxlX25vdDogW1xuICAgICAgICAgICAgJyN7cG9zU2F2ZShub2RlKX07JyxcbiAgICAgICAgICAgICdyZXBvcnRGYWlsdXJlcysrOycsXG4gICAgICAgICAgICAnI2Jsb2NrIGVtaXQobm9kZS5leHByZXNzaW9uKScsXG4gICAgICAgICAgICAncmVwb3J0RmFpbHVyZXMtLTsnLFxuICAgICAgICAgICAgJ2lmICgje25vZGUucmVzdWx0VmFyfSA9PT0gbnVsbCkgeycsXG4gICAgICAgICAgICAnICAje25vZGUucmVzdWx0VmFyfSA9IFwiXCI7JyxcbiAgICAgICAgICAgICd9IGVsc2UgeycsXG4gICAgICAgICAgICAnICAje25vZGUucmVzdWx0VmFyfSA9IG51bGw7JyxcbiAgICAgICAgICAgICcgICN7cG9zUmVzdG9yZShub2RlKX07JyxcbiAgICAgICAgICAgICd9J1xuICAgICAgICAgIF0sXG4gICAgICAgICAgc2VtYW50aWNfYW5kOiBbXG4gICAgICAgICAgICAnI3tub2RlLnJlc3VsdFZhcn0gPSAoZnVuY3Rpb24oI3sob3B0aW9ucy50cmFja0xpbmVBbmRDb2x1bW4gPyBbXCJvZmZzZXRcIiwgXCJsaW5lXCIsIFwiY29sdW1uXCJdIDogW1wib2Zmc2V0XCJdKS5jb25jYXQoa2V5cyhub2RlLnBhcmFtcykpLmpvaW4oXCIsIFwiKX0pIHsje25vZGUuY29kZX19KSgjeyhvcHRpb25zLnRyYWNrTGluZUFuZENvbHVtbiA/IFtcInBvcy5vZmZzZXRcIiwgXCJwb3MubGluZVwiLCBcInBvcy5jb2x1bW5cIl0gOiBbXCJwb3NcIl0pLmNvbmNhdCh2YWx1ZXMobm9kZS5wYXJhbXMpKS5qb2luKFwiLCBcIil9KSA/IFwiXCIgOiBudWxsOydcbiAgICAgICAgICBdLFxuICAgICAgICAgIHNlbWFudGljX25vdDogW1xuICAgICAgICAgICAgJyN7bm9kZS5yZXN1bHRWYXJ9ID0gKGZ1bmN0aW9uKCN7KG9wdGlvbnMudHJhY2tMaW5lQW5kQ29sdW1uID8gW1wib2Zmc2V0XCIsIFwibGluZVwiLCBcImNvbHVtblwiXSA6IFtcIm9mZnNldFwiXSkuY29uY2F0KGtleXMobm9kZS5wYXJhbXMpKS5qb2luKFwiLCBcIil9KSB7I3tub2RlLmNvZGV9fSkoI3sob3B0aW9ucy50cmFja0xpbmVBbmRDb2x1bW4gPyBbXCJwb3Mub2Zmc2V0XCIsIFwicG9zLmxpbmVcIiwgXCJwb3MuY29sdW1uXCJdIDogW1wicG9zXCJdKS5jb25jYXQodmFsdWVzKG5vZGUucGFyYW1zKSkuam9pbihcIiwgXCIpfSkgPyBudWxsIDogXCJcIjsnXG4gICAgICAgICAgXSxcbiAgICAgICAgICBvcHRpb25hbDogW1xuICAgICAgICAgICAgJyNibG9jayBlbWl0KG5vZGUuZXhwcmVzc2lvbiknLFxuICAgICAgICAgICAgJyN7bm9kZS5yZXN1bHRWYXJ9ID0gI3tub2RlLnJlc3VsdFZhcn0gIT09IG51bGwgPyAje25vZGUucmVzdWx0VmFyfSA6IFwiXCI7J1xuICAgICAgICAgIF0sXG4gICAgICAgICAgemVyb19vcl9tb3JlOiBbXG4gICAgICAgICAgICAnI3tub2RlLnJlc3VsdFZhcn0gPSBbXTsnLFxuICAgICAgICAgICAgJyNibG9jayBlbWl0KG5vZGUuZXhwcmVzc2lvbiknLFxuICAgICAgICAgICAgJ3doaWxlICgje25vZGUuZXhwcmVzc2lvbi5yZXN1bHRWYXJ9ICE9PSBudWxsKSB7JyxcbiAgICAgICAgICAgICcgICN7bm9kZS5yZXN1bHRWYXJ9LnB1c2goI3tub2RlLmV4cHJlc3Npb24ucmVzdWx0VmFyfSk7JyxcbiAgICAgICAgICAgICcgICNibG9jayBlbWl0KG5vZGUuZXhwcmVzc2lvbiknLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgICAgXSxcbiAgICAgICAgICBvbmVfb3JfbW9yZTogW1xuICAgICAgICAgICAgJyNibG9jayBlbWl0KG5vZGUuZXhwcmVzc2lvbiknLFxuICAgICAgICAgICAgJ2lmICgje25vZGUuZXhwcmVzc2lvbi5yZXN1bHRWYXJ9ICE9PSBudWxsKSB7JyxcbiAgICAgICAgICAgICcgICN7bm9kZS5yZXN1bHRWYXJ9ID0gW107JyxcbiAgICAgICAgICAgICcgIHdoaWxlICgje25vZGUuZXhwcmVzc2lvbi5yZXN1bHRWYXJ9ICE9PSBudWxsKSB7JyxcbiAgICAgICAgICAgICcgICAgI3tub2RlLnJlc3VsdFZhcn0ucHVzaCgje25vZGUuZXhwcmVzc2lvbi5yZXN1bHRWYXJ9KTsnLFxuICAgICAgICAgICAgJyAgICAjYmxvY2sgZW1pdChub2RlLmV4cHJlc3Npb24pJyxcbiAgICAgICAgICAgICcgIH0nLFxuICAgICAgICAgICAgJ30gZWxzZSB7JyxcbiAgICAgICAgICAgICcgICN7bm9kZS5yZXN1bHRWYXJ9ID0gbnVsbDsnLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgICAgXSxcbiAgICAgICAgICBhY3Rpb246IFtcbiAgICAgICAgICAgICcje3Bvc1NhdmUobm9kZSl9OycsXG4gICAgICAgICAgICAnI2Jsb2NrIGVtaXQobm9kZS5leHByZXNzaW9uKScsXG4gICAgICAgICAgICAnaWYgKCN7bm9kZS5yZXN1bHRWYXJ9ICE9PSBudWxsKSB7JyxcbiAgICAgICAgICAgICcgICN7bm9kZS5yZXN1bHRWYXJ9ID0gKGZ1bmN0aW9uKCN7KG9wdGlvbnMudHJhY2tMaW5lQW5kQ29sdW1uID8gW1wib2Zmc2V0XCIsIFwibGluZVwiLCBcImNvbHVtblwiXSA6IFtcIm9mZnNldFwiXSkuY29uY2F0KGtleXMobm9kZS5wYXJhbXMpKS5qb2luKFwiLCBcIil9KSB7I3tub2RlLmNvZGV9fSkoI3sob3B0aW9ucy50cmFja0xpbmVBbmRDb2x1bW4gPyBbbm9kZS5wb3NWYXIgKyBcIi5vZmZzZXRcIiwgbm9kZS5wb3NWYXIgKyBcIi5saW5lXCIsIG5vZGUucG9zVmFyICsgXCIuY29sdW1uXCJdIDogW25vZGUucG9zVmFyXSkuY29uY2F0KHZhbHVlcyhub2RlLnBhcmFtcykpLmpvaW4oXCIsIFwiKX0pOycsXG4gICAgICAgICAgICAnfScsXG4gICAgICAgICAgICAnaWYgKCN7bm9kZS5yZXN1bHRWYXJ9ID09PSBudWxsKSB7JyxcbiAgICAgICAgICAgICcgICN7cG9zUmVzdG9yZShub2RlKX07JyxcbiAgICAgICAgICAgICd9J1xuICAgICAgICAgIF0sXG4gICAgICAgICAgcnVsZV9yZWY6IFtcbiAgICAgICAgICAgICcje25vZGUucmVzdWx0VmFyfSA9IHBhcnNlXyN7bm9kZS5uYW1lfSgpOydcbiAgICAgICAgICBdLFxuICAgICAgICAgIGxpdGVyYWw6IFtcbiAgICAgICAgICAgICcjaWYgbm9kZS52YWx1ZS5sZW5ndGggPT09IDAnLFxuICAgICAgICAgICAgJyAgI3tub2RlLnJlc3VsdFZhcn0gPSBcIlwiOycsXG4gICAgICAgICAgICAnI2Vsc2UnLFxuICAgICAgICAgICAgJyAgI2lmICFub2RlLmlnbm9yZUNhc2UnLFxuICAgICAgICAgICAgJyAgICAjaWYgbm9kZS52YWx1ZS5sZW5ndGggPT09IDEnLFxuICAgICAgICAgICAgJyAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KCN7cG9zT2Zmc2V0KFwicG9zXCIpfSkgPT09ICN7bm9kZS52YWx1ZS5jaGFyQ29kZUF0KDApfSkgeycsXG4gICAgICAgICAgICAnICAgICNlbHNlJyxcbiAgICAgICAgICAgICcgICAgICBpZiAoaW5wdXQuc3Vic3RyKCN7cG9zT2Zmc2V0KFwicG9zXCIpfSwgI3tub2RlLnZhbHVlLmxlbmd0aH0pID09PSAje3N0cmluZyhub2RlLnZhbHVlKX0pIHsnLFxuICAgICAgICAgICAgJyAgICAjZW5kJyxcbiAgICAgICAgICAgICcgICNlbHNlJyxcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBPbmUtY2hhciBsaXRlcmFscyBhcmUgbm90IG9wdGltaXplZCB3aGVuIGNhc2UtaW5zZW5zaXRpdmVcbiAgICAgICAgICAgICAqIG1hdGNoaW5nIGlzIGVuYWJsZWQuIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBzaW1wbGUgd2F5IHRvXG4gICAgICAgICAgICAgKiBsb3dlcmNhc2UgYSBjaGFyYWN0ZXIgY29kZSB0aGF0IHdvcmtzIGZvciBjaGFyYWN0ZXIgb3V0c2lkZSBBU0NJSVxuICAgICAgICAgICAgICogbGV0dGVycy4gTW9yZW92ZXIsIHx0b0xvd2VyQ2FzZXwgY2FuIGNoYW5nZSBzdHJpbmcgbGVuZ3RoLFxuICAgICAgICAgICAgICogbWVhbmluZyB0aGUgcmVzdWx0IG9mIGxvd2VyY2FzaW5nIGEgY2hhcmFjdGVyIGNhbiBiZSBtb3JlXG4gICAgICAgICAgICAgKiBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnICAgIGlmIChpbnB1dC5zdWJzdHIoI3twb3NPZmZzZXQoXCJwb3NcIil9LCAje25vZGUudmFsdWUubGVuZ3RofSkudG9Mb3dlckNhc2UoKSA9PT0gI3tzdHJpbmcobm9kZS52YWx1ZS50b0xvd2VyQ2FzZSgpKX0pIHsnLFxuICAgICAgICAgICAgJyAgI2VuZCcsXG4gICAgICAgICAgICAnICAgICNpZiAhbm9kZS5pZ25vcmVDYXNlJyxcbiAgICAgICAgICAgICcgICAgICAje25vZGUucmVzdWx0VmFyfSA9ICN7c3RyaW5nKG5vZGUudmFsdWUpfTsnLFxuICAgICAgICAgICAgJyAgICAjZWxzZScsXG4gICAgICAgICAgICAnICAgICAgI3tub2RlLnJlc3VsdFZhcn0gPSBpbnB1dC5zdWJzdHIoI3twb3NPZmZzZXQoXCJwb3NcIil9LCAje25vZGUudmFsdWUubGVuZ3RofSk7JyxcbiAgICAgICAgICAgICcgICAgI2VuZCcsXG4gICAgICAgICAgICAnICAgICN7cG9zQWR2YW5jZShub2RlLnZhbHVlLmxlbmd0aCl9OycsXG4gICAgICAgICAgICAnICB9IGVsc2UgeycsXG4gICAgICAgICAgICAnICAgICN7bm9kZS5yZXN1bHRWYXJ9ID0gbnVsbDsnLFxuICAgICAgICAgICAgJyAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHsnLFxuICAgICAgICAgICAgJyAgICAgIG1hdGNoRmFpbGVkKCN7c3RyaW5nKHN0cmluZyhub2RlLnZhbHVlKSl9KTsnLFxuICAgICAgICAgICAgJyAgICB9JyxcbiAgICAgICAgICAgICcgIH0nLFxuICAgICAgICAgICAgJyNlbmQnXG4gICAgICAgICAgXSxcbiAgICAgICAgICBhbnk6IFtcbiAgICAgICAgICAgICdpZiAoaW5wdXQubGVuZ3RoID4gI3twb3NPZmZzZXQoXCJwb3NcIil9KSB7JyxcbiAgICAgICAgICAgICcgICN7bm9kZS5yZXN1bHRWYXJ9ID0gaW5wdXQuY2hhckF0KCN7cG9zT2Zmc2V0KFwicG9zXCIpfSk7JyxcbiAgICAgICAgICAgICcgICN7cG9zQWR2YW5jZSgxKX07JyxcbiAgICAgICAgICAgICd9IGVsc2UgeycsXG4gICAgICAgICAgICAnICAje25vZGUucmVzdWx0VmFyfSA9IG51bGw7JyxcbiAgICAgICAgICAgICcgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkgeycsXG4gICAgICAgICAgICAnICAgIG1hdGNoRmFpbGVkKFwiYW55IGNoYXJhY3RlclwiKTsnLFxuICAgICAgICAgICAgJyAgfScsXG4gICAgICAgICAgICAnfSdcbiAgICAgICAgICBdLFxuICAgICAgICAgIFwiY2xhc3NcIjogW1xuICAgICAgICAgICAgJ2lmICgje3JlZ2V4cH0udGVzdChpbnB1dC5jaGFyQXQoI3twb3NPZmZzZXQoXCJwb3NcIil9KSkpIHsnLFxuICAgICAgICAgICAgJyAgI3tub2RlLnJlc3VsdFZhcn0gPSBpbnB1dC5jaGFyQXQoI3twb3NPZmZzZXQoXCJwb3NcIil9KTsnLFxuICAgICAgICAgICAgJyAgI3twb3NBZHZhbmNlKDEpfTsnLFxuICAgICAgICAgICAgJ30gZWxzZSB7JyxcbiAgICAgICAgICAgICcgICN7bm9kZS5yZXN1bHRWYXJ9ID0gbnVsbDsnLFxuICAgICAgICAgICAgJyAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7JyxcbiAgICAgICAgICAgICcgICAgbWF0Y2hGYWlsZWQoI3tzdHJpbmcobm9kZS5yYXdUZXh0KX0pOycsXG4gICAgICAgICAgICAnICB9JyxcbiAgICAgICAgICAgICd9J1xuICAgICAgICAgIF1cbiAgICAgICAgfTtcblxuICAgIGZvciAobmFtZSBpbiBzb3VyY2VzKSB7XG4gICAgICB0ZW1wbGF0ZXNbbmFtZV0gPSBDb2RpZS50ZW1wbGF0ZShzb3VyY2VzW25hbWVdLmpvaW4oJ1xcbicpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVtcGxhdGVzO1xuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIGZpbGwobmFtZSwgdmFycykge1xuICAgIHZhcnMuc3RyaW5nICA9IHF1b3RlO1xuICAgIHZhcnMucGx1Y2sgICA9IHBsdWNrO1xuICAgIHZhcnMua2V5cyAgICA9IGtleXM7XG4gICAgdmFycy52YWx1ZXMgID0gdmFsdWVzO1xuICAgIHZhcnMuZW1pdCAgICA9IGVtaXQ7XG4gICAgdmFycy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIC8qIFBvc2l0aW9uLWhhbmRsaW5nIG1hY3JvcyAqL1xuICAgIGlmIChvcHRpb25zLnRyYWNrTGluZUFuZENvbHVtbikge1xuICAgICAgdmFycy5wb3NJbml0ICAgID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gXCJ2YXIgXCJcbiAgICAgICAgICAgICArIG5hbWVcbiAgICAgICAgICAgICArIFwiID0gXCJcbiAgICAgICAgICAgICArIFwieyBvZmZzZXQ6IDAsIGxpbmU6IDEsIGNvbHVtbjogMSwgc2VlbkNSOiBmYWxzZSB9XCI7XG4gICAgICB9O1xuICAgICAgdmFycy5wb3NDbG9uZSAgID0gZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gXCJjbG9uZShcIiArIG5hbWUgKyBcIilcIjsgfTtcbiAgICAgIHZhcnMucG9zT2Zmc2V0ICA9IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIG5hbWUgKyBcIi5vZmZzZXRcIjsgfTtcblxuICAgICAgdmFycy5wb3NBZHZhbmNlID0gZnVuY3Rpb24obikgICAgeyByZXR1cm4gXCJhZHZhbmNlKHBvcywgXCIgKyBuICsgXCIpXCI7IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhcnMucG9zSW5pdCAgICA9IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIFwidmFyIFwiICsgbmFtZSArIFwiID0gMFwiOyB9O1xuICAgICAgdmFycy5wb3NDbG9uZSAgID0gZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gbmFtZTsgfTtcbiAgICAgIHZhcnMucG9zT2Zmc2V0ICA9IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIG5hbWU7IH07XG5cbiAgICAgIHZhcnMucG9zQWR2YW5jZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIG4gPT09IDEgPyBcInBvcysrXCIgOiBcInBvcyArPSBcIiArIG47XG4gICAgICB9O1xuICAgIH1cbiAgICB2YXJzLnBvc1NhdmUgICAgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5wb3NWYXIgKyBcIiA9IFwiICsgdmFycy5wb3NDbG9uZShcInBvc1wiKTtcbiAgICB9O1xuICAgIHZhcnMucG9zUmVzdG9yZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBcInBvc1wiICsgXCIgPSBcIiArIHZhcnMucG9zQ2xvbmUobm9kZS5wb3NWYXIpO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGVtcGxhdGVzW25hbWVdKHZhcnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW1pdFNpbXBsZShuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHsgcmV0dXJuIGZpbGwobmFtZSwgeyBub2RlOiBub2RlIH0pOyB9O1xuICB9XG5cbiAgdmFyIGVtaXQgPSBidWlsZE5vZGVWaXNpdG9yKHtcbiAgICBncmFtbWFyOiBlbWl0U2ltcGxlKFwiZ3JhbW1hclwiKSxcblxuICAgIGluaXRpYWxpemVyOiBmdW5jdGlvbihub2RlKSB7IHJldHVybiBub2RlLmNvZGU7IH0sXG5cbiAgICBydWxlOiBlbWl0U2ltcGxlKFwicnVsZVwiKSxcblxuICAgIC8qXG4gICAgICogVGhlIGNvbnRyYWN0IGZvciBhbGwgY29kZSBmcmFnbWVudHMgZ2VuZXJhdGVkIGJ5IHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zXG4gICAgICogaXMgYXMgZm9sbG93cy5cbiAgICAgKlxuICAgICAqIFRoZSBjb2RlIGZyYWdtZW50IHRyaWVzIHRvIG1hdGNoIGEgcGFydCBvZiB0aGUgaW5wdXQgc3RhcnRpbmcgd2l0aCB0aGVcbiAgICAgKiBwb3NpdGlvbiBpbmRpY2F0ZWQgaW4gfHBvc3wuIFRoYXQgcG9zaXRpb24gbWF5IHBvaW50IHBhc3QgdGhlIGVuZCBvZiB0aGVcbiAgICAgKiBpbnB1dC5cbiAgICAgKlxuICAgICAqICogSWYgdGhlIGNvZGUgZnJhZ21lbnQgbWF0Y2hlcyB0aGUgaW5wdXQsIGl0IGFkdmFuY2VzIHxwb3N8IHRvIHBvaW50IHRvXG4gICAgICogICB0aGUgZmlyc3QgY2hyYWN0ZXIgZm9sbG93aW5nIHRoZSBtYXRjaGVkIHBhcnQgb2YgdGhlIGlucHV0IGFuZCBzZXRzXG4gICAgICogICB2YXJpYWJsZSB3aXRoIGEgbmFtZSBzdG9yZWQgaW4gfG5vZGUucmVzdWx0VmFyfCB0byBhbiBhcHByb3ByaWF0ZVxuICAgICAqICAgdmFsdWUuIFRoaXMgdmFsdWUgaXMgYWx3YXlzIG5vbi18bnVsbHwuXG4gICAgICpcbiAgICAgKiAqIElmIHRoZSBjb2RlIGZyYWdtZW50IGRvZXMgbm90IG1hdGNoIHRoZSBpbnB1dCwgaXQgcmV0dXJucyB3aXRoIHxwb3N8XG4gICAgICogICBzZXQgdG8gdGhlIG9yaWdpbmFsIHZhbHVlIGFuZCBpdCBzZXRzIGEgdmFyaWFibGUgd2l0aCBhIG5hbWUgc3RvcmVkIGluXG4gICAgICogICB8bm9kZS5yZXN1bHRWYXJ8IHRvIHxudWxsfC5cbiAgICAgKlxuICAgICAqIFRoZSBjb2RlIGNhbiB1c2UgdmFyaWFibGVzIHdpdGggbmFtZXMgc3RvcmVkIGluIHxyZXN1bHRWYXJ8IGFuZCB8cG9zVmFyfFxuICAgICAqIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgbm9kZSdzIHN1Ym5vZGVzLiBJdCBjYW4ndCB1c2UgYW55IG90aGVyXG4gICAgICogdmFyaWFibGVzLlxuICAgICAqL1xuXG4gICAgY2hvaWNlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgY29kZSwgbmV4dEFsdGVybmF0aXZlc0NvZGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSBub2RlLmFsdGVybmF0aXZlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBuZXh0QWx0ZXJuYXRpdmVzQ29kZSA9IGkgIT09IG5vZGUuYWx0ZXJuYXRpdmVzLmxlbmd0aCAtIDFcbiAgICAgICAgICA/IGZpbGwoXCJjaG9pY2UubmV4dFwiLCB7IG5vZGU6IG5vZGUsIGNvZGU6IGNvZGUgfSlcbiAgICAgICAgICA6ICcnO1xuICAgICAgICBjb2RlID0gZmlsbChcImNob2ljZVwiLCB7XG4gICAgICAgICAgYWx0ZXJuYXRpdmU6ICAgICAgICAgIG5vZGUuYWx0ZXJuYXRpdmVzW2ldLFxuICAgICAgICAgIG5leHRBbHRlcm5hdGl2ZXNDb2RlOiBuZXh0QWx0ZXJuYXRpdmVzQ29kZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfSxcblxuICAgIHNlcXVlbmNlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgY29kZSA9IGZpbGwoXCJzZXF1ZW5jZS5pbm5lclwiLCB7IG5vZGU6IG5vZGUgfSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSBub2RlLmVsZW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvZGUgPSBmaWxsKFwic2VxdWVuY2UuaXRlcmF0aW9uXCIsIHtcbiAgICAgICAgICBub2RlOiAgICBub2RlLFxuICAgICAgICAgIGVsZW1lbnQ6IG5vZGUuZWxlbWVudHNbaV0sXG4gICAgICAgICAgY29kZTogICAgY29kZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpbGwoXCJzZXF1ZW5jZVwiLCB7IG5vZGU6IG5vZGUsIGNvZGU6IGNvZGUgfSk7XG4gICAgfSxcblxuICAgIGxhYmVsZWQ6IGZ1bmN0aW9uKG5vZGUpIHsgcmV0dXJuIGVtaXQobm9kZS5leHByZXNzaW9uKTsgfSxcblxuICAgIHNpbXBsZV9hbmQ6ICAgZW1pdFNpbXBsZShcInNpbXBsZV9hbmRcIiksXG4gICAgc2ltcGxlX25vdDogICBlbWl0U2ltcGxlKFwic2ltcGxlX25vdFwiKSxcbiAgICBzZW1hbnRpY19hbmQ6IGVtaXRTaW1wbGUoXCJzZW1hbnRpY19hbmRcIiksXG4gICAgc2VtYW50aWNfbm90OiBlbWl0U2ltcGxlKFwic2VtYW50aWNfbm90XCIpLFxuICAgIG9wdGlvbmFsOiAgICAgZW1pdFNpbXBsZShcIm9wdGlvbmFsXCIpLFxuICAgIHplcm9fb3JfbW9yZTogZW1pdFNpbXBsZShcInplcm9fb3JfbW9yZVwiKSxcbiAgICBvbmVfb3JfbW9yZTogIGVtaXRTaW1wbGUoXCJvbmVfb3JfbW9yZVwiKSxcbiAgICBhY3Rpb246ICAgICAgIGVtaXRTaW1wbGUoXCJhY3Rpb25cIiksXG4gICAgcnVsZV9yZWY6ICAgICBlbWl0U2ltcGxlKFwicnVsZV9yZWZcIiksXG4gICAgbGl0ZXJhbDogICAgICBlbWl0U2ltcGxlKFwibGl0ZXJhbFwiKSxcbiAgICBhbnk6ICAgICAgICAgIGVtaXRTaW1wbGUoXCJhbnlcIiksXG5cbiAgICBcImNsYXNzXCI6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciByZWdleHA7XG5cbiAgICAgIGlmIChub2RlLnBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVnZXhwID0gJy9eWydcbiAgICAgICAgICArIChub2RlLmludmVydGVkID8gJ14nIDogJycpXG4gICAgICAgICAgKyBtYXAobm9kZS5wYXJ0cywgZnVuY3Rpb24ocGFydCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFydCBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgICAgICAgICAgPyBxdW90ZUZvclJlZ2V4cENsYXNzKHBhcnRbMF0pXG4gICAgICAgICAgICAgICAgICArICctJ1xuICAgICAgICAgICAgICAgICAgKyBxdW90ZUZvclJlZ2V4cENsYXNzKHBhcnRbMV0pXG4gICAgICAgICAgICAgICAgOiBxdW90ZUZvclJlZ2V4cENsYXNzKHBhcnQpO1xuICAgICAgICAgICAgfSkuam9pbignJylcbiAgICAgICAgICArICddLycgKyAobm9kZS5pZ25vcmVDYXNlID8gJ2knIDogJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLypcbiAgICAgICAgICogU3R1cGlkIElFIGNvbnNpZGVycyByZWdleHBzIC9bXS8gYW5kIC9bXl0vIHN5bnRhY3RpY2FsbHkgaW52YWxpZCwgc29cbiAgICAgICAgICogd2UgdHJhbnNsYXRlIHRoZW0gaW50byBldXFpdmFsZW50cyBpdCBjYW4gaGFuZGxlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVnZXhwID0gbm9kZS5pbnZlcnRlZCA/ICcvXltcXFxcU1xcXFxzXS8nIDogJy9eKD8hKS8nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmlsbChcImNsYXNzXCIsIHsgbm9kZTogbm9kZSwgcmVnZXhwOiByZWdleHAgfSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZW1pdChhc3QpO1xufTtcblxucmV0dXJuIFBFRztcblxufSkoKTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBQRUc7XG59XG4iLCJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIEhhc2ggPSByZXF1aXJlKCdoYXNoaXNoJyk7XG52YXIgQ2hhaW5zYXcgPSByZXF1aXJlKCdjaGFpbnNhdycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcTtcbmZ1bmN0aW9uIFNlcSAoeHMpIHtcbiAgICBpZiAoeHMgJiYgIUFycmF5LmlzQXJyYXkoeHMpIHx8IGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9uYWwgYXJndW1lbnQgdG8gU2VxKCkgaXMgZXhhY3RseSBvbmUgQXJyYXknKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGNoID0gQ2hhaW5zYXcoZnVuY3Rpb24gKHNhdykge1xuICAgICAgICBidWlsZGVyLmNhbGwodGhpcywgc2F3LCB4cyB8fCBbXSk7XG4gICAgfSk7XG4gICAgXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoWydjYXRjaCddKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrID8gZXJyLnN0YWNrIDogZXJyKVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2g7XG59XG5cblNlcS5hcCA9IFNlcTsgLy8gZm9yIGNvbXBhdGFiaWxpdHkgd2l0aCB2ZXJzaW9ucyA8MC4zXG5cbmZ1bmN0aW9uIGJ1aWxkZXIgKHNhdywgeHMpIHtcbiAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgdmFycyA6IHt9LFxuICAgICAgICBhcmdzIDoge30sXG4gICAgICAgIHN0YWNrIDogeHMsXG4gICAgICAgIGVycm9yIDogbnVsbFxuICAgIH07XG4gICAgY29udGV4dC5zdGFja18gPSBjb250ZXh0LnN0YWNrO1xuICAgIFxuICAgIGZ1bmN0aW9uIGFjdGlvbiAoc3RlcCwga2V5LCBmLCBnKSB7XG4gICAgICAgIHZhciBjYiA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZXJyb3IgPSB7IG1lc3NhZ2UgOiBlcnIsIGtleSA6IGtleSB9O1xuICAgICAgICAgICAgICAgIHNhdy5qdW1wKGxhc3RQYXIpO1xuICAgICAgICAgICAgICAgIHNhdy5kb3duKCdjYXRjaCcpO1xuICAgICAgICAgICAgICAgIGcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhY2tfW2tleV0gPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmFyZ3Nba2V5XSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN0YWNrXy5wdXNoLmFwcGx5KGNvbnRleHQuc3RhY2tfLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnZhcnNba2V5XSA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmFyZ3Nba2V5XSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGcpIGcoYXJncywga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgSGFzaChjb250ZXh0KS5mb3JFYWNoKGZ1bmN0aW9uICh2LGspIHsgY2Jba10gPSB2IH0pO1xuICAgICAgICBcbiAgICAgICAgY2IuaW50byA9IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBrZXkgPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGNiO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgY2IubmV4dCA9IGZ1bmN0aW9uIChlcnIsIHhzKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0YWNrXy5wdXNoLmFwcGx5KGNvbnRleHQuc3RhY2tfLCB4cyk7XG4gICAgICAgICAgICBjYi5hcHBseShjYiwgW2Vycl0uY29uY2F0KGNvbnRleHQuc3RhY2spKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNiLnBhc3MgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYi5hcHBseShjYiwgW2Vycl0uY29uY2F0KGNvbnRleHQuc3RhY2spKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNiLm9rID0gY2IuYmluZChjYiwgbnVsbCk7XG4gICAgICAgIFxuICAgICAgICBmLmFwcGx5KGNiLCBjb250ZXh0LnN0YWNrKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHJ1bm5pbmcgPSAwO1xuICAgIHZhciBlcnJvcnMgPSAwO1xuICAgIFxuICAgIHRoaXMuc2VxID0gZnVuY3Rpb24gKGtleSwgY2IpIHtcbiAgICAgICAgdmFyIGJvdW5kID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgYm91bmQudW5zaGlmdChjYik7XG4gICAgICAgICAgICBjYiA9IGtleTtcbiAgICAgICAgICAgIGtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGNvbnRleHQuZXJyb3IpIHNhdy5uZXh0KClcbiAgICAgICAgZWxzZSBpZiAocnVubmluZyA9PT0gMCkge1xuICAgICAgICAgICAgYWN0aW9uKHNhdy5zdGVwLCBrZXksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN0YWNrXyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgYXJncy51bnNoaWZ0LmFwcGx5KGFyZ3MsIGJvdW5kLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnID09PSBTZXEgPyB0aGlzIDogYXJnXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdGFjayA9IGNvbnRleHQuc3RhY2tfO1xuICAgICAgICAgICAgICAgICAgICBzYXcubmV4dCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgdmFyIGxhc3RQYXIgPSBudWxsO1xuICAgIHRoaXMucGFyID0gZnVuY3Rpb24gKGtleSwgY2IpIHtcbiAgICAgICAgbGFzdFBhciA9IHNhdy5zdGVwO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJ1bm5pbmcgPT0gMCkge1xuICAgICAgICAgICAgLy8gZW1wdHkgdGhlIGFjdGl2ZSBzdGFjayBmb3IgdGhlIGZpcnN0IHBhcigpIGluIGEgY2hhaW5cbiAgICAgICAgICAgIGNvbnRleHQuc3RhY2tfID0gW107XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBib3VuZCA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgYm91bmQudW5zaGlmdChjYik7XG4gICAgICAgICAgICBjYiA9IGtleTtcbiAgICAgICAgICAgIGtleSA9IGNvbnRleHQuc3RhY2tfLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnRleHQuc3RhY2tfLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNiXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0LmFwcGx5KGFyZ3MsIGJvdW5kLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZyA9PT0gU2VxID8gdGhpcyA6IGFyZ1xuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHJ1bm5pbmcgKys7XG4gICAgICAgIFxuICAgICAgICB2YXIgc3RlcCA9IHNhdy5zdGVwO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFjdGlvbihzdGVwLCBrZXksIGNiXywgZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZ3MpIGVycm9ycyArKztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBydW5uaW5nIC0tO1xuICAgICAgICAgICAgICAgIGlmIChydW5uaW5nID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdGFjayA9IGNvbnRleHQuc3RhY2tfLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHNhdy5zdGVwID0gbGFzdFBhcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9ycyA+IDApIHNhdy5kb3duKCdjYXRjaCcpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBzYXcubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc2F3Lm5leHQoKTtcbiAgICB9O1xuICAgIFxuICAgIFsgJ3NlcScsICdwYXInIF0uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzW25hbWUgKyAnXyddID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBjYiA9IHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/IGFyZ3NbMF0gOiBhcmdzWzFdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3YgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgYXJndi51bnNoaWZ0KHRoaXMpO1xuICAgICAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3YpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBhcmdzWzBdID0gZm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdzWzFdID0gZm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXNbbmFtZV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH07XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpc1snY2F0Y2gnXSA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICBpZiAoY29udGV4dC5lcnJvcikge1xuICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBjb250ZXh0LmVycm9yLm1lc3NhZ2UsIGNvbnRleHQuZXJyb3Iua2V5KTtcbiAgICAgICAgICAgIGNvbnRleHQuZXJyb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHNhdy5uZXh0KCk7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmZvckVhY2ggPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdGhpcy5zZXEoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29udGV4dC5zdGFja18gPSBjb250ZXh0LnN0YWNrLnNsaWNlKCk7XG4gICAgICAgICAgICB2YXIgZW5kID0gY29udGV4dC5zdGFjay5sZW5ndGg7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChlbmQgPT09IDApIHRoaXMobnVsbClcbiAgICAgICAgICAgIGVsc2UgY29udGV4dC5zdGFjay5mb3JFYWNoKGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uKHNhdy5zdGVwLCBpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiLmNhbGwodGhpcywgeCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09IGVuZCAtIDEpIHNhdy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnNlcUVhY2ggPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdGhpcy5zZXEoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29udGV4dC5zdGFja18gPSBjb250ZXh0LnN0YWNrLnNsaWNlKCk7XG4gICAgICAgICAgICB2YXIgeHMgPSBjb250ZXh0LnN0YWNrLnNsaWNlKCk7XG4gICAgICAgICAgICBpZiAoeHMubGVuZ3RoID09PSAwKSB0aGlzKG51bGwpO1xuICAgICAgICAgICAgZWxzZSAoZnVuY3Rpb24gbmV4dCAoaSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgc2F3LnN0ZXAsIGksXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgY2IuY2FsbCh0aGlzLCB4c1tpXSwgaSkgfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXJncyB8fCBpID09PSB4cy5sZW5ndGggLSAxKSBzYXcubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBuZXh0KGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KS5iaW5kKHRoaXMpKDApO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMucGFyRWFjaCA9IGZ1bmN0aW9uIChsaW1pdCwgY2IpIHtcbiAgICAgICAgdmFyIHhzID0gY29udGV4dC5zdGFjay5zbGljZSgpO1xuICAgICAgICBpZiAoY2IgPT09IHVuZGVmaW5lZCkgeyBjYiA9IGxpbWl0OyBsaW1pdCA9IHhzLmxlbmd0aCB9XG4gICAgICAgIGNvbnRleHQuc3RhY2tfID0gW107XG4gICAgICAgIFxuICAgICAgICB2YXIgYWN0aXZlID0gMDtcbiAgICAgICAgdmFyIGZpbmlzaGVkID0gMDtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIFxuICAgICAgICBpZiAoeHMubGVuZ3RoID09PSAwKSBzYXcubmV4dCgpXG4gICAgICAgIGVsc2UgeHMuZm9yRWFjaChmdW5jdGlvbiBjYWxsICh4LCBpKSB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChjYWxsLmJpbmQodGhpcywgeCwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlICsrO1xuICAgICAgICAgICAgICAgIGFjdGlvbihzYXcuc3RlcCwgaSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IuY2FsbCh0aGlzLCB4LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlIC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWQgKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkgcXVldWUuc2hpZnQoKSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmluaXNoZWQgPT09IHhzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhdy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMucGFyTWFwID0gZnVuY3Rpb24gKGxpbWl0LCBjYikge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIHZhciBsZW4gPSBjb250ZXh0LnN0YWNrLmxlbmd0aDtcbiAgICAgICAgaWYgKGNiID09PSB1bmRlZmluZWQpIHsgY2IgPSBsaW1pdDsgbGltaXQgPSBsZW4gfVxuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIFxuICAgICAgICBTZXEoKVxuICAgICAgICAgICAgLmV4dGVuZChjb250ZXh0LnN0YWNrKVxuICAgICAgICAgICAgLnBhckVhY2gobGltaXQsIGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXNbaV0gPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIG5leHQuc3RhY2sgPSBzZWxmLnN0YWNrO1xuICAgICAgICAgICAgICAgIG5leHQuc3RhY2tfID0gc2VsZi5zdGFja187XG4gICAgICAgICAgICAgICAgbmV4dC52YXJzID0gc2VsZi52YXJzO1xuICAgICAgICAgICAgICAgIG5leHQuYXJncyA9IHNlbGYuYXJncztcbiAgICAgICAgICAgICAgICBuZXh0LmVycm9yID0gc2VsZi5lcnJvcjtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBuZXh0LmludG8gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIG5leHQub2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0LmFwcGx5KG5leHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY2IuYXBwbHkobmV4dCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc2VxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0YWNrID0gcmVzO1xuICAgICAgICAgICAgICAgIHNhdy5uZXh0KCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICA7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnNlcU1hcCA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIHZhciBsYXN0SWR4ID0gY29udGV4dC5zdGFjay5sZW5ndGggLSAxO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5zZXFFYWNoKGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc1tpXSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbGFzdElkeClcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdGFjayA9IHJlcztcbiAgICAgICAgICAgICAgICBzZWxmLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBuZXh0LnN0YWNrID0gc2VsZi5zdGFjaztcbiAgICAgICAgICAgIG5leHQuc3RhY2tfID0gc2VsZi5zdGFja187XG4gICAgICAgICAgICBuZXh0LnZhcnMgPSBzZWxmLnZhcnM7XG4gICAgICAgICAgICBuZXh0LmFyZ3MgPSBzZWxmLmFyZ3M7XG4gICAgICAgICAgICBuZXh0LmVycm9yID0gc2VsZi5lcnJvcjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbmV4dC5pbnRvID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbGFzdElkeClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhY2sgPSByZXM7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbmV4dC5vayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQobnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQuYXBwbHkobmV4dCwgYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYi5hcHBseShuZXh0LCBhcmd1bWVudHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIENvbnN1bWVzIGFueSBlcnJvcnMgdGhhdCBvY2N1ciBpbiBgY2JgLiBDYWxscyB0byBgdGhpcy5pbnRvKGkpYCB3aWxsIHBsYWNlXG4gICAgICogdGhhdCB2YWx1ZSwgaWYgYWNjZXB0ZWQgYnkgdGhlIGZpbHRlciwgYXQgdGhlIGluZGV4IGluIHRoZSByZXN1bHRzIGFzXG4gICAgICogaWYgaXQgd2VyZSB0aGUgaS10aCBpbmRleCBiZWZvcmUgZmlsdGVyaW5nLiAoVGhpcyBtZWFucyBpdCB3aWxsIG5ldmVyIFxuICAgICAqIG92ZXJyaWRlIGFub3RoZXIgdmFsdWUsIGFuZCB3aWxsIG9ubHkgYWN0dWFsbHkgYXBwZWFyIGF0IGkgaWYgdGhlIGZpbHRlclxuICAgICAqIGFjY2VwdHMgYWxsIHZhbHVlcyBiZWZvcmUgaS4pXG4gICAgICovXG4gICAgdGhpcy5wYXJGaWx0ZXIgPSBmdW5jdGlvbiAobGltaXQsIGNiKSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgdmFyIGxlbiA9IGNvbnRleHQuc3RhY2subGVuZ3RoO1xuICAgICAgICBpZiAoY2IgPT09IHVuZGVmaW5lZCkgeyBjYiA9IGxpbWl0OyBsaW1pdCA9IGxlbiB9XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgXG4gICAgICAgIFNlcSgpXG4gICAgICAgICAgICAuZXh0ZW5kKGNvbnRleHQuc3RhY2spXG4gICAgICAgICAgICAucGFyRWFjaChsaW1pdCwgZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbiAoZXJyLCBvaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVyciAmJiBvaylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKFtpLCB4XSk7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c1swXSA9IG51bGw7IC8vIGRpc2NhcmQgZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIG5leHQuc3RhY2sgPSBzZWxmLnN0YWNrO1xuICAgICAgICAgICAgICAgIG5leHQuc3RhY2tfID0gc2VsZi5zdGFja187XG4gICAgICAgICAgICAgICAgbmV4dC52YXJzID0gc2VsZi52YXJzO1xuICAgICAgICAgICAgICAgIG5leHQuYXJncyA9IHNlbGYuYXJncztcbiAgICAgICAgICAgICAgICBuZXh0LmVycm9yID0gc2VsZi5lcnJvcjtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBuZXh0LmludG8gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXJyLCBvaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIgJiYgb2spXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goW2tleSwgeF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzWzBdID0gbnVsbDsgLy8gZGlzY2FyZCBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIG5leHQub2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0LmFwcGx5KG5leHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY2IuYXBwbHkobmV4dCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc2VxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0YWNrID0gcmVzLnNvcnQoKS5tYXAoZnVuY3Rpb24ocGFpcil7IHJldHVybiBwYWlyWzFdOyB9KTtcbiAgICAgICAgICAgICAgICBzYXcubmV4dCgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogQ29uc3VtZXMgYW55IGVycm9ycyB0aGF0IG9jY3VyIGluIGBjYmAuIENhbGxzIHRvIGB0aGlzLmludG8oaSlgIHdpbGwgcGxhY2VcbiAgICAgKiB0aGF0IHZhbHVlLCBpZiBhY2NlcHRlZCBieSB0aGUgZmlsdGVyLCBhdCB0aGUgaW5kZXggaW4gdGhlIHJlc3VsdHMgYXNcbiAgICAgKiBpZiBpdCB3ZXJlIHRoZSBpLXRoIGluZGV4IGJlZm9yZSBmaWx0ZXJpbmcuIChUaGlzIG1lYW5zIGl0IHdpbGwgbmV2ZXIgXG4gICAgICogb3ZlcnJpZGUgYW5vdGhlciB2YWx1ZSwgYW5kIHdpbGwgb25seSBhY3R1YWxseSBhcHBlYXIgYXQgaSBpZiB0aGUgZmlsdGVyXG4gICAgICogYWNjZXB0cyBhbGwgdmFsdWVzIGJlZm9yZSBpLilcbiAgICAgKi9cbiAgICB0aGlzLnNlcUZpbHRlciA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIHZhciBsYXN0SWR4ID0gY29udGV4dC5zdGFjay5sZW5ndGggLSAxO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5zZXFFYWNoKGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gKGVyciwgb2spIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVyciAmJiBvaylcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goW2ksIHhdKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbGFzdElkeClcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdGFjayA9IHJlcy5zb3J0KCkubWFwKGZ1bmN0aW9uKHBhaXIpeyByZXR1cm4gcGFpclsxXTsgfSk7XG4gICAgICAgICAgICAgICAgYXJndW1lbnRzWzBdID0gbnVsbDsgLy8gZGlzY2FyZCBlcnJvcnNcbiAgICAgICAgICAgICAgICBzZWxmLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBuZXh0LnN0YWNrID0gc2VsZi5zdGFjaztcbiAgICAgICAgICAgIG5leHQuc3RhY2tfID0gc2VsZi5zdGFja187XG4gICAgICAgICAgICBuZXh0LnZhcnMgPSBzZWxmLnZhcnM7XG4gICAgICAgICAgICBuZXh0LmFyZ3MgPSBzZWxmLmFyZ3M7XG4gICAgICAgICAgICBuZXh0LmVycm9yID0gc2VsZi5lcnJvcjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbmV4dC5pbnRvID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXJyLCBvaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVyciAmJiBvaylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKFtrZXksIHhdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGxhc3RJZHgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN0YWNrID0gcmVzLnNvcnQoKS5tYXAoZnVuY3Rpb24ocGFpcil7IHJldHVybiBwYWlyWzFdOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzWzBdID0gbnVsbDsgLy8gZGlzY2FyZCBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBuZXh0Lm9rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGFyZ3MudW5zaGlmdChudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dC5hcHBseShuZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNiLmFwcGx5KG5leHQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgWyAnZm9yRWFjaCcsICdzZXFFYWNoJywgJ3BhckVhY2gnLCAnc2VxTWFwJywgJ3Bhck1hcCcsICdzZXFGaWx0ZXInLCAncGFyRmlsdGVyJyBdXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB0aGlzW25hbWUgKyAnXyddID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tuYW1lXS5jYWxsKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzKVxuICAgIDtcbiAgICBcbiAgICBbJ3B1c2gnLCdwb3AnLCdzaGlmdCcsJ3Vuc2hpZnQnLCdzcGxpY2UnLCdyZXZlcnNlJ11cbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdGFja1tuYW1lXS5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBzYXcubmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcylcbiAgICA7XG4gICAgXG4gICAgWyAnbWFwJywgJ2ZpbHRlcicsICdyZWR1Y2UnIF1cbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IGNvbnRleHQuc3RhY2tbbmFtZV0uYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgLy8gc3RhY2sgbXVzdCBiZSBhbiBhcnJheSwgb3IgYmFkIHRoaW5ncyBoYXBwZW5cbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0YWNrID0gKEFycmF5LmlzQXJyYXkocmVzKSA/IHJlcyA6IFtyZXNdKTtcbiAgICAgICAgICAgICAgICBzYXcubmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcylcbiAgICA7XG4gICAgXG4gICAgdGhpcy5leHRlbmQgPSBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHhzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcmd1bWVudCB0byAuZXh0ZW5kKCkgaXMgbm90IGFuIEFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5zdGFjay5wdXNoLmFwcGx5KGNvbnRleHQuc3RhY2ssIHhzKTtcbiAgICAgICAgc2F3Lm5leHQoKTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZmxhdHRlbiA9IGZ1bmN0aW9uIChwYW5jYWtlKSB7XG4gICAgICAgIHZhciB4cyA9IFtdO1xuICAgICAgICAvLyBzaG91bGQgd2UgZnVsbHkgZmxhdHRlbiB0aGlzIGFycmF5PyAoZGVmYXVsdDogdHJ1ZSlcbiAgICAgICAgaWYgKHBhbmNha2UgPT09IHVuZGVmaW5lZCkgeyBwYW5jYWtlID0gdHJ1ZTsgfVxuICAgICAgICBjb250ZXh0LnN0YWNrLmZvckVhY2goZnVuY3Rpb24gZiAoeCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoeCkgJiYgcGFuY2FrZSkgeC5mb3JFYWNoKGYpO1xuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh4KSkgeHMgPSB4cy5jb25jYXQoeCk7XG4gICAgICAgICAgICBlbHNlIHhzLnB1c2goeCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb250ZXh0LnN0YWNrID0geHM7XG4gICAgICAgIHNhdy5uZXh0KCk7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnVuZmxhdHRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGV4dC5zdGFjayA9IFtjb250ZXh0LnN0YWNrXTtcbiAgICAgICAgc2F3Lm5leHQoKTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRleHQuc3RhY2sgPSBbXTtcbiAgICAgICAgc2F3Lm5leHQoKTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuc2V0ID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAgICAgIGNvbnRleHQuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgc2F3Lm5leHQoKTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXNbJ2RvJ10gPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgc2F3Lm5lc3QoY2IsIGNvbnRleHQpO1xuICAgIH07XG59XG4iLCJ2YXIgVHJhdmVyc2UgPSByZXF1aXJlKCd0cmF2ZXJzZScpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGFpbnNhdztcbmZ1bmN0aW9uIENoYWluc2F3IChidWlsZGVyKSB7XG4gICAgdmFyIHNhdyA9IENoYWluc2F3LnNhdyhidWlsZGVyLCB7fSk7XG4gICAgdmFyIHIgPSBidWlsZGVyLmNhbGwoc2F3LmhhbmRsZXJzLCBzYXcpO1xuICAgIGlmIChyICE9PSB1bmRlZmluZWQpIHNhdy5oYW5kbGVycyA9IHI7XG4gICAgcmV0dXJuIHNhdy5jaGFpbigpO1xufTtcblxuQ2hhaW5zYXcuc2F3ID0gZnVuY3Rpb24gKGJ1aWxkZXIsIGhhbmRsZXJzKSB7XG4gICAgdmFyIHNhdyA9IG5ldyBFdmVudEVtaXR0ZXI7XG4gICAgc2F3LmhhbmRsZXJzID0gaGFuZGxlcnM7XG4gICAgc2F3LmFjdGlvbnMgPSBbXTtcbiAgICBzYXcuc3RlcCA9IDA7XG4gICAgXG4gICAgc2F3LmNoYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2ggPSBUcmF2ZXJzZShzYXcuaGFuZGxlcnMpLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSb290KSByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIHZhciBwcyA9IHRoaXMucGF0aDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzYXcuYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggOiBwcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgOiBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNhdy5lbWl0KCdiZWdpbicpO1xuICAgICAgICAgICAgc2F3Lm5leHQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gY2g7XG4gICAgfTtcbiAgICBcbiAgICBzYXcubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFjdGlvbiA9IHNhdy5hY3Rpb25zW3Nhdy5zdGVwXTtcbiAgICAgICAgc2F3LnN0ZXAgKys7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWFjdGlvbikge1xuICAgICAgICAgICAgc2F3LmVtaXQoJ2VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhY3Rpb24udHJhcCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBzYXcuaGFuZGxlcnM7XG4gICAgICAgICAgICBhY3Rpb24ucGF0aC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgbm9kZSA9IG5vZGVba2V5XSB9KTtcbiAgICAgICAgICAgIG5vZGUuYXBwbHkoc2F3LmhhbmRsZXJzLCBhY3Rpb24uYXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIHNhdy5uZXN0ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICB2YXIgYXV0b25leHQgPSB0cnVlO1xuICAgICAgICBcbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB2YXIgYXV0b25leHQgPSBjYjtcbiAgICAgICAgICAgIGNiID0gYXJncy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgcyA9IENoYWluc2F3LnNhdyhidWlsZGVyLCB7fSk7XG4gICAgICAgIHZhciByID0gYnVpbGRlci5jYWxsKHMuaGFuZGxlcnMsIHMpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcy5oYW5kbGVycyA9IHI7XG4gICAgICAgIGNiLmFwcGx5KHMuY2hhaW4oKSwgYXJncyk7XG4gICAgICAgIGlmIChhdXRvbmV4dCAhPT0gZmFsc2UpIHMub24oJ2VuZCcsIHNhdy5uZXh0KTtcbiAgICB9O1xuICAgIFxuICAgIHNhdy50cmFwID0gZnVuY3Rpb24gKG5hbWUsIGNiKSB7XG4gICAgICAgIHZhciBwcyA9IEFycmF5LmlzQXJyYXkobmFtZSkgPyBuYW1lIDogW25hbWVdO1xuICAgICAgICBzYXcuYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHBhdGggOiBwcyxcbiAgICAgICAgICAgIHN0ZXAgOiBzYXcuc3RlcCxcbiAgICAgICAgICAgIGNiIDogY2IsXG4gICAgICAgICAgICB0cmFwIDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIHNhdy5kb3duID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHBzID0gKEFycmF5LmlzQXJyYXkobmFtZSkgPyBuYW1lIDogW25hbWVdKS5qb2luKCcvJyk7XG4gICAgICAgIHZhciBpID0gc2F3LmFjdGlvbnMuc2xpY2Uoc2F3LnN0ZXApLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgaWYgKHgudHJhcCAmJiB4LnN0ZXAgPD0gc2F3LnN0ZXApIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB4LnBhdGguam9pbignLycpID09IHBzO1xuICAgICAgICB9KS5pbmRleE9mKHRydWUpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGkgPj0gMCkgc2F3LnN0ZXAgKz0gaTtcbiAgICAgICAgZWxzZSBzYXcuc3RlcCA9IHNhdy5hY3Rpb25zLmxlbmd0aDtcbiAgICAgICAgXG4gICAgICAgIHZhciBhY3QgPSBzYXcuYWN0aW9uc1tzYXcuc3RlcCAtIDFdO1xuICAgICAgICBpZiAoYWN0ICYmIGFjdC50cmFwKSB7XG4gICAgICAgICAgICAvLyBJdCdzIGEgdHJhcCFcbiAgICAgICAgICAgIHNhdy5zdGVwID0gYWN0LnN0ZXA7XG4gICAgICAgICAgICBhY3QuY2IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHNhdy5uZXh0KCk7XG4gICAgfTtcbiAgICBcbiAgICBzYXcuanVtcCA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgIHNhdy5zdGVwID0gc3RlcDtcbiAgICAgICAgc2F3Lm5leHQoKTtcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiBzYXc7XG59OyBcbiIsIm1vZHVsZS5leHBvcnRzID0gVHJhdmVyc2U7XG5mdW5jdGlvbiBUcmF2ZXJzZSAob2JqKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYXZlcnNlKSkgcmV0dXJuIG5ldyBUcmF2ZXJzZShvYmopO1xuICAgIHRoaXMudmFsdWUgPSBvYmo7XG59XG5cblRyYXZlcnNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocHMpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMudmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHBzW2ldO1xuICAgICAgICBpZiAoIU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGUsIGtleSkpIHtcbiAgICAgICAgICAgIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAocHMsIHZhbHVlKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHMubGVuZ3RoIC0gMTsgaSArKykge1xuICAgICAgICB2YXIga2V5ID0gcHNbaV07XG4gICAgICAgIGlmICghT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobm9kZSwga2V5KSkgbm9kZVtrZXldID0ge307XG4gICAgICAgIG5vZGUgPSBub2RlW2tleV07XG4gICAgfVxuICAgIG5vZGVbcHNbaV1dID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYikge1xuICAgIHJldHVybiB3YWxrKHRoaXMudmFsdWUsIGNiLCB0cnVlKTtcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgdGhpcy52YWx1ZSA9IHdhbGsodGhpcy52YWx1ZSwgY2IsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoY2IsIGluaXQpIHtcbiAgICB2YXIgc2tpcCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDE7XG4gICAgdmFyIGFjYyA9IHNraXAgPyB0aGlzLnZhbHVlIDogaW5pdDtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUm9vdCB8fCAhc2tpcCkge1xuICAgICAgICAgICAgYWNjID0gY2IuY2FsbCh0aGlzLCBhY2MsIHgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5kZWVwRXF1YWwgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ2RlZXBFcXVhbCByZXF1aXJlcyBleGFjdGx5IG9uZSBvYmplY3QgdG8gY29tcGFyZSBhZ2FpbnN0J1xuICAgICAgICApO1xuICAgIH1cbiAgICBcbiAgICB2YXIgZXF1YWwgPSB0cnVlO1xuICAgIHZhciBub2RlID0gb2JqO1xuICAgIFxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoeSkge1xuICAgICAgICB2YXIgbm90RXF1YWwgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZXF1YWwgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9KS5iaW5kKHRoaXMpO1xuICAgICAgICBcbiAgICAgICAgLy9pZiAobm9kZSA9PT0gdW5kZWZpbmVkIHx8IG5vZGUgPT09IG51bGwpIHJldHVybiBub3RFcXVhbCgpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCF0aGlzLmlzUm9vdCkge1xuICAgICAgICAvKlxuICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCB0aGlzLmtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm90RXF1YWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHJldHVybiBub3RFcXVhbCgpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGVbdGhpcy5rZXldO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgeCA9IG5vZGU7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnBvc3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbm9kZSA9IHg7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdmFyIHRvUyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgaWYgKHRoaXMuY2lyY3VsYXIpIHtcbiAgICAgICAgICAgIGlmIChUcmF2ZXJzZShvYmopLmdldCh0aGlzLmNpcmN1bGFyLnBhdGgpICE9PSB4KSBub3RFcXVhbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB4ICE9PSB0eXBlb2YgeSkge1xuICAgICAgICAgICAgbm90RXF1YWwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4ID09PSBudWxsIHx8IHkgPT09IG51bGwgfHwgeCA9PT0gdW5kZWZpbmVkIHx8IHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHggIT09IHkpIG5vdEVxdWFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeC5fX3Byb3RvX18gIT09IHkuX19wcm90b19fKSB7XG4gICAgICAgICAgICBub3RFcXVhbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHggPT09IHkpIHtcbiAgICAgICAgICAgIC8vIG5vcFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgIC8vIGJvdGggcmVnZXhwcyBvbiBhY2NvdW50IG9mIHRoZSBfX3Byb3RvX18gY2hlY2tcbiAgICAgICAgICAgICAgICBpZiAoeC50b1N0cmluZygpICE9IHkudG9TdHJpbmcoKSkgbm90RXF1YWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHggIT09IHkpIG5vdEVxdWFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAodG9TKHkpID09PSAnW29iamVjdCBBcmd1bWVudHNdJ1xuICAgICAgICAgICAgfHwgdG9TKHgpID09PSAnW29iamVjdCBBcmd1bWVudHNdJykge1xuICAgICAgICAgICAgICAgIGlmICh0b1MoeCkgIT09IHRvUyh5KSkge1xuICAgICAgICAgICAgICAgICAgICBub3RFcXVhbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHggaW5zdGFuY2VvZiBEYXRlIHx8IHkgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoeCBpbnN0YW5jZW9mIERhdGUpIHx8ICEoeSBpbnN0YW5jZW9mIERhdGUpXG4gICAgICAgICAgICAgICAgfHwgeC5nZXRUaW1lKCkgIT09IHkuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdEVxdWFsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGt4ID0gT2JqZWN0LmtleXMoeCk7XG4gICAgICAgICAgICAgICAgdmFyIGt5ID0gT2JqZWN0LmtleXMoeSk7XG4gICAgICAgICAgICAgICAgaWYgKGt4Lmxlbmd0aCAhPT0ga3kubGVuZ3RoKSByZXR1cm4gbm90RXF1YWwoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGt4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrID0ga3hbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoeSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEVxdWFsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gZXF1YWw7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUucGF0aHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFjYyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBhY2MucHVzaCh0aGlzLnBhdGgpOyBcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLm5vZGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhY2MgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgYWNjLnB1c2godGhpcy5ub2RlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnRzID0gW10sIG5vZGVzID0gW107XG4gICAgXG4gICAgcmV0dXJuIChmdW5jdGlvbiBjbG9uZSAoc3JjKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHBhcmVudHNbaV0gPT09IHNyYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2Rlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICdvYmplY3QnICYmIHNyYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGRzdCA9IGNvcHkoc3JjKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcGFyZW50cy5wdXNoKHNyYyk7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKGRzdCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNyYykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHN0W2tleV0gPSBjbG9uZShzcmNba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcGFyZW50cy5wb3AoKTtcbiAgICAgICAgICAgIG5vZGVzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIGRzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzcmM7XG4gICAgICAgIH1cbiAgICB9KSh0aGlzLnZhbHVlKTtcbn07XG5cbmZ1bmN0aW9uIHdhbGsgKHJvb3QsIGNiLCBpbW11dGFibGUpIHtcbiAgICB2YXIgcGF0aCA9IFtdO1xuICAgIHZhciBwYXJlbnRzID0gW107XG4gICAgdmFyIGFsaXZlID0gdHJ1ZTtcbiAgICBcbiAgICByZXR1cm4gKGZ1bmN0aW9uIHdhbGtlciAobm9kZV8pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBpbW11dGFibGUgPyBjb3B5KG5vZGVfKSA6IG5vZGVfO1xuICAgICAgICB2YXIgbW9kaWZpZXJzID0ge307XG4gICAgICAgIFxuICAgICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgICAgICBub2RlIDogbm9kZSxcbiAgICAgICAgICAgIG5vZGVfIDogbm9kZV8sXG4gICAgICAgICAgICBwYXRoIDogW10uY29uY2F0KHBhdGgpLFxuICAgICAgICAgICAgcGFyZW50IDogcGFyZW50cy5zbGljZSgtMSlbMF0sXG4gICAgICAgICAgICBrZXkgOiBwYXRoLnNsaWNlKC0xKVswXSxcbiAgICAgICAgICAgIGlzUm9vdCA6IHBhdGgubGVuZ3RoID09PSAwLFxuICAgICAgICAgICAgbGV2ZWwgOiBwYXRoLmxlbmd0aCxcbiAgICAgICAgICAgIGNpcmN1bGFyIDogbnVsbCxcbiAgICAgICAgICAgIHVwZGF0ZSA6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucGFyZW50Lm5vZGVbc3RhdGUua2V5XSA9IHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLm5vZGUgPSB4O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkZWxldGUnIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5wYXJlbnQubm9kZVtzdGF0ZS5rZXldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZS5wYXJlbnQubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucGFyZW50Lm5vZGUuc3BsaWNlKHN0YXRlLmtleSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGUucGFyZW50Lm5vZGVbc3RhdGUua2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmVmb3JlIDogZnVuY3Rpb24gKGYpIHsgbW9kaWZpZXJzLmJlZm9yZSA9IGYgfSxcbiAgICAgICAgICAgIGFmdGVyIDogZnVuY3Rpb24gKGYpIHsgbW9kaWZpZXJzLmFmdGVyID0gZiB9LFxuICAgICAgICAgICAgcHJlIDogZnVuY3Rpb24gKGYpIHsgbW9kaWZpZXJzLnByZSA9IGYgfSxcbiAgICAgICAgICAgIHBvc3QgOiBmdW5jdGlvbiAoZikgeyBtb2RpZmllcnMucG9zdCA9IGYgfSxcbiAgICAgICAgICAgIHN0b3AgOiBmdW5jdGlvbiAoKSB7IGFsaXZlID0gZmFsc2UgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgaWYgKCFhbGl2ZSkgcmV0dXJuIHN0YXRlO1xuICAgICAgICBcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZS5pc0xlYWYgPSBPYmplY3Qua2V5cyhub2RlKS5sZW5ndGggPT0gMDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudHNbaV0ubm9kZV8gPT09IG5vZGVfKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmNpcmN1bGFyID0gcGFyZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuaXNMZWFmID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc3RhdGUubm90TGVhZiA9ICFzdGF0ZS5pc0xlYWY7XG4gICAgICAgIHN0YXRlLm5vdFJvb3QgPSAhc3RhdGUuaXNSb290O1xuICAgICAgICBcbiAgICAgICAgLy8gdXNlIHJldHVybiB2YWx1ZXMgdG8gdXBkYXRlIGlmIGRlZmluZWRcbiAgICAgICAgdmFyIHJldCA9IGNiLmNhbGwoc3RhdGUsIHN0YXRlLm5vZGUpO1xuICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQgJiYgc3RhdGUudXBkYXRlKSBzdGF0ZS51cGRhdGUocmV0KTtcbiAgICAgICAgaWYgKG1vZGlmaWVycy5iZWZvcmUpIG1vZGlmaWVycy5iZWZvcmUuY2FsbChzdGF0ZSwgc3RhdGUubm9kZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAodHlwZW9mIHN0YXRlLm5vZGUgPT0gJ29iamVjdCdcbiAgICAgICAgJiYgc3RhdGUubm9kZSAhPT0gbnVsbCAmJiAhc3RhdGUuY2lyY3VsYXIpIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChzdGF0ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3RhdGUubm9kZSk7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaSkge1xuICAgICAgICAgICAgICAgIHBhdGgucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChtb2RpZmllcnMucHJlKSBtb2RpZmllcnMucHJlLmNhbGwoc3RhdGUsIHN0YXRlLm5vZGVba2V5XSwga2V5KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB3YWxrZXIoc3RhdGUubm9kZVtrZXldKTtcbiAgICAgICAgICAgICAgICBpZiAoaW1tdXRhYmxlICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLm5vZGUsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUubm9kZVtrZXldID0gY2hpbGQubm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY2hpbGQuaXNMYXN0ID0gaSA9PSBrZXlzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgY2hpbGQuaXNGaXJzdCA9IGkgPT0gMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXJzLnBvc3QpIG1vZGlmaWVycy5wb3N0LmNhbGwoc3RhdGUsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJlbnRzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAobW9kaWZpZXJzLmFmdGVyKSBtb2RpZmllcnMuYWZ0ZXIuY2FsbChzdGF0ZSwgc3RhdGUubm9kZSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSkocm9vdCkubm9kZTtcbn1cblxuT2JqZWN0LmtleXMoVHJhdmVyc2UucHJvdG90eXBlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBUcmF2ZXJzZVtrZXldID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgdmFyIHQgPSBUcmF2ZXJzZShvYmopO1xuICAgICAgICByZXR1cm4gdFtrZXldLmFwcGx5KHQsIGFyZ3MpO1xuICAgIH07XG59KTtcblxuZnVuY3Rpb24gY29weSAoc3JjKSB7XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdvYmplY3QnICYmIHNyYyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZHN0O1xuICAgICAgICBcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSkge1xuICAgICAgICAgICAgZHN0ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgZHN0ID0gbmV3IERhdGUoc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgQm9vbGVhbihzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICAgICAgZHN0ID0gbmV3IE51bWJlcihzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgZHN0ID0gbmV3IFN0cmluZyhzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHN0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc3JjKSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIE9iamVjdC5rZXlzKHNyYykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBkc3Rba2V5XSA9IHNyY1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRzdDtcbiAgICB9XG4gICAgZWxzZSByZXR1cm4gc3JjO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xudmFyIFRyYXZlcnNlID0gcmVxdWlyZSgndHJhdmVyc2UnKTtcblxuZnVuY3Rpb24gSGFzaCAoaGFzaCwgeHMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYXNoKSAmJiBBcnJheS5pc0FycmF5KHhzKSkge1xuICAgICAgICB2YXIgdG8gPSBNYXRoLm1pbihoYXNoLmxlbmd0aCwgeHMubGVuZ3RoKTtcbiAgICAgICAgdmFyIGFjYyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGFjY1toYXNoW2ldXSA9IHhzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBIYXNoKGFjYyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChoYXNoID09PSB1bmRlZmluZWQpIHJldHVybiBIYXNoKHt9KTtcbiAgICBcbiAgICB2YXIgc2VsZiA9IHtcbiAgICAgICAgbWFwIDogZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIHZhciBhY2MgPSB7IF9fcHJvdG9fXyA6IGhhc2guX19wcm90b19fIH07XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhoYXNoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IGYuY2FsbChzZWxmLCBoYXNoW2tleV0sIGtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBIYXNoKGFjYyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZvckVhY2ggOiBmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoaGFzaCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZi5jYWxsKHNlbGYsIGhhc2hba2V5XSwga2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbHRlciA6IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICB2YXIgYWNjID0geyBfX3Byb3RvX18gOiBoYXNoLl9fcHJvdG9fXyB9O1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoaGFzaCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGYuY2FsbChzZWxmLCBoYXNoW2tleV0sIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2tleV0gPSBoYXNoW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSGFzaChhY2MpO1xuICAgICAgICB9LFxuICAgICAgICBkZXRlY3QgOiBmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGhhc2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoZi5jYWxsKHNlbGYsIGhhc2hba2V5XSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzaFtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZHVjZSA6IGZ1bmN0aW9uIChmLCBhY2MpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoaGFzaCk7XG4gICAgICAgICAgICBpZiAoYWNjID09PSB1bmRlZmluZWQpIGFjYyA9IGtleXMuc2hpZnQoKTtcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgYWNjID0gZi5jYWxsKHNlbGYsIGFjYywgaGFzaFtrZXldLCBrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LFxuICAgICAgICBzb21lIDogZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBoYXNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGYuY2FsbChzZWxmLCBoYXNoW2tleV0sIGtleSkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGUgOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZUFsbChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzaFtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlQWxsIDogZnVuY3Rpb24gKHhzKSB7XG4gICAgICAgICAgICB4cy5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlKHgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyZ2UgOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jb3B5LnVwZGF0ZUFsbChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29weS51cGRhdGUob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWVyZ2VBbGwgOiBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNvcHkudXBkYXRlQWxsKHhzKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzIDogZnVuY3Rpb24gKGtleSkgeyAvLyBvbmx5IG9wZXJhdGVzIG9uIGVudW1lcmFibGVzXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShrZXkpXG4gICAgICAgICAgICAgICAgPyBrZXkuZXZlcnkoZnVuY3Rpb24gKGspIHsgcmV0dXJuIHNlbGYuaGFzKGspIH0pXG4gICAgICAgICAgICAgICAgOiBzZWxmLmtleXMuaW5kZXhPZihrZXkudG9TdHJpbmcoKSkgPj0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWVzQXQgOiBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoa2V5cylcbiAgICAgICAgICAgICAgICA/IGtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGhhc2hba2V5XSB9KVxuICAgICAgICAgICAgICAgIDogaGFzaFtrZXlzXVxuICAgICAgICAgICAgO1xuICAgICAgICB9LFxuICAgICAgICB0YXAgOiBmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgZi5jYWxsKHNlbGYsIGhhc2gpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH0sXG4gICAgICAgIGV4dHJhY3QgOiBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICAgICAgdmFyIGFjYyA9IHt9O1xuICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIEhhc2goYWNjKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXhjbHVkZSA6IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5maWx0ZXIoZnVuY3Rpb24gKF8sIGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmluZGV4T2Yoa2V5KSA8IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbmQgOiBoYXNoLFxuICAgICAgICBpdGVtcyA6IGhhc2hcbiAgICB9O1xuICAgIFxuICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAga2V5cyA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5rZXlzKGhhc2gpIH0sXG4gICAgICAgIHZhbHVlcyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhoYXNoKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gaGFzaFtrZXldIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjb21wYWN0IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICE9PSB1bmRlZmluZWQgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb25lIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gSGFzaChIYXNoLmNsb25lKGhhc2gpKSB9LFxuICAgICAgICBjb3B5IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gSGFzaChIYXNoLmNvcHkoaGFzaCkpIH0sXG4gICAgICAgIGxlbmd0aCA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5rZXlzKGhhc2gpLmxlbmd0aCB9LFxuICAgICAgICBzaXplIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5sZW5ndGggfVxuICAgIH07XG4gICAgXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICAvLyBlczUtc2hpbSBoYXMgYW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IGJ1dCBpdCB0aHJvd3MgZm9yIGdldHRlcnNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBrZXksIHsgZ2V0IDogcHJvcHNba2V5XSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnY2xvbmUnICYmIGtleSAhPT0gJ2NvcHknICYmIGtleSAhPT0gJ2NvbXBhY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIF4gdGhvc2Uga2V5cyB1c2UgSGFzaCgpIHNvIGNhbid0IGNhbGwgdGhlbSB3aXRob3V0XG4gICAgICAgICAgICAgICAgICAgIC8vIGEgc3RhY2sgb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICAgICAgc2VsZltrZXldID0gcHJvcHNba2V5XSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzZWxmLl9fZGVmaW5lR2V0dGVyX18pIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgICBzZWxmLl9fZGVmaW5lR2V0dGVyX18oa2V5LCBwcm9wc1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gbm9uLWxhenkgdmVyc2lvbiBmb3IgYnJvd3NlcnMgdGhhdCBzdWNrID5fPFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIHNlbGZba2V5XSA9IHByb3BzW2tleV0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gc2VsZjtcbn07XG5cbi8vIGRlZXAgY29weVxuSGFzaC5jbG9uZSA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgICByZXR1cm4gVHJhdmVyc2UuY2xvbmUocmVmKTtcbn07XG5cbi8vIHNoYWxsb3cgY29weVxuSGFzaC5jb3B5ID0gZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBoYXNoID0geyBfX3Byb3RvX18gOiByZWYuX19wcm90b19fIH07XG4gICAgT2JqZWN0LmtleXMocmVmKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaGFzaFtrZXldID0gcmVmW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIGhhc2g7XG59O1xuXG5IYXNoLm1hcCA9IGZ1bmN0aW9uIChyZWYsIGYpIHtcbiAgICByZXR1cm4gSGFzaChyZWYpLm1hcChmKS5pdGVtcztcbn07XG5cbkhhc2guZm9yRWFjaCA9IGZ1bmN0aW9uIChyZWYsIGYpIHtcbiAgICBIYXNoKHJlZikuZm9yRWFjaChmKTtcbn07XG5cbkhhc2guZmlsdGVyID0gZnVuY3Rpb24gKHJlZiwgZikge1xuICAgIHJldHVybiBIYXNoKHJlZikuZmlsdGVyKGYpLml0ZW1zO1xufTtcblxuSGFzaC5kZXRlY3QgPSBmdW5jdGlvbiAocmVmLCBmKSB7XG4gICAgcmV0dXJuIEhhc2gocmVmKS5kZXRlY3QoZik7XG59O1xuXG5IYXNoLnJlZHVjZSA9IGZ1bmN0aW9uIChyZWYsIGYsIGFjYykge1xuICAgIHJldHVybiBIYXNoKHJlZikucmVkdWNlKGYsIGFjYyk7XG59O1xuXG5IYXNoLnNvbWUgPSBmdW5jdGlvbiAocmVmLCBmKSB7XG4gICAgcmV0dXJuIEhhc2gocmVmKS5zb21lKGYpO1xufTtcblxuSGFzaC51cGRhdGUgPSBmdW5jdGlvbiAoYSAvKiwgYiwgYywgLi4uICovKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBoYXNoID0gSGFzaChhKTtcbiAgICByZXR1cm4gaGFzaC51cGRhdGUuYXBwbHkoaGFzaCwgYXJncykuaXRlbXM7XG59O1xuXG5IYXNoLm1lcmdlID0gZnVuY3Rpb24gKGEgLyosIGIsIGMsIC4uLiAqLykge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgaGFzaCA9IEhhc2goYSk7XG4gICAgcmV0dXJuIGhhc2gubWVyZ2UuYXBwbHkoaGFzaCwgYXJncykuaXRlbXM7XG59O1xuXG5IYXNoLmhhcyA9IGZ1bmN0aW9uIChyZWYsIGtleSkge1xuICAgIHJldHVybiBIYXNoKHJlZikuaGFzKGtleSk7XG59O1xuXG5IYXNoLnZhbHVlc0F0ID0gZnVuY3Rpb24gKHJlZiwga2V5cykge1xuICAgIHJldHVybiBIYXNoKHJlZikudmFsdWVzQXQoa2V5cyk7XG59O1xuXG5IYXNoLnRhcCA9IGZ1bmN0aW9uIChyZWYsIGYpIHtcbiAgICByZXR1cm4gSGFzaChyZWYpLnRhcChmKS5pdGVtcztcbn07XG5cbkhhc2guZXh0cmFjdCA9IGZ1bmN0aW9uIChyZWYsIGtleXMpIHtcbiAgICByZXR1cm4gSGFzaChyZWYpLmV4dHJhY3Qoa2V5cykuaXRlbXM7XG59O1xuXG5IYXNoLmV4Y2x1ZGUgPSBmdW5jdGlvbiAocmVmLCBrZXlzKSB7XG4gICAgcmV0dXJuIEhhc2gocmVmKS5leGNsdWRlKGtleXMpLml0ZW1zO1xufTtcblxuSGFzaC5jb25jYXQgPSBmdW5jdGlvbiAoeHMpIHtcbiAgICB2YXIgaGFzaCA9IEhhc2goe30pO1xuICAgIHhzLmZvckVhY2goZnVuY3Rpb24gKHgpIHsgaGFzaC51cGRhdGUoeCkgfSk7XG4gICAgcmV0dXJuIGhhc2guaXRlbXM7XG59O1xuXG5IYXNoLnppcCA9IGZ1bmN0aW9uICh4cywgeXMpIHtcbiAgICByZXR1cm4gSGFzaCh4cywgeXMpLml0ZW1zO1xufTtcblxuLy8gLmxlbmd0aCBpcyBhbHJlYWR5IGRlZmluZWQgZm9yIGZ1bmN0aW9uIHByb3RvdHlwZXNcbkhhc2guc2l6ZSA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgICByZXR1cm4gSGFzaChyZWYpLnNpemU7XG59O1xuXG5IYXNoLmNvbXBhY3QgPSBmdW5jdGlvbiAocmVmKSB7XG4gICAgcmV0dXJuIEhhc2gocmVmKS5jb21wYWN0Lml0ZW1zO1xufTtcbiIsInZhciB0cmF2ZXJzZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBuZXcgVHJhdmVyc2Uob2JqKTtcbn07XG5cbmZ1bmN0aW9uIFRyYXZlcnNlIChvYmopIHtcbiAgICB0aGlzLnZhbHVlID0gb2JqO1xufVxuXG5UcmF2ZXJzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBzKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHMubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBwc1tpXTtcbiAgICAgICAgaWYgKCFub2RlIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGUsIGtleSkpIHtcbiAgICAgICAgICAgIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAocHMpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMudmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHBzW2ldO1xuICAgICAgICBpZiAoIW5vZGUgfHwgIWhhc093blByb3BlcnR5LmNhbGwobm9kZSwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChwcywgdmFsdWUpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMudmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcy5sZW5ndGggLSAxOyBpICsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBwc1tpXTtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGUsIGtleSkpIG5vZGVba2V5XSA9IHt9O1xuICAgICAgICBub2RlID0gbm9kZVtrZXldO1xuICAgIH1cbiAgICBub2RlW3BzW2ldXSA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICByZXR1cm4gd2Fsayh0aGlzLnZhbHVlLCBjYiwgdHJ1ZSk7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYikge1xuICAgIHRoaXMudmFsdWUgPSB3YWxrKHRoaXMudmFsdWUsIGNiLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGNiLCBpbml0KSB7XG4gICAgdmFyIHNraXAgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxO1xuICAgIHZhciBhY2MgPSBza2lwID8gdGhpcy52YWx1ZSA6IGluaXQ7XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1Jvb3QgfHwgIXNraXApIHtcbiAgICAgICAgICAgIGFjYyA9IGNiLmNhbGwodGhpcywgYWNjLCB4KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhY2M7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUucGF0aHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFjYyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBhY2MucHVzaCh0aGlzLnBhdGgpOyBcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLm5vZGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhY2MgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgYWNjLnB1c2godGhpcy5ub2RlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnRzID0gW10sIG5vZGVzID0gW107XG4gICAgXG4gICAgcmV0dXJuIChmdW5jdGlvbiBjbG9uZSAoc3JjKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHBhcmVudHNbaV0gPT09IHNyYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2Rlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICdvYmplY3QnICYmIHNyYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGRzdCA9IGNvcHkoc3JjKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcGFyZW50cy5wdXNoKHNyYyk7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKGRzdCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvckVhY2gob2JqZWN0S2V5cyhzcmMpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHN0W2tleV0gPSBjbG9uZShzcmNba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcGFyZW50cy5wb3AoKTtcbiAgICAgICAgICAgIG5vZGVzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIGRzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzcmM7XG4gICAgICAgIH1cbiAgICB9KSh0aGlzLnZhbHVlKTtcbn07XG5cbmZ1bmN0aW9uIHdhbGsgKHJvb3QsIGNiLCBpbW11dGFibGUpIHtcbiAgICB2YXIgcGF0aCA9IFtdO1xuICAgIHZhciBwYXJlbnRzID0gW107XG4gICAgdmFyIGFsaXZlID0gdHJ1ZTtcbiAgICBcbiAgICByZXR1cm4gKGZ1bmN0aW9uIHdhbGtlciAobm9kZV8pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBpbW11dGFibGUgPyBjb3B5KG5vZGVfKSA6IG5vZGVfO1xuICAgICAgICB2YXIgbW9kaWZpZXJzID0ge307XG4gICAgICAgIFxuICAgICAgICB2YXIga2VlcEdvaW5nID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICAgIG5vZGUgOiBub2RlLFxuICAgICAgICAgICAgbm9kZV8gOiBub2RlXyxcbiAgICAgICAgICAgIHBhdGggOiBbXS5jb25jYXQocGF0aCksXG4gICAgICAgICAgICBwYXJlbnQgOiBwYXJlbnRzW3BhcmVudHMubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBwYXJlbnRzIDogcGFyZW50cyxcbiAgICAgICAgICAgIGtleSA6IHBhdGguc2xpY2UoLTEpWzBdLFxuICAgICAgICAgICAgaXNSb290IDogcGF0aC5sZW5ndGggPT09IDAsXG4gICAgICAgICAgICBsZXZlbCA6IHBhdGgubGVuZ3RoLFxuICAgICAgICAgICAgY2lyY3VsYXIgOiBudWxsLFxuICAgICAgICAgICAgdXBkYXRlIDogZnVuY3Rpb24gKHgsIHN0b3BIZXJlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucGFyZW50Lm5vZGVbc3RhdGUua2V5XSA9IHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLm5vZGUgPSB4O1xuICAgICAgICAgICAgICAgIGlmIChzdG9wSGVyZSkga2VlcEdvaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2RlbGV0ZScgOiBmdW5jdGlvbiAoc3RvcEhlcmUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGUucGFyZW50Lm5vZGVbc3RhdGUua2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcEhlcmUpIGtlZXBHb2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZSA6IGZ1bmN0aW9uIChzdG9wSGVyZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHN0YXRlLnBhcmVudC5ub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wYXJlbnQubm9kZS5zcGxpY2Uoc3RhdGUua2V5LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5wYXJlbnQubm9kZVtzdGF0ZS5rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RvcEhlcmUpIGtlZXBHb2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtleXMgOiBudWxsLFxuICAgICAgICAgICAgYmVmb3JlIDogZnVuY3Rpb24gKGYpIHsgbW9kaWZpZXJzLmJlZm9yZSA9IGYgfSxcbiAgICAgICAgICAgIGFmdGVyIDogZnVuY3Rpb24gKGYpIHsgbW9kaWZpZXJzLmFmdGVyID0gZiB9LFxuICAgICAgICAgICAgcHJlIDogZnVuY3Rpb24gKGYpIHsgbW9kaWZpZXJzLnByZSA9IGYgfSxcbiAgICAgICAgICAgIHBvc3QgOiBmdW5jdGlvbiAoZikgeyBtb2RpZmllcnMucG9zdCA9IGYgfSxcbiAgICAgICAgICAgIHN0b3AgOiBmdW5jdGlvbiAoKSB7IGFsaXZlID0gZmFsc2UgfSxcbiAgICAgICAgICAgIGJsb2NrIDogZnVuY3Rpb24gKCkgeyBrZWVwR29pbmcgPSBmYWxzZSB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBpZiAoIWFsaXZlKSByZXR1cm4gc3RhdGU7XG4gICAgICAgIFxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVTdGF0ZSgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGUubm9kZSA9PT0gJ29iamVjdCcgJiYgc3RhdGUubm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICghc3RhdGUua2V5cyB8fCBzdGF0ZS5ub2RlXyAhPT0gc3RhdGUubm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5rZXlzID0gb2JqZWN0S2V5cyhzdGF0ZS5ub2RlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc0xlYWYgPSBzdGF0ZS5rZXlzLmxlbmd0aCA9PSAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50c1tpXS5ub2RlXyA9PT0gbm9kZV8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNpcmN1bGFyID0gcGFyZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuaXNMZWFmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5rZXlzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3RhdGUubm90TGVhZiA9ICFzdGF0ZS5pc0xlYWY7XG4gICAgICAgICAgICBzdGF0ZS5ub3RSb290ID0gIXN0YXRlLmlzUm9vdDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdXBkYXRlU3RhdGUoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIHVzZSByZXR1cm4gdmFsdWVzIHRvIHVwZGF0ZSBpZiBkZWZpbmVkXG4gICAgICAgIHZhciByZXQgPSBjYi5jYWxsKHN0YXRlLCBzdGF0ZS5ub2RlKTtcbiAgICAgICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkICYmIHN0YXRlLnVwZGF0ZSkgc3RhdGUudXBkYXRlKHJldCk7XG4gICAgICAgIFxuICAgICAgICBpZiAobW9kaWZpZXJzLmJlZm9yZSkgbW9kaWZpZXJzLmJlZm9yZS5jYWxsKHN0YXRlLCBzdGF0ZS5ub2RlKTtcbiAgICAgICAgXG4gICAgICAgIGlmICgha2VlcEdvaW5nKSByZXR1cm4gc3RhdGU7XG4gICAgICAgIFxuICAgICAgICBpZiAodHlwZW9mIHN0YXRlLm5vZGUgPT0gJ29iamVjdCdcbiAgICAgICAgJiYgc3RhdGUubm9kZSAhPT0gbnVsbCAmJiAhc3RhdGUuY2lyY3VsYXIpIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChzdGF0ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvckVhY2goc3RhdGUua2V5cywgZnVuY3Rpb24gKGtleSwgaSkge1xuICAgICAgICAgICAgICAgIHBhdGgucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChtb2RpZmllcnMucHJlKSBtb2RpZmllcnMucHJlLmNhbGwoc3RhdGUsIHN0YXRlLm5vZGVba2V5XSwga2V5KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB3YWxrZXIoc3RhdGUubm9kZVtrZXldKTtcbiAgICAgICAgICAgICAgICBpZiAoaW1tdXRhYmxlICYmIGhhc093blByb3BlcnR5LmNhbGwoc3RhdGUubm9kZSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5ub2RlW2tleV0gPSBjaGlsZC5ub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjaGlsZC5pc0xhc3QgPSBpID09IHN0YXRlLmtleXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBjaGlsZC5pc0ZpcnN0ID0gaSA9PSAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChtb2RpZmllcnMucG9zdCkgbW9kaWZpZXJzLnBvc3QuY2FsbChzdGF0ZSwgY2hpbGQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHBhdGgucG9wKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhcmVudHMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChtb2RpZmllcnMuYWZ0ZXIpIG1vZGlmaWVycy5hZnRlci5jYWxsKHN0YXRlLCBzdGF0ZS5ub2RlKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9KShyb290KS5ub2RlO1xufVxuXG5mdW5jdGlvbiBjb3B5IChzcmMpIHtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ29iamVjdCcgJiYgc3JjICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBkc3Q7XG4gICAgICAgIFxuICAgICAgICBpZiAoaXNBcnJheShzcmMpKSB7XG4gICAgICAgICAgICBkc3QgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0RhdGUoc3JjKSkge1xuICAgICAgICAgICAgZHN0ID0gbmV3IERhdGUoc3JjLmdldFRpbWUgPyBzcmMuZ2V0VGltZSgpIDogc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1JlZ0V4cChzcmMpKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgUmVnRXhwKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFcnJvcihzcmMpKSB7XG4gICAgICAgICAgICBkc3QgPSB7IG1lc3NhZ2U6IHNyYy5tZXNzYWdlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCb29sZWFuKHNyYykpIHtcbiAgICAgICAgICAgIGRzdCA9IG5ldyBCb29sZWFuKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNOdW1iZXIoc3JjKSkge1xuICAgICAgICAgICAgZHN0ID0gbmV3IE51bWJlcihzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU3RyaW5nKHNyYykpIHtcbiAgICAgICAgICAgIGRzdCA9IG5ldyBTdHJpbmcoc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChPYmplY3QuY3JlYXRlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgICAgZHN0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc3JjKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3JjLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIGRzdCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByb3RvID1cbiAgICAgICAgICAgICAgICAoc3JjLmNvbnN0cnVjdG9yICYmIHNyYy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpXG4gICAgICAgICAgICAgICAgfHwgc3JjLl9fcHJvdG9fX1xuICAgICAgICAgICAgICAgIHx8IHt9XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICB2YXIgVCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgVC5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgICAgICAgIGRzdCA9IG5ldyBUO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBmb3JFYWNoKG9iamVjdEtleXMoc3JjKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgZHN0W2tleV0gPSBzcmNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkc3Q7XG4gICAgfVxuICAgIGVsc2UgcmV0dXJuIHNyYztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzIChvYmopIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgcmVzLnB1c2goa2V5KVxuICAgIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiB0b1MgKG9iaikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgfVxuZnVuY3Rpb24gaXNEYXRlIChvYmopIHsgcmV0dXJuIHRvUyhvYmopID09PSAnW29iamVjdCBEYXRlXScgfVxuZnVuY3Rpb24gaXNSZWdFeHAgKG9iaikgeyByZXR1cm4gdG9TKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nIH1cbmZ1bmN0aW9uIGlzRXJyb3IgKG9iaikgeyByZXR1cm4gdG9TKG9iaikgPT09ICdbb2JqZWN0IEVycm9yXScgfVxuZnVuY3Rpb24gaXNCb29sZWFuIChvYmopIHsgcmV0dXJuIHRvUyhvYmopID09PSAnW29iamVjdCBCb29sZWFuXScgfVxuZnVuY3Rpb24gaXNOdW1iZXIgKG9iaikgeyByZXR1cm4gdG9TKG9iaikgPT09ICdbb2JqZWN0IE51bWJlcl0nIH1cbmZ1bmN0aW9uIGlzU3RyaW5nIChvYmopIHsgcmV0dXJuIHRvUyhvYmopID09PSAnW29iamVjdCBTdHJpbmddJyB9XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5ICh4cykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoeHMsIGZuKSB7XG4gICAgaWYgKHhzLmZvckVhY2gpIHJldHVybiB4cy5mb3JFYWNoKGZuKVxuICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbih4c1tpXSwgaSwgeHMpO1xuICAgIH1cbn07XG5cbmZvckVhY2gob2JqZWN0S2V5cyhUcmF2ZXJzZS5wcm90b3R5cGUpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdHJhdmVyc2Vba2V5XSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHZhciB0ID0gbmV3IFRyYXZlcnNlKG9iaik7XG4gICAgICAgIHJldHVybiB0W2tleV0uYXBwbHkodCwgYXJncyk7XG4gICAgfTtcbn0pO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QuaGFzT3duUHJvcGVydHkgfHwgZnVuY3Rpb24gKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIGtleSBpbiBvYmo7XG59O1xuIiwiLyoqXG4gKiBAcHJlc2VydmUgQ29weXJpZ2h0IDIwMTIgUm9iZXJ0IEd1c3QtQmFyZG9uIDxodHRwOi8vcm9iZXJ0Lmd1c3QtYmFyZG9uLm9yZy8+LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICogYXJlIG1ldDpcbiAqXG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gKiAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgICAgZGlzY2xhaW1lci5cbiAqXG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gKiAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiBcIkFTIElTXCIgQU5EIEFOWVxuICogRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICogUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAqIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAqIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAqIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICogVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gKiBTVUNIIERBTUFHRS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRW5oYW5jZXMgPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMvXCJcbiAqID5VZ2xpZnlKUzwvYT4gd2l0aCBjb25zb2xpZGF0aW9uIG9mIG51bGwsIEJvb2xlYW4sIGFuZCBTdHJpbmcgdmFsdWVzLlxuICogPHA+QWxzbyBrbm93biBhcyBhbGlhc2luZywgdGhpcyBmZWF0dXJlIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gPGEgaHJlZj1cbiAqIFwiaHR0cDovL2Nsb3N1cmUtY29tcGlsZXIuZ29vZ2xlY29kZS5jb20vXCI+dGhlIENsb3N1cmUgQ29tcGlsZXI8L2E+IHNpbmNlIGl0c1xuICogaW5pdGlhbCByZWxlYXNlLCB3aGVyZSBpdCBpcyB1bmF2YWlsYWJsZSBmcm9tIHRoZSA8YWJiciB0aXRsZT1cbiAqIFwiY29tbWFuZCBsaW5lIGludGVyZmFjZVwiPkNMSTwvYT4uIFRoZSBDbG9zdXJlIENvbXBpbGVyIGFsbG93cyBvbmUgdG8gbG9nIGFuZFxuICogaW5mbHVlbmNlIHRoaXMgcHJvY2Vzcy4gSW4gY29udHJhc3QsIHRoaXMgaW1wbGVtZW50YXRpb24gZG9lcyBub3QgaW50cm9kdWNlXG4gKiBhbnkgdmFyaWFibGUgZGVjbGFyYXRpb25zIGluIGdsb2JhbCBjb2RlIGFuZCBkZXJpdmVzIFN0cmluZyB2YWx1ZXMgZnJvbVxuICogaWRlbnRpZmllciBuYW1lcyB1c2VkIGFzIHByb3BlcnR5IGFjY2Vzc29ycy48L3A+XG4gKiA8cD5Db25zb2xpZGF0aW5nIGxpdGVyYWxzIG1heSB3b3JzZW4gdGhlIGRhdGEgY29tcHJlc3Npb24gcmF0aW8gd2hlbiBhbiA8YVxuICogaHJlZj1cImh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI2MTYjc2VjdGlvbi0zLjVcIj5lbmNvZGluZ1xuICogdHJhbnNmb3JtYXRpb248L2E+IGlzIGFwcGxpZWQuIEZvciBpbnN0YW5jZSwgPGEgaHJlZj1cbiAqIFwiaHR0cDovL2NvZGUuanF1ZXJ5LmNvbS9qcXVlcnktMS43LjEuanNcIj5qUXVlcnkgMS43LjE8L2E+IHRha2VzIDI0ODIzNSBieXRlcy5cbiAqIEJ1aWxkaW5nIGl0IHdpdGggPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMvdGFyYmFsbC92MS4yLjVcIj5cbiAqIFVnbGlmeUpTIHYxLjIuNTwvYT4gcmVzdWx0cyBpbiA5MzY0NyBieXRlcyAoMzcuNzMlIG9mIHRoZSBvcmlnaW5hbCkgd2hpY2ggYXJlXG4gKiB0aGVuIGNvbXByZXNzZWQgdG8gMzMxNTQgYnl0ZXMgKDEzLjM2JSBvZiB0aGUgb3JpZ2luYWwpIHVzaW5nIDxhIGhyZWY9XG4gKiBcImh0dHA6Ly9saW51eC5kaWUubmV0L21hbi8xL2d6aXBcIj5nemlwKDEpPC9hPi4gQnVpbGRpbmcgaXQgd2l0aCB0aGUgc2FtZVxuICogdmVyc2lvbiBvZiBVZ2xpZnlKUyAxLjIuNSBwYXRjaGVkIHdpdGggdGhlIGltcGxlbWVudGF0aW9uIG9mIGNvbnNvbGlkYXRpb25cbiAqIHJlc3VsdHMgaW4gODA3ODQgYnl0ZXMgKGEgZGVjcmVhc2Ugb2YgMTI4NjMgYnl0ZXMsIGkuZS4gMTMuNzQlLCBpbiBjb21wYXJpc29uXG4gKiB0byB0aGUgYWZvcmVtZW50aW9uZWQgOTM2NDcgYnl0ZXMpIHdoaWNoIGFyZSB0aGVuIGNvbXByZXNzZWQgdG8gMzQwMTMgYnl0ZXNcbiAqIChhbiBpbmNyZWFzZSBvZiA4NTkgYnl0ZXMsIGkuZS4gMi41OSUsIGluIGNvbXBhcmlzb24gdG8gdGhlIGFmb3JlbWVudGlvbmVkXG4gKiAzMzE1NCBieXRlcykuPC9wPlxuICogPHA+V3JpdHRlbiBpbiA8YSBocmVmPVwiaHR0cDovL2VzNS5naXRodWIuY29tLyN4NC4yLjJcIj50aGUgc3RyaWN0IHZhcmlhbnQ8L2E+XG4gKiBvZiA8YSBocmVmPVwiaHR0cDovL2VzNS5naXRodWIuY29tL1wiPkVDTUEtMjYyIDUuMSBFZGl0aW9uPC9hPi4gRW5jb2RlZCBpbiA8YVxuICogaHJlZj1cImh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM2MjlcIj5VVEYtODwvYT4uIEZvbGxvd3MgPGEgaHJlZj1cbiAqIFwiaHR0cDovL2dvb2dsZS1zdHlsZWd1aWRlLmdvb2dsZWNvZGUuY29tL3N2bi1oaXN0b3J5L3I3Ni90cnVuay9qYXZhc2NyaXB0Z3VpZGUueG1sXCJcbiAqID5SZXZpc2lvbiAyLjI4IG9mIHRoZSBHb29nbGUgSmF2YVNjcmlwdCBTdHlsZSBHdWlkZTwvYT4gKGV4Y2VwdCBmb3IgdGhlXG4gKiBkaXNjb3VyYWdlZCB1c2Ugb2YgdGhlIHtAY29kZSBmdW5jdGlvbn0gdGFnIGFuZCB0aGUge0Bjb2RlIG5hbWVzcGFjZX0gdGFnKS5cbiAqIDEwMCUgdHlwZWQgZm9yIHRoZSA8YSBocmVmPVxuICogXCJodHRwOi8vY2xvc3VyZS1jb21waWxlci5nb29nbGVjb2RlLmNvbS9maWxlcy9jb21waWxlci0yMDEyMDEyMy50YXIuZ3pcIlxuICogPkNsb3N1cmUgQ29tcGlsZXIgVmVyc2lvbiAxNzQxPC9hPi48L3A+XG4gKiA8cD5TaG91bGQgeW91IGZpbmQgdGhpcyBzb2Z0d2FyZSB1c2VmdWwsIHBsZWFzZSBjb25zaWRlciA8YSBocmVmPVxuICogXCJodHRwczovL3BheXBhbC5jb20vY2dpLWJpbi93ZWJzY3I/Y21kPV9zLXhjbGljayZob3N0ZWRfYnV0dG9uX2lkPUpaTFc3Mlg4RkQ0V0dcIlxuICogPmEgZG9uYXRpb248L2E+LjwvcD5cbiAqIEBhdXRob3IgZm9sbG93Lm1lQFJHdXN0QmFyZG9uIChSb2JlcnQgR3VzdC1CYXJkb24pXG4gKiBAc3VwcG9ydGVkIFRlc3RlZCB3aXRoOlxuICogICAgIDx1bD5cbiAqICAgICA8bGk+PGEgaHJlZj1cImh0dHA6Ly9ub2RlanMub3JnL2Rpc3QvdjAuNi4xMC9cIj5Ob2RlIHYwLjYuMTA8L2E+LDwvbGk+XG4gKiAgICAgPGxpPjxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTL3RhcmJhbGwvdjEuMi41XCI+VWdsaWZ5SlNcbiAqICAgICAgIHYxLjIuNTwvYT4uPC9saT5cbiAqICAgICA8L3VsPlxuICovXG5cbi8qZ2xvYmFsIGNvbnNvbGU6ZmFsc2UsIGV4cG9ydHM6dHJ1ZSwgbW9kdWxlOmZhbHNlLCByZXF1aXJlOmZhbHNlICovXG4vKmpzaGludCBzdWI6dHJ1ZSAqL1xuLyoqXG4gKiBDb25zb2xpZGF0ZXMgbnVsbCwgQm9vbGVhbiwgYW5kIFN0cmluZyB2YWx1ZXMgZm91bmQgaW5zaWRlIGFuIDxhYmJyIHRpdGxlPVxuICogXCJhYnN0cmFjdCBzeW50YXggdHJlZVwiPkFTVDwvYWJicj4uXG4gKiBAcGFyYW0geyFUU3ludGFjdGljQ29kZVVuaXR9IG9BYnN0cmFjdFN5bnRheFRyZWUgQW4gYXJyYXktbGlrZSBvYmplY3RcbiAqICAgICByZXByZXNlbnRpbmcgYW4gPGFiYnIgdGl0bGU9XCJhYnN0cmFjdCBzeW50YXggdHJlZVwiPkFTVDwvYWJicj4uXG4gKiBAcmV0dXJuIHshVFN5bnRhY3RpY0NvZGVVbml0fSBBbiBhcnJheS1saWtlIG9iamVjdCByZXByZXNlbnRpbmcgYW4gPGFiYnJcbiAqICAgICB0aXRsZT1cImFic3RyYWN0IHN5bnRheCB0cmVlXCI+QVNUPC9hYmJyPiB3aXRoIGl0cyBudWxsLCBCb29sZWFuLCBhbmRcbiAqICAgICBTdHJpbmcgdmFsdWVzIGNvbnNvbGlkYXRlZC5cbiAqL1xuLy8gVE9ETyh1c2VyKSBDb25zb2xpZGF0aW9uIG9mIG1hdGhlbWF0aWNhbCB2YWx1ZXMgZm91bmQgaW4gbnVtZXJpYyBsaXRlcmFscy5cbi8vIFRPRE8odXNlcikgVW5jb25zb2xpZGF0aW9uLlxuLy8gVE9ETyh1c2VyKSBDb25zb2xpZGF0aW9uIG9mIEVDTUEtMjYyIDZ0aCBFZGl0aW9uIHByb2dyYW1zLlxuLy8gVE9ETyh1c2VyKSBSZXdyaXRlIGluIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLlxuZXhwb3J0c1snYXN0X2NvbnNvbGlkYXRlJ10gPSBmdW5jdGlvbihvQWJzdHJhY3RTeW50YXhUcmVlKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLypqc2hpbnQgYml0d2lzZTp0cnVlLCBjdXJseTp0cnVlLCBlcWVxZXE6dHJ1ZSwgZm9yaW46dHJ1ZSwgaW1tZWQ6dHJ1ZSxcbiAgICAgICAgbGF0ZWRlZjp0cnVlLCBuZXdjYXA6dHJ1ZSwgbm9hcmdlOnRydWUsIG5vZW1wdHk6dHJ1ZSwgbm9uZXc6dHJ1ZSxcbiAgICAgICAgb25ldmFyOnRydWUsIHBsdXNwbHVzOnRydWUsIHJlZ2V4cDp0cnVlLCB1bmRlZjp0cnVlLCBzdHJpY3Q6dHJ1ZSxcbiAgICAgICAgc3ViOmZhbHNlLCB0cmFpbGluZzp0cnVlICovXG5cbiAgdmFyIF8sXG4gICAgICAvKipcbiAgICAgICAqIEEgcmVjb3JkIGNvbnNpc3Rpbmcgb2YgZGF0YSBhYm91dCBvbmUgb3IgbW9yZSBzb3VyY2UgZWxlbWVudHMuXG4gICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAqIEBub3NpZGVlZmZlY3RzXG4gICAgICAgKi9cbiAgICAgIFRTb3VyY2VFbGVtZW50c0RhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjYXRlZ29yeSBvZiB0aGUgZWxlbWVudHMuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBzZWUgRVNvdXJjZUVsZW1lbnRDYXRlZ29yaWVzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5DYXRlZ29yeSA9IEVTb3VyY2VFbGVtZW50Q2F0ZWdvcmllcy5OX09USEVSO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBvY2N1cnJlbmNlcyAod2l0aGluIHRoZSBlbGVtZW50cykgb2YgZWFjaCBwcmltaXRpdmVcbiAgICAgICAgICogdmFsdWUgdGhhdCBjb3VsZCBiZSBjb25zb2xpZGF0ZWQuXG4gICAgICAgICAqIEB0eXBlIHshQXJyYXkuPCFPYmplY3QuPHN0cmluZywgbnVtYmVyPj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFDb3VudCA9IFtdO1xuICAgICAgICB0aGlzLmFDb3VudFtFUHJpbWFyeUV4cHJlc3Npb25DYXRlZ29yaWVzLk5fSURFTlRJRklFUl9OQU1FU10gPSB7fTtcbiAgICAgICAgdGhpcy5hQ291bnRbRVByaW1hcnlFeHByZXNzaW9uQ2F0ZWdvcmllcy5OX1NUUklOR19MSVRFUkFMU10gPSB7fTtcbiAgICAgICAgdGhpcy5hQ291bnRbRVByaW1hcnlFeHByZXNzaW9uQ2F0ZWdvcmllcy5OX05VTExfQU5EX0JPT0xFQU5fTElURVJBTFNdID1cbiAgICAgICAgICAgIHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSWRlbnRpZmllciBuYW1lcyBmb3VuZCB3aXRoaW4gdGhlIGVsZW1lbnRzLlxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5LjxzdHJpbmc+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hSWRlbnRpZmllcnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByZWZpeGVkIHJlcHJlc2VudGF0aW9uIFN0cmluZ3Mgb2YgZWFjaCBwcmltaXRpdmUgdmFsdWUgdGhhdCBjb3VsZCBiZVxuICAgICAgICAgKiBjb25zb2xpZGF0ZWQgd2l0aGluIHRoZSBlbGVtZW50cy5cbiAgICAgICAgICogQHR5cGUgeyFBcnJheS48c3RyaW5nPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYVByaW1pdGl2ZVZhbHVlcyA9IFtdO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogQSByZWNvcmQgY29uc2lzdGluZyBvZiBkYXRhIGFib3V0IGEgcHJpbWl0aXZlIHZhbHVlIHRoYXQgY291bGQgYmVcbiAgICAgICAqIGNvbnNvbGlkYXRlZC5cbiAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICogQG5vc2lkZWVmZmVjdHNcbiAgICAgICAqL1xuICAgICAgVFByaW1pdGl2ZVZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGlmZmVyZW5jZSBpbiB0aGUgbnVtYmVyIG9mIHRlcm1pbmFsIHN5bWJvbHMgYmV0d2VlbiB0aGUgb3JpZ2luYWxcbiAgICAgICAgICogc291cmNlIHRleHQgYW5kIHRoZSBvbmUgd2l0aCB0aGUgcHJpbWl0aXZlIHZhbHVlIGNvbnNvbGlkYXRlZC4gSWYgdGhlXG4gICAgICAgICAqIGRpZmZlcmVuY2UgaXMgcG9zaXRpdmUsIHRoZSBwcmltaXRpdmUgdmFsdWUgaXMgY29uc2lkZXJlZCB3b3J0aHdoaWxlLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uU2F2aW5nID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGlkZW50aWZpZXIgbmFtZSBvZiB0aGUgdmFyaWFibGUgdGhhdCB3aWxsIGJlIGRlY2xhcmVkIGFuZCBhc3NpZ25lZFxuICAgICAgICAgKiB0aGUgcHJpbWl0aXZlIHZhbHVlIGlmIHRoZSBwcmltaXRpdmUgdmFsdWUgaXMgY29uc29saWRhdGVkLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zTmFtZSA9ICcnO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogQSByZWNvcmQgY29uc2lzdGluZyBvZiBkYXRhIG9uIHdoYXQgdG8gY29uc29saWRhdGUgd2l0aGluIHRoZSByYW5nZSBvZlxuICAgICAgICogc291cmNlIGVsZW1lbnRzIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIGNvbnNpZGVyZWQuXG4gICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAqIEBub3NpZGVlZmZlY3RzXG4gICAgICAgKi9cbiAgICAgIFRTb2x1dGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb2JqZWN0IHdob3NlIGtleXMgYXJlIHByZWZpeGVkIHJlcHJlc2VudGF0aW9uIFN0cmluZ3Mgb2YgZWFjaFxuICAgICAgICAgKiBwcmltaXRpdmUgdmFsdWUgdGhhdCBjb3VsZCBiZSBjb25zb2xpZGF0ZWQgd2l0aGluIHRoZSBlbGVtZW50cyBhbmRcbiAgICAgICAgICogd2hvc2UgdmFsdWVzIGFyZSBjb3JyZXNwb25kaW5nIGRhdGEgYWJvdXQgdGhvc2UgcHJpbWl0aXZlIHZhbHVlcy5cbiAgICAgICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywge25TYXZpbmc6IG51bWJlciwgc05hbWU6IHN0cmluZ30+fVxuICAgICAgICAgKiBAc2VlIFRQcmltaXRpdmVWYWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vUHJpbWl0aXZlVmFsdWVzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGlmZmVyZW5jZSBpbiB0aGUgbnVtYmVyIG9mIHRlcm1pbmFsIHN5bWJvbHMgYmV0d2VlbiB0aGUgb3JpZ2luYWxcbiAgICAgICAgICogc291cmNlIHRleHQgYW5kIHRoZSBvbmUgd2l0aCBhbGwgdGhlIHdvcnRod2hpbGUgcHJpbWl0aXZlIHZhbHVlc1xuICAgICAgICAgKiBjb25zb2xpZGF0ZWQuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBzZWUgVFByaW1pdGl2ZVZhbHVlI25TYXZpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMublNhdmluZ3MgPSAwO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHByb2Nlc3NvciBvZiA8YWJiciB0aXRsZT1cImFic3RyYWN0IHN5bnRheCB0cmVlXCI+QVNUPC9hYmJyPnMgZm91bmRcbiAgICAgICAqIGluIFVnbGlmeUpTLlxuICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICogQHR5cGUgeyFUUHJvY2Vzc29yfVxuICAgICAgICovXG4gICAgICBvUHJvY2Vzc29yID0gKC8qKiBAdHlwZSB7IVRQcm9jZXNzb3J9ICovIHJlcXVpcmUoJy4vcHJvY2VzcycpKSxcbiAgICAgIC8qKlxuICAgICAgICogQSByZWNvcmQgY29uc2lzdGluZyBvZiBhIG51bWJlciBvZiBjb25zdGFudHMgdGhhdCByZXByZXNlbnQgdGhlXG4gICAgICAgKiBkaWZmZXJlbmNlIGluIHRoZSBudW1iZXIgb2YgdGVybWluYWwgc3ltYm9scyBiZXR3ZWVuIGEgc291cmNlIHRleHQgd2l0aFxuICAgICAgICogYSBtb2RpZmllZCBzeW50YWN0aWMgY29kZSB1bml0IGFuZCB0aGUgb3JpZ2luYWwgb25lLlxuICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgbnVtYmVyPn1cbiAgICAgICAqL1xuICAgICAgb1dlaWdodHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGlmZmVyZW5jZSBpbiB0aGUgbnVtYmVyIG9mIHB1bmN0dWF0b3JzIHJlcXVpcmVkIGJ5IHRoZSBicmFja2V0XG4gICAgICAgICAqIG5vdGF0aW9uIGFuZCB0aGUgZG90IG5vdGF0aW9uLlxuICAgICAgICAgKiA8cD48Y29kZT4nW10nLmxlbmd0aCAtICcuJy5sZW5ndGg8L2NvZGU+PC9wPlxuICAgICAgICAgKiBAY29uc3RcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIE5fUFJPUEVSVFlfQUNDRVNTT1I6IDEsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHB1bmN0dWF0b3JzIHJlcXVpcmVkIGJ5IGEgdmFyaWFibGUgZGVjbGFyYXRpb24gd2l0aCBhblxuICAgICAgICAgKiBpbml0aWFsaXNlci5cbiAgICAgICAgICogPHA+PGNvZGU+JzonLmxlbmd0aCArICc7Jy5sZW5ndGg8L2NvZGU+PC9wPlxuICAgICAgICAgKiBAY29uc3RcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIE5fVkFSSUFCTEVfREVDTEFSQVRJT046IDIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHRlcm1pbmFsIHN5bWJvbHMgcmVxdWlyZWQgdG8gaW50cm9kdWNlIGEgdmFyaWFibGVcbiAgICAgICAgICogc3RhdGVtZW50IChleGNsdWRpbmcgaXRzIHZhcmlhYmxlIGRlY2xhcmF0aW9uIGxpc3QpLlxuICAgICAgICAgKiA8cD48Y29kZT4ndmFyICcubGVuZ3RoPC9jb2RlPjwvcD5cbiAgICAgICAgICogQGNvbnN0XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBOX1ZBUklBQkxFX1NUQVRFTUVOVF9BRkZJWEFUSU9OOiA0LFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiB0ZXJtaW5hbCBzeW1ib2xzIG5lZWRlZCB0byBlbmNsb3NlIHNvdXJjZSBlbGVtZW50c1xuICAgICAgICAgKiB3aXRoaW4gYSBmdW5jdGlvbiBjYWxsIHdpdGggbm8gYXJndW1lbnQgdmFsdWVzIHRvIGEgZnVuY3Rpb24gd2l0aCBhblxuICAgICAgICAgKiBlbXB0eSBwYXJhbWV0ZXIgbGlzdC5cbiAgICAgICAgICogPHA+PGNvZGU+JyhmdW5jdGlvbigpe30oKSk7Jy5sZW5ndGg8L2NvZGU+PC9wPlxuICAgICAgICAgKiBAY29uc3RcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIE5fQ0xPU1VSRTogMTdcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIENhdGVnb3JpZXMgb2YgcHJpbWFyeSBleHByZXNzaW9ucyBmcm9tIHdoaWNoIHByaW1pdGl2ZSB2YWx1ZXMgdGhhdFxuICAgICAgICogY291bGQgYmUgY29uc29saWRhdGVkIGFyZSBkZXJpdmFibGUuXG4gICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgKiBAZW51bSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICBFUHJpbWFyeUV4cHJlc3Npb25DYXRlZ29yaWVzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWRlbnRpZmllciBuYW1lcyB1c2VkIGFzIHByb3BlcnR5IGFjY2Vzc29ycy5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIE5fSURFTlRJRklFUl9OQU1FUzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0cmluZyBsaXRlcmFscy5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIE5fU1RSSU5HX0xJVEVSQUxTOiAxLFxuICAgICAgICAvKipcbiAgICAgICAgICogTnVsbCBhbmQgQm9vbGVhbiBsaXRlcmFscy5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIE5fTlVMTF9BTkRfQk9PTEVBTl9MSVRFUkFMUzogMlxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogUHJlZml4ZXMgb2YgcHJpbWl0aXZlIHZhbHVlcyB0aGF0IGNvdWxkIGJlIGNvbnNvbGlkYXRlZC5cbiAgICAgICAqIFRoZSBTdHJpbmcgdmFsdWVzIG9mIHRoZSBwcmVmaXhlcyBtdXN0IGhhdmUgc2FtZSBudW1iZXIgb2YgY2hhcmFjdGVycy5cbiAgICAgICAqIFRoZSBwcmVmaXhlcyBtdXN0IG5vdCBiZSB1c2VkIGluIGFueSBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gYW55IHZlcnNpb25cbiAgICAgICAqIG9mIDxhIGhyZWY9XG4gICAgICAgKiBcImh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9wdWJsaWNhdGlvbnMvc3RhbmRhcmRzL0VjbWEtMjYyLmh0bVwiXG4gICAgICAgKiA+RUNNQS0yNjI8L2E+LlxuICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICogQGVudW0ge3N0cmluZ31cbiAgICAgICAqL1xuICAgICAgRVZhbHVlUHJlZml4ZXMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVudGlmaWVzIFN0cmluZyB2YWx1ZXMuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBTX1NUUklORzogJyNTJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElkZW50aWZpZXMgbnVsbCBhbmQgQm9vbGVhbiB2YWx1ZXMuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBTX1NZTUJPTElDOiAnI08nXG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBDYXRlZ29yaWVzIG9mIHNvdXJjZSBlbGVtZW50cyBpbiB0ZXJtcyBvZiB0aGVpciBhcHByb3ByaWF0ZW5lc3Mgb2ZcbiAgICAgICAqIGhhdmluZyB0aGVpciBwcmltaXRpdmUgdmFsdWVzIGNvbnNvbGlkYXRlZC5cbiAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAqIEBlbnVtIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIEVTb3VyY2VFbGVtZW50Q2F0ZWdvcmllcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElkZW50aWZpZXMgYSBzb3VyY2UgZWxlbWVudCB0aGF0IGluY2x1ZGVzIHRoZSA8YSBocmVmPVxuICAgICAgICAgKiBcImh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDEyLjEwXCI+e0Bjb2RlIHdpdGh9PC9hPiBzdGF0ZW1lbnQuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBOX1dJVEg6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVudGlmaWVzIGEgc291cmNlIGVsZW1lbnQgdGhhdCBpbmNsdWRlcyB0aGUgPGEgaHJlZj1cbiAgICAgICAgICogXCJodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4xLjIuMVwiPntAY29kZSBldmFsfTwvYT4gaWRlbnRpZmllciBuYW1lLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgTl9FVkFMOiAxLFxuICAgICAgICAvKipcbiAgICAgICAgICogSWRlbnRpZmllcyBhIHNvdXJjZSBlbGVtZW50IHRoYXQgbXVzdCBiZSBleGNsdWRlZCBmcm9tIHRoZSBwcm9jZXNzXG4gICAgICAgICAqIHVubGVzcyBpdHMgd2hvbGUgc2NvcGUgaXMgZXhhbWluZWQuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBOX0VYQ0xVREFCTEU6IDIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVudGlmaWVzIHNvdXJjZSBlbGVtZW50cyBub3QgcG9zaW5nIGFueSBwcm9ibGVtcy5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIE5fT1RIRVI6IDNcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBsaXN0IG9mIGxpdGVyYWxzIChvdGhlciB0aGFuIHRoZSBTdHJpbmcgb25lcykgd2hvc2UgcHJpbWl0aXZlXG4gICAgICAgKiB2YWx1ZXMgY2FuIGJlIGNvbnNvbGlkYXRlZC5cbiAgICAgICAqIEBjb25zdFxuICAgICAgICogQHR5cGUgeyFBcnJheS48c3RyaW5nPn1cbiAgICAgICAqL1xuICAgICAgQV9PVEhFUl9TVUJTVElUVVRBQkxFX0xJVEVSQUxTID0gW1xuICAgICAgICAnbnVsbCcsICAgLy8gVGhlIG51bGwgbGl0ZXJhbC5cbiAgICAgICAgJ2ZhbHNlJywgIC8vIFRoZSBCb29sZWFuIGxpdGVyYWwge0Bjb2RlIGZhbHNlfS5cbiAgICAgICAgJ3RydWUnICAgIC8vIFRoZSBCb29sZWFuIGxpdGVyYWwge0Bjb2RlIHRydWV9LlxuICAgICAgXTtcblxuICAoLyoqXG4gICAgKiBDb25zb2xpZGF0ZXMgYWxsIHdvcnRod2hpbGUgcHJpbWl0aXZlIHZhbHVlcyBpbiBhIHN5bnRhY3RpYyBjb2RlIHVuaXQuXG4gICAgKiBAcGFyYW0geyFUU3ludGFjdGljQ29kZVVuaXR9IG9TeW50YWN0aWNDb2RlVW5pdCBBbiBhcnJheS1saWtlIG9iamVjdFxuICAgICogICAgIHJlcHJlc2VudGluZyB0aGUgYnJhbmNoIG9mIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSByZXByZXNlbnRpbmcgdGhlXG4gICAgKiAgICAgc3ludGFjdGljIGNvZGUgdW5pdCBhbG9uZyB3aXRoIGl0cyBzY29wZS5cbiAgICAqIEBzZWUgVFByaW1pdGl2ZVZhbHVlI25TYXZpbmdcbiAgICAqL1xuICAgZnVuY3Rpb24gZkV4YW1pbmVTeW50YWN0aWNDb2RlVW5pdChvU3ludGFjdGljQ29kZVVuaXQpIHtcbiAgICAgdmFyIF8sXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzeW50YWN0aWMgY29kZSB1bml0IHJlcHJlc2VudHMgZ2xvYmFsIGNvZGUuXG4gICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICAqL1xuICAgICAgICAgYklzR2xvYmFsID0gJ3RvcGxldmVsJyA9PT0gb1N5bnRhY3RpY0NvZGVVbml0WzBdLFxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgd2hvbGUgc2NvcGUgaXMgYmVpbmcgZXhhbWluZWQuXG4gICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICAqL1xuICAgICAgICAgYklzV2hvbGx5RXhhbWluYWJsZSA9ICFiSXNHbG9iYWwsXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIEFuIGFycmF5LWxpa2Ugb2JqZWN0IHJlcHJlc2VudGluZyBzb3VyY2UgZWxlbWVudHMgdGhhdCBjb25zdGl0dXRlIGFcbiAgICAgICAgICAqIHN5bnRhY3RpYyBjb2RlIHVuaXQuXG4gICAgICAgICAgKiBAdHlwZSB7IVRTeW50YWN0aWNDb2RlVW5pdH1cbiAgICAgICAgICAqL1xuICAgICAgICAgb1NvdXJjZUVsZW1lbnRzLFxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBBIHJlY29yZCBjb25zaXN0aW5nIG9mIGRhdGEgYWJvdXQgdGhlIHNvdXJjZSBlbGVtZW50IHRoYXQgaXNcbiAgICAgICAgICAqIGN1cnJlbnRseSBiZWluZyBleGFtaW5lZC5cbiAgICAgICAgICAqIEB0eXBlIHshVFNvdXJjZUVsZW1lbnRzRGF0YX1cbiAgICAgICAgICAqL1xuICAgICAgICAgb1NvdXJjZUVsZW1lbnREYXRhLFxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBUaGUgc2NvcGUgb2YgdGhlIHN5bnRhY3RpYyBjb2RlIHVuaXQuXG4gICAgICAgICAgKiBAdHlwZSB7IVRTY29wZX1cbiAgICAgICAgICAqL1xuICAgICAgICAgb1Njb3BlLFxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBBbiBpbnN0YW5jZSBvZiBhbiBvYmplY3QgdGhhdCBhbGxvd3MgdGhlIHRyYXZlcnNhbCBvZiBhbiA8YWJiclxuICAgICAgICAgICogdGl0bGU9XCJhYnN0cmFjdCBzeW50YXggdHJlZVwiPkFTVDwvYWJicj4uXG4gICAgICAgICAgKiBAdHlwZSB7IVRXYWxrZXJ9XG4gICAgICAgICAgKi9cbiAgICAgICAgIG9XYWxrZXIsXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIEFuIG9iamVjdCBlbmNvbXBhc3NpbmcgY29sbGVjdGlvbnMgb2YgZnVuY3Rpb25zIHVzZWQgZHVyaW5nIHRoZVxuICAgICAgICAgICogdHJhdmVyc2FsIG9mIGFuIDxhYmJyIHRpdGxlPVwiYWJzdHJhY3Qgc3ludGF4IHRyZWVcIj5BU1Q8L2FiYnI+LlxuICAgICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgIU9iamVjdC48c3RyaW5nLCBmdW5jdGlvbiguLi5bKl0pPj59XG4gICAgICAgICAgKi9cbiAgICAgICAgIG9XYWxrZXJzID0ge1xuICAgICAgICAgICAvKipcbiAgICAgICAgICAgICogQSBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyB1c2VkIGR1cmluZyB0aGUgc3VydmV5YW5jZSBvZiBzb3VyY2VcbiAgICAgICAgICAgICogZWxlbWVudHMuXG4gICAgICAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAgICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgZnVuY3Rpb24oLi4uWypdKT59XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICBvU3VydmV5U291cmNlRWxlbWVudDoge1xuICAgICAgICAgICAgIC8qKiNub2NvZGUrKi8gIC8vIEpzRG9jIFRvb2xraXQgMi40LjAgaGlkZXMgc29tZSBvZiB0aGUga2V5cy5cbiAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgKiBDbGFzc2lmaWVzIHRoZSBzb3VyY2UgZWxlbWVudCBhcyBleGNsdWRhYmxlIGlmIGl0IGRvZXMgbm90XG4gICAgICAgICAgICAgICogY29udGFpbiBhIHtAY29kZSB3aXRofSBzdGF0ZW1lbnQgb3IgdGhlIHtAY29kZSBldmFsfSBpZGVudGlmaWVyXG4gICAgICAgICAgICAgICogbmFtZS4gQWRkcyB0aGUgaWRlbnRpZmllciBvZiB0aGUgZnVuY3Rpb24gYW5kIGl0cyBmb3JtYWxcbiAgICAgICAgICAgICAgKiBwYXJhbWV0ZXJzIHRvIHRoZSBsaXN0IG9mIGlkZW50aWZpZXIgbmFtZXMgZm91bmQuXG4gICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNJZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgKiBAcGFyYW0geyFBcnJheS48c3RyaW5nPn0gYUZvcm1hbFBhcmFtZXRlckxpc3QgRm9ybWFsIHBhcmFtZXRlcnMuXG4gICAgICAgICAgICAgICogQHBhcmFtIHshVFN5bnRhY3RpY0NvZGVVbml0fSBvRnVuY3Rpb25Cb2R5IEZ1bmN0aW9uIGNvZGUuXG4gICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgJ2RlZnVuJzogZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgIHNJZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICBhRm9ybWFsUGFyYW1ldGVyTGlzdCxcbiAgICAgICAgICAgICAgICAgb0Z1bmN0aW9uQm9keSkge1xuICAgICAgICAgICAgICAgZkNsYXNzaWZ5QXNFeGNsdWRhYmxlKCk7XG4gICAgICAgICAgICAgICBmQWRkSWRlbnRpZmllcihzSWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICBhRm9ybWFsUGFyYW1ldGVyTGlzdC5mb3JFYWNoKGZBZGRJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAqIEluY3JlbWVudHMgdGhlIGNvdW50IG9mIHRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgb2YgdGhlIFN0cmluZ1xuICAgICAgICAgICAgICAqIHZhbHVlIHRoYXQgaXMgZXF1aXZhbGVudCB0byB0aGUgc2VxdWVuY2Ugb2YgdGVybWluYWwgc3ltYm9sc1xuICAgICAgICAgICAgICAqIHRoYXQgY29uc3RpdHV0ZSB0aGUgZW5jb3VudGVyZWQgaWRlbnRpZmllciBuYW1lLlxuICAgICAgICAgICAgICAqIEBwYXJhbSB7IVRTeW50YWN0aWNDb2RlVW5pdH0gb0V4cHJlc3Npb24gVGhlIG5vbnRlcm1pbmFsXG4gICAgICAgICAgICAgICogICAgIE1lbWJlckV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNJZGVudGlmaWVyTmFtZSBUaGUgaWRlbnRpZmllciBuYW1lIHVzZWQgYXMgdGhlXG4gICAgICAgICAgICAgICogICAgIHByb3BlcnR5IGFjY2Vzc29yLlxuICAgICAgICAgICAgICAqIEByZXR1cm4geyFBcnJheX0gVGhlIGVuY291bnRlcmVkIGJyYW5jaCBvZiBhbiA8YWJiciB0aXRsZT1cbiAgICAgICAgICAgICAgKiAgICAgXCJhYnN0cmFjdCBzeW50YXggdHJlZVwiPkFTVDwvYWJicj4gd2l0aCBpdHMgbm9udGVybWluYWxcbiAgICAgICAgICAgICAgKiAgICAgTWVtYmVyRXhwcmVzc2lvbiB0cmF2ZXJzZWQuXG4gICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgJ2RvdCc6IGZ1bmN0aW9uKG9FeHByZXNzaW9uLCBzSWRlbnRpZmllck5hbWUpIHtcbiAgICAgICAgICAgICAgIGZDb3VudFByaW1hcnlFeHByZXNzaW9uKFxuICAgICAgICAgICAgICAgICAgIEVQcmltYXJ5RXhwcmVzc2lvbkNhdGVnb3JpZXMuTl9JREVOVElGSUVSX05BTUVTLFxuICAgICAgICAgICAgICAgICAgIEVWYWx1ZVByZWZpeGVzLlNfU1RSSU5HICsgc0lkZW50aWZpZXJOYW1lKTtcbiAgICAgICAgICAgICAgIHJldHVybiBbJ2RvdCcsIG9XYWxrZXIud2FsayhvRXhwcmVzc2lvbiksIHNJZGVudGlmaWVyTmFtZV07XG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgKiBBZGRzIHRoZSBvcHRpb25hbCBpZGVudGlmaWVyIG9mIHRoZSBmdW5jdGlvbiBhbmQgaXRzIGZvcm1hbFxuICAgICAgICAgICAgICAqIHBhcmFtZXRlcnMgdG8gdGhlIGxpc3Qgb2YgaWRlbnRpZmllciBuYW1lcyBmb3VuZC5cbiAgICAgICAgICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHNJZGVudGlmaWVyIFRoZSBvcHRpb25hbCBpZGVudGlmaWVyIG9mIHRoZVxuICAgICAgICAgICAgICAqICAgICBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgKiBAcGFyYW0geyFBcnJheS48c3RyaW5nPn0gYUZvcm1hbFBhcmFtZXRlckxpc3QgRm9ybWFsIHBhcmFtZXRlcnMuXG4gICAgICAgICAgICAgICogQHBhcmFtIHshVFN5bnRhY3RpY0NvZGVVbml0fSBvRnVuY3Rpb25Cb2R5IEZ1bmN0aW9uIGNvZGUuXG4gICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgJ2Z1bmN0aW9uJzogZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgIHNJZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICBhRm9ybWFsUGFyYW1ldGVyTGlzdCxcbiAgICAgICAgICAgICAgICAgb0Z1bmN0aW9uQm9keSkge1xuICAgICAgICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2Ygc0lkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgZkFkZElkZW50aWZpZXIoc0lkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgYUZvcm1hbFBhcmFtZXRlckxpc3QuZm9yRWFjaChmQWRkSWRlbnRpZmllcik7XG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgKiBFaXRoZXIgaW5jcmVtZW50cyB0aGUgY291bnQgb2YgdGhlIG51bWJlciBvZiBvY2N1cnJlbmNlcyBvZiB0aGVcbiAgICAgICAgICAgICAgKiBlbmNvdW50ZXJlZCBudWxsIG9yIEJvb2xlYW4gdmFsdWUgb3IgY2xhc3NpZmllcyBhIHNvdXJjZSBlbGVtZW50XG4gICAgICAgICAgICAgICogYXMgY29udGFpbmluZyB0aGUge0Bjb2RlIGV2YWx9IGlkZW50aWZpZXIgbmFtZS5cbiAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc0lkZW50aWZpZXIgVGhlIGlkZW50aWZpZXIgZW5jb3VudGVyZWQuXG4gICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgJ25hbWUnOiBmdW5jdGlvbihzSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgaWYgKC0xICE9PSBBX09USEVSX1NVQlNUSVRVVEFCTEVfTElURVJBTFMuaW5kZXhPZihzSWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgICAgICAgZkNvdW50UHJpbWFyeUV4cHJlc3Npb24oXG4gICAgICAgICAgICAgICAgICAgICBFUHJpbWFyeUV4cHJlc3Npb25DYXRlZ29yaWVzLk5fTlVMTF9BTkRfQk9PTEVBTl9MSVRFUkFMUyxcbiAgICAgICAgICAgICAgICAgICAgIEVWYWx1ZVByZWZpeGVzLlNfU1lNQk9MSUMgKyBzSWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICBpZiAoJ2V2YWwnID09PSBzSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgIG9Tb3VyY2VFbGVtZW50RGF0YS5uQ2F0ZWdvcnkgPVxuICAgICAgICAgICAgICAgICAgICAgICBFU291cmNlRWxlbWVudENhdGVnb3JpZXMuTl9FVkFMO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgIGZBZGRJZGVudGlmaWVyKHNJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAqIENsYXNzaWZpZXMgdGhlIHNvdXJjZSBlbGVtZW50IGFzIGV4Y2x1ZGFibGUgaWYgaXQgZG9lcyBub3RcbiAgICAgICAgICAgICAgKiBjb250YWluIGEge0Bjb2RlIHdpdGh9IHN0YXRlbWVudCBvciB0aGUge0Bjb2RlIGV2YWx9IGlkZW50aWZpZXJcbiAgICAgICAgICAgICAgKiBuYW1lLlxuICAgICAgICAgICAgICAqIEBwYXJhbSB7VFN5bnRhY3RpY0NvZGVVbml0fSBvRXhwcmVzc2lvbiBUaGUgZXhwcmVzc2lvbiB3aG9zZVxuICAgICAgICAgICAgICAqICAgICB2YWx1ZSBpcyB0byBiZSByZXR1cm5lZC5cbiAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAncmV0dXJuJzogZnVuY3Rpb24ob0V4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgIGZDbGFzc2lmeUFzRXhjbHVkYWJsZSgpO1xuICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICogSW5jcmVtZW50cyB0aGUgY291bnQgb2YgdGhlIG51bWJlciBvZiBvY2N1cnJlbmNlcyBvZiB0aGVcbiAgICAgICAgICAgICAgKiBlbmNvdW50ZXJlZCBTdHJpbmcgdmFsdWUuXG4gICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNTdHJpbmdWYWx1ZSBUaGUgU3RyaW5nIHZhbHVlIG9mIHRoZSBzdHJpbmdcbiAgICAgICAgICAgICAgKiAgICAgbGl0ZXJhbCBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAnc3RyaW5nJzogZnVuY3Rpb24oc1N0cmluZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICBpZiAoc1N0cmluZ1ZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgZkNvdW50UHJpbWFyeUV4cHJlc3Npb24oXG4gICAgICAgICAgICAgICAgICAgICBFUHJpbWFyeUV4cHJlc3Npb25DYXRlZ29yaWVzLk5fU1RSSU5HX0xJVEVSQUxTLFxuICAgICAgICAgICAgICAgICAgICAgRVZhbHVlUHJlZml4ZXMuU19TVFJJTkcgKyBzU3RyaW5nVmFsdWUpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICogQWRkcyB0aGUgaWRlbnRpZmllciByZXNlcnZlZCBmb3IgYW4gZXhjZXB0aW9uIHRvIHRoZSBsaXN0IG9mXG4gICAgICAgICAgICAgICogaWRlbnRpZmllciBuYW1lcyBmb3VuZC5cbiAgICAgICAgICAgICAgKiBAcGFyYW0geyFUU3ludGFjdGljQ29kZVVuaXR9IG9UcnkgQSBibG9jayBvZiBjb2RlIGluIHdoaWNoIGFuXG4gICAgICAgICAgICAgICogICAgIGV4Y2VwdGlvbiBjYW4gb2NjdXIuXG4gICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gYUNhdGNoIFRoZSBpZGVudGlmaWVyIHJlc2VydmVkIGZvciBhbiBleGNlcHRpb25cbiAgICAgICAgICAgICAgKiAgICAgYW5kIGEgYmxvY2sgb2YgY29kZSB0byBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgICAgKiBAcGFyYW0ge1RTeW50YWN0aWNDb2RlVW5pdH0gb0ZpbmFsbHkgQW4gb3B0aW9uYWwgYmxvY2sgb2YgY29kZVxuICAgICAgICAgICAgICAqICAgICB0byBiZSBldmFsdWF0ZWQgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGFuIGV4Y2VwdGlvbiBvY2N1cnMuXG4gICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgJ3RyeSc6IGZ1bmN0aW9uKG9UcnksIGFDYXRjaCwgb0ZpbmFsbHkpIHtcbiAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFDYXRjaCkpIHtcbiAgICAgICAgICAgICAgICAgZkFkZElkZW50aWZpZXIoYUNhdGNoWzBdKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAqIENsYXNzaWZpZXMgdGhlIHNvdXJjZSBlbGVtZW50IGFzIGV4Y2x1ZGFibGUgaWYgaXQgZG9lcyBub3RcbiAgICAgICAgICAgICAgKiBjb250YWluIGEge0Bjb2RlIHdpdGh9IHN0YXRlbWVudCBvciB0aGUge0Bjb2RlIGV2YWx9IGlkZW50aWZpZXJcbiAgICAgICAgICAgICAgKiBuYW1lLiBBZGRzIHRoZSBpZGVudGlmaWVyIG9mIGVhY2ggZGVjbGFyZWQgdmFyaWFibGUgdG8gdGhlIGxpc3RcbiAgICAgICAgICAgICAgKiBvZiBpZGVudGlmaWVyIG5hbWVzIGZvdW5kLlxuICAgICAgICAgICAgICAqIEBwYXJhbSB7IUFycmF5LjwhQXJyYXk+fSBhVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QgVmFyaWFibGVcbiAgICAgICAgICAgICAgKiAgICAgZGVjbGFyYXRpb25zLlxuICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICd2YXInOiBmdW5jdGlvbihhVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QpIHtcbiAgICAgICAgICAgICAgIGZDbGFzc2lmeUFzRXhjbHVkYWJsZSgpO1xuICAgICAgICAgICAgICAgYVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0LmZvckVhY2goZkFkZFZhcmlhYmxlKTtcbiAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAqIENsYXNzaWZpZXMgYSBzb3VyY2UgZWxlbWVudCBhcyBjb250YWluaW5nIHRoZSB7QGNvZGUgd2l0aH1cbiAgICAgICAgICAgICAgKiBzdGF0ZW1lbnQuXG4gICAgICAgICAgICAgICogQHBhcmFtIHshVFN5bnRhY3RpY0NvZGVVbml0fSBvRXhwcmVzc2lvbiBBbiBleHByZXNzaW9uIHdob3NlXG4gICAgICAgICAgICAgICogICAgIHZhbHVlIGlzIHRvIGJlIGNvbnZlcnRlZCB0byBhIHZhbHVlIG9mIHR5cGUgT2JqZWN0IGFuZFxuICAgICAgICAgICAgICAqICAgICBiZWNvbWUgdGhlIGJpbmRpbmcgb2JqZWN0IG9mIGEgbmV3IG9iamVjdCBlbnZpcm9ubWVudFxuICAgICAgICAgICAgICAqICAgICByZWNvcmQgb2YgYSBuZXcgbGV4aWNhbCBlbnZpcm9ubWVudCBpbiB3aGljaCB0aGUgc3RhdGVtZW50XG4gICAgICAgICAgICAgICogICAgIGlzIHRvIGJlIGV4ZWN1dGVkLlxuICAgICAgICAgICAgICAqIEBwYXJhbSB7IVRTeW50YWN0aWNDb2RlVW5pdH0gb1N0YXRlbWVudCBUaGUgc3RhdGVtZW50IHRvIGJlXG4gICAgICAgICAgICAgICogICAgIGV4ZWN1dGVkIGluIHRoZSBhdWdtZW50ZWQgbGV4aWNhbCBlbnZpcm9ubWVudC5cbiAgICAgICAgICAgICAgKiBAcmV0dXJuIHshQXJyYXl9IEFuIGVtcHR5IGFycmF5IHRvIHN0b3AgdGhlIHRyYXZlcnNhbC5cbiAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAnd2l0aCc6IGZ1bmN0aW9uKG9FeHByZXNzaW9uLCBvU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICBvU291cmNlRWxlbWVudERhdGEubkNhdGVnb3J5ID0gRVNvdXJjZUVsZW1lbnRDYXRlZ29yaWVzLk5fV0lUSDtcbiAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgLyoqI25vY29kZS0qLyAgLy8gSnNEb2MgVG9vbGtpdCAyLjQuMCBoaWRlcyBzb21lIG9mIHRoZSBrZXlzLlxuICAgICAgICAgICB9LFxuICAgICAgICAgICAvKipcbiAgICAgICAgICAgICogQSBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyB1c2VkIHdoaWxlIGxvb2tpbmcgZm9yIG5lc3RlZCBmdW5jdGlvbnMuXG4gICAgICAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAgICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgZnVuY3Rpb24oLi4uWypdKT59XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICBvRXhhbWluZUZ1bmN0aW9uczoge1xuICAgICAgICAgICAgIC8qKiNub2NvZGUrKi8gIC8vIEpzRG9jIFRvb2xraXQgMi40LjAgaGlkZXMgc29tZSBvZiB0aGUga2V5cy5cbiAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgKiBPcmRlcnMgYW4gZXhhbWluYXRpb24gb2YgYSBuZXN0ZWQgZnVuY3Rpb24gZGVjbGFyYXRpb24uXG4gICAgICAgICAgICAgICogQHRoaXMgeyFUU3ludGFjdGljQ29kZVVuaXR9IEFuIGFycmF5LWxpa2Ugb2JqZWN0IHJlcHJlc2VudGluZ1xuICAgICAgICAgICAgICAqICAgICB0aGUgYnJhbmNoIG9mIGFuIDxhYmJyIHRpdGxlPVwiYWJzdHJhY3Qgc3ludGF4IHRyZWVcIlxuICAgICAgICAgICAgICAqICAgICA+QVNUPC9hYmJyPiByZXByZXNlbnRpbmcgdGhlIHN5bnRhY3RpYyBjb2RlIHVuaXQgYWxvbmcgd2l0aFxuICAgICAgICAgICAgICAqICAgICBpdHMgc2NvcGUuXG4gICAgICAgICAgICAgICogQHJldHVybiB7IUFycmF5fSBBbiBlbXB0eSBhcnJheSB0byBzdG9wIHRoZSB0cmF2ZXJzYWwuXG4gICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgJ2RlZnVuJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICBmRXhhbWluZVN5bnRhY3RpY0NvZGVVbml0KHRoaXMpO1xuICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICogT3JkZXJzIGFuIGV4YW1pbmF0aW9uIG9mIGEgbmVzdGVkIGZ1bmN0aW9uIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICogQHRoaXMgeyFUU3ludGFjdGljQ29kZVVuaXR9IEFuIGFycmF5LWxpa2Ugb2JqZWN0IHJlcHJlc2VudGluZ1xuICAgICAgICAgICAgICAqICAgICB0aGUgYnJhbmNoIG9mIGFuIDxhYmJyIHRpdGxlPVwiYWJzdHJhY3Qgc3ludGF4IHRyZWVcIlxuICAgICAgICAgICAgICAqICAgICA+QVNUPC9hYmJyPiByZXByZXNlbnRpbmcgdGhlIHN5bnRhY3RpYyBjb2RlIHVuaXQgYWxvbmcgd2l0aFxuICAgICAgICAgICAgICAqICAgICBpdHMgc2NvcGUuXG4gICAgICAgICAgICAgICogQHJldHVybiB7IUFycmF5fSBBbiBlbXB0eSBhcnJheSB0byBzdG9wIHRoZSB0cmF2ZXJzYWwuXG4gICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgJ2Z1bmN0aW9uJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICBmRXhhbWluZVN5bnRhY3RpY0NvZGVVbml0KHRoaXMpO1xuICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAvKiojbm9jb2RlLSovICAvLyBKc0RvYyBUb29sa2l0IDIuNC4wIGhpZGVzIHNvbWUgb2YgdGhlIGtleXMuXG4gICAgICAgICAgIH1cbiAgICAgICAgIH0sXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIFJlY29yZHMgY29udGFpbmluZyBkYXRhIGFib3V0IHNvdXJjZSBlbGVtZW50cy5cbiAgICAgICAgICAqIEB0eXBlIHtBcnJheS48VFNvdXJjZUVsZW1lbnRzRGF0YT59XG4gICAgICAgICAgKi9cbiAgICAgICAgIGFTb3VyY2VFbGVtZW50c0RhdGEgPSBbXSxcbiAgICAgICAgIC8qKlxuICAgICAgICAgICogVGhlIGluZGV4IChpbiB0aGUgc291cmNlIHRleHQgb3JkZXIpIG9mIHRoZSBzb3VyY2UgZWxlbWVudFxuICAgICAgICAgICogaW1tZWRpYXRlbHkgZm9sbG93aW5nIGEgPGEgaHJlZj1cImh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE0LjFcIlxuICAgICAgICAgICogPkRpcmVjdGl2ZSBQcm9sb2d1ZTwvYT4uXG4gICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgICovXG4gICAgICAgICBuQWZ0ZXJEaXJlY3RpdmVQcm9sb2d1ZSA9IDAsXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIFRoZSBpbmRleCAoaW4gdGhlIHNvdXJjZSB0ZXh0IG9yZGVyKSBvZiB0aGUgc291cmNlIGVsZW1lbnQgdGhhdCBpc1xuICAgICAgICAgICogY3VycmVudGx5IGJlaW5nIGNvbnNpZGVyZWQuXG4gICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgICovXG4gICAgICAgICBuUG9zaXRpb24sXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIFRoZSBpbmRleCAoaW4gdGhlIHNvdXJjZSB0ZXh0IG9yZGVyKSBvZiB0aGUgc291cmNlIGVsZW1lbnQgdGhhdCBpc1xuICAgICAgICAgICogdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgcmFuZ2Ugb2Ygc291cmNlIGVsZW1lbnRzIHRoYXQgaXMgY3VycmVudGx5XG4gICAgICAgICAgKiBiZWluZyBjb25zaWRlcmVkLlxuICAgICAgICAgICogQHR5cGUgeyh1bmRlZmluZWR8bnVtYmVyKX1cbiAgICAgICAgICAqL1xuICAgICAgICAgblRvLFxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBJbml0aWF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHNvdXJjZSBlbGVtZW50LlxuICAgICAgICAgICogQHBhcmFtIHshVFdhbGtlcn0gb1dhbGtlciBBbiBpbnN0YW5jZSBvZiBhbiBvYmplY3QgdGhhdCBhbGxvd3MgdGhlXG4gICAgICAgICAgKiAgICAgdHJhdmVyc2FsIG9mIGFuIGFic3RyYWN0IHN5bnRheCB0cmVlLlxuICAgICAgICAgICogQHBhcmFtIHshVFN5bnRhY3RpY0NvZGVVbml0fSBvU291cmNlRWxlbWVudCBBIHNvdXJjZSBlbGVtZW50IGZyb21cbiAgICAgICAgICAqICAgICB3aGljaCB0aGUgdHJhdmVyc2FsIHNob3VsZCBjb21tZW5jZS5cbiAgICAgICAgICAqIEByZXR1cm4ge2Z1bmN0aW9uKCk6ICFUU3ludGFjdGljQ29kZVVuaXR9IEEgZnVuY3Rpb24gdGhhdCBpcyBhYmxlIHRvXG4gICAgICAgICAgKiAgICAgaW5pdGlhdGUgdGhlIHRyYXZlcnNhbCBmcm9tIGEgZ2l2ZW4gc291cmNlIGVsZW1lbnQuXG4gICAgICAgICAgKi9cbiAgICAgICAgIGNDb250ZXh0ID0gZnVuY3Rpb24ob1dhbGtlciwgb1NvdXJjZUVsZW1lbnQpIHtcbiAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAqIEByZXR1cm4geyFUU3ludGFjdGljQ29kZVVuaXR9IEEgZnVuY3Rpb24gdGhhdCBpcyBhYmxlIHRvXG4gICAgICAgICAgICAqICAgICBpbml0aWF0ZSB0aGUgdHJhdmVyc2FsIGZyb20gYSBnaXZlbiBzb3VyY2UgZWxlbWVudC5cbiAgICAgICAgICAgICovXG4gICAgICAgICAgIHZhciBmTGFtYmRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgcmV0dXJuIG9XYWxrZXIud2FsayhvU291cmNlRWxlbWVudCk7XG4gICAgICAgICAgIH07XG5cbiAgICAgICAgICAgcmV0dXJuIGZMYW1iZGE7XG4gICAgICAgICB9LFxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBDbGFzc2lmaWVzIHRoZSBzb3VyY2UgZWxlbWVudCBhcyBleGNsdWRhYmxlIGlmIGl0IGRvZXMgbm90XG4gICAgICAgICAgKiBjb250YWluIGEge0Bjb2RlIHdpdGh9IHN0YXRlbWVudCBvciB0aGUge0Bjb2RlIGV2YWx9IGlkZW50aWZpZXJcbiAgICAgICAgICAqIG5hbWUuXG4gICAgICAgICAgKi9cbiAgICAgICAgIGZDbGFzc2lmeUFzRXhjbHVkYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICBpZiAob1NvdXJjZUVsZW1lbnREYXRhLm5DYXRlZ29yeSA9PT1cbiAgICAgICAgICAgICAgIEVTb3VyY2VFbGVtZW50Q2F0ZWdvcmllcy5OX09USEVSKSB7XG4gICAgICAgICAgICAgb1NvdXJjZUVsZW1lbnREYXRhLm5DYXRlZ29yeSA9XG4gICAgICAgICAgICAgICAgIEVTb3VyY2VFbGVtZW50Q2F0ZWdvcmllcy5OX0VYQ0xVREFCTEU7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH0sXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIEFkZHMgYW4gaWRlbnRpZmllciB0byB0aGUgbGlzdCBvZiBpZGVudGlmaWVyIG5hbWVzIGZvdW5kLlxuICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNJZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIHRvIGJlIGFkZGVkLlxuICAgICAgICAgICovXG4gICAgICAgICBmQWRkSWRlbnRpZmllciA9IGZ1bmN0aW9uKHNJZGVudGlmaWVyKSB7XG4gICAgICAgICAgIGlmICgtMSA9PT0gb1NvdXJjZUVsZW1lbnREYXRhLmFJZGVudGlmaWVycy5pbmRleE9mKHNJZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgIG9Tb3VyY2VFbGVtZW50RGF0YS5hSWRlbnRpZmllcnMucHVzaChzSWRlbnRpZmllcik7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH0sXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIEFkZHMgdGhlIGlkZW50aWZpZXIgb2YgYSB2YXJpYWJsZSB0byB0aGUgbGlzdCBvZiBpZGVudGlmaWVyIG5hbWVzXG4gICAgICAgICAgKiBmb3VuZC5cbiAgICAgICAgICAqIEBwYXJhbSB7IUFycmF5fSBhVmFyaWFibGVEZWNsYXJhdGlvbiBBIHZhcmlhYmxlIGRlY2xhcmF0aW9uLlxuICAgICAgICAgICovXG4gICAgICAgICBmQWRkVmFyaWFibGUgPSBmdW5jdGlvbihhVmFyaWFibGVEZWNsYXJhdGlvbikge1xuICAgICAgICAgICBmQWRkSWRlbnRpZmllcigvKiogQHR5cGUge3N0cmluZ30gKi8gYVZhcmlhYmxlRGVjbGFyYXRpb25bMF0pO1xuICAgICAgICAgfSxcbiAgICAgICAgIC8qKlxuICAgICAgICAgICogSW5jcmVtZW50cyB0aGUgY291bnQgb2YgdGhlIG51bWJlciBvZiBvY2N1cnJlbmNlcyBvZiB0aGUgcHJlZml4ZWRcbiAgICAgICAgICAqIFN0cmluZyByZXByZXNlbnRhdGlvbiBhdHRyaWJ1dGVkIHRvIHRoZSBwcmltYXJ5IGV4cHJlc3Npb24uXG4gICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbkNhdGVnb3J5IFRoZSBjYXRlZ29yeSBvZiB0aGUgcHJpbWFyeSBleHByZXNzaW9uLlxuICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNOYW1lIFRoZSBwcmVmaXhlZCBTdHJpbmcgcmVwcmVzZW50YXRpb24gYXR0cmlidXRlZFxuICAgICAgICAgICogICAgIHRvIHRoZSBwcmltYXJ5IGV4cHJlc3Npb24uXG4gICAgICAgICAgKi9cbiAgICAgICAgIGZDb3VudFByaW1hcnlFeHByZXNzaW9uID0gZnVuY3Rpb24obkNhdGVnb3J5LCBzTmFtZSkge1xuICAgICAgICAgICBpZiAoIW9Tb3VyY2VFbGVtZW50RGF0YS5hQ291bnRbbkNhdGVnb3J5XS5oYXNPd25Qcm9wZXJ0eShzTmFtZSkpIHtcbiAgICAgICAgICAgICBvU291cmNlRWxlbWVudERhdGEuYUNvdW50W25DYXRlZ29yeV1bc05hbWVdID0gMDtcbiAgICAgICAgICAgICBpZiAoLTEgPT09IG9Tb3VyY2VFbGVtZW50RGF0YS5hUHJpbWl0aXZlVmFsdWVzLmluZGV4T2Yoc05hbWUpKSB7XG4gICAgICAgICAgICAgICBvU291cmNlRWxlbWVudERhdGEuYVByaW1pdGl2ZVZhbHVlcy5wdXNoKHNOYW1lKTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgb1NvdXJjZUVsZW1lbnREYXRhLmFDb3VudFtuQ2F0ZWdvcnldW3NOYW1lXSArPSAxO1xuICAgICAgICAgfSxcbiAgICAgICAgIC8qKlxuICAgICAgICAgICogQ29uc29saWRhdGVzIGFsbCB3b3J0aHdoaWxlIHByaW1pdGl2ZSB2YWx1ZXMgaW4gYSByYW5nZSBvZiBzb3VyY2VcbiAgICAgICAgICAqICAgICBlbGVtZW50cy5cbiAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuRnJvbSBUaGUgaW5kZXggKGluIHRoZSBzb3VyY2UgdGV4dCBvcmRlcikgb2YgdGhlXG4gICAgICAgICAgKiAgICAgc291cmNlIGVsZW1lbnQgdGhhdCBpcyB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgcmFuZ2UuXG4gICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gblRvIFRoZSBpbmRleCAoaW4gdGhlIHNvdXJjZSB0ZXh0IG9yZGVyKSBvZiB0aGVcbiAgICAgICAgICAqICAgICBzb3VyY2UgZWxlbWVudCB0aGF0IGlzIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIHJhbmdlLlxuICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBiRW5jbG9zZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgcmFuZ2Ugc2hvdWxkIGJlXG4gICAgICAgICAgKiAgICAgZW5jbG9zZWQgd2l0aGluIGEgZnVuY3Rpb24gY2FsbCB3aXRoIG5vIGFyZ3VtZW50IHZhbHVlcyB0byBhXG4gICAgICAgICAgKiAgICAgZnVuY3Rpb24gd2l0aCBhbiBlbXB0eSBwYXJhbWV0ZXIgbGlzdCBpZiBhbnkgcHJpbWl0aXZlIHZhbHVlc1xuICAgICAgICAgICogICAgIGFyZSBjb25zb2xpZGF0ZWQuXG4gICAgICAgICAgKiBAc2VlIFRQcmltaXRpdmVWYWx1ZSNuU2F2aW5nXG4gICAgICAgICAgKi9cbiAgICAgICAgIGZFeGFtaW5lU291cmNlRWxlbWVudHMgPSBmdW5jdGlvbihuRnJvbSwgblRvLCBiRW5jbG9zZSkge1xuICAgICAgICAgICB2YXIgXyxcbiAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICogVGhlIGluZGV4IG9mIHRoZSBsYXN0IG1hbmdsZWQgbmFtZS5cbiAgICAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgIG5JbmRleCA9IG9TY29wZS5jbmFtZSxcbiAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICogVGhlIGluZGV4IG9mIHRoZSBzb3VyY2UgZWxlbWVudCB0aGF0IGlzIGN1cnJlbnRseSBiZWluZ1xuICAgICAgICAgICAgICAgICogY29uc2lkZXJlZC5cbiAgICAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgIG5Qb3NpdGlvbixcbiAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICogQSBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyB1c2VkIGR1cmluZyB0aGUgY29uc29saWRhdGlvbiBvZlxuICAgICAgICAgICAgICAgICogcHJpbWl0aXZlIHZhbHVlcyBhbmQgaWRlbnRpZmllciBuYW1lcyB1c2VkIGFzIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgKiBhY2Nlc3NvcnMuXG4gICAgICAgICAgICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgICAgICAgICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCBmdW5jdGlvbiguLi5bKl0pPn1cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgb1dhbGtlcnNUcmFuc2Zvcm1lcnMgPSB7XG4gICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgU3RyaW5nIHZhbHVlIHRoYXQgaXMgZXF1aXZhbGVudCB0byB0aGUgc2VxdWVuY2Ugb2ZcbiAgICAgICAgICAgICAgICAgICogdGVybWluYWwgc3ltYm9scyB0aGF0IGNvbnN0aXR1dGUgdGhlIGVuY291bnRlcmVkIGlkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICogbmFtZSBpcyB3b3J0aHdoaWxlLCBhIHN5bnRhY3RpYyBjb252ZXJzaW9uIGZyb20gdGhlIGRvdFxuICAgICAgICAgICAgICAgICAgKiBub3RhdGlvbiB0byB0aGUgYnJhY2tldCBub3RhdGlvbiBlbnN1ZXMgd2l0aCB0aGF0IHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAqIGJlaW5nIHN1YnN0aXR1dGVkIGJ5IGFuIGlkZW50aWZpZXIgbmFtZSB0byB3aGljaCB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICogaXMgYXNzaWduZWQuXG4gICAgICAgICAgICAgICAgICAqIEFwcGxpZXMgdG8gcHJvcGVydHkgYWNjZXNzb3JzIHRoYXQgdXNlIHRoZSBkb3Qgbm90YXRpb24uXG4gICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7IVRTeW50YWN0aWNDb2RlVW5pdH0gb0V4cHJlc3Npb24gVGhlIG5vbnRlcm1pbmFsXG4gICAgICAgICAgICAgICAgICAqICAgICBNZW1iZXJFeHByZXNzaW9uLlxuICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc0lkZW50aWZpZXJOYW1lIFRoZSBpZGVudGlmaWVyIG5hbWUgdXNlZCBhc1xuICAgICAgICAgICAgICAgICAgKiAgICAgdGhlIHByb3BlcnR5IGFjY2Vzc29yLlxuICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshQXJyYXl9IEEgc3ludGFjdGljIGNvZGUgdW5pdCB0aGF0IGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgICAgICAgICAgICAgICogICAgIHRoZSBvbmUgZW5jb3VudGVyZWQuXG4gICAgICAgICAgICAgICAgICAqIEBzZWUgVFByaW1pdGl2ZVZhbHVlI25TYXZpbmdcbiAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICdkb3QnOiBmdW5jdGlvbihvRXhwcmVzc2lvbiwgc0lkZW50aWZpZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICogVGhlIHByZWZpeGVkIFN0cmluZyB2YWx1ZSB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgICogc2VxdWVuY2Ugb2YgdGVybWluYWwgc3ltYm9scyB0aGF0IGNvbnN0aXR1dGUgdGhlXG4gICAgICAgICAgICAgICAgICAgICogZW5jb3VudGVyZWQgaWRlbnRpZmllciBuYW1lLlxuICAgICAgICAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgdmFyIHNQcmVmaXhlZCA9IEVWYWx1ZVByZWZpeGVzLlNfU1RSSU5HICsgc0lkZW50aWZpZXJOYW1lO1xuXG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIG9Tb2x1dGlvbkJlc3Qub1ByaW1pdGl2ZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgICAgc1ByZWZpeGVkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICBvU29sdXRpb25CZXN0Lm9QcmltaXRpdmVWYWx1ZXNbc1ByZWZpeGVkXS5uU2F2aW5nID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIFsnc3ViJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9XYWxrZXIud2FsayhvRXhwcmVzc2lvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICBbJ25hbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgIG9Tb2x1dGlvbkJlc3Qub1ByaW1pdGl2ZVZhbHVlc1tzUHJlZml4ZWRdLnNOYW1lXV0gOlxuICAgICAgICAgICAgICAgICAgICAgICBbJ2RvdCcsIG9XYWxrZXIud2FsayhvRXhwcmVzc2lvbiksIHNJZGVudGlmaWVyTmFtZV07XG4gICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgZW5jb3VudGVyZWQgaWRlbnRpZmllciBpcyBhIG51bGwgb3IgQm9vbGVhbiBsaXRlcmFsXG4gICAgICAgICAgICAgICAgICAqIGFuZCBpdHMgdmFsdWUgaXMgd29ydGh3aGlsZSwgdGhlIGlkZW50aWZpZXIgaXMgc3Vic3RpdHV0ZWRcbiAgICAgICAgICAgICAgICAgICogYnkgYW4gaWRlbnRpZmllciBuYW1lIHRvIHdoaWNoIHRoYXQgdmFsdWUgaXMgYXNzaWduZWQuXG4gICAgICAgICAgICAgICAgICAqIEFwcGxpZXMgdG8gaWRlbnRpZmllciBuYW1lcy5cbiAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNJZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshQXJyYXl9IEEgc3ludGFjdGljIGNvZGUgdW5pdCB0aGF0IGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgICAgICAgICAgICAgICogICAgIHRoZSBvbmUgZW5jb3VudGVyZWQuXG4gICAgICAgICAgICAgICAgICAqIEBzZWUgVFByaW1pdGl2ZVZhbHVlI25TYXZpbmdcbiAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICduYW1lJzogZnVuY3Rpb24oc0lkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgKiBUaGUgcHJlZml4ZWQgcmVwcmVzZW50YXRpb24gU3RyaW5nIG9mIHRoZSBpZGVudGlmaWVyLlxuICAgICAgICAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgdmFyIHNQcmVmaXhlZCA9IEVWYWx1ZVByZWZpeGVzLlNfU1lNQk9MSUMgKyBzSWRlbnRpZmllcjtcblxuICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAnbmFtZScsXG4gICAgICAgICAgICAgICAgICAgICBvU29sdXRpb25CZXN0Lm9QcmltaXRpdmVWYWx1ZXMuaGFzT3duUHJvcGVydHkoc1ByZWZpeGVkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgb1NvbHV0aW9uQmVzdC5vUHJpbWl0aXZlVmFsdWVzW3NQcmVmaXhlZF0ublNhdmluZyA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgb1NvbHV0aW9uQmVzdC5vUHJpbWl0aXZlVmFsdWVzW3NQcmVmaXhlZF0uc05hbWUgOlxuICAgICAgICAgICAgICAgICAgICAgc0lkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICogSWYgdGhlIGVuY291bnRlcmVkIFN0cmluZyB2YWx1ZSBpcyB3b3J0aHdoaWxlLCBpdCBpc1xuICAgICAgICAgICAgICAgICAgKiBzdWJzdGl0dXRlZCBieSBhbiBpZGVudGlmaWVyIG5hbWUgdG8gd2hpY2ggdGhhdCB2YWx1ZSBpc1xuICAgICAgICAgICAgICAgICAgKiBhc3NpZ25lZC5cbiAgICAgICAgICAgICAgICAgICogQXBwbGllcyB0byBTdHJpbmcgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1N0cmluZ1ZhbHVlIFRoZSBTdHJpbmcgdmFsdWUgb2YgdGhlIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgKiAgICAgbGl0ZXJhbCBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgICAgICAgICogQHJldHVybiB7IUFycmF5fSBBIHN5bnRhY3RpYyBjb2RlIHVuaXQgdGhhdCBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgICAgICAgICAgICAqICAgICB0aGUgb25lIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgICAgICAgKiBAc2VlIFRQcmltaXRpdmVWYWx1ZSNuU2F2aW5nXG4gICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAnc3RyaW5nJzogZnVuY3Rpb24oc1N0cmluZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICogVGhlIHByZWZpeGVkIHJlcHJlc2VudGF0aW9uIFN0cmluZyBvZiB0aGUgcHJpbWl0aXZlIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICogb2YgdGhlIGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICB2YXIgc1ByZWZpeGVkID1cbiAgICAgICAgICAgICAgICAgICAgICAgRVZhbHVlUHJlZml4ZXMuU19TVFJJTkcgKyBzU3RyaW5nVmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICByZXR1cm4gb1NvbHV0aW9uQmVzdC5vUHJpbWl0aXZlVmFsdWVzLmhhc093blByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAgICBzUHJlZml4ZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgIG9Tb2x1dGlvbkJlc3Qub1ByaW1pdGl2ZVZhbHVlc1tzUHJlZml4ZWRdLm5TYXZpbmcgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgWyduYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9Tb2x1dGlvbkJlc3Qub1ByaW1pdGl2ZVZhbHVlc1tzUHJlZml4ZWRdLnNOYW1lXSA6XG4gICAgICAgICAgICAgICAgICAgICAgIFsnc3RyaW5nJywgc1N0cmluZ1ZhbHVlXTtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICogU3VjaCBkYXRhIG9uIHdoYXQgdG8gY29uc29saWRhdGUgd2l0aGluIHRoZSByYW5nZSBvZiBzb3VyY2VcbiAgICAgICAgICAgICAgICAqIGVsZW1lbnRzIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIGNvbnNpZGVyZWQgdGhhdCBsZWFkIHRvIHRoZVxuICAgICAgICAgICAgICAgICogZ3JlYXRlc3Qga25vd24gcmVkdWN0aW9uIG9mIHRoZSBudW1iZXIgb2YgdGhlIHRlcm1pbmFsIHN5bWJvbHNcbiAgICAgICAgICAgICAgICAqIGluIGNvbXBhcmlzb24gdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSB0ZXh0LlxuICAgICAgICAgICAgICAgICogQHR5cGUgeyFUU29sdXRpb259XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgIG9Tb2x1dGlvbkJlc3QgPSBuZXcgVFNvbHV0aW9uKCksXG4gICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAqIERhdGEgcmVwcmVzZW50aW5nIGFuIG9uZ29pbmcgYXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyXG4gICAgICAgICAgICAgICAgKiByZWR1Y3Rpb24gb2YgdGhlIG51bWJlciBvZiB0aGUgdGVybWluYWwgc3ltYm9scyBpbiBjb21wYXJpc29uXG4gICAgICAgICAgICAgICAgKiB0byB0aGUgb3JpZ2luYWwgc291cmNlIHRleHQgdGhhbiB0aGUgYmVzdCBvbmUgdGhhdCBpc1xuICAgICAgICAgICAgICAgICogY3VycmVudGx5IGtub3duLlxuICAgICAgICAgICAgICAgICogQHR5cGUgeyFUU29sdXRpb259XG4gICAgICAgICAgICAgICAgKiBAc2VlIG9Tb2x1dGlvbkJlc3RcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgb1NvbHV0aW9uQ2FuZGlkYXRlID0gbmV3IFRTb2x1dGlvbigpLFxuICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBBIHJlY29yZCBjb25zaXN0aW5nIG9mIGRhdGEgYWJvdXQgdGhlIHJhbmdlIG9mIHNvdXJjZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgICogdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgZXhhbWluZWQuXG4gICAgICAgICAgICAgICAgKiBAdHlwZSB7IVRTb3VyY2VFbGVtZW50c0RhdGF9XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgIG9Tb3VyY2VFbGVtZW50c0RhdGEgPSBuZXcgVFNvdXJjZUVsZW1lbnRzRGF0YSgpLFxuICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBWYXJpYWJsZSBkZWNsYXJhdGlvbnMgZm9yIGVhY2ggcHJpbWl0aXZlIHZhbHVlIHRoYXQgaXMgdG8gYmVcbiAgICAgICAgICAgICAgICAqIGNvbnNvbGlkYXRlZCB3aXRoaW4gdGhlIGVsZW1lbnRzLlxuICAgICAgICAgICAgICAgICogQHR5cGUgeyFBcnJheS48IUFycmF5Pn1cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgYVZhcmlhYmxlRGVjbGFyYXRpb25zID0gW10sXG4gICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAqIEF1Z21lbnRzIGEgbGlzdCB3aXRoIGEgcHJlZml4ZWQgcmVwcmVzZW50YXRpb24gU3RyaW5nLlxuICAgICAgICAgICAgICAgICogQHBhcmFtIHshQXJyYXkuPHN0cmluZz59IGFMaXN0IEEgbGlzdCB0aGF0IGlzIHRvIGJlIGF1Z21lbnRlZC5cbiAgICAgICAgICAgICAgICAqIEByZXR1cm4ge2Z1bmN0aW9uKHN0cmluZyl9IEEgZnVuY3Rpb24gdGhhdCBhdWdtZW50cyBhIGxpc3RcbiAgICAgICAgICAgICAgICAqICAgICB3aXRoIGEgcHJlZml4ZWQgcmVwcmVzZW50YXRpb24gU3RyaW5nLlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICBjQXVnbWVudExpc3QgPSBmdW5jdGlvbihhTGlzdCkge1xuICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNQcmVmaXhlZCBQcmVmaXhlZCByZXByZXNlbnRhdGlvbiBTdHJpbmcgb2ZcbiAgICAgICAgICAgICAgICAgICogICAgIGEgcHJpbWl0aXZlIHZhbHVlIHRoYXQgY291bGQgYmUgY29uc29saWRhdGVkIHdpdGhpbiB0aGVcbiAgICAgICAgICAgICAgICAgICogICAgIGVsZW1lbnRzLlxuICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgdmFyIGZMYW1iZGEgPSBmdW5jdGlvbihzUHJlZml4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICBpZiAoLTEgPT09IGFMaXN0LmluZGV4T2Yoc1ByZWZpeGVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgYUxpc3QucHVzaChzUHJlZml4ZWQpO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICByZXR1cm4gZkxhbWJkYTtcbiAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAqIEFkZHMgdGhlIG51bWJlciBvZiBvY2N1cnJlbmNlcyBvZiBhIHByaW1pdGl2ZSB2YWx1ZSBvZiBhIGdpdmVuXG4gICAgICAgICAgICAgICAgKiBjYXRlZ29yeSB0aGF0IGNvdWxkIGJlIGNvbnNvbGlkYXRlZCBpbiB0aGUgc291cmNlIGVsZW1lbnQgd2l0aFxuICAgICAgICAgICAgICAgICogYSBnaXZlbiBpbmRleCB0byB0aGUgY291bnQgb2Ygb2NjdXJyZW5jZXMgb2YgdGhhdCBwcmltaXRpdmVcbiAgICAgICAgICAgICAgICAqIHZhbHVlIHdpdGhpbiB0aGUgcmFuZ2Ugb2Ygc291cmNlIGVsZW1lbnRzIHRoYXQgaXMgY3VycmVudGx5XG4gICAgICAgICAgICAgICAgKiBiZWluZyBjb25zaWRlcmVkLlxuICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5Qb3NpdGlvbiBUaGUgaW5kZXggKGluIHRoZSBzb3VyY2UgdGV4dCBvcmRlcilcbiAgICAgICAgICAgICAgICAqICAgICBvZiBhIHNvdXJjZSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5DYXRlZ29yeSBUaGUgY2F0ZWdvcnkgb2YgdGhlIHByaW1hcnlcbiAgICAgICAgICAgICAgICAqICAgICBleHByZXNzaW9uIGZyb20gd2hpY2ggdGhlIHByaW1pdGl2ZSB2YWx1ZSBpcyBkZXJpdmVkLlxuICAgICAgICAgICAgICAgICogQHJldHVybiB7ZnVuY3Rpb24oc3RyaW5nKX0gQSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIHRoZVxuICAgICAgICAgICAgICAgICogICAgIGFkZGl0aW9uLlxuICAgICAgICAgICAgICAgICogQHNlZSBjQWRkT2NjdXJyZW5jZXNJbkNhdGVnb3J5XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgIGNBZGRPY2N1cnJlbmNlcyA9IGZ1bmN0aW9uKG5Qb3NpdGlvbiwgbkNhdGVnb3J5KSB7XG4gICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1ByZWZpeGVkIFRoZSBwcmVmaXhlZCByZXByZXNlbnRhdGlvbiBTdHJpbmdcbiAgICAgICAgICAgICAgICAgICogICAgIG9mIGEgcHJpbWl0aXZlIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgdmFyIGZMYW1iZGEgPSBmdW5jdGlvbihzUHJlZml4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICBpZiAoIW9Tb3VyY2VFbGVtZW50c0RhdGEuYUNvdW50W25DYXRlZ29yeV0uaGFzT3duUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzUHJlZml4ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICBvU291cmNlRWxlbWVudHNEYXRhLmFDb3VudFtuQ2F0ZWdvcnldW3NQcmVmaXhlZF0gPSAwO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICBvU291cmNlRWxlbWVudHNEYXRhLmFDb3VudFtuQ2F0ZWdvcnldW3NQcmVmaXhlZF0gKz1cbiAgICAgICAgICAgICAgICAgICAgICAgYVNvdXJjZUVsZW1lbnRzRGF0YVtuUG9zaXRpb25dLmFDb3VudFtuQ2F0ZWdvcnldW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgc1ByZWZpeGVkXTtcbiAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICByZXR1cm4gZkxhbWJkYTtcbiAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAqIEFkZHMgdGhlIG51bWJlciBvZiBvY2N1cnJlbmNlcyBvZiBlYWNoIHByaW1pdGl2ZSB2YWx1ZSBvZiBhXG4gICAgICAgICAgICAgICAgKiBnaXZlbiBjYXRlZ29yeSB0aGF0IGNvdWxkIGJlIGNvbnNvbGlkYXRlZCBpbiB0aGUgc291cmNlXG4gICAgICAgICAgICAgICAgKiBlbGVtZW50IHdpdGggYSBnaXZlbiBpbmRleCB0byB0aGUgY291bnQgb2Ygb2NjdXJyZW5jZXMgb2YgdGhhdFxuICAgICAgICAgICAgICAgICogcHJpbWl0aXZlIHZhbHVlcyB3aXRoaW4gdGhlIHJhbmdlIG9mIHNvdXJjZSBlbGVtZW50cyB0aGF0IGlzXG4gICAgICAgICAgICAgICAgKiBjdXJyZW50bHkgYmVpbmcgY29uc2lkZXJlZC5cbiAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuUG9zaXRpb24gVGhlIGluZGV4IChpbiB0aGUgc291cmNlIHRleHQgb3JkZXIpXG4gICAgICAgICAgICAgICAgKiAgICAgb2YgYSBzb3VyY2UgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAqIEByZXR1cm4ge2Z1bmN0aW9uKG51bWJlcil9IEEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyB0aGVcbiAgICAgICAgICAgICAgICAqICAgICBhZGRpdGlvbi5cbiAgICAgICAgICAgICAgICAqIEBzZWUgZkFkZE9jY3VycmVuY2VzXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgIGNBZGRPY2N1cnJlbmNlc0luQ2F0ZWdvcnkgPSBmdW5jdGlvbihuUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuQ2F0ZWdvcnkgVGhlIGNhdGVnb3J5IG9mIHRoZSBwcmltYXJ5XG4gICAgICAgICAgICAgICAgICAqICAgICBleHByZXNzaW9uIGZyb20gd2hpY2ggdGhlIHByaW1pdGl2ZSB2YWx1ZSBpcyBkZXJpdmVkLlxuICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgdmFyIGZMYW1iZGEgPSBmdW5jdGlvbihuQ2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhcbiAgICAgICAgICAgICAgICAgICAgICAgYVNvdXJjZUVsZW1lbnRzRGF0YVtuUG9zaXRpb25dLmFDb3VudFtuQ2F0ZWdvcnldXG4gICAgICAgICAgICAgICAgICAgKS5mb3JFYWNoKGNBZGRPY2N1cnJlbmNlcyhuUG9zaXRpb24sIG5DYXRlZ29yeSkpO1xuICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgIHJldHVybiBmTGFtYmRhO1xuICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICogQWRkcyB0aGUgbnVtYmVyIG9mIG9jY3VycmVuY2VzIG9mIGVhY2ggcHJpbWl0aXZlIHZhbHVlIHRoYXRcbiAgICAgICAgICAgICAgICAqIGNvdWxkIGJlIGNvbnNvbGlkYXRlZCBpbiB0aGUgc291cmNlIGVsZW1lbnQgd2l0aCBhIGdpdmVuIGluZGV4XG4gICAgICAgICAgICAgICAgKiB0byB0aGUgY291bnQgb2Ygb2NjdXJyZW5jZXMgb2YgdGhhdCBwcmltaXRpdmUgdmFsdWVzIHdpdGhpblxuICAgICAgICAgICAgICAgICogdGhlIHJhbmdlIG9mIHNvdXJjZSBlbGVtZW50cyB0aGF0IGlzIGN1cnJlbnRseSBiZWluZ1xuICAgICAgICAgICAgICAgICogY29uc2lkZXJlZC5cbiAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuUG9zaXRpb24gVGhlIGluZGV4IChpbiB0aGUgc291cmNlIHRleHQgb3JkZXIpXG4gICAgICAgICAgICAgICAgKiAgICAgb2YgYSBzb3VyY2UgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgZkFkZE9jY3VycmVuY2VzID0gZnVuY3Rpb24oblBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGFTb3VyY2VFbGVtZW50c0RhdGFbblBvc2l0aW9uXS5hQ291bnQpLmZvckVhY2goXG4gICAgICAgICAgICAgICAgICAgICBjQWRkT2NjdXJyZW5jZXNJbkNhdGVnb3J5KG5Qb3NpdGlvbikpO1xuICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICogQ3JlYXRlcyBhIHZhcmlhYmxlIGRlY2xhcmF0aW9uIGZvciBhIHByaW1pdGl2ZSB2YWx1ZSBpZiB0aGF0XG4gICAgICAgICAgICAgICAgKiBwcmltaXRpdmUgdmFsdWUgaXMgdG8gYmUgY29uc29saWRhdGVkIHdpdGhpbiB0aGUgZWxlbWVudHMuXG4gICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1ByZWZpeGVkIFByZWZpeGVkIHJlcHJlc2VudGF0aW9uIFN0cmluZyBvZiBhXG4gICAgICAgICAgICAgICAgKiAgICAgcHJpbWl0aXZlIHZhbHVlIHRoYXQgY291bGQgYmUgY29uc29saWRhdGVkIHdpdGhpbiB0aGVcbiAgICAgICAgICAgICAgICAqICAgICBlbGVtZW50cy5cbiAgICAgICAgICAgICAgICAqIEBzZWUgYVZhcmlhYmxlRGVjbGFyYXRpb25zXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgIGNBdWdtZW50VmFyaWFibGVEZWNsYXJhdGlvbnMgPSBmdW5jdGlvbihzUHJlZml4ZWQpIHtcbiAgICAgICAgICAgICAgICAgaWYgKG9Tb2x1dGlvbkJlc3Qub1ByaW1pdGl2ZVZhbHVlc1tzUHJlZml4ZWRdLm5TYXZpbmcgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgYVZhcmlhYmxlRGVjbGFyYXRpb25zLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgb1NvbHV0aW9uQmVzdC5vUHJpbWl0aXZlVmFsdWVzW3NQcmVmaXhlZF0uc05hbWUsXG4gICAgICAgICAgICAgICAgICAgICBbMCA9PT0gc1ByZWZpeGVkLmluZGV4T2YoRVZhbHVlUHJlZml4ZXMuU19TWU1CT0xJQykgP1xuICAgICAgICAgICAgICAgICAgICAgICduYW1lJyA6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgIHNQcmVmaXhlZC5zdWJzdHJpbmcoRVZhbHVlUHJlZml4ZXMuU19TWU1CT0xJQy5sZW5ndGgpXVxuICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBTb3J0cyBwcmltaXRpdmUgdmFsdWVzIHdpdGggcmVnYXJkIHRvIHRoZSBkaWZmZXJlbmNlIGluIHRoZVxuICAgICAgICAgICAgICAgICogbnVtYmVyIG9mIHRlcm1pbmFsIHN5bWJvbHMgYmV0d2VlbiB0aGUgb3JpZ2luYWwgc291cmNlIHRleHRcbiAgICAgICAgICAgICAgICAqIGFuZCB0aGUgb25lIHdpdGggdGhvc2UgcHJpbWl0aXZlIHZhbHVlcyBjb25zb2xpZGF0ZWQuXG4gICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1ByZWZpeGVkMCBUaGUgcHJlZml4ZWQgcmVwcmVzZW50YXRpb24gU3RyaW5nXG4gICAgICAgICAgICAgICAgKiAgICAgb2YgdGhlIGZpcnN0IG9mIHRoZSB0d28gcHJpbWl0aXZlIHZhbHVlcyB0aGF0IGFyZSBiZWluZ1xuICAgICAgICAgICAgICAgICogICAgIGNvbXBhcmVkLlxuICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNQcmVmaXhlZDEgVGhlIHByZWZpeGVkIHJlcHJlc2VudGF0aW9uIFN0cmluZ1xuICAgICAgICAgICAgICAgICogICAgIG9mIHRoZSBzZWNvbmQgb2YgdGhlIHR3byBwcmltaXRpdmUgdmFsdWVzIHRoYXQgYXJlIGJlaW5nXG4gICAgICAgICAgICAgICAgKiAgICAgY29tcGFyZWQuXG4gICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAgICAgICAgKiAgICAgPGRsPlxuICAgICAgICAgICAgICAgICogICAgICAgICA8ZHQ+LTE8L2R0PlxuICAgICAgICAgICAgICAgICogICAgICAgICA8ZGQ+aWYgdGhlIGZpcnN0IHByaW1pdGl2ZSB2YWx1ZSBtdXN0IGJlIHBsYWNlZCBiZWZvcmVcbiAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICB0aGUgb3RoZXIgb25lLDwvZGQ+XG4gICAgICAgICAgICAgICAgKiAgICAgICAgIDxkdD4wPC9kdD5cbiAgICAgICAgICAgICAgICAqICAgICAgICAgPGRkPmlmIHRoZSBmaXJzdCBwcmltaXRpdmUgdmFsdWUgbWF5IGJlIHBsYWNlZCBiZWZvcmVcbiAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICB0aGUgb3RoZXIgb25lLDwvZGQ+XG4gICAgICAgICAgICAgICAgKiAgICAgICAgIDxkdD4xPC9kdD5cbiAgICAgICAgICAgICAgICAqICAgICAgICAgPGRkPmlmIHRoZSBmaXJzdCBwcmltaXRpdmUgdmFsdWUgbXVzdCBub3QgYmUgcGxhY2VkXG4gICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgYmVmb3JlIHRoZSBvdGhlciBvbmUuPC9kZD5cbiAgICAgICAgICAgICAgICAqICAgICA8L2RsPlxuICAgICAgICAgICAgICAgICogQHNlZSBUU29sdXRpb24ub1ByaW1pdGl2ZVZhbHVlc1xuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICBjU29ydFByaW1pdGl2ZVZhbHVlcyA9IGZ1bmN0aW9uKHNQcmVmaXhlZDAsIHNQcmVmaXhlZDEpIHtcbiAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW46XG4gICAgICAgICAgICAgICAgICAqIDxvbD5cbiAgICAgICAgICAgICAgICAgICogPGxpPnRoZSBkaWZmZXJlbmNlIGluIHRoZSBudW1iZXIgb2YgdGVybWluYWwgc3ltYm9sc1xuICAgICAgICAgICAgICAgICAgKiAgICAgYmV0d2VlbiB0aGUgb3JpZ2luYWwgc291cmNlIHRleHQgYW5kIHRoZSBvbmUgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAgICogICAgIGZpcnN0IHByaW1pdGl2ZSB2YWx1ZSBjb25zb2xpZGF0ZWQsIGFuZDwvbGk+XG4gICAgICAgICAgICAgICAgICAqIDxsaT50aGUgZGlmZmVyZW5jZSBpbiB0aGUgbnVtYmVyIG9mIHRlcm1pbmFsIHN5bWJvbHNcbiAgICAgICAgICAgICAgICAgICogICAgIGJldHdlZW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0ZXh0IGFuZCB0aGUgb25lIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgICAqICAgICBzZWNvbmQgcHJpbWl0aXZlIHZhbHVlIGNvbnNvbGlkYXRlZC48L2xpPlxuICAgICAgICAgICAgICAgICAgKiA8L29sPlxuICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgdmFyIG5EaWZmZXJlbmNlID1cbiAgICAgICAgICAgICAgICAgICAgIG9Tb2x1dGlvbkNhbmRpZGF0ZS5vUHJpbWl0aXZlVmFsdWVzW3NQcmVmaXhlZDBdLm5TYXZpbmcgLVxuICAgICAgICAgICAgICAgICAgICAgb1NvbHV0aW9uQ2FuZGlkYXRlLm9QcmltaXRpdmVWYWx1ZXNbc1ByZWZpeGVkMV0ublNhdmluZztcblxuICAgICAgICAgICAgICAgICByZXR1cm4gbkRpZmZlcmVuY2UgPiAwID8gLTEgOiBuRGlmZmVyZW5jZSA8IDAgPyAxIDogMDtcbiAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAqIEFzc2lnbnMgYW4gaWRlbnRpZmllciBuYW1lIHRvIGEgcHJpbWl0aXZlIHZhbHVlIGFuZCBjYWxjdWxhdGVzXG4gICAgICAgICAgICAgICAgKiB3aGV0aGVyIGluc3RhbmNlcyBvZiB0aGF0IHByaW1pdGl2ZSB2YWx1ZSBhcmUgd29ydGhcbiAgICAgICAgICAgICAgICAqIGNvbnNvbGlkYXRpbmcuXG4gICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1ByZWZpeGVkIFRoZSBwcmVmaXhlZCByZXByZXNlbnRhdGlvbiBTdHJpbmdcbiAgICAgICAgICAgICAgICAqICAgICBvZiBhIHByaW1pdGl2ZSB2YWx1ZSB0aGF0IGlzIGJlaW5nIGV2YWx1YXRlZC5cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgZkV2YWx1YXRlUHJpbWl0aXZlVmFsdWUgPSBmdW5jdGlvbihzUHJlZml4ZWQpIHtcbiAgICAgICAgICAgICAgICAgdmFyIF8sXG4gICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAqIFRoZSBpbmRleCBvZiB0aGUgbGFzdCBtYW5nbGVkIG5hbWUuXG4gICAgICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICBuSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAqIFRoZSByZXByZXNlbnRhdGlvbiBTdHJpbmcgb2YgdGhlIHByaW1pdGl2ZSB2YWx1ZSB0aGF0IGlzXG4gICAgICAgICAgICAgICAgICAgICAgKiBiZWluZyBldmFsdWF0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICBzTmFtZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgc1ByZWZpeGVkLnN1YnN0cmluZyhFVmFsdWVQcmVmaXhlcy5TX1NZTUJPTElDLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAqIFRoZSBudW1iZXIgb2Ygc291cmNlIGNoYXJhY3RlcnMgdGFrZW4gdXAgYnkgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgKiByZXByZXNlbnRhdGlvbiBTdHJpbmcgb2YgdGhlIHByaW1pdGl2ZSB2YWx1ZSB0aGF0IGlzXG4gICAgICAgICAgICAgICAgICAgICAgKiBiZWluZyBldmFsdWF0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICBuTGVuZ3RoT3JpZ2luYWwgPSBzTmFtZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAqIFRoZSBudW1iZXIgb2Ygc291cmNlIGNoYXJhY3RlcnMgdGFrZW4gdXAgYnkgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgKiBpZGVudGlmaWVyIG5hbWUgdGhhdCBjb3VsZCBzdWJzdGl0dXRlIHRoZSBwcmltaXRpdmVcbiAgICAgICAgICAgICAgICAgICAgICAqIHZhbHVlIHRoYXQgaXMgYmVpbmcgZXZhbHVhdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICogc3Vic3RpdHV0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICBuTGVuZ3RoU3Vic3RpdHV0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHNvdXJjZSBjaGFyYWN0ZXJzIHRha2VuIHVwIGJ5IGJ5IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICogcmVwcmVzZW50YXRpb24gU3RyaW5nIG9mIHRoZSBwcmltaXRpdmUgdmFsdWUgdGhhdCBpc1xuICAgICAgICAgICAgICAgICAgICAgICogYmVpbmcgZXZhbHVhdGVkIHdoZW4gaXQgaXMgcmVwcmVzZW50ZWQgYnkgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAqIGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICBuTGVuZ3RoU3RyaW5nID0gb1Byb2Nlc3Nvci5tYWtlX3N0cmluZyhzTmFtZSkubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgIG9Tb2x1dGlvbkNhbmRpZGF0ZS5vUHJpbWl0aXZlVmFsdWVzW3NQcmVmaXhlZF0gPVxuICAgICAgICAgICAgICAgICAgICAgbmV3IFRQcmltaXRpdmVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICBkbyB7ICAvLyBGaW5kIGFuIGlkZW50aWZpZXIgdW51c2VkIGluIHRoaXMgb3IgYW55IG5lc3RlZCBzY29wZS5cbiAgICAgICAgICAgICAgICAgICBuSW5kZXggPSBvU2NvcGUuY25hbWU7XG4gICAgICAgICAgICAgICAgICAgb1NvbHV0aW9uQ2FuZGlkYXRlLm9QcmltaXRpdmVWYWx1ZXNbc1ByZWZpeGVkXS5zTmFtZSA9XG4gICAgICAgICAgICAgICAgICAgICAgIG9TY29wZS5uZXh0X21hbmdsZWQoKTtcbiAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLTEgIT09IG9Tb3VyY2VFbGVtZW50c0RhdGEuYUlkZW50aWZpZXJzLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICBvU29sdXRpb25DYW5kaWRhdGUub1ByaW1pdGl2ZVZhbHVlc1tzUHJlZml4ZWRdLnNOYW1lKSk7XG4gICAgICAgICAgICAgICAgIG5MZW5ndGhTdWJzdGl0dXRpb24gPSBvU29sdXRpb25DYW5kaWRhdGUub1ByaW1pdGl2ZVZhbHVlc1tcbiAgICAgICAgICAgICAgICAgICAgIHNQcmVmaXhlZF0uc05hbWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gc1ByZWZpeGVkLmluZGV4T2YoRVZhbHVlUHJlZml4ZXMuU19TWU1CT0xJQykpIHtcbiAgICAgICAgICAgICAgICAgICAvLyBmb286bnVsbCwgb3IgZm9vOm51bGw7XG4gICAgICAgICAgICAgICAgICAgb1NvbHV0aW9uQ2FuZGlkYXRlLm9QcmltaXRpdmVWYWx1ZXNbc1ByZWZpeGVkXS5uU2F2aW5nIC09XG4gICAgICAgICAgICAgICAgICAgICAgIG5MZW5ndGhTdWJzdGl0dXRpb24gKyBuTGVuZ3RoT3JpZ2luYWwgK1xuICAgICAgICAgICAgICAgICAgICAgICBvV2VpZ2h0cy5OX1ZBUklBQkxFX0RFQ0xBUkFUSU9OO1xuICAgICAgICAgICAgICAgICAgIC8vIG51bGwgdnMgZm9vXG4gICAgICAgICAgICAgICAgICAgb1NvbHV0aW9uQ2FuZGlkYXRlLm9QcmltaXRpdmVWYWx1ZXNbc1ByZWZpeGVkXS5uU2F2aW5nICs9XG4gICAgICAgICAgICAgICAgICAgICAgIG9Tb3VyY2VFbGVtZW50c0RhdGEuYUNvdW50W1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgRVByaW1hcnlFeHByZXNzaW9uQ2F0ZWdvcmllcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOX05VTExfQU5EX0JPT0xFQU5fTElURVJBTFNdW3NQcmVmaXhlZF0gKlxuICAgICAgICAgICAgICAgICAgICAgICAobkxlbmd0aE9yaWdpbmFsIC0gbkxlbmd0aFN1YnN0aXR1dGlvbik7XG4gICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgLy8gZm9vOidmcm9tQ2hhckNvZGUnO1xuICAgICAgICAgICAgICAgICAgIG9Tb2x1dGlvbkNhbmRpZGF0ZS5vUHJpbWl0aXZlVmFsdWVzW3NQcmVmaXhlZF0ublNhdmluZyAtPVxuICAgICAgICAgICAgICAgICAgICAgICBuTGVuZ3RoU3Vic3RpdHV0aW9uICsgbkxlbmd0aFN0cmluZyArXG4gICAgICAgICAgICAgICAgICAgICAgIG9XZWlnaHRzLk5fVkFSSUFCTEVfREVDTEFSQVRJT047XG4gICAgICAgICAgICAgICAgICAgLy8gLmZyb21DaGFyQ29kZSB2cyBbZm9vXVxuICAgICAgICAgICAgICAgICAgIGlmIChvU291cmNlRWxlbWVudHNEYXRhLmFDb3VudFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEVQcmltYXJ5RXhwcmVzc2lvbkNhdGVnb3JpZXMuTl9JREVOVElGSUVSX05BTUVTXG4gICAgICAgICAgICAgICAgICAgICAgIF0uaGFzT3duUHJvcGVydHkoc1ByZWZpeGVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgb1NvbHV0aW9uQ2FuZGlkYXRlLm9QcmltaXRpdmVWYWx1ZXNbc1ByZWZpeGVkXS5uU2F2aW5nICs9XG4gICAgICAgICAgICAgICAgICAgICAgICAgb1NvdXJjZUVsZW1lbnRzRGF0YS5hQ291bnRbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVQcmltYXJ5RXhwcmVzc2lvbkNhdGVnb3JpZXMuTl9JREVOVElGSUVSX05BTUVTXG4gICAgICAgICAgICAgICAgICAgICAgICAgXVtzUHJlZml4ZWRdICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAobkxlbmd0aE9yaWdpbmFsIC0gbkxlbmd0aFN1YnN0aXR1dGlvbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9XZWlnaHRzLk5fUFJPUEVSVFlfQUNDRVNTT1IpO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAvLyAnZnJvbUNoYXJDb2RlJyB2cyBmb29cbiAgICAgICAgICAgICAgICAgICBpZiAob1NvdXJjZUVsZW1lbnRzRGF0YS5hQ291bnRbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBFUHJpbWFyeUV4cHJlc3Npb25DYXRlZ29yaWVzLk5fU1RSSU5HX0xJVEVSQUxTXG4gICAgICAgICAgICAgICAgICAgICAgIF0uaGFzT3duUHJvcGVydHkoc1ByZWZpeGVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgb1NvbHV0aW9uQ2FuZGlkYXRlLm9QcmltaXRpdmVWYWx1ZXNbc1ByZWZpeGVkXS5uU2F2aW5nICs9XG4gICAgICAgICAgICAgICAgICAgICAgICAgb1NvdXJjZUVsZW1lbnRzRGF0YS5hQ291bnRbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVQcmltYXJ5RXhwcmVzc2lvbkNhdGVnb3JpZXMuTl9TVFJJTkdfTElURVJBTFNcbiAgICAgICAgICAgICAgICAgICAgICAgICBdW3NQcmVmaXhlZF0gKlxuICAgICAgICAgICAgICAgICAgICAgICAgIChuTGVuZ3RoU3RyaW5nIC0gbkxlbmd0aFN1YnN0aXR1dGlvbik7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgIGlmIChvU29sdXRpb25DYW5kaWRhdGUub1ByaW1pdGl2ZVZhbHVlc1tzUHJlZml4ZWRdLm5TYXZpbmcgPlxuICAgICAgICAgICAgICAgICAgICAgMCkge1xuICAgICAgICAgICAgICAgICAgIG9Tb2x1dGlvbkNhbmRpZGF0ZS5uU2F2aW5ncyArPVxuICAgICAgICAgICAgICAgICAgICAgICBvU29sdXRpb25DYW5kaWRhdGUub1ByaW1pdGl2ZVZhbHVlc1tzUHJlZml4ZWRdLm5TYXZpbmc7XG4gICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgb1Njb3BlLmNuYW1lID0gbkluZGV4OyAvLyBGcmVlIHRoZSBpZGVudGlmaWVyIG5hbWUuXG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAqIEFkZHMgYSB2YXJpYWJsZSBkZWNsYXJhdGlvbiB0byBhbiBleGlzdGluZyB2YXJpYWJsZSBzdGF0ZW1lbnQuXG4gICAgICAgICAgICAgICAgKiBAcGFyYW0geyFBcnJheX0gYVZhcmlhYmxlRGVjbGFyYXRpb24gQSB2YXJpYWJsZSBkZWNsYXJhdGlvblxuICAgICAgICAgICAgICAgICogICAgIHdpdGggYW4gaW5pdGlhbGlzZXIuXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgIGNBZGRWYXJpYWJsZURlY2xhcmF0aW9uID0gZnVuY3Rpb24oYVZhcmlhYmxlRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgKC8qKiBAdHlwZSB7IUFycmF5fSAqLyBvU291cmNlRWxlbWVudHNbbkZyb21dWzFdKS51bnNoaWZ0KFxuICAgICAgICAgICAgICAgICAgICAgYVZhcmlhYmxlRGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICBpZiAobkZyb20gPiBuVG8pIHtcbiAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgLy8gSWYgdGhlIHJhbmdlIGlzIGEgY2xvc3VyZSwgcmV1c2UgdGhlIGNsb3N1cmUuXG4gICAgICAgICAgIGlmIChuRnJvbSA9PT0gblRvICYmXG4gICAgICAgICAgICAgICAnc3RhdCcgPT09IG9Tb3VyY2VFbGVtZW50c1tuRnJvbV1bMF0gJiZcbiAgICAgICAgICAgICAgICdjYWxsJyA9PT0gb1NvdXJjZUVsZW1lbnRzW25Gcm9tXVsxXVswXSAmJlxuICAgICAgICAgICAgICAgJ2Z1bmN0aW9uJyA9PT0gb1NvdXJjZUVsZW1lbnRzW25Gcm9tXVsxXVsxXVswXSkge1xuICAgICAgICAgICAgIGZFeGFtaW5lU3ludGFjdGljQ29kZVVuaXQob1NvdXJjZUVsZW1lbnRzW25Gcm9tXVsxXVsxXSk7XG4gICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIC8vIENyZWF0ZSBhIGxpc3Qgb2YgYWxsIGRlcml2ZWQgcHJpbWl0aXZlIHZhbHVlcyB3aXRoaW4gdGhlIHJhbmdlLlxuICAgICAgICAgICBmb3IgKG5Qb3NpdGlvbiA9IG5Gcm9tOyBuUG9zaXRpb24gPD0gblRvOyBuUG9zaXRpb24gKz0gMSkge1xuICAgICAgICAgICAgIGFTb3VyY2VFbGVtZW50c0RhdGFbblBvc2l0aW9uXS5hUHJpbWl0aXZlVmFsdWVzLmZvckVhY2goXG4gICAgICAgICAgICAgICAgIGNBdWdtZW50TGlzdChvU291cmNlRWxlbWVudHNEYXRhLmFQcmltaXRpdmVWYWx1ZXMpKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICBpZiAoMCA9PT0gb1NvdXJjZUVsZW1lbnRzRGF0YS5hUHJpbWl0aXZlVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgfVxuICAgICAgICAgICBmb3IgKG5Qb3NpdGlvbiA9IG5Gcm9tOyBuUG9zaXRpb24gPD0gblRvOyBuUG9zaXRpb24gKz0gMSkge1xuICAgICAgICAgICAgIC8vIEFkZCB0aGUgbnVtYmVyIG9mIG9jY3VycmVuY2VzIHRvIHRoZSB0b3RhbCBjb3VudC5cbiAgICAgICAgICAgICBmQWRkT2NjdXJyZW5jZXMoblBvc2l0aW9uKTtcbiAgICAgICAgICAgICAvLyBBZGQgaWRlbnRpZmllcnMgb2YgdGhpcyBvciBhbnkgbmVzdGVkIHNjb3BlIHRvIHRoZSBsaXN0LlxuICAgICAgICAgICAgIGFTb3VyY2VFbGVtZW50c0RhdGFbblBvc2l0aW9uXS5hSWRlbnRpZmllcnMuZm9yRWFjaChcbiAgICAgICAgICAgICAgICAgY0F1Z21lbnRMaXN0KG9Tb3VyY2VFbGVtZW50c0RhdGEuYUlkZW50aWZpZXJzKSk7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgLy8gRGlzdHJpYnV0ZSBpZGVudGlmaWVyIG5hbWVzIGFtb25nIGRlcml2ZWQgcHJpbWl0aXZlIHZhbHVlcy5cbiAgICAgICAgICAgZG8geyAgLy8gSWYgdGhlcmUgd2FzIGFueSBwcm9ncmVzcywgZmluZCBhIGJldHRlciBkaXN0cmlidXRpb24uXG4gICAgICAgICAgICAgb1NvbHV0aW9uQmVzdCA9IG9Tb2x1dGlvbkNhbmRpZGF0ZTtcbiAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMob1NvbHV0aW9uQ2FuZGlkYXRlLm9QcmltaXRpdmVWYWx1ZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgIC8vIFNvcnQgcHJpbWl0aXZlIHZhbHVlcyBkZXNjZW5kaW5nIGJ5IHRoZWlyIHdvcnRod2hpbGVuZXNzLlxuICAgICAgICAgICAgICAgb1NvdXJjZUVsZW1lbnRzRGF0YS5hUHJpbWl0aXZlVmFsdWVzLnNvcnQoY1NvcnRQcmltaXRpdmVWYWx1ZXMpO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICBvU29sdXRpb25DYW5kaWRhdGUgPSBuZXcgVFNvbHV0aW9uKCk7XG4gICAgICAgICAgICAgb1NvdXJjZUVsZW1lbnRzRGF0YS5hUHJpbWl0aXZlVmFsdWVzLmZvckVhY2goXG4gICAgICAgICAgICAgICAgIGZFdmFsdWF0ZVByaW1pdGl2ZVZhbHVlKTtcbiAgICAgICAgICAgICBvU2NvcGUuY25hbWUgPSBuSW5kZXg7XG4gICAgICAgICAgIH0gd2hpbGUgKG9Tb2x1dGlvbkNhbmRpZGF0ZS5uU2F2aW5ncyA+IG9Tb2x1dGlvbkJlc3QublNhdmluZ3MpO1xuICAgICAgICAgICAvLyBUYWtlIHRoZSBuZWNlc3NpdHkgb2YgYWRkaW5nIGEgdmFyaWFibGUgc3RhdGVtZW50IGludG8gYWNjb3VudC5cbiAgICAgICAgICAgaWYgKCd2YXInICE9PSBvU291cmNlRWxlbWVudHNbbkZyb21dWzBdKSB7XG4gICAgICAgICAgICAgb1NvbHV0aW9uQmVzdC5uU2F2aW5ncyAtPSBvV2VpZ2h0cy5OX1ZBUklBQkxFX1NUQVRFTUVOVF9BRkZJWEFUSU9OO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIGlmIChiRW5jbG9zZSkge1xuICAgICAgICAgICAgIC8vIFRha2UgdGhlIG5lY2Vzc2l0eSBvZiBmb3JtaW5nIGEgY2xvc3VyZSBpbnRvIGFjY291bnQuXG4gICAgICAgICAgICAgb1NvbHV0aW9uQmVzdC5uU2F2aW5ncyAtPSBvV2VpZ2h0cy5OX0NMT1NVUkU7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgaWYgKG9Tb2x1dGlvbkJlc3QublNhdmluZ3MgPiAwKSB7XG4gICAgICAgICAgICAgLy8gQ3JlYXRlIHZhcmlhYmxlIGRlY2xhcmF0aW9ucyBzdWl0YWJsZSBmb3IgVWdsaWZ5SlMuXG4gICAgICAgICAgICAgT2JqZWN0LmtleXMob1NvbHV0aW9uQmVzdC5vUHJpbWl0aXZlVmFsdWVzKS5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICBjQXVnbWVudFZhcmlhYmxlRGVjbGFyYXRpb25zKTtcbiAgICAgICAgICAgICAvLyBSZXdyaXRlIGV4cHJlc3Npb25zIHRoYXQgY29udGFpbiB3b3J0aHdoaWxlIHByaW1pdGl2ZSB2YWx1ZXMuXG4gICAgICAgICAgICAgZm9yIChuUG9zaXRpb24gPSBuRnJvbTsgblBvc2l0aW9uIDw9IG5UbzsgblBvc2l0aW9uICs9IDEpIHtcbiAgICAgICAgICAgICAgIG9XYWxrZXIgPSBvUHJvY2Vzc29yLmFzdF93YWxrZXIoKTtcbiAgICAgICAgICAgICAgIG9Tb3VyY2VFbGVtZW50c1tuUG9zaXRpb25dID1cbiAgICAgICAgICAgICAgICAgICBvV2Fsa2VyLndpdGhfd2Fsa2VycyhcbiAgICAgICAgICAgICAgICAgICAgICAgb1dhbGtlcnNUcmFuc2Zvcm1lcnMsXG4gICAgICAgICAgICAgICAgICAgICAgIGNDb250ZXh0KG9XYWxrZXIsIG9Tb3VyY2VFbGVtZW50c1tuUG9zaXRpb25dKSk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgIGlmICgndmFyJyA9PT0gb1NvdXJjZUVsZW1lbnRzW25Gcm9tXVswXSkgeyAgLy8gUmV1c2UgdGhlIHN0YXRlbWVudC5cbiAgICAgICAgICAgICAgICgvKiogQHR5cGUgeyFBcnJheS48IUFycmF5Pn0gKi8gYVZhcmlhYmxlRGVjbGFyYXRpb25zLnJldmVyc2UoXG4gICAgICAgICAgICAgICAgICAgKSkuZm9yRWFjaChjQWRkVmFyaWFibGVEZWNsYXJhdGlvbik7XG4gICAgICAgICAgICAgfSBlbHNlIHsgIC8vIEFkZCBhIHZhcmlhYmxlIHN0YXRlbWVudC5cbiAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChcbiAgICAgICAgICAgICAgICAgICBvU291cmNlRWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgbkZyb20sXG4gICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICBbJ3ZhcicsIGFWYXJpYWJsZURlY2xhcmF0aW9uc10pO1xuICAgICAgICAgICAgICAgblRvICs9IDE7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgIGlmIChiRW5jbG9zZSkge1xuICAgICAgICAgICAgICAgLy8gQWRkIGEgY2xvc3VyZS5cbiAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChcbiAgICAgICAgICAgICAgICAgICBvU291cmNlRWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgbkZyb20sXG4gICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICBbJ3N0YXQnLCBbJ2NhbGwnLCBbJ2Z1bmN0aW9uJywgbnVsbCwgW10sIFtdXSwgW11dXSk7XG4gICAgICAgICAgICAgICAvLyBDb3B5IHNvdXJjZSBlbGVtZW50cyBpbnRvIHRoZSBjbG9zdXJlLlxuICAgICAgICAgICAgICAgZm9yIChuUG9zaXRpb24gPSBuVG8gKyAxOyBuUG9zaXRpb24gPiBuRnJvbTsgblBvc2l0aW9uIC09IDEpIHtcbiAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgIG9Tb3VyY2VFbGVtZW50c1tuRnJvbV1bMV1bMV1bM10sXG4gICAgICAgICAgICAgICAgICAgICBvU291cmNlRWxlbWVudHNbblBvc2l0aW9uXSk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAvLyBSZW1vdmUgc291cmNlIGVsZW1lbnRzIG91dHNpZGUgdGhlIGNsb3N1cmUuXG4gICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgb1NvdXJjZUVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgIG5Gcm9tICsgMSxcbiAgICAgICAgICAgICAgICAgICBuVG8gLSBuRnJvbSArIDEpO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgICBpZiAoYkVuY2xvc2UpIHtcbiAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBhdmFpbGFiaWxpdHkgb2YgaWRlbnRpZmllciBuYW1lcy5cbiAgICAgICAgICAgICBvU2NvcGUuY25hbWUgPSBuSW5kZXg7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH07XG5cbiAgICAgb1NvdXJjZUVsZW1lbnRzID0gKC8qKiBAdHlwZSB7IVRTeW50YWN0aWNDb2RlVW5pdH0gKi9cbiAgICAgICAgIG9TeW50YWN0aWNDb2RlVW5pdFtiSXNHbG9iYWwgPyAxIDogM10pO1xuICAgICBpZiAoMCA9PT0gb1NvdXJjZUVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgIHJldHVybjtcbiAgICAgfVxuICAgICBvU2NvcGUgPSBiSXNHbG9iYWwgPyBvU3ludGFjdGljQ29kZVVuaXQuc2NvcGUgOiBvU291cmNlRWxlbWVudHMuc2NvcGU7XG4gICAgIC8vIFNraXAgYSBEaXJlY3RpdmUgUHJvbG9ndWUuXG4gICAgIHdoaWxlIChuQWZ0ZXJEaXJlY3RpdmVQcm9sb2d1ZSA8IG9Tb3VyY2VFbGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgICAgICdkaXJlY3RpdmUnID09PSBvU291cmNlRWxlbWVudHNbbkFmdGVyRGlyZWN0aXZlUHJvbG9ndWVdWzBdKSB7XG4gICAgICAgbkFmdGVyRGlyZWN0aXZlUHJvbG9ndWUgKz0gMTtcbiAgICAgICBhU291cmNlRWxlbWVudHNEYXRhLnB1c2gobnVsbCk7XG4gICAgIH1cbiAgICAgaWYgKG9Tb3VyY2VFbGVtZW50cy5sZW5ndGggPT09IG5BZnRlckRpcmVjdGl2ZVByb2xvZ3VlKSB7XG4gICAgICAgcmV0dXJuO1xuICAgICB9XG4gICAgIGZvciAoblBvc2l0aW9uID0gbkFmdGVyRGlyZWN0aXZlUHJvbG9ndWU7XG4gICAgICAgICAgblBvc2l0aW9uIDwgb1NvdXJjZUVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICBuUG9zaXRpb24gKz0gMSkge1xuICAgICAgIG9Tb3VyY2VFbGVtZW50RGF0YSA9IG5ldyBUU291cmNlRWxlbWVudHNEYXRhKCk7XG4gICAgICAgb1dhbGtlciA9IG9Qcm9jZXNzb3IuYXN0X3dhbGtlcigpO1xuICAgICAgIC8vIENsYXNzaWZ5IGEgc291cmNlIGVsZW1lbnQuXG4gICAgICAgLy8gRmluZCBpdHMgZGVyaXZlZCBwcmltaXRpdmUgdmFsdWVzIGFuZCBjb3VudCB0aGVpciBvY2N1cnJlbmNlcy5cbiAgICAgICAvLyBGaW5kIGFsbCBpZGVudGlmaWVycyB1c2VkIChpbmNsdWRpbmcgbmVzdGVkIHNjb3BlcykuXG4gICAgICAgb1dhbGtlci53aXRoX3dhbGtlcnMoXG4gICAgICAgICAgIG9XYWxrZXJzLm9TdXJ2ZXlTb3VyY2VFbGVtZW50LFxuICAgICAgICAgICBjQ29udGV4dChvV2Fsa2VyLCBvU291cmNlRWxlbWVudHNbblBvc2l0aW9uXSkpO1xuICAgICAgIC8vIEVzdGFibGlzaCB3aGV0aGVyIHRoZSBzY29wZSBpcyBzdGlsbCB3aG9sbHkgZXhhbWluYWJsZS5cbiAgICAgICBiSXNXaG9sbHlFeGFtaW5hYmxlID0gYklzV2hvbGx5RXhhbWluYWJsZSAmJlxuICAgICAgICAgICBFU291cmNlRWxlbWVudENhdGVnb3JpZXMuTl9XSVRIICE9PSBvU291cmNlRWxlbWVudERhdGEubkNhdGVnb3J5ICYmXG4gICAgICAgICAgIEVTb3VyY2VFbGVtZW50Q2F0ZWdvcmllcy5OX0VWQUwgIT09IG9Tb3VyY2VFbGVtZW50RGF0YS5uQ2F0ZWdvcnk7XG4gICAgICAgYVNvdXJjZUVsZW1lbnRzRGF0YS5wdXNoKG9Tb3VyY2VFbGVtZW50RGF0YSk7XG4gICAgIH1cbiAgICAgaWYgKGJJc1dob2xseUV4YW1pbmFibGUpIHsgIC8vIEV4YW1pbmUgdGhlIHdob2xlIHNjb3BlLlxuICAgICAgIGZFeGFtaW5lU291cmNlRWxlbWVudHMoXG4gICAgICAgICAgIG5BZnRlckRpcmVjdGl2ZVByb2xvZ3VlLFxuICAgICAgICAgICBvU291cmNlRWxlbWVudHMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgZmFsc2UpO1xuICAgICB9IGVsc2UgeyAgLy8gRXhhbWluZSB1bmV4Y2x1ZGVkIHJhbmdlcyBvZiBzb3VyY2UgZWxlbWVudHMuXG4gICAgICAgZm9yIChuUG9zaXRpb24gPSBvU291cmNlRWxlbWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIG5Qb3NpdGlvbiA+PSBuQWZ0ZXJEaXJlY3RpdmVQcm9sb2d1ZTtcbiAgICAgICAgICAgIG5Qb3NpdGlvbiAtPSAxKSB7XG4gICAgICAgICBvU291cmNlRWxlbWVudERhdGEgPSAoLyoqIEB0eXBlIHshVFNvdXJjZUVsZW1lbnRzRGF0YX0gKi9cbiAgICAgICAgICAgICBhU291cmNlRWxlbWVudHNEYXRhW25Qb3NpdGlvbl0pO1xuICAgICAgICAgaWYgKEVTb3VyY2VFbGVtZW50Q2F0ZWdvcmllcy5OX09USEVSID09PVxuICAgICAgICAgICAgIG9Tb3VyY2VFbGVtZW50RGF0YS5uQ2F0ZWdvcnkpIHtcbiAgICAgICAgICAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgblRvKSB7XG4gICAgICAgICAgICAgblRvID0gblBvc2l0aW9uOyAgLy8gSW5kaWNhdGUgdGhlIGVuZCBvZiBhIHJhbmdlLlxuICAgICAgICAgICB9XG4gICAgICAgICAgIC8vIEV4YW1pbmUgdGhlIHJhbmdlIGlmIGl0IGltbWVkaWF0ZWx5IGZvbGxvd3MgYSBEaXJlY3RpdmUgUHJvbG9ndWUuXG4gICAgICAgICAgIGlmIChuUG9zaXRpb24gPT09IG5BZnRlckRpcmVjdGl2ZVByb2xvZ3VlKSB7XG4gICAgICAgICAgICAgZkV4YW1pbmVTb3VyY2VFbGVtZW50cyhuUG9zaXRpb24sIG5UbywgdHJ1ZSk7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG5Ubykge1xuICAgICAgICAgICAgIC8vIEV4YW1pbmUgdGhlIHJhbmdlIHRoYXQgaW1tZWRpYXRlbHkgZm9sbG93cyB0aGlzIHNvdXJjZSBlbGVtZW50LlxuICAgICAgICAgICAgIGZFeGFtaW5lU291cmNlRWxlbWVudHMoblBvc2l0aW9uICsgMSwgblRvLCB0cnVlKTtcbiAgICAgICAgICAgICBuVG8gPSB2b2lkIDA7ICAvLyBPYmxpdGVyYXRlIHRoZSByYW5nZS5cbiAgICAgICAgICAgfVxuICAgICAgICAgICAvLyBFeGFtaW5lIG5lc3RlZCBmdW5jdGlvbnMuXG4gICAgICAgICAgIG9XYWxrZXIgPSBvUHJvY2Vzc29yLmFzdF93YWxrZXIoKTtcbiAgICAgICAgICAgb1dhbGtlci53aXRoX3dhbGtlcnMoXG4gICAgICAgICAgICAgICBvV2Fsa2Vycy5vRXhhbWluZUZ1bmN0aW9ucyxcbiAgICAgICAgICAgICAgIGNDb250ZXh0KG9XYWxrZXIsIG9Tb3VyY2VFbGVtZW50c1tuUG9zaXRpb25dKSk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9XG4gICB9KG9BYnN0cmFjdFN5bnRheFRyZWUgPSBvUHJvY2Vzc29yLmFzdF9hZGRfc2NvcGUob0Fic3RyYWN0U3ludGF4VHJlZSkpKTtcbiAgcmV0dXJuIG9BYnN0cmFjdFN5bnRheFRyZWU7XG59O1xuLypqc2hpbnQgc3ViOmZhbHNlICovXG5cbi8qIExvY2FsIFZhcmlhYmxlczogICAgICAqL1xuLyogbW9kZToganMgICAgICAgICAgICAgICovXG4vKiBjb2Rpbmc6IHV0Zi04ICAgICAgICAgKi9cbi8qIGluZGVudC10YWJzLW1vZGU6IG5pbCAqL1xuLyogdGFiLXdpZHRoOiAyICAgICAgICAgICovXG4vKiBFbmQ6ICAgICAgICAgICAgICAgICAgKi9cbi8qIHZpbTogc2V0IGZ0PWphdmFzY3JpcHQgZmVuYz11dGYtOCBldCB0cz0yIHN0cz0yIHN3PTI6ICovXG4vKiA6bW9kZT1qYXZhc2NyaXB0Om5vVGFicz10cnVlOnRhYlNpemU9MjppbmRlbnRTaXplPTI6ZGVlcEluZGVudD10cnVlOiAqL1xuXG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG5cbiAgVGhpcyB2ZXJzaW9uIGlzIHN1aXRhYmxlIGZvciBOb2RlLmpzLiAgV2l0aCBtaW5pbWFsIGNoYW5nZXMgKHRoZVxuICBleHBvcnRzIHN0dWZmKSBpdCBzaG91bGQgd29yayBvbiBhbnkgSlMgcGxhdGZvcm0uXG5cbiAgVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSB0b2tlbml6ZXIvcGFyc2VyLiAgSXQgaXMgYSBwb3J0IHRvIEphdmFTY3JpcHRcbiAgb2YgcGFyc2UtanMgWzFdLCBhIEphdmFTY3JpcHQgcGFyc2VyIGxpYnJhcnkgd3JpdHRlbiBpbiBDb21tb24gTGlzcFxuICBieSBNYXJpam4gSGF2ZXJiZWtlLiAgVGhhbmsgeW91IE1hcmlqbiFcblxuICBbMV0gaHR0cDovL21hcmlqbi5oYXZlcmJla2UubmwvcGFyc2UtanMvXG5cbiAgRXhwb3J0ZWQgZnVuY3Rpb25zOlxuXG4gICAgLSB0b2tlbml6ZXIoY29kZSkgLS0gcmV0dXJucyBhIGZ1bmN0aW9uLiAgQ2FsbCB0aGUgcmV0dXJuZWRcbiAgICAgIGZ1bmN0aW9uIHRvIGZldGNoIHRoZSBuZXh0IHRva2VuLlxuXG4gICAgLSBwYXJzZShjb2RlKSAtLSByZXR1cm5zIGFuIEFTVCBvZiB0aGUgZ2l2ZW4gSmF2YVNjcmlwdCBjb2RlLlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEwIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgIEJhc2VkIG9uIHBhcnNlLWpzIChodHRwOi8vbWFyaWpuLmhhdmVyYmVrZS5ubC9wYXJzZS1qcy8pLlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIuXG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcbiAgICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gICAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAgICBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAgICBTVUNIIERBTUFHRS5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiAtLS0tLVsgVG9rZW5pemVyIChjb25zdGFudHMpIF0tLS0tLSAqL1xuXG52YXIgS0VZV09SRFMgPSBhcnJheV90b19oYXNoKFtcbiAgICAgICAgXCJicmVha1wiLFxuICAgICAgICBcImNhc2VcIixcbiAgICAgICAgXCJjYXRjaFwiLFxuICAgICAgICBcImNvbnN0XCIsXG4gICAgICAgIFwiY29udGludWVcIixcbiAgICAgICAgXCJkZWJ1Z2dlclwiLFxuICAgICAgICBcImRlZmF1bHRcIixcbiAgICAgICAgXCJkZWxldGVcIixcbiAgICAgICAgXCJkb1wiLFxuICAgICAgICBcImVsc2VcIixcbiAgICAgICAgXCJmaW5hbGx5XCIsXG4gICAgICAgIFwiZm9yXCIsXG4gICAgICAgIFwiZnVuY3Rpb25cIixcbiAgICAgICAgXCJpZlwiLFxuICAgICAgICBcImluXCIsXG4gICAgICAgIFwiaW5zdGFuY2VvZlwiLFxuICAgICAgICBcIm5ld1wiLFxuICAgICAgICBcInJldHVyblwiLFxuICAgICAgICBcInN3aXRjaFwiLFxuICAgICAgICBcInRocm93XCIsXG4gICAgICAgIFwidHJ5XCIsXG4gICAgICAgIFwidHlwZW9mXCIsXG4gICAgICAgIFwidmFyXCIsXG4gICAgICAgIFwidm9pZFwiLFxuICAgICAgICBcIndoaWxlXCIsXG4gICAgICAgIFwid2l0aFwiXG5dKTtcblxudmFyIFJFU0VSVkVEX1dPUkRTID0gYXJyYXlfdG9faGFzaChbXG4gICAgICAgIFwiYWJzdHJhY3RcIixcbiAgICAgICAgXCJib29sZWFuXCIsXG4gICAgICAgIFwiYnl0ZVwiLFxuICAgICAgICBcImNoYXJcIixcbiAgICAgICAgXCJjbGFzc1wiLFxuICAgICAgICBcImRvdWJsZVwiLFxuICAgICAgICBcImVudW1cIixcbiAgICAgICAgXCJleHBvcnRcIixcbiAgICAgICAgXCJleHRlbmRzXCIsXG4gICAgICAgIFwiZmluYWxcIixcbiAgICAgICAgXCJmbG9hdFwiLFxuICAgICAgICBcImdvdG9cIixcbiAgICAgICAgXCJpbXBsZW1lbnRzXCIsXG4gICAgICAgIFwiaW1wb3J0XCIsXG4gICAgICAgIFwiaW50XCIsXG4gICAgICAgIFwiaW50ZXJmYWNlXCIsXG4gICAgICAgIFwibG9uZ1wiLFxuICAgICAgICBcIm5hdGl2ZVwiLFxuICAgICAgICBcInBhY2thZ2VcIixcbiAgICAgICAgXCJwcml2YXRlXCIsXG4gICAgICAgIFwicHJvdGVjdGVkXCIsXG4gICAgICAgIFwicHVibGljXCIsXG4gICAgICAgIFwic2hvcnRcIixcbiAgICAgICAgXCJzdGF0aWNcIixcbiAgICAgICAgXCJzdXBlclwiLFxuICAgICAgICBcInN5bmNocm9uaXplZFwiLFxuICAgICAgICBcInRocm93c1wiLFxuICAgICAgICBcInRyYW5zaWVudFwiLFxuICAgICAgICBcInZvbGF0aWxlXCJcbl0pO1xuXG52YXIgS0VZV09SRFNfQkVGT1JFX0VYUFJFU1NJT04gPSBhcnJheV90b19oYXNoKFtcbiAgICAgICAgXCJyZXR1cm5cIixcbiAgICAgICAgXCJuZXdcIixcbiAgICAgICAgXCJkZWxldGVcIixcbiAgICAgICAgXCJ0aHJvd1wiLFxuICAgICAgICBcImVsc2VcIixcbiAgICAgICAgXCJjYXNlXCJcbl0pO1xuXG52YXIgS0VZV09SRFNfQVRPTSA9IGFycmF5X3RvX2hhc2goW1xuICAgICAgICBcImZhbHNlXCIsXG4gICAgICAgIFwibnVsbFwiLFxuICAgICAgICBcInRydWVcIixcbiAgICAgICAgXCJ1bmRlZmluZWRcIlxuXSk7XG5cbnZhciBPUEVSQVRPUl9DSEFSUyA9IGFycmF5X3RvX2hhc2goY2hhcmFjdGVycyhcIistKiYlPTw+IT98fl5cIikpO1xuXG52YXIgUkVfSEVYX05VTUJFUiA9IC9eMHhbMC05YS1mXSskL2k7XG52YXIgUkVfT0NUX05VTUJFUiA9IC9eMFswLTddKyQvO1xudmFyIFJFX0RFQ19OVU1CRVIgPSAvXlxcZCpcXC4/XFxkKig/OmVbKy1dP1xcZCooPzpcXGRcXC4/fFxcLj9cXGQpXFxkKik/JC9pO1xuXG52YXIgT1BFUkFUT1JTID0gYXJyYXlfdG9faGFzaChbXG4gICAgICAgIFwiaW5cIixcbiAgICAgICAgXCJpbnN0YW5jZW9mXCIsXG4gICAgICAgIFwidHlwZW9mXCIsXG4gICAgICAgIFwibmV3XCIsXG4gICAgICAgIFwidm9pZFwiLFxuICAgICAgICBcImRlbGV0ZVwiLFxuICAgICAgICBcIisrXCIsXG4gICAgICAgIFwiLS1cIixcbiAgICAgICAgXCIrXCIsXG4gICAgICAgIFwiLVwiLFxuICAgICAgICBcIiFcIixcbiAgICAgICAgXCJ+XCIsXG4gICAgICAgIFwiJlwiLFxuICAgICAgICBcInxcIixcbiAgICAgICAgXCJeXCIsXG4gICAgICAgIFwiKlwiLFxuICAgICAgICBcIi9cIixcbiAgICAgICAgXCIlXCIsXG4gICAgICAgIFwiPj5cIixcbiAgICAgICAgXCI8PFwiLFxuICAgICAgICBcIj4+PlwiLFxuICAgICAgICBcIjxcIixcbiAgICAgICAgXCI+XCIsXG4gICAgICAgIFwiPD1cIixcbiAgICAgICAgXCI+PVwiLFxuICAgICAgICBcIj09XCIsXG4gICAgICAgIFwiPT09XCIsXG4gICAgICAgIFwiIT1cIixcbiAgICAgICAgXCIhPT1cIixcbiAgICAgICAgXCI/XCIsXG4gICAgICAgIFwiPVwiLFxuICAgICAgICBcIis9XCIsXG4gICAgICAgIFwiLT1cIixcbiAgICAgICAgXCIvPVwiLFxuICAgICAgICBcIio9XCIsXG4gICAgICAgIFwiJT1cIixcbiAgICAgICAgXCI+Pj1cIixcbiAgICAgICAgXCI8PD1cIixcbiAgICAgICAgXCI+Pj49XCIsXG4gICAgICAgIFwifD1cIixcbiAgICAgICAgXCJePVwiLFxuICAgICAgICBcIiY9XCIsXG4gICAgICAgIFwiJiZcIixcbiAgICAgICAgXCJ8fFwiXG5dKTtcblxudmFyIFdISVRFU1BBQ0VfQ0hBUlMgPSBhcnJheV90b19oYXNoKGNoYXJhY3RlcnMoXCIgXFx1MDBhMFxcblxcclxcdFxcZlxcdTAwMGJcXHUyMDBiXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXCIpKTtcblxudmFyIFBVTkNfQkVGT1JFX0VYUFJFU1NJT04gPSBhcnJheV90b19oYXNoKGNoYXJhY3RlcnMoXCJbeygsLjs6XCIpKTtcblxudmFyIFBVTkNfQ0hBUlMgPSBhcnJheV90b19oYXNoKGNoYXJhY3RlcnMoXCJbXXt9KCksOzpcIikpO1xuXG52YXIgUkVHRVhQX01PRElGSUVSUyA9IGFycmF5X3RvX2hhc2goY2hhcmFjdGVycyhcImdtc2l5XCIpKTtcblxuLyogLS0tLS1bIFRva2VuaXplciBdLS0tLS0gKi9cblxudmFyIFVOSUNPREUgPSB7ICAvLyBVbmljb2RlIDYuMVxuICAgICAgICBsZXR0ZXI6IG5ldyBSZWdFeHAoXCJbXFxcXHUwMDQxLVxcXFx1MDA1QVxcXFx1MDA2MS1cXFxcdTAwN0FcXFxcdTAwQUFcXFxcdTAwQjVcXFxcdTAwQkFcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyQzFcXFxcdTAyQzYtXFxcXHUwMkQxXFxcXHUwMkUwLVxcXFx1MDJFNFxcXFx1MDJFQ1xcXFx1MDJFRVxcXFx1MDM3MC1cXFxcdTAzNzRcXFxcdTAzNzZcXFxcdTAzNzdcXFxcdTAzN0EtXFxcXHUwMzdEXFxcXHUwMzg2XFxcXHUwMzg4LVxcXFx1MDM4QVxcXFx1MDM4Q1xcXFx1MDM4RS1cXFxcdTAzQTFcXFxcdTAzQTMtXFxcXHUwM0Y1XFxcXHUwM0Y3LVxcXFx1MDQ4MVxcXFx1MDQ4QS1cXFxcdTA1MjdcXFxcdTA1MzEtXFxcXHUwNTU2XFxcXHUwNTU5XFxcXHUwNTYxLVxcXFx1MDU4N1xcXFx1MDVEMC1cXFxcdTA1RUFcXFxcdTA1RjAtXFxcXHUwNUYyXFxcXHUwNjIwLVxcXFx1MDY0QVxcXFx1MDY2RVxcXFx1MDY2RlxcXFx1MDY3MS1cXFxcdTA2RDNcXFxcdTA2RDVcXFxcdTA2RTVcXFxcdTA2RTZcXFxcdTA2RUVcXFxcdTA2RUZcXFxcdTA2RkEtXFxcXHUwNkZDXFxcXHUwNkZGXFxcXHUwNzEwXFxcXHUwNzEyLVxcXFx1MDcyRlxcXFx1MDc0RC1cXFxcdTA3QTVcXFxcdTA3QjFcXFxcdTA3Q0EtXFxcXHUwN0VBXFxcXHUwN0Y0XFxcXHUwN0Y1XFxcXHUwN0ZBXFxcXHUwODAwLVxcXFx1MDgxNVxcXFx1MDgxQVxcXFx1MDgyNFxcXFx1MDgyOFxcXFx1MDg0MC1cXFxcdTA4NThcXFxcdTA4QTBcXFxcdTA4QTItXFxcXHUwOEFDXFxcXHUwOTA0LVxcXFx1MDkzOVxcXFx1MDkzRFxcXFx1MDk1MFxcXFx1MDk1OC1cXFxcdTA5NjFcXFxcdTA5NzEtXFxcXHUwOTc3XFxcXHUwOTc5LVxcXFx1MDk3RlxcXFx1MDk4NS1cXFxcdTA5OENcXFxcdTA5OEZcXFxcdTA5OTBcXFxcdTA5OTMtXFxcXHUwOUE4XFxcXHUwOUFBLVxcXFx1MDlCMFxcXFx1MDlCMlxcXFx1MDlCNi1cXFxcdTA5QjlcXFxcdTA5QkRcXFxcdTA5Q0VcXFxcdTA5RENcXFxcdTA5RERcXFxcdTA5REYtXFxcXHUwOUUxXFxcXHUwOUYwXFxcXHUwOUYxXFxcXHUwQTA1LVxcXFx1MEEwQVxcXFx1MEEwRlxcXFx1MEExMFxcXFx1MEExMy1cXFxcdTBBMjhcXFxcdTBBMkEtXFxcXHUwQTMwXFxcXHUwQTMyXFxcXHUwQTMzXFxcXHUwQTM1XFxcXHUwQTM2XFxcXHUwQTM4XFxcXHUwQTM5XFxcXHUwQTU5LVxcXFx1MEE1Q1xcXFx1MEE1RVxcXFx1MEE3Mi1cXFxcdTBBNzRcXFxcdTBBODUtXFxcXHUwQThEXFxcXHUwQThGLVxcXFx1MEE5MVxcXFx1MEE5My1cXFxcdTBBQThcXFxcdTBBQUEtXFxcXHUwQUIwXFxcXHUwQUIyXFxcXHUwQUIzXFxcXHUwQUI1LVxcXFx1MEFCOVxcXFx1MEFCRFxcXFx1MEFEMFxcXFx1MEFFMFxcXFx1MEFFMVxcXFx1MEIwNS1cXFxcdTBCMENcXFxcdTBCMEZcXFxcdTBCMTBcXFxcdTBCMTMtXFxcXHUwQjI4XFxcXHUwQjJBLVxcXFx1MEIzMFxcXFx1MEIzMlxcXFx1MEIzM1xcXFx1MEIzNS1cXFxcdTBCMzlcXFxcdTBCM0RcXFxcdTBCNUNcXFxcdTBCNURcXFxcdTBCNUYtXFxcXHUwQjYxXFxcXHUwQjcxXFxcXHUwQjgzXFxcXHUwQjg1LVxcXFx1MEI4QVxcXFx1MEI4RS1cXFxcdTBCOTBcXFxcdTBCOTItXFxcXHUwQjk1XFxcXHUwQjk5XFxcXHUwQjlBXFxcXHUwQjlDXFxcXHUwQjlFXFxcXHUwQjlGXFxcXHUwQkEzXFxcXHUwQkE0XFxcXHUwQkE4LVxcXFx1MEJBQVxcXFx1MEJBRS1cXFxcdTBCQjlcXFxcdTBCRDBcXFxcdTBDMDUtXFxcXHUwQzBDXFxcXHUwQzBFLVxcXFx1MEMxMFxcXFx1MEMxMi1cXFxcdTBDMjhcXFxcdTBDMkEtXFxcXHUwQzMzXFxcXHUwQzM1LVxcXFx1MEMzOVxcXFx1MEMzRFxcXFx1MEM1OFxcXFx1MEM1OVxcXFx1MEM2MFxcXFx1MEM2MVxcXFx1MEM4NS1cXFxcdTBDOENcXFxcdTBDOEUtXFxcXHUwQzkwXFxcXHUwQzkyLVxcXFx1MENBOFxcXFx1MENBQS1cXFxcdTBDQjNcXFxcdTBDQjUtXFxcXHUwQ0I5XFxcXHUwQ0JEXFxcXHUwQ0RFXFxcXHUwQ0UwXFxcXHUwQ0UxXFxcXHUwQ0YxXFxcXHUwQ0YyXFxcXHUwRDA1LVxcXFx1MEQwQ1xcXFx1MEQwRS1cXFxcdTBEMTBcXFxcdTBEMTItXFxcXHUwRDNBXFxcXHUwRDNEXFxcXHUwRDRFXFxcXHUwRDYwXFxcXHUwRDYxXFxcXHUwRDdBLVxcXFx1MEQ3RlxcXFx1MEQ4NS1cXFxcdTBEOTZcXFxcdTBEOUEtXFxcXHUwREIxXFxcXHUwREIzLVxcXFx1MERCQlxcXFx1MERCRFxcXFx1MERDMC1cXFxcdTBEQzZcXFxcdTBFMDEtXFxcXHUwRTMwXFxcXHUwRTMyXFxcXHUwRTMzXFxcXHUwRTQwLVxcXFx1MEU0NlxcXFx1MEU4MVxcXFx1MEU4MlxcXFx1MEU4NFxcXFx1MEU4N1xcXFx1MEU4OFxcXFx1MEU4QVxcXFx1MEU4RFxcXFx1MEU5NC1cXFxcdTBFOTdcXFxcdTBFOTktXFxcXHUwRTlGXFxcXHUwRUExLVxcXFx1MEVBM1xcXFx1MEVBNVxcXFx1MEVBN1xcXFx1MEVBQVxcXFx1MEVBQlxcXFx1MEVBRC1cXFxcdTBFQjBcXFxcdTBFQjJcXFxcdTBFQjNcXFxcdTBFQkRcXFxcdTBFQzAtXFxcXHUwRUM0XFxcXHUwRUM2XFxcXHUwRURDLVxcXFx1MEVERlxcXFx1MEYwMFxcXFx1MEY0MC1cXFxcdTBGNDdcXFxcdTBGNDktXFxcXHUwRjZDXFxcXHUwRjg4LVxcXFx1MEY4Q1xcXFx1MTAwMC1cXFxcdTEwMkFcXFxcdTEwM0ZcXFxcdTEwNTAtXFxcXHUxMDU1XFxcXHUxMDVBLVxcXFx1MTA1RFxcXFx1MTA2MVxcXFx1MTA2NVxcXFx1MTA2NlxcXFx1MTA2RS1cXFxcdTEwNzBcXFxcdTEwNzUtXFxcXHUxMDgxXFxcXHUxMDhFXFxcXHUxMEEwLVxcXFx1MTBDNVxcXFx1MTBDN1xcXFx1MTBDRFxcXFx1MTBEMC1cXFxcdTEwRkFcXFxcdTEwRkMtXFxcXHUxMjQ4XFxcXHUxMjRBLVxcXFx1MTI0RFxcXFx1MTI1MC1cXFxcdTEyNTZcXFxcdTEyNThcXFxcdTEyNUEtXFxcXHUxMjVEXFxcXHUxMjYwLVxcXFx1MTI4OFxcXFx1MTI4QS1cXFxcdTEyOERcXFxcdTEyOTAtXFxcXHUxMkIwXFxcXHUxMkIyLVxcXFx1MTJCNVxcXFx1MTJCOC1cXFxcdTEyQkVcXFxcdTEyQzBcXFxcdTEyQzItXFxcXHUxMkM1XFxcXHUxMkM4LVxcXFx1MTJENlxcXFx1MTJEOC1cXFxcdTEzMTBcXFxcdTEzMTItXFxcXHUxMzE1XFxcXHUxMzE4LVxcXFx1MTM1QVxcXFx1MTM4MC1cXFxcdTEzOEZcXFxcdTEzQTAtXFxcXHUxM0Y0XFxcXHUxNDAxLVxcXFx1MTY2Q1xcXFx1MTY2Ri1cXFxcdTE2N0ZcXFxcdTE2ODEtXFxcXHUxNjlBXFxcXHUxNkEwLVxcXFx1MTZFQVxcXFx1MTZFRS1cXFxcdTE2RjBcXFxcdTE3MDAtXFxcXHUxNzBDXFxcXHUxNzBFLVxcXFx1MTcxMVxcXFx1MTcyMC1cXFxcdTE3MzFcXFxcdTE3NDAtXFxcXHUxNzUxXFxcXHUxNzYwLVxcXFx1MTc2Q1xcXFx1MTc2RS1cXFxcdTE3NzBcXFxcdTE3ODAtXFxcXHUxN0IzXFxcXHUxN0Q3XFxcXHUxN0RDXFxcXHUxODIwLVxcXFx1MTg3N1xcXFx1MTg4MC1cXFxcdTE4QThcXFxcdTE4QUFcXFxcdTE4QjAtXFxcXHUxOEY1XFxcXHUxOTAwLVxcXFx1MTkxQ1xcXFx1MTk1MC1cXFxcdTE5NkRcXFxcdTE5NzAtXFxcXHUxOTc0XFxcXHUxOTgwLVxcXFx1MTlBQlxcXFx1MTlDMS1cXFxcdTE5QzdcXFxcdTFBMDAtXFxcXHUxQTE2XFxcXHUxQTIwLVxcXFx1MUE1NFxcXFx1MUFBN1xcXFx1MUIwNS1cXFxcdTFCMzNcXFxcdTFCNDUtXFxcXHUxQjRCXFxcXHUxQjgzLVxcXFx1MUJBMFxcXFx1MUJBRVxcXFx1MUJBRlxcXFx1MUJCQS1cXFxcdTFCRTVcXFxcdTFDMDAtXFxcXHUxQzIzXFxcXHUxQzRELVxcXFx1MUM0RlxcXFx1MUM1QS1cXFxcdTFDN0RcXFxcdTFDRTktXFxcXHUxQ0VDXFxcXHUxQ0VFLVxcXFx1MUNGMVxcXFx1MUNGNVxcXFx1MUNGNlxcXFx1MUQwMC1cXFxcdTFEQkZcXFxcdTFFMDAtXFxcXHUxRjE1XFxcXHUxRjE4LVxcXFx1MUYxRFxcXFx1MUYyMC1cXFxcdTFGNDVcXFxcdTFGNDgtXFxcXHUxRjREXFxcXHUxRjUwLVxcXFx1MUY1N1xcXFx1MUY1OVxcXFx1MUY1QlxcXFx1MUY1RFxcXFx1MUY1Ri1cXFxcdTFGN0RcXFxcdTFGODAtXFxcXHUxRkI0XFxcXHUxRkI2LVxcXFx1MUZCQ1xcXFx1MUZCRVxcXFx1MUZDMi1cXFxcdTFGQzRcXFxcdTFGQzYtXFxcXHUxRkNDXFxcXHUxRkQwLVxcXFx1MUZEM1xcXFx1MUZENi1cXFxcdTFGREJcXFxcdTFGRTAtXFxcXHUxRkVDXFxcXHUxRkYyLVxcXFx1MUZGNFxcXFx1MUZGNi1cXFxcdTFGRkNcXFxcdTIwNzFcXFxcdTIwN0ZcXFxcdTIwOTAtXFxcXHUyMDlDXFxcXHUyMTAyXFxcXHUyMTA3XFxcXHUyMTBBLVxcXFx1MjExM1xcXFx1MjExNVxcXFx1MjExOS1cXFxcdTIxMURcXFxcdTIxMjRcXFxcdTIxMjZcXFxcdTIxMjhcXFxcdTIxMkEtXFxcXHUyMTJEXFxcXHUyMTJGLVxcXFx1MjEzOVxcXFx1MjEzQy1cXFxcdTIxM0ZcXFxcdTIxNDUtXFxcXHUyMTQ5XFxcXHUyMTRFXFxcXHUyMTYwLVxcXFx1MjE4OFxcXFx1MkMwMC1cXFxcdTJDMkVcXFxcdTJDMzAtXFxcXHUyQzVFXFxcXHUyQzYwLVxcXFx1MkNFNFxcXFx1MkNFQi1cXFxcdTJDRUVcXFxcdTJDRjJcXFxcdTJDRjNcXFxcdTJEMDAtXFxcXHUyRDI1XFxcXHUyRDI3XFxcXHUyRDJEXFxcXHUyRDMwLVxcXFx1MkQ2N1xcXFx1MkQ2RlxcXFx1MkQ4MC1cXFxcdTJEOTZcXFxcdTJEQTAtXFxcXHUyREE2XFxcXHUyREE4LVxcXFx1MkRBRVxcXFx1MkRCMC1cXFxcdTJEQjZcXFxcdTJEQjgtXFxcXHUyREJFXFxcXHUyREMwLVxcXFx1MkRDNlxcXFx1MkRDOC1cXFxcdTJEQ0VcXFxcdTJERDAtXFxcXHUyREQ2XFxcXHUyREQ4LVxcXFx1MkRERVxcXFx1MkUyRlxcXFx1MzAwNS1cXFxcdTMwMDdcXFxcdTMwMjEtXFxcXHUzMDI5XFxcXHUzMDMxLVxcXFx1MzAzNVxcXFx1MzAzOC1cXFxcdTMwM0NcXFxcdTMwNDEtXFxcXHUzMDk2XFxcXHUzMDlELVxcXFx1MzA5RlxcXFx1MzBBMS1cXFxcdTMwRkFcXFxcdTMwRkMtXFxcXHUzMEZGXFxcXHUzMTA1LVxcXFx1MzEyRFxcXFx1MzEzMS1cXFxcdTMxOEVcXFxcdTMxQTAtXFxcXHUzMUJBXFxcXHUzMUYwLVxcXFx1MzFGRlxcXFx1MzQwMC1cXFxcdTREQjVcXFxcdTRFMDAtXFxcXHU5RkNDXFxcXHVBMDAwLVxcXFx1QTQ4Q1xcXFx1QTREMC1cXFxcdUE0RkRcXFxcdUE1MDAtXFxcXHVBNjBDXFxcXHVBNjEwLVxcXFx1QTYxRlxcXFx1QTYyQVxcXFx1QTYyQlxcXFx1QTY0MC1cXFxcdUE2NkVcXFxcdUE2N0YtXFxcXHVBNjk3XFxcXHVBNkEwLVxcXFx1QTZFRlxcXFx1QTcxNy1cXFxcdUE3MUZcXFxcdUE3MjItXFxcXHVBNzg4XFxcXHVBNzhCLVxcXFx1QTc4RVxcXFx1QTc5MC1cXFxcdUE3OTNcXFxcdUE3QTAtXFxcXHVBN0FBXFxcXHVBN0Y4LVxcXFx1QTgwMVxcXFx1QTgwMy1cXFxcdUE4MDVcXFxcdUE4MDctXFxcXHVBODBBXFxcXHVBODBDLVxcXFx1QTgyMlxcXFx1QTg0MC1cXFxcdUE4NzNcXFxcdUE4ODItXFxcXHVBOEIzXFxcXHVBOEYyLVxcXFx1QThGN1xcXFx1QThGQlxcXFx1QTkwQS1cXFxcdUE5MjVcXFxcdUE5MzAtXFxcXHVBOTQ2XFxcXHVBOTYwLVxcXFx1QTk3Q1xcXFx1QTk4NC1cXFxcdUE5QjJcXFxcdUE5Q0ZcXFxcdUFBMDAtXFxcXHVBQTI4XFxcXHVBQTQwLVxcXFx1QUE0MlxcXFx1QUE0NC1cXFxcdUFBNEJcXFxcdUFBNjAtXFxcXHVBQTc2XFxcXHVBQTdBXFxcXHVBQTgwLVxcXFx1QUFBRlxcXFx1QUFCMVxcXFx1QUFCNVxcXFx1QUFCNlxcXFx1QUFCOS1cXFxcdUFBQkRcXFxcdUFBQzBcXFxcdUFBQzJcXFxcdUFBREItXFxcXHVBQUREXFxcXHVBQUUwLVxcXFx1QUFFQVxcXFx1QUFGMi1cXFxcdUFBRjRcXFxcdUFCMDEtXFxcXHVBQjA2XFxcXHVBQjA5LVxcXFx1QUIwRVxcXFx1QUIxMS1cXFxcdUFCMTZcXFxcdUFCMjAtXFxcXHVBQjI2XFxcXHVBQjI4LVxcXFx1QUIyRVxcXFx1QUJDMC1cXFxcdUFCRTJcXFxcdUFDMDAtXFxcXHVEN0EzXFxcXHVEN0IwLVxcXFx1RDdDNlxcXFx1RDdDQi1cXFxcdUQ3RkJcXFxcdUY5MDAtXFxcXHVGQTZEXFxcXHVGQTcwLVxcXFx1RkFEOVxcXFx1RkIwMC1cXFxcdUZCMDZcXFxcdUZCMTMtXFxcXHVGQjE3XFxcXHVGQjFEXFxcXHVGQjFGLVxcXFx1RkIyOFxcXFx1RkIyQS1cXFxcdUZCMzZcXFxcdUZCMzgtXFxcXHVGQjNDXFxcXHVGQjNFXFxcXHVGQjQwXFxcXHVGQjQxXFxcXHVGQjQzXFxcXHVGQjQ0XFxcXHVGQjQ2LVxcXFx1RkJCMVxcXFx1RkJEMy1cXFxcdUZEM0RcXFxcdUZENTAtXFxcXHVGRDhGXFxcXHVGRDkyLVxcXFx1RkRDN1xcXFx1RkRGMC1cXFxcdUZERkJcXFxcdUZFNzAtXFxcXHVGRTc0XFxcXHVGRTc2LVxcXFx1RkVGQ1xcXFx1RkYyMS1cXFxcdUZGM0FcXFxcdUZGNDEtXFxcXHVGRjVBXFxcXHVGRjY2LVxcXFx1RkZCRVxcXFx1RkZDMi1cXFxcdUZGQzdcXFxcdUZGQ0EtXFxcXHVGRkNGXFxcXHVGRkQyLVxcXFx1RkZEN1xcXFx1RkZEQS1cXFxcdUZGRENdXCIpLFxuICAgICAgICBjb21iaW5pbmdfbWFyazogbmV3IFJlZ0V4cChcIltcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUwNDgzLVxcXFx1MDQ4N1xcXFx1MDU5MS1cXFxcdTA1QkRcXFxcdTA1QkZcXFxcdTA1QzFcXFxcdTA1QzJcXFxcdTA1QzRcXFxcdTA1QzVcXFxcdTA1QzdcXFxcdTA2MTAtXFxcXHUwNjFBXFxcXHUwNjRCLVxcXFx1MDY1RlxcXFx1MDY3MFxcXFx1MDZENi1cXFxcdTA2RENcXFxcdTA2REYtXFxcXHUwNkU0XFxcXHUwNkU3XFxcXHUwNkU4XFxcXHUwNkVBLVxcXFx1MDZFRFxcXFx1MDcxMVxcXFx1MDczMC1cXFxcdTA3NEFcXFxcdTA3QTYtXFxcXHUwN0IwXFxcXHUwN0VCLVxcXFx1MDdGM1xcXFx1MDgxNi1cXFxcdTA4MTlcXFxcdTA4MUItXFxcXHUwODIzXFxcXHUwODI1LVxcXFx1MDgyN1xcXFx1MDgyOS1cXFxcdTA4MkRcXFxcdTA4NTktXFxcXHUwODVCXFxcXHUwOEU0LVxcXFx1MDhGRVxcXFx1MDkwMC1cXFxcdTA5MDNcXFxcdTA5M0EtXFxcXHUwOTNDXFxcXHUwOTNFLVxcXFx1MDk0RlxcXFx1MDk1MS1cXFxcdTA5NTdcXFxcdTA5NjJcXFxcdTA5NjNcXFxcdTA5ODEtXFxcXHUwOTgzXFxcXHUwOUJDXFxcXHUwOUJFLVxcXFx1MDlDNFxcXFx1MDlDN1xcXFx1MDlDOFxcXFx1MDlDQi1cXFxcdTA5Q0RcXFxcdTA5RDdcXFxcdTA5RTJcXFxcdTA5RTNcXFxcdTBBMDEtXFxcXHUwQTAzXFxcXHUwQTNDXFxcXHUwQTNFLVxcXFx1MEE0MlxcXFx1MEE0N1xcXFx1MEE0OFxcXFx1MEE0Qi1cXFxcdTBBNERcXFxcdTBBNTFcXFxcdTBBNzBcXFxcdTBBNzFcXFxcdTBBNzVcXFxcdTBBODEtXFxcXHUwQTgzXFxcXHUwQUJDXFxcXHUwQUJFLVxcXFx1MEFDNVxcXFx1MEFDNy1cXFxcdTBBQzlcXFxcdTBBQ0ItXFxcXHUwQUNEXFxcXHUwQUUyXFxcXHUwQUUzXFxcXHUwQjAxLVxcXFx1MEIwM1xcXFx1MEIzQ1xcXFx1MEIzRS1cXFxcdTBCNDRcXFxcdTBCNDdcXFxcdTBCNDhcXFxcdTBCNEItXFxcXHUwQjREXFxcXHUwQjU2XFxcXHUwQjU3XFxcXHUwQjYyXFxcXHUwQjYzXFxcXHUwQjgyXFxcXHUwQkJFLVxcXFx1MEJDMlxcXFx1MEJDNi1cXFxcdTBCQzhcXFxcdTBCQ0EtXFxcXHUwQkNEXFxcXHUwQkQ3XFxcXHUwQzAxLVxcXFx1MEMwM1xcXFx1MEMzRS1cXFxcdTBDNDRcXFxcdTBDNDYtXFxcXHUwQzQ4XFxcXHUwQzRBLVxcXFx1MEM0RFxcXFx1MEM1NVxcXFx1MEM1NlxcXFx1MEM2MlxcXFx1MEM2M1xcXFx1MEM4MlxcXFx1MEM4M1xcXFx1MENCQ1xcXFx1MENCRS1cXFxcdTBDQzRcXFxcdTBDQzYtXFxcXHUwQ0M4XFxcXHUwQ0NBLVxcXFx1MENDRFxcXFx1MENENVxcXFx1MENENlxcXFx1MENFMlxcXFx1MENFM1xcXFx1MEQwMlxcXFx1MEQwM1xcXFx1MEQzRS1cXFxcdTBENDRcXFxcdTBENDYtXFxcXHUwRDQ4XFxcXHUwRDRBLVxcXFx1MEQ0RFxcXFx1MEQ1N1xcXFx1MEQ2MlxcXFx1MEQ2M1xcXFx1MEQ4MlxcXFx1MEQ4M1xcXFx1MERDQVxcXFx1MERDRi1cXFxcdTBERDRcXFxcdTBERDZcXFxcdTBERDgtXFxcXHUwRERGXFxcXHUwREYyXFxcXHUwREYzXFxcXHUwRTMxXFxcXHUwRTM0LVxcXFx1MEUzQVxcXFx1MEU0Ny1cXFxcdTBFNEVcXFxcdTBFQjFcXFxcdTBFQjQtXFxcXHUwRUI5XFxcXHUwRUJCXFxcXHUwRUJDXFxcXHUwRUM4LVxcXFx1MEVDRFxcXFx1MEYxOFxcXFx1MEYxOVxcXFx1MEYzNVxcXFx1MEYzN1xcXFx1MEYzOVxcXFx1MEYzRVxcXFx1MEYzRlxcXFx1MEY3MS1cXFxcdTBGODRcXFxcdTBGODZcXFxcdTBGODdcXFxcdTBGOEQtXFxcXHUwRjk3XFxcXHUwRjk5LVxcXFx1MEZCQ1xcXFx1MEZDNlxcXFx1MTAyQi1cXFxcdTEwM0VcXFxcdTEwNTYtXFxcXHUxMDU5XFxcXHUxMDVFLVxcXFx1MTA2MFxcXFx1MTA2Mi1cXFxcdTEwNjRcXFxcdTEwNjctXFxcXHUxMDZEXFxcXHUxMDcxLVxcXFx1MTA3NFxcXFx1MTA4Mi1cXFxcdTEwOERcXFxcdTEwOEZcXFxcdTEwOUEtXFxcXHUxMDlEXFxcXHUxMzVELVxcXFx1MTM1RlxcXFx1MTcxMi1cXFxcdTE3MTRcXFxcdTE3MzItXFxcXHUxNzM0XFxcXHUxNzUyXFxcXHUxNzUzXFxcXHUxNzcyXFxcXHUxNzczXFxcXHUxN0I0LVxcXFx1MTdEM1xcXFx1MTdERFxcXFx1MTgwQi1cXFxcdTE4MERcXFxcdTE4QTlcXFxcdTE5MjAtXFxcXHUxOTJCXFxcXHUxOTMwLVxcXFx1MTkzQlxcXFx1MTlCMC1cXFxcdTE5QzBcXFxcdTE5QzhcXFxcdTE5QzlcXFxcdTFBMTctXFxcXHUxQTFCXFxcXHUxQTU1LVxcXFx1MUE1RVxcXFx1MUE2MC1cXFxcdTFBN0NcXFxcdTFBN0ZcXFxcdTFCMDAtXFxcXHUxQjA0XFxcXHUxQjM0LVxcXFx1MUI0NFxcXFx1MUI2Qi1cXFxcdTFCNzNcXFxcdTFCODAtXFxcXHUxQjgyXFxcXHUxQkExLVxcXFx1MUJBRFxcXFx1MUJFNi1cXFxcdTFCRjNcXFxcdTFDMjQtXFxcXHUxQzM3XFxcXHUxQ0QwLVxcXFx1MUNEMlxcXFx1MUNENC1cXFxcdTFDRThcXFxcdTFDRURcXFxcdTFDRjItXFxcXHUxQ0Y0XFxcXHUxREMwLVxcXFx1MURFNlxcXFx1MURGQy1cXFxcdTFERkZcXFxcdTIwRDAtXFxcXHUyMERDXFxcXHUyMEUxXFxcXHUyMEU1LVxcXFx1MjBGMFxcXFx1MkNFRi1cXFxcdTJDRjFcXFxcdTJEN0ZcXFxcdTJERTAtXFxcXHUyREZGXFxcXHUzMDJBLVxcXFx1MzAyRlxcXFx1MzA5OVxcXFx1MzA5QVxcXFx1QTY2RlxcXFx1QTY3NC1cXFxcdUE2N0RcXFxcdUE2OUZcXFxcdUE2RjBcXFxcdUE2RjFcXFxcdUE4MDJcXFxcdUE4MDZcXFxcdUE4MEJcXFxcdUE4MjMtXFxcXHVBODI3XFxcXHVBODgwXFxcXHVBODgxXFxcXHVBOEI0LVxcXFx1QThDNFxcXFx1QThFMC1cXFxcdUE4RjFcXFxcdUE5MjYtXFxcXHVBOTJEXFxcXHVBOTQ3LVxcXFx1QTk1M1xcXFx1QTk4MC1cXFxcdUE5ODNcXFxcdUE5QjMtXFxcXHVBOUMwXFxcXHVBQTI5LVxcXFx1QUEzNlxcXFx1QUE0M1xcXFx1QUE0Q1xcXFx1QUE0RFxcXFx1QUE3QlxcXFx1QUFCMFxcXFx1QUFCMi1cXFxcdUFBQjRcXFxcdUFBQjdcXFxcdUFBQjhcXFxcdUFBQkVcXFxcdUFBQkZcXFxcdUFBQzFcXFxcdUFBRUItXFxcXHVBQUVGXFxcXHVBQUY1XFxcXHVBQUY2XFxcXHVBQkUzLVxcXFx1QUJFQVxcXFx1QUJFQ1xcXFx1QUJFRFxcXFx1RkIxRVxcXFx1RkUwMC1cXFxcdUZFMEZcXFxcdUZFMjAtXFxcXHVGRTI2XVwiKSxcbiAgICAgICAgY29ubmVjdG9yX3B1bmN0dWF0aW9uOiBuZXcgUmVnRXhwKFwiW1xcXFx1MDA1RlxcXFx1MjAzRlxcXFx1MjA0MFxcXFx1MjA1NFxcXFx1RkUzM1xcXFx1RkUzNFxcXFx1RkU0RC1cXFxcdUZFNEZcXFxcdUZGM0ZdXCIpLFxuICAgICAgICBkaWdpdDogbmV3IFJlZ0V4cChcIltcXFxcdTAwMzAtXFxcXHUwMDM5XFxcXHUwNjYwLVxcXFx1MDY2OVxcXFx1MDZGMC1cXFxcdTA2RjlcXFxcdTA3QzAtXFxcXHUwN0M5XFxcXHUwOTY2LVxcXFx1MDk2RlxcXFx1MDlFNi1cXFxcdTA5RUZcXFxcdTBBNjYtXFxcXHUwQTZGXFxcXHUwQUU2LVxcXFx1MEFFRlxcXFx1MEI2Ni1cXFxcdTBCNkZcXFxcdTBCRTYtXFxcXHUwQkVGXFxcXHUwQzY2LVxcXFx1MEM2RlxcXFx1MENFNi1cXFxcdTBDRUZcXFxcdTBENjYtXFxcXHUwRDZGXFxcXHUwRTUwLVxcXFx1MEU1OVxcXFx1MEVEMC1cXFxcdTBFRDlcXFxcdTBGMjAtXFxcXHUwRjI5XFxcXHUxMDQwLVxcXFx1MTA0OVxcXFx1MTA5MC1cXFxcdTEwOTlcXFxcdTE3RTAtXFxcXHUxN0U5XFxcXHUxODEwLVxcXFx1MTgxOVxcXFx1MTk0Ni1cXFxcdTE5NEZcXFxcdTE5RDAtXFxcXHUxOUQ5XFxcXHUxQTgwLVxcXFx1MUE4OVxcXFx1MUE5MC1cXFxcdTFBOTlcXFxcdTFCNTAtXFxcXHUxQjU5XFxcXHUxQkIwLVxcXFx1MUJCOVxcXFx1MUM0MC1cXFxcdTFDNDlcXFxcdTFDNTAtXFxcXHUxQzU5XFxcXHVBNjIwLVxcXFx1QTYyOVxcXFx1QThEMC1cXFxcdUE4RDlcXFxcdUE5MDAtXFxcXHVBOTA5XFxcXHVBOUQwLVxcXFx1QTlEOVxcXFx1QUE1MC1cXFxcdUFBNTlcXFxcdUFCRjAtXFxcXHVBQkY5XFxcXHVGRjEwLVxcXFx1RkYxOV1cIilcbn07XG5cbmZ1bmN0aW9uIGlzX2xldHRlcihjaCkge1xuICAgICAgICByZXR1cm4gVU5JQ09ERS5sZXR0ZXIudGVzdChjaCk7XG59O1xuXG5mdW5jdGlvbiBpc19kaWdpdChjaCkge1xuICAgICAgICBjaCA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHJldHVybiBjaCA+PSA0OCAmJiBjaCA8PSA1Nztcbn07XG5cbmZ1bmN0aW9uIGlzX3VuaWNvZGVfZGlnaXQoY2gpIHtcbiAgICAgICAgcmV0dXJuIFVOSUNPREUuZGlnaXQudGVzdChjaCk7XG59XG5cbmZ1bmN0aW9uIGlzX2FscGhhbnVtZXJpY19jaGFyKGNoKSB7XG4gICAgICAgIHJldHVybiBpc19kaWdpdChjaCkgfHwgaXNfbGV0dGVyKGNoKTtcbn07XG5cbmZ1bmN0aW9uIGlzX3VuaWNvZGVfY29tYmluaW5nX21hcmsoY2gpIHtcbiAgICAgICAgcmV0dXJuIFVOSUNPREUuY29tYmluaW5nX21hcmsudGVzdChjaCk7XG59O1xuXG5mdW5jdGlvbiBpc191bmljb2RlX2Nvbm5lY3Rvcl9wdW5jdHVhdGlvbihjaCkge1xuICAgICAgICByZXR1cm4gVU5JQ09ERS5jb25uZWN0b3JfcHVuY3R1YXRpb24udGVzdChjaCk7XG59O1xuXG5mdW5jdGlvbiBpc19pZGVudGlmaWVyX3N0YXJ0KGNoKSB7XG4gICAgICAgIHJldHVybiBjaCA9PSBcIiRcIiB8fCBjaCA9PSBcIl9cIiB8fCBpc19sZXR0ZXIoY2gpO1xufTtcblxuZnVuY3Rpb24gaXNfaWRlbnRpZmllcl9jaGFyKGNoKSB7XG4gICAgICAgIHJldHVybiBpc19pZGVudGlmaWVyX3N0YXJ0KGNoKVxuICAgICAgICAgICAgICAgIHx8IGlzX3VuaWNvZGVfY29tYmluaW5nX21hcmsoY2gpXG4gICAgICAgICAgICAgICAgfHwgaXNfdW5pY29kZV9kaWdpdChjaClcbiAgICAgICAgICAgICAgICB8fCBpc191bmljb2RlX2Nvbm5lY3Rvcl9wdW5jdHVhdGlvbihjaClcbiAgICAgICAgICAgICAgICB8fCBjaCA9PSBcIlxcdTIwMGNcIiAvLyB6ZXJvLXdpZHRoIG5vbi1qb2luZXIgPFpXTko+XG4gICAgICAgICAgICAgICAgfHwgY2ggPT0gXCJcXHUyMDBkXCIgLy8gemVyby13aWR0aCBqb2luZXIgPFpXSj4gKGluIG15IEVDTUEtMjYyIFBERiwgdGhpcyBpcyBhbHNvIDIwMGMpXG4gICAgICAgIDtcbn07XG5cbmZ1bmN0aW9uIHBhcnNlX2pzX251bWJlcihudW0pIHtcbiAgICAgICAgaWYgKFJFX0hFWF9OVU1CRVIudGVzdChudW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bS5zdWJzdHIoMiksIDE2KTtcbiAgICAgICAgfSBlbHNlIGlmIChSRV9PQ1RfTlVNQkVSLnRlc3QobnVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChudW0uc3Vic3RyKDEpLCA4KTtcbiAgICAgICAgfSBlbHNlIGlmIChSRV9ERUNfTlVNQkVSLnRlc3QobnVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG51bSk7XG4gICAgICAgIH1cbn07XG5cbmZ1bmN0aW9uIEpTX1BhcnNlX0Vycm9yKG1lc3NhZ2UsIGxpbmUsIGNvbCwgcG9zKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMubGluZSA9IGxpbmUgKyAxO1xuICAgICAgICB0aGlzLmNvbCA9IGNvbCArIDE7XG4gICAgICAgIHRoaXMucG9zID0gcG9zICsgMTtcbiAgICAgICAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xufTtcblxuSlNfUGFyc2VfRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2UgKyBcIiAobGluZTogXCIgKyB0aGlzLmxpbmUgKyBcIiwgY29sOiBcIiArIHRoaXMuY29sICsgXCIsIHBvczogXCIgKyB0aGlzLnBvcyArIFwiKVwiICsgXCJcXG5cXG5cIiArIHRoaXMuc3RhY2s7XG59O1xuXG5mdW5jdGlvbiBqc19lcnJvcihtZXNzYWdlLCBsaW5lLCBjb2wsIHBvcykge1xuICAgICAgICB0aHJvdyBuZXcgSlNfUGFyc2VfRXJyb3IobWVzc2FnZSwgbGluZSwgY29sLCBwb3MpO1xufTtcblxuZnVuY3Rpb24gaXNfdG9rZW4odG9rZW4sIHR5cGUsIHZhbCkge1xuICAgICAgICByZXR1cm4gdG9rZW4udHlwZSA9PSB0eXBlICYmICh2YWwgPT0gbnVsbCB8fCB0b2tlbi52YWx1ZSA9PSB2YWwpO1xufTtcblxudmFyIEVYX0VPRiA9IHt9O1xuXG5mdW5jdGlvbiB0b2tlbml6ZXIoJFRFWFQpIHtcblxuICAgICAgICB2YXIgUyA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0ICAgICAgICAgICAgOiAkVEVYVC5yZXBsYWNlKC9cXHJcXG4/fFtcXG5cXHUyMDI4XFx1MjAyOV0vZywgXCJcXG5cIikucmVwbGFjZSgvXlxcdUZFRkYvLCAnJyksXG4gICAgICAgICAgICAgICAgcG9zICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgICAgICB0b2twb3MgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgICAgIGxpbmUgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgdG9rbGluZSAgICAgICAgIDogMCxcbiAgICAgICAgICAgICAgICBjb2wgICAgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgICAgIHRva2NvbCAgICAgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgbmV3bGluZV9iZWZvcmUgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVnZXhfYWxsb3dlZCAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29tbWVudHNfYmVmb3JlIDogW11cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBwZWVrKCkgeyByZXR1cm4gUy50ZXh0LmNoYXJBdChTLnBvcyk7IH07XG5cbiAgICAgICAgZnVuY3Rpb24gbmV4dChzaWduYWxfZW9mLCBpbl9zdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2ggPSBTLnRleHQuY2hhckF0KFMucG9zKyspO1xuICAgICAgICAgICAgICAgIGlmIChzaWduYWxfZW9mICYmICFjaClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVYX0VPRjtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgUy5uZXdsaW5lX2JlZm9yZSA9IFMubmV3bGluZV9iZWZvcmUgfHwgIWluX3N0cmluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICsrUy5saW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgUy5jb2wgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK1MuY29sO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2g7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZW9mKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhUy5wZWVrKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZmluZCh3aGF0LCBzaWduYWxfZW9mKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IFMudGV4dC5pbmRleE9mKHdoYXQsIFMucG9zKTtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmFsX2VvZiAmJiBwb3MgPT0gLTEpIHRocm93IEVYX0VPRjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0X3Rva2VuKCkge1xuICAgICAgICAgICAgICAgIFMudG9rbGluZSA9IFMubGluZTtcbiAgICAgICAgICAgICAgICBTLnRva2NvbCA9IFMuY29sO1xuICAgICAgICAgICAgICAgIFMudG9rcG9zID0gUy5wb3M7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gdG9rZW4odHlwZSwgdmFsdWUsIGlzX2NvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBTLnJlZ2V4X2FsbG93ZWQgPSAoKHR5cGUgPT0gXCJvcGVyYXRvclwiICYmICFIT1AoVU5BUllfUE9TVEZJWCwgdmFsdWUpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZSA9PSBcImtleXdvcmRcIiAmJiBIT1AoS0VZV09SRFNfQkVGT1JFX0VYUFJFU1NJT04sIHZhbHVlKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGUgPT0gXCJwdW5jXCIgJiYgSE9QKFBVTkNfQkVGT1JFX0VYUFJFU1NJT04sIHZhbHVlKSkpO1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlICAgOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgIDogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lICAgOiBTLnRva2xpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wgICAgOiBTLnRva2NvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyAgICA6IFMudG9rcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9zIDogUy5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBubGIgICAgOiBTLm5ld2xpbmVfYmVmb3JlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzX2NvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5jb21tZW50c19iZWZvcmUgPSBTLmNvbW1lbnRzX2JlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMuY29tbWVudHNfYmVmb3JlID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIG5vdGUgb2YgYW55IG5ld2xpbmVzIGluIHRoZSBjb21tZW50cyB0aGF0IGNhbWUgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmV0LmNvbW1lbnRzX2JlZm9yZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQubmxiID0gcmV0Lm5sYiB8fCByZXQuY29tbWVudHNfYmVmb3JlW2ldLm5sYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUy5uZXdsaW5lX2JlZm9yZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gc2tpcF93aGl0ZXNwYWNlKCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChIT1AoV0hJVEVTUEFDRV9DSEFSUywgcGVlaygpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiByZWFkX3doaWxlKHByZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gXCJcIiwgY2ggPSBwZWVrKCksIGkgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjaCAmJiBwcmVkKGNoLCBpKyspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgKz0gbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSBwZWVrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VfZXJyb3IoZXJyKSB7XG4gICAgICAgICAgICAgICAganNfZXJyb3IoZXJyLCBTLnRva2xpbmUsIFMudG9rY29sLCBTLnRva3Bvcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZF9udW0ocHJlZml4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhc19lID0gZmFsc2UsIGFmdGVyX2UgPSBmYWxzZSwgaGFzX3ggPSBmYWxzZSwgaGFzX2RvdCA9IHByZWZpeCA9PSBcIi5cIjtcbiAgICAgICAgICAgICAgICB2YXIgbnVtID0gcmVhZF93aGlsZShmdW5jdGlvbihjaCwgaSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT0gXCJ4XCIgfHwgY2ggPT0gXCJYXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc194KSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNfeCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc194ICYmIChjaCA9PSBcIkVcIiB8fCBjaCA9PSBcImVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc19lKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNfZSA9IGFmdGVyX2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZnRlcl9lIHx8IChpID09IDAgJiYgIXByZWZpeCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT0gXCIrXCIpIHJldHVybiBhZnRlcl9lO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJfZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzX2RvdCAmJiAhaGFzX3ggJiYgIWhhc19lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNfZG90ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzX2FscGhhbnVtZXJpY19jaGFyKGNoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZml4KVxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcHJlZml4ICsgbnVtO1xuICAgICAgICAgICAgICAgIHZhciB2YWxpZCA9IHBhcnNlX2pzX251bWJlcihudW0pO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odmFsaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4oXCJudW1cIiwgdmFsaWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZV9lcnJvcihcIkludmFsaWQgc3ludGF4OiBcIiArIG51bSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRfZXNjYXBlZF9jaGFyKGluX3N0cmluZykge1xuICAgICAgICAgICAgICAgIHZhciBjaCA9IG5leHQodHJ1ZSwgaW5fc3RyaW5nKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJuXCIgOiByZXR1cm4gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJcIiA6IHJldHVybiBcIlxcclwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidFwiIDogcmV0dXJuIFwiXFx0XCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJiXCIgOiByZXR1cm4gXCJcXGJcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInZcIiA6IHJldHVybiBcIlxcdTAwMGJcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZcIiA6IHJldHVybiBcIlxcZlwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiMFwiIDogcmV0dXJuIFwiXFwwXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ4XCIgOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShoZXhfYnl0ZXMoMikpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidVwiIDogcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoaGV4X2J5dGVzKDQpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlxcblwiOiByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCAgOiByZXR1cm4gY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGhleF9ieXRlcyhuKSB7XG4gICAgICAgICAgICAgICAgdmFyIG51bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICg7IG4gPiAwOyAtLW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaWdpdCA9IHBhcnNlSW50KG5leHQodHJ1ZSksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihkaWdpdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlX2Vycm9yKFwiSW52YWxpZCBoZXgtY2hhcmFjdGVyIHBhdHRlcm4gaW4gc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gKG51bSA8PCA0KSB8IGRpZ2l0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRfc3RyaW5nKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aXRoX2VvZl9lcnJvcihcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdW90ZSA9IG5leHQoKSwgcmV0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoID0gbmV4dCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVhZCBPY3RhbEVzY2FwZVNlcXVlbmNlIChYWFg6IGRlcHJlY2F0ZWQgaWYgXCJzdHJpY3QgbW9kZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMvaXNzdWVzLzE3OFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvY3RhbF9sZW4gPSAwLCBmaXJzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSByZWFkX3doaWxlKGZ1bmN0aW9uKGNoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA+PSBcIjBcIiAmJiBjaCA8PSBcIjdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKytvY3RhbF9sZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmlyc3QgPD0gXCIzXCIgJiYgb2N0YWxfbGVuIDw9IDIpIHJldHVybiArK29jdGFsX2xlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmlyc3QgPj0gXCI0XCIgJiYgb2N0YWxfbGVuIDw9IDEpIHJldHVybiArK29jdGFsX2xlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2N0YWxfbGVuID4gMCkgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGNoLCA4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBjaCA9IHJlYWRfZXNjYXBlZF9jaGFyKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09IHF1b3RlKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuKFwic3RyaW5nXCIsIHJldCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZF9saW5lX2NvbW1lbnQoKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHZhciBpID0gZmluZChcIlxcblwiKSwgcmV0O1xuICAgICAgICAgICAgICAgIGlmIChpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBTLnRleHQuc3Vic3RyKFMucG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMucG9zID0gUy50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gUy50ZXh0LnN1YnN0cmluZyhTLnBvcywgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBTLnBvcyA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbihcImNvbW1lbnQxXCIsIHJldCwgdHJ1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZF9tdWx0aWxpbmVfY29tbWVudCgpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpdGhfZW9mX2Vycm9yKFwiVW50ZXJtaW5hdGVkIG11bHRpbGluZSBjb21tZW50XCIsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGZpbmQoXCIqL1wiLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gUy50ZXh0LnN1YnN0cmluZyhTLnBvcywgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBTLnBvcyA9IGkgKyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgUy5saW5lICs9IHRleHQuc3BsaXQoXCJcXG5cIikubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMubmV3bGluZV9iZWZvcmUgPSBTLm5ld2xpbmVfYmVmb3JlIHx8IHRleHQuaW5kZXhPZihcIlxcblwiKSA+PSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTL2lzc3Vlcy8jaXNzdWUvMTAwXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoL15AY2Nfb24vaS50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oXCJXQVJOSU5HOiBhdCBsaW5lIFwiICsgUy5saW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybihcIioqKiBGb3VuZCBcXFwiY29uZGl0aW9uYWwgY29tbWVudFxcXCI6IFwiICsgdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oXCIqKiogVWdsaWZ5SlMgRElTQ0FSRFMgQUxMIENPTU1FTlRTLiAgVGhpcyBtZWFucyB5b3VyIGNvZGUgbWlnaHQgbm8gbG9uZ2VyIHdvcmsgcHJvcGVybHkgaW4gSW50ZXJuZXQgRXhwbG9yZXIuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4oXCJjb21tZW50MlwiLCB0ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiByZWFkX25hbWUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhY2tzbGFzaCA9IGZhbHNlLCBuYW1lID0gXCJcIiwgY2gsIGVzY2FwZWQgPSBmYWxzZSwgaGV4O1xuICAgICAgICAgICAgICAgIHdoaWxlICgoY2ggPSBwZWVrKCkpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmFja3NsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PSBcIlxcXFxcIikgZXNjYXBlZCA9IGJhY2tzbGFzaCA9IHRydWUsIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNfaWRlbnRpZmllcl9jaGFyKGNoKSkgbmFtZSArPSBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoICE9IFwidVwiKSBwYXJzZV9lcnJvcihcIkV4cGVjdGluZyBVbmljb2RlRXNjYXBlU2VxdWVuY2UgLS0gdVhYWFhcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gcmVhZF9lc2NhcGVkX2NoYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc19pZGVudGlmaWVyX2NoYXIoY2gpKSBwYXJzZV9lcnJvcihcIlVuaWNvZGUgY2hhcjogXCIgKyBjaC5jaGFyQ29kZUF0KDApICsgXCIgaXMgbm90IHZhbGlkIGluIGlkZW50aWZpZXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tzbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoSE9QKEtFWVdPUkRTLCBuYW1lKSAmJiBlc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZXggPSBuYW1lLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJcXFxcdVwiICsgXCIwMDAwXCIuc3Vic3RyKGhleC5sZW5ndGgpICsgaGV4ICsgbmFtZS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZF9yZWdleHAocmVnZXhwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpdGhfZW9mX2Vycm9yKFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZfYmFja3NsYXNoID0gZmFsc2UsIGNoLCBpbl9jbGFzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjaCA9IG5leHQodHJ1ZSkpKSBpZiAocHJldl9iYWNrc2xhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhwICs9IFwiXFxcXFwiICsgY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZfYmFja3NsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiW1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluX2NsYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhwICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIl1cIiAmJiBpbl9jbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbl9jbGFzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleHAgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiL1wiICYmICFpbl9jbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldl9iYWNrc2xhc2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhwICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZHMgPSByZWFkX25hbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbihcInJlZ2V4cFwiLCBbIHJlZ2V4cCwgbW9kcyBdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiByZWFkX29wZXJhdG9yKHByZWZpeCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdyb3cob3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGVlaygpKSByZXR1cm4gb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmlnZ2VyID0gb3AgKyBwZWVrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoSE9QKE9QRVJBVE9SUywgYmlnZ2VyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBncm93KGJpZ2dlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4oXCJvcGVyYXRvclwiLCBncm93KHByZWZpeCB8fCBuZXh0KCkpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVfc2xhc2goKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHZhciByZWdleF9hbGxvd2VkID0gUy5yZWdleF9hbGxvd2VkO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocGVlaygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBTLmNvbW1lbnRzX2JlZm9yZS5wdXNoKHJlYWRfbGluZV9jb21tZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgUy5yZWdleF9hbGxvd2VkID0gcmVnZXhfYWxsb3dlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0X3Rva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBTLmNvbW1lbnRzX2JlZm9yZS5wdXNoKHJlYWRfbXVsdGlsaW5lX2NvbW1lbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBTLnJlZ2V4X2FsbG93ZWQgPSByZWdleF9hbGxvd2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRfdG9rZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFMucmVnZXhfYWxsb3dlZCA/IHJlYWRfcmVnZXhwKFwiXCIpIDogcmVhZF9vcGVyYXRvcihcIi9cIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlX2RvdCgpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzX2RpZ2l0KHBlZWsoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVhZF9udW0oXCIuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRva2VuKFwicHVuY1wiLCBcIi5cIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZF93b3JkKCkge1xuICAgICAgICAgICAgICAgIHZhciB3b3JkID0gcmVhZF9uYW1lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFIT1AoS0VZV09SRFMsIHdvcmQpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRva2VuKFwibmFtZVwiLCB3b3JkKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBIT1AoT1BFUkFUT1JTLCB3b3JkKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0b2tlbihcIm9wZXJhdG9yXCIsIHdvcmQpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IEhPUChLRVlXT1JEU19BVE9NLCB3b3JkKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0b2tlbihcImF0b21cIiwgd29yZClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdG9rZW4oXCJrZXl3b3JkXCIsIHdvcmQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHdpdGhfZW9mX2Vycm9yKGVvZl9lcnJvciwgY29udCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udCgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleCA9PT0gRVhfRU9GKSBwYXJzZV9lcnJvcihlb2ZfZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbmV4dF90b2tlbihmb3JjZV9yZWdleHApIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yY2VfcmVnZXhwICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZF9yZWdleHAoZm9yY2VfcmVnZXhwKTtcbiAgICAgICAgICAgICAgICBza2lwX3doaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICBzdGFydF90b2tlbigpO1xuICAgICAgICAgICAgICAgIHZhciBjaCA9IHBlZWsoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoKSByZXR1cm4gdG9rZW4oXCJlb2ZcIik7XG4gICAgICAgICAgICAgICAgaWYgKGlzX2RpZ2l0KGNoKSkgcmV0dXJuIHJlYWRfbnVtKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpIHJldHVybiByZWFkX3N0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmIChIT1AoUFVOQ19DSEFSUywgY2gpKSByZXR1cm4gdG9rZW4oXCJwdW5jXCIsIG5leHQoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09IFwiLlwiKSByZXR1cm4gaGFuZGxlX2RvdCgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PSBcIi9cIikgcmV0dXJuIGhhbmRsZV9zbGFzaCgpO1xuICAgICAgICAgICAgICAgIGlmIChIT1AoT1BFUkFUT1JfQ0hBUlMsIGNoKSkgcmV0dXJuIHJlYWRfb3BlcmF0b3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT0gXCJcXFxcXCIgfHwgaXNfaWRlbnRpZmllcl9zdGFydChjaCkpIHJldHVybiByZWFkX3dvcmQoKTtcbiAgICAgICAgICAgICAgICBwYXJzZV9lcnJvcihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNoICsgXCInXCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG5leHRfdG9rZW4uY29udGV4dCA9IGZ1bmN0aW9uKG5jKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5jKSBTID0gbmM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFM7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHRfdG9rZW47XG5cbn07XG5cbi8qIC0tLS0tWyBQYXJzZXIgKGNvbnN0YW50cykgXS0tLS0tICovXG5cbnZhciBVTkFSWV9QUkVGSVggPSBhcnJheV90b19oYXNoKFtcbiAgICAgICAgXCJ0eXBlb2ZcIixcbiAgICAgICAgXCJ2b2lkXCIsXG4gICAgICAgIFwiZGVsZXRlXCIsXG4gICAgICAgIFwiLS1cIixcbiAgICAgICAgXCIrK1wiLFxuICAgICAgICBcIiFcIixcbiAgICAgICAgXCJ+XCIsXG4gICAgICAgIFwiLVwiLFxuICAgICAgICBcIitcIlxuXSk7XG5cbnZhciBVTkFSWV9QT1NURklYID0gYXJyYXlfdG9faGFzaChbIFwiLS1cIiwgXCIrK1wiIF0pO1xuXG52YXIgQVNTSUdOTUVOVCA9IChmdW5jdGlvbihhLCByZXQsIGkpe1xuICAgICAgICB3aGlsZSAoaSA8IGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0W2FbaV1dID0gYVtpXS5zdWJzdHIoMCwgYVtpXS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbn0pKFxuICAgICAgICBbXCIrPVwiLCBcIi09XCIsIFwiLz1cIiwgXCIqPVwiLCBcIiU9XCIsIFwiPj49XCIsIFwiPDw9XCIsIFwiPj4+PVwiLCBcInw9XCIsIFwiXj1cIiwgXCImPVwiXSxcbiAgICAgICAgeyBcIj1cIjogdHJ1ZSB9LFxuICAgICAgICAwXG4pO1xuXG52YXIgUFJFQ0VERU5DRSA9IChmdW5jdGlvbihhLCByZXQpe1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IDE7IGkgPCBhLmxlbmd0aDsgKytpLCArK24pIHtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGFbaV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRbYltqXV0gPSBuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xufSkoXG4gICAgICAgIFtcbiAgICAgICAgICAgICAgICBbXCJ8fFwiXSxcbiAgICAgICAgICAgICAgICBbXCImJlwiXSxcbiAgICAgICAgICAgICAgICBbXCJ8XCJdLFxuICAgICAgICAgICAgICAgIFtcIl5cIl0sXG4gICAgICAgICAgICAgICAgW1wiJlwiXSxcbiAgICAgICAgICAgICAgICBbXCI9PVwiLCBcIj09PVwiLCBcIiE9XCIsIFwiIT09XCJdLFxuICAgICAgICAgICAgICAgIFtcIjxcIiwgXCI+XCIsIFwiPD1cIiwgXCI+PVwiLCBcImluXCIsIFwiaW5zdGFuY2VvZlwiXSxcbiAgICAgICAgICAgICAgICBbXCI+PlwiLCBcIjw8XCIsIFwiPj4+XCJdLFxuICAgICAgICAgICAgICAgIFtcIitcIiwgXCItXCJdLFxuICAgICAgICAgICAgICAgIFtcIipcIiwgXCIvXCIsIFwiJVwiXVxuICAgICAgICBdLFxuICAgICAgICB7fVxuKTtcblxudmFyIFNUQVRFTUVOVFNfV0lUSF9MQUJFTFMgPSBhcnJheV90b19oYXNoKFsgXCJmb3JcIiwgXCJkb1wiLCBcIndoaWxlXCIsIFwic3dpdGNoXCIgXSk7XG5cbnZhciBBVE9NSUNfU1RBUlRfVE9LRU4gPSBhcnJheV90b19oYXNoKFsgXCJhdG9tXCIsIFwibnVtXCIsIFwic3RyaW5nXCIsIFwicmVnZXhwXCIsIFwibmFtZVwiIF0pO1xuXG4vKiAtLS0tLVsgUGFyc2VyIF0tLS0tLSAqL1xuXG5mdW5jdGlvbiBOb2RlV2l0aFRva2VuKHN0ciwgc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBzdHI7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG59O1xuXG5Ob2RlV2l0aFRva2VuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5uYW1lOyB9O1xuXG5mdW5jdGlvbiBwYXJzZSgkVEVYVCwgZXhpZ2VudF9tb2RlLCBlbWJlZF90b2tlbnMpIHtcblxuICAgICAgICB2YXIgUyA9IHtcbiAgICAgICAgICAgICAgICBpbnB1dCAgICAgICAgIDogdHlwZW9mICRURVhUID09IFwic3RyaW5nXCIgPyB0b2tlbml6ZXIoJFRFWFQsIHRydWUpIDogJFRFWFQsXG4gICAgICAgICAgICAgICAgdG9rZW4gICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgcHJldiAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgcGVla2VkICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgaW5fZnVuY3Rpb24gICA6IDAsXG4gICAgICAgICAgICAgICAgaW5fZGlyZWN0aXZlcyA6IHRydWUsXG4gICAgICAgICAgICAgICAgaW5fbG9vcCAgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgbGFiZWxzICAgICAgICA6IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgUy50b2tlbiA9IG5leHQoKTtcblxuICAgICAgICBmdW5jdGlvbiBpcyh0eXBlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc190b2tlbihTLnRva2VuLCB0eXBlLCB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcGVlaygpIHsgcmV0dXJuIFMucGVla2VkIHx8IChTLnBlZWtlZCA9IFMuaW5wdXQoKSk7IH07XG5cbiAgICAgICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgICAgICBTLnByZXYgPSBTLnRva2VuO1xuICAgICAgICAgICAgICAgIGlmIChTLnBlZWtlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUy50b2tlbiA9IFMucGVla2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgUy5wZWVrZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBTLnRva2VuID0gUy5pbnB1dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBTLmluX2RpcmVjdGl2ZXMgPSBTLmluX2RpcmVjdGl2ZXMgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgUy50b2tlbi50eXBlID09IFwic3RyaW5nXCIgfHwgaXMoXCJwdW5jXCIsIFwiO1wiKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFMudG9rZW47XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcHJldigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUy5wcmV2O1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGNyb2FrKG1zZywgbGluZSwgY29sLCBwb3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gUy5pbnB1dC5jb250ZXh0KCk7XG4gICAgICAgICAgICAgICAganNfZXJyb3IobXNnLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgIT0gbnVsbCA/IGxpbmUgOiBjdHgudG9rbGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBjb2wgIT0gbnVsbCA/IGNvbCA6IGN0eC50b2tjb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgcG9zICE9IG51bGwgPyBwb3MgOiBjdHgudG9rcG9zKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiB0b2tlbl9lcnJvcih0b2tlbiwgbXNnKSB7XG4gICAgICAgICAgICAgICAgY3JvYWsobXNnLCB0b2tlbi5saW5lLCB0b2tlbi5jb2wpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHVuZXhwZWN0ZWQodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gUy50b2tlbjtcbiAgICAgICAgICAgICAgICB0b2tlbl9lcnJvcih0b2tlbiwgXCJVbmV4cGVjdGVkIHRva2VuOiBcIiArIHRva2VuLnR5cGUgKyBcIiAoXCIgKyB0b2tlbi52YWx1ZSArIFwiKVwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBleHBlY3RfdG9rZW4odHlwZSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzKHR5cGUsIHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2VuX2Vycm9yKFMudG9rZW4sIFwiVW5leHBlY3RlZCB0b2tlbiBcIiArIFMudG9rZW4udHlwZSArIFwiLCBleHBlY3RlZCBcIiArIHR5cGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGV4cGVjdChwdW5jKSB7IHJldHVybiBleHBlY3RfdG9rZW4oXCJwdW5jXCIsIHB1bmMpOyB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGNhbl9pbnNlcnRfc2VtaWNvbG9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhZXhpZ2VudF9tb2RlICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIFMudG9rZW4ubmxiIHx8IGlzKFwiZW9mXCIpIHx8IGlzKFwicHVuY1wiLCBcIn1cIilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHNlbWljb2xvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXMoXCJwdW5jXCIsIFwiO1wiKSkgbmV4dCgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFjYW5faW5zZXJ0X3NlbWljb2xvbigpKSB1bmV4cGVjdGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gYXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNsaWNlKGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyZW50aGVzaXNlZCgpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoXCIoXCIpO1xuICAgICAgICAgICAgICAgIHZhciBleCA9IGV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoXCIpXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBleDtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBhZGRfdG9rZW5zKHN0ciwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHIgaW5zdGFuY2VvZiBOb2RlV2l0aFRva2VuID8gc3RyIDogbmV3IE5vZGVXaXRoVG9rZW4oc3RyLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBtYXliZV9lbWJlZF90b2tlbnMocGFyc2VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVtYmVkX3Rva2VucykgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhc3QgPSBwYXJzZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzdFswXSA9IGFkZF90b2tlbnMoYXN0WzBdLCBzdGFydCwgcHJldigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBlbHNlIHJldHVybiBwYXJzZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHN0YXRlbWVudCA9IG1heWJlX2VtYmVkX3Rva2VucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiLCBcIi9cIikgfHwgaXMoXCJvcGVyYXRvclwiLCBcIi89XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBTLnBlZWtlZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBTLnRva2VuID0gUy5pbnB1dChTLnRva2VuLnZhbHVlLnN1YnN0cigxKSk7IC8vIGZvcmNlIHJlZ2V4cFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKFMudG9rZW4udHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyID0gUy5pbl9kaXJlY3RpdmVzLCBzdGF0ID0gc2ltcGxlX3N0YXRlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpciAmJiBzdGF0WzFdWzBdID09IFwic3RyaW5nXCIgJiYgIWlzKFwicHVuY1wiLCBcIixcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwiZGlyZWN0aXZlXCIsIHN0YXRbMV1bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXQ7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlZ2V4cFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwib3BlcmF0b3JcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImF0b21cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGVfc3RhdGVtZW50KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc190b2tlbihwZWVrKCksIFwicHVuY1wiLCBcIjpcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBsYWJlbGVkX3N0YXRlbWVudChwcm9nMShTLnRva2VuLnZhbHVlLCBuZXh0LCBuZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzaW1wbGVfc3RhdGVtZW50KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInB1bmNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoUy50b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ7XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcyhcImJsb2NrXCIsIGJsb2NrXygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiW1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGVfc3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIjtcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJibG9ja1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImtleXdvcmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvZzEoUy50b2tlbi52YWx1ZSwgbmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYnJlYWtcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJyZWFrX2NvbnQoXCJicmVha1wiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjb250aW51ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnJlYWtfY29udChcImNvbnRpbnVlXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRlYnVnZ2VyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJkZWJ1Z2dlclwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkb1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uKGJvZHkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdF90b2tlbihcImtleXdvcmRcIiwgXCJ3aGlsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJkb1wiLCBwcm9nMShwYXJlbnRoZXNpc2VkLCBzZW1pY29sb24pLCBib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoaW5fbG9vcChzdGF0ZW1lbnQpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcl8oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25fKHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlmXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpZl8oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZXR1cm5cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFMuaW5fZnVuY3Rpb24gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcm9hayhcIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcyhcInJldHVyblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMoXCJwdW5jXCIsIFwiO1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAobmV4dCgpLCBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjYW5faW5zZXJ0X3NlbWljb2xvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcHJvZzEoZXhwcmVzc2lvbiwgc2VtaWNvbG9uKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3dpdGNoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcyhcInN3aXRjaFwiLCBwYXJlbnRoZXNpc2VkKCksIHN3aXRjaF9ibG9ja18oKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGhyb3dcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFMudG9rZW4ubmxiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiSWxsZWdhbCBuZXdsaW5lIGFmdGVyICd0aHJvdydcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcyhcInRocm93XCIsIHByb2cxKGV4cHJlc3Npb24sIHNlbWljb2xvbikpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRyeVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ5XygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInZhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvZzEodmFyXywgc2VtaWNvbG9uKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvZzEoY29uc3RfLCBzZW1pY29sb24pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIndoaWxlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcyhcIndoaWxlXCIsIHBhcmVudGhlc2lzZWQoKSwgaW5fbG9vcChzdGF0ZW1lbnQpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ3aXRoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcyhcIndpdGhcIiwgcGFyZW50aGVzaXNlZCgpLCBzdGF0ZW1lbnQoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBsYWJlbGVkX3N0YXRlbWVudChsYWJlbCkge1xuICAgICAgICAgICAgICAgIFMubGFiZWxzLnB1c2gobGFiZWwpO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IFMudG9rZW4sIHN0YXQgPSBzdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpZ2VudF9tb2RlICYmICFIT1AoU1RBVEVNRU5UU19XSVRIX0xBQkVMUywgc3RhdFswXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBTLmxhYmVscy5wb3AoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJsYWJlbFwiLCBsYWJlbCwgc3RhdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gc2ltcGxlX3N0YXRlbWVudCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJzdGF0XCIsIHByb2cxKGV4cHJlc3Npb24sIHNlbWljb2xvbikpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGJyZWFrX2NvbnQodHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lO1xuICAgICAgICAgICAgICAgIGlmICghY2FuX2luc2VydF9zZW1pY29sb24oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGlzKFwibmFtZVwiKSA/IFMudG9rZW4udmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1lbWJlcihuYW1lLCBTLmxhYmVscykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiTGFiZWwgXCIgKyBuYW1lICsgXCIgd2l0aG91dCBtYXRjaGluZyBsb29wIG9yIHN0YXRlbWVudFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoUy5pbl9sb29wID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9hayh0eXBlICsgXCIgbm90IGluc2lkZSBhIGxvb3Agb3Igc3dpdGNoXCIpO1xuICAgICAgICAgICAgICAgIHNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcyh0eXBlLCBuYW1lKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBmb3JfKCkge1xuICAgICAgICAgICAgICAgIGV4cGVjdChcIihcIik7XG4gICAgICAgICAgICAgICAgdmFyIGluaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghaXMoXCJwdW5jXCIsIFwiO1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IGlzKFwia2V5d29yZFwiLCBcInZhclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChuZXh0KCksIHZhcl8odHJ1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZXhwcmVzc2lvbih0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyhcIm9wZXJhdG9yXCIsIFwiaW5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluaXRbMF0gPT0gXCJ2YXJcIiAmJiBpbml0WzFdLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJPbmx5IG9uZSB2YXJpYWJsZSBkZWNsYXJhdGlvbiBhbGxvd2VkIGluIGZvci4uaW4gbG9vcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcl9pbihpbml0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZ3VsYXJfZm9yKGluaXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlZ3VsYXJfZm9yKGluaXQpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoXCI7XCIpO1xuICAgICAgICAgICAgICAgIHZhciB0ZXN0ID0gaXMoXCJwdW5jXCIsIFwiO1wiKSA/IG51bGwgOiBleHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFwiO1wiKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RlcCA9IGlzKFwicHVuY1wiLCBcIilcIikgPyBudWxsIDogZXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChcIilcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwiZm9yXCIsIGluaXQsIHRlc3QsIHN0ZXAsIGluX2xvb3Aoc3RhdGVtZW50KSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZm9yX2luKGluaXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGhzID0gaW5pdFswXSA9PSBcInZhclwiID8gYXMoXCJuYW1lXCIsIGluaXRbMV1bMF0pIDogaW5pdDtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IGV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoXCIpXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcyhcImZvci1pblwiLCBpbml0LCBsaHMsIG9iaiwgaW5fbG9vcChzdGF0ZW1lbnQpKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZnVuY3Rpb25fID0gZnVuY3Rpb24oaW5fc3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBpcyhcIm5hbWVcIikgPyBwcm9nMShTLnRva2VuLnZhbHVlLCBuZXh0KSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGluX3N0YXRlbWVudCAmJiAhbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoXCIoXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcyhpbl9zdGF0ZW1lbnQgPyBcImRlZnVuXCIgOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24oZmlyc3QsIGEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghaXMoXCJwdW5jXCIsIFwiKVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KSBmaXJzdCA9IGZhbHNlOyBlbHNlIGV4cGVjdChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzKFwibmFtZVwiKSkgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKFMudG9rZW4udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pKHRydWUsIFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYm9keVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK1MuaW5fZnVuY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvb3AgPSBTLmluX2xvb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUy5pbl9kaXJlY3RpdmVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTLmluX2xvb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gYmxvY2tfKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1TLmluX2Z1bmN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFMuaW5fbG9vcCA9IGxvb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGlmXygpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29uZCA9IHBhcmVudGhlc2lzZWQoKSwgYm9keSA9IHN0YXRlbWVudCgpLCBiZWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiZWxzZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVsc2UgPSBzdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwiaWZcIiwgY29uZCwgYm9keSwgYmVsc2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGJsb2NrXygpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoXCJ7XCIpO1xuICAgICAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFpcyhcInB1bmNcIiwgXCJ9XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMoXCJlb2ZcIikpIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChzdGF0ZW1lbnQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc3dpdGNoX2Jsb2NrXyA9IGN1cnJ5KGluX2xvb3AsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFwie1wiKTtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IFtdLCBjdXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHdoaWxlICghaXMoXCJwdW5jXCIsIFwifVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKFwiZW9mXCIpKSB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiY2FzZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goWyBleHByZXNzaW9uKCksIGN1ciBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KFwiOlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzKFwia2V5d29yZFwiLCBcImRlZmF1bHRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QoXCI6XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKFsgbnVsbCwgY3VyIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3VyKSB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5wdXNoKHN0YXRlbWVudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiB0cnlfKCkge1xuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gYmxvY2tfKCksIGJjYXRjaCwgYmZpbmFsbHk7XG4gICAgICAgICAgICAgICAgaWYgKGlzKFwia2V5d29yZFwiLCBcImNhdGNoXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QoXCIoXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpcyhcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiTmFtZSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gUy50b2tlbi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChcIilcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBiY2F0Y2ggPSBbIG5hbWUsIGJsb2NrXygpIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpcyhcImtleXdvcmRcIiwgXCJmaW5hbGx5XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZmluYWxseSA9IGJsb2NrXygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWJjYXRjaCAmJiAhYmZpbmFsbHkpXG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9hayhcIk1pc3NpbmcgY2F0Y2gvZmluYWxseSBibG9ja3NcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwidHJ5XCIsIGJvZHksIGJjYXRjaCwgYmZpbmFsbHkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHZhcmRlZnMobm9faW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXMoXCJuYW1lXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IFMudG9rZW4udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiLCBcIj1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goWyBuYW1lLCBleHByZXNzaW9uKGZhbHNlLCBub19pbikgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goWyBuYW1lIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpcyhcInB1bmNcIiwgXCIsXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gdmFyXyhub19pbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcyhcInZhclwiLCB2YXJkZWZzKG5vX2luKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gY29uc3RfKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcyhcImNvbnN0XCIsIHZhcmRlZnMoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbmV3XygpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3ZXhwID0gZXhwcl9hdG9tKGZhbHNlKSwgYXJncztcbiAgICAgICAgICAgICAgICBpZiAoaXMoXCJwdW5jXCIsIFwiKFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGV4cHJfbGlzdChcIilcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoYXMoXCJuZXdcIiwgbmV3ZXhwLCBhcmdzKSwgdHJ1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGV4cHJfYXRvbSA9IG1heWJlX2VtYmVkX3Rva2VucyhmdW5jdGlvbihhbGxvd19jYWxscykge1xuICAgICAgICAgICAgICAgIGlmIChpcyhcIm9wZXJhdG9yXCIsIFwibmV3XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3XygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXMoXCJwdW5jXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKFMudG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKHByb2cxKGV4cHJlc3Npb24sIGN1cnJ5KGV4cGVjdCwgXCIpXCIpKSwgYWxsb3dfY2FsbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJbXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoYXJyYXlfKCksIGFsbG93X2NhbGxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwie1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKG9iamVjdF8oKSwgYWxsb3dfY2FsbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKGZ1bmN0aW9uXyhmYWxzZSksIGFsbG93X2NhbGxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEhPUChBVE9NSUNfU1RBUlRfVE9LRU4sIFMudG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdG9tID0gUy50b2tlbi50eXBlID09IFwicmVnZXhwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhcyhcInJlZ2V4cFwiLCBTLnRva2VuLnZhbHVlWzBdLCBTLnRva2VuLnZhbHVlWzFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFzKFMudG9rZW4udHlwZSwgUy50b2tlbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhwcm9nMShhdG9tLCBuZXh0KSwgYWxsb3dfY2FsbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGV4cHJfbGlzdChjbG9zaW5nLCBhbGxvd190cmFpbGluZ19jb21tYSwgYWxsb3dfZW1wdHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSB0cnVlLCBhID0gW107XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFpcyhcInB1bmNcIiwgY2xvc2luZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdCkgZmlyc3QgPSBmYWxzZTsgZWxzZSBleHBlY3QoXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsbG93X3RyYWlsaW5nX2NvbW1hICYmIGlzKFwicHVuY1wiLCBjbG9zaW5nKSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMoXCJwdW5jXCIsIFwiLFwiKSAmJiBhbGxvd19lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goWyBcImF0b21cIiwgXCJ1bmRlZmluZWRcIiBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChleHByZXNzaW9uKGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBhcnJheV8oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwiYXJyYXlcIiwgZXhwcl9saXN0KFwiXVwiLCAhZXhpZ2VudF9tb2RlLCB0cnVlKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gb2JqZWN0XygpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSB0cnVlLCBhID0gW107XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFpcyhcInB1bmNcIiwgXCJ9XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIGZpcnN0ID0gZmFsc2U7IGVsc2UgZXhwZWN0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXhpZ2VudF9tb2RlICYmIGlzKFwicHVuY1wiLCBcIn1cIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHRyYWlsaW5nIGNvbW1hXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBTLnRva2VuLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGFzX3Byb3BlcnR5X25hbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09IFwibmFtZVwiICYmIChuYW1lID09IFwiZ2V0XCIgfHwgbmFtZSA9PSBcInNldFwiKSAmJiAhaXMoXCJwdW5jXCIsIFwiOlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goWyBhc19uYW1lKCksIGZ1bmN0aW9uXyhmYWxzZSksIG5hbWUgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QoXCI6XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goWyBuYW1lLCBleHByZXNzaW9uKGZhbHNlKSBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcyhcIm9iamVjdFwiLCBhKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBhc19wcm9wZXJ0eV9uYW1lKCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoUy50b2tlbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2cxKFMudG9rZW4udmFsdWUsIG5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXNfbmFtZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGFzX25hbWUoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChTLnRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm9wZXJhdG9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJrZXl3b3JkXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhdG9tXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvZzEoUy50b2tlbi52YWx1ZSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHN1YnNjcmlwdHMoZXhwciwgYWxsb3dfY2FsbHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXMoXCJwdW5jXCIsIFwiLlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoYXMoXCJkb3RcIiwgZXhwciwgYXNfbmFtZSgpKSwgYWxsb3dfY2FsbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXMoXCJwdW5jXCIsIFwiW1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoYXMoXCJzdWJcIiwgZXhwciwgcHJvZzEoZXhwcmVzc2lvbiwgY3VycnkoZXhwZWN0LCBcIl1cIikpKSwgYWxsb3dfY2FsbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dfY2FsbHMgJiYgaXMoXCJwdW5jXCIsIFwiKFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoYXMoXCJjYWxsXCIsIGV4cHIsIGV4cHJfbGlzdChcIilcIikpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbWF5YmVfdW5hcnkoYWxsb3dfY2FsbHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiKSAmJiBIT1AoVU5BUllfUFJFRklYLCBTLnRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VfdW5hcnkoXCJ1bmFyeS1wcmVmaXhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2cxKFMudG9rZW4udmFsdWUsIG5leHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVfdW5hcnkoYWxsb3dfY2FsbHMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IGV4cHJfYXRvbShhbGxvd19jYWxscyk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGlzKFwib3BlcmF0b3JcIikgJiYgSE9QKFVOQVJZX1BPU1RGSVgsIFMudG9rZW4udmFsdWUpICYmICFTLnRva2VuLm5sYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbWFrZV91bmFyeShcInVuYXJ5LXBvc3RmaXhcIiwgUy50b2tlbi52YWx1ZSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBtYWtlX3VuYXJ5KHRhZywgb3AsIGV4cHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKG9wID09IFwiKytcIiB8fCBvcCA9PSBcIi0tXCIpICYmICFpc19hc3NpZ25hYmxlKGV4cHIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJJbnZhbGlkIHVzZSBvZiBcIiArIG9wICsgXCIgb3BlcmF0b3JcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzKHRhZywgb3AsIGV4cHIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGV4cHJfb3AobGVmdCwgbWluX3ByZWMsIG5vX2luKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wID0gaXMoXCJvcGVyYXRvclwiKSA/IFMudG9rZW4udmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChvcCAmJiBvcCA9PSBcImluXCIgJiYgbm9faW4pIG9wID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgcHJlYyA9IG9wICE9IG51bGwgPyBQUkVDRURFTkNFW29wXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHByZWMgIT0gbnVsbCAmJiBwcmVjID4gbWluX3ByZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByaWdodCA9IGV4cHJfb3AobWF5YmVfdW5hcnkodHJ1ZSksIHByZWMsIG5vX2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHByX29wKGFzKFwiYmluYXJ5XCIsIG9wLCBsZWZ0LCByaWdodCksIG1pbl9wcmVjLCBub19pbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGV4cHJfb3BzKG5vX2luKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cHJfb3AobWF5YmVfdW5hcnkodHJ1ZSksIDAsIG5vX2luKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBtYXliZV9jb25kaXRpb25hbChub19pbikge1xuICAgICAgICAgICAgICAgIHZhciBleHByID0gZXhwcl9vcHMobm9faW4pO1xuICAgICAgICAgICAgICAgIGlmIChpcyhcIm9wZXJhdG9yXCIsIFwiP1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHllcyA9IGV4cHJlc3Npb24oZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KFwiOlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcyhcImNvbmRpdGlvbmFsXCIsIGV4cHIsIHllcywgZXhwcmVzc2lvbihmYWxzZSwgbm9faW4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gaXNfYXNzaWduYWJsZShleHByKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFleGlnZW50X21vZGUpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXhwclswXStcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkb3RcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1YlwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmV3XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHByWzFdICE9IFwidGhpc1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBtYXliZV9hc3NpZ24obm9faW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IG1heWJlX2NvbmRpdGlvbmFsKG5vX2luKSwgdmFsID0gUy50b2tlbi52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiKSAmJiBIT1AoQVNTSUdOTUVOVCwgdmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2Fzc2lnbmFibGUobGVmdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXMoXCJhc3NpZ25cIiwgQVNTSUdOTUVOVFt2YWxdLCBsZWZ0LCBtYXliZV9hc3NpZ24obm9faW4pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiSW52YWxpZCBhc3NpZ25tZW50XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IG1heWJlX2VtYmVkX3Rva2VucyhmdW5jdGlvbihjb21tYXMsIG5vX2luKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIGV4cHIgPSBtYXliZV9hc3NpZ24obm9faW4pO1xuICAgICAgICAgICAgICAgIGlmIChjb21tYXMgJiYgaXMoXCJwdW5jXCIsIFwiLFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzKFwic2VxXCIsIGV4cHIsIGV4cHJlc3Npb24odHJ1ZSwgbm9faW4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGluX2xvb3AoY29udCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK1MuaW5fbG9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250KCk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC0tUy5pbl9sb29wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYXMoXCJ0b3BsZXZlbFwiLCAoZnVuY3Rpb24oYSl7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFpcyhcImVvZlwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChzdGF0ZW1lbnQoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH0pKFtdKSk7XG5cbn07XG5cbi8qIC0tLS0tWyBVdGlsaXRpZXMgXS0tLS0tICovXG5cbmZ1bmN0aW9uIGN1cnJ5KGYpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KHNsaWNlKGFyZ3VtZW50cykpKTsgfTtcbn07XG5cbmZ1bmN0aW9uIHByb2cxKHJldCkge1xuICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgICAgICAgICAgcmV0ID0gcmV0KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgLS1uID4gMDsgKytpKVxuICAgICAgICAgICAgICAgIGFyZ3VtZW50c1tpXSgpO1xuICAgICAgICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gYXJyYXlfdG9faGFzaChhKSB7XG4gICAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIHJldFthW2ldXSA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBzbGljZShhLCBzdGFydCkge1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYSwgc3RhcnQgfHwgMCk7XG59O1xuXG5mdW5jdGlvbiBjaGFyYWN0ZXJzKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnNwbGl0KFwiXCIpO1xufTtcblxuZnVuY3Rpb24gbWVtYmVyKG5hbWUsIGFycmF5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBhcnJheS5sZW5ndGg7IC0taSA+PSAwOylcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlbaV0gPT0gbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBIT1Aob2JqLCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn07XG5cbnZhciB3YXJuID0gZnVuY3Rpb24oKSB7fTtcblxuLyogLS0tLS1bIEV4cG9ydHMgXS0tLS0tICovXG5cbmV4cG9ydHMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5zbGljZSA9IHNsaWNlO1xuZXhwb3J0cy5jdXJyeSA9IGN1cnJ5O1xuZXhwb3J0cy5tZW1iZXIgPSBtZW1iZXI7XG5leHBvcnRzLmFycmF5X3RvX2hhc2ggPSBhcnJheV90b19oYXNoO1xuZXhwb3J0cy5QUkVDRURFTkNFID0gUFJFQ0VERU5DRTtcbmV4cG9ydHMuS0VZV09SRFNfQVRPTSA9IEtFWVdPUkRTX0FUT007XG5leHBvcnRzLlJFU0VSVkVEX1dPUkRTID0gUkVTRVJWRURfV09SRFM7XG5leHBvcnRzLktFWVdPUkRTID0gS0VZV09SRFM7XG5leHBvcnRzLkFUT01JQ19TVEFSVF9UT0tFTiA9IEFUT01JQ19TVEFSVF9UT0tFTjtcbmV4cG9ydHMuT1BFUkFUT1JTID0gT1BFUkFUT1JTO1xuZXhwb3J0cy5pc19hbHBoYW51bWVyaWNfY2hhciA9IGlzX2FscGhhbnVtZXJpY19jaGFyO1xuZXhwb3J0cy5pc19pZGVudGlmaWVyX3N0YXJ0ID0gaXNfaWRlbnRpZmllcl9zdGFydDtcbmV4cG9ydHMuaXNfaWRlbnRpZmllcl9jaGFyID0gaXNfaWRlbnRpZmllcl9jaGFyO1xuZXhwb3J0cy5zZXRfbG9nZ2VyID0gZnVuY3Rpb24obG9nZ2VyKSB7XG4gICAgICAgIHdhcm4gPSBsb2dnZXI7XG59O1xuXG4vLyBMb2NhbCB2YXJpYWJsZXM6XG4vLyBqcy1pbmRlbnQtbGV2ZWw6IDhcbi8vIEVuZDpcbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cblxuICBUaGlzIHZlcnNpb24gaXMgc3VpdGFibGUgZm9yIE5vZGUuanMuICBXaXRoIG1pbmltYWwgY2hhbmdlcyAodGhlXG4gIGV4cG9ydHMgc3R1ZmYpIGl0IHNob3VsZCB3b3JrIG9uIGFueSBKUyBwbGF0Zm9ybS5cblxuICBUaGlzIGZpbGUgaW1wbGVtZW50cyBzb21lIEFTVCBwcm9jZXNzb3JzLiAgVGhleSB3b3JrIG9uIGRhdGEgYnVpbHRcbiAgYnkgcGFyc2UtanMuXG5cbiAgRXhwb3J0ZWQgZnVuY3Rpb25zOlxuXG4gICAgLSBhc3RfbWFuZ2xlKGFzdCwgb3B0aW9ucykgLS0gbWFuZ2xlcyB0aGUgdmFyaWFibGUvZnVuY3Rpb24gbmFtZXNcbiAgICAgIGluIHRoZSBBU1QuICBSZXR1cm5zIGFuIEFTVC5cblxuICAgIC0gYXN0X3NxdWVlemUoYXN0KSAtLSBlbXBsb3lzIHZhcmlvdXMgb3B0aW1pemF0aW9ucyB0byBtYWtlIHRoZVxuICAgICAgZmluYWwgZ2VuZXJhdGVkIGNvZGUgZXZlbiBzbWFsbGVyLiAgUmV0dXJucyBhbiBBU1QuXG5cbiAgICAtIGdlbl9jb2RlKGFzdCwgb3B0aW9ucykgLS0gZ2VuZXJhdGVzIEpTIGNvZGUgZnJvbSB0aGUgQVNULiAgUGFzc1xuICAgICAgdHJ1ZSAob3IgYW4gb2JqZWN0LCBzZWUgdGhlIGNvZGUgZm9yIHNvbWUgb3B0aW9ucykgYXMgc2Vjb25kXG4gICAgICBhcmd1bWVudCB0byBnZXQgXCJwcmV0dHlcIiAoaW5kZW50ZWQpIGNvZGUuXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTAgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBqc3AgPSByZXF1aXJlKFwiLi9wYXJzZS1qc1wiKSxcbiAgICBjdXJyeSA9IGpzcC5jdXJyeSxcbiAgICBzbGljZSA9IGpzcC5zbGljZSxcbiAgICBtZW1iZXIgPSBqc3AubWVtYmVyLFxuICAgIGlzX2lkZW50aWZpZXJfY2hhciA9IGpzcC5pc19pZGVudGlmaWVyX2NoYXIsXG4gICAgUFJFQ0VERU5DRSA9IGpzcC5QUkVDRURFTkNFLFxuICAgIE9QRVJBVE9SUyA9IGpzcC5PUEVSQVRPUlM7XG5cbi8qIC0tLS0tWyBoZWxwZXIgZm9yIEFTVCB0cmF2ZXJzYWwgXS0tLS0tICovXG5cbmZ1bmN0aW9uIGFzdF93YWxrZXIoKSB7XG4gICAgICAgIGZ1bmN0aW9uIF92YXJkZWZzKGRlZnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBNQVAoZGVmcywgZnVuY3Rpb24oZGVmKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gWyBkZWZbMF0gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVsxXSA9IHdhbGsoZGVmWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICAgIH0pIF07XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIF9ibG9jayhzdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dCA9IFsgdGhpc1swXSBdO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZW1lbnRzICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChNQVAoc3RhdGVtZW50cywgd2FsaykpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB3YWxrZXJzID0ge1xuICAgICAgICAgICAgICAgIFwic3RyaW5nXCI6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgc3RyIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIm51bVwiOiBmdW5jdGlvbihudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIG51bSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIG5hbWUgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwidG9wbGV2ZWxcIjogZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgTUFQKHN0YXRlbWVudHMsIHdhbGspIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImJsb2NrXCI6IF9ibG9jayxcbiAgICAgICAgICAgICAgICBcInNwbGljZVwiOiBfYmxvY2ssXG4gICAgICAgICAgICAgICAgXCJ2YXJcIjogX3ZhcmRlZnMsXG4gICAgICAgICAgICAgICAgXCJjb25zdFwiOiBfdmFyZGVmcyxcbiAgICAgICAgICAgICAgICBcInRyeVwiOiBmdW5jdGlvbih0LCBjLCBmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNQVAodCwgd2FsayksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgIT0gbnVsbCA/IFsgY1swXSwgTUFQKGNbMV0sIHdhbGspIF0gOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmICE9IG51bGwgPyBNQVAoZiwgd2FsaykgOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ0aHJvd1wiOiBmdW5jdGlvbihleHByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCB3YWxrKGV4cHIpIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIm5ld1wiOiBmdW5jdGlvbihjdG9yLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCB3YWxrKGN0b3IpLCBNQVAoYXJncywgd2FsaykgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwic3dpdGNoXCI6IGZ1bmN0aW9uKGV4cHIsIGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHdhbGsoZXhwciksIE1BUChib2R5LCBmdW5jdGlvbihicmFuY2gpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBicmFuY2hbMF0gPyB3YWxrKGJyYW5jaFswXSkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNQVAoYnJhbmNoWzFdLCB3YWxrKSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYnJlYWtcIjogZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIGxhYmVsIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImNvbnRpbnVlXCI6IGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBsYWJlbCBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJjb25kaXRpb25hbFwiOiBmdW5jdGlvbihjb25kLCB0LCBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCB3YWxrKGNvbmQpLCB3YWxrKHQpLCB3YWxrKGUpIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImFzc2lnblwiOiBmdW5jdGlvbihvcCwgbHZhbHVlLCBydmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIG9wLCB3YWxrKGx2YWx1ZSksIHdhbGsocnZhbHVlKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJkb3RcIjogZnVuY3Rpb24oZXhwcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgd2FsayhleHByKSBdLmNvbmNhdChzbGljZShhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiY2FsbFwiOiBmdW5jdGlvbihleHByLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCB3YWxrKGV4cHIpLCBNQVAoYXJncywgd2FsaykgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIjogZnVuY3Rpb24obmFtZSwgYXJncywgYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgbmFtZSwgYXJncy5zbGljZSgpLCBNQVAoYm9keSwgd2FsaykgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZGVidWdnZXJcIjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImRlZnVuXCI6IGZ1bmN0aW9uKG5hbWUsIGFyZ3MsIGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIG5hbWUsIGFyZ3Muc2xpY2UoKSwgTUFQKGJvZHksIHdhbGspIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImlmXCI6IGZ1bmN0aW9uKGNvbmRpdGlvbmFsLCB0LCBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCB3YWxrKGNvbmRpdGlvbmFsKSwgd2Fsayh0KSwgd2FsayhlKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJmb3JcIjogZnVuY3Rpb24oaW5pdCwgY29uZCwgc3RlcCwgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHdhbGsoaW5pdCksIHdhbGsoY29uZCksIHdhbGsoc3RlcCksIHdhbGsoYmxvY2spIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImZvci1pblwiOiBmdW5jdGlvbih2dmFyLCBrZXksIGhhc2gsIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCB3YWxrKHZ2YXIpLCB3YWxrKGtleSksIHdhbGsoaGFzaCksIHdhbGsoYmxvY2spIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIndoaWxlXCI6IGZ1bmN0aW9uKGNvbmQsIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCB3YWxrKGNvbmQpLCB3YWxrKGJsb2NrKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJkb1wiOiBmdW5jdGlvbihjb25kLCBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgd2Fsayhjb25kKSwgd2FsayhibG9jaykgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwicmV0dXJuXCI6IGZ1bmN0aW9uKGV4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHdhbGsoZXhwcikgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYmluYXJ5XCI6IGZ1bmN0aW9uKG9wLCBsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgb3AsIHdhbGsobGVmdCksIHdhbGsocmlnaHQpIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInVuYXJ5LXByZWZpeFwiOiBmdW5jdGlvbihvcCwgZXhwcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgb3AsIHdhbGsoZXhwcikgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwidW5hcnktcG9zdGZpeFwiOiBmdW5jdGlvbihvcCwgZXhwcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgb3AsIHdhbGsoZXhwcikgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwic3ViXCI6IGZ1bmN0aW9uKGV4cHIsIHN1YnNjcmlwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgd2FsayhleHByKSwgd2FsayhzdWJzY3JpcHQpIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiOiBmdW5jdGlvbihwcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgTUFQKHByb3BzLCBmdW5jdGlvbihwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAubGVuZ3RoID09IDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFsgcFswXSwgd2FsayhwWzFdKSBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbIHBbMF0sIHdhbGsocFsxXSksIHBbMl0gXTsgLy8gZ2V0L3NldC10ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInJlZ2V4cFwiOiBmdW5jdGlvbihyeCwgbW9kcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgcngsIG1vZHMgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIE1BUChlbGVtZW50cywgd2FsaykgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwic3RhdFwiOiBmdW5jdGlvbihzdGF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCB3YWxrKHN0YXQpIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInNlcVwiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0gXS5jb25jYXQoTUFQKHNsaWNlKGFyZ3VtZW50cyksIHdhbGspKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwibGFiZWxcIjogZnVuY3Rpb24obmFtZSwgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIG5hbWUsIHdhbGsoYmxvY2spIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIndpdGhcIjogZnVuY3Rpb24oZXhwciwgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHdhbGsoZXhwciksIHdhbGsoYmxvY2spIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImF0b21cIjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgbmFtZSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJkaXJlY3RpdmVcIjogZnVuY3Rpb24oZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBkaXIgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHVzZXIgPSB7fTtcbiAgICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICAgIGZ1bmN0aW9uIHdhbGsoYXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFzdCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gYXN0WzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdlbiA9IHVzZXJbdHlwZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBnZW4uYXBwbHkoYXN0LCBhc3Quc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbiA9IHdhbGtlcnNbdHlwZV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2VuLmFwcGx5KGFzdCwgYXN0LnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGRpdmUoYXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFzdCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3YWxrZXJzW2FzdFswXV0uYXBwbHkoYXN0LCBhc3Quc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gd2l0aF93YWxrZXJzKHdhbGtlcnMsIGNvbnQpe1xuICAgICAgICAgICAgICAgIHZhciBzYXZlID0ge30sIGk7XG4gICAgICAgICAgICAgICAgZm9yIChpIGluIHdhbGtlcnMpIGlmIChIT1Aod2Fsa2VycywgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVbaV0gPSB1c2VyW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcltpXSA9IHdhbGtlcnNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXQgPSBjb250KCk7XG4gICAgICAgICAgICAgICAgZm9yIChpIGluIHNhdmUpIGlmIChIT1Aoc2F2ZSwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2F2ZVtpXSkgZGVsZXRlIHVzZXJbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHVzZXJbaV0gPSBzYXZlW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2Fsazogd2FsayxcbiAgICAgICAgICAgICAgICBkaXZlOiBkaXZlLFxuICAgICAgICAgICAgICAgIHdpdGhfd2Fsa2Vyczogd2l0aF93YWxrZXJzLFxuICAgICAgICAgICAgICAgIHBhcmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMl07IC8vIGxhc3Qgb25lIGlzIGN1cnJlbnQgbm9kZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbn07XG5cbi8qIC0tLS0tWyBTY29wZSBhbmQgbWFuZ2xpbmcgXS0tLS0tICovXG5cbmZ1bmN0aW9uIFNjb3BlKHBhcmVudCkge1xuICAgICAgICB0aGlzLm5hbWVzID0ge307ICAgICAgICAvLyBuYW1lcyBkZWZpbmVkIGluIHRoaXMgc2NvcGVcbiAgICAgICAgdGhpcy5tYW5nbGVkID0ge307ICAgICAgLy8gbWFuZ2xlZCBuYW1lcyAob3JpZy5uYW1lID0+IG1hbmdsZWQpXG4gICAgICAgIHRoaXMucmV2X21hbmdsZWQgPSB7fTsgIC8vIHJldmVyc2UgbG9va3VwIChtYW5nbGVkID0+IG9yaWcubmFtZSlcbiAgICAgICAgdGhpcy5jbmFtZSA9IC0xOyAgICAgICAgLy8gY3VycmVudCBtYW5nbGVkIG5hbWVcbiAgICAgICAgdGhpcy5yZWZzID0ge307ICAgICAgICAgLy8gbmFtZXMgcmVmZXJlbmNlZCBmcm9tIHRoaXMgc2NvcGVcbiAgICAgICAgdGhpcy51c2VzX3dpdGggPSBmYWxzZTsgLy8gd2lsbCBiZWNvbWUgVFJVRSBpZiB3aXRoKCkgaXMgZGV0ZWN0ZWQgaW4gdGhpcyBvciBhbnkgc3Vic2NvcGVzXG4gICAgICAgIHRoaXMudXNlc19ldmFsID0gZmFsc2U7IC8vIHdpbGwgYmVjb21lIFRSVUUgaWYgZXZhbCgpIGlzIGRldGVjdGVkIGluIHRoaXMgb3IgYW55IHN1YnNjb3Blc1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBbXTsgICAvLyBkaXJlY3RpdmVzIGFjdGl2YXRlZCBmcm9tIHRoaXMgc2NvcGVcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7ICAgLy8gcGFyZW50IHNjb3BlXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTsgICAgIC8vIHN1Yi1zY29wZXNcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGV2ZWwgPSBwYXJlbnQubGV2ZWwgKyAxO1xuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubGV2ZWwgPSAwO1xuICAgICAgICB9XG59O1xuXG5mdW5jdGlvbiBiYXNlNTRfZGlnaXRzKCkge1xuICAgICAgICBpZiAodHlwZW9mIERJR0lUU19PVkVSUklERV9GT1JfVEVTVElORyAhPSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBESUdJVFNfT1ZFUlJJREVfRk9SX1RFU1RJTkc7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJldG5yaXNvdWFmbGNocGR2bWd5YndFU3hUTkNrTEFPTV9EUEhCakZJcVJVeldYViRKS1FHWVowNTE2MzcyOTg0XCI7XG59XG5cbnZhciBiYXNlNTQgPSAoZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIERJR0lUUyA9IGJhc2U1NF9kaWdpdHMoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG51bSkge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBcIlwiLCBiYXNlID0gNTQ7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ICs9IERJR0lUUy5jaGFyQXQobnVtICUgYmFzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIGJhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSA9IDY0O1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKG51bSA+IDApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG59KSgpO1xuXG5TY29wZS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGhhczogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSB0aGlzOyBzOyBzID0gcy5wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoSE9QKHMubmFtZXMsIG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSxcbiAgICAgICAgaGFzX21hbmdsZWQ6IGZ1bmN0aW9uKG1uYW1lKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcyA9IHRoaXM7IHM7IHMgPSBzLnBhcmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChIT1Aocy5yZXZfbWFuZ2xlZCwgbW5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSxcbiAgICAgICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXM6IHRoaXMubmFtZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VzX2V2YWw6IHRoaXMudXNlc19ldmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlc193aXRoOiB0aGlzLnVzZXNfd2l0aFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgbmV4dF9tYW5nbGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBtdXN0IGJlIGNhcmVmdWwgdGhhdCB0aGUgbmV3IG1hbmdsZWQgbmFtZTpcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIDEuIGRvZXNuJ3Qgc2hhZG93IGEgbWFuZ2xlZCBuYW1lIGZyb20gYSBwYXJlbnRcbiAgICAgICAgICAgICAgICAvLyAgICBzY29wZSwgdW5sZXNzIHdlIGRvbid0IHJlZmVyZW5jZSB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAvLyAgICBuYW1lIGZyb20gdGhpcyBzY29wZSBPUiBmcm9tIGFueSBzdWItc2NvcGVzIVxuICAgICAgICAgICAgICAgIC8vICAgIFRoaXMgd2lsbCBnZXQgc2xvdy5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIDIuIGRvZXNuJ3Qgc2hhZG93IGFuIG9yaWdpbmFsIG5hbWUgZnJvbSBhIHBhcmVudFxuICAgICAgICAgICAgICAgIC8vICAgIHNjb3BlLCBpbiB0aGUgZXZlbnQgdGhhdCB0aGUgbmFtZSBpcyBub3QgbWFuZ2xlZFxuICAgICAgICAgICAgICAgIC8vICAgIGluIHRoZSBwYXJlbnQgc2NvcGUgYW5kIHdlIHJlZmVyZW5jZSB0aGF0IG5hbWVcbiAgICAgICAgICAgICAgICAvLyAgICBoZXJlIE9SIElOIEFOWSBTVUJTQ09QRVMhXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAzLiBkb2Vzbid0IHNoYWRvdyBhIG5hbWUgdGhhdCBpcyByZWZlcmVuY2VkIGJ1dCBub3RcbiAgICAgICAgICAgICAgICAvLyAgICBkZWZpbmVkIChwb3NzaWJseSBnbG9iYWwgZGVmaW5lZCBlbHNld2hlcmUpLlxuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gYmFzZTU0KCsrdGhpcy5jbmFtZSksIHByaW9yO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIDEuXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvciA9IHRoaXMuaGFzX21hbmdsZWQobSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJpb3IgJiYgdGhpcy5yZWZzW3ByaW9yLnJldl9tYW5nbGVkW21dXSA9PT0gcHJpb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIDIuXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvciA9IHRoaXMuaGFzKG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByaW9yICYmIHByaW9yICE9PSB0aGlzICYmIHRoaXMucmVmc1ttXSA9PT0gcHJpb3IgJiYgIXByaW9yLmhhc19tYW5nbGVkKG0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEhPUCh0aGlzLnJlZnMsIG0pICYmIHRoaXMucmVmc1ttXSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSSBnb3QgXCJkb1wiIG9uY2UuIDotL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc19pZGVudGlmaWVyKG0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRfbWFuZ2xlOiBmdW5jdGlvbihuYW1lLCBtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXZfbWFuZ2xlZFttXSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFuZ2xlZFtuYW1lXSA9IG07XG4gICAgICAgIH0sXG4gICAgICAgIGdldF9tYW5nbGVkOiBmdW5jdGlvbihuYW1lLCBuZXdNYW5nbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy51c2VzX2V2YWwgfHwgdGhpcy51c2VzX3dpdGgpIHJldHVybiBuYW1lOyAvLyBubyBtYW5nbGUgaWYgZXZhbCBvciB3aXRoIGlzIGluIHVzZVxuICAgICAgICAgICAgICAgIHZhciBzID0gdGhpcy5oYXMobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzKSByZXR1cm4gbmFtZTsgLy8gbm90IGluIHZpc2libGUgc2NvcGUsIG5vIG1hbmdsZVxuICAgICAgICAgICAgICAgIGlmIChIT1Aocy5tYW5nbGVkLCBuYW1lKSkgcmV0dXJuIHMubWFuZ2xlZFtuYW1lXTsgLy8gYWxyZWFkeSBtYW5nbGVkIGluIHRoaXMgc2NvcGVcbiAgICAgICAgICAgICAgICBpZiAoIW5ld01hbmdsZSkgcmV0dXJuIG5hbWU7ICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBmb3VuZCBhbmQgbm8gbWFuZ2xpbmcgcmVxdWVzdGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHMuc2V0X21hbmdsZShuYW1lLCBzLm5leHRfbWFuZ2xlZCgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVmZXJlbmNlczogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lICYmICF0aGlzLnBhcmVudCB8fCB0aGlzLnVzZXNfd2l0aCB8fCB0aGlzLnVzZXNfZXZhbCB8fCB0aGlzLnJlZnNbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmluZTogZnVuY3Rpb24obmFtZSwgdHlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09IFwidmFyXCIgfHwgIUhPUCh0aGlzLm5hbWVzLCBuYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lc1tuYW1lXSA9IHR5cGUgfHwgXCJ2YXJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWN0aXZlX2RpcmVjdGl2ZTogZnVuY3Rpb24oZGlyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lbWJlcihkaXIsIHRoaXMuZGlyZWN0aXZlcykgfHwgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuYWN0aXZlX2RpcmVjdGl2ZShkaXIpO1xuICAgICAgICB9XG59O1xuXG5mdW5jdGlvbiBhc3RfYWRkX3Njb3BlKGFzdCkge1xuXG4gICAgICAgIHZhciBjdXJyZW50X3Njb3BlID0gbnVsbDtcbiAgICAgICAgdmFyIHcgPSBhc3Rfd2Fsa2VyKCksIHdhbGsgPSB3LndhbGs7XG4gICAgICAgIHZhciBoYXZpbmdfZXZhbCA9IFtdO1xuXG4gICAgICAgIGZ1bmN0aW9uIHdpdGhfbmV3X3Njb3BlKGNvbnQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50X3Njb3BlID0gbmV3IFNjb3BlKGN1cnJlbnRfc2NvcGUpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfc2NvcGUubGFiZWxzID0gbmV3IFNjb3BlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IGN1cnJlbnRfc2NvcGUuYm9keSA9IGNvbnQoKTtcbiAgICAgICAgICAgICAgICByZXQuc2NvcGUgPSBjdXJyZW50X3Njb3BlO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfc2NvcGUgPSBjdXJyZW50X3Njb3BlLnBhcmVudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGRlZmluZShuYW1lLCB0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRfc2NvcGUuZGVmaW5lKG5hbWUsIHR5cGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlZmVyZW5jZShuYW1lKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudF9zY29wZS5yZWZzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBfbGFtYmRhKG5hbWUsIGFyZ3MsIGJvZHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNfZGVmdW4gPSB0aGlzWzBdID09IFwiZGVmdW5cIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBpc19kZWZ1biA/IGRlZmluZShuYW1lLCBcImRlZnVuXCIpIDogbmFtZSwgYXJncywgd2l0aF9uZXdfc2NvcGUoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNfZGVmdW4pIGRlZmluZShuYW1lLCBcImxhbWJkYVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1BUChhcmdzLCBmdW5jdGlvbihuYW1lKXsgZGVmaW5lKG5hbWUsIFwiYXJnXCIpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1BUChib2R5LCB3YWxrKTtcbiAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gX3ZhcmRlZnModHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihkZWZzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBNQVAoZGVmcywgZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluZShkWzBdLCB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRbMV0pIHJlZmVyZW5jZShkWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gX2JyZWFjb250KGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsKVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9zY29wZS5sYWJlbHMucmVmc1tsYWJlbF0gPSB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB3aXRoX25ld19zY29wZShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgQVNUXG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHcud2l0aF93YWxrZXJzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIjogX2xhbWJkYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGVmdW5cIjogX2xhbWJkYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibGFiZWxcIjogZnVuY3Rpb24obmFtZSwgc3RhdCkgeyBjdXJyZW50X3Njb3BlLmxhYmVscy5kZWZpbmUobmFtZSkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYnJlYWtcIjogX2JyZWFjb250LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjb250aW51ZVwiOiBfYnJlYWNvbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndpdGhcIjogZnVuY3Rpb24oZXhwciwgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcyA9IGN1cnJlbnRfc2NvcGU7IHM7IHMgPSBzLnBhcmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLnVzZXNfd2l0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YXJcIjogX3ZhcmRlZnMoXCJ2YXJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBcImNvbnN0XCI6IF92YXJkZWZzKFwiY29uc3RcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRyeVwiOiBmdW5jdGlvbih0LCBjLCBmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjICE9IG51bGwpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNQVAodCwgd2FsayksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBkZWZpbmUoY1swXSwgXCJjYXRjaFwiKSwgTUFQKGNbMV0sIHdhbGspIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiAhPSBudWxsID8gTUFQKGYsIHdhbGspIDogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwiZXZhbFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhdmluZ19ldmFsLnB1c2goY3VycmVudF9zY29wZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZShuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGsoYXN0KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHRoZSByZWFzb24gd2h5IHdlIG5lZWQgYW4gYWRkaXRpb25hbCBwYXNzIGhlcmUgaXNcbiAgICAgICAgICAgICAgICAvLyB0aGF0IG5hbWVzIGNhbiBiZSB1c2VkIHByaW9yIHRvIHRoZWlyIGRlZmluaXRpb24uXG5cbiAgICAgICAgICAgICAgICAvLyBzY29wZXMgd2hlcmUgZXZhbCB3YXMgZGV0ZWN0ZWQgYW5kIHRoZWlyIHBhcmVudHNcbiAgICAgICAgICAgICAgICAvLyBhcmUgbWFya2VkIHdpdGggdXNlc19ldmFsLCB1bmxlc3MgdGhleSBkZWZpbmUgdGhlXG4gICAgICAgICAgICAgICAgLy8gXCJldmFsXCIgbmFtZS5cbiAgICAgICAgICAgICAgICBNQVAoaGF2aW5nX2V2YWwsIGZ1bmN0aW9uKHNjb3BlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2NvcGUuaGFzKFwiZXZhbFwiKSkgd2hpbGUgKHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnVzZXNfZXZhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0gc2NvcGUucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gZm9yIHJlZmVyZW5jZWQgbmFtZXMgaXQgbWlnaHQgYmUgdXNlZnVsIHRvIGtub3dcbiAgICAgICAgICAgICAgICAvLyB0aGVpciBvcmlnaW4gc2NvcGUuICBjdXJyZW50X3Njb3BlIGhlcmUgaXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gdG9wbGV2ZWwgb25lLlxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZpeHJlZnMoc2NvcGUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIGNoaWxkcmVuIGZpcnN0OyBvcmRlciBzaG91bGRuJ3QgbWF0dGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBzY29wZS5jaGlsZHJlbi5sZW5ndGg7IC0taSA+PSAwOylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZml4cmVmcyhzY29wZS5jaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgaW4gc2NvcGUucmVmcykgaWYgKEhPUChzY29wZS5yZWZzLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIG9yaWdpbiBzY29wZSBhbmQgcHJvcGFnYXRlIHRoZSByZWZlcmVuY2UgdG8gb3JpZ2luXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG9yaWdpbiA9IHNjb3BlLmhhcyhpKSwgcyA9IHNjb3BlOyBzOyBzID0gcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLnJlZnNbaV0gPSBvcmlnaW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT09IG9yaWdpbikgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZpeHJlZnMoY3VycmVudF9zY29wZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9KTtcblxufTtcblxuLyogLS0tLS1bIG1hbmdsZSBuYW1lcyBdLS0tLS0gKi9cblxuZnVuY3Rpb24gYXN0X21hbmdsZShhc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHcgPSBhc3Rfd2Fsa2VyKCksIHdhbGsgPSB3LndhbGssIHNjb3BlO1xuICAgICAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICAgICAgICAgIG1hbmdsZSAgICAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgdG9wbGV2ZWwgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGVmaW5lcyAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBleGNlcHQgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIG5vX2Z1bmN0aW9ucyA6IGZhbHNlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldF9tYW5nbGVkKG5hbWUsIG5ld01hbmdsZSkge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5tYW5nbGUpIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy50b3BsZXZlbCAmJiAhc2NvcGUucGFyZW50KSByZXR1cm4gbmFtZTsgLy8gZG9uJ3QgbWFuZ2xlIHRvcGxldmVsXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXhjZXB0ICYmIG1lbWJlcihuYW1lLCBvcHRpb25zLmV4Y2VwdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ub19mdW5jdGlvbnMgJiYgSE9QKHNjb3BlLm5hbWVzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgICAoc2NvcGUubmFtZXNbbmFtZV0gPT0gJ2RlZnVuJyB8fCBzY29wZS5uYW1lc1tuYW1lXSA9PSAnbGFtYmRhJykpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZ2V0X21hbmdsZWQobmFtZSwgbmV3TWFuZ2xlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRfZGVmaW5lKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBhbHdheXMgbG9va3VwIGEgZGVmaW5lZCBzeW1ib2wgZm9yIHRoZSBjdXJyZW50IHNjb3BlIEZJUlNULCBzbyBkZWNsYXJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFycyB0cnVtcCBhIERFRklORSBzeW1ib2wsIGJ1dCBpZiBubyBzdWNoIHZhciBpcyBmb3VuZCwgdGhlbiBtYXRjaCBhIERFRklORSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY29wZS5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEhPUChvcHRpb25zLmRlZmluZXMsIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGVmaW5lc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIF9sYW1iZGEobmFtZSwgYXJncywgYm9keSkge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5ub19mdW5jdGlvbnMgJiYgb3B0aW9ucy5tYW5nbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc19kZWZ1biA9IHRoaXNbMF0gPT0gXCJkZWZ1blwiLCBleHRyYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc19kZWZ1bikgbmFtZSA9IGdldF9tYW5nbGVkKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChib2R5LnNjb3BlLnJlZmVyZW5jZXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHNjb3BlLnVzZXNfZXZhbCB8fCBzY29wZS51c2VzX3dpdGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGV4dHJhW25hbWVdID0gc2NvcGUubmV4dF9tYW5nbGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFbbmFtZV0gPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgbmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJvZHkgPSB3aXRoX3Njb3BlKGJvZHkuc2NvcGUsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gTUFQKGFyZ3MsIGZ1bmN0aW9uKG5hbWUpeyByZXR1cm4gZ2V0X21hbmdsZWQobmFtZSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTUFQKGJvZHksIHdhbGspO1xuICAgICAgICAgICAgICAgIH0sIGV4dHJhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBuYW1lLCBhcmdzLCBib2R5IF07XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gd2l0aF9zY29wZShzLCBjb250LCBleHRyYSkge1xuICAgICAgICAgICAgICAgIHZhciBfc2NvcGUgPSBzY29wZTtcbiAgICAgICAgICAgICAgICBzY29wZSA9IHM7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhKSBmb3IgKHZhciBpIGluIGV4dHJhKSBpZiAoSE9QKGV4dHJhLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5zZXRfbWFuZ2xlKGksIGV4dHJhW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBzLm5hbWVzKSBpZiAoSE9QKHMubmFtZXMsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRfbWFuZ2xlZChpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IGNvbnQoKTtcbiAgICAgICAgICAgICAgICByZXQuc2NvcGUgPSBzO1xuICAgICAgICAgICAgICAgIHNjb3BlID0gX3Njb3BlO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gX3ZhcmRlZnMoZGVmcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIE1BUChkZWZzLCBmdW5jdGlvbihkKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIGdldF9tYW5nbGVkKGRbMF0pLCB3YWxrKGRbMV0pIF07XG4gICAgICAgICAgICAgICAgfSkgXTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBfYnJlYWNvbnQobGFiZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWwpIHJldHVybiBbIHRoaXNbMF0sIHNjb3BlLmxhYmVscy5nZXRfbWFuZ2xlZChsYWJlbCkgXTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdy53aXRoX3dhbGtlcnMoe1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIjogX2xhbWJkYSxcbiAgICAgICAgICAgICAgICBcImRlZnVuXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBmdW5jdGlvbiBkZWNsYXJhdGlvbnMgdG8gdGhlIHRvcCB3aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGV5IGFyZSBub3QgaW4gc29tZSBibG9jay5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhc3QgPSBfbGFtYmRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHcucGFyZW50KClbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9wbGV2ZWxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGVmdW5cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1BUC5hdF90b3AoYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImxhYmVsXCI6IGZ1bmN0aW9uKGxhYmVsLCBzdGF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGUubGFiZWxzLnJlZnNbbGFiZWxdKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5sYWJlbHMuZ2V0X21hbmdsZWQobGFiZWwsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxrKHN0YXQpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGsoc3RhdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImJyZWFrXCI6IF9icmVhY29udCxcbiAgICAgICAgICAgICAgICBcImNvbnRpbnVlXCI6IF9icmVhY29udCxcbiAgICAgICAgICAgICAgICBcInZhclwiOiBfdmFyZGVmcyxcbiAgICAgICAgICAgICAgICBcImNvbnN0XCI6IF92YXJkZWZzLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0X2RlZmluZShuYW1lKSB8fCBbIHRoaXNbMF0sIGdldF9tYW5nbGVkKG5hbWUpIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInRyeVwiOiBmdW5jdGlvbih0LCBjLCBmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTUFQKHQsIHdhbGspLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyAhPSBudWxsID8gWyBnZXRfbWFuZ2xlZChjWzBdKSwgTUFQKGNbMV0sIHdhbGspIF0gOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiAhPSBudWxsID8gTUFQKGYsIHdhbGspIDogbnVsbCBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ0b3BsZXZlbFwiOiBmdW5jdGlvbihib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2l0aF9zY29wZShzZWxmLnNjb3BlLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBzZWxmWzBdLCBNQVAoYm9keSwgd2FsaykgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJkaXJlY3RpdmVcIjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTUFQLmF0X3RvcCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3YWxrKGFzdF9hZGRfc2NvcGUoYXN0KSk7XG4gICAgICAgIH0pO1xufTtcblxuLyogLS0tLS1bXG4gICAtIGNvbXByZXNzIGZvb1tcImJhclwiXSBpbnRvIGZvby5iYXIsXG4gICAtIHJlbW92ZSBibG9jayBicmFja2V0cyB7fSB3aGVyZSBwb3NzaWJsZVxuICAgLSBqb2luIGNvbnNlY3V0aXZlIHZhciBkZWNsYXJhdGlvbnNcbiAgIC0gdmFyaW91cyBvcHRpbWl6YXRpb25zIGZvciBJRnM6XG4gICAgIC0gaWYgKGNvbmQpIGZvbygpOyBlbHNlIGJhcigpOyAgPT0+ICBjb25kP2ZvbygpOmJhcigpO1xuICAgICAtIGlmIChjb25kKSBmb28oKTsgID09PiAgY29uZCYmZm9vKCk7XG4gICAgIC0gaWYgKGZvbykgcmV0dXJuIGJhcigpOyBlbHNlIHJldHVybiBiYXooKTsgID09PiByZXR1cm4gZm9vP2JhcigpOmJheigpOyAvLyBhbHNvIGZvciB0aHJvd1xuICAgICAtIGlmIChmb28pIHJldHVybiBiYXIoKTsgZWxzZSBzb21ldGhpbmcoKTsgID09PiB7aWYoZm9vKXJldHVybiBiYXIoKTtzb21ldGhpbmcoKX1cbiAgIF0tLS0tLSAqL1xuXG52YXIgd2FybiA9IGZ1bmN0aW9uKCl7fTtcblxuZnVuY3Rpb24gYmVzdF9vZihhc3QxLCBhc3QyKSB7XG4gICAgICAgIHJldHVybiBnZW5fY29kZShhc3QxKS5sZW5ndGggPiBnZW5fY29kZShhc3QyWzBdID09IFwic3RhdFwiID8gYXN0MlsxXSA6IGFzdDIpLmxlbmd0aCA/IGFzdDIgOiBhc3QxO1xufTtcblxuZnVuY3Rpb24gbGFzdF9zdGF0KGIpIHtcbiAgICAgICAgaWYgKGJbMF0gPT0gXCJibG9ja1wiICYmIGJbMV0gJiYgYlsxXS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBiWzFdW2JbMV0ubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiBiO1xufVxuXG5mdW5jdGlvbiBhYm9ydHModCkge1xuICAgICAgICBpZiAodCkgc3dpdGNoIChsYXN0X3N0YXQodClbMF0pIHtcbiAgICAgICAgICAgIGNhc2UgXCJyZXR1cm5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJicmVha1wiOlxuICAgICAgICAgICAgY2FzZSBcImNvbnRpbnVlXCI6XG4gICAgICAgICAgICBjYXNlIFwidGhyb3dcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxufTtcblxuZnVuY3Rpb24gYm9vbGVhbl9leHByKGV4cHIpIHtcbiAgICAgICAgcmV0dXJuICggKGV4cHJbMF0gPT0gXCJ1bmFyeS1wcmVmaXhcIlxuICAgICAgICAgICAgICAgICAgJiYgbWVtYmVyKGV4cHJbMV0sIFsgXCIhXCIsIFwiZGVsZXRlXCIgXSkpIHx8XG5cbiAgICAgICAgICAgICAgICAgKGV4cHJbMF0gPT0gXCJiaW5hcnlcIlxuICAgICAgICAgICAgICAgICAgJiYgbWVtYmVyKGV4cHJbMV0sIFsgXCJpblwiLCBcImluc3RhbmNlb2ZcIiwgXCI9PVwiLCBcIiE9XCIsIFwiPT09XCIsIFwiIT09XCIsIFwiPFwiLCBcIjw9XCIsIFwiPj1cIiwgXCI+XCIgXSkpIHx8XG5cbiAgICAgICAgICAgICAgICAgKGV4cHJbMF0gPT0gXCJiaW5hcnlcIlxuICAgICAgICAgICAgICAgICAgJiYgbWVtYmVyKGV4cHJbMV0sIFsgXCImJlwiLCBcInx8XCIgXSlcbiAgICAgICAgICAgICAgICAgICYmIGJvb2xlYW5fZXhwcihleHByWzJdKVxuICAgICAgICAgICAgICAgICAgJiYgYm9vbGVhbl9leHByKGV4cHJbM10pKSB8fFxuXG4gICAgICAgICAgICAgICAgIChleHByWzBdID09IFwiY29uZGl0aW9uYWxcIlxuICAgICAgICAgICAgICAgICAgJiYgYm9vbGVhbl9leHByKGV4cHJbMl0pXG4gICAgICAgICAgICAgICAgICAmJiBib29sZWFuX2V4cHIoZXhwclszXSkpIHx8XG5cbiAgICAgICAgICAgICAgICAgKGV4cHJbMF0gPT0gXCJhc3NpZ25cIlxuICAgICAgICAgICAgICAgICAgJiYgZXhwclsxXSA9PT0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgJiYgYm9vbGVhbl9leHByKGV4cHJbM10pKSB8fFxuXG4gICAgICAgICAgICAgICAgIChleHByWzBdID09IFwic2VxXCJcbiAgICAgICAgICAgICAgICAgICYmIGJvb2xlYW5fZXhwcihleHByW2V4cHIubGVuZ3RoIC0gMV0pKVxuICAgICAgICAgICAgICAgKTtcbn07XG5cbmZ1bmN0aW9uIGVtcHR5KGIpIHtcbiAgICAgICAgcmV0dXJuICFiIHx8IChiWzBdID09IFwiYmxvY2tcIiAmJiAoIWJbMV0gfHwgYlsxXS5sZW5ndGggPT0gMCkpO1xufTtcblxuZnVuY3Rpb24gaXNfc3RyaW5nKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIChub2RlWzBdID09IFwic3RyaW5nXCIgfHxcbiAgICAgICAgICAgICAgICBub2RlWzBdID09IFwidW5hcnktcHJlZml4XCIgJiYgbm9kZVsxXSA9PSBcInR5cGVvZlwiIHx8XG4gICAgICAgICAgICAgICAgbm9kZVswXSA9PSBcImJpbmFyeVwiICYmIG5vZGVbMV0gPT0gXCIrXCIgJiZcbiAgICAgICAgICAgICAgICAoaXNfc3RyaW5nKG5vZGVbMl0pIHx8IGlzX3N0cmluZyhub2RlWzNdKSkpO1xufTtcblxudmFyIHdoZW5fY29uc3RhbnQgPSAoZnVuY3Rpb24oKXtcblxuICAgICAgICB2YXIgJE5PVF9DT05TVEFOVCA9IHt9O1xuXG4gICAgICAgIC8vIHRoaXMgY2FuIG9ubHkgZXZhbHVhdGUgY29uc3RhbnQgZXhwcmVzc2lvbnMuICBJZiBpdCBmaW5kcyBhbnl0aGluZ1xuICAgICAgICAvLyBub3QgY29uc3RhbnQsIGl0IHRocm93cyAkTk9UX0NPTlNUQU5ULlxuICAgICAgICBmdW5jdGlvbiBldmFsdWF0ZShleHByKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChleHByWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cHJbMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhdG9tXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4cHJbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidHJ1ZVwiOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmFsc2VcIjogcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJudWxsXCI6IHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1bmFyeS1wcmVmaXhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXhwclsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhXCI6IHJldHVybiAhZXZhbHVhdGUoZXhwclsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInR5cGVvZlwiOiByZXR1cm4gdHlwZW9mIGV2YWx1YXRlKGV4cHJbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ+XCI6IHJldHVybiB+ZXZhbHVhdGUoZXhwclsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIi1cIjogcmV0dXJuIC1ldmFsdWF0ZShleHByWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiK1wiOiByZXR1cm4gK2V2YWx1YXRlKGV4cHJbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJiaW5hcnlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gZXhwclsyXSwgcmlnaHQgPSBleHByWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChleHByWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiYmXCIgICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSAmJiAgICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwifHxcIiAgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpIHx8ICAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ8XCIgICAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgfCAgICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiZcIiAgICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSAmICAgICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXlwiICAgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpIF4gICAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIrXCIgICAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgKyAgICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIipcIiAgICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSAqICAgICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiL1wiICAgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpIC8gICAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIlXCIgICAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgJSAgICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIi1cIiAgICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSAtICAgICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPDxcIiAgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpIDw8ICAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI+PlwiICAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgPj4gICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj4+PlwiICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSA+Pj4gICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPT1cIiAgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpID09ICAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI9PT1cIiAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgPT09ICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiE9XCIgICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSAhPSAgICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIT09XCIgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpICE9PSAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI8XCIgICAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgPCAgICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIjw9XCIgICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSA8PSAgICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPlwiICAgICAgICAgIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpID4gICAgICAgICAgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI+PVwiICAgICAgICAgOiByZXR1cm4gZXZhbHVhdGUobGVmdCkgPj0gICAgICAgICBldmFsdWF0ZShyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluXCIgICAgICAgICA6IHJldHVybiBldmFsdWF0ZShsZWZ0KSBpbiAgICAgICAgIGV2YWx1YXRlKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5zdGFuY2VvZlwiIDogcmV0dXJuIGV2YWx1YXRlKGxlZnQpIGluc3RhbmNlb2YgZXZhbHVhdGUocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyAkTk9UX0NPTlNUQU5UO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihleHByLCB5ZXMsIG5vKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBldmFsdWF0ZShleHByKSwgYXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiBhc3QgPSAgWyBcInN0cmluZ1wiLCB2YWwgXTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOiBhc3QgPSAgWyBcIm51bVwiLCB2YWwgXTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjogYXN0ID0gIFsgXCJuYW1lXCIsIFN0cmluZyh2YWwpIF07IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IG51bGwpIHsgYXN0ID0gWyBcImF0b21cIiwgXCJudWxsXCIgXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgaGFuZGxlIGNvbnN0YW50IG9mIHR5cGU6IFwiICsgKHR5cGVvZiB2YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5ZXMuY2FsbChleHByLCBhc3QsIHZhbCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4ID09PSAkTk9UX0NPTlNUQU5UKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByWzBdID09IFwiYmluYXJ5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChleHByWzFdID09IFwiPT09XCIgfHwgZXhwclsxXSA9PSBcIiE9PVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKChpc19zdHJpbmcoZXhwclsyXSkgJiYgaXNfc3RyaW5nKGV4cHJbM10pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IChib29sZWFuX2V4cHIoZXhwclsyXSkgJiYgYm9vbGVhbl9leHByKGV4cHJbM10pKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByWzFdID0gZXhwclsxXS5zdWJzdHIoMCwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm8gJiYgZXhwclswXSA9PSBcImJpbmFyeVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChleHByWzFdID09IFwifHxcIiB8fCBleHByWzFdID09IFwiJiZcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSB3aG9sZSBleHByZXNzaW9uIGlzIG5vdCBjb25zdGFudCBidXQgdGhlIGx2YWwgbWF5IGJlLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsdmFsID0gZXZhbHVhdGUoZXhwclsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9ICgoZXhwclsxXSA9PSBcIiYmXCIgJiYgKGx2YWwgPyBleHByWzNdIDogbHZhbCkpICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXhwclsxXSA9PSBcInx8XCIgJiYgKGx2YWwgPyBsdmFsICAgIDogZXhwclszXSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZXgyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUdOT1JFLi4uIGx2YWwgaXMgbm90IGNvbnN0YW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vID8gbm8uY2FsbChleHByLCBleHByKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHRocm93IGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxufSkoKTtcblxuZnVuY3Rpb24gd2Fybl91bnJlYWNoYWJsZShhc3QpIHtcbiAgICAgICAgaWYgKCFlbXB0eShhc3QpKVxuICAgICAgICAgICAgICAgIHdhcm4oXCJEcm9wcGluZyB1bnJlYWNoYWJsZSBjb2RlOiBcIiArIGdlbl9jb2RlKGFzdCwgdHJ1ZSkpO1xufTtcblxuZnVuY3Rpb24gcHJlcGFyZV9pZnMoYXN0KSB7XG4gICAgICAgIHZhciB3ID0gYXN0X3dhbGtlcigpLCB3YWxrID0gdy53YWxrO1xuICAgICAgICAvLyBJbiB0aGlzIGZpcnN0IHBhc3MsIHdlIHJld3JpdGUgaWZzIHdoaWNoIGFib3J0IHdpdGggbm8gZWxzZSB3aXRoIGFuXG4gICAgICAgIC8vIGlmLWVsc2UuICBGb3IgZXhhbXBsZTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gaWYgKHgpIHtcbiAgICAgICAgLy8gICAgIGJsYWgoKTtcbiAgICAgICAgLy8gICAgIHJldHVybiB5O1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGZvb2JhcigpO1xuICAgICAgICAvL1xuICAgICAgICAvLyBpcyByZXdyaXR0ZW4gaW50bzpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gaWYgKHgpIHtcbiAgICAgICAgLy8gICAgIGJsYWgoKTtcbiAgICAgICAgLy8gICAgIHJldHVybiB5O1xuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAvLyAgICAgZm9vYmFyKCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgZnVuY3Rpb24gcmVkb19pZihzdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVtZW50cyA9IE1BUChzdGF0ZW1lbnRzLCB3YWxrKTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpID0gc3RhdGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaVswXSAhPSBcImlmXCIpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlbM10pIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGZpWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhYm9ydHModCkpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uZGl0aW9uYWwgPSB3YWxrKGZpWzFdKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVfYm9keSA9IHJlZG9faWYoc3RhdGVtZW50cy5zbGljZShpICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBlX2JvZHkubGVuZ3RoID09IDEgPyBlX2JvZHlbMF0gOiBbIFwiYmxvY2tcIiwgZV9ib2R5IF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnRzLnNsaWNlKDAsIGkpLmNvbmNhdChbIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlbMF0sICAgICAgICAgIC8vIFwiaWZcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25hbCwgICAgLy8gY29uZGl0aW9uYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCwgICAgICAgICAgICAgIC8vIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSAgICAgICAgICAgICAgIC8vIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIF0gXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlbWVudHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcmVkb19pZl9sYW1iZGEobmFtZSwgYXJncywgYm9keSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSByZWRvX2lmKGJvZHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIG5hbWUsIGFyZ3MsIGJvZHkgXTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiByZWRvX2lmX2Jsb2NrKHN0YXRlbWVudHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBzdGF0ZW1lbnRzICE9IG51bGwgPyByZWRvX2lmKHN0YXRlbWVudHMpIDogbnVsbCBdO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB3LndpdGhfd2Fsa2Vycyh7XG4gICAgICAgICAgICAgICAgXCJkZWZ1blwiOiByZWRvX2lmX2xhbWJkYSxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCI6IHJlZG9faWZfbGFtYmRhLFxuICAgICAgICAgICAgICAgIFwiYmxvY2tcIjogcmVkb19pZl9ibG9jayxcbiAgICAgICAgICAgICAgICBcInNwbGljZVwiOiByZWRvX2lmX2Jsb2NrLFxuICAgICAgICAgICAgICAgIFwidG9wbGV2ZWxcIjogZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgcmVkb19pZihzdGF0ZW1lbnRzKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ0cnlcIjogZnVuY3Rpb24odCwgYywgZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkb19pZih0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyAhPSBudWxsID8gWyBjWzBdLCByZWRvX2lmKGNbMV0pIF0gOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmICE9IG51bGwgPyByZWRvX2lmKGYpIDogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3YWxrKGFzdCk7XG4gICAgICAgIH0pO1xufTtcblxuZnVuY3Rpb24gZm9yX3NpZGVfZWZmZWN0cyhhc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIHcgPSBhc3Rfd2Fsa2VyKCksIHdhbGsgPSB3LndhbGs7XG4gICAgICAgIHZhciAkc3RvcCA9IHt9LCAkcmVzdGFydCA9IHt9O1xuICAgICAgICBmdW5jdGlvbiBzdG9wKCkgeyB0aHJvdyAkc3RvcCB9O1xuICAgICAgICBmdW5jdGlvbiByZXN0YXJ0KCkgeyB0aHJvdyAkcmVzdGFydCB9O1xuICAgICAgICBmdW5jdGlvbiBmb3VuZCgpeyByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIHRoaXMsIHcsIHN0b3AsIHJlc3RhcnQpIH07XG4gICAgICAgIGZ1bmN0aW9uIHVuYXJ5KG9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wID09IFwiKytcIiB8fCBvcCA9PSBcIi0tXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gYmluYXJ5KG9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wID09IFwiJiZcIiB8fCBvcCA9PSBcInx8XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHcud2l0aF93YWxrZXJzKHtcbiAgICAgICAgICAgICAgICBcInRyeVwiOiBmb3VuZCxcbiAgICAgICAgICAgICAgICBcInRocm93XCI6IGZvdW5kLFxuICAgICAgICAgICAgICAgIFwicmV0dXJuXCI6IGZvdW5kLFxuICAgICAgICAgICAgICAgIFwibmV3XCI6IGZvdW5kLFxuICAgICAgICAgICAgICAgIFwic3dpdGNoXCI6IGZvdW5kLFxuICAgICAgICAgICAgICAgIFwiYnJlYWtcIjogZm91bmQsXG4gICAgICAgICAgICAgICAgXCJjb250aW51ZVwiOiBmb3VuZCxcbiAgICAgICAgICAgICAgICBcImFzc2lnblwiOiBmb3VuZCxcbiAgICAgICAgICAgICAgICBcImNhbGxcIjogZm91bmQsXG4gICAgICAgICAgICAgICAgXCJpZlwiOiBmb3VuZCxcbiAgICAgICAgICAgICAgICBcImZvclwiOiBmb3VuZCxcbiAgICAgICAgICAgICAgICBcImZvci1pblwiOiBmb3VuZCxcbiAgICAgICAgICAgICAgICBcIndoaWxlXCI6IGZvdW5kLFxuICAgICAgICAgICAgICAgIFwiZG9cIjogZm91bmQsXG4gICAgICAgICAgICAgICAgXCJyZXR1cm5cIjogZm91bmQsXG4gICAgICAgICAgICAgICAgXCJ1bmFyeS1wcmVmaXhcIjogdW5hcnksXG4gICAgICAgICAgICAgICAgXCJ1bmFyeS1wb3N0Zml4XCI6IHVuYXJ5LFxuICAgICAgICAgICAgICAgIFwiY29uZGl0aW9uYWxcIjogZm91bmQsXG4gICAgICAgICAgICAgICAgXCJiaW5hcnlcIjogYmluYXJ5LFxuICAgICAgICAgICAgICAgIFwiZGVmdW5cIjogZm91bmRcbiAgICAgICAgfSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhbGsoYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleCA9PT0gJHN0b3ApIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4ID09PSAkcmVzdGFydCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH0pO1xufTtcblxuZnVuY3Rpb24gYXN0X2xpZnRfdmFyaWFibGVzKGFzdCkge1xuICAgICAgICB2YXIgdyA9IGFzdF93YWxrZXIoKSwgd2FsayA9IHcud2Fsaywgc2NvcGU7XG4gICAgICAgIGZ1bmN0aW9uIGRvX2JvZHkoYm9keSwgZW52KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9zY29wZSA9IHNjb3BlO1xuICAgICAgICAgICAgICAgIHNjb3BlID0gZW52O1xuICAgICAgICAgICAgICAgIGJvZHkgPSBNQVAoYm9keSwgd2Fsayk7XG4gICAgICAgICAgICAgICAgdmFyIGhhc2ggPSB7fSwgbmFtZXMgPSBNQVAoZW52Lm5hbWVzLCBmdW5jdGlvbih0eXBlLCBuYW1lKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9IFwidmFyXCIpIHJldHVybiBNQVAuc2tpcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZW52LnJlZmVyZW5jZXMobmFtZSkpIHJldHVybiBNQVAuc2tpcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgbmFtZSBdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb29raW5nIGZvciBhc3NpZ25tZW50cyB0byBhbnkgb2YgdGhlc2UgdmFyaWFibGVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIHNhdmUgY29uc2lkZXJhYmxlIHNwYWNlIGJ5IG1vdmluZyB0aGUgZGVmaW5pdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSB2YXIgZGVjbGFyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3Jfc2lkZV9lZmZlY3RzKFsgXCJibG9ja1wiLCBib2R5IF0sIGZ1bmN0aW9uKGFzdCwgd2Fsa2VyLCBzdG9wLCByZXN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhc3RbMF0gPT0gXCJhc3NpZ25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgYXN0WzFdID09PSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBhc3RbMl1bMF0gPT0gXCJuYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIEhPUChoYXNoLCBhc3RbMl1bMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBkZWZpbml0aW9uIGludG8gdGhlIHZhciBkZWNsYXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBuYW1lcy5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVzW2ldWzBdID09IGFzdFsyXVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZXNbaV1bMV0pIC8vIHRoaXMgbmFtZSBhbHJlYWR5IGRlZmluZWQsIHdlIG11c3Qgc3RvcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNbaV1bMV0gPSBhc3RbM107IC8vIGRlZmluaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXMucHVzaChuYW1lcy5zcGxpY2UoaSwgMSlbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoaXMgYXNzaWdubWVudCBmcm9tIHRoZSBBU1QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSB3YWxrZXIucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBbMF0gPT0gXCJzZXFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBwWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS51bnNoaWZ0KDAsIHAubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuc3BsaWNlLmFwcGx5KHAsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwWzBdID09IFwic3RhdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLnNwbGljZSgwLCBwLmxlbmd0aCwgXCJibG9ja1wiKTsgLy8gZW1wdHkgc3RhdGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5LnVuc2hpZnQoWyBcInZhclwiLCBuYW1lcyBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2NvcGUgPSBfc2NvcGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIF92YXJkZWZzKGRlZnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gZGVmcy5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBkZWZzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkWzFdKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBbIFwiYXNzaWduXCIsIHRydWUsIFsgXCJuYW1lXCIsIGRbMF0gXSwgZFsxXSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PSBudWxsKSByZXQgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSByZXQgPSBbIFwic2VxXCIsIGQsIHJldCBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmV0ID09IG51bGwgJiYgdy5wYXJlbnQoKVswXSAhPSBcImZvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAody5wYXJlbnQoKVswXSA9PSBcImZvci1pblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBcIm5hbWVcIiwgZGVmc1swXVswXSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1BUC5za2lwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWyBcInN0YXRcIiwgcmV0IF07XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIF90b3BsZXZlbChib2R5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgZG9fYm9keShib2R5LCB0aGlzLnNjb3BlKSBdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdy53aXRoX3dhbGtlcnMoe1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIjogZnVuY3Rpb24obmFtZSwgYXJncywgYm9keSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gYXJncy5sZW5ndGg7IC0taSA+PSAwICYmICFib2R5LnNjb3BlLnJlZmVyZW5jZXMoYXJnc1tpXSk7KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFib2R5LnNjb3BlLnJlZmVyZW5jZXMobmFtZSkpIG5hbWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgbmFtZSwgYXJncywgZG9fYm9keShib2R5LCBib2R5LnNjb3BlKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJkZWZ1blwiOiBmdW5jdGlvbihuYW1lLCBhcmdzLCBib2R5KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2NvcGUucmVmZXJlbmNlcyhuYW1lKSkgcmV0dXJuIE1BUC5za2lwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGFyZ3MubGVuZ3RoOyAtLWkgPj0gMCAmJiAhYm9keS5zY29wZS5yZWZlcmVuY2VzKGFyZ3NbaV0pOylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIG5hbWUsIGFyZ3MsIGRvX2JvZHkoYm9keSwgYm9keS5zY29wZSkgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwidmFyXCI6IF92YXJkZWZzLFxuICAgICAgICAgICAgICAgIFwidG9wbGV2ZWxcIjogX3RvcGxldmVsXG4gICAgICAgIH0sIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhbGsoYXN0X2FkZF9zY29wZShhc3QpKTtcbiAgICAgICAgfSk7XG59O1xuXG5mdW5jdGlvbiBhc3Rfc3F1ZWV6ZShhc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgYXN0ID0gc3F1ZWV6ZV8xKGFzdCwgb3B0aW9ucyk7XG4gICAgICAgIGFzdCA9IHNxdWVlemVfMihhc3QsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYXN0O1xufTtcblxuZnVuY3Rpb24gc3F1ZWV6ZV8xKGFzdCwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICAgICAgICAgIG1ha2Vfc2VxcyAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkZWFkX2NvZGUgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgbm9fd2FybmluZ3MgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBrZWVwX2NvbXBzICA6IHRydWUsXG4gICAgICAgICAgICAgICAgdW5zYWZlICAgICAgOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdyA9IGFzdF93YWxrZXIoKSwgd2FsayA9IHcud2Fsaywgc2NvcGU7XG5cbiAgICAgICAgZnVuY3Rpb24gbmVnYXRlKGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm90X2MgPSBbIFwidW5hcnktcHJlZml4XCIsIFwiIVwiLCBjIF07XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1bmFyeS1wcmVmaXhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjWzFdID09IFwiIVwiICYmIGJvb2xlYW5fZXhwcihjWzJdKSA/IGNbMl0gOiBub3RfYztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNlcVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHNsaWNlKGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY1tjLmxlbmd0aCAtIDFdID0gbmVnYXRlKGNbYy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNvbmRpdGlvbmFsXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdF9vZihub3RfYywgWyBcImNvbmRpdGlvbmFsXCIsIGNbMV0sIG5lZ2F0ZShjWzJdKSwgbmVnYXRlKGNbM10pIF0pO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYmluYXJ5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3AgPSBjWzFdLCBsZWZ0ID0gY1syXSwgcmlnaHQgPSBjWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmtlZXBfY29tcHMpIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPD1cIiAgOiByZXR1cm4gWyBcImJpbmFyeVwiLCBcIj5cIiwgbGVmdCwgcmlnaHQgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPFwiICAgOiByZXR1cm4gWyBcImJpbmFyeVwiLCBcIj49XCIsIGxlZnQsIHJpZ2h0IF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj49XCIgIDogcmV0dXJuIFsgXCJiaW5hcnlcIiwgXCI8XCIsIGxlZnQsIHJpZ2h0IF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj5cIiAgIDogcmV0dXJuIFsgXCJiaW5hcnlcIiwgXCI8PVwiLCBsZWZ0LCByaWdodCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI9PVwiICA6IHJldHVybiBbIFwiYmluYXJ5XCIsIFwiIT1cIiwgbGVmdCwgcmlnaHQgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIT1cIiAgOiByZXR1cm4gWyBcImJpbmFyeVwiLCBcIj09XCIsIGxlZnQsIHJpZ2h0IF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj09PVwiIDogcmV0dXJuIFsgXCJiaW5hcnlcIiwgXCIhPT1cIiwgbGVmdCwgcmlnaHQgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIT09XCIgOiByZXR1cm4gWyBcImJpbmFyeVwiLCBcIj09PVwiLCBsZWZ0LCByaWdodCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCImJlwiICA6IHJldHVybiBiZXN0X29mKG5vdF9jLCBbIFwiYmluYXJ5XCIsIFwifHxcIiwgbmVnYXRlKGxlZnQpLCBuZWdhdGUocmlnaHQpIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ8fFwiICA6IHJldHVybiBiZXN0X29mKG5vdF9jLCBbIFwiYmluYXJ5XCIsIFwiJiZcIiwgbmVnYXRlKGxlZnQpLCBuZWdhdGUocmlnaHQpIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub3RfYztcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBtYWtlX2NvbmRpdGlvbmFsKGMsIHQsIGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFrZV9yZWFsX2NvbmRpdGlvbmFsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY1swXSA9PSBcInVuYXJ5LXByZWZpeFwiICYmIGNbMV0gPT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgPyBbIFwiY29uZGl0aW9uYWxcIiwgY1syXSwgZSwgdCBdIDogWyBcImJpbmFyeVwiLCBcInx8XCIsIGNbMl0sIHQgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlID8gYmVzdF9vZihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIFwiY29uZGl0aW9uYWxcIiwgYywgdCwgZSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgXCJjb25kaXRpb25hbFwiLCBuZWdhdGUoYyksIGUsIHQgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIDogWyBcImJpbmFyeVwiLCBcIiYmXCIsIGMsIHQgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIHNob3J0Y3V0IHRoZSBjb25kaXRpb25hbCBpZiB0aGUgZXhwcmVzc2lvbiBoYXMgYSBjb25zdGFudCB2YWx1ZVxuICAgICAgICAgICAgICAgIHJldHVybiB3aGVuX2NvbnN0YW50KGMsIGZ1bmN0aW9uKGFzdCwgdmFsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5fdW5yZWFjaGFibGUodmFsID8gZSA6IHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICAgICAgICAgICh2YWwgPyB0IDogZSk7XG4gICAgICAgICAgICAgICAgfSwgbWFrZV9yZWFsX2NvbmRpdGlvbmFsKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBybWJsb2NrKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrICE9IG51bGwgJiYgYmxvY2tbMF0gPT0gXCJibG9ja1wiICYmIGJsb2NrWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tbMV0ubGVuZ3RoID09IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gYmxvY2tbMV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChibG9ja1sxXS5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBbIFwiYmxvY2tcIiBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gX2xhbWJkYShuYW1lLCBhcmdzLCBib2R5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgbmFtZSwgYXJncywgdGlnaHRlbihib2R5LCBcImxhbWJkYVwiKSBdO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHRoaXMgZnVuY3Rpb24gZG9lcyBhIGZldyB0aGluZ3M6XG4gICAgICAgIC8vIDEuIGRpc2NhcmQgdXNlbGVzcyBibG9ja3NcbiAgICAgICAgLy8gMi4gam9pbiBjb25zZWN1dGl2ZSB2YXIgZGVjbGFyYXRpb25zXG4gICAgICAgIC8vIDMuIHJlbW92ZSBvYnZpb3VzbHkgZGVhZCBjb2RlXG4gICAgICAgIC8vIDQuIHRyYW5zZm9ybSBjb25zZWN1dGl2ZSBzdGF0ZW1lbnRzIHVzaW5nIHRoZSBjb21tYSBvcGVyYXRvclxuICAgICAgICAvLyA1LiBpZiBibG9ja190eXBlID09IFwibGFtYmRhXCIgYW5kIGl0IGRldGVjdHMgY29uc3RydWN0cyBsaWtlIGlmKGZvbykgcmV0dXJuIC4uLiAtIHJld3JpdGUgbGlrZSBpZiAoIWZvbykgeyAuLi4gfVxuICAgICAgICBmdW5jdGlvbiB0aWdodGVuKHN0YXRlbWVudHMsIGJsb2NrX3R5cGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzID0gTUFQKHN0YXRlbWVudHMsIHdhbGspO1xuXG4gICAgICAgICAgICAgICAgc3RhdGVtZW50cyA9IHN0YXRlbWVudHMucmVkdWNlKGZ1bmN0aW9uKGEsIHN0YXQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRbMF0gPT0gXCJibG9ja1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoLmFwcGx5KGEsIHN0YXRbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzID0gKGZ1bmN0aW9uKGEsIHByZXYpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGN1cil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2ICYmICgoY3VyWzBdID09IFwidmFyXCIgJiYgcHJldlswXSA9PSBcInZhclwiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGN1clswXSA9PSBcImNvbnN0XCIgJiYgcHJldlswXSA9PSBcImNvbnN0XCIpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZbMV0gPSBwcmV2WzFdLmNvbmNhdChjdXJbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChjdXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgfSkoW10pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVhZF9jb2RlKSBzdGF0ZW1lbnRzID0gKGZ1bmN0aW9uKGEsIGhhc19xdWl0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudHMuZm9yRWFjaChmdW5jdGlvbihzdCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNfcXVpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdFswXSA9PSBcImZ1bmN0aW9uXCIgfHwgc3RbMF0gPT0gXCJkZWZ1blwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdFswXSA9PSBcInZhclwiIHx8IHN0WzBdID09IFwiY29uc3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLm5vX3dhcm5pbmdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuKFwiVmFyaWFibGVzIGRlY2xhcmVkIGluIHVucmVhY2hhYmxlIGNvZGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdFsxXSA9IE1BUChzdFsxXSwgZnVuY3Rpb24oZGVmKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZlsxXSAmJiAhb3B0aW9ucy5ub193YXJuaW5ncylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuX3VucmVhY2hhYmxlKFsgXCJhc3NpZ25cIiwgdHJ1ZSwgWyBcIm5hbWVcIiwgZGVmWzBdIF0sIGRlZlsxXSBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgZGVmWzBdIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFvcHRpb25zLm5vX3dhcm5pbmdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Fybl91bnJlYWNoYWJsZShzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyKHN0WzBdLCBbIFwicmV0dXJuXCIsIFwidGhyb3dcIiwgXCJicmVha1wiLCBcImNvbnRpbnVlXCIgXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNfcXVpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgfSkoW10pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubWFrZV9zZXFzKSBzdGF0ZW1lbnRzID0gKGZ1bmN0aW9uKGEsIHByZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudHMuZm9yRWFjaChmdW5jdGlvbihjdXIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldiAmJiBwcmV2WzBdID09IFwic3RhdFwiICYmIGN1clswXSA9PSBcInN0YXRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZbMV0gPSBbIFwic2VxXCIsIHByZXZbMV0sIGN1clsxXSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChjdXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEubGVuZ3RoID49IDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBhW2EubGVuZ3RoLTJdWzBdID09IFwic3RhdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKGFbYS5sZW5ndGgtMV1bMF0gPT0gXCJyZXR1cm5cIiB8fCBhW2EubGVuZ3RoLTFdWzBdID09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBhW2EubGVuZ3RoLTFdWzFdKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnNwbGljZShhLmxlbmd0aCAtIDIsIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgYVthLmxlbmd0aC0xXVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIFwic2VxXCIsIGFbYS5sZW5ndGgtMl1bMV0sIGFbYS5sZW5ndGgtMV1bMV0gXV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgfSkoW10pO1xuXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpbmNyZWFzZXMgalF1ZXJ5IGJ5IDFLLiAgUHJvYmFibHkgbm90IHN1Y2ggYSBnb29kIGlkZWEgYWZ0ZXIgYWxsLi5cbiAgICAgICAgICAgICAgICAvLyBwYXJ0IG9mIHRoaXMgaXMgZG9uZSBpbiBwcmVwYXJlX2lmcyBhbnl3YXkuXG4gICAgICAgICAgICAgICAgLy8gaWYgKGJsb2NrX3R5cGUgPT0gXCJsYW1iZGFcIikgc3RhdGVtZW50cyA9IChmdW5jdGlvbihpLCBhLCBzdGF0KXtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHdoaWxlIChpIDwgc3RhdGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgc3RhdCA9IHN0YXRlbWVudHNbaSsrXTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgaWYgKHN0YXRbMF0gPT0gXCJpZlwiICYmICFzdGF0WzNdKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRbMl1bMF0gPT0gXCJyZXR1cm5cIiAmJiBzdGF0WzJdWzFdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChtYWtlX2lmKG5lZ2F0ZShzdGF0WzFdKSwgWyBcImJsb2NrXCIsIHN0YXRlbWVudHMuc2xpY2UoaSkgXSkpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gbGFzdF9zdGF0KHN0YXRbMl0pO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0WzBdID09IFwicmV0dXJuXCIgJiYgbGFzdFsxXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2gobWFrZV9pZihzdGF0WzFdLCBbIFwiYmxvY2tcIiwgc3RhdFsyXVsxXS5zbGljZSgwLCAtMSkgXSwgWyBcImJsb2NrXCIsIHN0YXRlbWVudHMuc2xpY2UoaSkgXSkpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgIGEucHVzaChzdGF0KTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICAgIC8vIH0pKDAsIFtdKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnRzO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VfaWYoYywgdCwgZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aGVuX2NvbnN0YW50KGMsIGZ1bmN0aW9uKGFzdCwgdmFsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHdhbGsodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5fdW5yZWFjaGFibGUoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0IHx8IFsgXCJibG9ja1wiIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gd2FsayhlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Fybl91bnJlYWNoYWJsZSh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgfHwgWyBcImJsb2NrXCIgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX3JlYWxfaWYoYywgdCwgZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gYWJvcnRfZWxzZShjLCB0LCBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IFsgWyBcImlmXCIsIG5lZ2F0ZShjKSwgZSBdIF07XG4gICAgICAgICAgICAgICAgaWYgKHRbMF0gPT0gXCJibG9ja1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodFsxXSkgcmV0ID0gcmV0LmNvbmNhdCh0WzFdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2godCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3YWxrKFsgXCJibG9ja1wiLCByZXQgXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZV9yZWFsX2lmKGMsIHQsIGUpIHtcbiAgICAgICAgICAgICAgICBjID0gd2FsayhjKTtcbiAgICAgICAgICAgICAgICB0ID0gd2Fsayh0KTtcbiAgICAgICAgICAgICAgICBlID0gd2FsayhlKTtcblxuICAgICAgICAgICAgICAgIGlmIChlbXB0eShlKSAmJiBlbXB0eSh0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIFwic3RhdFwiLCBjIF07XG5cbiAgICAgICAgICAgICAgICBpZiAoZW1wdHkodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBuZWdhdGUoYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW1wdHkoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGJvdGggZWxzZSBhbmQgdGhlbiwgbWF5YmUgaXQgbWFrZXMgc2Vuc2UgdG8gc3dpdGNoIHRoZW0/XG4gICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBnZW5fY29kZShjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBuZWdhdGUoYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gZ2VuX2NvZGUobik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiLmxlbmd0aCA8IGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHRtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IFsgXCJpZlwiLCBjLCB0LCBlIF07XG4gICAgICAgICAgICAgICAgaWYgKHRbMF0gPT0gXCJpZlwiICYmIGVtcHR5KHRbM10pICYmIGVtcHR5KGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBiZXN0X29mKHJldCwgd2FsayhbIFwiaWZcIiwgWyBcImJpbmFyeVwiLCBcIiYmXCIsIGMsIHRbMV0gXSwgdFsyXSBdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRbMF0gPT0gXCJzdGF0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlWzBdID09IFwic3RhdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IGJlc3Rfb2YocmV0LCBbIFwic3RhdFwiLCBtYWtlX2NvbmRpdGlvbmFsKGMsIHRbMV0sIGVbMV0pIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhYm9ydHMoZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gYWJvcnRfZWxzZShjLCB0LCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBiZXN0X29mKHJldCwgWyBcInN0YXRcIiwgbWFrZV9jb25kaXRpb25hbChjLCB0WzFdKSBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZSAmJiB0WzBdID09IGVbMF0gJiYgKHRbMF0gPT0gXCJyZXR1cm5cIiB8fCB0WzBdID09IFwidGhyb3dcIikgJiYgdFsxXSAmJiBlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBiZXN0X29mKHJldCwgWyB0WzBdLCBtYWtlX2NvbmRpdGlvbmFsKGMsIHRbMV0sIGVbMV0gKSBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZSAmJiBhYm9ydHModCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IFsgWyBcImlmXCIsIGMsIHQgXSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVbMF0gPT0gXCJibG9ja1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlWzFdKSByZXQgPSByZXQuY29uY2F0KGVbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gd2FsayhbIFwiYmxvY2tcIiwgcmV0IF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0ICYmIGFib3J0cyhlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gYWJvcnRfZWxzZShjLCB0LCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBfZG9fd2hpbGUoY29uZCwgYm9keSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aGVuX2NvbnN0YW50KGNvbmQsIGZ1bmN0aW9uKGNvbmQsIHZhbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuX3VucmVhY2hhYmxlKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBcImJsb2NrXCIgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIFwiZm9yXCIsIG51bGwsIG51bGwsIG51bGwsIHdhbGsoYm9keSkgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdy53aXRoX3dhbGtlcnMoe1xuICAgICAgICAgICAgICAgIFwic3ViXCI6IGZ1bmN0aW9uKGV4cHIsIHN1YnNjcmlwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnNjcmlwdFswXSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gc3Vic2NyaXB0WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfaWRlbnRpZmllcihuYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBcImRvdFwiLCB3YWxrKGV4cHIpLCBuYW1lIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9eWzEtOV1bMC05XSokLy50ZXN0KG5hbWUpIHx8IG5hbWUgPT09IFwiMFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIFwic3ViXCIsIHdhbGsoZXhwciksIFsgXCJudW1cIiwgcGFyc2VJbnQobmFtZSwgMTApIF0gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiaWZcIjogbWFrZV9pZixcbiAgICAgICAgICAgICAgICBcInRvcGxldmVsXCI6IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIFwidG9wbGV2ZWxcIiwgdGlnaHRlbihib2R5KSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJzd2l0Y2hcIjogZnVuY3Rpb24oZXhwciwgYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3QgPSBib2R5Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBcInN3aXRjaFwiLCB3YWxrKGV4cHIpLCBNQVAoYm9keSwgZnVuY3Rpb24oYnJhbmNoLCBpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gdGlnaHRlbihicmFuY2hbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSBsYXN0ICYmIGJsb2NrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGJsb2NrW2Jsb2NrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlWzBdID09IFwiYnJlYWtcIiAmJiAhbm9kZVsxXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIGJyYW5jaFswXSA/IHdhbGsoYnJhbmNoWzBdKSA6IG51bGwsIGJsb2NrIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiOiBfbGFtYmRhLFxuICAgICAgICAgICAgICAgIFwiZGVmdW5cIjogX2xhbWJkYSxcbiAgICAgICAgICAgICAgICBcImJsb2NrXCI6IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib2R5KSByZXR1cm4gcm1ibG9jayhbIFwiYmxvY2tcIiwgdGlnaHRlbihib2R5KSBdKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYmluYXJ5XCI6IGZ1bmN0aW9uKG9wLCBsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdoZW5fY29uc3RhbnQoWyBcImJpbmFyeVwiLCBvcCwgd2FsayhsZWZ0KSwgd2FsayhyaWdodCkgXSwgZnVuY3Rpb24geWVzKGMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdF9vZih3YWxrKGMpLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIG5vKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihvcCAhPSBcIj09XCIgJiYgb3AgIT0gXCIhPVwiKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSB3YWxrKGxlZnQpLCByID0gd2FsayhyaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobCAmJiBsWzBdID09IFwidW5hcnktcHJlZml4XCIgJiYgbFsxXSA9PSBcIiFcIiAmJiBsWzJdWzBdID09IFwibnVtXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gWydudW0nLCArIWxbMl1bMV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHIgJiYgclswXSA9PSBcInVuYXJ5LXByZWZpeFwiICYmIHJbMV0gPT0gXCIhXCIgJiYgclsyXVswXSA9PSBcIm51bVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBbJ251bScsICshclsyXVsxXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcImJpbmFyeVwiLCBvcCwgbGVmdCwgcmlnaHRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCkgfHwgdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJjb25kaXRpb25hbFwiOiBmdW5jdGlvbihjLCB0LCBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9jb25kaXRpb25hbCh3YWxrKGMpLCB3YWxrKHQpLCB3YWxrKGUpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwidHJ5XCI6IGZ1bmN0aW9uKHQsIGMsIGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidHJ5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpZ2h0ZW4odCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgIT0gbnVsbCA/IFsgY1swXSwgdGlnaHRlbihjWzFdKSBdIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiAhPSBudWxsID8gdGlnaHRlbihmKSA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInVuYXJ5LXByZWZpeFwiOiBmdW5jdGlvbihvcCwgZXhwcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHdhbGsoZXhwcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gWyBcInVuYXJ5LXByZWZpeFwiLCBvcCwgZXhwciBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wID09IFwiIVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBiZXN0X29mKHJldCwgbmVnYXRlKGV4cHIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aGVuX2NvbnN0YW50KHJldCwgZnVuY3Rpb24oYXN0LCB2YWwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2Fsayhhc3QpOyAvLyBpdCdzIGVpdGhlciB0cnVlIG9yIGZhbHNlLCBzbyBtaW5pZmllcyB0byAhMCBvciAhMVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7IHJldHVybiByZXQgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRydWVcIjogcmV0dXJuIFsgXCJ1bmFyeS1wcmVmaXhcIiwgXCIhXCIsIFsgXCJudW1cIiwgMCBdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmFsc2VcIjogcmV0dXJuIFsgXCJ1bmFyeS1wcmVmaXhcIiwgXCIhXCIsIFsgXCJudW1cIiwgMSBdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwid2hpbGVcIjogX2RvX3doaWxlLFxuICAgICAgICAgICAgICAgIFwiYXNzaWduXCI6IGZ1bmN0aW9uKG9wLCBsdmFsdWUsIHJ2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbHZhbHVlID0gd2FsayhsdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnZhbHVlID0gd2FsayhydmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9rT3BzID0gWyAnKycsICctJywgJy8nLCAnKicsICclJywgJz4+JywgJzw8JywgJz4+PicsICd8JywgJ14nLCAnJicgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCA9PT0gdHJ1ZSAmJiBsdmFsdWVbMF0gPT09IFwibmFtZVwiICYmIHJ2YWx1ZVswXSA9PT0gXCJiaW5hcnlcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5va09wcy5pbmRleE9mKHJ2YWx1ZVsxXSkgJiYgcnZhbHVlWzJdWzBdID09PSBcIm5hbWVcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ2YWx1ZVsyXVsxXSA9PT0gbHZhbHVlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHJ2YWx1ZVsxXSwgbHZhbHVlLCBydmFsdWVbM10gXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgb3AsIGx2YWx1ZSwgcnZhbHVlIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImNhbGxcIjogZnVuY3Rpb24oZXhwciwgYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHdhbGsoZXhwcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy51bnNhZmUgJiYgZXhwclswXSA9PSBcImRvdFwiICYmIGV4cHJbMV1bMF0gPT0gXCJzdHJpbmdcIiAmJiBleHByWzJdID09IFwidG9TdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwclsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIGV4cHIsICBNQVAoYXJncywgd2FsaykgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwibnVtXCI6IGZ1bmN0aW9uIChudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUobnVtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgXCJiaW5hcnlcIiwgXCIvXCIsIG51bSA9PT0gMSAvIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbIFwibnVtXCIsIDEgXSA6IG51bSA9PT0gLTEgLyAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gWyBcInVuYXJ5LXByZWZpeFwiLCBcIi1cIiwgWyBcIm51bVwiLCAxIF0gXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFsgXCJudW1cIiwgMCBdLCBbIFwibnVtXCIsIDAgXSBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzWzBdLCBudW0gXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3YWxrKHByZXBhcmVfaWZzKHdhbGsocHJlcGFyZV9pZnMoYXN0KSkpKTtcbiAgICAgICAgfSk7XG59O1xuXG5mdW5jdGlvbiBzcXVlZXplXzIoYXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB3ID0gYXN0X3dhbGtlcigpLCB3YWxrID0gdy53YWxrLCBzY29wZTtcbiAgICAgICAgZnVuY3Rpb24gd2l0aF9zY29wZShzLCBjb250KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNhdmUgPSBzY29wZSwgcmV0O1xuICAgICAgICAgICAgICAgIHNjb3BlID0gcztcbiAgICAgICAgICAgICAgICByZXQgPSBjb250KCk7XG4gICAgICAgICAgICAgICAgc2NvcGUgPSBzYXZlO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGxhbWJkYShuYW1lLCBhcmdzLCBib2R5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgbmFtZSwgYXJncywgd2l0aF9zY29wZShib2R5LnNjb3BlLCBjdXJyeShNQVAsIGJvZHksIHdhbGspKSBdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdy53aXRoX3dhbGtlcnMoe1xuICAgICAgICAgICAgICAgIFwiZGlyZWN0aXZlXCI6IGZ1bmN0aW9uKGRpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlLmFjdGl2ZV9kaXJlY3RpdmUoZGlyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgXCJibG9ja1wiIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5kaXJlY3RpdmVzLnB1c2goZGlyKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwidG9wbGV2ZWxcIjogZnVuY3Rpb24oYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpc1swXSwgd2l0aF9zY29wZSh0aGlzLnNjb3BlLCBjdXJyeShNQVAsIGJvZHksIHdhbGspKSBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiOiBsYW1iZGEsXG4gICAgICAgICAgICAgICAgXCJkZWZ1blwiOiBsYW1iZGFcbiAgICAgICAgfSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2Fsayhhc3RfYWRkX3Njb3BlKGFzdCkpO1xuICAgICAgICB9KTtcbn07XG5cbi8qIC0tLS0tWyByZS1nZW5lcmF0ZSBjb2RlIGZyb20gdGhlIEFTVCBdLS0tLS0gKi9cblxudmFyIERPVF9DQUxMX05PX1BBUkVOUyA9IGpzcC5hcnJheV90b19oYXNoKFtcbiAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgIFwiYXJyYXlcIixcbiAgICAgICAgXCJvYmplY3RcIixcbiAgICAgICAgXCJzdHJpbmdcIixcbiAgICAgICAgXCJkb3RcIixcbiAgICAgICAgXCJzdWJcIixcbiAgICAgICAgXCJjYWxsXCIsXG4gICAgICAgIFwicmVnZXhwXCIsXG4gICAgICAgIFwiZGVmdW5cIlxuXSk7XG5cbmZ1bmN0aW9uIG1ha2Vfc3RyaW5nKHN0ciwgYXNjaWlfb25seSkge1xuICAgICAgICB2YXIgZHEgPSAwLCBzcSA9IDA7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9bXFxcXFxcYlxcZlxcblxcclxcdFxceDIyXFx4MjdcXHUyMDI4XFx1MjAyOVxcMF0vZywgZnVuY3Rpb24ocyl7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6IHJldHVybiBcIlxcXFxcXFxcXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJcXGJcIjogcmV0dXJuIFwiXFxcXGJcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlxcZlwiOiByZXR1cm4gXCJcXFxcZlwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXFxuXCI6IHJldHVybiBcIlxcXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJcXHJcIjogcmV0dXJuIFwiXFxcXHJcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjhcIjogcmV0dXJuIFwiXFxcXHUyMDI4XCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI5XCI6IHJldHVybiBcIlxcXFx1MjAyOVwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdcIic6ICsrZHE7IHJldHVybiAnXCInO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiJ1wiOiArK3NxOyByZXR1cm4gXCInXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJcXDBcIjogcmV0dXJuIFwiXFxcXDBcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYXNjaWlfb25seSkgc3RyID0gdG9fYXNjaWkoc3RyKTtcbiAgICAgICAgaWYgKGRxID4gc3EpIHJldHVybiBcIidcIiArIHN0ci5yZXBsYWNlKC9cXHgyNy9nLCBcIlxcXFwnXCIpICsgXCInXCI7XG4gICAgICAgIGVsc2UgcmV0dXJuICdcIicgKyBzdHIucmVwbGFjZSgvXFx4MjIvZywgJ1xcXFxcIicpICsgJ1wiJztcbn07XG5cbmZ1bmN0aW9uIHRvX2FzY2lpKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXHUwMDgwLVxcdWZmZmZdL2csIGZ1bmN0aW9uKGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29kZS5sZW5ndGggPCA0KSBjb2RlID0gXCIwXCIgKyBjb2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1XCIgKyBjb2RlO1xuICAgICAgICB9KTtcbn07XG5cbnZhciBTUExJQ0VfTkVFRFNfQlJBQ0tFVFMgPSBqc3AuYXJyYXlfdG9faGFzaChbIFwiaWZcIiwgXCJ3aGlsZVwiLCBcImRvXCIsIFwiZm9yXCIsIFwiZm9yLWluXCIsIFwid2l0aFwiIF0pO1xuXG5mdW5jdGlvbiBnZW5fY29kZShhc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBpbmRlbnRfc3RhcnQgOiAwLFxuICAgICAgICAgICAgICAgIGluZGVudF9sZXZlbCA6IDQsXG4gICAgICAgICAgICAgICAgcXVvdGVfa2V5cyAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc3BhY2VfY29sb24gIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgYmVhdXRpZnkgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgYXNjaWlfb25seSAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaW5saW5lX3NjcmlwdDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBiZWF1dGlmeSA9ICEhb3B0aW9ucy5iZWF1dGlmeTtcbiAgICAgICAgdmFyIGluZGVudGF0aW9uID0gMCxcbiAgICAgICAgICAgIG5ld2xpbmUgPSBiZWF1dGlmeSA/IFwiXFxuXCIgOiBcIlwiLFxuICAgICAgICAgICAgc3BhY2UgPSBiZWF1dGlmeSA/IFwiIFwiIDogXCJcIjtcblxuICAgICAgICBmdW5jdGlvbiBlbmNvZGVfc3RyaW5nKHN0cikge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBtYWtlX3N0cmluZyhzdHIsIG9wdGlvbnMuYXNjaWlfb25seSk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW5saW5lX3NjcmlwdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHJldC5yZXBsYWNlKC88XFx4MmZzY3JpcHQoWz5cXC9cXHRcXG5cXGZcXHIgXSkvZ2ksIFwiPFxcXFwvc2NyaXB0JDFcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBtYWtlX25hbWUobmFtZSkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXNjaWlfb25seSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSB0b19hc2NpaShuYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBpbmRlbnQobGluZSkge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAoYmVhdXRpZnkpXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gcmVwZWF0X3N0cmluZyhcIiBcIiwgb3B0aW9ucy5pbmRlbnRfc3RhcnQgKyBpbmRlbnRhdGlvbiAqIG9wdGlvbnMuaW5kZW50X2xldmVsKSArIGxpbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gd2l0aF9pbmRlbnQoY29udCwgaW5jcikge1xuICAgICAgICAgICAgICAgIGlmIChpbmNyID09IG51bGwpIGluY3IgPSAxO1xuICAgICAgICAgICAgICAgIGluZGVudGF0aW9uICs9IGluY3I7XG4gICAgICAgICAgICAgICAgdHJ5IHsgcmV0dXJuIGNvbnQuYXBwbHkobnVsbCwgc2xpY2UoYXJndW1lbnRzLCAxKSk7IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaW5kZW50YXRpb24gLT0gaW5jcjsgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGxhc3RfY2hhcihzdHIpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZmlyc3RfY2hhcihzdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnRvU3RyaW5nKCkuY2hhckF0KDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGFkZF9zcGFjZXMoYSkge1xuICAgICAgICAgICAgICAgIGlmIChiZWF1dGlmeSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmpvaW4oXCIgXCIpO1xuICAgICAgICAgICAgICAgIHZhciBiID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGFbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYi5wdXNoKGFbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGlzX2lkZW50aWZpZXJfY2hhcihsYXN0X2NoYXIoYVtpXSkpICYmIChpc19pZGVudGlmaWVyX2NoYXIoZmlyc3RfY2hhcihuZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBmaXJzdF9jaGFyKG5leHQpID09IFwiXFxcXFwiKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKC9bXFwrXFwtXSQvLnRlc3QoYVtpXS50b1N0cmluZygpKSAmJiAvXltcXCtcXC1dLy50ZXN0KG5leHQudG9TdHJpbmcoKSkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYi5qb2luKFwiXCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGFkZF9jb21tYXMoYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmpvaW4oXCIsXCIgKyBzcGFjZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyZW50aGVzaXplKGV4cHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2VuID0gbWFrZShleHByKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChlbCBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIGVsKGV4cHIpKSB8fCBleHByWzBdID09IGVsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIoXCIgKyBnZW4gKyBcIilcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbjtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBiZXN0X29mKGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoYS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGFbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gYVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA8PSBiLmxlbmd0aCA/IGEgOiBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmVzdF9vZihbIGFbMF0sIGJlc3Rfb2YoYS5zbGljZSgxKSkgXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbmVlZHNfcGFyZW5zKGV4cHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwclswXSA9PSBcImZ1bmN0aW9uXCIgfHwgZXhwclswXSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb3QvY2FsbCBvbiBhIGxpdGVyYWwgZnVuY3Rpb24gcmVxdWlyZXMgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbiBsaXRlcmFsIGl0c2VsZiB0byBiZSBwYXJlbnRoZXNpemVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGlmIGl0J3MgdGhlIGZpcnN0IFwidGhpbmdcIiBpbiBhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGF0ZW1lbnQuICBUaGlzIG1lYW5zIHRoYXQgdGhlIHBhcmVudCBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJzdGF0XCIsIGJ1dCBpdCBjb3VsZCBhbHNvIGJlIGEgXCJzZXFcIiBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIHRoZSBmaXJzdCBpbiB0aGlzIFwic2VxXCIgYW5kIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFyZW50IGlzIFwic3RhdFwiLCBhbmQgc28gb24uICBNZXNzeSBzdHVmZixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBpdCB3b3J0aHMgdGhlIHRyb3VibGUuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHNsaWNlKHcuc3RhY2soKSksIHNlbGYgPSBhLnBvcCgpLCBwID0gYS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwWzBdID09IFwic3RhdFwiKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgocFswXSA9PSBcInNlcVwiIHx8IHBbMF0gPT0gXCJjYWxsXCIgfHwgcFswXSA9PSBcImRvdFwiIHx8IHBbMF0gPT0gXCJzdWJcIiB8fCBwWzBdID09IFwiY29uZGl0aW9uYWxcIikgJiYgcFsxXSA9PT0gc2VsZikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgocFswXSA9PSBcImJpbmFyeVwiIHx8IHBbMF0gPT0gXCJhc3NpZ25cIiB8fCBwWzBdID09IFwidW5hcnktcG9zdGZpeFwiKSAmJiBwWzJdID09PSBzZWxmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBhLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gIUhPUChET1RfQ0FMTF9OT19QQVJFTlMsIGV4cHJbMF0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VfbnVtKG51bSkge1xuICAgICAgICAgICAgICAgIHZhciBzdHIgPSBudW0udG9TdHJpbmcoMTApLCBhID0gWyBzdHIucmVwbGFjZSgvXjBcXC4vLCBcIi5cIikucmVwbGFjZSgnZSsnLCAnZScpIF0sIG07XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguZmxvb3IobnVtKSA9PT0gbnVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKFwiMHhcIiArIG51bS50b1N0cmluZygxNikudG9Mb3dlckNhc2UoKSwgLy8gcHJvYmFibHkgcG9pbnRsZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjBcIiArIG51bS50b1N0cmluZyg4KSk7IC8vIHNhbWUuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goXCItMHhcIiArICgtbnVtKS50b1N0cmluZygxNikudG9Mb3dlckNhc2UoKSwgLy8gcHJvYmFibHkgcG9pbnRsZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi0wXCIgKyAoLW51bSkudG9TdHJpbmcoOCkpOyAvLyBzYW1lLlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtID0gL14oLio/KSgwKykkLy5leGVjKG51bSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChtWzFdICsgXCJlXCIgKyBtWzJdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgobSA9IC9eMD9cXC4oMCspKC4qKSQvLmV4ZWMobnVtKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChtWzJdICsgXCJlLVwiICsgKG1bMV0ubGVuZ3RoICsgbVsyXS5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ci5zdWJzdHIoc3RyLmluZGV4T2YoXCIuXCIpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiZXN0X29mKGEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB3ID0gYXN0X3dhbGtlcigpO1xuICAgICAgICB2YXIgbWFrZSA9IHcud2FsaztcbiAgICAgICAgcmV0dXJuIHcud2l0aF93YWxrZXJzKHtcbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiOiBlbmNvZGVfc3RyaW5nLFxuICAgICAgICAgICAgICAgIFwibnVtXCI6IG1ha2VfbnVtLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBtYWtlX25hbWUsXG4gICAgICAgICAgICAgICAgXCJkZWJ1Z2dlclwiOiBmdW5jdGlvbigpeyByZXR1cm4gXCJkZWJ1Z2dlcjtcIiB9LFxuICAgICAgICAgICAgICAgIFwidG9wbGV2ZWxcIjogZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VfYmxvY2tfc3RhdGVtZW50cyhzdGF0ZW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuam9pbihuZXdsaW5lICsgbmV3bGluZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInNwbGljZVwiOiBmdW5jdGlvbihzdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdy5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChIT1AoU1BMSUNFX05FRURTX0JSQUNLRVRTLCBwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgYmxvY2sgYnJhY2tldHMgaW4gdGhpcyBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX2Jsb2NrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTUFQKG1ha2VfYmxvY2tfc3RhdGVtZW50cyhzdGF0ZW1lbnRzLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihsaW5lLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZmlyc3QgbGluZSBpcyBhbHJlYWR5IGluZGVudGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSA+IDAgPyBpbmRlbnQobGluZSkgOiBsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmpvaW4obmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImJsb2NrXCI6IG1ha2VfYmxvY2ssXG4gICAgICAgICAgICAgICAgXCJ2YXJcIjogZnVuY3Rpb24oZGVmcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidmFyIFwiICsgYWRkX2NvbW1hcyhNQVAoZGVmcywgbWFrZV8xdmFyZGVmKSkgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiY29uc3RcIjogZnVuY3Rpb24oZGVmcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29uc3QgXCIgKyBhZGRfY29tbWFzKE1BUChkZWZzLCBtYWtlXzF2YXJkZWYpKSArIFwiO1wiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ0cnlcIjogZnVuY3Rpb24odHIsIGNhLCBmaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9IFsgXCJ0cnlcIiwgbWFrZV9ibG9jayh0cikgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYSkgb3V0LnB1c2goXCJjYXRjaFwiLCBcIihcIiArIGNhWzBdICsgXCIpXCIsIG1ha2VfYmxvY2soY2FbMV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaSkgb3V0LnB1c2goXCJmaW5hbGx5XCIsIG1ha2VfYmxvY2soZmkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRfc3BhY2VzKG91dCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInRocm93XCI6IGZ1bmN0aW9uKGV4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRfc3BhY2VzKFsgXCJ0aHJvd1wiLCBtYWtlKGV4cHIpIF0pICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIm5ld1wiOiBmdW5jdGlvbihjdG9yLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJncy5sZW5ndGggPiAwID8gXCIoXCIgKyBhZGRfY29tbWFzKE1BUChhcmdzLCBmdW5jdGlvbihleHByKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShleHByLCBcInNlcVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSArIFwiKVwiIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRfc3BhY2VzKFsgXCJuZXdcIiwgcGFyZW50aGVzaXplKGN0b3IsIFwic2VxXCIsIFwiYmluYXJ5XCIsIFwiY29uZGl0aW9uYWxcIiwgXCJhc3NpZ25cIiwgZnVuY3Rpb24oZXhwcil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ID0gYXN0X3dhbGtlcigpLCBoYXNfY2FsbCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcud2l0aF93YWxrZXJzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY2FsbFwiOiBmdW5jdGlvbigpIHsgdGhyb3cgaGFzX2NhbGwgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdy53YWxrKGV4cHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4ID09PSBoYXNfY2FsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSArIGFyZ3MgXSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInN3aXRjaFwiOiBmdW5jdGlvbihleHByLCBib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkX3NwYWNlcyhbIFwic3dpdGNoXCIsIFwiKFwiICsgbWFrZShleHByKSArIFwiKVwiLCBtYWtlX3N3aXRjaF9ibG9jayhib2R5KSBdKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYnJlYWtcIjogZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXQgPSBcImJyZWFrXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWwgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiIFwiICsgbWFrZV9uYW1lKGxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiY29udGludWVcIjogZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXQgPSBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWwgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiIFwiICsgbWFrZV9uYW1lKGxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiY29uZGl0aW9uYWxcIjogZnVuY3Rpb24oY28sIHRoLCBlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZF9zcGFjZXMoWyBwYXJlbnRoZXNpemUoY28sIFwiYXNzaWduXCIsIFwic2VxXCIsIFwiY29uZGl0aW9uYWxcIiksIFwiP1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRoZXNpemUodGgsIFwic2VxXCIpLCBcIjpcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50aGVzaXplKGVsLCBcInNlcVwiKSBdKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYXNzaWduXCI6IGZ1bmN0aW9uKG9wLCBsdmFsdWUsIHJ2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wICYmIG9wICE9PSB0cnVlKSBvcCArPSBcIj1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Ugb3AgPSBcIj1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRfc3BhY2VzKFsgbWFrZShsdmFsdWUpLCBvcCwgcGFyZW50aGVzaXplKHJ2YWx1ZSwgXCJzZXFcIikgXSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImRvdFwiOiBmdW5jdGlvbihleHByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0gbWFrZShleHByKSwgaSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwclswXSA9PSBcIm51bVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghL1thLWYuXS9pLnRlc3Qob3V0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCIuXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHJbMF0gIT0gXCJmdW5jdGlvblwiICYmIG5lZWRzX3BhcmVucyhleHByKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ID0gXCIoXCIgKyBvdXQgKyBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiLlwiICsgbWFrZV9uYW1lKGFyZ3VtZW50c1tpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImNhbGxcIjogZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBtYWtlKGZ1bmMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYuY2hhckF0KDApICE9IFwiKFwiICYmIG5lZWRzX3BhcmVucyhmdW5jKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IFwiKFwiICsgZiArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGYgKyBcIihcIiArIGFkZF9jb21tYXMoTUFQKGFyZ3MsIGZ1bmN0aW9uKGV4cHIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKGV4cHIsIFwic2VxXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCI6IG1ha2VfZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgXCJkZWZ1blwiOiBtYWtlX2Z1bmN0aW9uLFxuICAgICAgICAgICAgICAgIFwiaWZcIjogZnVuY3Rpb24oY28sIHRoLCBlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9IFsgXCJpZlwiLCBcIihcIiArIG1ha2UoY28pICsgXCIpXCIsIGVsID8gbWFrZV90aGVuKHRoKSA6IG1ha2UodGgpIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goXCJlbHNlXCIsIG1ha2UoZWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRfc3BhY2VzKG91dCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImZvclwiOiBmdW5jdGlvbihpbml0LCBjb25kLCBzdGVwLCBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9IFsgXCJmb3JcIiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IChpbml0ICE9IG51bGwgPyBtYWtlKGluaXQpIDogXCJcIikucmVwbGFjZSgvOypcXHMqJC8sIFwiO1wiICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZCA9IChjb25kICE9IG51bGwgPyBtYWtlKGNvbmQpIDogXCJcIikucmVwbGFjZSgvOypcXHMqJC8sIFwiO1wiICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcCA9IChzdGVwICE9IG51bGwgPyBtYWtlKHN0ZXApIDogXCJcIikucmVwbGFjZSgvOypcXHMqJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBpbml0ICsgY29uZCArIHN0ZXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncyA9PSBcIjsgOyBcIikgYXJncyA9IFwiOztcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKFwiKFwiICsgYXJncyArIFwiKVwiLCBtYWtlKGJsb2NrKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkX3NwYWNlcyhvdXQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJmb3ItaW5cIjogZnVuY3Rpb24odnZhciwga2V5LCBoYXNoLCBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZF9zcGFjZXMoWyBcImZvclwiLCBcIihcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh2dmFyID8gbWFrZSh2dmFyKS5yZXBsYWNlKC87KyQvLCBcIlwiKSA6IG1ha2Uoa2V5KSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZShoYXNoKSArIFwiKVwiLCBtYWtlKGJsb2NrKSBdKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwid2hpbGVcIjogZnVuY3Rpb24oY29uZGl0aW9uLCBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZF9zcGFjZXMoWyBcIndoaWxlXCIsIFwiKFwiICsgbWFrZShjb25kaXRpb24pICsgXCIpXCIsIG1ha2UoYmxvY2spIF0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJkb1wiOiBmdW5jdGlvbihjb25kaXRpb24sIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkX3NwYWNlcyhbIFwiZG9cIiwgbWFrZShibG9jayksIFwid2hpbGVcIiwgXCIoXCIgKyBtYWtlKGNvbmRpdGlvbikgKyBcIilcIiBdKSArIFwiO1wiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJyZXR1cm5cIjogZnVuY3Rpb24oZXhwcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9IFsgXCJyZXR1cm5cIiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHIgIT0gbnVsbCkgb3V0LnB1c2gobWFrZShleHByKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkX3NwYWNlcyhvdXQpICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImJpbmFyeVwiOiBmdW5jdGlvbihvcGVyYXRvciwgbHZhbHVlLCBydmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gbWFrZShsdmFsdWUpLCByaWdodCA9IG1ha2UocnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFhYWDogSSdtIHByZXR0eSBzdXJlIG90aGVyIGNhc2VzIHdpbGwgYml0ZSBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICB3ZSBuZWVkIHRvIGJlIHNtYXJ0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgIGFkZGluZyBwYXJlbnMgYWxsIHRoZSB0aW1lIGlzIHRoZSBzYWZlc3QgYmV0LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlcihsdmFsdWVbMF0sIFsgXCJhc3NpZ25cIiwgXCJjb25kaXRpb25hbFwiLCBcInNlcVwiIF0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbHZhbHVlWzBdID09IFwiYmluYXJ5XCIgJiYgUFJFQ0VERU5DRVtvcGVyYXRvcl0gPiBQUkVDRURFTkNFW2x2YWx1ZVsxXV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsdmFsdWVbMF0gPT0gXCJmdW5jdGlvblwiICYmIG5lZWRzX3BhcmVucyh0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gXCIoXCIgKyBsZWZ0ICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyKHJ2YWx1ZVswXSwgWyBcImFzc2lnblwiLCBcImNvbmRpdGlvbmFsXCIsIFwic2VxXCIgXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydmFsdWVbMF0gPT0gXCJiaW5hcnlcIiAmJiBQUkVDRURFTkNFW29wZXJhdG9yXSA+PSBQUkVDRURFTkNFW3J2YWx1ZVsxXV0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKHJ2YWx1ZVsxXSA9PSBvcGVyYXRvciAmJiBtZW1iZXIob3BlcmF0b3IsIFsgXCImJlwiLCBcInx8XCIsIFwiKlwiIF0pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IFwiKFwiICsgcmlnaHQgKyBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFiZWF1dGlmeSAmJiBvcHRpb25zLmlubGluZV9zY3JpcHQgJiYgKG9wZXJhdG9yID09IFwiPFwiIHx8IG9wZXJhdG9yID09IFwiPDxcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHJ2YWx1ZVswXSA9PSBcInJlZ2V4cFwiICYmIC9ec2NyaXB0L2kudGVzdChydmFsdWVbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gXCIgXCIgKyByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRfc3BhY2VzKFsgbGVmdCwgb3BlcmF0b3IsIHJpZ2h0IF0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ1bmFyeS1wcmVmaXhcIjogZnVuY3Rpb24ob3BlcmF0b3IsIGV4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBtYWtlKGV4cHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZXhwclswXSA9PSBcIm51bVwiIHx8IChleHByWzBdID09IFwidW5hcnktcHJlZml4XCIgJiYgIUhPUChPUEVSQVRPUlMsIG9wZXJhdG9yICsgZXhwclsxXSkpIHx8ICFuZWVkc19wYXJlbnMoZXhwcikpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBcIihcIiArIHZhbCArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yICsgKGpzcC5pc19hbHBoYW51bWVyaWNfY2hhcihvcGVyYXRvci5jaGFyQXQoMCkpID8gXCIgXCIgOiBcIlwiKSArIHZhbDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwidW5hcnktcG9zdGZpeFwiOiBmdW5jdGlvbihvcGVyYXRvciwgZXhwcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IG1ha2UoZXhwcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShleHByWzBdID09IFwibnVtXCIgfHwgKGV4cHJbMF0gPT0gXCJ1bmFyeS1wb3N0Zml4XCIgJiYgIUhPUChPUEVSQVRPUlMsIG9wZXJhdG9yICsgZXhwclsxXSkpIHx8ICFuZWVkc19wYXJlbnMoZXhwcikpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBcIihcIiArIHZhbCArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbCArIG9wZXJhdG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJzdWJcIjogZnVuY3Rpb24oZXhwciwgc3Vic2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IG1ha2UoZXhwcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVlZHNfcGFyZW5zKGV4cHIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoID0gXCIoXCIgKyBoYXNoICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzaCArIFwiW1wiICsgbWFrZShzdWJzY3JpcHQpICsgXCJdXCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiOiBmdW5jdGlvbihwcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9ial9uZWVkc19wYXJlbnMgPSBuZWVkc19wYXJlbnModGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmpfbmVlZHNfcGFyZW5zID8gXCIoe30pXCIgOiBcInt9XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0gXCJ7XCIgKyBuZXdsaW5lICsgd2l0aF9pbmRlbnQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1BUChwcm9wcywgZnVuY3Rpb24ocCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAubGVuZ3RoID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldHRlci9zZXR0ZXIuICBUaGUgbmFtZSBpcyBpbiBwWzBdLCB0aGUgYXJnLmxpc3QgaW4gcFsxXVsyXSwgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBib2R5IGluIHBbMV1bM10gYW5kIHR5cGUgKFwiZ2V0XCIgLyBcInNldFwiKSBpbiBwWzJdLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGVudChtYWtlX2Z1bmN0aW9uKHBbMF0sIHBbMV1bMl0sIHBbMV1bM10sIHBbMl0sIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHBbMF0sIHZhbCA9IHBhcmVudGhlc2l6ZShwWzFdLCBcInNlcVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5xdW90ZV9rZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBlbmNvZGVfc3RyaW5nKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgodHlwZW9mIGtleSA9PSBcIm51bWJlclwiIHx8ICFiZWF1dGlmeSAmJiAra2V5ICsgXCJcIiA9PSBrZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBwYXJzZUZsb2F0KGtleSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gbWFrZV9udW0oK2tleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXNfaWRlbnRpZmllcihrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBlbmNvZGVfc3RyaW5nKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRlbnQoYWRkX3NwYWNlcyhiZWF1dGlmeSAmJiBvcHRpb25zLnNwYWNlX2NvbG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gWyBrZXksIFwiOlwiLCB2YWwgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFsga2V5ICsgXCI6XCIsIHZhbCBdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oXCIsXCIgKyBuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pICsgbmV3bGluZSArIGluZGVudChcIn1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqX25lZWRzX3BhcmVucyA/IFwiKFwiICsgb3V0ICsgXCIpXCIgOiBvdXQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInJlZ2V4cFwiOiBmdW5jdGlvbihyeCwgbW9kcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXNjaWlfb25seSkgcnggPSB0b19hc2NpaShyeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIvXCIgKyByeCArIFwiL1wiICsgbW9kcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT0gMCkgcmV0dXJuIFwiW11cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRfc3BhY2VzKFsgXCJbXCIsIGFkZF9jb21tYXMoTUFQKGVsZW1lbnRzLCBmdW5jdGlvbihlbCwgaSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmVhdXRpZnkgJiYgZWxbMF0gPT0gXCJhdG9tXCIgJiYgZWxbMV0gPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGkgPT09IGVsZW1lbnRzLmxlbmd0aCAtIDEgPyBcIixcIiA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUoZWwsIFwic2VxXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpLCBcIl1cIiBdKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwic3RhdFwiOiBmdW5jdGlvbihzdG10KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RtdCAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbWFrZShzdG10KS5yZXBsYWNlKC87KlxccyokLywgXCI7XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCI7XCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInNlcVwiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRfY29tbWFzKE1BUChzbGljZShhcmd1bWVudHMpLCBtYWtlKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImxhYmVsXCI6IGZ1bmN0aW9uKG5hbWUsIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkX3NwYWNlcyhbIG1ha2VfbmFtZShuYW1lKSwgXCI6XCIsIG1ha2UoYmxvY2spIF0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ3aXRoXCI6IGZ1bmN0aW9uKGV4cHIsIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkX3NwYWNlcyhbIFwid2l0aFwiLCBcIihcIiArIG1ha2UoZXhwcikgKyBcIilcIiwgbWFrZShibG9jaykgXSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImF0b21cIjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VfbmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZGlyZWN0aXZlXCI6IGZ1bmN0aW9uKGRpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfc3RyaW5nKGRpcikgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKCl7IHJldHVybiBtYWtlKGFzdCkgfSk7XG5cbiAgICAgICAgLy8gVGhlIHNxdWVlemVyIHJlcGxhY2VzIFwiYmxvY2tcIi1zIHRoYXQgY29udGFpbiBvbmx5IGEgc2luZ2xlXG4gICAgICAgIC8vIHN0YXRlbWVudCB3aXRoIHRoZSBzdGF0ZW1lbnQgaXRzZWxmOyB0ZWNobmljYWxseSwgdGhlIEFTVFxuICAgICAgICAvLyBpcyBjb3JyZWN0LCBidXQgdGhpcyBjYW4gY3JlYXRlIHByb2JsZW1zIHdoZW4gd2Ugb3V0cHV0IGFuXG4gICAgICAgIC8vIElGIGhhdmluZyBhbiBFTFNFIGNsYXVzZSB3aGVyZSB0aGUgVEhFTiBjbGF1c2UgZW5kcyBpbiBhblxuICAgICAgICAvLyBJRiAqd2l0aG91dCogYW4gRUxTRSBibG9jayAodGhlbiB0aGUgb3V0ZXIgRUxTRSB3b3VsZCByZWZlclxuICAgICAgICAvLyB0byB0aGUgaW5uZXIgSUYpLiAgVGhpcyBmdW5jdGlvbiBjaGVja3MgZm9yIHRoaXMgY2FzZSBhbmRcbiAgICAgICAgLy8gYWRkcyB0aGUgYmxvY2sgYnJhY2tldHMgaWYgbmVlZGVkLlxuICAgICAgICBmdW5jdGlvbiBtYWtlX3RoZW4odGgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGggPT0gbnVsbCkgcmV0dXJuIFwiO1wiO1xuICAgICAgICAgICAgICAgIGlmICh0aFswXSA9PSBcImRvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMvaXNzdWVzLyNpc3N1ZS81N1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUUgY3JvYWtzIHdpdGggXCJzeW50YXggZXJyb3JcIiBvbiBjb2RlIGxpa2UgdGhpczpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBpZiAoZm9vKSBkbyAuLi4gd2hpbGUoY29uZCk7IGVsc2UgLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIGJsb2NrIGJyYWNrZXRzIGFyb3VuZCBkby93aGlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VfYmxvY2soWyB0aCBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGIgPSB0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBiWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gXCJpZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYlszXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBlbHNlLCB3ZSBtdXN0IGFkZCB0aGUgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZShbIFwiYmxvY2tcIiwgWyB0aCBdXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBiWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBcIndoaWxlXCIgfHwgdHlwZSA9PSBcImRvXCIpIGIgPSBiWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBcImZvclwiIHx8IHR5cGUgPT0gXCJmb3ItaW5cIikgYiA9IGJbNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZSh0aCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZV9mdW5jdGlvbihuYW1lLCBhcmdzLCBib2R5LCBrZXl3b3JkLCBub19wYXJlbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0ID0ga2V5d29yZCB8fCBcImZ1bmN0aW9uXCI7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSBcIiBcIiArIG1ha2VfbmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0ICs9IFwiKFwiICsgYWRkX2NvbW1hcyhNQVAoYXJncywgbWFrZV9uYW1lKSkgKyBcIilcIjtcbiAgICAgICAgICAgICAgICBvdXQgPSBhZGRfc3BhY2VzKFsgb3V0LCBtYWtlX2Jsb2NrKGJvZHkpIF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAoIW5vX3BhcmVucyAmJiBuZWVkc19wYXJlbnModGhpcykpID8gXCIoXCIgKyBvdXQgKyBcIilcIiA6IG91dDtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBtdXN0X2hhc19zZW1pY29sb24obm9kZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobm9kZVswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwid2l0aFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwid2hpbGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eShub2RlWzJdKSB8fCBtdXN0X2hhc19zZW1pY29sb24obm9kZVsyXSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZvci1pblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5KG5vZGVbNF0pIHx8IG11c3RfaGFzX3NlbWljb2xvbihub2RlWzRdKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlmXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW1wdHkobm9kZVsyXSkgJiYgIW5vZGVbM10pIHJldHVybiB0cnVlOyAvLyBgaWYnIHdpdGggZW1wdHkgYHRoZW4nIGFuZCBubyBgZWxzZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlWzNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbXB0eShub2RlWzNdKSkgcmV0dXJuIHRydWU7IC8vIGBlbHNlJyBwcmVzZW50IGJ1dCBlbXB0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXVzdF9oYXNfc2VtaWNvbG9uKG5vZGVbM10pOyAvLyBkaXZlIGludG8gdGhlIGBlbHNlJyBicmFuY2hcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtdXN0X2hhc19zZW1pY29sb24obm9kZVsyXSk7IC8vIGRpdmUgaW50byB0aGUgYHRoZW4nIGJyYW5jaFxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGlyZWN0aXZlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZV9ibG9ja19zdGF0ZW1lbnRzKHN0YXRlbWVudHMsIG5vaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IFtdLCBsYXN0ID0gc3RhdGVtZW50cy5sZW5ndGggLSAxLCBpID0gMDsgaSA8PSBsYXN0OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ID0gc3RhdGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2RlID0gbWFrZShzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9IFwiO1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmVhdXRpZnkgJiYgaSA9PSBsYXN0ICYmICFtdXN0X2hhc19zZW1pY29sb24oc3RhdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKC87K1xccyokLywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9pbmRlbnQgPyBhIDogTUFQKGEsIGluZGVudCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZV9zd2l0Y2hfYmxvY2soYm9keSkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gYm9keS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG4gPT0gMCkgcmV0dXJuIFwie31cIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ7XCIgKyBuZXdsaW5lICsgTUFQKGJvZHksIGZ1bmN0aW9uKGJyYW5jaCwgaSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzX2JvZHkgPSBicmFuY2hbMV0ubGVuZ3RoID4gMCwgY29kZSA9IHdpdGhfaW5kZW50KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRlbnQoYnJhbmNoWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhZGRfc3BhY2VzKFsgXCJjYXNlXCIsIG1ha2UoYnJhbmNoWzBdKSArIFwiOlwiIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcImRlZmF1bHQ6XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMC41KSArIChoYXNfYm9keSA/IG5ld2xpbmUgKyB3aXRoX2luZGVudChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ibG9ja19zdGF0ZW1lbnRzKGJyYW5jaFsxXSkuam9pbihuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIDogXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJlYXV0aWZ5ICYmIGhhc19ib2R5ICYmIGkgPCBuIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSArPSBcIjtcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4obmV3bGluZSkgKyBuZXdsaW5lICsgaW5kZW50KFwifVwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBtYWtlX2Jsb2NrKHN0YXRlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlbWVudHMpIHJldHVybiBcIjtcIjtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVtZW50cy5sZW5ndGggPT0gMCkgcmV0dXJuIFwie31cIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ7XCIgKyBuZXdsaW5lICsgd2l0aF9pbmRlbnQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX2Jsb2NrX3N0YXRlbWVudHMoc3RhdGVtZW50cykuam9pbihuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICB9KSArIG5ld2xpbmUgKyBpbmRlbnQoXCJ9XCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VfMXZhcmRlZihkZWYpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGRlZlswXSwgdmFsID0gZGVmWzFdO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBhZGRfc3BhY2VzKFsgbWFrZV9uYW1lKG5hbWUpLCBcIj1cIiwgcGFyZW50aGVzaXplKHZhbCwgXCJzZXFcIikgXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH07XG5cbn07XG5cbmZ1bmN0aW9uIHNwbGl0X2xpbmVzKGNvZGUsIG1heF9saW5lX2xlbmd0aCkge1xuICAgICAgICB2YXIgc3BsaXRzID0gWyAwIF07XG4gICAgICAgIGpzcC5wYXJzZShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHZhciBuZXh0X3Rva2VuID0ganNwLnRva2VuaXplcihjb2RlKTtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdF9zcGxpdCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZfdG9rZW47XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY3VycmVudF9sZW5ndGgodG9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rLnBvcyAtIGxhc3Rfc3BsaXQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzcGxpdF9oZXJlKHRvaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9zcGxpdCA9IHRvay5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpdHMucHVzaChsYXN0X3NwbGl0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGN1c3RvbSgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvayA9IG5leHRfdG9rZW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldl90b2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2X3Rva2VuLnR5cGUgPT0gXCJrZXl3b3JkXCIpIGJyZWFrIG91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudF9sZW5ndGgodG9rKSA+IG1heF9saW5lX2xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodG9rLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImtleXdvcmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImF0b21cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInB1bmNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0X2hlcmUodG9rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZfdG9rZW4gPSB0b2s7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY3VzdG9tLmNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0X3Rva2VuLmNvbnRleHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXN0b207XG4gICAgICAgIH0oKSk7XG4gICAgICAgIHJldHVybiBzcGxpdHMubWFwKGZ1bmN0aW9uKHBvcywgaSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGUuc3Vic3RyaW5nKHBvcywgc3BsaXRzW2kgKyAxXSB8fCBjb2RlLmxlbmd0aCk7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG59O1xuXG4vKiAtLS0tLVsgVXRpbGl0aWVzIF0tLS0tLSAqL1xuXG5mdW5jdGlvbiByZXBlYXRfc3RyaW5nKHN0ciwgaSkge1xuICAgICAgICBpZiAoaSA8PSAwKSByZXR1cm4gXCJcIjtcbiAgICAgICAgaWYgKGkgPT0gMSkgcmV0dXJuIHN0cjtcbiAgICAgICAgdmFyIGQgPSByZXBlYXRfc3RyaW5nKHN0ciwgaSA+PiAxKTtcbiAgICAgICAgZCArPSBkO1xuICAgICAgICBpZiAoaSAmIDEpIGQgKz0gc3RyO1xuICAgICAgICByZXR1cm4gZDtcbn07XG5cbmZ1bmN0aW9uIGRlZmF1bHRzKGFyZ3MsIGRlZnMpIHtcbiAgICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgICBpZiAoYXJncyA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBhcmdzID0ge307XG4gICAgICAgIGZvciAodmFyIGkgaW4gZGVmcykgaWYgKEhPUChkZWZzLCBpKSkge1xuICAgICAgICAgICAgICAgIHJldFtpXSA9IChhcmdzICYmIEhPUChhcmdzLCBpKSkgPyBhcmdzW2ldIDogZGVmc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gaXNfaWRlbnRpZmllcihuYW1lKSB7XG4gICAgICAgIHJldHVybiAvXlthLXpfJF1bYS16MC05XyRdKiQvaS50ZXN0KG5hbWUpXG4gICAgICAgICAgICAgICAgJiYgbmFtZSAhPSBcInRoaXNcIlxuICAgICAgICAgICAgICAgICYmICFIT1AoanNwLktFWVdPUkRTX0FUT00sIG5hbWUpXG4gICAgICAgICAgICAgICAgJiYgIUhPUChqc3AuUkVTRVJWRURfV09SRFMsIG5hbWUpXG4gICAgICAgICAgICAgICAgJiYgIUhPUChqc3AuS0VZV09SRFMsIG5hbWUpO1xufTtcblxuZnVuY3Rpb24gSE9QKG9iaiwgcHJvcCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59O1xuXG4vLyBzb21lIHV0aWxpdGllc1xuXG52YXIgTUFQO1xuXG4oZnVuY3Rpb24oKXtcbiAgICAgICAgTUFQID0gZnVuY3Rpb24oYSwgZiwgbykge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBbXSwgdG9wID0gW10sIGk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZG9pdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBmLmNhbGwobywgYVtpXSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgQXRUb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsLnY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBTcGxpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3AucHVzaC5hcHBseSh0b3AsIHZhbC52KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3AucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwgIT0gc2tpcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgU3BsaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2guYXBwbHkocmV0LCB2YWwudik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBBcnJheSkgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIGRvaXQoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGZvciAoaSBpbiBhKSBpZiAoSE9QKGEsIGkpKSBkb2l0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvcC5jb25jYXQocmV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgTUFQLmF0X3RvcCA9IGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gbmV3IEF0VG9wKHZhbCkgfTtcbiAgICAgICAgTUFQLnNwbGljZSA9IGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gbmV3IFNwbGljZSh2YWwpIH07XG4gICAgICAgIHZhciBza2lwID0gTUFQLnNraXAgPSB7fTtcbiAgICAgICAgZnVuY3Rpb24gQXRUb3AodmFsKSB7IHRoaXMudiA9IHZhbCB9O1xuICAgICAgICBmdW5jdGlvbiBTcGxpY2UodmFsKSB7IHRoaXMudiA9IHZhbCB9O1xufSkoKTtcblxuLyogLS0tLS1bIEV4cG9ydHMgXS0tLS0tICovXG5cbmV4cG9ydHMuYXN0X3dhbGtlciA9IGFzdF93YWxrZXI7XG5leHBvcnRzLmFzdF9tYW5nbGUgPSBhc3RfbWFuZ2xlO1xuZXhwb3J0cy5hc3Rfc3F1ZWV6ZSA9IGFzdF9zcXVlZXplO1xuZXhwb3J0cy5hc3RfbGlmdF92YXJpYWJsZXMgPSBhc3RfbGlmdF92YXJpYWJsZXM7XG5leHBvcnRzLmdlbl9jb2RlID0gZ2VuX2NvZGU7XG5leHBvcnRzLmFzdF9hZGRfc2NvcGUgPSBhc3RfYWRkX3Njb3BlO1xuZXhwb3J0cy5zZXRfbG9nZ2VyID0gZnVuY3Rpb24obG9nZ2VyKSB7IHdhcm4gPSBsb2dnZXIgfTtcbmV4cG9ydHMubWFrZV9zdHJpbmcgPSBtYWtlX3N0cmluZztcbmV4cG9ydHMuc3BsaXRfbGluZXMgPSBzcGxpdF9saW5lcztcbmV4cG9ydHMuTUFQID0gTUFQO1xuXG4vLyBrZWVwIHRoaXMgbGFzdCFcbmV4cG9ydHMuYXN0X3NxdWVlemVfbW9yZSA9IHJlcXVpcmUoXCIuL3NxdWVlemUtbW9yZVwiKS5hc3Rfc3F1ZWV6ZV9tb3JlO1xuXG4vLyBMb2NhbCB2YXJpYWJsZXM6XG4vLyBqcy1pbmRlbnQtbGV2ZWw6IDhcbi8vIEVuZDpcbiIsInZhciBqc3AgPSByZXF1aXJlKFwiLi9wYXJzZS1qc1wiKSxcbiAgICBwcm8gPSByZXF1aXJlKFwiLi9wcm9jZXNzXCIpLFxuICAgIHNsaWNlID0ganNwLnNsaWNlLFxuICAgIG1lbWJlciA9IGpzcC5tZW1iZXIsXG4gICAgY3VycnkgPSBqc3AuY3VycnksXG4gICAgTUFQID0gcHJvLk1BUCxcbiAgICBQUkVDRURFTkNFID0ganNwLlBSRUNFREVOQ0UsXG4gICAgT1BFUkFUT1JTID0ganNwLk9QRVJBVE9SUztcblxuZnVuY3Rpb24gYXN0X3NxdWVlemVfbW9yZShhc3QpIHtcbiAgICAgICAgdmFyIHcgPSBwcm8uYXN0X3dhbGtlcigpLCB3YWxrID0gdy53YWxrLCBzY29wZTtcbiAgICAgICAgZnVuY3Rpb24gd2l0aF9zY29wZShzLCBjb250KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNhdmUgPSBzY29wZSwgcmV0O1xuICAgICAgICAgICAgICAgIHNjb3BlID0gcztcbiAgICAgICAgICAgICAgICByZXQgPSBjb250KCk7XG4gICAgICAgICAgICAgICAgc2NvcGUgPSBzYXZlO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIF9sYW1iZGEobmFtZSwgYXJncywgYm9keSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIG5hbWUsIGFyZ3MsIHdpdGhfc2NvcGUoYm9keS5zY29wZSwgY3VycnkoTUFQLCBib2R5LCB3YWxrKSkgXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHcud2l0aF93YWxrZXJzKHtcbiAgICAgICAgICAgICAgICBcInRvcGxldmVsXCI6IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHRoaXNbMF0sIHdpdGhfc2NvcGUodGhpcy5zY29wZSwgY3VycnkoTUFQLCBib2R5LCB3YWxrKSkgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIjogX2xhbWJkYSxcbiAgICAgICAgICAgICAgICBcImRlZnVuXCI6IF9sYW1iZGEsXG4gICAgICAgICAgICAgICAgXCJuZXdcIjogZnVuY3Rpb24oY3RvciwgYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0b3JbMF0gPT0gXCJuYW1lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0b3JbMV0gPT0gXCJBcnJheVwiICYmICFzY29wZS5oYXMoXCJBcnJheVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBcImFycmF5XCIsIGFyZ3MgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGsoWyBcImNhbGxcIiwgWyBcIm5hbWVcIiwgXCJBcnJheVwiIF0sIGFyZ3MgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN0b3JbMV0gPT0gXCJPYmplY3RcIiAmJiAhc2NvcGUuaGFzKFwiT2JqZWN0XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgXCJvYmplY3RcIiwgW10gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGsoWyBcImNhbGxcIiwgWyBcIm5hbWVcIiwgXCJPYmplY3RcIiBdLCBhcmdzIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoY3RvclsxXSA9PSBcIlJlZ0V4cFwiIHx8IGN0b3JbMV0gPT0gXCJGdW5jdGlvblwiIHx8IGN0b3JbMV0gPT0gXCJFcnJvclwiKSAmJiAhc2NvcGUuaGFzKGN0b3JbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGsoWyBcImNhbGxcIiwgWyBcIm5hbWVcIiwgY3RvclsxXSBdLCBhcmdzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiY2FsbFwiOiBmdW5jdGlvbihleHByLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwclswXSA9PSBcImRvdFwiICYmIGV4cHJbMV1bMF0gPT0gXCJzdHJpbmdcIiAmJiBhcmdzLmxlbmd0aCA9PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKGFyZ3NbMF1bMV0gPiAwICYmIGV4cHJbMl0gPT0gXCJzdWJzdHJpbmdcIiB8fCBleHByWzJdID09IFwic3Vic3RyXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIFwiY2FsbFwiLCBbIFwiZG90XCIsIGV4cHJbMV0sIFwic2xpY2VcIl0sIGFyZ3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJbMF0gPT0gXCJkb3RcIiAmJiBleHByWzJdID09IFwidG9TdHJpbmdcIiAmJiBhcmdzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvby50b1N0cmluZygpICA9PT4gIGZvbytcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByWzFdWzBdID09IFwic3RyaW5nXCIpIHJldHVybiBleHByWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBcImJpbmFyeVwiLCBcIitcIiwgZXhwclsxXSwgWyBcInN0cmluZ1wiLCBcIlwiIF1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJbMF0gPT0gXCJuYW1lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJbMV0gPT0gXCJBcnJheVwiICYmIGFyZ3MubGVuZ3RoICE9IDEgJiYgIXNjb3BlLmhhcyhcIkFycmF5XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgXCJhcnJheVwiLCBhcmdzIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJbMV0gPT0gXCJPYmplY3RcIiAmJiAhYXJncy5sZW5ndGggJiYgIXNjb3BlLmhhcyhcIk9iamVjdFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIFwib2JqZWN0XCIsIFtdIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJbMV0gPT0gXCJTdHJpbmdcIiAmJiAhc2NvcGUuaGFzKFwiU3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgXCJiaW5hcnlcIiwgXCIrXCIsIGFyZ3NbMF0sIFsgXCJzdHJpbmdcIiwgXCJcIiBdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhbGsocHJvLmFzdF9hZGRfc2NvcGUoYXN0KSk7XG4gICAgICAgIH0pO1xufTtcblxuZXhwb3J0cy5hc3Rfc3F1ZWV6ZV9tb3JlID0gYXN0X3NxdWVlemVfbW9yZTtcblxuLy8gTG9jYWwgdmFyaWFibGVzOlxuLy8ganMtaW5kZW50LWxldmVsOiA4XG4vLyBFbmQ6XG4iLCIvL2NvbnZpZW5lbmNlIGZ1bmN0aW9uKHNyYywgW29wdGlvbnNdKTtcbmZ1bmN0aW9uIHVnbGlmeShvcmlnX2NvZGUsIG9wdGlvbnMpe1xuICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICB2YXIganNwID0gdWdsaWZ5LnBhcnNlcjtcbiAgdmFyIHBybyA9IHVnbGlmeS51Z2xpZnk7XG5cbiAgdmFyIGFzdCA9IGpzcC5wYXJzZShvcmlnX2NvZGUsIG9wdGlvbnMuc3RyaWN0X3NlbWljb2xvbnMpOyAvLyBwYXJzZSBjb2RlIGFuZCBnZXQgdGhlIGluaXRpYWwgQVNUXG4gIGFzdCA9IHByby5hc3RfbWFuZ2xlKGFzdCwgb3B0aW9ucy5tYW5nbGVfb3B0aW9ucyk7IC8vIGdldCBhIG5ldyBBU1Qgd2l0aCBtYW5nbGVkIG5hbWVzXG4gIGFzdCA9IHByby5hc3Rfc3F1ZWV6ZShhc3QsIG9wdGlvbnMuc3F1ZWV6ZV9vcHRpb25zKTsgLy8gZ2V0IGFuIEFTVCB3aXRoIGNvbXByZXNzaW9uIG9wdGltaXphdGlvbnNcbiAgdmFyIGZpbmFsX2NvZGUgPSBwcm8uZ2VuX2NvZGUoYXN0LCBvcHRpb25zLmdlbl9vcHRpb25zKTsgLy8gY29tcHJlc3NlZCBjb2RlIGhlcmVcbiAgcmV0dXJuIGZpbmFsX2NvZGU7XG59O1xuXG51Z2xpZnkucGFyc2VyID0gcmVxdWlyZShcIi4vbGliL3BhcnNlLWpzXCIpO1xudWdsaWZ5LnVnbGlmeSA9IHJlcXVpcmUoXCIuL2xpYi9wcm9jZXNzXCIpO1xudWdsaWZ5LmNvbnNvbGlkYXRvciA9IHJlcXVpcmUoXCIuL2xpYi9jb25zb2xpZGF0b3JcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gdWdsaWZ5XG4iLCIvLyAgICAgVW5kZXJzY29yZS5qcyAxLjMuM1xuLy8gICAgIChjKSAyMDA5LTIwMTIgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIEluYy5cbi8vICAgICBVbmRlcnNjb3JlIGlzIGZyZWVseSBkaXN0cmlidXRhYmxlIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbi8vICAgICBQb3J0aW9ucyBvZiBVbmRlcnNjb3JlIGFyZSBpbnNwaXJlZCBvciBib3Jyb3dlZCBmcm9tIFByb3RvdHlwZSxcbi8vICAgICBPbGl2ZXIgU3RlZWxlJ3MgRnVuY3Rpb25hbCwgYW5kIEpvaG4gUmVzaWcncyBNaWNyby1UZW1wbGF0aW5nLlxuLy8gICAgIEZvciBhbGwgZGV0YWlscyBhbmQgZG9jdW1lbnRhdGlvbjpcbi8vICAgICBodHRwOi8vZG9jdW1lbnRjbG91ZC5naXRodWIuY29tL3VuZGVyc2NvcmVcblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBnbG9iYWxgIG9uIHRoZSBzZXJ2ZXIuXG4gIHZhciByb290ID0gdGhpcztcblxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYF9gIHZhcmlhYmxlLlxuICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xuXG4gIC8vIEVzdGFibGlzaCB0aGUgb2JqZWN0IHRoYXQgZ2V0cyByZXR1cm5lZCB0byBicmVhayBvdXQgb2YgYSBsb29wIGl0ZXJhdGlvbi5cbiAgdmFyIGJyZWFrZXIgPSB7fTtcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhciBzbGljZSAgICAgICAgICAgID0gQXJyYXlQcm90by5zbGljZSxcbiAgICAgIHVuc2hpZnQgICAgICAgICAgPSBBcnJheVByb3RvLnVuc2hpZnQsXG4gICAgICB0b1N0cmluZyAgICAgICAgID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSAgID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gQWxsICoqRUNNQVNjcmlwdCA1KiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlXG4gIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuICB2YXJcbiAgICBuYXRpdmVGb3JFYWNoICAgICAgPSBBcnJheVByb3RvLmZvckVhY2gsXG4gICAgbmF0aXZlTWFwICAgICAgICAgID0gQXJyYXlQcm90by5tYXAsXG4gICAgbmF0aXZlUmVkdWNlICAgICAgID0gQXJyYXlQcm90by5yZWR1Y2UsXG4gICAgbmF0aXZlUmVkdWNlUmlnaHQgID0gQXJyYXlQcm90by5yZWR1Y2VSaWdodCxcbiAgICBuYXRpdmVGaWx0ZXIgICAgICAgPSBBcnJheVByb3RvLmZpbHRlcixcbiAgICBuYXRpdmVFdmVyeSAgICAgICAgPSBBcnJheVByb3RvLmV2ZXJ5LFxuICAgIG5hdGl2ZVNvbWUgICAgICAgICA9IEFycmF5UHJvdG8uc29tZSxcbiAgICBuYXRpdmVJbmRleE9mICAgICAgPSBBcnJheVByb3RvLmluZGV4T2YsXG4gICAgbmF0aXZlTGFzdEluZGV4T2YgID0gQXJyYXlQcm90by5sYXN0SW5kZXhPZixcbiAgICBuYXRpdmVJc0FycmF5ICAgICAgPSBBcnJheS5pc0FycmF5LFxuICAgIG5hdGl2ZUtleXMgICAgICAgICA9IE9iamVjdC5rZXlzLFxuICAgIG5hdGl2ZUJpbmQgICAgICAgICA9IEZ1bmNQcm90by5iaW5kO1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikgeyByZXR1cm4gbmV3IHdyYXBwZXIob2JqKTsgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdCB2aWEgYSBzdHJpbmcgaWRlbnRpZmllcixcbiAgLy8gZm9yIENsb3N1cmUgQ29tcGlsZXIgXCJhZHZhbmNlZFwiIG1vZGUuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF87XG4gICAgfVxuICAgIGV4cG9ydHMuXyA9IF87XG4gIH0gZWxzZSB7XG4gICAgcm9vdFsnXyddID0gXztcbiAgfVxuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbi5cbiAgXy5WRVJTSU9OID0gJzEuMy4zJztcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIG9iamVjdHMgd2l0aCB0aGUgYnVpbHQtaW4gYGZvckVhY2hgLCBhcnJheXMsIGFuZCByYXcgb2JqZWN0cy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGZvckVhY2hgIGlmIGF2YWlsYWJsZS5cbiAgdmFyIGVhY2ggPSBfLmVhY2ggPSBfLmZvckVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm47XG4gICAgaWYgKG5hdGl2ZUZvckVhY2ggJiYgb2JqLmZvckVhY2ggPT09IG5hdGl2ZUZvckVhY2gpIHtcbiAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGkgaW4gb2JqICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKSByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKF8uaGFzKG9iaiwga2V5KSkge1xuICAgICAgICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaikgPT09IGJyZWFrZXIpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdG9yIHRvIGVhY2ggZWxlbWVudC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYG1hcGAgaWYgYXZhaWxhYmxlLlxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdHM7XG4gICAgaWYgKG5hdGl2ZU1hcCAmJiBvYmoubWFwID09PSBuYXRpdmVNYXApIHJldHVybiBvYmoubWFwKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICB9KTtcbiAgICBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHJlc3VsdHMubGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGByZWR1Y2VgIGlmIGF2YWlsYWJsZS5cbiAgXy5yZWR1Y2UgPSBfLmZvbGRsID0gXy5pbmplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgdmFyIGluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICBpZiAob2JqID09IG51bGwpIG9iaiA9IFtdO1xuICAgIGlmIChuYXRpdmVSZWR1Y2UgJiYgb2JqLnJlZHVjZSA9PT0gbmF0aXZlUmVkdWNlKSB7XG4gICAgICBpZiAoY29udGV4dCkgaXRlcmF0b3IgPSBfLmJpbmQoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIGluaXRpYWwgPyBvYmoucmVkdWNlKGl0ZXJhdG9yLCBtZW1vKSA6IG9iai5yZWR1Y2UoaXRlcmF0b3IpO1xuICAgIH1cbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgbWVtbyA9IHZhbHVlO1xuICAgICAgICBpbml0aWFsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG1lbW8sIHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFpbml0aWFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGByZWR1Y2VSaWdodGAgaWYgYXZhaWxhYmxlLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIG1lbW8sIGNvbnRleHQpIHtcbiAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIGlmIChvYmogPT0gbnVsbCkgb2JqID0gW107XG4gICAgaWYgKG5hdGl2ZVJlZHVjZVJpZ2h0ICYmIG9iai5yZWR1Y2VSaWdodCA9PT0gbmF0aXZlUmVkdWNlUmlnaHQpIHtcbiAgICAgIGlmIChjb250ZXh0KSBpdGVyYXRvciA9IF8uYmluZChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgICByZXR1cm4gaW5pdGlhbCA/IG9iai5yZWR1Y2VSaWdodChpdGVyYXRvciwgbWVtbykgOiBvYmoucmVkdWNlUmlnaHQoaXRlcmF0b3IpO1xuICAgIH1cbiAgICB2YXIgcmV2ZXJzZWQgPSBfLnRvQXJyYXkob2JqKS5yZXZlcnNlKCk7XG4gICAgaWYgKGNvbnRleHQgJiYgIWluaXRpYWwpIGl0ZXJhdG9yID0gXy5iaW5kKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICByZXR1cm4gaW5pdGlhbCA/IF8ucmVkdWNlKHJldmVyc2VkLCBpdGVyYXRvciwgbWVtbywgY29udGV4dCkgOiBfLnJlZHVjZShyZXZlcnNlZCwgaXRlcmF0b3IpO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgZmlyc3QgdmFsdWUgd2hpY2ggcGFzc2VzIGEgdHJ1dGggdGVzdC4gQWxpYXNlZCBhcyBgZGV0ZWN0YC5cbiAgXy5maW5kID0gXy5kZXRlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBhbnkob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGZpbHRlcmAgaWYgYXZhaWxhYmxlLlxuICAvLyBBbGlhc2VkIGFzIGBzZWxlY3RgLlxuICBfLmZpbHRlciA9IF8uc2VsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0cztcbiAgICBpZiAobmF0aXZlRmlsdGVyICYmIG9iai5maWx0ZXIgPT09IG5hdGl2ZUZpbHRlcikgcmV0dXJuIG9iai5maWx0ZXIoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGhdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgZm9yIHdoaWNoIGEgdHJ1dGggdGVzdCBmYWlscy5cbiAgXy5yZWplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHRzO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmICghaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgZXZlcnlgIGlmIGF2YWlsYWJsZS5cbiAgLy8gQWxpYXNlZCBhcyBgYWxsYC5cbiAgXy5ldmVyeSA9IF8uYWxsID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAobmF0aXZlRXZlcnkgJiYgb2JqLmV2ZXJ5ID09PSBuYXRpdmVFdmVyeSkgcmV0dXJuIG9iai5ldmVyeShpdGVyYXRvciwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKCEocmVzdWx0ID0gcmVzdWx0ICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkpIHJldHVybiBicmVha2VyO1xuICAgIH0pO1xuICAgIHJldHVybiAhIXJlc3VsdDtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHNvbWVgIGlmIGF2YWlsYWJsZS5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgdmFyIGFueSA9IF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGl0ZXJhdG9yIHx8IChpdGVyYXRvciA9IF8uaWRlbnRpdHkpO1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKG5hdGl2ZVNvbWUgJiYgb2JqLnNvbWUgPT09IG5hdGl2ZVNvbWUpIHJldHVybiBvYmouc29tZShpdGVyYXRvciwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHJlc3VsdCB8fCAocmVzdWx0ID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSkgcmV0dXJuIGJyZWFrZXI7XG4gICAgfSk7XG4gICAgcmV0dXJuICEhcmVzdWx0O1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiBhIGdpdmVuIHZhbHVlIGlzIGluY2x1ZGVkIGluIHRoZSBhcnJheSBvciBvYmplY3QgdXNpbmcgYD09PWAuXG4gIC8vIEFsaWFzZWQgYXMgYGNvbnRhaW5zYC5cbiAgXy5pbmNsdWRlID0gXy5jb250YWlucyA9IGZ1bmN0aW9uKG9iaiwgdGFyZ2V0KSB7XG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gZm91bmQ7XG4gICAgaWYgKG5hdGl2ZUluZGV4T2YgJiYgb2JqLmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHJldHVybiBvYmouaW5kZXhPZih0YXJnZXQpICE9IC0xO1xuICAgIGZvdW5kID0gYW55KG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdGFyZ2V0O1xuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKF8uaXNGdW5jdGlvbihtZXRob2QpID8gbWV0aG9kIHx8IHZhbHVlIDogdmFsdWVbbWV0aG9kXSkuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG4gIF8ucGx1Y2sgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlKXsgcmV0dXJuIHZhbHVlW2tleV07IH0pO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IG9yIChlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5tYXggPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzQXJyYXkob2JqKSAmJiBvYmpbMF0gPT09ICtvYmpbMF0pIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBvYmopO1xuICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0VtcHR5KG9iaikpIHJldHVybiAtSW5maW5pdHk7XG4gICAgdmFyIHJlc3VsdCA9IHtjb21wdXRlZCA6IC1JbmZpbml0eX07XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgdmFyIGNvbXB1dGVkID0gaXRlcmF0b3IgPyBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkgOiB2YWx1ZTtcbiAgICAgIGNvbXB1dGVkID49IHJlc3VsdC5jb21wdXRlZCAmJiAocmVzdWx0ID0ge3ZhbHVlIDogdmFsdWUsIGNvbXB1dGVkIDogY29tcHV0ZWR9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5taW4gPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzQXJyYXkob2JqKSAmJiBvYmpbMF0gPT09ICtvYmpbMF0pIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCBvYmopO1xuICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0VtcHR5KG9iaikpIHJldHVybiBJbmZpbml0eTtcbiAgICB2YXIgcmVzdWx0ID0ge2NvbXB1dGVkIDogSW5maW5pdHl9O1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IGl0ZXJhdG9yID8gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpIDogdmFsdWU7XG4gICAgICBjb21wdXRlZCA8IHJlc3VsdC5jb21wdXRlZCAmJiAocmVzdWx0ID0ge3ZhbHVlIDogdmFsdWUsIGNvbXB1dGVkIDogY29tcHV0ZWR9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICB9O1xuXG4gIC8vIFNodWZmbGUgYW4gYXJyYXkuXG4gIF8uc2h1ZmZsZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBzaHVmZmxlZCA9IFtdLCByYW5kO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJhbmQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaW5kZXggKyAxKSk7XG4gICAgICBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNvcnQgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiBwcm9kdWNlZCBieSBhbiBpdGVyYXRvci5cbiAgXy5zb3J0QnkgPSBmdW5jdGlvbihvYmosIHZhbCwgY29udGV4dCkge1xuICAgIHZhciBpdGVyYXRvciA9IF8uaXNGdW5jdGlvbih2YWwpID8gdmFsIDogZnVuY3Rpb24ob2JqKSB7IHJldHVybiBvYmpbdmFsXTsgfTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUgOiB2YWx1ZSxcbiAgICAgICAgY3JpdGVyaWEgOiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdClcbiAgICAgIH07XG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhLCBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgIGlmIChiID09PSB2b2lkIDApIHJldHVybiAtMTtcbiAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZnVuY3Rpb24ob2JqLCB2YWwpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGl0ZXJhdG9yID0gXy5pc0Z1bmN0aW9uKHZhbCkgPyB2YWwgOiBmdW5jdGlvbihvYmopIHsgcmV0dXJuIG9ialt2YWxdOyB9O1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgIHZhciBrZXkgPSBpdGVyYXRvcih2YWx1ZSwgaW5kZXgpO1xuICAgICAgKHJlc3VsdFtrZXldIHx8IChyZXN1bHRba2V5XSA9IFtdKSkucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBVc2UgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgYXQgd2hhdCBpbmRleCBhbiBvYmplY3Qgc2hvdWxkXG4gIC8vIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXG4gIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbihhcnJheSwgb2JqLCBpdGVyYXRvcikge1xuICAgIGl0ZXJhdG9yIHx8IChpdGVyYXRvciA9IF8uaWRlbnRpdHkpO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7XG4gICAgICBpdGVyYXRvcihhcnJheVttaWRdKSA8IGl0ZXJhdG9yKG9iaikgPyBsb3cgPSBtaWQgKyAxIDogaGlnaCA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbiAgfTtcblxuICAvLyBTYWZlbHkgY29udmVydCBhbnl0aGluZyBpdGVyYWJsZSBpbnRvIGEgcmVhbCwgbGl2ZSBhcnJheS5cbiAgXy50b0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFvYmopICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICBpZiAoXy5pc0FycmF5KG9iaikpICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoXy5pc0FyZ3VtZW50cyhvYmopKSAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAob2JqLnRvQXJyYXkgJiYgXy5pc0Z1bmN0aW9uKG9iai50b0FycmF5KSkgcmV0dXJuIG9iai50b0FycmF5KCk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmoubGVuZ3RoIDogXy5rZXlzKG9iaikubGVuZ3RoO1xuICB9O1xuXG4gIC8vIEFycmF5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGZpcnN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgaGVhZGAgYW5kIGB0YWtlYC4gVGhlICoqZ3VhcmQqKiBjaGVja1xuICAvLyBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8uZmlyc3QgPSBfLmhlYWQgPSBfLnRha2UgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gKG4gIT0gbnVsbCkgJiYgIWd1YXJkID8gc2xpY2UuY2FsbChhcnJheSwgMCwgbikgOiBhcnJheVswXTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNjaWFseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi4gVGhlICoqZ3VhcmQqKiBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoXG4gIC8vIGBfLm1hcGAuXG4gIF8uaW5pdGlhbCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBhcnJheS5sZW5ndGggLSAoKG4gPT0gbnVsbCkgfHwgZ3VhcmQgPyAxIDogbikpO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBsYXN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gVGhlICoqZ3VhcmQqKiBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmICgobiAhPSBudWxsKSAmJiAhZ3VhcmQpIHtcbiAgICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBNYXRoLm1heChhcnJheS5sZW5ndGggLSBuLCAwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYC5cbiAgLy8gRXNwZWNpYWxseSB1c2VmdWwgb24gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgYW4gKippbmRleCoqIHdpbGwgcmV0dXJuXG4gIC8vIHRoZSByZXN0IG9mIHRoZSB2YWx1ZXMgaW4gdGhlIGFycmF5IGZyb20gdGhhdCBpbmRleCBvbndhcmQuIFRoZSAqKmd1YXJkKipcbiAgLy8gY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLnJlc3QgPSBfLnRhaWwgPSBmdW5jdGlvbihhcnJheSwgaW5kZXgsIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIChpbmRleCA9PSBudWxsKSB8fCBndWFyZCA/IDEgOiBpbmRleCk7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpeyByZXR1cm4gISF2YWx1ZTsgfSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgY29tcGxldGVseSBmbGF0dGVuZWQgdmVyc2lvbiBvZiBhbiBhcnJheS5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gXy5yZWR1Y2UoYXJyYXksIGZ1bmN0aW9uKG1lbW8sIHZhbHVlKSB7XG4gICAgICBpZiAoXy5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIG1lbW8uY29uY2F0KHNoYWxsb3cgPyB2YWx1ZSA6IF8uZmxhdHRlbih2YWx1ZSkpO1xuICAgICAgbWVtb1ttZW1vLmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIFtdKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdG9yKSB7XG4gICAgdmFyIGluaXRpYWwgPSBpdGVyYXRvciA/IF8ubWFwKGFycmF5LCBpdGVyYXRvcikgOiBhcnJheTtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIC8vIFRoZSBgaXNTb3J0ZWRgIGZsYWcgaXMgaXJyZWxldmFudCBpZiB0aGUgYXJyYXkgb25seSBjb250YWlucyB0d28gZWxlbWVudHMuXG4gICAgaWYgKGFycmF5Lmxlbmd0aCA8IDMpIGlzU29ydGVkID0gdHJ1ZTtcbiAgICBfLnJlZHVjZShpbml0aWFsLCBmdW5jdGlvbiAobWVtbywgdmFsdWUsIGluZGV4KSB7XG4gICAgICBpZiAoaXNTb3J0ZWQgPyBfLmxhc3QobWVtbykgIT09IHZhbHVlIHx8ICFtZW1vLmxlbmd0aCA6ICFfLmluY2x1ZGUobWVtbywgdmFsdWUpKSB7XG4gICAgICAgIG1lbW8ucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJlc3VsdHMucHVzaChhcnJheVtpbmRleF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSwgW10pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoXy5mbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcbiAgLy8gcGFzc2VkLWluIGFycmF5cy4gKEFsaWFzZWQgYXMgXCJpbnRlcnNlY3RcIiBmb3IgYmFjay1jb21wYXQuKVxuICBfLmludGVyc2VjdGlvbiA9IF8uaW50ZXJzZWN0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoXy51bmlxKGFycmF5KSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgcmV0dXJuIF8uZXZlcnkocmVzdCwgZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIF8uaW5kZXhPZihvdGhlciwgaXRlbSkgPj0gMDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cbiAgXy5kaWZmZXJlbmNlID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IF8uZmxhdHRlbihzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIHRydWUpO1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpeyByZXR1cm4gIV8uaW5jbHVkZShyZXN0LCB2YWx1ZSk7IH0pO1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIGxlbmd0aCA9IF8ubWF4KF8ucGx1Y2soYXJncywgJ2xlbmd0aCcpKTtcbiAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHJlc3VsdHNbaV0gPSBfLnBsdWNrKGFyZ3MsIFwiXCIgKyBpKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBJZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBseSB1cyB3aXRoIGluZGV4T2YgKEknbSBsb29raW5nIGF0IHlvdSwgKipNU0lFKiopLFxuICAvLyB3ZSBuZWVkIHRoaXMgZnVuY3Rpb24uIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW5cbiAgLy8gaXRlbSBpbiBhbiBhcnJheSwgb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGluZGV4T2ZgIGlmIGF2YWlsYWJsZS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpc1NvcnRlZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gLTE7XG4gICAgdmFyIGksIGw7XG4gICAgaWYgKGlzU29ydGVkKSB7XG4gICAgICBpID0gXy5zb3J0ZWRJbmRleChhcnJheSwgaXRlbSk7XG4gICAgICByZXR1cm4gYXJyYXlbaV0gPT09IGl0ZW0gPyBpIDogLTE7XG4gICAgfVxuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIGFycmF5LmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHJldHVybiBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIGlmIChpIGluIGFycmF5ICYmIGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGxhc3RJbmRleE9mYCBpZiBhdmFpbGFibGUuXG4gIF8ubGFzdEluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gLTE7XG4gICAgaWYgKG5hdGl2ZUxhc3RJbmRleE9mICYmIGFycmF5Lmxhc3RJbmRleE9mID09PSBuYXRpdmVMYXN0SW5kZXhPZikgcmV0dXJuIGFycmF5Lmxhc3RJbmRleE9mKGl0ZW0pO1xuICAgIHZhciBpID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIGlmIChpIGluIGFycmF5ICYmIGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IGFyZ3VtZW50c1syXSB8fCAxO1xuXG4gICAgdmFyIGxlbiA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB2YXIgcmFuZ2UgPSBuZXcgQXJyYXkobGVuKTtcblxuICAgIHdoaWxlKGlkeCA8IGxlbikge1xuICAgICAgcmFuZ2VbaWR4KytdID0gc3RhcnQ7XG4gICAgICBzdGFydCArPSBzdGVwO1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJldXNhYmxlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBwcm90b3R5cGUgc2V0dGluZy5cbiAgdmFyIGN0b3IgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBCaW5kaW5nIHdpdGggYXJndW1lbnRzIGlzIGFsc28ga25vd24gYXMgYGN1cnJ5YC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmIGF2YWlsYWJsZS5cbiAgLy8gV2UgY2hlY2sgZm9yIGBmdW5jLmJpbmRgIGZpcnN0LCB0byBmYWlsIGZhc3Qgd2hlbiBgZnVuY2AgaXMgdW5kZWZpbmVkLlxuICBfLmJpbmQgPSBmdW5jdGlvbiBiaW5kKGZ1bmMsIGNvbnRleHQpIHtcbiAgICB2YXIgYm91bmQsIGFyZ3M7XG4gICAgaWYgKGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCAmJiBuYXRpdmVCaW5kKSByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgYm91bmQpKSByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgIGN0b3IucHJvdG90eXBlID0gZnVuYy5wcm90b3R5cGU7XG4gICAgICB2YXIgc2VsZiA9IG5ldyBjdG9yO1xuICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkoc2VsZiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQmluZCBhbGwgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0XG4gIC8vIGFsbCBjYWxsYmFja3MgZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgZnVuY3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgaWYgKGZ1bmNzLmxlbmd0aCA9PSAwKSBmdW5jcyA9IF8uZnVuY3Rpb25zKG9iaik7XG4gICAgZWFjaChmdW5jcywgZnVuY3Rpb24oZikgeyBvYmpbZl0gPSBfLmJpbmQob2JqW2ZdLCBvYmopOyB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXG4gIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1bmMsIGhhc2hlcikge1xuICAgIHZhciBtZW1vID0ge307XG4gICAgaGFzaGVyIHx8IChoYXNoZXIgPSBfLmlkZW50aXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIga2V5ID0gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gXy5oYXMobWVtbywga2V5KSA/IG1lbW9ba2V5XSA6IChtZW1vW2tleV0gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gIF8uZGVsYXkgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7IH0sIHdhaXQpO1xuICB9O1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICBfLmRlZmVyID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHJldHVybiBfLmRlbGF5LmFwcGx5KF8sIFtmdW5jLCAxXS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlXG4gIC8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLlxuICBfLnRocm90dGxlID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBjb250ZXh0LCBhcmdzLCB0aW1lb3V0LCB0aHJvdHRsaW5nLCBtb3JlLCByZXN1bHQ7XG4gICAgdmFyIHdoZW5Eb25lID0gXy5kZWJvdW5jZShmdW5jdGlvbigpeyBtb3JlID0gdGhyb3R0bGluZyA9IGZhbHNlOyB9LCB3YWl0KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjb250ZXh0ID0gdGhpczsgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKG1vcmUpIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIHdoZW5Eb25lKCk7XG4gICAgICB9O1xuICAgICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICBpZiAodGhyb3R0bGluZykge1xuICAgICAgICBtb3JlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgICB3aGVuRG9uZSgpO1xuICAgICAgdGhyb3R0bGluZyA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSkgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIH07XG4gICAgICBpZiAoaW1tZWRpYXRlICYmICF0aW1lb3V0KSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhdCBtb3N0IG9uZSB0aW1lLCBubyBtYXR0ZXIgaG93XG4gIC8vIG9mdGVuIHlvdSBjYWxsIGl0LiBVc2VmdWwgZm9yIGxhenkgaW5pdGlhbGl6YXRpb24uXG4gIF8ub25jZSA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgcmFuID0gZmFsc2UsIG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHJhbikgcmV0dXJuIG1lbW87XG4gICAgICByYW4gPSB0cnVlO1xuICAgICAgcmV0dXJuIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcbiAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZFxuICAvLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICBfLndyYXAgPSBmdW5jdGlvbihmdW5jLCB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbZnVuY10uY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG4gICAgICByZXR1cm4gd3JhcHBlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBhIGxpc3Qgb2YgZnVuY3Rpb25zLCBlYWNoXG4gIC8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gIF8uY29tcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmdW5jcyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGZvciAodmFyIGkgPSBmdW5jcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcmdzID0gW2Z1bmNzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIGFmdGVyIGJlaW5nIGNhbGxlZCBOIHRpbWVzLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICBpZiAodGltZXMgPD0gMCkgcmV0dXJuIGZ1bmMoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHsgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gT2JqZWN0IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBPYmplY3Qua2V5c2BcbiAgXy5rZXlzID0gbmF0aXZlS2V5cyB8fCBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqICE9PSBPYmplY3Qob2JqKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBvYmplY3QnKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIGtleXNba2V5cy5sZW5ndGhdID0ga2V5O1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLmlkZW50aXR5KTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBzb3J0ZWQgbGlzdCBvZiB0aGUgZnVuY3Rpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoZSBvYmplY3QuXG4gIC8vIEFsaWFzZWQgYXMgYG1ldGhvZHNgXG4gIF8uZnVuY3Rpb25zID0gXy5tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvYmpba2V5XSkpIG5hbWVzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLnNvcnQoKTtcbiAgfTtcblxuICAvLyBFeHRlbmQgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gcGFzc2VkLWluIG9iamVjdChzKS5cbiAgXy5leHRlbmQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBlYWNoKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZWFjaChfLmZsYXR0ZW4oc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSwgZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAoa2V5IGluIG9iaikgcmVzdWx0W2tleV0gPSBvYmpba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBlYWNoKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAob2JqW3Byb3BdID09IG51bGwpIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbi5cbiAgZnVuY3Rpb24gZXEoYSwgYiwgc3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBIYXJtb255IGBlZ2FsYCBwcm9wb3NhbDogaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PSAxIC8gYjtcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiO1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhLl9jaGFpbikgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIuX2NoYWluKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBJbnZva2UgYSBjdXN0b20gYGlzRXF1YWxgIG1ldGhvZCBpZiBvbmUgaXMgcHJvdmlkZWQuXG4gICAgaWYgKGEuaXNFcXVhbCAmJiBfLmlzRnVuY3Rpb24oYS5pc0VxdWFsKSkgcmV0dXJuIGEuaXNFcXVhbChiKTtcbiAgICBpZiAoYi5pc0VxdWFsICYmIF8uaXNGdW5jdGlvbihiLmlzRXF1YWwpKSByZXR1cm4gYi5pc0VxdWFsKGEpO1xuICAgIC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXG4gICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSk7XG4gICAgaWYgKGNsYXNzTmFtZSAhPSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZyhcIjVcIilgLlxuICAgICAgICByZXR1cm4gYSA9PSBTdHJpbmcoYik7XG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLiBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yXG4gICAgICAgIC8vIG90aGVyIG51bWVyaWMgdmFsdWVzLlxuICAgICAgICByZXR1cm4gYSAhPSArYSA/IGIgIT0gK2IgOiAoYSA9PSAwID8gMSAvIGEgPT0gMSAvIGIgOiBhID09ICtiKTtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgIHJldHVybiArYSA9PSArYjtcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyIHNvdXJjZSBwYXR0ZXJucyBhbmQgZmxhZ3MuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgICByZXR1cm4gYS5zb3VyY2UgPT0gYi5zb3VyY2UgJiZcbiAgICAgICAgICAgICAgIGEuZ2xvYmFsID09IGIuZ2xvYmFsICYmXG4gICAgICAgICAgICAgICBhLm11bHRpbGluZSA9PSBiLm11bHRpbGluZSAmJlxuICAgICAgICAgICAgICAgYS5pZ25vcmVDYXNlID09IGIuaWdub3JlQ2FzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuICAgIHZhciBsZW5ndGggPSBzdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChzdGFja1tsZW5ndGhdID09IGEpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgc3RhY2sucHVzaChhKTtcbiAgICB2YXIgc2l6ZSA9IDAsIHJlc3VsdCA9IHRydWU7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgaWYgKGNsYXNzTmFtZSA9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgIHNpemUgPSBhLmxlbmd0aDtcbiAgICAgIHJlc3VsdCA9IHNpemUgPT0gYi5sZW5ndGg7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICAgIHdoaWxlIChzaXplLS0pIHtcbiAgICAgICAgICAvLyBFbnN1cmUgY29tbXV0YXRpdmUgZXF1YWxpdHkgZm9yIHNwYXJzZSBhcnJheXMuXG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gc2l6ZSBpbiBhID09IHNpemUgaW4gYiAmJiBlcShhW3NpemVdLCBiW3NpemVdLCBzdGFjaykpKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICBpZiAoJ2NvbnN0cnVjdG9yJyBpbiBhICE9ICdjb25zdHJ1Y3RvcicgaW4gYiB8fCBhLmNvbnN0cnVjdG9yICE9IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgICAgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICAgICAgaWYgKF8uaGFzKGEsIGtleSkpIHtcbiAgICAgICAgICAvLyBDb3VudCB0aGUgZXhwZWN0ZWQgbnVtYmVyIG9mIHByb3BlcnRpZXMuXG4gICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlci5cbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSBfLmhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBzdGFjaykpKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGZvciAoa2V5IGluIGIpIHtcbiAgICAgICAgICBpZiAoXy5oYXMoYiwga2V5KSAmJiAhKHNpemUtLSkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9ICFzaXplO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBzdGFjay5wb3AoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXG4gIF8uaXNFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXEoYSwgYiwgW10pO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikpIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT0gMSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcbiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIGFyZ3VtZW50cyBvYmplY3Q/XG4gIF8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuICB9O1xuICBpZiAoIV8uaXNBcmd1bWVudHMoYXJndW1lbnRzKSkge1xuICAgIF8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiAhIShvYmogJiYgXy5oYXMob2JqLCAnY2FsbGVlJykpO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgZnVuY3Rpb24/XG4gIF8uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgc3RyaW5nP1xuICBfLmlzU3RyaW5nID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBTdHJpbmddJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgbnVtYmVyP1xuICBfLmlzTnVtYmVyID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBOdW1iZXJdJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIGlzRmluaXRlKG9iaik7XG4gIH07XG5cbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gP1xuICBfLmlzTmFOID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgLy8gYE5hTmAgaXMgdGhlIG9ubHkgdmFsdWUgZm9yIHdoaWNoIGA9PT1gIGlzIG5vdCByZWZsZXhpdmUuXG4gICAgcmV0dXJuIG9iaiAhPT0gb2JqO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBib29sZWFuP1xuICBfLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBkYXRlP1xuICBfLmlzRGF0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgRGF0ZV0nO1xuICB9O1xuXG4gIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbj9cbiAgXy5pc1JlZ0V4cCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgUmVnRXhwXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gSGFzIG93biBwcm9wZXJ0eT9cbiAgXy5oYXMgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgfTtcblxuICAvLyBVdGlsaXR5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJ1biBVbmRlcnNjb3JlLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHNcbiAgLy8gcHJldmlvdXMgb3duZXIuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICByb290Ll8gPSBwcmV2aW91c1VuZGVyc2NvcmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gS2VlcCB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gYXJvdW5kIGZvciBkZWZhdWx0IGl0ZXJhdG9ycy5cbiAgXy5pZGVudGl0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8vIFJ1biBhIGZ1bmN0aW9uICoqbioqIHRpbWVzLlxuICBfLnRpbWVzID0gZnVuY3Rpb24gKG4sIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgaSk7XG4gIH07XG5cbiAgLy8gRXNjYXBlIGEgc3RyaW5nIGZvciBIVE1MIGludGVycG9sYXRpb24uXG4gIF8uZXNjYXBlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgcmV0dXJuICgnJytzdHJpbmcpLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JykucmVwbGFjZSgvJy9nLCAnJiN4Mjc7JykucmVwbGFjZSgvXFwvL2csJyYjeDJGOycpO1xuICB9O1xuXG4gIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgcHJvcGVydHkgaXMgYSBmdW5jdGlvbiB0aGVuIGludm9rZSBpdDtcbiAgLy8gb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCwgZW5zdXJpbmcgdGhhdFxuICAvLyB0aGV5J3JlIGNvcnJlY3RseSBhZGRlZCB0byB0aGUgT09QIHdyYXBwZXIgYXMgd2VsbC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSl7XG4gICAgICBhZGRUb1dyYXBwZXIobmFtZSwgX1tuYW1lXSA9IG9ialtuYW1lXSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSBpZENvdW50ZXIrKztcbiAgICByZXR1cm4gcHJlZml4ID8gcHJlZml4ICsgaWQgOiBpZDtcbiAgfTtcblxuICAvLyBCeSBkZWZhdWx0LCBVbmRlcnNjb3JlIHVzZXMgRVJCLXN0eWxlIHRlbXBsYXRlIGRlbGltaXRlcnMsIGNoYW5nZSB0aGVcbiAgLy8gZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gICAgZXZhbHVhdGUgICAgOiAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgIGludGVycG9sYXRlIDogLzwlPShbXFxzXFxTXSs/KSU+L2csXG4gICAgZXNjYXBlICAgICAgOiAvPCUtKFtcXHNcXFNdKz8pJT4vZ1xuICB9O1xuXG4gIC8vIFdoZW4gY3VzdG9taXppbmcgYHRlbXBsYXRlU2V0dGluZ3NgLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byBkZWZpbmUgYW5cbiAgLy8gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiBvciBlc2NhcGluZyByZWdleCwgd2UgbmVlZCBvbmUgdGhhdCBpc1xuICAvLyBndWFyYW50ZWVkIG5vdCB0byBtYXRjaC5cbiAgdmFyIG5vTWF0Y2ggPSAvLl4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ3InOiAnXFxyJyxcbiAgICAnbic6ICdcXG4nLFxuICAgICd0JzogJ1xcdCcsXG4gICAgJ3UyMDI4JzogJ1xcdTIwMjgnLFxuICAgICd1MjAyOSc6ICdcXHUyMDI5J1xuICB9O1xuXG4gIGZvciAodmFyIHAgaW4gZXNjYXBlcykgZXNjYXBlc1tlc2NhcGVzW3BdXSA9IHA7XG4gIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdHxcXHUyMDI4fFxcdTIwMjkvZztcbiAgdmFyIHVuZXNjYXBlciA9IC9cXFxcKFxcXFx8J3xyfG58dHx1MjAyOHx1MjAyOSkvZztcblxuICAvLyBXaXRoaW4gYW4gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiwgb3IgZXNjYXBpbmcsIHJlbW92ZSBIVE1MIGVzY2FwaW5nXG4gIC8vIHRoYXQgaGFkIGJlZW4gcHJldmlvdXNseSBhZGRlZC5cbiAgdmFyIHVuZXNjYXBlID0gZnVuY3Rpb24oY29kZSkge1xuICAgIHJldHVybiBjb2RlLnJlcGxhY2UodW5lc2NhcGVyLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlKSB7XG4gICAgICByZXR1cm4gZXNjYXBlc1tlc2NhcGVdO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIF8udGVtcGxhdGUgPSBmdW5jdGlvbih0ZXh0LCBkYXRhLCBzZXR0aW5ncykge1xuICAgIHNldHRpbmdzID0gXy5kZWZhdWx0cyhzZXR0aW5ncyB8fCB7fSwgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgdGFraW5nIGNhcmUgdG8gZXNjYXBlIGNoYXJhY3RlcnMgdGhhdFxuICAgIC8vIGNhbm5vdCBiZSBpbmNsdWRlZCBpbiBhIHN0cmluZyBsaXRlcmFsIGFuZCB0aGVuIHVuZXNjYXBlIHRoZW0gaW4gY29kZVxuICAgIC8vIGJsb2Nrcy5cbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIiArIHRleHRcbiAgICAgIC5yZXBsYWNlKGVzY2FwZXIsIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTtcbiAgICAgIH0pXG4gICAgICAucmVwbGFjZShzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCwgZnVuY3Rpb24obWF0Y2gsIGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIFwiJytcXG5fLmVzY2FwZShcIiArIHVuZXNjYXBlKGNvZGUpICsgXCIpK1xcbidcIjtcbiAgICAgIH0pXG4gICAgICAucmVwbGFjZShzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoLCBmdW5jdGlvbihtYXRjaCwgY29kZSkge1xuICAgICAgICByZXR1cm4gXCInK1xcbihcIiArIHVuZXNjYXBlKGNvZGUpICsgXCIpK1xcbidcIjtcbiAgICAgIH0pXG4gICAgICAucmVwbGFjZShzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoLCBmdW5jdGlvbihtYXRjaCwgY29kZSkge1xuICAgICAgICByZXR1cm4gXCInO1xcblwiICsgdW5lc2NhcGUoY29kZSkgKyBcIlxcbjtfX3ArPSdcIjtcbiAgICAgIH0pICsgXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX19wPScnO1wiICtcbiAgICAgIFwidmFyIHByaW50PWZ1bmN0aW9uKCl7X19wKz1BcnJheS5wcm90b3R5cGUuam9pbi5jYWxsKGFyZ3VtZW50cywgJycpfTtcXG5cIiArXG4gICAgICBzb3VyY2UgKyBcInJldHVybiBfX3A7XFxuXCI7XG5cbiAgICB2YXIgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgaWYgKGRhdGEpIHJldHVybiByZW5kZXIoZGF0YSwgXyk7XG4gICAgdmFyIHRlbXBsYXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEsIF8pO1xuICAgIH07XG5cbiAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbiBzb3VyY2UgYXMgYSBjb252ZW5pZW5jZSBmb3IgYnVpbGQgdGltZVxuICAgIC8vIHByZWNvbXBpbGF0aW9uLlxuICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonKSArICcpe1xcbicgK1xuICAgICAgc291cmNlICsgJ30nO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9O1xuXG4gIC8vIEFkZCBhIFwiY2hhaW5cIiBmdW5jdGlvbiwgd2hpY2ggd2lsbCBkZWxlZ2F0ZSB0byB0aGUgd3JhcHBlci5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfKG9iaikuY2hhaW4oKTtcbiAgfTtcblxuICAvLyBUaGUgT09QIFdyYXBwZXJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXRcbiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGVcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cbiAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbihvYmopIHsgdGhpcy5fd3JhcHBlZCA9IG9iajsgfTtcblxuICAvLyBFeHBvc2UgYHdyYXBwZXIucHJvdG90eXBlYCBhcyBgXy5wcm90b3R5cGVgXG4gIF8ucHJvdG90eXBlID0gd3JhcHBlci5wcm90b3R5cGU7XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24ob2JqLCBjaGFpbikge1xuICAgIHJldHVybiBjaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xuICB9O1xuXG4gIC8vIEEgbWV0aG9kIHRvIGVhc2lseSBhZGQgZnVuY3Rpb25zIHRvIHRoZSBPT1Agd3JhcHBlci5cbiAgdmFyIGFkZFRvV3JhcHBlciA9IGZ1bmN0aW9uKG5hbWUsIGZ1bmMpIHtcbiAgICB3cmFwcGVyLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICB1bnNoaWZ0LmNhbGwoYXJncywgdGhpcy5fd3JhcHBlZCk7XG4gICAgICByZXR1cm4gcmVzdWx0KGZ1bmMuYXBwbHkoXywgYXJncyksIHRoaXMuX2NoYWluKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEFkZCBhbGwgb2YgdGhlIFVuZGVyc2NvcmUgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgXy5taXhpbihfKTtcblxuICAvLyBBZGQgYWxsIG11dGF0b3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBlYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICB3cmFwcGVyLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHdyYXBwZWQgPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KHdyYXBwZWQsIGFyZ3VtZW50cyk7XG4gICAgICB2YXIgbGVuZ3RoID0gd3JhcHBlZC5sZW5ndGg7XG4gICAgICBpZiAoKG5hbWUgPT0gJ3NoaWZ0JyB8fCBuYW1lID09ICdzcGxpY2UnKSAmJiBsZW5ndGggPT09IDApIGRlbGV0ZSB3cmFwcGVkWzBdO1xuICAgICAgcmV0dXJuIHJlc3VsdCh3cmFwcGVkLCB0aGlzLl9jaGFpbik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWRkIGFsbCBhY2Nlc3NvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIGVhY2goWydjb25jYXQnLCAnam9pbicsICdzbGljZSddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgd3JhcHBlci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZXN1bHQobWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsIGFyZ3VtZW50cyksIHRoaXMuX2NoYWluKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBTdGFydCBjaGFpbmluZyBhIHdyYXBwZWQgVW5kZXJzY29yZSBvYmplY3QuXG4gIHdyYXBwZXIucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEV4dHJhY3RzIHRoZSByZXN1bHQgZnJvbSBhIHdyYXBwZWQgYW5kIGNoYWluZWQgb2JqZWN0LlxuICB3cmFwcGVyLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgLy8gZXhwb3NlIHVuaWNvZGVSZWdFeHAgYXNcbiAgICAvLyAtIGFuIEFNRCBtb2R1bGUgKHJlcXVpcmUpXG4gICAgLy8gLSBhIG5vZGUgbW9kdWxlXG5cbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShmYWN0b3J5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LnVuaWNvZGVSZWdFeHAgPSBmYWN0b3J5KCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoeHJlZ2V4cCkge1xuICAgIHZhciB1bmljb2RlUmVnRXhwID0ge307XG5cbiAgICAvLyBUaGVzZSBhcmUgdGFrZW4gZnJvbSB0aGUgWFJlZ0V4cCBsaWJyYXJ5IChzZWUgLi4vZXh0cmFjdFJlZ0V4cHNGcm9tWFJlZ0V4cC5qcyk6XG4gICAgdW5pY29kZVJlZ0V4cC5sZXR0ZXIgPSAvW0EtWmEtesKqwrXCusOALcOWw5gtw7bDuC3LgcuGLcuRy6Aty6TLrMuuzbAtzbTNts23zbotzb3Ohs6ILc6KzozOji3Ooc6jLc+1z7ct0oHSii3Up9SxLdWW1ZnVoS3Wh9eQLdeq17At17LYoC3Zitmu2a/ZsS3bk9uV26Xbptuu26/bui3bvNu/3JDcki3cr92NLd6l3rHfii3fqt+037XfuuCggC3goJXgoJrgoKTgoKjgoYAt4KGY4KKg4KKiLeCirOCkhC3gpLngpL3gpZDgpZgt4KWh4KWxLeClt+CluS3gpb/gpoUt4KaM4KaP4KaQ4KaTLeCmqOCmqi3gprDgprLgprYt4Ka54Ka94KeO4Kec4Ked4KefLeCnoeCnsOCnseCohS3gqIrgqI/gqJDgqJMt4Kio4KiqLeCosOCosuCos+CoteCotuCouOCoueCpmS3gqZzgqZ7gqbIt4Km04KqFLeCqjeCqjy3gqpHgqpMt4Kqo4KqqLeCqsOCqsuCqs+CqtS3gqrngqr3gq5Dgq6Dgq6HgrIUt4KyM4KyP4KyQ4KyTLeCsqOCsqi3grLDgrLLgrLPgrLUt4Ky54Ky94K2c4K2d4K2fLeCtoeCtseCug+CuhS3grorgro4t4K6Q4K6SLeCuleCumeCumuCunOCunuCun+Cuo+CupOCuqC3grqrgrq4t4K654K+Q4LCFLeCwjOCwji3gsJDgsJIt4LCo4LCqLeCws+CwtS3gsLngsL3gsZjgsZngsaDgsaHgsoUt4LKM4LKOLeCykOCyki3gsqjgsqot4LKz4LK1LeCyueCyveCznuCzoOCzoeCzseCzsuC0hS3gtIzgtI4t4LSQ4LSSLeC0uuC0veC1juC1oOC1oeC1ui3gtb/gtoUt4LaW4LaaLeC2seC2sy3gtrvgtr3gt4At4LeG4LiBLeC4sOC4suC4s+C5gC3guYbguoHguoLguoTguofguojguorguo3gupQt4LqX4LqZLeC6n+C6oS3guqPguqXguqfguqrguqvguq0t4Lqw4Lqy4Lqz4Lq94LuALeC7hOC7huC7nC3gu5/gvIDgvYAt4L2H4L2JLeC9rOC+iC3gvozhgIAt4YCq4YC/4YGQLeGBleGBmi3hgZ3hgaHhgaXhgabhga4t4YGw4YG1LeGCgeGCjuGCoC3hg4Xhg4fhg43hg5At4YO64YO8LeGJiOGJii3hiY3hiZAt4YmW4YmY4YmaLeGJneGJoC3hiojhioot4YqN4YqQLeGKsOGKsi3hirXhirgt4Yq+4YuA4YuCLeGLheGLiC3hi5bhi5gt4YyQ4YySLeGMleGMmC3hjZrhjoAt4Y6P4Y6gLeGPtOGQgS3hmazhma8t4Zm/4ZqBLeGamuGaoC3hm6rhnIAt4ZyM4ZyOLeGckeGcoC3hnLHhnYAt4Z2R4Z2gLeGdrOGdri3hnbDhnoAt4Z6z4Z+X4Z+c4aCgLeGht+GigC3hoqjhoqrhorAt4aO14aSALeGknOGlkC3hpa3hpbAt4aW04aaALeGmq+GngS3hp4fhqIAt4aiW4aigLeGplOGqp+GshS3hrLPhrYUt4a2L4a6DLeGuoOGuruGur+Guui3hr6XhsIAt4bCj4bGNLeGxj+Gxmi3hsb3hs6kt4bOs4bOuLeGzseGzteGztuG0gC3htr/huIAt4byV4byYLeG8neG8oC3hvYXhvYgt4b2N4b2QLeG9l+G9meG9m+G9neG9ny3hvb3hvoAt4b604b62LeG+vOG+vuG/gi3hv4Thv4Yt4b+M4b+QLeG/k+G/li3hv5vhv6At4b+s4b+yLeG/tOG/ti3hv7zigbHigb/igpAt4oKc4oSC4oSH4oSKLeKEk+KEleKEmS3ihJ3ihKTihKbihKjihKot4oSt4oSvLeKEueKEvC3ihL/ihYUt4oWJ4oWO4oaD4oaE4rCALeKwruKwsC3isZ7isaAt4rOk4rOrLeKzruKzsuKzs+K0gC3itKXitKfitK3itLAt4rWn4rWv4raALeK2luK2oC3itqbitqgt4rau4rawLeK2tuK2uC3itr7it4At4reG4reILeK3juK3kC3it5bit5gt4ree4riv44CF44CG44CxLeOAteOAu+OAvOOBgS3jgpbjgp0t44Kf44KhLeODuuODvC3jg7/jhIUt44St44SxLeOGjuOGoC3jhrrjh7At44e/45CALeS2teS4gC3pv4zqgIAt6pKM6pOQLeqTveqUgC3qmIzqmJAt6pif6piq6pir6pmALeqZruqZvy3qmpfqmqAt6pul6pyXLeqcn+qcoi3qnojqnost6p6O6p6QLeqek+qeoC3qnqrqn7gt6qCB6qCDLeqgheqghy3qoIrqoIwt6qCi6qGALeqhs+qigi3qorPqo7It6qO36qO76qSKLeqkpeqksC3qpYbqpaAt6qW86qaELeqmsuqnj+qogC3qqKjqqYAt6qmC6qmELeqpi+qpoC3qqbbqqbrqqoAt6qqv6qqx6qq16qq26qq5LeqqveqrgOqrguqrmy3qq53qq6At6quq6quyLeqrtOqsgS3qrIbqrIkt6qyO6qyRLeqsluqsoC3qrKbqrKgt6qyu6q+ALeqvouqwgC3tnqPtnrAt7Z+G7Z+LLe2fu++kgC3vqa3vqbAt76uZ76yALe+shu+sky3vrJfvrJ3vrJ8t76yo76yqLe+stu+suC3vrLzvrL7vrYDvrYHvrYPvrYTvrYYt766x76+TLe+0ve+1kC3vto/vtpIt77eH77ewLe+3u++5sC3vubTvubYt77u877yhLe+8uu+9gS3vvZrvvaYt776+77+CLe+/h++/ii3vv4/vv5It77+X77+aLe+/nF0vO1xuICAgIHVuaWNvZGVSZWdFeHAubWFyayA9IC9bXFx1MDMwMC1cXHUwMzZGXFx1MDQ4My1cXHUwNDg5XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDYxMC1cXHUwNjFBXFx1MDY0Qi1cXHUwNjVGXFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXFx1MDcxMVxcdTA3MzAtXFx1MDc0QVxcdTA3QTYtXFx1MDdCMFxcdTA3RUItXFx1MDdGM1xcdTA4MTYtXFx1MDgxOVxcdTA4MUItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyRFxcdTA4NTktXFx1MDg1QlxcdTA4RTQtXFx1MDhGRVxcdTA5MDAtXFx1MDkwM1xcdTA5M0EtXFx1MDkzQ1xcdTA5M0UtXFx1MDk0RlxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk4MS1cXHUwOTgzXFx1MDlCQ1xcdTA5QkUtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNEXFx1MDlEN1xcdTA5RTJcXHUwOUUzXFx1MEEwMS1cXHUwQTAzXFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNzBcXHUwQTcxXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBQkNcXHUwQUJFLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBCMDEtXFx1MEIwM1xcdTBCM0NcXHUwQjNFLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI2MlxcdTBCNjNcXHUwQjgyXFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEN1xcdTBDMDEtXFx1MEMwM1xcdTBDM0UtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM2MlxcdTBDNjNcXHUwQzgyXFx1MEM4M1xcdTBDQkNcXHUwQ0JFLVxcdTBDQzRcXHUwQ0M2LVxcdTBDQzhcXHUwQ0NBLVxcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDRTJcXHUwQ0UzXFx1MEQwMlxcdTBEMDNcXHUwRDNFLVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENERcXHUwRDU3XFx1MEQ2MlxcdTBENjNcXHUwRDgyXFx1MEQ4M1xcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERGMlxcdTBERjNcXHUwRTMxXFx1MEUzNC1cXHUwRTNBXFx1MEU0Ny1cXHUwRTRFXFx1MEVCMVxcdTBFQjQtXFx1MEVCOVxcdTBFQkJcXHUwRUJDXFx1MEVDOC1cXHUwRUNEXFx1MEYxOFxcdTBGMTlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFXFx1MEYzRlxcdTBGNzEtXFx1MEY4NFxcdTBGODZcXHUwRjg3XFx1MEY4RC1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMkItXFx1MTAzRVxcdTEwNTYtXFx1MTA1OVxcdTEwNUUtXFx1MTA2MFxcdTEwNjItXFx1MTA2NFxcdTEwNjctXFx1MTA2RFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4RFxcdTEwOEZcXHUxMDlBLVxcdTEwOURcXHUxMzVELVxcdTEzNUZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdCNC1cXHUxN0QzXFx1MTdERFxcdTE4MEItXFx1MTgwRFxcdTE4QTlcXHUxOTIwLVxcdTE5MkJcXHUxOTMwLVxcdTE5M0JcXHUxOUIwLVxcdTE5QzBcXHUxOUM4XFx1MTlDOVxcdTFBMTctXFx1MUExQlxcdTFBNTUtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0ZcXHUxQjAwLVxcdTFCMDRcXHUxQjM0LVxcdTFCNDRcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCODJcXHUxQkExLVxcdTFCQURcXHUxQkU2LVxcdTFCRjNcXHUxQzI0LVxcdTFDMzdcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRThcXHUxQ0VEXFx1MUNGMi1cXHUxQ0Y0XFx1MURDMC1cXHUxREU2XFx1MURGQy1cXHUxREZGXFx1MjBEMC1cXHUyMEYwXFx1MkNFRi1cXHUyQ0YxXFx1MkQ3RlxcdTJERTAtXFx1MkRGRlxcdTMwMkEtXFx1MzAyRlxcdTMwOTlcXHUzMDlBXFx1QTY2Ri1cXHVBNjcyXFx1QTY3NC1cXHVBNjdEXFx1QTY5RlxcdUE2RjBcXHVBNkYxXFx1QTgwMlxcdUE4MDZcXHVBODBCXFx1QTgyMy1cXHVBODI3XFx1QTg4MFxcdUE4ODFcXHVBOEI0LVxcdUE4QzRcXHVBOEUwLVxcdUE4RjFcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTNcXHVBOTgwLVxcdUE5ODNcXHVBOUIzLVxcdUE5QzBcXHVBQTI5LVxcdUFBMzZcXHVBQTQzXFx1QUE0Q1xcdUFBNERcXHVBQTdCXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQi1cXHVBQUVGXFx1QUFGNVxcdUFBRjZcXHVBQkUzLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUZCMUVcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMjZdLztcbiAgICB1bmljb2RlUmVnRXhwLm51bWJlciA9IC9bMC05wrLCs8K5wrwtwr7ZoC3ZqduwLdu534At34ngpaYt4KWv4KemLeCnr+CntC3gp7ngqaYt4Kmv4KumLeCrr+Ctpi3gra/grbIt4K234K+mLeCvsuCxpi3gsa/gsbgt4LG+4LOmLeCzr+C1pi3gtbXguZAt4LmZ4LuQLeC7meC8oC3gvLPhgYAt4YGJ4YKQLeGCmeGNqS3hjbzhm64t4Zuw4Z+gLeGfqeGfsC3hn7nhoJAt4aCZ4aWGLeGlj+GnkC3hp5rhqoAt4aqJ4aqQLeGqmeGtkC3hrZnhrrAt4a654bGALeGxieGxkC3hsZnigbDigbQt4oG54oKALeKCieKFkC3ihoLihoUt4oaJ4pGgLeKSm+KTqi3ik7/inbYt4p6T4rO944CH44ChLeOAqeOAuC3jgLrjhpIt44aV44igLeOIqeOJiC3jiY/jiZEt44mf44qALeOKieOKsS3jir/qmKAt6pip6pumLeqbr+qgsC3qoLXqo5At6qOZ6qSALeqkieqnkC3qp5nqqZAt6qmZ6q+wLeqvue+8kC3vvJldLztcbiAgICB1bmljb2RlUmVnRXhwLnB1bmN0dWF0aW9uID0gL1tcXHUwMDIxLVxcdTAwMjNcXHUwMDI1LVxcdTAwMkFcXHUwMDJDLVxcdTAwMkZcXHUwMDNBXFx1MDAzQlxcdTAwM0ZcXHUwMDQwXFx1MDA1Qi1cXHUwMDVEXFx1MDA1RlxcdTAwN0JcXHUwMDdEXFx1MDBBMVxcdTAwQTdcXHUwMEFCXFx1MDBCNlxcdTAwQjdcXHUwMEJCXFx1MDBCRlxcdTAzN0VcXHUwMzg3XFx1MDU1QS1cXHUwNTVGXFx1MDU4OVxcdTA1OEFcXHUwNUJFXFx1MDVDMFxcdTA1QzNcXHUwNUM2XFx1MDVGM1xcdTA1RjRcXHUwNjA5XFx1MDYwQVxcdTA2MENcXHUwNjBEXFx1MDYxQlxcdTA2MUVcXHUwNjFGXFx1MDY2QS1cXHUwNjZEXFx1MDZENFxcdTA3MDAtXFx1MDcwRFxcdTA3RjctXFx1MDdGOVxcdTA4MzAtXFx1MDgzRVxcdTA4NUVcXHUwOTY0XFx1MDk2NVxcdTA5NzBcXHUwQUYwXFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjNBLVxcdTBGM0RcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTQwMFxcdTE2NkRcXHUxNjZFXFx1MTY5QlxcdTE2OUNcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE3RDQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQVxcdTE4MDAtXFx1MTgwQVxcdTE5NDRcXHUxOTQ1XFx1MUExRVxcdTFBMUZcXHUxQUEwLVxcdTFBQTZcXHUxQUE4LVxcdTFBQURcXHUxQjVBLVxcdTFCNjBcXHUxQkZDLVxcdTFCRkZcXHUxQzNCLVxcdTFDM0ZcXHUxQzdFXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUyMDEwLVxcdTIwMjdcXHUyMDMwLVxcdTIwNDNcXHUyMDQ1LVxcdTIwNTFcXHUyMDUzLVxcdTIwNUVcXHUyMDdEXFx1MjA3RVxcdTIwOERcXHUyMDhFXFx1MjMyOVxcdTIzMkFcXHUyNzY4LVxcdTI3NzVcXHUyN0M1XFx1MjdDNlxcdTI3RTYtXFx1MjdFRlxcdTI5ODMtXFx1Mjk5OFxcdTI5RDgtXFx1MjlEQlxcdTI5RkNcXHUyOUZEXFx1MkNGOS1cXHUyQ0ZDXFx1MkNGRVxcdTJDRkZcXHUyRDcwXFx1MkUwMC1cXHUyRTJFXFx1MkUzMC1cXHUyRTNCXFx1MzAwMS1cXHUzMDAzXFx1MzAwOC1cXHUzMDExXFx1MzAxNC1cXHUzMDFGXFx1MzAzMFxcdTMwM0RcXHUzMEEwXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE5MkVcXHVBOTJGXFx1QTk1RlxcdUE5QzEtXFx1QTlDRFxcdUE5REVcXHVBOURGXFx1QUE1Qy1cXHVBQTVGXFx1QUFERVxcdUFBREZcXHVBQUYwXFx1QUFGMVxcdUFCRUJcXHVGRDNFXFx1RkQzRlxcdUZFMTAtXFx1RkUxOVxcdUZFMzAtXFx1RkU1MlxcdUZFNTQtXFx1RkU2MVxcdUZFNjNcXHVGRTY4XFx1RkU2QVxcdUZFNkJcXHVGRjAxLVxcdUZGMDNcXHVGRjA1LVxcdUZGMEFcXHVGRjBDLVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQi1cXHVGRjNEXFx1RkYzRlxcdUZGNUJcXHVGRjVEXFx1RkY1Ri1cXHVGRjY1XS87XG4gICAgdW5pY29kZVJlZ0V4cC5zeW1ib2wgPSAvW1xcdTAwMjQrPC0+XFx1MDA1RWBcXHUwMDdDfsKiLcKmwqjCqcKswq4twrHCtMK4w5fDt8uCLcuFy5Ity5/LpS3Lq8uty68ty7/Ntc6EzoXPttKC1o/Yhi3YiNiL2I7Yj9ue26nbvdu+37bgp7Lgp7Pgp7rgp7vgq7HgrbDgr7Mt4K+64LG/4LW54Li/4LyBLeC8g+C8k+C8lS3gvJfgvJot4Lyf4Ly04Ly24Ly44L6+LeC/heC/hy3gv4zgv47gv4/gv5Ut4L+Y4YKe4YKf4Y6QLeGOmeGfm+GlgOGnni3hp7/hraEt4a2q4a20LeGtvOG+veG+vy3hv4Hhv40t4b+P4b+dLeG/n+G/rS3hv6/hv73hv77igYTigZLigbot4oG84oKKLeKCjOKCoC3igrnihIDihIHihIMt4oSG4oSI4oSJ4oSU4oSWLeKEmOKEni3ihKPihKXihKfihKnihK7ihLrihLvihYAt4oWE4oWKLeKFjeKFj+KGkC3ijKjijKst4o+z4pCALeKQpuKRgC3ikYrikpwt4pOp4pSALeKbv+KcgS3inafinpQt4p+E4p+HLeKfpeKfsC3ipoLippkt4qeX4qecLeKnu+Knvi3irYzirZAt4q2Z4rOlLeKzquK6gC3iupniupst4ruz4ryALeK/leK/sC3iv7vjgITjgJLjgJPjgKDjgLbjgLfjgL7jgL/jgpvjgpzjhpDjhpHjhpYt44af44eALeOHo+OIgC3jiJ7jiKot44mH44mQ44mgLeOJv+OKii3jirDji4At44u+44yALeOPv+S3gC3kt7/qkpAt6pOG6pyALeqcluqcoOqcoeqeieqeiuqgqC3qoKvqoLYt6qC56qm3Leqpue+sqe+usi3vr4Hvt7zvt73vuaLvuaQt77mm77mp77yE77yL77ycLe+8nu+8vu+9gO+9nO+9nu+/oC3vv6bvv6gt77+u77+877+9XS87XG4gICAgdW5pY29kZVJlZ0V4cC5zZXBhcmF0b3IgPSAvW1xcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwLVxcdTIwMEFcXHUyMDI4XFx1MjAyOVxcdTIwMkZcXHUyMDVGXFx1MzAwMF0vO1xuICAgIHVuaWNvZGVSZWdFeHAub3RoZXIgPSAvW1xcdTAwMDAtXFx1MDAxRlxcdTAwN0YtXFx1MDA5RlxcdTAwQURcXHUwMzc4XFx1MDM3OVxcdTAzN0YtXFx1MDM4M1xcdTAzOEJcXHUwMzhEXFx1MDNBMlxcdTA1MjgtXFx1MDUzMFxcdTA1NTdcXHUwNTU4XFx1MDU2MFxcdTA1ODhcXHUwNThCLVxcdTA1OEVcXHUwNTkwXFx1MDVDOC1cXHUwNUNGXFx1MDVFQi1cXHUwNUVGXFx1MDVGNS1cXHUwNjA1XFx1MDYxQ1xcdTA2MURcXHUwNkREXFx1MDcwRVxcdTA3MEZcXHUwNzRCXFx1MDc0Q1xcdTA3QjItXFx1MDdCRlxcdTA3RkItXFx1MDdGRlxcdTA4MkVcXHUwODJGXFx1MDgzRlxcdTA4NUNcXHUwODVEXFx1MDg1Ri1cXHUwODlGXFx1MDhBMVxcdTA4QUQtXFx1MDhFM1xcdTA4RkZcXHUwOTc4XFx1MDk4MFxcdTA5ODRcXHUwOThEXFx1MDk4RVxcdTA5OTFcXHUwOTkyXFx1MDlBOVxcdTA5QjFcXHUwOUIzLVxcdTA5QjVcXHUwOUJBXFx1MDlCQlxcdTA5QzVcXHUwOUM2XFx1MDlDOVxcdTA5Q0FcXHUwOUNGLVxcdTA5RDZcXHUwOUQ4LVxcdTA5REJcXHUwOURFXFx1MDlFNFxcdTA5RTVcXHUwOUZDLVxcdTBBMDBcXHUwQTA0XFx1MEEwQi1cXHUwQTBFXFx1MEExMVxcdTBBMTJcXHUwQTI5XFx1MEEzMVxcdTBBMzRcXHUwQTM3XFx1MEEzQVxcdTBBM0JcXHUwQTNEXFx1MEE0My1cXHUwQTQ2XFx1MEE0OVxcdTBBNEFcXHUwQTRFLVxcdTBBNTBcXHUwQTUyLVxcdTBBNThcXHUwQTVEXFx1MEE1Ri1cXHUwQTY1XFx1MEE3Ni1cXHUwQTgwXFx1MEE4NFxcdTBBOEVcXHUwQTkyXFx1MEFBOVxcdTBBQjFcXHUwQUI0XFx1MEFCQVxcdTBBQkJcXHUwQUM2XFx1MEFDQVxcdTBBQ0VcXHUwQUNGXFx1MEFEMS1cXHUwQURGXFx1MEFFNFxcdTBBRTVcXHUwQUYyLVxcdTBCMDBcXHUwQjA0XFx1MEIwRFxcdTBCMEVcXHUwQjExXFx1MEIxMlxcdTBCMjlcXHUwQjMxXFx1MEIzNFxcdTBCM0FcXHUwQjNCXFx1MEI0NVxcdTBCNDZcXHUwQjQ5XFx1MEI0QVxcdTBCNEUtXFx1MEI1NVxcdTBCNTgtXFx1MEI1QlxcdTBCNUVcXHUwQjY0XFx1MEI2NVxcdTBCNzgtXFx1MEI4MVxcdTBCODRcXHUwQjhCLVxcdTBCOERcXHUwQjkxXFx1MEI5Ni1cXHUwQjk4XFx1MEI5QlxcdTBCOURcXHUwQkEwLVxcdTBCQTJcXHUwQkE1LVxcdTBCQTdcXHUwQkFCLVxcdTBCQURcXHUwQkJBLVxcdTBCQkRcXHUwQkMzLVxcdTBCQzVcXHUwQkM5XFx1MEJDRVxcdTBCQ0ZcXHUwQkQxLVxcdTBCRDZcXHUwQkQ4LVxcdTBCRTVcXHUwQkZCLVxcdTBDMDBcXHUwQzA0XFx1MEMwRFxcdTBDMTFcXHUwQzI5XFx1MEMzNFxcdTBDM0EtXFx1MEMzQ1xcdTBDNDVcXHUwQzQ5XFx1MEM0RS1cXHUwQzU0XFx1MEM1N1xcdTBDNUEtXFx1MEM1RlxcdTBDNjRcXHUwQzY1XFx1MEM3MC1cXHUwQzc3XFx1MEM4MFxcdTBDODFcXHUwQzg0XFx1MEM4RFxcdTBDOTFcXHUwQ0E5XFx1MENCNFxcdTBDQkFcXHUwQ0JCXFx1MENDNVxcdTBDQzlcXHUwQ0NFLVxcdTBDRDRcXHUwQ0Q3LVxcdTBDRERcXHUwQ0RGXFx1MENFNFxcdTBDRTVcXHUwQ0YwXFx1MENGMy1cXHUwRDAxXFx1MEQwNFxcdTBEMERcXHUwRDExXFx1MEQzQlxcdTBEM0NcXHUwRDQ1XFx1MEQ0OVxcdTBENEYtXFx1MEQ1NlxcdTBENTgtXFx1MEQ1RlxcdTBENjRcXHUwRDY1XFx1MEQ3Ni1cXHUwRDc4XFx1MEQ4MFxcdTBEODFcXHUwRDg0XFx1MEQ5Ny1cXHUwRDk5XFx1MERCMlxcdTBEQkNcXHUwREJFXFx1MERCRlxcdTBEQzctXFx1MERDOVxcdTBEQ0ItXFx1MERDRVxcdTBERDVcXHUwREQ3XFx1MERFMC1cXHUwREYxXFx1MERGNS1cXHUwRTAwXFx1MEUzQi1cXHUwRTNFXFx1MEU1Qy1cXHUwRTgwXFx1MEU4M1xcdTBFODVcXHUwRTg2XFx1MEU4OVxcdTBFOEJcXHUwRThDXFx1MEU4RS1cXHUwRTkzXFx1MEU5OFxcdTBFQTBcXHUwRUE0XFx1MEVBNlxcdTBFQThcXHUwRUE5XFx1MEVBQ1xcdTBFQkFcXHUwRUJFXFx1MEVCRlxcdTBFQzVcXHUwRUM3XFx1MEVDRVxcdTBFQ0ZcXHUwRURBXFx1MEVEQlxcdTBFRTAtXFx1MEVGRlxcdTBGNDhcXHUwRjZELVxcdTBGNzBcXHUwRjk4XFx1MEZCRFxcdTBGQ0RcXHUwRkRCLVxcdTBGRkZcXHUxMEM2XFx1MTBDOC1cXHUxMENDXFx1MTBDRVxcdTEwQ0ZcXHUxMjQ5XFx1MTI0RVxcdTEyNEZcXHUxMjU3XFx1MTI1OVxcdTEyNUVcXHUxMjVGXFx1MTI4OVxcdTEyOEVcXHUxMjhGXFx1MTJCMVxcdTEyQjZcXHUxMkI3XFx1MTJCRlxcdTEyQzFcXHUxMkM2XFx1MTJDN1xcdTEyRDdcXHUxMzExXFx1MTMxNlxcdTEzMTdcXHUxMzVCXFx1MTM1Q1xcdTEzN0QtXFx1MTM3RlxcdTEzOUEtXFx1MTM5RlxcdTEzRjUtXFx1MTNGRlxcdTE2OUQtXFx1MTY5RlxcdTE2RjEtXFx1MTZGRlxcdTE3MERcXHUxNzE1LVxcdTE3MUZcXHUxNzM3LVxcdTE3M0ZcXHUxNzU0LVxcdTE3NUZcXHUxNzZEXFx1MTc3MVxcdTE3NzQtXFx1MTc3RlxcdTE3REVcXHUxN0RGXFx1MTdFQS1cXHUxN0VGXFx1MTdGQS1cXHUxN0ZGXFx1MTgwRlxcdTE4MUEtXFx1MTgxRlxcdTE4NzgtXFx1MTg3RlxcdTE4QUItXFx1MThBRlxcdTE4RjYtXFx1MThGRlxcdTE5MUQtXFx1MTkxRlxcdTE5MkMtXFx1MTkyRlxcdTE5M0MtXFx1MTkzRlxcdTE5NDEtXFx1MTk0M1xcdTE5NkVcXHUxOTZGXFx1MTk3NS1cXHUxOTdGXFx1MTlBQy1cXHUxOUFGXFx1MTlDQS1cXHUxOUNGXFx1MTlEQi1cXHUxOUREXFx1MUExQ1xcdTFBMURcXHUxQTVGXFx1MUE3RFxcdTFBN0VcXHUxQThBLVxcdTFBOEZcXHUxQTlBLVxcdTFBOUZcXHUxQUFFLVxcdTFBRkZcXHUxQjRDLVxcdTFCNEZcXHUxQjdELVxcdTFCN0ZcXHUxQkY0LVxcdTFCRkJcXHUxQzM4LVxcdTFDM0FcXHUxQzRBLVxcdTFDNENcXHUxQzgwLVxcdTFDQkZcXHUxQ0M4LVxcdTFDQ0ZcXHUxQ0Y3LVxcdTFDRkZcXHUxREU3LVxcdTFERkJcXHUxRjE2XFx1MUYxN1xcdTFGMUVcXHUxRjFGXFx1MUY0NlxcdTFGNDdcXHUxRjRFXFx1MUY0RlxcdTFGNThcXHUxRjVBXFx1MUY1Q1xcdTFGNUVcXHUxRjdFXFx1MUY3RlxcdTFGQjVcXHUxRkM1XFx1MUZENFxcdTFGRDVcXHUxRkRDXFx1MUZGMFxcdTFGRjFcXHUxRkY1XFx1MUZGRlxcdTIwMEItXFx1MjAwRlxcdTIwMkEtXFx1MjAyRVxcdTIwNjAtXFx1MjA2RlxcdTIwNzJcXHUyMDczXFx1MjA4RlxcdTIwOUQtXFx1MjA5RlxcdTIwQkEtXFx1MjBDRlxcdTIwRjEtXFx1MjBGRlxcdTIxOEEtXFx1MjE4RlxcdTIzRjQtXFx1MjNGRlxcdTI0MjctXFx1MjQzRlxcdTI0NEItXFx1MjQ1RlxcdTI3MDBcXHUyQjRELVxcdTJCNEZcXHUyQjVBLVxcdTJCRkZcXHUyQzJGXFx1MkM1RlxcdTJDRjQtXFx1MkNGOFxcdTJEMjZcXHUyRDI4LVxcdTJEMkNcXHUyRDJFXFx1MkQyRlxcdTJENjgtXFx1MkQ2RVxcdTJENzEtXFx1MkQ3RVxcdTJEOTctXFx1MkQ5RlxcdTJEQTdcXHUyREFGXFx1MkRCN1xcdTJEQkZcXHUyREM3XFx1MkRDRlxcdTJERDdcXHUyRERGXFx1MkUzQy1cXHUyRTdGXFx1MkU5QVxcdTJFRjQtXFx1MkVGRlxcdTJGRDYtXFx1MkZFRlxcdTJGRkMtXFx1MkZGRlxcdTMwNDBcXHUzMDk3XFx1MzA5OFxcdTMxMDAtXFx1MzEwNFxcdTMxMkUtXFx1MzEzMFxcdTMxOEZcXHUzMUJCLVxcdTMxQkZcXHUzMUU0LVxcdTMxRUZcXHUzMjFGXFx1MzJGRlxcdTREQjYtXFx1NERCRlxcdTlGQ0QtXFx1OUZGRlxcdUE0OEQtXFx1QTQ4RlxcdUE0QzctXFx1QTRDRlxcdUE2MkMtXFx1QTYzRlxcdUE2OTgtXFx1QTY5RVxcdUE2RjgtXFx1QTZGRlxcdUE3OEZcXHVBNzk0LVxcdUE3OUZcXHVBN0FCLVxcdUE3RjdcXHVBODJDLVxcdUE4MkZcXHVBODNBLVxcdUE4M0ZcXHVBODc4LVxcdUE4N0ZcXHVBOEM1LVxcdUE4Q0RcXHVBOERBLVxcdUE4REZcXHVBOEZDLVxcdUE4RkZcXHVBOTU0LVxcdUE5NUVcXHVBOTdELVxcdUE5N0ZcXHVBOUNFXFx1QTlEQS1cXHVBOUREXFx1QTlFMC1cXHVBOUZGXFx1QUEzNy1cXHVBQTNGXFx1QUE0RVxcdUFBNEZcXHVBQTVBXFx1QUE1QlxcdUFBN0MtXFx1QUE3RlxcdUFBQzMtXFx1QUFEQVxcdUFBRjctXFx1QUIwMFxcdUFCMDdcXHVBQjA4XFx1QUIwRlxcdUFCMTBcXHVBQjE3LVxcdUFCMUZcXHVBQjI3XFx1QUIyRi1cXHVBQkJGXFx1QUJFRVxcdUFCRUZcXHVBQkZBLVxcdUFCRkZcXHVEN0E0LVxcdUQ3QUZcXHVEN0M3LVxcdUQ3Q0FcXHVEN0ZDLVxcdUY4RkZcXHVGQTZFXFx1RkE2RlxcdUZBREEtXFx1RkFGRlxcdUZCMDctXFx1RkIxMlxcdUZCMTgtXFx1RkIxQ1xcdUZCMzdcXHVGQjNEXFx1RkIzRlxcdUZCNDJcXHVGQjQ1XFx1RkJDMi1cXHVGQkQyXFx1RkQ0MC1cXHVGRDRGXFx1RkQ5MFxcdUZEOTFcXHVGREM4LVxcdUZERUZcXHVGREZFXFx1RkRGRlxcdUZFMUEtXFx1RkUxRlxcdUZFMjctXFx1RkUyRlxcdUZFNTNcXHVGRTY3XFx1RkU2Qy1cXHVGRTZGXFx1RkU3NVxcdUZFRkQtXFx1RkYwMFxcdUZGQkYtXFx1RkZDMVxcdUZGQzhcXHVGRkM5XFx1RkZEMFxcdUZGRDFcXHVGRkQ4XFx1RkZEOVxcdUZGREQtXFx1RkZERlxcdUZGRTdcXHVGRkVGLVxcdUZGRkJcXHVGRkZFXFx1RkZGRl0vOyAvLyBPdGhlciAoY29udHJvbCwgZm9ybWF0LCBwcml2YXRlIHVzZSwgc3Vycm9nYXRlLCBhbmQgdW5hc3NpZ25lZCBjb2RlcylcblxuICAgIHZhciB1bmljb2RlUGFja2FnZU5hbWVzTWFwcGluZyA9IHtcbiAgICAgICAgTDogdW5pY29kZVJlZ0V4cC5sZXR0ZXIsXG4gICAgICAgIE06IHVuaWNvZGVSZWdFeHAubWFyayxcbiAgICAgICAgTjogdW5pY29kZVJlZ0V4cC5udW1iZXIsXG4gICAgICAgIFA6IHVuaWNvZGVSZWdFeHAucHVuY3R1YXRpb24sXG4gICAgICAgIFM6IHVuaWNvZGVSZWdFeHAuc3ltYm9sLFxuICAgICAgICBaOiB1bmljb2RlUmVnRXhwLnNlcGFyYXRvcixcbiAgICAgICAgQzogdW5pY29kZVJlZ0V4cC5vdGhlcixcbiAgICAgICAgbGV0dGVyOiB1bmljb2RlUmVnRXhwLmxldHRlcixcbiAgICAgICAgbWFyazogdW5pY29kZVJlZ0V4cC5tYXJrLFxuICAgICAgICBudW1iZXI6IHVuaWNvZGVSZWdFeHAubnVtYmVyLFxuICAgICAgICBkaWdpdDogdW5pY29kZVJlZ0V4cC5udW1iZXIsXG4gICAgICAgIHB1bmN0dWF0aW9uOiB1bmljb2RlUmVnRXhwLnB1bmN0dWF0aW9uLFxuICAgICAgICBzeW1ib2w6IHVuaWNvZGVSZWdFeHAuc3ltYm9sLFxuICAgICAgICBzZXBhcmF0b3I6IHVuaWNvZGVSZWdFeHAuc2VwYXJhdG9yLFxuICAgICAgICBvdGhlcjogdW5pY29kZVJlZ0V4cC5vdGhlclxuICAgIH07XG5cbiAgICB1bmljb2RlUmVnRXhwLnVuaWNvZGVQYWNrYWdlTmFtZVJlZ0V4cCA9IG5ldyBSZWdFeHAoJ15cXFxcW1xcXFw6KFxcXFxeKT8oJyArIE9iamVjdC5rZXlzKHVuaWNvZGVQYWNrYWdlTmFtZXNNYXBwaW5nKS5qb2luKCd8JykgKyAnKVxcXFw6XFxcXF0kJyk7XG5cbiAgICB1bmljb2RlUmVnRXhwLmV4cGFuZENsZHJVbmljb2RlU2V0SWRUb0NoYXJhY3RlckNsYXNzID0gZnVuY3Rpb24gKHVuaWNvZGVTZXRJZCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1bmljb2RlU2V0SWQucmVwbGFjZSh1bmljb2RlUmVnRXhwLnVuaWNvZGVQYWNrYWdlTmFtZVJlZ0V4cCwgZnVuY3Rpb24gKCQwLCBuZWdhdGVkLCBwYWNrYWdlTmFtZSkge1xuICAgICAgICAgICAgdmFyIGNoYXJhY3RlcnMgPSB1bmljb2RlUGFja2FnZU5hbWVzTWFwcGluZ1twYWNrYWdlTmFtZV0uc291cmNlLnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgKG5lZ2F0ZWQgPyAnXicgKyBjaGFyYWN0ZXJzIDogY2hhcmFjdGVycykgKyAnXSc7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgdW5pY29kZVJlZ0V4cC5zcGxpY2VDaGFyYWN0ZXJDbGFzc1JlZ0V4cHMgPSBmdW5jdGlvbiAoKSB7IC8vIC4uLlxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ1snICsgYXJncy5tYXAoZnVuY3Rpb24gKHJlZ0V4cCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ0V4cC5zb3VyY2UucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgfSkuam9pbihcIlwiKSArICddJyk7XG4gICAgfTtcblxuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgY29tYmluZWQsIGV4Y2VwdCAnc2VwYXJhdG9yJywgYW5kICdvdGhlcic6XG4gICAgdW5pY29kZVJlZ0V4cC52aXNpYmxlID0gdW5pY29kZVJlZ0V4cC5zcGxpY2VDaGFyYWN0ZXJDbGFzc1JlZ0V4cHMoXG4gICAgICAgIHVuaWNvZGVSZWdFeHAubGV0dGVyLFxuICAgICAgICB1bmljb2RlUmVnRXhwLm1hcmssXG4gICAgICAgIHVuaWNvZGVSZWdFeHAubnVtYmVyLFxuICAgICAgICB1bmljb2RlUmVnRXhwLnB1bmN0dWF0aW9uLFxuICAgICAgICB1bmljb2RlUmVnRXhwLnN5bWJvbFxuICAgICk7XG5cbiAgICAvLyBUaGUgc2V0IG9mIHByaW50YWJsZSBjaGFyYWN0ZXJzIGFsc28gaW5jbHVkZXMgc3BhY2U6XG4gICAgdW5pY29kZVJlZ0V4cC5wcmludGFibGUgPSB1bmljb2RlUmVnRXhwLnNwbGljZUNoYXJhY3RlckNsYXNzUmVnRXhwcyhcbiAgICAgICAgdW5pY29kZVJlZ0V4cC52aXNpYmxlLFxuICAgICAgICB1bmljb2RlUmVnRXhwLnNlcGFyYXRvclxuICAgICk7XG5cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIHJlbW92aW5nIGEgY2hhciBmcm9tIGEgY2hhcmFjdGVyIGNsYXNzIHJlZ3VsYXIgZXhwcmVzc2lvbjpcblxuICAgIGZ1bmN0aW9uIHBhcnNlQ2hhckNvZGUodTQsIHgyLCBsaXRlcmFsKSB7XG4gICAgICAgIGlmICh1NCB8fCB4Mikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHU0IHx8IHgyLCAxNik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbGl0ZXJhbC5jaGFyQ29kZUF0KDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hhckNvZGVUb1JlZ0V4cFRva2VuKGNoYXJDb2RlKSB7XG4gICAgICAgIGlmIChjaGFyQ29kZSA+PSAweDIwICYmIGNoYXJDb2RlIDwgMHg3Zikge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhleFN0ciA9IGNoYXJDb2RlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIHJldHVybiBcIlxcXFx1XCIgKyBcIjAwMDBcIi5zbGljZShoZXhTdHIubGVuZ3RoKSArIGhleFN0cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFyYWN0ZXJDbGFzc1Rva2VuID0gLyg/OlxcXFx1KFswLTlhLWZdezR9KXxcXFxceChbMC05YS1mXXsyfSl8KFteXFwtXSkpKD86LSg/OlxcXFx1KFswLTlhLWZdezR9KXxcXFxceChbMC05YS1mXXsyfSl8KFteXFwtXSkpKT8vZ2k7XG5cbiAgICB1bmljb2RlUmVnRXhwLnJlbW92ZUNoYXJhY3RlckZyb21DaGFyYWN0ZXJDbGFzc1JlZ0V4cCA9IGZ1bmN0aW9uIChyZWdFeHAsIGNoKSB7XG4gICAgICAgIHZhciBjaGFyQ29kZSA9IGNoLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ1snICsgcmVnRXhwLnNvdXJjZS5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpLnJlcGxhY2UoY2hhcmFjdGVyQ2xhc3NUb2tlbiwgZnVuY3Rpb24gKCQwLCBmcm9tVTQsIGZyb21YMiwgZnJvbUxpdGVyYWwsIHRvVTQsIHRvWDIsIHRvTGl0ZXJhbCkge1xuICAgICAgICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IHBhcnNlQ2hhckNvZGUoZnJvbVU0LCBmcm9tWDIsIGZyb21MaXRlcmFsKTtcbiAgICAgICAgICAgIGlmICh0b1U0IHx8IHRvWDIgfHwgdG9MaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvQ2hhckNvZGUgPSBwYXJzZUNoYXJDb2RlKHRvVTQsIHRvWDIsIHRvTGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09PSBmcm9tQ2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlICsgMSA8IHRvQ2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFyQ29kZVRvUmVnRXhwVG9rZW4oY2hhckNvZGUgKyAxKSArICctJyArIGNoYXJDb2RlVG9SZWdFeHBUb2tlbih0b0NoYXJDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFyQ29kZVRvUmVnRXhwVG9rZW4odG9DaGFyQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09PSB0b0NoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tQ2hhckNvZGUgPCBjaGFyQ29kZSAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFyQ29kZVRvUmVnRXhwVG9rZW4oZnJvbUNoYXJDb2RlKSArICctJyArIGNoYXJDb2RlVG9SZWdFeHBUb2tlbihjaGFyQ29kZSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbUNoYXJDb2RlID09PSB0b0NoYXJDb2RlIC0gMSwgcmV3cml0ZSB0byBzaW5nbGUgY2hhclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJDb2RlVG9SZWdFeHBUb2tlbihmcm9tQ2hhckNvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA+IGZyb21DaGFyQ29kZSAmJiBjaGFyQ29kZSA8IHRvQ2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJDb2RlVG9SZWdFeHBUb2tlbihmcm9tQ2hhckNvZGUpICsgKGNoYXJDb2RlID4gZnJvbUNoYXJDb2RlICsgMSA/ICctJyArIGNoYXJDb2RlVG9SZWdFeHBUb2tlbihjaGFyQ29kZSAtIDEpIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChjaGFyQ29kZSArIDEgPCB0b0NoYXJDb2RlID8gY2hhckNvZGVUb1JlZ0V4cFRva2VuKGNoYXJDb2RlICsgMSkgKyAnLScgOiAnJykgKyBjaGFyQ29kZVRvUmVnRXhwVG9rZW4odG9DaGFyQ29kZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09PSBmcm9tQ2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJDb2RlVG9SZWdFeHBUb2tlbihmcm9tQ2hhckNvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkgKyAnXScpO1xuICAgIH07XG5cbiAgICByZXR1cm4gdW5pY29kZVJlZ0V4cDtcbn0pKTtcbiIsImZ1bmN0aW9uIERPTVBhcnNlcihvcHRpb25zKXtcclxuXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8e2xvY2F0b3I6e319O1xyXG5cdFxyXG59XHJcbkRPTVBhcnNlci5wcm90b3R5cGUucGFyc2VGcm9tU3RyaW5nID0gZnVuY3Rpb24oc291cmNlLG1pbWVUeXBlKXtcdFxyXG5cdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cdHZhciBzYXggPSAgbmV3IFhNTFJlYWRlcigpO1xyXG5cdHZhciBkb21CdWlsZGVyID0gb3B0aW9ucy5kb21CdWlsZGVyIHx8IG5ldyBET01IYW5kbGVyKCk7Ly9jb250ZW50SGFuZGxlciBhbmQgTGV4aWNhbEhhbmRsZXJcclxuXHR2YXIgZXJyb3JIYW5kbGVyID0gb3B0aW9ucy5lcnJvckhhbmRsZXI7XHJcblx0dmFyIGxvY2F0b3IgPSBvcHRpb25zLmxvY2F0b3I7XHJcblx0dmFyIGRlZmF1bHROU01hcCA9IG9wdGlvbnMueG1sbnN8fHt9O1xyXG5cdHZhciBlbnRpdHlNYXAgPSB7J2x0JzonPCcsJ2d0JzonPicsJ2FtcCc6JyYnLCdxdW90JzonXCInLCdhcG9zJzpcIidcIn1cclxuXHRpZihsb2NhdG9yKXtcclxuXHRcdGRvbUJ1aWxkZXIuc2V0RG9jdW1lbnRMb2NhdG9yKGxvY2F0b3IpXHJcblx0fVxyXG5cdFxyXG5cdHNheC5lcnJvckhhbmRsZXIgPSBidWlsZEVycm9ySGFuZGxlcihlcnJvckhhbmRsZXIsZG9tQnVpbGRlcixsb2NhdG9yKTtcclxuXHRzYXguZG9tQnVpbGRlciA9IG9wdGlvbnMuZG9tQnVpbGRlciB8fCBkb21CdWlsZGVyO1xyXG5cdGlmKC9cXC94P2h0bWw/JC8udGVzdChtaW1lVHlwZSkpe1xyXG5cdFx0ZW50aXR5TWFwLm5ic3AgPSAnXFx4YTAnO1xyXG5cdFx0ZW50aXR5TWFwLmNvcHkgPSAnXFx4YTknO1xyXG5cdFx0ZGVmYXVsdE5TTWFwWycnXT0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xyXG5cdH1cclxuXHRpZihzb3VyY2Upe1xyXG5cdFx0c2F4LnBhcnNlKHNvdXJjZSxkZWZhdWx0TlNNYXAsZW50aXR5TWFwKTtcclxuXHR9ZWxzZXtcclxuXHRcdHNheC5lcnJvckhhbmRsZXIuZXJyb3IoXCJpbnZhbGlkIGRvY3VtZW50IHNvdXJjZVwiKTtcclxuXHR9XHJcblx0cmV0dXJuIGRvbUJ1aWxkZXIuZG9jdW1lbnQ7XHJcbn1cclxuZnVuY3Rpb24gYnVpbGRFcnJvckhhbmRsZXIoZXJyb3JJbXBsLGRvbUJ1aWxkZXIsbG9jYXRvcil7XHJcblx0aWYoIWVycm9ySW1wbCl7XHJcblx0XHRpZihkb21CdWlsZGVyIGluc3RhbmNlb2YgRE9NSGFuZGxlcil7XHJcblx0XHRcdHJldHVybiBkb21CdWlsZGVyO1xyXG5cdFx0fVxyXG5cdFx0ZXJyb3JJbXBsID0gZG9tQnVpbGRlciA7XHJcblx0fVxyXG5cdHZhciBlcnJvckhhbmRsZXIgPSB7fVxyXG5cdHZhciBpc0NhbGxiYWNrID0gZXJyb3JJbXBsIGluc3RhbmNlb2YgRnVuY3Rpb247XHJcblx0bG9jYXRvciA9IGxvY2F0b3J8fHt9XHJcblx0ZnVuY3Rpb24gYnVpbGQoa2V5KXtcclxuXHRcdHZhciBmbiA9IGVycm9ySW1wbFtrZXldO1xyXG5cdFx0aWYoIWZuKXtcclxuXHRcdFx0aWYoaXNDYWxsYmFjayl7XHJcblx0XHRcdFx0Zm4gPSBlcnJvckltcGwubGVuZ3RoID09IDI/ZnVuY3Rpb24obXNnKXtlcnJvckltcGwoa2V5LG1zZyl9OmVycm9ySW1wbDtcclxuXHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0dmFyIGk9YXJndW1lbnRzLmxlbmd0aDtcclxuXHRcdFx0XHR3aGlsZSgtLWkpe1xyXG5cdFx0XHRcdFx0aWYoZm4gPSBlcnJvckltcGxbYXJndW1lbnRzW2ldXSl7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZXJyb3JIYW5kbGVyW2tleV0gPSBmbiAmJiBmdW5jdGlvbihtc2cpe1xyXG5cdFx0XHRmbihtc2crX2xvY2F0b3IobG9jYXRvcikpO1xyXG5cdFx0fXx8ZnVuY3Rpb24oKXt9O1xyXG5cdH1cclxuXHRidWlsZCgnd2FybmluZycsJ3dhcm4nKTtcclxuXHRidWlsZCgnZXJyb3InLCd3YXJuJywnd2FybmluZycpO1xyXG5cdGJ1aWxkKCdmYXRhbEVycm9yJywnd2FybicsJ3dhcm5pbmcnLCdlcnJvcicpO1xyXG5cdHJldHVybiBlcnJvckhhbmRsZXI7XHJcbn1cclxuLyoqXHJcbiAqICtDb250ZW50SGFuZGxlcitFcnJvckhhbmRsZXJcclxuICogK0xleGljYWxIYW5kbGVyK0VudGl0eVJlc29sdmVyMlxyXG4gKiAtRGVjbEhhbmRsZXItRFRESGFuZGxlciBcclxuICogXHJcbiAqIERlZmF1bHRIYW5kbGVyOkVudGl0eVJlc29sdmVyLCBEVERIYW5kbGVyLCBDb250ZW50SGFuZGxlciwgRXJyb3JIYW5kbGVyXHJcbiAqIERlZmF1bHRIYW5kbGVyMjpEZWZhdWx0SGFuZGxlcixMZXhpY2FsSGFuZGxlciwgRGVjbEhhbmRsZXIsIEVudGl0eVJlc29sdmVyMlxyXG4gKiBAbGluayBodHRwOi8vd3d3LnNheHByb2plY3Qub3JnL2FwaWRvYy9vcmcveG1sL3NheC9oZWxwZXJzL0RlZmF1bHRIYW5kbGVyLmh0bWxcclxuICovXHJcbmZ1bmN0aW9uIERPTUhhbmRsZXIoKSB7XHJcbiAgICB0aGlzLmNkYXRhID0gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gcG9zaXRpb24obG9jYXRvcixub2RlKXtcclxuXHRub2RlLmxpbmVOdW1iZXIgPSBsb2NhdG9yLmxpbmVOdW1iZXI7XHJcblx0bm9kZS5jb2x1bW5OdW1iZXIgPSBsb2NhdG9yLmNvbHVtbk51bWJlcjtcclxufVxyXG4vKipcclxuICogQHNlZSBvcmcueG1sLnNheC5Db250ZW50SGFuZGxlciNzdGFydERvY3VtZW50XHJcbiAqIEBsaW5rIGh0dHA6Ly93d3cuc2F4cHJvamVjdC5vcmcvYXBpZG9jL29yZy94bWwvc2F4L0NvbnRlbnRIYW5kbGVyLmh0bWxcclxuICovIFxyXG5ET01IYW5kbGVyLnByb3RvdHlwZSA9IHtcclxuXHRzdGFydERvY3VtZW50IDogZnVuY3Rpb24oKSB7XHJcbiAgICBcdHRoaXMuZG9jdW1lbnQgPSBuZXcgRE9NSW1wbGVtZW50YXRpb24oKS5jcmVhdGVEb2N1bWVudChudWxsLCBudWxsLCBudWxsKTtcclxuICAgIFx0aWYgKHRoaXMubG9jYXRvcikge1xyXG4gICAgICAgIFx0dGhpcy5kb2N1bWVudC5kb2N1bWVudFVSSSA9IHRoaXMubG9jYXRvci5zeXN0ZW1JZDtcclxuICAgIFx0fVxyXG5cdH0sXHJcblx0c3RhcnRFbGVtZW50OmZ1bmN0aW9uKG5hbWVzcGFjZVVSSSwgbG9jYWxOYW1lLCBxTmFtZSwgYXR0cnMpIHtcclxuXHRcdHZhciBkb2MgPSB0aGlzLmRvY3VtZW50O1xyXG5cdCAgICB2YXIgZWwgPSBkb2MuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgcU5hbWV8fGxvY2FsTmFtZSk7XHJcblx0ICAgIHZhciBsZW4gPSBhdHRycy5sZW5ndGg7XHJcblx0ICAgIGFwcGVuZEVsZW1lbnQodGhpcywgZWwpO1xyXG5cdCAgICB0aGlzLmN1cnJlbnRFbGVtZW50ID0gZWw7XHJcblx0ICAgIFxyXG5cdFx0dGhpcy5sb2NhdG9yICYmIHBvc2l0aW9uKHRoaXMubG9jYXRvcixlbClcclxuXHQgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgbGVuOyBpKyspIHtcclxuXHQgICAgICAgIHZhciBuYW1lc3BhY2VVUkkgPSBhdHRycy5nZXRVUkkoaSk7XHJcblx0ICAgICAgICB2YXIgdmFsdWUgPSBhdHRycy5nZXRWYWx1ZShpKTtcclxuXHQgICAgICAgIHZhciBxTmFtZSA9IGF0dHJzLmdldFFOYW1lKGkpO1xyXG5cdFx0XHR2YXIgYXR0ciA9IGRvYy5jcmVhdGVBdHRyaWJ1dGVOUyhuYW1lc3BhY2VVUkksIHFOYW1lKTtcclxuXHRcdFx0aWYoIGF0dHIuZ2V0T2Zmc2V0KXtcclxuXHRcdFx0XHRwb3NpdGlvbihhdHRyLmdldE9mZnNldCgxKSxhdHRyKVxyXG5cdFx0XHR9XHJcblx0XHRcdGF0dHIudmFsdWUgPSBhdHRyLm5vZGVWYWx1ZSA9IHZhbHVlO1xyXG5cdFx0XHRlbC5zZXRBdHRyaWJ1dGVOb2RlKGF0dHIpXHJcblx0ICAgIH1cclxuXHR9LFxyXG5cdGVuZEVsZW1lbnQ6ZnVuY3Rpb24obmFtZXNwYWNlVVJJLCBsb2NhbE5hbWUsIHFOYW1lKSB7XHJcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudEVsZW1lbnRcclxuXHQgICAgdmFyIHRhZ05hbWUgPSBjdXJyZW50LnRhZ05hbWU7XHJcblx0ICAgIHRoaXMuY3VycmVudEVsZW1lbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XHJcblx0fSxcclxuXHRzdGFydFByZWZpeE1hcHBpbmc6ZnVuY3Rpb24ocHJlZml4LCB1cmkpIHtcclxuXHR9LFxyXG5cdGVuZFByZWZpeE1hcHBpbmc6ZnVuY3Rpb24ocHJlZml4KSB7XHJcblx0fSxcclxuXHRwcm9jZXNzaW5nSW5zdHJ1Y3Rpb246ZnVuY3Rpb24odGFyZ2V0LCBkYXRhKSB7XHJcblx0ICAgIHZhciBpbnMgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZVByb2Nlc3NpbmdJbnN0cnVjdGlvbih0YXJnZXQsIGRhdGEpO1xyXG5cdCAgICB0aGlzLmxvY2F0b3IgJiYgcG9zaXRpb24odGhpcy5sb2NhdG9yLGlucylcclxuXHQgICAgYXBwZW5kRWxlbWVudCh0aGlzLCBpbnMpO1xyXG5cdH0sXHJcblx0aWdub3JhYmxlV2hpdGVzcGFjZTpmdW5jdGlvbihjaCwgc3RhcnQsIGxlbmd0aCkge1xyXG5cdH0sXHJcblx0Y2hhcmFjdGVyczpmdW5jdGlvbihjaGFycywgc3RhcnQsIGxlbmd0aCkge1xyXG5cdFx0Y2hhcnMgPSBfdG9TdHJpbmcuYXBwbHkodGhpcyxhcmd1bWVudHMpXHJcblx0XHQvL2NvbnNvbGUubG9nKGNoYXJzKVxyXG5cdFx0aWYodGhpcy5jdXJyZW50RWxlbWVudCAmJiBjaGFycyl7XHJcblx0XHRcdGlmICh0aGlzLmNkYXRhKSB7XHJcblx0XHRcdFx0dmFyIGNoYXJOb2RlID0gdGhpcy5kb2N1bWVudC5jcmVhdGVDREFUQVNlY3Rpb24oY2hhcnMpO1xyXG5cdFx0XHRcdHRoaXMuY3VycmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoY2hhck5vZGUpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBjaGFyTm9kZSA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hhcnMpO1xyXG5cdFx0XHRcdHRoaXMuY3VycmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoY2hhck5vZGUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMubG9jYXRvciAmJiBwb3NpdGlvbih0aGlzLmxvY2F0b3IsY2hhck5vZGUpXHJcblx0XHR9XHJcblx0fSxcclxuXHRza2lwcGVkRW50aXR5OmZ1bmN0aW9uKG5hbWUpIHtcclxuXHR9LFxyXG5cdGVuZERvY3VtZW50OmZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5kb2N1bWVudC5ub3JtYWxpemUoKTtcclxuXHR9LFxyXG5cdHNldERvY3VtZW50TG9jYXRvcjpmdW5jdGlvbiAobG9jYXRvcikge1xyXG5cdCAgICBpZih0aGlzLmxvY2F0b3IgPSBsb2NhdG9yKXsvLyAmJiAhKCdsaW5lTnVtYmVyJyBpbiBsb2NhdG9yKSl7XHJcblx0ICAgIFx0bG9jYXRvci5saW5lTnVtYmVyID0gMDtcclxuXHQgICAgfVxyXG5cdH0sXHJcblx0Ly9MZXhpY2FsSGFuZGxlclxyXG5cdGNvbW1lbnQ6ZnVuY3Rpb24oY2hhcnMsIHN0YXJ0LCBsZW5ndGgpIHtcclxuXHRcdGNoYXJzID0gX3RvU3RyaW5nLmFwcGx5KHRoaXMsYXJndW1lbnRzKVxyXG5cdCAgICB2YXIgY29tbSA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlQ29tbWVudChjaGFycyk7XHJcblx0ICAgIHRoaXMubG9jYXRvciAmJiBwb3NpdGlvbih0aGlzLmxvY2F0b3IsY29tbSlcclxuXHQgICAgYXBwZW5kRWxlbWVudCh0aGlzLCBjb21tKTtcclxuXHR9LFxyXG5cdFxyXG5cdHN0YXJ0Q0RBVEE6ZnVuY3Rpb24oKSB7XHJcblx0ICAgIC8vdXNlZCBpbiBjaGFyYWN0ZXJzKCkgbWV0aG9kc1xyXG5cdCAgICB0aGlzLmNkYXRhID0gdHJ1ZTtcclxuXHR9LFxyXG5cdGVuZENEQVRBOmZ1bmN0aW9uKCkge1xyXG5cdCAgICB0aGlzLmNkYXRhID0gZmFsc2U7XHJcblx0fSxcclxuXHRcclxuXHRzdGFydERURDpmdW5jdGlvbihuYW1lLCBwdWJsaWNJZCwgc3lzdGVtSWQpIHtcclxuXHRcdHZhciBpbXBsID0gdGhpcy5kb2N1bWVudC5pbXBsZW1lbnRhdGlvbjtcclxuXHQgICAgaWYgKGltcGwgJiYgaW1wbC5jcmVhdGVEb2N1bWVudFR5cGUpIHtcclxuXHQgICAgICAgIHZhciBkdCA9IGltcGwuY3JlYXRlRG9jdW1lbnRUeXBlKG5hbWUsIHB1YmxpY0lkLCBzeXN0ZW1JZCk7XHJcblx0ICAgICAgICB0aGlzLmxvY2F0b3IgJiYgcG9zaXRpb24odGhpcy5sb2NhdG9yLGR0KVxyXG5cdCAgICAgICAgYXBwZW5kRWxlbWVudCh0aGlzLCBkdCk7XHJcblx0ICAgIH1cclxuXHR9LFxyXG5cdC8qKlxyXG5cdCAqIEBzZWUgb3JnLnhtbC5zYXguRXJyb3JIYW5kbGVyXHJcblx0ICogQGxpbmsgaHR0cDovL3d3dy5zYXhwcm9qZWN0Lm9yZy9hcGlkb2Mvb3JnL3htbC9zYXgvRXJyb3JIYW5kbGVyLmh0bWxcclxuXHQgKi9cclxuXHR3YXJuaW5nOmZ1bmN0aW9uKGVycm9yKSB7XHJcblx0XHRjb25zb2xlLndhcm4oZXJyb3IsX2xvY2F0b3IodGhpcy5sb2NhdG9yKSk7XHJcblx0fSxcclxuXHRlcnJvcjpmdW5jdGlvbihlcnJvcikge1xyXG5cdFx0Y29uc29sZS5lcnJvcihlcnJvcixfbG9jYXRvcih0aGlzLmxvY2F0b3IpKTtcclxuXHR9LFxyXG5cdGZhdGFsRXJyb3I6ZnVuY3Rpb24oZXJyb3IpIHtcclxuXHRcdGNvbnNvbGUuZXJyb3IoZXJyb3IsX2xvY2F0b3IodGhpcy5sb2NhdG9yKSk7XHJcblx0ICAgIHRocm93IGVycm9yO1xyXG5cdH1cclxufVxyXG5mdW5jdGlvbiBfbG9jYXRvcihsKXtcclxuXHRpZihsKXtcclxuXHRcdHJldHVybiAnXFxuQCcrKGwuc3lzdGVtSWQgfHwnJykrJyNbbGluZTonK2wubGluZU51bWJlcisnLGNvbDonK2wuY29sdW1uTnVtYmVyKyddJ1xyXG5cdH1cclxufVxyXG5mdW5jdGlvbiBfdG9TdHJpbmcoY2hhcnMsc3RhcnQsbGVuZ3RoKXtcclxuXHRpZih0eXBlb2YgY2hhcnMgPT0gJ3N0cmluZycpe1xyXG5cdFx0cmV0dXJuIGNoYXJzLnN1YnN0cihzdGFydCxsZW5ndGgpXHJcblx0fWVsc2V7Ly9qYXZhIHNheCBjb25uZWN0IHdpZHRoIHhtbGRvbSBvbiByaGlubyh3aGF0IGFib3V0OiBcIj8gJiYgIShjaGFycyBpbnN0YW5jZW9mIFN0cmluZylcIilcclxuXHRcdGlmKGNoYXJzLmxlbmd0aCA+PSBzdGFydCtsZW5ndGggfHwgc3RhcnQpe1xyXG5cdFx0XHRyZXR1cm4gbmV3IGphdmEubGFuZy5TdHJpbmcoY2hhcnMsc3RhcnQsbGVuZ3RoKSsnJztcclxuXHRcdH1cclxuXHRcdHJldHVybiBjaGFycztcclxuXHR9XHJcbn1cclxuXHJcbi8qXHJcbiAqIEBsaW5rIGh0dHA6Ly93d3cuc2F4cHJvamVjdC5vcmcvYXBpZG9jL29yZy94bWwvc2F4L2V4dC9MZXhpY2FsSGFuZGxlci5odG1sXHJcbiAqIHVzZWQgbWV0aG9kIG9mIG9yZy54bWwuc2F4LmV4dC5MZXhpY2FsSGFuZGxlcjpcclxuICogICNjb21tZW50KGNoYXJzLCBzdGFydCwgbGVuZ3RoKVxyXG4gKiAgI3N0YXJ0Q0RBVEEoKVxyXG4gKiAgI2VuZENEQVRBKClcclxuICogICNzdGFydERURChuYW1lLCBwdWJsaWNJZCwgc3lzdGVtSWQpXHJcbiAqXHJcbiAqXHJcbiAqIElHTk9SRUQgbWV0aG9kIG9mIG9yZy54bWwuc2F4LmV4dC5MZXhpY2FsSGFuZGxlcjpcclxuICogICNlbmREVEQoKVxyXG4gKiAgI3N0YXJ0RW50aXR5KG5hbWUpXHJcbiAqICAjZW5kRW50aXR5KG5hbWUpXHJcbiAqXHJcbiAqXHJcbiAqIEBsaW5rIGh0dHA6Ly93d3cuc2F4cHJvamVjdC5vcmcvYXBpZG9jL29yZy94bWwvc2F4L2V4dC9EZWNsSGFuZGxlci5odG1sXHJcbiAqIElHTk9SRUQgbWV0aG9kIG9mIG9yZy54bWwuc2F4LmV4dC5EZWNsSGFuZGxlclxyXG4gKiBcdCNhdHRyaWJ1dGVEZWNsKGVOYW1lLCBhTmFtZSwgdHlwZSwgbW9kZSwgdmFsdWUpXHJcbiAqICAjZWxlbWVudERlY2wobmFtZSwgbW9kZWwpXHJcbiAqICAjZXh0ZXJuYWxFbnRpdHlEZWNsKG5hbWUsIHB1YmxpY0lkLCBzeXN0ZW1JZClcclxuICogICNpbnRlcm5hbEVudGl0eURlY2wobmFtZSwgdmFsdWUpXHJcbiAqIEBsaW5rIGh0dHA6Ly93d3cuc2F4cHJvamVjdC5vcmcvYXBpZG9jL29yZy94bWwvc2F4L2V4dC9FbnRpdHlSZXNvbHZlcjIuaHRtbFxyXG4gKiBJR05PUkVEIG1ldGhvZCBvZiBvcmcueG1sLnNheC5FbnRpdHlSZXNvbHZlcjJcclxuICogICNyZXNvbHZlRW50aXR5KFN0cmluZyBuYW1lLFN0cmluZyBwdWJsaWNJZCxTdHJpbmcgYmFzZVVSSSxTdHJpbmcgc3lzdGVtSWQpXHJcbiAqICAjcmVzb2x2ZUVudGl0eShwdWJsaWNJZCwgc3lzdGVtSWQpXHJcbiAqICAjZ2V0RXh0ZXJuYWxTdWJzZXQobmFtZSwgYmFzZVVSSSlcclxuICogQGxpbmsgaHR0cDovL3d3dy5zYXhwcm9qZWN0Lm9yZy9hcGlkb2Mvb3JnL3htbC9zYXgvRFRESGFuZGxlci5odG1sXHJcbiAqIElHTk9SRUQgbWV0aG9kIG9mIG9yZy54bWwuc2F4LkRUREhhbmRsZXJcclxuICogICNub3RhdGlvbkRlY2wobmFtZSwgcHVibGljSWQsIHN5c3RlbUlkKSB7fTtcclxuICogICN1bnBhcnNlZEVudGl0eURlY2wobmFtZSwgcHVibGljSWQsIHN5c3RlbUlkLCBub3RhdGlvbk5hbWUpIHt9O1xyXG4gKi9cclxuXCJlbmREVEQsc3RhcnRFbnRpdHksZW5kRW50aXR5LGF0dHJpYnV0ZURlY2wsZWxlbWVudERlY2wsZXh0ZXJuYWxFbnRpdHlEZWNsLGludGVybmFsRW50aXR5RGVjbCxyZXNvbHZlRW50aXR5LGdldEV4dGVybmFsU3Vic2V0LG5vdGF0aW9uRGVjbCx1bnBhcnNlZEVudGl0eURlY2xcIi5yZXBsYWNlKC9cXHcrL2csZnVuY3Rpb24oa2V5KXtcclxuXHRET01IYW5kbGVyLnByb3RvdHlwZVtrZXldID0gZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH1cclxufSlcclxuXHJcbi8qIFByaXZhdGUgc3RhdGljIGhlbHBlcnMgdHJlYXRlZCBiZWxvdyBhcyBwcml2YXRlIGluc3RhbmNlIG1ldGhvZHMsIHNvIGRvbid0IG5lZWQgdG8gYWRkIHRoZXNlIHRvIHRoZSBwdWJsaWMgQVBJOyB3ZSBtaWdodCB1c2UgYSBSZWxhdG9yIHRvIGFsc28gZ2V0IHJpZCBvZiBub24tc3RhbmRhcmQgcHVibGljIHByb3BlcnRpZXMgKi9cclxuZnVuY3Rpb24gYXBwZW5kRWxlbWVudCAoaGFuZGVyLG5vZGUpIHtcclxuICAgIGlmICghaGFuZGVyLmN1cnJlbnRFbGVtZW50KSB7XHJcbiAgICAgICAgaGFuZGVyLmRvY3VtZW50LmFwcGVuZENoaWxkKG5vZGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBoYW5kZXIuY3VycmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQobm9kZSk7XHJcbiAgICB9XHJcbn0vL2FwcGVuZENoaWxkIGFuZCBzZXRBdHRyaWJ1dGVOUyBhcmUgcHJlZm9ybWFuY2Uga2V5XHJcblxyXG5pZih0eXBlb2YgcmVxdWlyZSA9PSAnZnVuY3Rpb24nKXtcclxuXHR2YXIgWE1MUmVhZGVyID0gcmVxdWlyZSgnLi9zYXgnKS5YTUxSZWFkZXI7XHJcblx0dmFyIERPTUltcGxlbWVudGF0aW9uID0gZXhwb3J0cy5ET01JbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vZG9tJykuRE9NSW1wbGVtZW50YXRpb247XHJcblx0ZXhwb3J0cy5YTUxTZXJpYWxpemVyID0gcmVxdWlyZSgnLi9kb20nKS5YTUxTZXJpYWxpemVyIDtcclxuXHRleHBvcnRzLkRPTVBhcnNlciA9IERPTVBhcnNlcjtcclxufVxyXG4iLCIvKlxuICogRE9NIExldmVsIDJcbiAqIE9iamVjdCBET01FeGNlcHRpb25cbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLURPTS1MZXZlbC0xL2VjbWEtc2NyaXB0LWxhbmd1YWdlLWJpbmRpbmcuaHRtbFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAwL1JFQy1ET00tTGV2ZWwtMi1Db3JlLTIwMDAxMTEzL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxuICovXG5cbmZ1bmN0aW9uIGNvcHkoc3JjLGRlc3Qpe1xuXHRmb3IodmFyIHAgaW4gc3JjKXtcblx0XHRkZXN0W3BdID0gc3JjW3BdO1xuXHR9XG59XG4vKipcbl5cXHcrXFwucHJvdG90eXBlXFwuKFtfXFx3XSspXFxzKj1cXHMqKCg/Oi4qXFx7XFxzKj9bXFxyXFxuXVtcXHNcXFNdKj9efSl8XFxTLio/KD89WztcXHJcXG5dKSk7P1xuXlxcdytcXC5wcm90b3R5cGVcXC4oW19cXHddKylcXHMqPVxccyooXFxTLio/KD89WztcXHJcXG5dKSk7P1xuICovXG5mdW5jdGlvbiBfZXh0ZW5kcyhDbGFzcyxTdXBlcil7XG5cdHZhciBwdCA9IENsYXNzLnByb3RvdHlwZTtcblx0aWYoT2JqZWN0LmNyZWF0ZSl7XG5cdFx0dmFyIHBwdCA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKVxuXHRcdHB0Ll9fcHJvdG9fXyA9IHBwdDtcblx0fVxuXHRpZighKHB0IGluc3RhbmNlb2YgU3VwZXIpKXtcblx0XHRmdW5jdGlvbiB0KCl7fTtcblx0XHR0LnByb3RvdHlwZSA9IFN1cGVyLnByb3RvdHlwZTtcblx0XHR0ID0gbmV3IHQoKTtcblx0XHRjb3B5KHB0LHQpO1xuXHRcdENsYXNzLnByb3RvdHlwZSA9IHB0ID0gdDtcblx0fVxuXHRpZihwdC5jb25zdHJ1Y3RvciAhPSBDbGFzcyl7XG5cdFx0aWYodHlwZW9mIENsYXNzICE9ICdmdW5jdGlvbicpe1xuXHRcdFx0Y29uc29sZS5lcnJvcihcInVua25vdyBDbGFzczpcIitDbGFzcylcblx0XHR9XG5cdFx0cHQuY29uc3RydWN0b3IgPSBDbGFzc1xuXHR9XG59XG52YXIgaHRtbG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnIDtcbi8vIE5vZGUgVHlwZXNcbnZhciBOb2RlVHlwZSA9IHt9XG52YXIgRUxFTUVOVF9OT0RFICAgICAgICAgICAgICAgID0gTm9kZVR5cGUuRUxFTUVOVF9OT0RFICAgICAgICAgICAgICAgID0gMTtcbnZhciBBVFRSSUJVVEVfTk9ERSAgICAgICAgICAgICAgPSBOb2RlVHlwZS5BVFRSSUJVVEVfTk9ERSAgICAgICAgICAgICAgPSAyO1xudmFyIFRFWFRfTk9ERSAgICAgICAgICAgICAgICAgICA9IE5vZGVUeXBlLlRFWFRfTk9ERSAgICAgICAgICAgICAgICAgICA9IDM7XG52YXIgQ0RBVEFfU0VDVElPTl9OT0RFICAgICAgICAgID0gTm9kZVR5cGUuQ0RBVEFfU0VDVElPTl9OT0RFICAgICAgICAgID0gNDtcbnZhciBFTlRJVFlfUkVGRVJFTkNFX05PREUgICAgICAgPSBOb2RlVHlwZS5FTlRJVFlfUkVGRVJFTkNFX05PREUgICAgICAgPSA1O1xudmFyIEVOVElUWV9OT0RFICAgICAgICAgICAgICAgICA9IE5vZGVUeXBlLkVOVElUWV9OT0RFICAgICAgICAgICAgICAgICA9IDY7XG52YXIgUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFID0gTm9kZVR5cGUuUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFID0gNztcbnZhciBDT01NRU5UX05PREUgICAgICAgICAgICAgICAgPSBOb2RlVHlwZS5DT01NRU5UX05PREUgICAgICAgICAgICAgICAgPSA4O1xudmFyIERPQ1VNRU5UX05PREUgICAgICAgICAgICAgICA9IE5vZGVUeXBlLkRPQ1VNRU5UX05PREUgICAgICAgICAgICAgICA9IDk7XG52YXIgRE9DVU1FTlRfVFlQRV9OT0RFICAgICAgICAgID0gTm9kZVR5cGUuRE9DVU1FTlRfVFlQRV9OT0RFICAgICAgICAgID0gMTA7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAgICAgID0gTm9kZVR5cGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAgICAgID0gMTE7XG52YXIgTk9UQVRJT05fTk9ERSAgICAgICAgICAgICAgID0gTm9kZVR5cGUuTk9UQVRJT05fTk9ERSAgICAgICAgICAgICAgID0gMTI7XG5cbi8vIEV4Y2VwdGlvbkNvZGVcbnZhciBFeGNlcHRpb25Db2RlID0ge31cbnZhciBFeGNlcHRpb25NZXNzYWdlID0ge307XG52YXIgSU5ERVhfU0laRV9FUlIgICAgICAgICAgICAgID0gRXhjZXB0aW9uQ29kZS5JTkRFWF9TSVpFX0VSUiAgICAgICAgICAgICAgPSAoKEV4Y2VwdGlvbk1lc3NhZ2VbMV09XCJJbmRleCBzaXplIGVycm9yXCIpLDEpO1xudmFyIERPTVNUUklOR19TSVpFX0VSUiAgICAgICAgICA9IEV4Y2VwdGlvbkNvZGUuRE9NU1RSSU5HX1NJWkVfRVJSICAgICAgICAgID0gKChFeGNlcHRpb25NZXNzYWdlWzJdPVwiRE9NU3RyaW5nIHNpemUgZXJyb3JcIiksMik7XG52YXIgSElFUkFSQ0hZX1JFUVVFU1RfRVJSICAgICAgID0gRXhjZXB0aW9uQ29kZS5ISUVSQVJDSFlfUkVRVUVTVF9FUlIgICAgICAgPSAoKEV4Y2VwdGlvbk1lc3NhZ2VbM109XCJIaWVyYXJjaHkgcmVxdWVzdCBlcnJvclwiKSwzKTtcbnZhciBXUk9OR19ET0NVTUVOVF9FUlIgICAgICAgICAgPSBFeGNlcHRpb25Db2RlLldST05HX0RPQ1VNRU5UX0VSUiAgICAgICAgICA9ICgoRXhjZXB0aW9uTWVzc2FnZVs0XT1cIldyb25nIGRvY3VtZW50XCIpLDQpO1xudmFyIElOVkFMSURfQ0hBUkFDVEVSX0VSUiAgICAgICA9IEV4Y2VwdGlvbkNvZGUuSU5WQUxJRF9DSEFSQUNURVJfRVJSICAgICAgID0gKChFeGNlcHRpb25NZXNzYWdlWzVdPVwiSW52YWxpZCBjaGFyYWN0ZXJcIiksNSk7XG52YXIgTk9fREFUQV9BTExPV0VEX0VSUiAgICAgICAgID0gRXhjZXB0aW9uQ29kZS5OT19EQVRBX0FMTE9XRURfRVJSICAgICAgICAgPSAoKEV4Y2VwdGlvbk1lc3NhZ2VbNl09XCJObyBkYXRhIGFsbG93ZWRcIiksNik7XG52YXIgTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSID0gRXhjZXB0aW9uQ29kZS5OT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlIgPSAoKEV4Y2VwdGlvbk1lc3NhZ2VbN109XCJObyBtb2RpZmljYXRpb24gYWxsb3dlZFwiKSw3KTtcbnZhciBOT1RfRk9VTkRfRVJSICAgICAgICAgICAgICAgPSBFeGNlcHRpb25Db2RlLk5PVF9GT1VORF9FUlIgICAgICAgICAgICAgICA9ICgoRXhjZXB0aW9uTWVzc2FnZVs4XT1cIk5vdCBmb3VuZFwiKSw4KTtcbnZhciBOT1RfU1VQUE9SVEVEX0VSUiAgICAgICAgICAgPSBFeGNlcHRpb25Db2RlLk5PVF9TVVBQT1JURURfRVJSICAgICAgICAgICA9ICgoRXhjZXB0aW9uTWVzc2FnZVs5XT1cIk5vdCBzdXBwb3J0ZWRcIiksOSk7XG52YXIgSU5VU0VfQVRUUklCVVRFX0VSUiAgICAgICAgID0gRXhjZXB0aW9uQ29kZS5JTlVTRV9BVFRSSUJVVEVfRVJSICAgICAgICAgPSAoKEV4Y2VwdGlvbk1lc3NhZ2VbMTBdPVwiQXR0cmlidXRlIGluIHVzZVwiKSwxMCk7XG4vL2xldmVsMlxudmFyIElOVkFMSURfU1RBVEVfRVJSICAgICAgICBcdD0gRXhjZXB0aW9uQ29kZS5JTlZBTElEX1NUQVRFX0VSUiAgICAgICAgXHQ9ICgoRXhjZXB0aW9uTWVzc2FnZVsxMV09XCJJbnZhbGlkIHN0YXRlXCIpLDExKTtcbnZhciBTWU5UQVhfRVJSICAgICAgICAgICAgICAgXHQ9IEV4Y2VwdGlvbkNvZGUuU1lOVEFYX0VSUiAgICAgICAgICAgICAgIFx0PSAoKEV4Y2VwdGlvbk1lc3NhZ2VbMTJdPVwiU3ludGF4IGVycm9yXCIpLDEyKTtcbnZhciBJTlZBTElEX01PRElGSUNBVElPTl9FUlIgXHQ9IEV4Y2VwdGlvbkNvZGUuSU5WQUxJRF9NT0RJRklDQVRJT05fRVJSIFx0PSAoKEV4Y2VwdGlvbk1lc3NhZ2VbMTNdPVwiSW52YWxpZCBtb2RpZmljYXRpb25cIiksMTMpO1xudmFyIE5BTUVTUEFDRV9FUlIgICAgICAgICAgICBcdD0gRXhjZXB0aW9uQ29kZS5OQU1FU1BBQ0VfRVJSICAgICAgICAgICBcdD0gKChFeGNlcHRpb25NZXNzYWdlWzE0XT1cIkludmFsaWQgbmFtZXNwYWNlXCIpLDE0KTtcbnZhciBJTlZBTElEX0FDQ0VTU19FUlIgICAgICAgXHQ9IEV4Y2VwdGlvbkNvZGUuSU5WQUxJRF9BQ0NFU1NfRVJSICAgICAgXHQ9ICgoRXhjZXB0aW9uTWVzc2FnZVsxNV09XCJJbnZhbGlkIGFjY2Vzc1wiKSwxNSk7XG5cblxuZnVuY3Rpb24gRE9NRXhjZXB0aW9uKGNvZGUsIG1lc3NhZ2UpIHtcblx0aWYobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKXtcblx0XHR2YXIgZXJyb3IgPSBtZXNzYWdlO1xuXHR9ZWxzZXtcblx0XHRlcnJvciA9IHRoaXM7XG5cdFx0RXJyb3IuY2FsbCh0aGlzLCBFeGNlcHRpb25NZXNzYWdlW2NvZGVdKTtcblx0XHR0aGlzLm1lc3NhZ2UgPSBFeGNlcHRpb25NZXNzYWdlW2NvZGVdO1xuXHRcdGlmKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBET01FeGNlcHRpb24pO1xuXHR9XG5cdGVycm9yLmNvZGUgPSBjb2RlO1xuXHRpZihtZXNzYWdlKSB0aGlzLm1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2UgKyBcIjogXCIgKyBtZXNzYWdlO1xuXHRyZXR1cm4gZXJyb3I7XG59O1xuRE9NRXhjZXB0aW9uLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcbmNvcHkoRXhjZXB0aW9uQ29kZSxET01FeGNlcHRpb24pXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMC9SRUMtRE9NLUxldmVsLTItQ29yZS0yMDAwMTExMy9jb3JlLmh0bWwjSUQtNTM2Mjk3MTc3XG4gKiBUaGUgTm9kZUxpc3QgaW50ZXJmYWNlIHByb3ZpZGVzIHRoZSBhYnN0cmFjdGlvbiBvZiBhbiBvcmRlcmVkIGNvbGxlY3Rpb24gb2Ygbm9kZXMsIHdpdGhvdXQgZGVmaW5pbmcgb3IgY29uc3RyYWluaW5nIGhvdyB0aGlzIGNvbGxlY3Rpb24gaXMgaW1wbGVtZW50ZWQuIE5vZGVMaXN0IG9iamVjdHMgaW4gdGhlIERPTSBhcmUgbGl2ZS5cbiAqIFRoZSBpdGVtcyBpbiB0aGUgTm9kZUxpc3QgYXJlIGFjY2Vzc2libGUgdmlhIGFuIGludGVncmFsIGluZGV4LCBzdGFydGluZyBmcm9tIDAuXG4gKi9cbmZ1bmN0aW9uIE5vZGVMaXN0KCkge1xufTtcbk5vZGVMaXN0LnByb3RvdHlwZSA9IHtcblx0LyoqXG5cdCAqIFRoZSBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlIGxpc3QuIFRoZSByYW5nZSBvZiB2YWxpZCBjaGlsZCBub2RlIGluZGljZXMgaXMgMCB0byBsZW5ndGgtMSBpbmNsdXNpdmUuXG5cdCAqIEBzdGFuZGFyZCBsZXZlbDFcblx0ICovXG5cdGxlbmd0aDowLCBcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGluZGV4dGggaXRlbSBpbiB0aGUgY29sbGVjdGlvbi4gSWYgaW5kZXggaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlIGxpc3QsIHRoaXMgcmV0dXJucyBudWxsLlxuXHQgKiBAc3RhbmRhcmQgbGV2ZWwxXG5cdCAqIEBwYXJhbSBpbmRleCAgdW5zaWduZWQgbG9uZyBcblx0ICogICBJbmRleCBpbnRvIHRoZSBjb2xsZWN0aW9uLlxuXHQgKiBAcmV0dXJuIE5vZGVcblx0ICogXHRUaGUgbm9kZSBhdCB0aGUgaW5kZXh0aCBwb3NpdGlvbiBpbiB0aGUgTm9kZUxpc3QsIG9yIG51bGwgaWYgdGhhdCBpcyBub3QgYSB2YWxpZCBpbmRleC4gXG5cdCAqL1xuXHRpdGVtOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHJldHVybiB0aGlzW2luZGV4XSB8fCBudWxsO1xuXHR9XG59O1xuZnVuY3Rpb24gTGl2ZU5vZGVMaXN0KG5vZGUscmVmcmVzaCl7XG5cdHRoaXMuX25vZGUgPSBub2RlO1xuXHR0aGlzLl9yZWZyZXNoID0gcmVmcmVzaFxuXHRfdXBkYXRlTGl2ZUxpc3QodGhpcyk7XG59XG5mdW5jdGlvbiBfdXBkYXRlTGl2ZUxpc3QobGlzdCl7XG5cdHZhciBpbmMgPSBsaXN0Ll9ub2RlLl9pbmMgfHwgbGlzdC5fbm9kZS5vd25lckRvY3VtZW50Ll9pbmM7XG5cdGlmKGxpc3QuX2luYyAhPSBpbmMpe1xuXHRcdHZhciBscyA9IGxpc3QuX3JlZnJlc2gobGlzdC5fbm9kZSk7XG5cdFx0Ly9jb25zb2xlLmxvZyhscy5sZW5ndGgpXG5cdFx0X19zZXRfXyhsaXN0LCdsZW5ndGgnLGxzLmxlbmd0aCk7XG5cdFx0Y29weShscyxsaXN0KTtcblx0XHRsaXN0Ll9pbmMgPSBpbmM7XG5cdH1cbn1cbkxpdmVOb2RlTGlzdC5wcm90b3R5cGUuaXRlbSA9IGZ1bmN0aW9uKGkpe1xuXHRfdXBkYXRlTGl2ZUxpc3QodGhpcyk7XG5cdHJldHVybiB0aGlzW2ldO1xufVxuXG5fZXh0ZW5kcyhMaXZlTm9kZUxpc3QsTm9kZUxpc3QpO1xuLyoqXG4gKiBcbiAqIE9iamVjdHMgaW1wbGVtZW50aW5nIHRoZSBOYW1lZE5vZGVNYXAgaW50ZXJmYWNlIGFyZSB1c2VkIHRvIHJlcHJlc2VudCBjb2xsZWN0aW9ucyBvZiBub2RlcyB0aGF0IGNhbiBiZSBhY2Nlc3NlZCBieSBuYW1lLiBOb3RlIHRoYXQgTmFtZWROb2RlTWFwIGRvZXMgbm90IGluaGVyaXQgZnJvbSBOb2RlTGlzdDsgTmFtZWROb2RlTWFwcyBhcmUgbm90IG1haW50YWluZWQgaW4gYW55IHBhcnRpY3VsYXIgb3JkZXIuIE9iamVjdHMgY29udGFpbmVkIGluIGFuIG9iamVjdCBpbXBsZW1lbnRpbmcgTmFtZWROb2RlTWFwIG1heSBhbHNvIGJlIGFjY2Vzc2VkIGJ5IGFuIG9yZGluYWwgaW5kZXgsIGJ1dCB0aGlzIGlzIHNpbXBseSB0byBhbGxvdyBjb252ZW5pZW50IGVudW1lcmF0aW9uIG9mIHRoZSBjb250ZW50cyBvZiBhIE5hbWVkTm9kZU1hcCwgYW5kIGRvZXMgbm90IGltcGx5IHRoYXQgdGhlIERPTSBzcGVjaWZpZXMgYW4gb3JkZXIgdG8gdGhlc2UgTm9kZXMuXG4gKiBOYW1lZE5vZGVNYXAgb2JqZWN0cyBpbiB0aGUgRE9NIGFyZSBsaXZlLlxuICogdXNlZCBmb3IgYXR0cmlidXRlcyBvciBEb2N1bWVudFR5cGUgZW50aXRpZXMgXG4gKi9cbmZ1bmN0aW9uIE5hbWVkTm9kZU1hcCgpIHtcbn07XG5cbmZ1bmN0aW9uIF9maW5kTm9kZUluZGV4KGxpc3Qsbm9kZSl7XG5cdHZhciBpID0gbGlzdC5sZW5ndGg7XG5cdHdoaWxlKGktLSl7XG5cdFx0aWYobGlzdFtpXSA9PT0gbm9kZSl7cmV0dXJuIGl9XG5cdH1cbn1cblxuZnVuY3Rpb24gX2FkZE5hbWVkTm9kZShlbCxsaXN0LG5ld0F0dHIsb2xkQXR0cil7XG5cdGlmKG9sZEF0dHIpe1xuXHRcdGxpc3RbX2ZpbmROb2RlSW5kZXgobGlzdCxvbGRBdHRyKV0gPSBuZXdBdHRyO1xuXHR9ZWxzZXtcblx0XHRsaXN0W2xpc3QubGVuZ3RoKytdID0gbmV3QXR0cjtcblx0fVxuXHRpZihlbCl7XG5cdFx0bmV3QXR0ci5vd25lckVsZW1lbnQgPSBlbDtcblx0XHR2YXIgZG9jID0gZWwub3duZXJEb2N1bWVudDtcblx0XHRpZihkb2Mpe1xuXHRcdFx0b2xkQXR0ciAmJiBfb25SZW1vdmVBdHRyaWJ1dGUoZG9jLGVsLG9sZEF0dHIpO1xuXHRcdFx0X29uQWRkQXR0cmlidXRlKGRvYyxlbCxuZXdBdHRyKTtcblx0XHR9XG5cdH1cbn1cbmZ1bmN0aW9uIF9yZW1vdmVOYW1lZE5vZGUoZWwsbGlzdCxhdHRyKXtcblx0dmFyIGkgPSBfZmluZE5vZGVJbmRleChsaXN0LGF0dHIpO1xuXHRpZihpPj0wKXtcblx0XHR2YXIgbGFzdEluZGV4ID0gbGlzdC5sZW5ndGgtMVxuXHRcdHdoaWxlKGk8bGFzdEluZGV4KXtcblx0XHRcdGxpc3RbaV0gPSBsaXN0WysraV1cblx0XHR9XG5cdFx0bGlzdC5sZW5ndGggPSBsYXN0SW5kZXg7XG5cdFx0aWYoZWwpe1xuXHRcdFx0dmFyIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQ7XG5cdFx0XHRpZihkb2Mpe1xuXHRcdFx0XHRfb25SZW1vdmVBdHRyaWJ1dGUoZG9jLGVsLGF0dHIpO1xuXHRcdFx0XHRhdHRyLm93bmVyRWxlbWVudCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ZWxzZXtcblx0XHR0aHJvdyBET01FeGNlcHRpb24oTk9UX0ZPVU5EX0VSUixuZXcgRXJyb3IoKSlcblx0fVxufVxuTmFtZWROb2RlTWFwLnByb3RvdHlwZSA9IHtcblx0bGVuZ3RoOjAsXG5cdGl0ZW06Tm9kZUxpc3QucHJvdG90eXBlLml0ZW0sXG5cdGdldE5hbWVkSXRlbTogZnVuY3Rpb24oa2V5KSB7XG4vL1x0XHRpZihrZXkuaW5kZXhPZignOicpPjAgfHwga2V5ID09ICd4bWxucycpe1xuLy9cdFx0XHRyZXR1cm4gbnVsbDtcbi8vXHRcdH1cblx0XHR2YXIgaSA9IHRoaXMubGVuZ3RoO1xuXHRcdHdoaWxlKGktLSl7XG5cdFx0XHR2YXIgYXR0ciA9IHRoaXNbaV07XG5cdFx0XHRpZihhdHRyLm5vZGVOYW1lID09IGtleSl7XG5cdFx0XHRcdHJldHVybiBhdHRyO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0c2V0TmFtZWRJdGVtOiBmdW5jdGlvbihhdHRyKSB7XG5cdFx0dmFyIGVsID0gYXR0ci5vd25lckVsZW1lbnQ7XG5cdFx0aWYoZWwgJiYgZWwhPXRoaXMuX293bmVyRWxlbWVudCl7XG5cdFx0XHR0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKElOVVNFX0FUVFJJQlVURV9FUlIpO1xuXHRcdH1cblx0XHR2YXIgb2xkQXR0ciA9IHRoaXMuZ2V0TmFtZWRJdGVtKGF0dHIubm9kZU5hbWUpO1xuXHRcdF9hZGROYW1lZE5vZGUodGhpcy5fb3duZXJFbGVtZW50LHRoaXMsYXR0cixvbGRBdHRyKTtcblx0XHRyZXR1cm4gb2xkQXR0cjtcblx0fSxcblx0LyogcmV0dXJucyBOb2RlICovXG5cdHNldE5hbWVkSXRlbU5TOiBmdW5jdGlvbihhdHRyKSB7Ly8gcmFpc2VzOiBXUk9OR19ET0NVTUVOVF9FUlIsTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSLElOVVNFX0FUVFJJQlVURV9FUlJcblx0XHR2YXIgZWwgPSBhdHRyLm93bmVyRWxlbWVudCwgb2xkQXR0cjtcblx0XHRpZihlbCAmJiBlbCE9dGhpcy5fb3duZXJFbGVtZW50KXtcblx0XHRcdHRocm93IG5ldyBET01FeGNlcHRpb24oSU5VU0VfQVRUUklCVVRFX0VSUik7XG5cdFx0fVxuXHRcdG9sZEF0dHIgPSB0aGlzLmdldE5hbWVkSXRlbU5TKGF0dHIubmFtZXNwYWNlVVJJLGF0dHIubG9jYWxOYW1lKTtcblx0XHRfYWRkTmFtZWROb2RlKHRoaXMuX293bmVyRWxlbWVudCx0aGlzLGF0dHIsb2xkQXR0cik7XG5cdFx0cmV0dXJuIG9sZEF0dHI7XG5cdH0sXG5cblx0LyogcmV0dXJucyBOb2RlICovXG5cdHJlbW92ZU5hbWVkSXRlbTogZnVuY3Rpb24oa2V5KSB7XG5cdFx0dmFyIGF0dHIgPSB0aGlzLmdldE5hbWVkSXRlbShrZXkpO1xuXHRcdF9yZW1vdmVOYW1lZE5vZGUodGhpcy5fb3duZXJFbGVtZW50LHRoaXMsYXR0cik7XG5cdFx0cmV0dXJuIGF0dHI7XG5cdFx0XG5cdFx0XG5cdH0sLy8gcmFpc2VzOiBOT1RfRk9VTkRfRVJSLE5PX01PRElGSUNBVElPTl9BTExPV0VEX0VSUlxuXHRcblx0Ly9mb3IgbGV2ZWwyXG5cdHJlbW92ZU5hbWVkSXRlbU5TOmZ1bmN0aW9uKG5hbWVzcGFjZVVSSSxsb2NhbE5hbWUpe1xuXHRcdHZhciBhdHRyID0gdGhpcy5nZXROYW1lZEl0ZW1OUyhuYW1lc3BhY2VVUkksbG9jYWxOYW1lKTtcblx0XHRfcmVtb3ZlTmFtZWROb2RlKHRoaXMuX293bmVyRWxlbWVudCx0aGlzLGF0dHIpO1xuXHRcdHJldHVybiBhdHRyO1xuXHR9LFxuXHRnZXROYW1lZEl0ZW1OUzogZnVuY3Rpb24obmFtZXNwYWNlVVJJLCBsb2NhbE5hbWUpIHtcblx0XHR2YXIgaSA9IHRoaXMubGVuZ3RoO1xuXHRcdHdoaWxlKGktLSl7XG5cdFx0XHR2YXIgbm9kZSA9IHRoaXNbaV07XG5cdFx0XHRpZihub2RlLmxvY2FsTmFtZSA9PSBsb2NhbE5hbWUgJiYgbm9kZS5uYW1lc3BhY2VVUkkgPT0gbmFtZXNwYWNlVVJJKXtcblx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG59O1xuLyoqXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy1ET00tTGV2ZWwtMS9sZXZlbC1vbmUtY29yZS5odG1sI0lELTEwMjE2MTQ5MFxuICovXG5mdW5jdGlvbiBET01JbXBsZW1lbnRhdGlvbigvKiBPYmplY3QgKi8gZmVhdHVyZXMpIHtcblx0dGhpcy5fZmVhdHVyZXMgPSB7fTtcblx0aWYgKGZlYXR1cmVzKSB7XG5cdFx0Zm9yICh2YXIgZmVhdHVyZSBpbiBmZWF0dXJlcykge1xuXHRcdFx0IHRoaXMuX2ZlYXR1cmVzID0gZmVhdHVyZXNbZmVhdHVyZV07XG5cdFx0fVxuXHR9XG59O1xuXG5ET01JbXBsZW1lbnRhdGlvbi5wcm90b3R5cGUgPSB7XG5cdGhhc0ZlYXR1cmU6IGZ1bmN0aW9uKC8qIHN0cmluZyAqLyBmZWF0dXJlLCAvKiBzdHJpbmcgKi8gdmVyc2lvbikge1xuXHRcdHZhciB2ZXJzaW9ucyA9IHRoaXMuX2ZlYXR1cmVzW2ZlYXR1cmUudG9Mb3dlckNhc2UoKV07XG5cdFx0aWYgKHZlcnNpb25zICYmICghdmVyc2lvbiB8fCB2ZXJzaW9uIGluIHZlcnNpb25zKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0sXG5cdC8vIEludHJvZHVjZWQgaW4gRE9NIExldmVsIDI6XG5cdGNyZWF0ZURvY3VtZW50OmZ1bmN0aW9uKG5hbWVzcGFjZVVSSSwgIHF1YWxpZmllZE5hbWUsIGRvY3R5cGUpey8vIHJhaXNlczpJTlZBTElEX0NIQVJBQ1RFUl9FUlIsTkFNRVNQQUNFX0VSUixXUk9OR19ET0NVTUVOVF9FUlJcblx0XHR2YXIgZG9jID0gbmV3IERvY3VtZW50KCk7XG5cdFx0ZG9jLmRvY3R5cGUgPSBkb2N0eXBlO1xuXHRcdGlmKGRvY3R5cGUpe1xuXHRcdFx0ZG9jLmFwcGVuZENoaWxkKGRvY3R5cGUpO1xuXHRcdH1cblx0XHRkb2MuaW1wbGVtZW50YXRpb24gPSB0aGlzO1xuXHRcdGRvYy5jaGlsZE5vZGVzID0gbmV3IE5vZGVMaXN0KCk7XG5cdFx0aWYocXVhbGlmaWVkTmFtZSl7XG5cdFx0XHR2YXIgcm9vdCA9IGRvYy5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLHF1YWxpZmllZE5hbWUpO1xuXHRcdFx0ZG9jLmFwcGVuZENoaWxkKHJvb3QpO1xuXHRcdH1cblx0XHRyZXR1cm4gZG9jO1xuXHR9LFxuXHQvLyBJbnRyb2R1Y2VkIGluIERPTSBMZXZlbCAyOlxuXHRjcmVhdGVEb2N1bWVudFR5cGU6ZnVuY3Rpb24ocXVhbGlmaWVkTmFtZSwgcHVibGljSWQsIHN5c3RlbUlkKXsvLyByYWlzZXM6SU5WQUxJRF9DSEFSQUNURVJfRVJSLE5BTUVTUEFDRV9FUlJcblx0XHR2YXIgbm9kZSA9IG5ldyBEb2N1bWVudFR5cGUoKTtcblx0XHRub2RlLm5hbWUgPSBxdWFsaWZpZWROYW1lO1xuXHRcdG5vZGUubm9kZU5hbWUgPSBxdWFsaWZpZWROYW1lO1xuXHRcdG5vZGUucHVibGljSWQgPSBwdWJsaWNJZDtcblx0XHRub2RlLnN5c3RlbUlkID0gc3lzdGVtSWQ7XG5cdFx0Ly8gSW50cm9kdWNlZCBpbiBET00gTGV2ZWwgMjpcblx0XHQvL3JlYWRvbmx5IGF0dHJpYnV0ZSBET01TdHJpbmcgICAgICAgIGludGVybmFsU3Vic2V0O1xuXHRcdFxuXHRcdC8vVE9ETzouLlxuXHRcdC8vICByZWFkb25seSBhdHRyaWJ1dGUgTmFtZWROb2RlTWFwICAgICBlbnRpdGllcztcblx0XHQvLyAgcmVhZG9ubHkgYXR0cmlidXRlIE5hbWVkTm9kZU1hcCAgICAgbm90YXRpb25zO1xuXHRcdHJldHVybiBub2RlO1xuXHR9XG59O1xuXG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAwL1JFQy1ET00tTGV2ZWwtMi1Db3JlLTIwMDAxMTEzL2NvcmUuaHRtbCNJRC0xOTUwNjQxMjQ3XG4gKi9cblxuZnVuY3Rpb24gTm9kZSgpIHtcbn07XG5cbk5vZGUucHJvdG90eXBlID0ge1xuXHRmaXJzdENoaWxkIDogbnVsbCxcblx0bGFzdENoaWxkIDogbnVsbCxcblx0cHJldmlvdXNTaWJsaW5nIDogbnVsbCxcblx0bmV4dFNpYmxpbmcgOiBudWxsLFxuXHRhdHRyaWJ1dGVzIDogbnVsbCxcblx0cGFyZW50Tm9kZSA6IG51bGwsXG5cdGNoaWxkTm9kZXMgOiBudWxsLFxuXHRvd25lckRvY3VtZW50IDogbnVsbCxcblx0bm9kZVZhbHVlIDogbnVsbCxcblx0bmFtZXNwYWNlVVJJIDogbnVsbCxcblx0cHJlZml4IDogbnVsbCxcblx0bG9jYWxOYW1lIDogbnVsbCxcblx0Ly8gTW9kaWZpZWQgaW4gRE9NIExldmVsIDI6XG5cdGluc2VydEJlZm9yZTpmdW5jdGlvbihuZXdDaGlsZCwgcmVmQ2hpbGQpey8vcmFpc2VzIFxuXHRcdHJldHVybiBfaW5zZXJ0QmVmb3JlKHRoaXMsbmV3Q2hpbGQscmVmQ2hpbGQpO1xuXHR9LFxuXHRyZXBsYWNlQ2hpbGQ6ZnVuY3Rpb24obmV3Q2hpbGQsIG9sZENoaWxkKXsvL3JhaXNlcyBcblx0XHR0aGlzLmluc2VydEJlZm9yZShuZXdDaGlsZCxvbGRDaGlsZCk7XG5cdFx0aWYob2xkQ2hpbGQpe1xuXHRcdFx0dGhpcy5yZW1vdmVDaGlsZChvbGRDaGlsZCk7XG5cdFx0fVxuXHR9LFxuXHRyZW1vdmVDaGlsZDpmdW5jdGlvbihvbGRDaGlsZCl7XG5cdFx0cmV0dXJuIF9yZW1vdmVDaGlsZCh0aGlzLG9sZENoaWxkKTtcblx0fSxcblx0YXBwZW5kQ2hpbGQ6ZnVuY3Rpb24obmV3Q2hpbGQpe1xuXHRcdHJldHVybiB0aGlzLmluc2VydEJlZm9yZShuZXdDaGlsZCxudWxsKTtcblx0fSxcblx0aGFzQ2hpbGROb2RlczpmdW5jdGlvbigpe1xuXHRcdHJldHVybiB0aGlzLmZpcnN0Q2hpbGQgIT0gbnVsbDtcblx0fSxcblx0Y2xvbmVOb2RlOmZ1bmN0aW9uKGRlZXApe1xuXHRcdHJldHVybiBjbG9uZU5vZGUodGhpcy5vd25lckRvY3VtZW50fHx0aGlzLHRoaXMsZGVlcCk7XG5cdH0sXG5cdC8vIE1vZGlmaWVkIGluIERPTSBMZXZlbCAyOlxuXHRub3JtYWxpemU6ZnVuY3Rpb24oKXtcblx0XHR2YXIgY2hpbGQgPSB0aGlzLmZpcnN0Q2hpbGQ7XG5cdFx0d2hpbGUoY2hpbGQpe1xuXHRcdFx0dmFyIG5leHQgPSBjaGlsZC5uZXh0U2libGluZztcblx0XHRcdGlmKG5leHQgJiYgbmV4dC5ub2RlVHlwZSA9PSBURVhUX05PREUgJiYgY2hpbGQubm9kZVR5cGUgPT0gVEVYVF9OT0RFKXtcblx0XHRcdFx0dGhpcy5yZW1vdmVDaGlsZChuZXh0KTtcblx0XHRcdFx0Y2hpbGQuYXBwZW5kRGF0YShuZXh0LmRhdGEpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdGNoaWxkLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHRjaGlsZCA9IG5leHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuICBcdC8vIEludHJvZHVjZWQgaW4gRE9NIExldmVsIDI6XG5cdGlzU3VwcG9ydGVkOmZ1bmN0aW9uKGZlYXR1cmUsIHZlcnNpb24pe1xuXHRcdHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShmZWF0dXJlLHZlcnNpb24pO1xuXHR9LFxuICAgIC8vIEludHJvZHVjZWQgaW4gRE9NIExldmVsIDI6XG4gICAgaGFzQXR0cmlidXRlczpmdW5jdGlvbigpe1xuICAgIFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5sZW5ndGg+MDtcbiAgICB9LFxuICAgIGxvb2t1cFByZWZpeDpmdW5jdGlvbihuYW1lc3BhY2VVUkkpe1xuICAgIFx0dmFyIGVsID0gdGhpcztcbiAgICBcdHdoaWxlKGVsKXtcbiAgICBcdFx0dmFyIG1hcCA9IGVsLl9uc01hcDtcbiAgICBcdFx0Ly9jb25zb2xlLmRpcihtYXApXG4gICAgXHRcdGlmKG1hcCl7XG4gICAgXHRcdFx0Zm9yKHZhciBuIGluIG1hcCl7XG4gICAgXHRcdFx0XHRpZihtYXBbbl0gPT0gbmFtZXNwYWNlVVJJKXtcbiAgICBcdFx0XHRcdFx0cmV0dXJuIG47XG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fVxuICAgIFx0XHR9XG4gICAgXHRcdGVsID0gZWwubm9kZVR5cGUgPT0gMj9lbC5vd25lckRvY3VtZW50IDogZWwucGFyZW50Tm9kZTtcbiAgICBcdH1cbiAgICBcdHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgLy8gSW50cm9kdWNlZCBpbiBET00gTGV2ZWwgMzpcbiAgICBsb29rdXBOYW1lc3BhY2VVUkk6ZnVuY3Rpb24ocHJlZml4KXtcbiAgICBcdHZhciBlbCA9IHRoaXM7XG4gICAgXHR3aGlsZShlbCl7XG4gICAgXHRcdHZhciBtYXAgPSBlbC5fbnNNYXA7XG4gICAgXHRcdC8vY29uc29sZS5kaXIobWFwKVxuICAgIFx0XHRpZihtYXApe1xuICAgIFx0XHRcdGlmKHByZWZpeCBpbiBtYXApe1xuICAgIFx0XHRcdFx0cmV0dXJuIG1hcFtwcmVmaXhdIDtcbiAgICBcdFx0XHR9XG4gICAgXHRcdH1cbiAgICBcdFx0ZWwgPSBlbC5ub2RlVHlwZSA9PSAyP2VsLm93bmVyRG9jdW1lbnQgOiBlbC5wYXJlbnROb2RlO1xuICAgIFx0fVxuICAgIFx0cmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICAvLyBJbnRyb2R1Y2VkIGluIERPTSBMZXZlbCAzOlxuICAgIGlzRGVmYXVsdE5hbWVzcGFjZTpmdW5jdGlvbihuYW1lc3BhY2VVUkkpe1xuICAgIFx0dmFyIHByZWZpeCA9IHRoaXMubG9va3VwUHJlZml4KG5hbWVzcGFjZVVSSSk7XG4gICAgXHRyZXR1cm4gcHJlZml4ID09IG51bGw7XG4gICAgfVxufTtcblxuXG5mdW5jdGlvbiBfeG1sRW5jb2RlcihjKXtcblx0cmV0dXJuIGMgPT0gJzwnICYmICcmbHQ7JyB8fFxuICAgICAgICAgYyA9PSAnPicgJiYgJyZndDsnIHx8XG4gICAgICAgICBjID09ICcmJyAmJiAnJmFtcDsnIHx8XG4gICAgICAgICBjID09ICdcIicgJiYgJyZxdW90OycgfHxcbiAgICAgICAgICcmIycrYy5jaGFyQ29kZUF0KCkrJzsnXG59XG5cblxuY29weShOb2RlVHlwZSxOb2RlKTtcbmNvcHkoTm9kZVR5cGUsTm9kZS5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEBwYXJhbSBjYWxsYmFjayByZXR1cm4gdHJ1ZSBmb3IgY29udGludWUsZmFsc2UgZm9yIGJyZWFrXG4gKiBAcmV0dXJuIGJvb2xlYW4gdHJ1ZTogYnJlYWsgdmlzaXQ7XG4gKi9cbmZ1bmN0aW9uIF92aXNpdE5vZGUobm9kZSxjYWxsYmFjayl7XG5cdGlmKGNhbGxiYWNrKG5vZGUpKXtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRpZihub2RlID0gbm9kZS5maXJzdENoaWxkKXtcblx0XHRkb3tcblx0XHRcdGlmKF92aXNpdE5vZGUobm9kZSxjYWxsYmFjaykpe3JldHVybiB0cnVlfVxuICAgICAgICB9d2hpbGUobm9kZT1ub2RlLm5leHRTaWJsaW5nKVxuICAgIH1cbn1cblxuXG5cbmZ1bmN0aW9uIERvY3VtZW50KCl7XG59XG5mdW5jdGlvbiBfb25BZGRBdHRyaWJ1dGUoZG9jLGVsLG5ld0F0dHIpe1xuXHRkb2MgJiYgZG9jLl9pbmMrKztcblx0dmFyIG5zID0gbmV3QXR0ci5uYW1lc3BhY2VVUkkgO1xuXHRpZihucyA9PSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nKXtcblx0XHQvL3VwZGF0ZSBuYW1lc3BhY2Vcblx0XHRlbC5fbnNNYXBbbmV3QXR0ci5wcmVmaXg/bmV3QXR0ci5sb2NhbE5hbWU6JyddID0gbmV3QXR0ci52YWx1ZVxuXHR9XG59XG5mdW5jdGlvbiBfb25SZW1vdmVBdHRyaWJ1dGUoZG9jLGVsLG5ld0F0dHIscmVtb3ZlKXtcblx0ZG9jICYmIGRvYy5faW5jKys7XG5cdHZhciBucyA9IG5ld0F0dHIubmFtZXNwYWNlVVJJIDtcblx0aWYobnMgPT0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJyl7XG5cdFx0Ly91cGRhdGUgbmFtZXNwYWNlXG5cdFx0ZGVsZXRlIGVsLl9uc01hcFtuZXdBdHRyLnByZWZpeD9uZXdBdHRyLmxvY2FsTmFtZTonJ11cblx0fVxufVxuZnVuY3Rpb24gX29uVXBkYXRlQ2hpbGQoZG9jLGVsLG5ld0NoaWxkKXtcblx0aWYoZG9jICYmIGRvYy5faW5jKXtcblx0XHRkb2MuX2luYysrO1xuXHRcdC8vdXBkYXRlIGNoaWxkTm9kZXNcblx0XHR2YXIgY3MgPSBlbC5jaGlsZE5vZGVzO1xuXHRcdGlmKG5ld0NoaWxkKXtcblx0XHRcdGNzW2NzLmxlbmd0aCsrXSA9IG5ld0NoaWxkO1xuXHRcdH1lbHNle1xuXHRcdFx0Ly9jb25zb2xlLmxvZygxKVxuXHRcdFx0dmFyIGNoaWxkID0gZWwuZmlyc3RDaGlsZDtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdHdoaWxlKGNoaWxkKXtcblx0XHRcdFx0Y3NbaSsrXSA9IGNoaWxkO1xuXHRcdFx0XHRjaGlsZCA9Y2hpbGQubmV4dFNpYmxpbmc7XG5cdFx0XHR9XG5cdFx0XHRjcy5sZW5ndGggPSBpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIGF0dHJpYnV0ZXM7XG4gKiBjaGlsZHJlbjtcbiAqIFxuICogd3JpdGVhYmxlIHByb3BlcnRpZXM6XG4gKiBub2RlVmFsdWUsQXR0cjp2YWx1ZSxDaGFyYWN0ZXJEYXRhOmRhdGFcbiAqIHByZWZpeFxuICovXG5mdW5jdGlvbiBfcmVtb3ZlQ2hpbGQocGFyZW50Tm9kZSxjaGlsZCl7XG5cdHZhciBwcmV2aW91cyA9IGNoaWxkLnByZXZpb3VzU2libGluZztcblx0dmFyIG5leHQgPSBjaGlsZC5uZXh0U2libGluZztcblx0aWYocHJldmlvdXMpe1xuXHRcdHByZXZpb3VzLm5leHRTaWJsaW5nID0gbmV4dDtcblx0fWVsc2V7XG5cdFx0cGFyZW50Tm9kZS5maXJzdENoaWxkID0gbmV4dFxuXHR9XG5cdGlmKG5leHQpe1xuXHRcdG5leHQucHJldmlvdXNTaWJsaW5nID0gcHJldmlvdXM7XG5cdH1lbHNle1xuXHRcdHBhcmVudE5vZGUubGFzdENoaWxkID0gcHJldmlvdXM7XG5cdH1cblx0X29uVXBkYXRlQ2hpbGQocGFyZW50Tm9kZS5vd25lckRvY3VtZW50LHBhcmVudE5vZGUpO1xuXHRyZXR1cm4gY2hpbGQ7XG59XG4vKipcbiAqIHByZWZvcm1hbmNlIGtleShyZWZDaGlsZCA9PSBudWxsKVxuICovXG5mdW5jdGlvbiBfaW5zZXJ0QmVmb3JlKHBhcmVudE5vZGUsbmV3Q2hpbGQsbmV4dENoaWxkKXtcblx0dmFyIGNwID0gbmV3Q2hpbGQucGFyZW50Tm9kZTtcblx0aWYoY3Ape1xuXHRcdGNwLnJlbW92ZUNoaWxkKG5ld0NoaWxkKTsvL3JlbW92ZSBhbmQgdXBkYXRlXG5cdH1cblx0aWYobmV3Q2hpbGQubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUpe1xuXHRcdHZhciBuZXdGaXJzdCA9IG5ld0NoaWxkLmZpcnN0Q2hpbGQ7XG5cdFx0aWYgKG5ld0ZpcnN0ID09IG51bGwpIHtcblx0XHRcdHJldHVybiBuZXdDaGlsZDtcblx0XHR9XG5cdFx0dmFyIG5ld0xhc3QgPSBuZXdDaGlsZC5sYXN0Q2hpbGQ7XG5cdH1lbHNle1xuXHRcdG5ld0ZpcnN0ID0gbmV3TGFzdCA9IG5ld0NoaWxkO1xuXHR9XG5cdHZhciBwcmUgPSBuZXh0Q2hpbGQgPyBuZXh0Q2hpbGQucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Tm9kZS5sYXN0Q2hpbGQ7XG5cblx0bmV3Rmlyc3QucHJldmlvdXNTaWJsaW5nID0gcHJlO1xuXHRuZXdMYXN0Lm5leHRTaWJsaW5nID0gbmV4dENoaWxkO1xuXHRcblx0XG5cdGlmKHByZSl7XG5cdFx0cHJlLm5leHRTaWJsaW5nID0gbmV3Rmlyc3Q7XG5cdH1lbHNle1xuXHRcdHBhcmVudE5vZGUuZmlyc3RDaGlsZCA9IG5ld0ZpcnN0O1xuXHR9XG5cdGlmKG5leHRDaGlsZCA9PSBudWxsKXtcblx0XHRwYXJlbnROb2RlLmxhc3RDaGlsZCA9IG5ld0xhc3Q7XG5cdH1lbHNle1xuXHRcdG5leHRDaGlsZC5wcmV2aW91c1NpYmxpbmcgPSBuZXdMYXN0O1xuXHR9XG5cdGRve1xuXHRcdG5ld0ZpcnN0LnBhcmVudE5vZGUgPSBwYXJlbnROb2RlO1xuXHR9d2hpbGUobmV3Rmlyc3QgIT09IG5ld0xhc3QgJiYgKG5ld0ZpcnN0PSBuZXdGaXJzdC5uZXh0U2libGluZykpXG5cdF9vblVwZGF0ZUNoaWxkKHBhcmVudE5vZGUub3duZXJEb2N1bWVudHx8cGFyZW50Tm9kZSxwYXJlbnROb2RlKTtcblx0Ly9jb25zb2xlLmxvZyhwYXJlbnROb2RlLmxhc3RDaGlsZC5uZXh0U2libGluZyA9PSBudWxsKVxuXHRpZiAobmV3Q2hpbGQubm9kZVR5cGUgPT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuXHRcdG5ld0NoaWxkLmZpcnN0Q2hpbGQgPSBuZXdDaGlsZC5sYXN0Q2hpbGQgPSBudWxsO1xuXHR9XG5cdHJldHVybiBuZXdDaGlsZDtcbn1cbmZ1bmN0aW9uIF9hcHBlbmRTaW5nbGVDaGlsZChwYXJlbnROb2RlLG5ld0NoaWxkKXtcblx0dmFyIGNwID0gbmV3Q2hpbGQucGFyZW50Tm9kZTtcblx0aWYoY3Ape1xuXHRcdHZhciBwcmUgPSBwYXJlbnROb2RlLmxhc3RDaGlsZDtcblx0XHRjcC5yZW1vdmVDaGlsZChuZXdDaGlsZCk7Ly9yZW1vdmUgYW5kIHVwZGF0ZVxuXHRcdHZhciBwcmUgPSBwYXJlbnROb2RlLmxhc3RDaGlsZDtcblx0fVxuXHR2YXIgcHJlID0gcGFyZW50Tm9kZS5sYXN0Q2hpbGQ7XG5cdG5ld0NoaWxkLnBhcmVudE5vZGUgPSBwYXJlbnROb2RlO1xuXHRuZXdDaGlsZC5wcmV2aW91c1NpYmxpbmcgPSBwcmU7XG5cdG5ld0NoaWxkLm5leHRTaWJsaW5nID0gbnVsbDtcblx0aWYocHJlKXtcblx0XHRwcmUubmV4dFNpYmxpbmcgPSBuZXdDaGlsZDtcblx0fWVsc2V7XG5cdFx0cGFyZW50Tm9kZS5maXJzdENoaWxkID0gbmV3Q2hpbGQ7XG5cdH1cblx0cGFyZW50Tm9kZS5sYXN0Q2hpbGQgPSBuZXdDaGlsZDtcblx0X29uVXBkYXRlQ2hpbGQocGFyZW50Tm9kZS5vd25lckRvY3VtZW50LHBhcmVudE5vZGUsbmV3Q2hpbGQpO1xuXHRyZXR1cm4gbmV3Q2hpbGQ7XG5cdC8vY29uc29sZS5sb2coXCJfX2FhXCIscGFyZW50Tm9kZS5sYXN0Q2hpbGQubmV4dFNpYmxpbmcgPT0gbnVsbClcbn1cbkRvY3VtZW50LnByb3RvdHlwZSA9IHtcblx0Ly9pbXBsZW1lbnRhdGlvbiA6IG51bGwsXG5cdG5vZGVOYW1lIDogICcjZG9jdW1lbnQnLFxuXHRub2RlVHlwZSA6ICBET0NVTUVOVF9OT0RFLFxuXHRkb2N0eXBlIDogIG51bGwsXG5cdGRvY3VtZW50RWxlbWVudCA6ICBudWxsLFxuXHRfaW5jIDogMSxcblx0XG5cdGluc2VydEJlZm9yZSA6ICBmdW5jdGlvbihuZXdDaGlsZCwgcmVmQ2hpbGQpey8vcmFpc2VzIFxuXHRcdGlmKG5ld0NoaWxkLm5vZGVUeXBlID09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUpe1xuXHRcdFx0dmFyIGNoaWxkID0gbmV3Q2hpbGQuZmlyc3RDaGlsZDtcblx0XHRcdHdoaWxlKGNoaWxkKXtcblx0XHRcdFx0dmFyIG5leHQgPSBjaGlsZC5uZXh0U2libGluZztcblx0XHRcdFx0dGhpcy5pbnNlcnRCZWZvcmUoY2hpbGQscmVmQ2hpbGQpO1xuXHRcdFx0XHRjaGlsZCA9IG5leHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3Q2hpbGQ7XG5cdFx0fVxuXHRcdGlmKHRoaXMuZG9jdW1lbnRFbGVtZW50ID09IG51bGwgJiYgbmV3Q2hpbGQubm9kZVR5cGUgPT0gMSl7XG5cdFx0XHR0aGlzLmRvY3VtZW50RWxlbWVudCA9IG5ld0NoaWxkO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gX2luc2VydEJlZm9yZSh0aGlzLG5ld0NoaWxkLHJlZkNoaWxkKSwobmV3Q2hpbGQub3duZXJEb2N1bWVudCA9IHRoaXMpLG5ld0NoaWxkO1xuXHR9LFxuXHRyZW1vdmVDaGlsZCA6ICBmdW5jdGlvbihvbGRDaGlsZCl7XG5cdFx0aWYodGhpcy5kb2N1bWVudEVsZW1lbnQgPT0gb2xkQ2hpbGQpe1xuXHRcdFx0dGhpcy5kb2N1bWVudEVsZW1lbnQgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gX3JlbW92ZUNoaWxkKHRoaXMsb2xkQ2hpbGQpO1xuXHR9LFxuXHQvLyBJbnRyb2R1Y2VkIGluIERPTSBMZXZlbCAyOlxuXHRpbXBvcnROb2RlIDogZnVuY3Rpb24oaW1wb3J0ZWROb2RlLGRlZXApe1xuXHRcdHJldHVybiBpbXBvcnROb2RlKHRoaXMsaW1wb3J0ZWROb2RlLGRlZXApO1xuXHR9LFxuXHQvLyBJbnRyb2R1Y2VkIGluIERPTSBMZXZlbCAyOlxuXHRnZXRFbGVtZW50QnlJZCA6XHRmdW5jdGlvbihpZCl7XG5cdFx0dmFyIHJ0diA9IG51bGw7XG5cdFx0X3Zpc2l0Tm9kZSh0aGlzLmRvY3VtZW50RWxlbWVudCxmdW5jdGlvbihub2RlKXtcblx0XHRcdGlmKG5vZGUubm9kZVR5cGUgPT0gMSl7XG5cdFx0XHRcdGlmKG5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpID09IGlkKXtcblx0XHRcdFx0XHRydHYgPSBub2RlO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSlcblx0XHRyZXR1cm4gcnR2O1xuXHR9LFxuXHRcblx0Ly9kb2N1bWVudCBmYWN0b3J5IG1ldGhvZDpcblx0Y3JlYXRlRWxlbWVudCA6XHRmdW5jdGlvbih0YWdOYW1lKXtcblx0XHR2YXIgbm9kZSA9IG5ldyBFbGVtZW50KCk7XG5cdFx0bm9kZS5vd25lckRvY3VtZW50ID0gdGhpcztcblx0XHRub2RlLm5vZGVOYW1lID0gdGFnTmFtZTtcblx0XHRub2RlLnRhZ05hbWUgPSB0YWdOYW1lO1xuXHRcdG5vZGUuY2hpbGROb2RlcyA9IG5ldyBOb2RlTGlzdCgpO1xuXHRcdHZhciBhdHRyc1x0PSBub2RlLmF0dHJpYnV0ZXMgPSBuZXcgTmFtZWROb2RlTWFwKCk7XG5cdFx0YXR0cnMuX293bmVyRWxlbWVudCA9IG5vZGU7XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH0sXG5cdGNyZWF0ZURvY3VtZW50RnJhZ21lbnQgOlx0ZnVuY3Rpb24oKXtcblx0XHR2YXIgbm9kZSA9IG5ldyBEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0bm9kZS5vd25lckRvY3VtZW50ID0gdGhpcztcblx0XHRub2RlLmNoaWxkTm9kZXMgPSBuZXcgTm9kZUxpc3QoKTtcblx0XHRyZXR1cm4gbm9kZTtcblx0fSxcblx0Y3JlYXRlVGV4dE5vZGUgOlx0ZnVuY3Rpb24oZGF0YSl7XG5cdFx0dmFyIG5vZGUgPSBuZXcgVGV4dCgpO1xuXHRcdG5vZGUub3duZXJEb2N1bWVudCA9IHRoaXM7XG5cdFx0bm9kZS5hcHBlbmREYXRhKGRhdGEpXG5cdFx0cmV0dXJuIG5vZGU7XG5cdH0sXG5cdGNyZWF0ZUNvbW1lbnQgOlx0ZnVuY3Rpb24oZGF0YSl7XG5cdFx0dmFyIG5vZGUgPSBuZXcgQ29tbWVudCgpO1xuXHRcdG5vZGUub3duZXJEb2N1bWVudCA9IHRoaXM7XG5cdFx0bm9kZS5hcHBlbmREYXRhKGRhdGEpXG5cdFx0cmV0dXJuIG5vZGU7XG5cdH0sXG5cdGNyZWF0ZUNEQVRBU2VjdGlvbiA6XHRmdW5jdGlvbihkYXRhKXtcblx0XHR2YXIgbm9kZSA9IG5ldyBDREFUQVNlY3Rpb24oKTtcblx0XHRub2RlLm93bmVyRG9jdW1lbnQgPSB0aGlzO1xuXHRcdG5vZGUuYXBwZW5kRGF0YShkYXRhKVxuXHRcdHJldHVybiBub2RlO1xuXHR9LFxuXHRjcmVhdGVQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gOlx0ZnVuY3Rpb24odGFyZ2V0LGRhdGEpe1xuXHRcdHZhciBub2RlID0gbmV3IFByb2Nlc3NpbmdJbnN0cnVjdGlvbigpO1xuXHRcdG5vZGUub3duZXJEb2N1bWVudCA9IHRoaXM7XG5cdFx0bm9kZS50YWdOYW1lID0gbm9kZS50YXJnZXQgPSB0YXJnZXQ7XG5cdFx0bm9kZS5ub2RlVmFsdWU9IG5vZGUuZGF0YSA9IGRhdGE7XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH0sXG5cdGNyZWF0ZUF0dHJpYnV0ZSA6XHRmdW5jdGlvbihuYW1lKXtcblx0XHR2YXIgbm9kZSA9IG5ldyBBdHRyKCk7XG5cdFx0bm9kZS5vd25lckRvY3VtZW50XHQ9IHRoaXM7XG5cdFx0bm9kZS5uYW1lID0gbmFtZTtcblx0XHRub2RlLm5vZGVOYW1lXHQ9IG5hbWU7XG5cdFx0bm9kZS5sb2NhbE5hbWUgPSBuYW1lO1xuXHRcdG5vZGUuc3BlY2lmaWVkID0gdHJ1ZTtcblx0XHRyZXR1cm4gbm9kZTtcblx0fSxcblx0Y3JlYXRlRW50aXR5UmVmZXJlbmNlIDpcdGZ1bmN0aW9uKG5hbWUpe1xuXHRcdHZhciBub2RlID0gbmV3IEVudGl0eVJlZmVyZW5jZSgpO1xuXHRcdG5vZGUub3duZXJEb2N1bWVudFx0PSB0aGlzO1xuXHRcdG5vZGUubm9kZU5hbWVcdD0gbmFtZTtcblx0XHRyZXR1cm4gbm9kZTtcblx0fSxcblx0Ly8gSW50cm9kdWNlZCBpbiBET00gTGV2ZWwgMjpcblx0Y3JlYXRlRWxlbWVudE5TIDpcdGZ1bmN0aW9uKG5hbWVzcGFjZVVSSSxxdWFsaWZpZWROYW1lKXtcblx0XHR2YXIgbm9kZSA9IG5ldyBFbGVtZW50KCk7XG5cdFx0dmFyIHBsID0gcXVhbGlmaWVkTmFtZS5zcGxpdCgnOicpO1xuXHRcdHZhciBhdHRyc1x0PSBub2RlLmF0dHJpYnV0ZXMgPSBuZXcgTmFtZWROb2RlTWFwKCk7XG5cdFx0bm9kZS5jaGlsZE5vZGVzID0gbmV3IE5vZGVMaXN0KCk7XG5cdFx0bm9kZS5vd25lckRvY3VtZW50ID0gdGhpcztcblx0XHRub2RlLm5vZGVOYW1lID0gcXVhbGlmaWVkTmFtZTtcblx0XHRub2RlLnRhZ05hbWUgPSBxdWFsaWZpZWROYW1lO1xuXHRcdG5vZGUubmFtZXNwYWNlVVJJID0gbmFtZXNwYWNlVVJJO1xuXHRcdGlmKHBsLmxlbmd0aCA9PSAyKXtcblx0XHRcdG5vZGUucHJlZml4ID0gcGxbMF07XG5cdFx0XHRub2RlLmxvY2FsTmFtZSA9IHBsWzFdO1xuXHRcdH1lbHNle1xuXHRcdFx0Ly9lbC5wcmVmaXggPSBudWxsO1xuXHRcdFx0bm9kZS5sb2NhbE5hbWUgPSBxdWFsaWZpZWROYW1lO1xuXHRcdH1cblx0XHRhdHRycy5fb3duZXJFbGVtZW50ID0gbm9kZTtcblx0XHRyZXR1cm4gbm9kZTtcblx0fSxcblx0Ly8gSW50cm9kdWNlZCBpbiBET00gTGV2ZWwgMjpcblx0Y3JlYXRlQXR0cmlidXRlTlMgOlx0ZnVuY3Rpb24obmFtZXNwYWNlVVJJLHF1YWxpZmllZE5hbWUpe1xuXHRcdHZhciBub2RlID0gbmV3IEF0dHIoKTtcblx0XHR2YXIgcGwgPSBxdWFsaWZpZWROYW1lLnNwbGl0KCc6Jyk7XG5cdFx0bm9kZS5vd25lckRvY3VtZW50ID0gdGhpcztcblx0XHRub2RlLm5vZGVOYW1lID0gcXVhbGlmaWVkTmFtZTtcblx0XHRub2RlLm5hbWUgPSBxdWFsaWZpZWROYW1lO1xuXHRcdG5vZGUubmFtZXNwYWNlVVJJID0gbmFtZXNwYWNlVVJJO1xuXHRcdG5vZGUuc3BlY2lmaWVkID0gdHJ1ZTtcblx0XHRpZihwbC5sZW5ndGggPT0gMil7XG5cdFx0XHRub2RlLnByZWZpeCA9IHBsWzBdO1xuXHRcdFx0bm9kZS5sb2NhbE5hbWUgPSBwbFsxXTtcblx0XHR9ZWxzZXtcblx0XHRcdC8vZWwucHJlZml4ID0gbnVsbDtcblx0XHRcdG5vZGUubG9jYWxOYW1lID0gcXVhbGlmaWVkTmFtZTtcblx0XHR9XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH1cbn07XG5fZXh0ZW5kcyhEb2N1bWVudCxOb2RlKTtcblxuXG5mdW5jdGlvbiBFbGVtZW50KCkge1xuXHR0aGlzLl9uc01hcCA9IHt9O1xufTtcbkVsZW1lbnQucHJvdG90eXBlID0ge1xuXHRub2RlVHlwZSA6IEVMRU1FTlRfTk9ERSxcblx0aGFzQXR0cmlidXRlIDogZnVuY3Rpb24obmFtZSl7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlTm9kZShuYW1lKSE9bnVsbDtcblx0fSxcblx0Z2V0QXR0cmlidXRlIDogZnVuY3Rpb24obmFtZSl7XG5cdFx0dmFyIGF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZU5vZGUobmFtZSk7XG5cdFx0cmV0dXJuIGF0dHIgJiYgYXR0ci52YWx1ZSB8fCAnJztcblx0fSxcblx0Z2V0QXR0cmlidXRlTm9kZSA6IGZ1bmN0aW9uKG5hbWUpe1xuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKG5hbWUpO1xuXHR9LFxuXHRzZXRBdHRyaWJ1dGUgOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSl7XG5cdFx0dmFyIGF0dHIgPSB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlQXR0cmlidXRlKG5hbWUpO1xuXHRcdGF0dHIudmFsdWUgPSBhdHRyLm5vZGVWYWx1ZSA9IFwiXCIgKyB2YWx1ZTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZU5vZGUoYXR0cilcblx0fSxcblx0cmVtb3ZlQXR0cmlidXRlIDogZnVuY3Rpb24obmFtZSl7XG5cdFx0dmFyIGF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZU5vZGUobmFtZSlcblx0XHRhdHRyICYmIHRoaXMucmVtb3ZlQXR0cmlidXRlTm9kZShhdHRyKTtcblx0fSxcblx0XG5cdC8vZm91ciByZWFsIG9wZWFydGlvbiBtZXRob2Rcblx0YXBwZW5kQ2hpbGQ6ZnVuY3Rpb24obmV3Q2hpbGQpe1xuXHRcdGlmKG5ld0NoaWxkLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFKXtcblx0XHRcdHJldHVybiB0aGlzLmluc2VydEJlZm9yZShuZXdDaGlsZCxudWxsKTtcblx0XHR9ZWxzZXtcblx0XHRcdHJldHVybiBfYXBwZW5kU2luZ2xlQ2hpbGQodGhpcyxuZXdDaGlsZCk7XG5cdFx0fVxuXHR9LFxuXHRzZXRBdHRyaWJ1dGVOb2RlIDogZnVuY3Rpb24obmV3QXR0cil7XG5cdFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5zZXROYW1lZEl0ZW0obmV3QXR0cik7XG5cdH0sXG5cdHNldEF0dHJpYnV0ZU5vZGVOUyA6IGZ1bmN0aW9uKG5ld0F0dHIpe1xuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuc2V0TmFtZWRJdGVtTlMobmV3QXR0cik7XG5cdH0sXG5cdHJlbW92ZUF0dHJpYnV0ZU5vZGUgOiBmdW5jdGlvbihvbGRBdHRyKXtcblx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnJlbW92ZU5hbWVkSXRlbShvbGRBdHRyLm5vZGVOYW1lKTtcblx0fSxcblx0Ly9nZXQgcmVhbCBhdHRyaWJ1dGUgbmFtZSxhbmQgcmVtb3ZlIGl0IGJ5IHJlbW92ZUF0dHJpYnV0ZU5vZGVcblx0cmVtb3ZlQXR0cmlidXRlTlMgOiBmdW5jdGlvbihuYW1lc3BhY2VVUkksIGxvY2FsTmFtZSl7XG5cdFx0dmFyIG9sZCA9IHRoaXMuZ2V0QXR0cmlidXRlTm9kZU5TKG5hbWVzcGFjZVVSSSwgbG9jYWxOYW1lKTtcblx0XHRvbGQgJiYgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOb2RlKG9sZCk7XG5cdH0sXG5cdFxuXHRoYXNBdHRyaWJ1dGVOUyA6IGZ1bmN0aW9uKG5hbWVzcGFjZVVSSSwgbG9jYWxOYW1lKXtcblx0XHRyZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGVOb2RlTlMobmFtZXNwYWNlVVJJLCBsb2NhbE5hbWUpIT1udWxsO1xuXHR9LFxuXHRnZXRBdHRyaWJ1dGVOUyA6IGZ1bmN0aW9uKG5hbWVzcGFjZVVSSSwgbG9jYWxOYW1lKXtcblx0XHR2YXIgYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlTm9kZU5TKG5hbWVzcGFjZVVSSSwgbG9jYWxOYW1lKTtcblx0XHRyZXR1cm4gYXR0ciAmJiBhdHRyLnZhbHVlIHx8ICcnO1xuXHR9LFxuXHRzZXRBdHRyaWJ1dGVOUyA6IGZ1bmN0aW9uKG5hbWVzcGFjZVVSSSwgcXVhbGlmaWVkTmFtZSwgdmFsdWUpe1xuXHRcdHZhciBhdHRyID0gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUF0dHJpYnV0ZU5TKG5hbWVzcGFjZVVSSSwgcXVhbGlmaWVkTmFtZSk7XG5cdFx0YXR0ci52YWx1ZSA9IGF0dHIubm9kZVZhbHVlID0gdmFsdWU7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGVOb2RlKGF0dHIpXG5cdH0sXG5cdGdldEF0dHJpYnV0ZU5vZGVOUyA6IGZ1bmN0aW9uKG5hbWVzcGFjZVVSSSwgbG9jYWxOYW1lKXtcblx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmdldE5hbWVkSXRlbU5TKG5hbWVzcGFjZVVSSSwgbG9jYWxOYW1lKTtcblx0fSxcblx0XG5cdGdldEVsZW1lbnRzQnlUYWdOYW1lIDogZnVuY3Rpb24odGFnTmFtZSl7XG5cdFx0cmV0dXJuIG5ldyBMaXZlTm9kZUxpc3QodGhpcyxmdW5jdGlvbihiYXNlKXtcblx0XHRcdHZhciBscyA9IFtdO1xuXHRcdFx0X3Zpc2l0Tm9kZShiYXNlLGZ1bmN0aW9uKG5vZGUpe1xuXHRcdFx0XHRpZihub2RlICE9PSBiYXNlICYmIG5vZGUubm9kZVR5cGUgPT0gRUxFTUVOVF9OT0RFICYmICh0YWdOYW1lID09PSAnKicgfHwgbm9kZS50YWdOYW1lID09IHRhZ05hbWUpKXtcblx0XHRcdFx0XHRscy5wdXNoKG5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBscztcblx0XHR9KTtcblx0fSxcblx0Z2V0RWxlbWVudHNCeVRhZ05hbWVOUyA6IGZ1bmN0aW9uKG5hbWVzcGFjZVVSSSwgbG9jYWxOYW1lKXtcblx0XHRyZXR1cm4gbmV3IExpdmVOb2RlTGlzdCh0aGlzLGZ1bmN0aW9uKGJhc2Upe1xuXHRcdFx0dmFyIGxzID0gW107XG5cdFx0XHRfdmlzaXROb2RlKGJhc2UsZnVuY3Rpb24obm9kZSl7XG5cdFx0XHRcdGlmKG5vZGUgIT09IGJhc2UgJiYgbm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIG5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VVUkkgJiYgKGxvY2FsTmFtZSA9PT0gJyonIHx8IG5vZGUubG9jYWxOYW1lID09IGxvY2FsTmFtZSkpe1xuXHRcdFx0XHRcdGxzLnB1c2gobm9kZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGxzO1xuXHRcdH0pO1xuXHR9XG59O1xuRG9jdW1lbnQucHJvdG90eXBlLmdldEVsZW1lbnRzQnlUYWdOYW1lID0gRWxlbWVudC5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeVRhZ05hbWU7XG5Eb2N1bWVudC5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeVRhZ05hbWVOUyA9IEVsZW1lbnQucHJvdG90eXBlLmdldEVsZW1lbnRzQnlUYWdOYW1lTlM7XG5cblxuX2V4dGVuZHMoRWxlbWVudCxOb2RlKTtcbmZ1bmN0aW9uIEF0dHIoKSB7XG59O1xuQXR0ci5wcm90b3R5cGUubm9kZVR5cGUgPSBBVFRSSUJVVEVfTk9ERTtcbl9leHRlbmRzKEF0dHIsTm9kZSk7XG5cblxuZnVuY3Rpb24gQ2hhcmFjdGVyRGF0YSgpIHtcbn07XG5DaGFyYWN0ZXJEYXRhLnByb3RvdHlwZSA9IHtcblx0ZGF0YSA6ICcnLFxuXHRzdWJzdHJpbmdEYXRhIDogZnVuY3Rpb24ob2Zmc2V0LCBjb3VudCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEuc3Vic3RyaW5nKG9mZnNldCwgb2Zmc2V0K2NvdW50KTtcblx0fSxcblx0YXBwZW5kRGF0YTogZnVuY3Rpb24odGV4dCkge1xuXHRcdHRleHQgPSB0aGlzLmRhdGErdGV4dDtcblx0XHR0aGlzLm5vZGVWYWx1ZSA9IHRoaXMuZGF0YSA9IHRleHQ7XG5cdFx0dGhpcy5sZW5ndGggPSB0ZXh0Lmxlbmd0aDtcblx0fSxcblx0aW5zZXJ0RGF0YTogZnVuY3Rpb24ob2Zmc2V0LHRleHQpIHtcblx0XHR0aGlzLnJlcGxhY2VEYXRhKG9mZnNldCwwLHRleHQpO1xuXHRcblx0fSxcblx0YXBwZW5kQ2hpbGQ6ZnVuY3Rpb24obmV3Q2hpbGQpe1xuXHRcdC8vaWYoIShuZXdDaGlsZCBpbnN0YW5jZW9mIENoYXJhY3RlckRhdGEpKXtcblx0XHRcdHRocm93IG5ldyBFcnJvcihFeGNlcHRpb25NZXNzYWdlWzNdKVxuXHRcdC8vfVxuXHRcdHJldHVybiBOb2RlLnByb3RvdHlwZS5hcHBlbmRDaGlsZC5hcHBseSh0aGlzLGFyZ3VtZW50cylcblx0fSxcblx0ZGVsZXRlRGF0YTogZnVuY3Rpb24ob2Zmc2V0LCBjb3VudCkge1xuXHRcdHRoaXMucmVwbGFjZURhdGEob2Zmc2V0LGNvdW50LFwiXCIpO1xuXHR9LFxuXHRyZXBsYWNlRGF0YTogZnVuY3Rpb24ob2Zmc2V0LCBjb3VudCwgdGV4dCkge1xuXHRcdHZhciBzdGFydCA9IHRoaXMuZGF0YS5zdWJzdHJpbmcoMCxvZmZzZXQpO1xuXHRcdHZhciBlbmQgPSB0aGlzLmRhdGEuc3Vic3RyaW5nKG9mZnNldCtjb3VudCk7XG5cdFx0dGV4dCA9IHN0YXJ0ICsgdGV4dCArIGVuZDtcblx0XHR0aGlzLm5vZGVWYWx1ZSA9IHRoaXMuZGF0YSA9IHRleHQ7XG5cdFx0dGhpcy5sZW5ndGggPSB0ZXh0Lmxlbmd0aDtcblx0fVxufVxuX2V4dGVuZHMoQ2hhcmFjdGVyRGF0YSxOb2RlKTtcbmZ1bmN0aW9uIFRleHQoKSB7XG59O1xuVGV4dC5wcm90b3R5cGUgPSB7XG5cdG5vZGVOYW1lIDogXCIjdGV4dFwiLFxuXHRub2RlVHlwZSA6IFRFWFRfTk9ERSxcblx0c3BsaXRUZXh0IDogZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0dmFyIHRleHQgPSB0aGlzLmRhdGE7XG5cdFx0dmFyIG5ld1RleHQgPSB0ZXh0LnN1YnN0cmluZyhvZmZzZXQpO1xuXHRcdHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBvZmZzZXQpO1xuXHRcdHRoaXMuZGF0YSA9IHRoaXMubm9kZVZhbHVlID0gdGV4dDtcblx0XHR0aGlzLmxlbmd0aCA9IHRleHQubGVuZ3RoO1xuXHRcdHZhciBuZXdOb2RlID0gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5ld1RleHQpO1xuXHRcdGlmKHRoaXMucGFyZW50Tm9kZSl7XG5cdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHRoaXMubmV4dFNpYmxpbmcpO1xuXHRcdH1cblx0XHRyZXR1cm4gbmV3Tm9kZTtcblx0fVxufVxuX2V4dGVuZHMoVGV4dCxDaGFyYWN0ZXJEYXRhKTtcbmZ1bmN0aW9uIENvbW1lbnQoKSB7XG59O1xuQ29tbWVudC5wcm90b3R5cGUgPSB7XG5cdG5vZGVOYW1lIDogXCIjY29tbWVudFwiLFxuXHRub2RlVHlwZSA6IENPTU1FTlRfTk9ERVxufVxuX2V4dGVuZHMoQ29tbWVudCxDaGFyYWN0ZXJEYXRhKTtcblxuZnVuY3Rpb24gQ0RBVEFTZWN0aW9uKCkge1xufTtcbkNEQVRBU2VjdGlvbi5wcm90b3R5cGUgPSB7XG5cdG5vZGVOYW1lIDogXCIjY2RhdGEtc2VjdGlvblwiLFxuXHRub2RlVHlwZSA6IENEQVRBX1NFQ1RJT05fTk9ERVxufVxuX2V4dGVuZHMoQ0RBVEFTZWN0aW9uLENoYXJhY3RlckRhdGEpO1xuXG5cbmZ1bmN0aW9uIERvY3VtZW50VHlwZSgpIHtcbn07XG5Eb2N1bWVudFR5cGUucHJvdG90eXBlLm5vZGVUeXBlID0gRE9DVU1FTlRfVFlQRV9OT0RFO1xuX2V4dGVuZHMoRG9jdW1lbnRUeXBlLE5vZGUpO1xuXG5mdW5jdGlvbiBOb3RhdGlvbigpIHtcbn07XG5Ob3RhdGlvbi5wcm90b3R5cGUubm9kZVR5cGUgPSBOT1RBVElPTl9OT0RFO1xuX2V4dGVuZHMoTm90YXRpb24sTm9kZSk7XG5cbmZ1bmN0aW9uIEVudGl0eSgpIHtcbn07XG5FbnRpdHkucHJvdG90eXBlLm5vZGVUeXBlID0gRU5USVRZX05PREU7XG5fZXh0ZW5kcyhFbnRpdHksTm9kZSk7XG5cbmZ1bmN0aW9uIEVudGl0eVJlZmVyZW5jZSgpIHtcbn07XG5FbnRpdHlSZWZlcmVuY2UucHJvdG90eXBlLm5vZGVUeXBlID0gRU5USVRZX1JFRkVSRU5DRV9OT0RFO1xuX2V4dGVuZHMoRW50aXR5UmVmZXJlbmNlLE5vZGUpO1xuXG5mdW5jdGlvbiBEb2N1bWVudEZyYWdtZW50KCkge1xufTtcbkRvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLm5vZGVOYW1lID1cdFwiI2RvY3VtZW50LWZyYWdtZW50XCI7XG5Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS5ub2RlVHlwZSA9XHRET0NVTUVOVF9GUkFHTUVOVF9OT0RFO1xuX2V4dGVuZHMoRG9jdW1lbnRGcmFnbWVudCxOb2RlKTtcblxuXG5mdW5jdGlvbiBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oKSB7XG59XG5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24ucHJvdG90eXBlLm5vZGVUeXBlID0gUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFO1xuX2V4dGVuZHMoUHJvY2Vzc2luZ0luc3RydWN0aW9uLE5vZGUpO1xuZnVuY3Rpb24gWE1MU2VyaWFsaXplcigpe31cblhNTFNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZVRvU3RyaW5nID0gZnVuY3Rpb24obm9kZSl7XG5cdHZhciBidWYgPSBbXTtcblx0c2VyaWFsaXplVG9TdHJpbmcobm9kZSxidWYpO1xuXHRyZXR1cm4gYnVmLmpvaW4oJycpO1xufVxuTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPWZ1bmN0aW9uKCl7XG5cdHJldHVybiBYTUxTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVUb1N0cmluZyh0aGlzKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVRvU3RyaW5nKG5vZGUsYnVmKXtcblx0c3dpdGNoKG5vZGUubm9kZVR5cGUpe1xuXHRjYXNlIEVMRU1FTlRfTk9ERTpcblx0XHR2YXIgYXR0cnMgPSBub2RlLmF0dHJpYnV0ZXM7XG5cdFx0dmFyIGxlbiA9IGF0dHJzLmxlbmd0aDtcblx0XHR2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG5cdFx0dmFyIG5vZGVOYW1lID0gbm9kZS50YWdOYW1lO1xuXHRcdHZhciBpc0hUTUwgPSBodG1sbnMgPT09IG5vZGUubmFtZXNwYWNlVVJJXG5cdFx0YnVmLnB1c2goJzwnLG5vZGVOYW1lKTtcblx0XHRmb3IodmFyIGk9MDtpPGxlbjtpKyspe1xuXHRcdFx0c2VyaWFsaXplVG9TdHJpbmcoYXR0cnMuaXRlbShpKSxidWYsaXNIVE1MKTtcblx0XHR9XG5cdFx0aWYoY2hpbGQgfHwgaXNIVE1MICYmICEvXig/Om1ldGF8bGlua3xpbWd8YnJ8aHJ8aW5wdXQpJC9pLnRlc3Qobm9kZU5hbWUpKXtcblx0XHRcdGJ1Zi5wdXNoKCc+Jyk7XG5cdFx0XHQvL2lmIGlzIGNkYXRhIGNoaWxkIG5vZGVcblx0XHRcdGlmKGlzSFRNTCAmJiAvXnNjcmlwdCQvaS50ZXN0KG5vZGVOYW1lKSl7XG5cdFx0XHRcdGlmKGNoaWxkKXtcblx0XHRcdFx0XHRidWYucHVzaChjaGlsZC5kYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHdoaWxlKGNoaWxkKXtcblx0XHRcdFx0XHRzZXJpYWxpemVUb1N0cmluZyhjaGlsZCxidWYpO1xuXHRcdFx0XHRcdGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGJ1Zi5wdXNoKCc8Lycsbm9kZU5hbWUsJz4nKTtcblx0XHR9ZWxzZXtcblx0XHRcdGJ1Zi5wdXNoKCcvPicpO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdGNhc2UgRE9DVU1FTlRfTk9ERTpcblx0Y2FzZSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuXHRcdHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcblx0XHR3aGlsZShjaGlsZCl7XG5cdFx0XHRzZXJpYWxpemVUb1N0cmluZyhjaGlsZCxidWYpO1xuXHRcdFx0Y2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcblx0XHR9XG5cdFx0cmV0dXJuO1xuXHRjYXNlIEFUVFJJQlVURV9OT0RFOlxuXHRcdHJldHVybiBidWYucHVzaCgnICcsbm9kZS5uYW1lLCc9XCInLG5vZGUudmFsdWUucmVwbGFjZSgvWzwmXCJdL2csX3htbEVuY29kZXIpLCdcIicpO1xuXHRjYXNlIFRFWFRfTk9ERTpcblx0XHRyZXR1cm4gYnVmLnB1c2gobm9kZS5kYXRhLnJlcGxhY2UoL1s8Jl0vZyxfeG1sRW5jb2RlcikpO1xuXHRjYXNlIENEQVRBX1NFQ1RJT05fTk9ERTpcblx0XHRyZXR1cm4gYnVmLnB1c2goICc8IVtDREFUQVsnLG5vZGUuZGF0YSwnXV0+Jyk7XG5cdGNhc2UgQ09NTUVOVF9OT0RFOlxuXHRcdHJldHVybiBidWYucHVzaCggXCI8IS0tXCIsbm9kZS5kYXRhLFwiLS0+XCIpO1xuXHRjYXNlIERPQ1VNRU5UX1RZUEVfTk9ERTpcblx0XHR2YXIgcHViaWQgPSBub2RlLnB1YmxpY0lkO1xuXHRcdHZhciBzeXNpZCA9IG5vZGUuc3lzdGVtSWQ7XG5cdFx0YnVmLnB1c2goJzwhRE9DVFlQRSAnLG5vZGUubmFtZSk7XG5cdFx0aWYocHViaWQpe1xuXHRcdFx0YnVmLnB1c2goJyBQVUJMSUMgXCInLHB1YmlkKTtcblx0XHRcdGlmIChzeXNpZCAmJiBzeXNpZCE9Jy4nKSB7XG5cdFx0XHRcdGJ1Zi5wdXNoKCAnXCIgXCInLHN5c2lkKTtcblx0XHRcdH1cblx0XHRcdGJ1Zi5wdXNoKCdcIj4nKTtcblx0XHR9ZWxzZSBpZihzeXNpZCAmJiBzeXNpZCE9Jy4nKXtcblx0XHRcdGJ1Zi5wdXNoKCcgU1lTVEVNIFwiJyxzeXNpZCwnXCI+Jyk7XG5cdFx0fWVsc2V7XG5cdFx0XHR2YXIgc3ViID0gbm9kZS5pbnRlcm5hbFN1YnNldDtcblx0XHRcdGlmKHN1Yil7XG5cdFx0XHRcdGJ1Zi5wdXNoKFwiIFtcIixzdWIsXCJdXCIpO1xuXHRcdFx0fVxuXHRcdFx0YnVmLnB1c2goXCI+XCIpO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdGNhc2UgUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFOlxuXHRcdHJldHVybiBidWYucHVzaCggXCI8P1wiLG5vZGUudGFyZ2V0LFwiIFwiLG5vZGUuZGF0YSxcIj8+XCIpO1xuXHRjYXNlIEVOVElUWV9SRUZFUkVOQ0VfTk9ERTpcblx0XHRyZXR1cm4gYnVmLnB1c2goICcmJyxub2RlLm5vZGVOYW1lLCc7Jyk7XG5cdC8vY2FzZSBFTlRJVFlfTk9ERTpcblx0Ly9jYXNlIE5PVEFUSU9OX05PREU6XG5cdGRlZmF1bHQ6XG5cdFx0YnVmLnB1c2goJz8/Jyxub2RlLm5vZGVOYW1lKTtcblx0fVxufVxuZnVuY3Rpb24gaW1wb3J0Tm9kZShkb2Msbm9kZSxkZWVwKXtcblx0dmFyIG5vZGUyO1xuXHRzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcblx0Y2FzZSBFTEVNRU5UX05PREU6XG5cdFx0bm9kZTIgPSBub2RlLmNsb25lTm9kZShmYWxzZSk7XG5cdFx0bm9kZTIub3duZXJEb2N1bWVudCA9IGRvYztcblx0XHQvL3ZhciBhdHRycyA9IG5vZGUyLmF0dHJpYnV0ZXM7XG5cdFx0Ly92YXIgbGVuID0gYXR0cnMubGVuZ3RoO1xuXHRcdC8vZm9yKHZhciBpPTA7aTxsZW47aSsrKXtcblx0XHRcdC8vbm9kZTIuc2V0QXR0cmlidXRlTm9kZU5TKGltcG9ydE5vZGUoZG9jLGF0dHJzLml0ZW0oaSksZGVlcCkpO1xuXHRcdC8vfVxuXHRjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG5cdFx0YnJlYWs7XG5cdGNhc2UgQVRUUklCVVRFX05PREU6XG5cdFx0ZGVlcCA9IHRydWU7XG5cdFx0YnJlYWs7XG5cdC8vY2FzZSBFTlRJVFlfUkVGRVJFTkNFX05PREU6XG5cdC8vY2FzZSBQUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREU6XG5cdC8vLy9jYXNlIFRFWFRfTk9ERTpcblx0Ly9jYXNlIENEQVRBX1NFQ1RJT05fTk9ERTpcblx0Ly9jYXNlIENPTU1FTlRfTk9ERTpcblx0Ly9cdGRlZXAgPSBmYWxzZTtcblx0Ly9cdGJyZWFrO1xuXHQvL2Nhc2UgRE9DVU1FTlRfTk9ERTpcblx0Ly9jYXNlIERPQ1VNRU5UX1RZUEVfTk9ERTpcblx0Ly9jYW5ub3QgYmUgaW1wb3J0ZWQuXG5cdC8vY2FzZSBFTlRJVFlfTk9ERTpcblx0Ly9jYXNlIE5PVEFUSU9OX05PREXvvJpcblx0Ly9jYW4gbm90IGhpdCBpbiBsZXZlbDNcblx0Ly9kZWZhdWx0OnRocm93IGU7XG5cdH1cblx0aWYoIW5vZGUyKXtcblx0XHRub2RlMiA9IG5vZGUuY2xvbmVOb2RlKGZhbHNlKTsvL2ZhbHNlXG5cdH1cblx0bm9kZTIub3duZXJEb2N1bWVudCA9IGRvYztcblx0bm9kZTIucGFyZW50Tm9kZSA9IG51bGw7XG5cdGlmKGRlZXApe1xuXHRcdHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcblx0XHR3aGlsZShjaGlsZCl7XG5cdFx0XHRub2RlMi5hcHBlbmRDaGlsZChpbXBvcnROb2RlKGRvYyxjaGlsZCxkZWVwKSk7XG5cdFx0XHRjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbm9kZTI7XG59XG4vL1xuLy92YXIgX3JlbGF0aW9uTWFwID0ge2ZpcnN0Q2hpbGQ6MSxsYXN0Q2hpbGQ6MSxwcmV2aW91c1NpYmxpbmc6MSxuZXh0U2libGluZzoxLFxuLy9cdFx0XHRcdFx0YXR0cmlidXRlczoxLGNoaWxkTm9kZXM6MSxwYXJlbnROb2RlOjEsZG9jdW1lbnRFbGVtZW50OjEsZG9jdHlwZSx9O1xuZnVuY3Rpb24gY2xvbmVOb2RlKGRvYyxub2RlLGRlZXApe1xuXHR2YXIgbm9kZTIgPSBuZXcgbm9kZS5jb25zdHJ1Y3RvcigpO1xuXHRmb3IodmFyIG4gaW4gbm9kZSl7XG5cdFx0dmFyIHYgPSBub2RlW25dO1xuXHRcdGlmKHR5cGVvZiB2ICE9ICdvYmplY3QnICl7XG5cdFx0XHRpZih2ICE9IG5vZGUyW25dKXtcblx0XHRcdFx0bm9kZTJbbl0gPSB2O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRpZihub2RlLmNoaWxkTm9kZXMpe1xuXHRcdG5vZGUyLmNoaWxkTm9kZXMgPSBuZXcgTm9kZUxpc3QoKTtcblx0fVxuXHRub2RlMi5vd25lckRvY3VtZW50ID0gZG9jO1xuXHRzd2l0Y2ggKG5vZGUyLm5vZGVUeXBlKSB7XG5cdGNhc2UgRUxFTUVOVF9OT0RFOlxuXHRcdHZhciBhdHRyc1x0PSBub2RlLmF0dHJpYnV0ZXM7XG5cdFx0dmFyIGF0dHJzMlx0PSBub2RlMi5hdHRyaWJ1dGVzID0gbmV3IE5hbWVkTm9kZU1hcCgpO1xuXHRcdHZhciBsZW4gPSBhdHRycy5sZW5ndGhcblx0XHRhdHRyczIuX293bmVyRWxlbWVudCA9IG5vZGUyO1xuXHRcdGZvcih2YXIgaT0wO2k8bGVuO2krKyl7XG5cdFx0XHRub2RlMi5zZXRBdHRyaWJ1dGVOb2RlKGNsb25lTm9kZShkb2MsYXR0cnMuaXRlbShpKSx0cnVlKSk7XG5cdFx0fVxuXHRcdGJyZWFrOztcblx0Y2FzZSBBVFRSSUJVVEVfTk9ERTpcblx0XHRkZWVwID0gdHJ1ZTtcblx0fVxuXHRpZihkZWVwKXtcblx0XHR2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG5cdFx0d2hpbGUoY2hpbGQpe1xuXHRcdFx0bm9kZTIuYXBwZW5kQ2hpbGQoY2xvbmVOb2RlKGRvYyxjaGlsZCxkZWVwKSk7XG5cdFx0XHRjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbm9kZTI7XG59XG5cbmZ1bmN0aW9uIF9fc2V0X18ob2JqZWN0LGtleSx2YWx1ZSl7XG5cdG9iamVjdFtrZXldID0gdmFsdWVcbn1cbi8vZG8gZHluYW1pY1xudHJ5e1xuXHRpZihPYmplY3QuZGVmaW5lUHJvcGVydHkpe1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaXZlTm9kZUxpc3QucHJvdG90eXBlLCdsZW5ndGgnLHtcblx0XHRcdGdldDpmdW5jdGlvbigpe1xuXHRcdFx0XHRfdXBkYXRlTGl2ZUxpc3QodGhpcyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLiQkbGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlLnByb3RvdHlwZSwndGV4dENvbnRlbnQnLHtcblx0XHRcdGdldDpmdW5jdGlvbigpe1xuXHRcdFx0XHRyZXR1cm4gZ2V0VGV4dENvbnRlbnQodGhpcyk7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OmZ1bmN0aW9uKGRhdGEpe1xuXHRcdFx0XHRzd2l0Y2godGhpcy5ub2RlVHlwZSl7XG5cdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0Y2FzZSAxMTpcblx0XHRcdFx0XHR3aGlsZSh0aGlzLmZpcnN0Q2hpbGQpe1xuXHRcdFx0XHRcdFx0dGhpcy5yZW1vdmVDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihkYXRhIHx8IFN0cmluZyhkYXRhKSl7XG5cdFx0XHRcdFx0XHR0aGlzLmFwcGVuZENoaWxkKHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkYXRhKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdC8vVE9ETzpcblx0XHRcdFx0XHR0aGlzLmRhdGEgPSBkYXRhO1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHR0aGlzLm5vZGVWYWx1ZSA9IGRhdGE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KVxuXHRcdFxuXHRcdGZ1bmN0aW9uIGdldFRleHRDb250ZW50KG5vZGUpe1xuXHRcdFx0c3dpdGNoKG5vZGUubm9kZVR5cGUpe1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0Y2FzZSAxMTpcblx0XHRcdFx0dmFyIGJ1ZiA9IFtdO1xuXHRcdFx0XHRub2RlID0gbm9kZS5maXJzdENoaWxkO1xuXHRcdFx0XHR3aGlsZShub2RlKXtcblx0XHRcdFx0XHRpZihub2RlLm5vZGVUeXBlIT09NyAmJiBub2RlLm5vZGVUeXBlICE9PTgpe1xuXHRcdFx0XHRcdFx0YnVmLnB1c2goZ2V0VGV4dENvbnRlbnQobm9kZSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRub2RlID0gbm9kZS5uZXh0U2libGluZztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gYnVmLmpvaW4oJycpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIG5vZGUubm9kZVZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRfX3NldF9fID0gZnVuY3Rpb24ob2JqZWN0LGtleSx2YWx1ZSl7XG5cdFx0XHQvL2NvbnNvbGUubG9nKHZhbHVlKVxuXHRcdFx0b2JqZWN0WyckJCcra2V5XSA9IHZhbHVlXG5cdFx0fVxuXHR9XG59Y2F0Y2goZSl7Ly9pZThcbn1cblxuaWYodHlwZW9mIHJlcXVpcmUgPT0gJ2Z1bmN0aW9uJyl7XG5cdGV4cG9ydHMuRE9NSW1wbGVtZW50YXRpb24gPSBET01JbXBsZW1lbnRhdGlvbjtcblx0ZXhwb3J0cy5YTUxTZXJpYWxpemVyID0gWE1MU2VyaWFsaXplcjtcbn1cbiIsIi8vWzRdICAgXHROYW1lU3RhcnRDaGFyXHQgICA6Oj0gICBcdFwiOlwiIHwgW0EtWl0gfCBcIl9cIiB8IFthLXpdIHwgWyN4QzAtI3hENl0gfCBbI3hEOC0jeEY2XSB8IFsjeEY4LSN4MkZGXSB8IFsjeDM3MC0jeDM3RF0gfCBbI3gzN0YtI3gxRkZGXSB8IFsjeDIwMEMtI3gyMDBEXSB8IFsjeDIwNzAtI3gyMThGXSB8IFsjeDJDMDAtI3gyRkVGXSB8IFsjeDMwMDEtI3hEN0ZGXSB8IFsjeEY5MDAtI3hGRENGXSB8IFsjeEZERjAtI3hGRkZEXSB8IFsjeDEwMDAwLSN4RUZGRkZdXHJcbi8vWzRhXSAgIFx0TmFtZUNoYXJcdCAgIDo6PSAgIFx0TmFtZVN0YXJ0Q2hhciB8IFwiLVwiIHwgXCIuXCIgfCBbMC05XSB8ICN4QjcgfCBbI3gwMzAwLSN4MDM2Rl0gfCBbI3gyMDNGLSN4MjA0MF1cclxuLy9bNV0gICBcdE5hbWVcdCAgIDo6PSAgIFx0TmFtZVN0YXJ0Q2hhciAoTmFtZUNoYXIpKlxyXG52YXIgbmFtZVN0YXJ0Q2hhciA9IC9bQS1aX2EtelxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdLy8vXFx1MTAwMDAtXFx1RUZGRkZcclxudmFyIG5hbWVDaGFyID0gbmV3IFJlZ0V4cChcIltcXFxcLVxcXFwuMC05XCIrbmFtZVN0YXJ0Q2hhci5zb3VyY2Uuc2xpY2UoMSwtMSkrXCJcXHUwMEI3XFx1MDMwMC1cXHUwMzZGXFxcXHV4MjAzRi1cXHUyMDQwXVwiKTtcclxudmFyIHRhZ05hbWVQYXR0ZXJuID0gbmV3IFJlZ0V4cCgnXicrbmFtZVN0YXJ0Q2hhci5zb3VyY2UrbmFtZUNoYXIuc291cmNlKycqKD86XFw6JytuYW1lU3RhcnRDaGFyLnNvdXJjZStuYW1lQ2hhci5zb3VyY2UrJyopPyQnKTtcclxuLy92YXIgdGFnTmFtZVBhdHRlcm4gPSAvXlthLXpBLVpfXVtcXHdcXC1cXC5dKig/OlxcOlthLXpBLVpfXVtcXHdcXC1cXC5dKik/JC9cclxuLy92YXIgaGFuZGxlcnMgPSAncmVzb2x2ZUVudGl0eSxnZXRFeHRlcm5hbFN1YnNldCxjaGFyYWN0ZXJzLGVuZERvY3VtZW50LGVuZEVsZW1lbnQsZW5kUHJlZml4TWFwcGluZyxpZ25vcmFibGVXaGl0ZXNwYWNlLHByb2Nlc3NpbmdJbnN0cnVjdGlvbixzZXREb2N1bWVudExvY2F0b3Isc2tpcHBlZEVudGl0eSxzdGFydERvY3VtZW50LHN0YXJ0RWxlbWVudCxzdGFydFByZWZpeE1hcHBpbmcsbm90YXRpb25EZWNsLHVucGFyc2VkRW50aXR5RGVjbCxlcnJvcixmYXRhbEVycm9yLHdhcm5pbmcsYXR0cmlidXRlRGVjbCxlbGVtZW50RGVjbCxleHRlcm5hbEVudGl0eURlY2wsaW50ZXJuYWxFbnRpdHlEZWNsLGNvbW1lbnQsZW5kQ0RBVEEsZW5kRFRELGVuZEVudGl0eSxzdGFydENEQVRBLHN0YXJ0RFRELHN0YXJ0RW50aXR5Jy5zcGxpdCgnLCcpXHJcblxyXG4vL1NfVEFHLFx0U19BVFRSLFx0U19FUSxcdFNfVlxyXG4vL1NfQVRUUl9TLFx0U19FLFx0U19TLFx0U19DXHJcbnZhciBTX1RBRyA9IDA7Ly90YWcgbmFtZSBvZmZlcnJpbmdcclxudmFyIFNfQVRUUiA9IDE7Ly9hdHRyIG5hbWUgb2ZmZXJyaW5nIFxyXG52YXIgU19BVFRSX1M9MjsvL2F0dHIgbmFtZSBlbmQgYW5kIHNwYWNlIG9mZmVyXHJcbnZhciBTX0VRID0gMzsvLz1zcGFjZT9cclxudmFyIFNfViA9IDQ7Ly9hdHRyIHZhbHVlKG5vIHF1b3QgdmFsdWUgb25seSlcclxudmFyIFNfRSA9IDU7Ly9hdHRyIHZhbHVlIGVuZCBhbmQgbm8gc3BhY2UocXVvdCBlbmQpXHJcbnZhciBTX1MgPSA2Oy8vKGF0dHIgdmFsdWUgZW5kIHx8IHRhZyBlbmQgKSAmJiAoc3BhY2Ugb2ZmZXIpXHJcbnZhciBTX0MgPSA3Oy8vY2xvc2VkIGVsPGVsIC8+XHJcblxyXG5mdW5jdGlvbiBYTUxSZWFkZXIoKXtcclxuXHRcclxufVxyXG5cclxuWE1MUmVhZGVyLnByb3RvdHlwZSA9IHtcclxuXHRwYXJzZTpmdW5jdGlvbihzb3VyY2UsZGVmYXVsdE5TTWFwLGVudGl0eU1hcCl7XHJcblx0XHR2YXIgZG9tQnVpbGRlciA9IHRoaXMuZG9tQnVpbGRlcjtcclxuXHRcdGRvbUJ1aWxkZXIuc3RhcnREb2N1bWVudCgpO1xyXG5cdFx0X2NvcHkoZGVmYXVsdE5TTWFwICxkZWZhdWx0TlNNYXAgPSB7fSlcclxuXHRcdHBhcnNlKHNvdXJjZSxkZWZhdWx0TlNNYXAsZW50aXR5TWFwLFxyXG5cdFx0XHRcdGRvbUJ1aWxkZXIsdGhpcy5lcnJvckhhbmRsZXIpO1xyXG5cdFx0ZG9tQnVpbGRlci5lbmREb2N1bWVudCgpO1xyXG5cdH1cclxufVxyXG5mdW5jdGlvbiBwYXJzZShzb3VyY2UsZGVmYXVsdE5TTWFwQ29weSxlbnRpdHlNYXAsZG9tQnVpbGRlcixlcnJvckhhbmRsZXIpe1xyXG4gIGZ1bmN0aW9uIGZpeGVkRnJvbUNoYXJDb2RlKGNvZGUpIHtcclxuXHRcdC8vIFN0cmluZy5wcm90b3R5cGUuZnJvbUNoYXJDb2RlIGRvZXMgbm90IHN1cHBvcnRzXHJcblx0XHQvLyA+IDIgYnl0ZXMgdW5pY29kZSBjaGFycyBkaXJlY3RseVxyXG5cdFx0aWYgKGNvZGUgPiAweGZmZmYpIHtcclxuXHRcdFx0Y29kZSAtPSAweDEwMDAwO1xyXG5cdFx0XHR2YXIgc3Vycm9nYXRlMSA9IDB4ZDgwMCArIChjb2RlID4+IDEwKVxyXG5cdFx0XHRcdCwgc3Vycm9nYXRlMiA9IDB4ZGMwMCArIChjb2RlICYgMHgzZmYpO1xyXG5cclxuXHRcdFx0cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoc3Vycm9nYXRlMSwgc3Vycm9nYXRlMik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcclxuXHRcdH1cclxuXHR9XHJcblx0ZnVuY3Rpb24gZW50aXR5UmVwbGFjZXIoYSl7XHJcblx0XHR2YXIgayA9IGEuc2xpY2UoMSwtMSk7XHJcblx0XHRpZihrIGluIGVudGl0eU1hcCl7XHJcblx0XHRcdHJldHVybiBlbnRpdHlNYXBba107IFxyXG5cdFx0fWVsc2UgaWYoay5jaGFyQXQoMCkgPT09ICcjJyl7XHJcblx0XHRcdHJldHVybiBmaXhlZEZyb21DaGFyQ29kZShwYXJzZUludChrLnN1YnN0cigxKS5yZXBsYWNlKCd4JywnMHgnKSkpXHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0ZXJyb3JIYW5kbGVyLmVycm9yKCdlbnRpdHkgbm90IGZvdW5kOicrYSk7XHJcblx0XHRcdHJldHVybiBhO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRmdW5jdGlvbiBhcHBlbmRUZXh0KGVuZCl7Ly9oYXMgc29tZSBidWdzXHJcblx0XHR2YXIgeHQgPSBzb3VyY2Uuc3Vic3RyaW5nKHN0YXJ0LGVuZCkucmVwbGFjZSgvJiM/XFx3KzsvZyxlbnRpdHlSZXBsYWNlcik7XHJcblx0XHRsb2NhdG9yJiZwb3NpdGlvbihzdGFydCk7XHJcblx0XHRkb21CdWlsZGVyLmNoYXJhY3RlcnMoeHQsMCxlbmQtc3RhcnQpO1xyXG5cdFx0c3RhcnQgPSBlbmRcclxuXHR9XHJcblx0ZnVuY3Rpb24gcG9zaXRpb24oc3RhcnQsbSl7XHJcblx0XHR3aGlsZShzdGFydD49ZW5kUG9zICYmIChtID0gbGluZVBhdHRlcm4uZXhlYyhzb3VyY2UpKSl7XHJcblx0XHRcdHN0YXJ0UG9zID0gbS5pbmRleDtcclxuXHRcdFx0ZW5kUG9zID0gc3RhcnRQb3MgKyBtWzBdLmxlbmd0aDtcclxuXHRcdFx0bG9jYXRvci5saW5lTnVtYmVyKys7XHJcblx0XHRcdC8vY29uc29sZS5sb2coJ2xpbmUrKzonLGxvY2F0b3Isc3RhcnRQb3MsZW5kUG9zKVxyXG5cdFx0fVxyXG5cdFx0bG9jYXRvci5jb2x1bW5OdW1iZXIgPSBzdGFydC1zdGFydFBvcysxO1xyXG5cdH1cclxuXHR2YXIgc3RhcnRQb3MgPSAwO1xyXG5cdHZhciBlbmRQb3MgPSAwO1xyXG5cdHZhciBsaW5lUGF0dGVybiA9IC8uKyg/Olxcclxcbj98XFxuKXwuKiQvZ1xyXG5cdHZhciBsb2NhdG9yID0gZG9tQnVpbGRlci5sb2NhdG9yO1xyXG5cdFxyXG5cdHZhciBwYXJzZVN0YWNrID0gW3tjdXJyZW50TlNNYXA6ZGVmYXVsdE5TTWFwQ29weX1dXHJcblx0dmFyIGNsb3NlTWFwID0ge307XHJcblx0dmFyIHN0YXJ0ID0gMDtcclxuXHR3aGlsZSh0cnVlKXtcclxuXHRcdHZhciBpID0gc291cmNlLmluZGV4T2YoJzwnLHN0YXJ0KTtcclxuXHRcdGlmKGk8MCl7XHJcblx0XHRcdGlmKCFzb3VyY2Uuc3Vic3RyKHN0YXJ0KS5tYXRjaCgvXlxccyokLykpe1xyXG5cdFx0XHRcdHZhciBkb2MgPSBkb21CdWlsZGVyLmRvY3VtZW50O1xyXG4gICAgXHRcdFx0dmFyIHRleHQgPSBkb2MuY3JlYXRlVGV4dE5vZGUoc291cmNlLnN1YnN0cihzdGFydCkpO1xyXG4gICAgXHRcdFx0ZG9jLmFwcGVuZENoaWxkKHRleHQpO1xyXG4gICAgXHRcdFx0ZG9tQnVpbGRlci5jdXJyZW50RWxlbWVudCA9IHRleHQ7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0aWYoaT5zdGFydCl7XHJcblx0XHRcdGFwcGVuZFRleHQoaSk7XHJcblx0XHR9XHJcblx0XHRzd2l0Y2goc291cmNlLmNoYXJBdChpKzEpKXtcclxuXHRcdGNhc2UgJy8nOlxyXG5cdFx0XHR2YXIgZW5kID0gc291cmNlLmluZGV4T2YoJz4nLGkrMyk7XHJcblx0XHRcdHZhciB0YWdOYW1lID0gc291cmNlLnN1YnN0cmluZyhpKzIsZW5kKTtcclxuXHRcdFx0dmFyIGNvbmZpZyA9IHBhcnNlU3RhY2sucG9wKCk7XHJcblx0XHRcdHZhciBsb2NhbE5TTWFwID0gY29uZmlnLmxvY2FsTlNNYXA7XHJcblx0XHRcdFxyXG5cdCAgICAgICAgaWYoY29uZmlnLnRhZ05hbWUgIT0gdGFnTmFtZSl7XHJcblx0ICAgICAgICAgICAgZXJyb3JIYW5kbGVyLmZhdGFsRXJyb3IoXCJlbmQgdGFnIG5hbWU6IFwiK3RhZ05hbWUrJyBpcyBub3QgbWF0Y2ggdGhlIGN1cnJlbnQgc3RhcnQgdGFnTmFtZTonK2NvbmZpZy50YWdOYW1lICk7XHJcblx0ICAgICAgICB9XHJcblx0XHRcdGRvbUJ1aWxkZXIuZW5kRWxlbWVudChjb25maWcudXJpLGNvbmZpZy5sb2NhbE5hbWUsdGFnTmFtZSk7XHJcblx0XHRcdGlmKGxvY2FsTlNNYXApe1xyXG5cdFx0XHRcdGZvcih2YXIgcHJlZml4IGluIGxvY2FsTlNNYXApe1xyXG5cdFx0XHRcdFx0ZG9tQnVpbGRlci5lbmRQcmVmaXhNYXBwaW5nKHByZWZpeCkgO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbmQrKztcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRcdC8vIGVuZCBlbG1lbnRcclxuXHRcdGNhc2UgJz8nOi8vIDw/Li4uPz5cclxuXHRcdFx0bG9jYXRvciYmcG9zaXRpb24oaSk7XHJcblx0XHRcdGVuZCA9IHBhcnNlSW5zdHJ1Y3Rpb24oc291cmNlLGksZG9tQnVpbGRlcik7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSAnISc6Ly8gPCFkb2N0eXBlLDwhW0NEQVRBLDwhLS1cclxuXHRcdFx0bG9jYXRvciYmcG9zaXRpb24oaSk7XHJcblx0XHRcdGVuZCA9IHBhcnNlRENDKHNvdXJjZSxpLGRvbUJ1aWxkZXIsZXJyb3JIYW5kbGVyKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHR0cnl7XHJcblx0XHRcdFx0bG9jYXRvciYmcG9zaXRpb24oaSk7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0dmFyIGVsID0gbmV3IEVsZW1lbnRBdHRyaWJ1dGVzKCk7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly9lbFN0YXJ0RW5kXHJcblx0XHRcdFx0dmFyIGVuZCA9IHBhcnNlRWxlbWVudFN0YXJ0UGFydChzb3VyY2UsaSxlbCxlbnRpdHlSZXBsYWNlcixlcnJvckhhbmRsZXIpO1xyXG5cdFx0XHRcdHZhciBsZW4gPSBlbC5sZW5ndGg7XHJcblx0XHRcdFx0Ly9wb3NpdGlvbiBmaXhlZFxyXG5cdFx0XHRcdGlmKGxlbiAmJiBsb2NhdG9yKXtcclxuXHRcdFx0XHRcdHZhciBiYWNrdXAgPSBjb3B5TG9jYXRvcihsb2NhdG9yLHt9KTtcclxuXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7aTxsZW47aSsrKXtcclxuXHRcdFx0XHRcdFx0dmFyIGEgPSBlbFtpXTtcclxuXHRcdFx0XHRcdFx0cG9zaXRpb24oYS5vZmZzZXQpO1xyXG5cdFx0XHRcdFx0XHRhLm9mZnNldCA9IGNvcHlMb2NhdG9yKGxvY2F0b3Ise30pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Y29weUxvY2F0b3IoYmFja3VwLGxvY2F0b3IpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZighZWwuY2xvc2VkICYmIGZpeFNlbGZDbG9zZWQoc291cmNlLGVuZCxlbC50YWdOYW1lLGNsb3NlTWFwKSl7XHJcblx0XHRcdFx0XHRlbC5jbG9zZWQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0aWYoIWVudGl0eU1hcC5uYnNwKXtcclxuXHRcdFx0XHRcdFx0ZXJyb3JIYW5kbGVyLndhcm5pbmcoJ3VuY2xvc2VkIHhtbCBhdHRyaWJ1dGUnKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YXBwZW5kRWxlbWVudChlbCxkb21CdWlsZGVyLHBhcnNlU3RhY2spO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGlmKGVsLnVyaSA9PT0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnICYmICFlbC5jbG9zZWQpe1xyXG5cdFx0XHRcdFx0ZW5kID0gcGFyc2VIdG1sU3BlY2lhbENvbnRlbnQoc291cmNlLGVuZCxlbC50YWdOYW1lLGVudGl0eVJlcGxhY2VyLGRvbUJ1aWxkZXIpXHJcblx0XHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0XHRlbmQrKztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1jYXRjaChlKXtcclxuXHRcdFx0XHRlcnJvckhhbmRsZXIuZXJyb3IoJ2VsZW1lbnQgcGFyc2UgZXJyb3I6ICcrZSk7XHJcblx0XHRcdFx0ZW5kID0gLTE7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblx0XHRpZihlbmQ8MCl7XHJcblx0XHRcdC8vVE9ETzog6L+Z6YeM5pyJ5Y+v6IO9c2F45Zue6YCA77yM5pyJ5L2N572u6ZSZ6K+v6aOO6ZmpXHJcblx0XHRcdGFwcGVuZFRleHQoaSsxKTtcclxuXHRcdH1lbHNle1xyXG5cdFx0XHRzdGFydCA9IGVuZDtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuZnVuY3Rpb24gY29weUxvY2F0b3IoZix0KXtcclxuXHR0LmxpbmVOdW1iZXIgPSBmLmxpbmVOdW1iZXI7XHJcblx0dC5jb2x1bW5OdW1iZXIgPSBmLmNvbHVtbk51bWJlcjtcclxuXHRyZXR1cm4gdDtcclxuXHRcclxufVxyXG5cclxuLyoqXHJcbiAqIEBzZWUgI2FwcGVuZEVsZW1lbnQoc291cmNlLGVsU3RhcnRFbmQsZWwsc2VsZkNsb3NlZCxlbnRpdHlSZXBsYWNlcixkb21CdWlsZGVyLHBhcnNlU3RhY2spO1xyXG4gKiBAcmV0dXJuIGVuZCBvZiB0aGUgZWxlbWVudFN0YXJ0UGFydChlbmQgb2YgZWxlbWVudEVuZFBhcnQgZm9yIHNlbGZDbG9zZWQgZWwpXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZUVsZW1lbnRTdGFydFBhcnQoc291cmNlLHN0YXJ0LGVsLGVudGl0eVJlcGxhY2VyLGVycm9ySGFuZGxlcil7XHJcblx0dmFyIGF0dHJOYW1lO1xyXG5cdHZhciB2YWx1ZTtcclxuXHR2YXIgcCA9ICsrc3RhcnQ7XHJcblx0dmFyIHMgPSBTX1RBRzsvL3N0YXR1c1xyXG5cdHdoaWxlKHRydWUpe1xyXG5cdFx0dmFyIGMgPSBzb3VyY2UuY2hhckF0KHApO1xyXG5cdFx0c3dpdGNoKGMpe1xyXG5cdFx0Y2FzZSAnPSc6XHJcblx0XHRcdGlmKHMgPT09IFNfQVRUUil7Ly9hdHRyTmFtZVxyXG5cdFx0XHRcdGF0dHJOYW1lID0gc291cmNlLnNsaWNlKHN0YXJ0LHApO1xyXG5cdFx0XHRcdHMgPSBTX0VRO1xyXG5cdFx0XHR9ZWxzZSBpZihzID09PSBTX0FUVFJfUyl7XHJcblx0XHRcdFx0cyA9IFNfRVE7XHJcblx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdC8vZmF0YWxFcnJvcjogZXF1YWwgbXVzdCBhZnRlciBhdHRyTmFtZSBvciBzcGFjZSBhZnRlciBhdHRyTmFtZVxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignYXR0cmlidXRlIGVxdWFsIG11c3QgYWZ0ZXIgYXR0ck5hbWUnKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJ1xcJyc6XHJcblx0XHRjYXNlICdcIic6XHJcblx0XHRcdGlmKHMgPT09IFNfRVEpey8vZXF1YWxcclxuXHRcdFx0XHRzdGFydCA9IHArMTtcclxuXHRcdFx0XHRwID0gc291cmNlLmluZGV4T2YoYyxzdGFydClcclxuXHRcdFx0XHRpZihwPjApe1xyXG5cdFx0XHRcdFx0dmFsdWUgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQscCkucmVwbGFjZSgvJiM/XFx3KzsvZyxlbnRpdHlSZXBsYWNlcik7XHJcblx0XHRcdFx0XHRlbC5hZGQoYXR0ck5hbWUsdmFsdWUsc3RhcnQtMSk7XHJcblx0XHRcdFx0XHRzID0gU19FO1xyXG5cdFx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdFx0Ly9mYXRhbEVycm9yOiBubyBlbmQgcXVvdCBtYXRjaFxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdhdHRyaWJ1dGUgdmFsdWUgbm8gZW5kIFxcJycrYysnXFwnIG1hdGNoJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9ZWxzZSBpZihzID09IFNfVil7XHJcblx0XHRcdFx0dmFsdWUgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQscCkucmVwbGFjZSgvJiM/XFx3KzsvZyxlbnRpdHlSZXBsYWNlcik7XHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhhdHRyTmFtZSx2YWx1ZSxzdGFydCxwKVxyXG5cdFx0XHRcdGVsLmFkZChhdHRyTmFtZSx2YWx1ZSxzdGFydCk7XHJcblx0XHRcdFx0Ly9jb25zb2xlLmRpcihlbClcclxuXHRcdFx0XHRlcnJvckhhbmRsZXIud2FybmluZygnYXR0cmlidXRlIFwiJythdHRyTmFtZSsnXCIgbWlzc2VkIHN0YXJ0IHF1b3QoJytjKycpISEnKTtcclxuXHRcdFx0XHRzdGFydCA9IHArMTtcclxuXHRcdFx0XHRzID0gU19FXHJcblx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdC8vZmF0YWxFcnJvcjogbm8gZXF1YWwgYmVmb3JlXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdhdHRyaWJ1dGUgdmFsdWUgbXVzdCBhZnRlciBcIj1cIicpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSAnLyc6XHJcblx0XHRcdHN3aXRjaChzKXtcclxuXHRcdFx0Y2FzZSBTX1RBRzpcclxuXHRcdFx0XHRlbC5zZXRUYWdOYW1lKHNvdXJjZS5zbGljZShzdGFydCxwKSk7XHJcblx0XHRcdGNhc2UgU19FOlxyXG5cdFx0XHRjYXNlIFNfUzpcclxuXHRcdFx0Y2FzZSBTX0M6XHJcblx0XHRcdFx0cyA9IFNfQztcclxuXHRcdFx0XHRlbC5jbG9zZWQgPSB0cnVlO1xyXG5cdFx0XHRjYXNlIFNfVjpcclxuXHRcdFx0Y2FzZSBTX0FUVFI6XHJcblx0XHRcdGNhc2UgU19BVFRSX1M6XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdC8vY2FzZSBTX0VROlxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImF0dHJpYnV0ZSBpbnZhbGlkIGNsb3NlIGNoYXIoJy8nKVwiKVxyXG5cdFx0XHR9XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSAnJzovL2VuZCBkb2N1bWVudFxyXG5cdFx0XHQvL3Rocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnKVxyXG5cdFx0XHRlcnJvckhhbmRsZXIuZXJyb3IoJ3VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XHJcblx0XHRjYXNlICc+JzpcclxuXHRcdFx0c3dpdGNoKHMpe1xyXG5cdFx0XHRjYXNlIFNfVEFHOlxyXG5cdFx0XHRcdGVsLnNldFRhZ05hbWUoc291cmNlLnNsaWNlKHN0YXJ0LHApKTtcclxuXHRcdFx0Y2FzZSBTX0U6XHJcblx0XHRcdGNhc2UgU19TOlxyXG5cdFx0XHRjYXNlIFNfQzpcclxuXHRcdFx0XHRicmVhazsvL25vcm1hbFxyXG5cdFx0XHRjYXNlIFNfVjovL0NvbXBhdGlibGUgc3RhdGVcclxuXHRcdFx0Y2FzZSBTX0FUVFI6XHJcblx0XHRcdFx0dmFsdWUgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQscCk7XHJcblx0XHRcdFx0aWYodmFsdWUuc2xpY2UoLTEpID09PSAnLycpe1xyXG5cdFx0XHRcdFx0ZWwuY2xvc2VkICA9IHRydWU7XHJcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsLTEpXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRjYXNlIFNfQVRUUl9TOlxyXG5cdFx0XHRcdGlmKHMgPT09IFNfQVRUUl9TKXtcclxuXHRcdFx0XHRcdHZhbHVlID0gYXR0ck5hbWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHMgPT0gU19WKXtcclxuXHRcdFx0XHRcdGVycm9ySGFuZGxlci53YXJuaW5nKCdhdHRyaWJ1dGUgXCInK3ZhbHVlKydcIiBtaXNzZWQgcXVvdChcIikhIScpO1xyXG5cdFx0XHRcdFx0ZWwuYWRkKGF0dHJOYW1lLHZhbHVlLnJlcGxhY2UoLyYjP1xcdys7L2csZW50aXR5UmVwbGFjZXIpLHN0YXJ0KVxyXG5cdFx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdFx0ZXJyb3JIYW5kbGVyLndhcm5pbmcoJ2F0dHJpYnV0ZSBcIicrdmFsdWUrJ1wiIG1pc3NlZCB2YWx1ZSEhIFwiJyt2YWx1ZSsnXCIgaW5zdGVhZCEhJylcclxuXHRcdFx0XHRcdGVsLmFkZCh2YWx1ZSx2YWx1ZSxzdGFydClcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgU19FUTpcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2F0dHJpYnV0ZSB2YWx1ZSBtaXNzZWQhIScpO1xyXG5cdFx0XHR9XHJcbi8vXHRcdFx0Y29uc29sZS5sb2codGFnTmFtZSx0YWdOYW1lUGF0dGVybix0YWdOYW1lUGF0dGVybi50ZXN0KHRhZ05hbWUpKVxyXG5cdFx0XHRyZXR1cm4gcDtcclxuXHRcdC8qeG1sIHNwYWNlICdcXHgyMCcgfCAjeDkgfCAjeEQgfCAjeEE7ICovXHJcblx0XHRjYXNlICdcXHUwMDgwJzpcclxuXHRcdFx0YyA9ICcgJztcclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdGlmKGM8PSAnICcpey8vc3BhY2VcclxuXHRcdFx0XHRzd2l0Y2gocyl7XHJcblx0XHRcdFx0Y2FzZSBTX1RBRzpcclxuXHRcdFx0XHRcdGVsLnNldFRhZ05hbWUoc291cmNlLnNsaWNlKHN0YXJ0LHApKTsvL3RhZ05hbWVcclxuXHRcdFx0XHRcdHMgPSBTX1M7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFNfQVRUUjpcclxuXHRcdFx0XHRcdGF0dHJOYW1lID0gc291cmNlLnNsaWNlKHN0YXJ0LHApXHJcblx0XHRcdFx0XHRzID0gU19BVFRSX1M7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFNfVjpcclxuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IHNvdXJjZS5zbGljZShzdGFydCxwKS5yZXBsYWNlKC8mIz9cXHcrOy9nLGVudGl0eVJlcGxhY2VyKTtcclxuXHRcdFx0XHRcdGVycm9ySGFuZGxlci53YXJuaW5nKCdhdHRyaWJ1dGUgXCInK3ZhbHVlKydcIiBtaXNzZWQgcXVvdChcIikhIScpO1xyXG5cdFx0XHRcdFx0ZWwuYWRkKGF0dHJOYW1lLHZhbHVlLHN0YXJ0KVxyXG5cdFx0XHRcdGNhc2UgU19FOlxyXG5cdFx0XHRcdFx0cyA9IFNfUztcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdC8vY2FzZSBTX1M6XHJcblx0XHRcdFx0Ly9jYXNlIFNfRVE6XHJcblx0XHRcdFx0Ly9jYXNlIFNfQVRUUl9TOlxyXG5cdFx0XHRcdC8vXHR2b2lkKCk7YnJlYWs7XHJcblx0XHRcdFx0Ly9jYXNlIFNfQzpcclxuXHRcdFx0XHRcdC8vaWdub3JlIHdhcm5pbmdcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1lbHNley8vbm90IHNwYWNlXHJcbi8vU19UQUcsXHRTX0FUVFIsXHRTX0VRLFx0U19WXHJcbi8vU19BVFRSX1MsXHRTX0UsXHRTX1MsXHRTX0NcclxuXHRcdFx0XHRzd2l0Y2gocyl7XHJcblx0XHRcdFx0Ly9jYXNlIFNfVEFHOnZvaWQoKTticmVhaztcclxuXHRcdFx0XHQvL2Nhc2UgU19BVFRSOnZvaWQoKTticmVhaztcclxuXHRcdFx0XHQvL2Nhc2UgU19WOnZvaWQoKTticmVhaztcclxuXHRcdFx0XHRjYXNlIFNfQVRUUl9TOlxyXG5cdFx0XHRcdFx0ZXJyb3JIYW5kbGVyLndhcm5pbmcoJ2F0dHJpYnV0ZSBcIicrYXR0ck5hbWUrJ1wiIG1pc3NlZCB2YWx1ZSEhIFwiJythdHRyTmFtZSsnXCIgaW5zdGVhZCEhJylcclxuXHRcdFx0XHRcdGVsLmFkZChhdHRyTmFtZSxhdHRyTmFtZSxzdGFydCk7XHJcblx0XHRcdFx0XHRzdGFydCA9IHA7XHJcblx0XHRcdFx0XHRzID0gU19BVFRSO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBTX0U6XHJcblx0XHRcdFx0XHRlcnJvckhhbmRsZXIud2FybmluZygnYXR0cmlidXRlIHNwYWNlIGlzIHJlcXVpcmVkXCInK2F0dHJOYW1lKydcIiEhJylcclxuXHRcdFx0XHRjYXNlIFNfUzpcclxuXHRcdFx0XHRcdHMgPSBTX0FUVFI7XHJcblx0XHRcdFx0XHRzdGFydCA9IHA7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFNfRVE6XHJcblx0XHRcdFx0XHRzID0gU19WO1xyXG5cdFx0XHRcdFx0c3RhcnQgPSBwO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBTX0M6XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJlbGVtZW50cyBjbG9zZWQgY2hhcmFjdGVyICcvJyBhbmQgJz4nIG11c3QgYmUgY29ubmVjdGVkIHRvXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cCsrO1xyXG5cdH1cclxufVxyXG4vKipcclxuICogQHJldHVybiBlbmQgb2YgdGhlIGVsZW1lbnRTdGFydFBhcnQoZW5kIG9mIGVsZW1lbnRFbmRQYXJ0IGZvciBzZWxmQ2xvc2VkIGVsKVxyXG4gKi9cclxuZnVuY3Rpb24gYXBwZW5kRWxlbWVudChlbCxkb21CdWlsZGVyLHBhcnNlU3RhY2spe1xyXG5cdHZhciB0YWdOYW1lID0gZWwudGFnTmFtZTtcclxuXHR2YXIgbG9jYWxOU01hcCA9IG51bGw7XHJcblx0dmFyIGN1cnJlbnROU01hcCA9IHBhcnNlU3RhY2tbcGFyc2VTdGFjay5sZW5ndGgtMV0uY3VycmVudE5TTWFwO1xyXG5cdHZhciBpID0gZWwubGVuZ3RoO1xyXG5cdHdoaWxlKGktLSl7XHJcblx0XHR2YXIgYSA9IGVsW2ldO1xyXG5cdFx0dmFyIHFOYW1lID0gYS5xTmFtZTtcclxuXHRcdHZhciB2YWx1ZSA9IGEudmFsdWU7XHJcblx0XHR2YXIgbnNwID0gcU5hbWUuaW5kZXhPZignOicpO1xyXG5cdFx0aWYobnNwPjApe1xyXG5cdFx0XHR2YXIgcHJlZml4ID0gYS5wcmVmaXggPSBxTmFtZS5zbGljZSgwLG5zcCk7XHJcblx0XHRcdHZhciBsb2NhbE5hbWUgPSBxTmFtZS5zbGljZShuc3ArMSk7XHJcblx0XHRcdHZhciBuc1ByZWZpeCA9IHByZWZpeCA9PT0gJ3htbG5zJyAmJiBsb2NhbE5hbWVcclxuXHRcdH1lbHNle1xyXG5cdFx0XHRsb2NhbE5hbWUgPSBxTmFtZTtcclxuXHRcdFx0cHJlZml4ID0gbnVsbFxyXG5cdFx0XHRuc1ByZWZpeCA9IHFOYW1lID09PSAneG1sbnMnICYmICcnXHJcblx0XHR9XHJcblx0XHQvL2NhbiBub3Qgc2V0IHByZWZpeCxiZWNhdXNlIHByZWZpeCAhPT0gJydcclxuXHRcdGEubG9jYWxOYW1lID0gbG9jYWxOYW1lIDtcclxuXHRcdC8vcHJlZml4ID09IG51bGwgZm9yIG5vIG5zIHByZWZpeCBhdHRyaWJ1dGUgXHJcblx0XHRpZihuc1ByZWZpeCAhPT0gZmFsc2Upey8vaGFjayEhXHJcblx0XHRcdGlmKGxvY2FsTlNNYXAgPT0gbnVsbCl7XHJcblx0XHRcdFx0bG9jYWxOU01hcCA9IHt9XHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhjdXJyZW50TlNNYXAsMClcclxuXHRcdFx0XHRfY29weShjdXJyZW50TlNNYXAsY3VycmVudE5TTWFwPXt9KVxyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coY3VycmVudE5TTWFwLDEpXHJcblx0XHRcdH1cclxuXHRcdFx0Y3VycmVudE5TTWFwW25zUHJlZml4XSA9IGxvY2FsTlNNYXBbbnNQcmVmaXhdID0gdmFsdWU7XHJcblx0XHRcdGEudXJpID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJ1xyXG5cdFx0XHRkb21CdWlsZGVyLnN0YXJ0UHJlZml4TWFwcGluZyhuc1ByZWZpeCwgdmFsdWUpIFxyXG5cdFx0fVxyXG5cdH1cclxuXHR2YXIgaSA9IGVsLmxlbmd0aDtcclxuXHR3aGlsZShpLS0pe1xyXG5cdFx0YSA9IGVsW2ldO1xyXG5cdFx0dmFyIHByZWZpeCA9IGEucHJlZml4O1xyXG5cdFx0aWYocHJlZml4KXsvL25vIHByZWZpeCBhdHRyaWJ1dGUgaGFzIG5vIG5hbWVzcGFjZVxyXG5cdFx0XHRpZihwcmVmaXggPT09ICd4bWwnKXtcclxuXHRcdFx0XHRhLnVyaSA9ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnO1xyXG5cdFx0XHR9aWYocHJlZml4ICE9PSAneG1sbnMnKXtcclxuXHRcdFx0XHRhLnVyaSA9IGN1cnJlbnROU01hcFtwcmVmaXhdXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly97Y29uc29sZS5sb2coJyMjIycrYS5xTmFtZSxkb21CdWlsZGVyLmxvY2F0b3Iuc3lzdGVtSWQrJycsY3VycmVudE5TTWFwLGEudXJpKX1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHR2YXIgbnNwID0gdGFnTmFtZS5pbmRleE9mKCc6Jyk7XHJcblx0aWYobnNwPjApe1xyXG5cdFx0cHJlZml4ID0gZWwucHJlZml4ID0gdGFnTmFtZS5zbGljZSgwLG5zcCk7XHJcblx0XHRsb2NhbE5hbWUgPSBlbC5sb2NhbE5hbWUgPSB0YWdOYW1lLnNsaWNlKG5zcCsxKTtcclxuXHR9ZWxzZXtcclxuXHRcdHByZWZpeCA9IG51bGw7Ly9pbXBvcnRhbnQhIVxyXG5cdFx0bG9jYWxOYW1lID0gZWwubG9jYWxOYW1lID0gdGFnTmFtZTtcclxuXHR9XHJcblx0Ly9ubyBwcmVmaXggZWxlbWVudCBoYXMgZGVmYXVsdCBuYW1lc3BhY2VcclxuXHR2YXIgbnMgPSBlbC51cmkgPSBjdXJyZW50TlNNYXBbcHJlZml4IHx8ICcnXTtcclxuXHRkb21CdWlsZGVyLnN0YXJ0RWxlbWVudChucyxsb2NhbE5hbWUsdGFnTmFtZSxlbCk7XHJcblx0Ly9lbmRQcmVmaXhNYXBwaW5nIGFuZCBzdGFydFByZWZpeE1hcHBpbmcgaGF2ZSBub3QgYW55IGhlbHAgZm9yIGRvbSBidWlsZGVyXHJcblx0Ly9sb2NhbE5TTWFwID0gbnVsbFxyXG5cdGlmKGVsLmNsb3NlZCl7XHJcblx0XHRkb21CdWlsZGVyLmVuZEVsZW1lbnQobnMsbG9jYWxOYW1lLHRhZ05hbWUpO1xyXG5cdFx0aWYobG9jYWxOU01hcCl7XHJcblx0XHRcdGZvcihwcmVmaXggaW4gbG9jYWxOU01hcCl7XHJcblx0XHRcdFx0ZG9tQnVpbGRlci5lbmRQcmVmaXhNYXBwaW5nKHByZWZpeCkgXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9ZWxzZXtcclxuXHRcdGVsLmN1cnJlbnROU01hcCA9IGN1cnJlbnROU01hcDtcclxuXHRcdGVsLmxvY2FsTlNNYXAgPSBsb2NhbE5TTWFwO1xyXG5cdFx0cGFyc2VTdGFjay5wdXNoKGVsKTtcclxuXHR9XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VIdG1sU3BlY2lhbENvbnRlbnQoc291cmNlLGVsU3RhcnRFbmQsdGFnTmFtZSxlbnRpdHlSZXBsYWNlcixkb21CdWlsZGVyKXtcclxuXHRpZigvXig/OnNjcmlwdHx0ZXh0YXJlYSkkL2kudGVzdCh0YWdOYW1lKSl7XHJcblx0XHR2YXIgZWxFbmRTdGFydCA9ICBzb3VyY2UuaW5kZXhPZignPC8nK3RhZ05hbWUrJz4nLGVsU3RhcnRFbmQpO1xyXG5cdFx0dmFyIHRleHQgPSBzb3VyY2Uuc3Vic3RyaW5nKGVsU3RhcnRFbmQrMSxlbEVuZFN0YXJ0KTtcclxuXHRcdGlmKC9bJjxdLy50ZXN0KHRleHQpKXtcclxuXHRcdFx0aWYoL15zY3JpcHQkL2kudGVzdCh0YWdOYW1lKSl7XHJcblx0XHRcdFx0Ly9pZighL1xcXVxcXT4vLnRlc3QodGV4dCkpe1xyXG5cdFx0XHRcdFx0Ly9sZXhIYW5kbGVyLnN0YXJ0Q0RBVEEoKTtcclxuXHRcdFx0XHRcdGRvbUJ1aWxkZXIuY2hhcmFjdGVycyh0ZXh0LDAsdGV4dC5sZW5ndGgpO1xyXG5cdFx0XHRcdFx0Ly9sZXhIYW5kbGVyLmVuZENEQVRBKCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gZWxFbmRTdGFydDtcclxuXHRcdFx0XHQvL31cclxuXHRcdFx0fS8vfWVsc2V7Ly90ZXh0IGFyZWFcclxuXHRcdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC8mIz9cXHcrOy9nLGVudGl0eVJlcGxhY2VyKTtcclxuXHRcdFx0XHRkb21CdWlsZGVyLmNoYXJhY3RlcnModGV4dCwwLHRleHQubGVuZ3RoKTtcclxuXHRcdFx0XHRyZXR1cm4gZWxFbmRTdGFydDtcclxuXHRcdFx0Ly99XHJcblx0XHRcdFxyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZWxTdGFydEVuZCsxO1xyXG59XHJcbmZ1bmN0aW9uIGZpeFNlbGZDbG9zZWQoc291cmNlLGVsU3RhcnRFbmQsdGFnTmFtZSxjbG9zZU1hcCl7XHJcblx0Ly9pZih0YWdOYW1lIGluIGNsb3NlTWFwKXtcclxuXHR2YXIgcG9zID0gY2xvc2VNYXBbdGFnTmFtZV07XHJcblx0aWYocG9zID09IG51bGwpe1xyXG5cdFx0Ly9jb25zb2xlLmxvZyh0YWdOYW1lKVxyXG5cdFx0cG9zID0gY2xvc2VNYXBbdGFnTmFtZV0gPSBzb3VyY2UubGFzdEluZGV4T2YoJzwvJyt0YWdOYW1lKyc+JylcclxuXHR9XHJcblx0cmV0dXJuIHBvczxlbFN0YXJ0RW5kO1xyXG5cdC8vfSBcclxufVxyXG5mdW5jdGlvbiBfY29weShzb3VyY2UsdGFyZ2V0KXtcclxuXHRmb3IodmFyIG4gaW4gc291cmNlKXt0YXJnZXRbbl0gPSBzb3VyY2Vbbl19XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VEQ0Moc291cmNlLHN0YXJ0LGRvbUJ1aWxkZXIsZXJyb3JIYW5kbGVyKXsvL3N1cmUgc3RhcnQgd2l0aCAnPCEnXHJcblx0dmFyIG5leHQ9IHNvdXJjZS5jaGFyQXQoc3RhcnQrMilcclxuXHRzd2l0Y2gobmV4dCl7XHJcblx0Y2FzZSAnLSc6XHJcblx0XHRpZihzb3VyY2UuY2hhckF0KHN0YXJ0ICsgMykgPT09ICctJyl7XHJcblx0XHRcdHZhciBlbmQgPSBzb3VyY2UuaW5kZXhPZignLS0+JyxzdGFydCs0KTtcclxuXHRcdFx0Ly9hcHBlbmQgY29tbWVudCBzb3VyY2Uuc3Vic3RyaW5nKDQsZW5kKS8vPCEtLVxyXG5cdFx0XHRpZihlbmQ+c3RhcnQpe1xyXG5cdFx0XHRcdGRvbUJ1aWxkZXIuY29tbWVudChzb3VyY2Usc3RhcnQrNCxlbmQtc3RhcnQtNCk7XHJcblx0XHRcdFx0cmV0dXJuIGVuZCszO1xyXG5cdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRlcnJvckhhbmRsZXIuZXJyb3IoXCJVbmNsb3NlZCBjb21tZW50XCIpO1xyXG5cdFx0XHRcdHJldHVybiAtMTtcclxuXHRcdFx0fVxyXG5cdFx0fWVsc2V7XHJcblx0XHRcdC8vZXJyb3JcclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0fVxyXG5cdGRlZmF1bHQ6XHJcblx0XHRpZihzb3VyY2Uuc3Vic3RyKHN0YXJ0KzMsNikgPT0gJ0NEQVRBWycpe1xyXG5cdFx0XHR2YXIgZW5kID0gc291cmNlLmluZGV4T2YoJ11dPicsc3RhcnQrOSk7XHJcblx0XHRcdGRvbUJ1aWxkZXIuc3RhcnRDREFUQSgpO1xyXG5cdFx0XHRkb21CdWlsZGVyLmNoYXJhY3RlcnMoc291cmNlLHN0YXJ0KzksZW5kLXN0YXJ0LTkpO1xyXG5cdFx0XHRkb21CdWlsZGVyLmVuZENEQVRBKCkgXHJcblx0XHRcdHJldHVybiBlbmQrMztcclxuXHRcdH1cclxuXHRcdC8vPCFET0NUWVBFXHJcblx0XHQvL3N0YXJ0RFREKGphdmEubGFuZy5TdHJpbmcgbmFtZSwgamF2YS5sYW5nLlN0cmluZyBwdWJsaWNJZCwgamF2YS5sYW5nLlN0cmluZyBzeXN0ZW1JZCkgXHJcblx0XHR2YXIgbWF0Y2hzID0gc3BsaXQoc291cmNlLHN0YXJ0KTtcclxuXHRcdHZhciBsZW4gPSBtYXRjaHMubGVuZ3RoO1xyXG5cdFx0aWYobGVuPjEgJiYgLyFkb2N0eXBlL2kudGVzdChtYXRjaHNbMF1bMF0pKXtcclxuXHRcdFx0dmFyIG5hbWUgPSBtYXRjaHNbMV1bMF07XHJcblx0XHRcdHZhciBwdWJpZCA9IGxlbj4zICYmIC9ecHVibGljJC9pLnRlc3QobWF0Y2hzWzJdWzBdKSAmJiBtYXRjaHNbM11bMF1cclxuXHRcdFx0dmFyIHN5c2lkID0gbGVuPjQgJiYgbWF0Y2hzWzRdWzBdO1xyXG5cdFx0XHR2YXIgbGFzdE1hdGNoID0gbWF0Y2hzW2xlbi0xXVxyXG5cdFx0XHRkb21CdWlsZGVyLnN0YXJ0RFREKG5hbWUscHViaWQgJiYgcHViaWQucmVwbGFjZSgvXihbJ1wiXSkoLio/KVxcMSQvLCckMicpLFxyXG5cdFx0XHRcdFx0c3lzaWQgJiYgc3lzaWQucmVwbGFjZSgvXihbJ1wiXSkoLio/KVxcMSQvLCckMicpKTtcclxuXHRcdFx0ZG9tQnVpbGRlci5lbmREVEQoKTtcclxuXHRcdFx0XHJcblx0XHRcdHJldHVybiBsYXN0TWF0Y2guaW5kZXgrbGFzdE1hdGNoWzBdLmxlbmd0aFxyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gLTE7XHJcbn1cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gcGFyc2VJbnN0cnVjdGlvbihzb3VyY2Usc3RhcnQsZG9tQnVpbGRlcil7XHJcblx0dmFyIGVuZCA9IHNvdXJjZS5pbmRleE9mKCc/Picsc3RhcnQpO1xyXG5cdGlmKGVuZCl7XHJcblx0XHR2YXIgbWF0Y2ggPSBzb3VyY2Uuc3Vic3RyaW5nKHN0YXJ0LGVuZCkubWF0Y2goL148XFw/KFxcUyopXFxzKihbXFxzXFxTXSo/KVxccyokLyk7XHJcblx0XHRpZihtYXRjaCl7XHJcblx0XHRcdHZhciBsZW4gPSBtYXRjaFswXS5sZW5ndGg7XHJcblx0XHRcdGRvbUJ1aWxkZXIucHJvY2Vzc2luZ0luc3RydWN0aW9uKG1hdGNoWzFdLCBtYXRjaFsyXSkgO1xyXG5cdFx0XHRyZXR1cm4gZW5kKzI7XHJcblx0XHR9ZWxzZXsvL2Vycm9yXHJcblx0XHRcdHJldHVybiAtMTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIC0xO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHNvdXJjZVxyXG4gKi9cclxuZnVuY3Rpb24gRWxlbWVudEF0dHJpYnV0ZXMoc291cmNlKXtcclxuXHRcclxufVxyXG5FbGVtZW50QXR0cmlidXRlcy5wcm90b3R5cGUgPSB7XHJcblx0c2V0VGFnTmFtZTpmdW5jdGlvbih0YWdOYW1lKXtcclxuXHRcdGlmKCF0YWdOYW1lUGF0dGVybi50ZXN0KHRhZ05hbWUpKXtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHRhZ05hbWU6Jyt0YWdOYW1lKVxyXG5cdFx0fVxyXG5cdFx0dGhpcy50YWdOYW1lID0gdGFnTmFtZVxyXG5cdH0sXHJcblx0YWRkOmZ1bmN0aW9uKHFOYW1lLHZhbHVlLG9mZnNldCl7XHJcblx0XHRpZighdGFnTmFtZVBhdHRlcm4udGVzdChxTmFtZSkpe1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXR0cmlidXRlOicrcU5hbWUpXHJcblx0XHR9XHJcblx0XHR0aGlzW3RoaXMubGVuZ3RoKytdID0ge3FOYW1lOnFOYW1lLHZhbHVlOnZhbHVlLG9mZnNldDpvZmZzZXR9XHJcblx0fSxcclxuXHRsZW5ndGg6MCxcclxuXHRnZXRMb2NhbE5hbWU6ZnVuY3Rpb24oaSl7cmV0dXJuIHRoaXNbaV0ubG9jYWxOYW1lfSxcclxuXHRnZXRPZmZzZXQ6ZnVuY3Rpb24oaSl7cmV0dXJuIHRoaXNbaV0ub2Zmc2V0fSxcclxuXHRnZXRRTmFtZTpmdW5jdGlvbihpKXtyZXR1cm4gdGhpc1tpXS5xTmFtZX0sXHJcblx0Z2V0VVJJOmZ1bmN0aW9uKGkpe3JldHVybiB0aGlzW2ldLnVyaX0sXHJcblx0Z2V0VmFsdWU6ZnVuY3Rpb24oaSl7cmV0dXJuIHRoaXNbaV0udmFsdWV9XHJcbi8vXHQsZ2V0SW5kZXg6ZnVuY3Rpb24odXJpLCBsb2NhbE5hbWUpKXtcclxuLy9cdFx0aWYobG9jYWxOYW1lKXtcclxuLy9cdFx0XHRcclxuLy9cdFx0fWVsc2V7XHJcbi8vXHRcdFx0dmFyIHFOYW1lID0gdXJpXHJcbi8vXHRcdH1cclxuLy9cdH0sXHJcbi8vXHRnZXRWYWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFZhbHVlKHRoaXMuZ2V0SW5kZXguYXBwbHkodGhpcyxhcmd1bWVudHMpKX0sXHJcbi8vXHRnZXRUeXBlOmZ1bmN0aW9uKHVyaSxsb2NhbE5hbWUpe31cclxuLy9cdGdldFR5cGU6ZnVuY3Rpb24oaSl7fSxcclxufVxyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gX3NldF9wcm90b18odGhpeixwYXJlbnQpe1xyXG5cdHRoaXouX19wcm90b19fID0gcGFyZW50O1xyXG5cdHJldHVybiB0aGl6O1xyXG59XHJcbmlmKCEoX3NldF9wcm90b18oe30sX3NldF9wcm90b18ucHJvdG90eXBlKSBpbnN0YW5jZW9mIF9zZXRfcHJvdG9fKSl7XHJcblx0X3NldF9wcm90b18gPSBmdW5jdGlvbih0aGl6LHBhcmVudCl7XHJcblx0XHRmdW5jdGlvbiBwKCl7fTtcclxuXHRcdHAucHJvdG90eXBlID0gcGFyZW50O1xyXG5cdFx0cCA9IG5ldyBwKCk7XHJcblx0XHRmb3IocGFyZW50IGluIHRoaXope1xyXG5cdFx0XHRwW3BhcmVudF0gPSB0aGl6W3BhcmVudF07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcDtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNwbGl0KHNvdXJjZSxzdGFydCl7XHJcblx0dmFyIG1hdGNoO1xyXG5cdHZhciBidWYgPSBbXTtcclxuXHR2YXIgcmVnID0gLydbXiddKyd8XCJbXlwiXStcInxbXlxcczw+XFwvPV0rPT98KFxcLz9cXHMqPnw8KS9nO1xyXG5cdHJlZy5sYXN0SW5kZXggPSBzdGFydDtcclxuXHRyZWcuZXhlYyhzb3VyY2UpOy8vc2tpcCA8XHJcblx0d2hpbGUobWF0Y2ggPSByZWcuZXhlYyhzb3VyY2UpKXtcclxuXHRcdGJ1Zi5wdXNoKG1hdGNoKTtcclxuXHRcdGlmKG1hdGNoWzFdKXJldHVybiBidWY7XHJcblx0fVxyXG59XHJcblxyXG5pZih0eXBlb2YgcmVxdWlyZSA9PSAnZnVuY3Rpb24nKXtcclxuXHRleHBvcnRzLlhNTFJlYWRlciA9IFhNTFJlYWRlcjtcclxufVxyXG5cclxuIiwiLypcclxuICogeHBhdGguanNcclxuICpcclxuICogQW4gWFBhdGggMS4wIGxpYnJhcnkgZm9yIEphdmFTY3JpcHQuXHJcbiAqXHJcbiAqIENhbWVyb24gTWNDb3JtYWNrIDxjYW0gKGF0KSBtY2MuaWQuYXU+XHJcbiAqXHJcbiAqIFRoaXMgd29yayBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQ3JlYXRpdmUgQ29tbW9ucyBBdHRyaWJ1dGlvbi1TaGFyZUFsaWtlXHJcbiAqIExpY2Vuc2UuIFRvIHZpZXcgYSBjb3B5IG9mIHRoaXMgbGljZW5zZSwgdmlzaXRcclxuICpcclxuICogICBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1zYS8yLjAvXHJcbiAqXHJcbiAqIG9yIHNlbmQgYSBsZXR0ZXIgdG8gQ3JlYXRpdmUgQ29tbW9ucywgNTU5IE5hdGhhbiBBYmJvdHQgV2F5LCBTdGFuZm9yZCxcclxuICogQ2FsaWZvcm5pYSA5NDMwNSwgVVNBLlxyXG4gKlxyXG4gKiBSZXZpc2lvbiAyMDogQXByaWwgMjYsIDIwMTFcclxuICogICBGaXhlZCBhIHR5cG8gcmVzdWx0aW5nIGluIEZJUlNUX09SREVSRURfTk9ERV9UWVBFIHJlc3VsdHMgYmVpbmcgd3JvbmcsXHJcbiAqICAgdGhhbmtzIHRvIDxzaGlfYTAwOSAoYXQpIGhvdG1haWwuY29tPi5cclxuICpcclxuICogUmV2aXNpb24gMTk6IE5vdmVtYmVyIDI5LCAyMDA1XHJcbiAqICAgTm9kZXNldHMgbm93IHN0b3JlIHRoZWlyIG5vZGVzIGluIGEgaGVpZ2h0IGJhbGFuY2VkIHRyZWUsIGluY3JlYXNpbmdcclxuICogICBwZXJmb3JtYW5jZSBmb3IgdGhlIGNvbW1vbiBjYXNlIG9mIHNlbGVjdGluZyBub2RlcyBpbiBkb2N1bWVudCBvcmRlcixcclxuICogICB0aGFua3MgdG8gU+mWjmFzdGllbiBDcmFtYXR0ZSA8Y29udGFjdCAoYXQpIHplbmludGVyYWN0aWYuY29tPi5cclxuICogICBBVkwgdHJlZSBjb2RlIGFkYXB0ZWQgZnJvbSBSYWltdW5kIE5ldW1hbm4gPHJub3ZhIChhdCkgZ214Lm5ldD4uXHJcbiAqXHJcbiAqIFJldmlzaW9uIDE4OiBPY3RvYmVyIDI3LCAyMDA1XHJcbiAqICAgRE9NIDMgWFBhdGggc3VwcG9ydC4gIENhdmVhdHM6XHJcbiAqICAgICAtIG5hbWVzcGFjZSBwcmVmaXhlcyBhcmVuJ3QgcmVzb2x2ZWQgaW4gWFBhdGhFdmFsdWF0b3IuY3JlYXRlRXhwcmVzc2lvbixcclxuICogICAgICAgYnV0IGluIFhQYXRoRXhwcmVzc2lvbi5ldmFsdWF0ZS5cclxuICogICAgIC0gWFBhdGhSZXN1bHQuaW52YWxpZEl0ZXJhdG9yU3RhdGUgaXMgbm90IGltcGxlbWVudGVkLlxyXG4gKlxyXG4gKiBSZXZpc2lvbiAxNzogT2N0b2JlciAyNSwgMjAwNVxyXG4gKiAgIFNvbWUgY29yZSBYUGF0aCBmdW5jdGlvbiBmaXhlcyBhbmQgYSBwYXRjaCB0byBhdm9pZCBjcmFzaGluZyBjZXJ0YWluXHJcbiAqICAgdmVyc2lvbnMgb2YgTVNYTUwgaW4gUGF0aEV4cHIucHJvdG90eXBlLmdldE93bmVyRWxlbWVudCwgdGhhbmtzIHRvXHJcbiAqICAgU+mWjmFzdGllbiBDcmFtYXR0ZSA8Y29udGFjdCAoYXQpIHplbmludGVyYWN0aWYuY29tPi5cclxuICpcclxuICogUmV2aXNpb24gMTY6IFNlcHRlbWJlciAyMiwgMjAwNVxyXG4gKiAgIFdvcmthcm91bmRzIGZvciBzb21lIElFIDUuNSBkZWZpY2llbmNpZXMuXHJcbiAqICAgRml4ZWQgcHJvYmxlbSB3aXRoIHByZWZpeCBub2RlIHRlc3RzIG9uIGF0dHJpYnV0ZSBub2Rlcy5cclxuICpcclxuICogUmV2aXNpb24gMTU6IE1heSAyMSwgMjAwNVxyXG4gKiAgIEZpeGVkIHByb2JsZW0gd2l0aCBRTmFtZSBub2RlIHRlc3RzIG9uIGVsZW1lbnRzIHdpdGggYW4geG1sbnM9XCIuLi5cIi5cclxuICpcclxuICogUmV2aXNpb24gMTQ6IE1heSAxOSwgMjAwNVxyXG4gKiAgIEZpeGVkIFFOYW1lIG5vZGUgdGVzdHMgb24gYXR0cmlidXRlIG5vZGUgcmVncmVzc2lvbi5cclxuICpcclxuICogUmV2aXNpb24gMTM6IE1heSAzLCAyMDA1XHJcbiAqICAgTm9kZSB0ZXN0cyBhcmUgY2FzZSBpbnNlbnNpdGl2ZSBub3cgaWYgd29ya2luZyBpbiBhbiBIVE1MIERPTS5cclxuICpcclxuICogUmV2aXNpb24gMTI6IEFwcmlsIDI2LCAyMDA1XHJcbiAqICAgVXBkYXRlZCBsaWNlbmNlLiAgU2xpZ2h0IGNvZGUgY2hhbmdlcyB0byBlbmFibGUgdXNlIG9mIERlYW5cclxuICogICBFZHdhcmRzJyBzY3JpcHQgY29tcHJlc3Npb24sIGh0dHA6Ly9kZWFuLmVkd2FyZHMubmFtZS9wYWNrZXIvIC5cclxuICpcclxuICogUmV2aXNpb24gMTE6IEFwcmlsIDIzLCAyMDA1XHJcbiAqICAgRml4ZWQgYnVnIHdpdGggJ2FuZCcgYW5kICdvcicgb3BlcmF0b3JzLCBmaXggdGhhbmtzIHRvXHJcbiAqICAgU2FuZHkgTWNBcnRodXIgPHNhbmR5IChhdCkgbWNhcnRodXIub3JnPi5cclxuICpcclxuICogUmV2aXNpb24gMTA6IEFwcmlsIDE1LCAyMDA1XHJcbiAqICAgQWRkZWQgc3VwcG9ydCBmb3IgYSB2aXJ0dWFsIHJvb3Qgbm9kZSwgc3VwcG9zZWRseSBoZWxwZnVsIGZvclxyXG4gKiAgIGltcGxlbWVudGluZyBYRm9ybXMuICBGaXhlZCBwcm9ibGVtIHdpdGggUU5hbWUgbm9kZSB0ZXN0cyBhbmRcclxuICogICB0aGUgcGFyZW50IGF4aXMuXHJcbiAqXHJcbiAqIFJldmlzaW9uIDk6IE1hcmNoIDE3LCAyMDA1XHJcbiAqICAgTmFtZXNwYWNlIHJlc29sdmVyIHR3ZWFrZWQgc28gdXNpbmcgdGhlIGRvY3VtZW50IG5vZGUgYXMgdGhlIGNvbnRleHRcclxuICogICBmb3IgbmFtZXNwYWNlIGxvb2t1cHMgaXMgZXF1aXZhbGVudCB0byB1c2luZyB0aGUgZG9jdW1lbnQgZWxlbWVudC5cclxuICpcclxuICogUmV2aXNpb24gODogRmVicnVhcnkgMTMsIDIwMDVcclxuICogICBIYW5kbGUgaW1wbGljaXQgZGVjbGFyYXRpb24gb2YgJ3htbG5zJyBuYW1lc3BhY2UgcHJlZml4LlxyXG4gKiAgIEZpeGVkIGJ1ZyB3aGVuIGNvbXBhcmluZyBub2Rlc2V0cy5cclxuICogICBJbnN0YW5jZSBkYXRhIGNhbiBub3cgYmUgYXNzb2NpYXRlZCB3aXRoIGEgRnVuY3Rpb25SZXNvbHZlciwgYW5kXHJcbiAqICAgICB3b3JrYXJvdW5kIGZvciBNU1hNTCBub3Qgc3VwcG9ydGluZyAnbG9jYWxOYW1lJyBhbmQgJ2dldEVsZW1lbnRCeUlkJyxcclxuICogICAgIHRoYW5rcyB0byBHcmFudCBHb25nYXdhcmUuXHJcbiAqICAgRml4IGEgZmV3IHByb2JsZW1zIHdoZW4gdGhlIGNvbnRleHQgbm9kZSBpcyB0aGUgcm9vdCBub2RlLlxyXG4gKlxyXG4gKiBSZXZpc2lvbiA3OiBGZWJydWFyeSAxMSwgMjAwNVxyXG4gKiAgIERlZmF1bHQgbmFtZXNwYWNlIHJlc29sdmVyIGZpeCBmcm9tIEdyYW50IEdvbmdhd2FyZVxyXG4gKiAgIDxncmFudCAoYXQpIGdvbmdhd2FyZS5jb20+LlxyXG4gKlxyXG4gKiBSZXZpc2lvbiA2OiBGZWJydWFyeSAxMCwgMjAwNVxyXG4gKiAgIEZpeGVkIGJ1ZyBpbiAnbnVtYmVyJyBmdW5jdGlvbi5cclxuICpcclxuICogUmV2aXNpb24gNTogRmVicnVhcnkgOSwgMjAwNVxyXG4gKiAgIEZpeGVkIGJ1ZyB3aGVyZSB0ZXh0IG5vZGVzIG5vdCBnZXR0aW5nIGNvbnZlcnRlZCB0byBzdHJpbmcgdmFsdWVzLlxyXG4gKlxyXG4gKiBSZXZpc2lvbiA0OiBKYW51YXJ5IDIxLCAyMDA1XHJcbiAqICAgQnVnIGluICduYW1lJyBmdW5jdGlvbiwgZml4IHRoYW5rcyB0byBCaWxsIEVkbmV5LlxyXG4gKiAgIEZpeGVkIGluY29ycmVjdCBwcm9jZXNzaW5nIG9mIG5hbWVzcGFjZSBub2Rlcy5cclxuICogICBGaXhlZCBOYW1lc3BhY2VSZXNvbHZlciB0byByZXNvbHZlICd4bWwnIG5hbWVzcGFjZS5cclxuICogICBJbXBsZW1lbnRlZCB1bmlvbiAnfCcgb3BlcmF0b3IuXHJcbiAqXHJcbiAqIFJldmlzaW9uIDM6IEphbnVhcnkgMTQsIDIwMDVcclxuICogICBGaXhlZCBidWcgd2l0aCBub2Rlc2V0IGNvbXBhcmlzb25zLCBidWcgbGV4aW5nIDwgYW5kID4uXHJcbiAqXHJcbiAqIFJldmlzaW9uIDI6IE9jdG9iZXIgMjYsIDIwMDRcclxuICogICBRTmFtZSBub2RlIHRlc3QgbmFtZXNwYWNlIGhhbmRsaW5nIGZpeGVkLiAgRmV3IG90aGVyIGJ1ZyBmaXhlcy5cclxuICpcclxuICogUmV2aXNpb24gMTogQXVndXN0IDEzLCAyMDA0XHJcbiAqICAgQnVnIGZpeGVzIGZyb20gV2lsbGlhbSBKLiBFZG5leSA8YmVkbmV5IChhdCkgdGVjaG5pY2FscHVyc3VpdC5jb20+LlxyXG4gKiAgIEFkZGVkIG1pbmltYWwgbGljZW5jZS5cclxuICpcclxuICogSW5pdGlhbCB2ZXJzaW9uOiBKdW5lIDE0LCAyMDA0XHJcbiAqL1xyXG5cclxuLy8gbm9uLW5vZGUgd3JhcHBlclxyXG5pZih0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgKSB7XHJcblx0eHBhdGggPSB7fTtcclxufVxyXG4oZnVuY3Rpb24oZXhwb3J0cykge1xyXG5cdFxyXG4vLyBYUGF0aFBhcnNlciAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblhQYXRoUGFyc2VyLnByb3RvdHlwZSA9IG5ldyBPYmplY3QoKTtcclxuWFBhdGhQYXJzZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWFBhdGhQYXJzZXI7XHJcblhQYXRoUGFyc2VyLnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gWFBhdGhQYXJzZXIoKSB7XHJcblx0dGhpcy5pbml0KCk7XHJcbn1cclxuXHJcblhQYXRoUGFyc2VyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zID0gW107XHJcblxyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1szXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBPck9wZXJhdGlvbihyaHNbMF0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNV0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgQW5kT3BlcmF0aW9uKHJoc1swXSwgcmhzWzJdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s3XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBFcXVhbHNPcGVyYXRpb24ocmhzWzBdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzhdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IE5vdEVxdWFsT3BlcmF0aW9uKHJoc1swXSwgcmhzWzJdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1sxMF0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgTGVzc1RoYW5PcGVyYXRpb24ocmhzWzBdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzExXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBHcmVhdGVyVGhhbk9wZXJhdGlvbihyaHNbMF0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMTJdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IExlc3NUaGFuT3JFcXVhbE9wZXJhdGlvbihyaHNbMF0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMTNdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IEdyZWF0ZXJUaGFuT3JFcXVhbE9wZXJhdGlvbihyaHNbMF0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMTVdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBsdXNPcGVyYXRpb24ocmhzWzBdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzE2XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBNaW51c09wZXJhdGlvbihyaHNbMF0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMThdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IE11bHRpcGx5T3BlcmF0aW9uKHJoc1swXSwgcmhzWzJdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1sxOV0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgRGl2T3BlcmF0aW9uKHJoc1swXSwgcmhzWzJdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1syMF0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgTW9kT3BlcmF0aW9uKHJoc1swXSwgcmhzWzJdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1syMl0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgVW5hcnlNaW51c09wZXJhdGlvbihyaHNbMV0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzI0XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBCYXJPcGVyYXRpb24ocmhzWzBdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzI1XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBQYXRoRXhwcih1bmRlZmluZWQsIHVuZGVmaW5lZCwgcmhzWzBdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1syN10gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJoc1swXS5sb2NhdGlvblBhdGggPSByaHNbMl07XHJcblx0XHRyZXR1cm4gcmhzWzBdO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzI4XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmhzWzBdLmxvY2F0aW9uUGF0aCA9IHJoc1syXTtcclxuXHRcdHJoc1swXS5sb2NhdGlvblBhdGguc3RlcHMudW5zaGlmdChuZXcgU3RlcChTdGVwLkRFU0NFTkRBTlRPUlNFTEYsIG5ldyBOb2RlVGVzdChOb2RlVGVzdC5OT0RFLCB1bmRlZmluZWQpLCBbXSkpO1xyXG5cdFx0cmV0dXJuIHJoc1swXTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1syOV0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgUGF0aEV4cHIocmhzWzBdLCBbXSwgdW5kZWZpbmVkKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1szMF0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YocmhzWzBdLCBQYXRoRXhwcikpIHtcclxuXHRcdFx0aWYgKHJoc1swXS5maWx0ZXJQcmVkaWNhdGVzID09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdHJoc1swXS5maWx0ZXJQcmVkaWNhdGVzID0gW107XHJcblx0XHRcdH1cclxuXHRcdFx0cmhzWzBdLmZpbHRlclByZWRpY2F0ZXMucHVzaChyaHNbMV0pO1xyXG5cdFx0XHRyZXR1cm4gcmhzWzBdO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBQYXRoRXhwcihyaHNbMF0sIFtyaHNbMV1dLCB1bmRlZmluZWQpO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzMyXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIHJoc1sxXTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1szM10gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgWFN0cmluZyhyaHNbMF0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzM0XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBYTnVtYmVyKHJoc1swXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMzZdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IEZ1bmN0aW9uQ2FsbChyaHNbMF0sIFtdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1szN10gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgRnVuY3Rpb25DYWxsKHJoc1swXSwgcmhzWzJdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1szOF0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBbIHJoc1swXSBdO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzM5XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmhzWzJdLnVuc2hpZnQocmhzWzBdKTtcclxuXHRcdHJldHVybiByaHNbMl07XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNDNdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IExvY2F0aW9uUGF0aCh0cnVlLCBbXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNDRdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyaHNbMV0uYWJzb2x1dGUgPSB0cnVlO1xyXG5cdFx0cmV0dXJuIHJoc1sxXTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s0Nl0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgTG9jYXRpb25QYXRoKGZhbHNlLCBbIHJoc1swXSBdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s0N10gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJoc1swXS5zdGVwcy5wdXNoKHJoc1syXSk7XHJcblx0XHRyZXR1cm4gcmhzWzBdO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzQ5XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBTdGVwKHJoc1swXSwgcmhzWzFdLCBbXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNTBdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IFN0ZXAoU3RlcC5DSElMRCwgcmhzWzBdLCBbXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNTFdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IFN0ZXAocmhzWzBdLCByaHNbMV0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNTJdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IFN0ZXAoU3RlcC5DSElMRCwgcmhzWzBdLCByaHNbMV0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzU0XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIFsgcmhzWzBdIF07XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNTVdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyaHNbMV0udW5zaGlmdChyaHNbMF0pO1xyXG5cdFx0cmV0dXJuIHJoc1sxXTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s1Nl0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdGlmIChyaHNbMF0gPT0gXCJhbmNlc3RvclwiKSB7XHJcblx0XHRcdHJldHVybiBTdGVwLkFOQ0VTVE9SO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJhbmNlc3Rvci1vci1zZWxmXCIpIHtcclxuXHRcdFx0cmV0dXJuIFN0ZXAuQU5DRVNUT1JPUlNFTEY7XHJcblx0XHR9IGVsc2UgaWYgKHJoc1swXSA9PSBcImF0dHJpYnV0ZVwiKSB7XHJcblx0XHRcdHJldHVybiBTdGVwLkFUVFJJQlVURTtcclxuXHRcdH0gZWxzZSBpZiAocmhzWzBdID09IFwiY2hpbGRcIikge1xyXG5cdFx0XHRyZXR1cm4gU3RlcC5DSElMRDtcclxuXHRcdH0gZWxzZSBpZiAocmhzWzBdID09IFwiZGVzY2VuZGFudFwiKSB7XHJcblx0XHRcdHJldHVybiBTdGVwLkRFU0NFTkRBTlQ7XHJcblx0XHR9IGVsc2UgaWYgKHJoc1swXSA9PSBcImRlc2NlbmRhbnQtb3Itc2VsZlwiKSB7XHJcblx0XHRcdHJldHVybiBTdGVwLkRFU0NFTkRBTlRPUlNFTEY7XHJcblx0XHR9IGVsc2UgaWYgKHJoc1swXSA9PSBcImZvbGxvd2luZ1wiKSB7XHJcblx0XHRcdHJldHVybiBTdGVwLkZPTExPV0lORztcclxuXHRcdH0gZWxzZSBpZiAocmhzWzBdID09IFwiZm9sbG93aW5nLXNpYmxpbmdcIikge1xyXG5cdFx0XHRyZXR1cm4gU3RlcC5GT0xMT1dJTkdTSUJMSU5HO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJuYW1lc3BhY2VcIikge1xyXG5cdFx0XHRyZXR1cm4gU3RlcC5OQU1FU1BBQ0U7XHJcblx0XHR9IGVsc2UgaWYgKHJoc1swXSA9PSBcInBhcmVudFwiKSB7XHJcblx0XHRcdHJldHVybiBTdGVwLlBBUkVOVDtcclxuXHRcdH0gZWxzZSBpZiAocmhzWzBdID09IFwicHJlY2VkaW5nXCIpIHtcclxuXHRcdFx0cmV0dXJuIFN0ZXAuUFJFQ0VESU5HO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJwcmVjZWRpbmctc2libGluZ1wiKSB7XHJcblx0XHRcdHJldHVybiBTdGVwLlBSRUNFRElOR1NJQkxJTkc7XHJcblx0XHR9IGVsc2UgaWYgKHJoc1swXSA9PSBcInNlbGZcIikge1xyXG5cdFx0XHRyZXR1cm4gU3RlcC5TRUxGO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIC0xO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzU3XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIFN0ZXAuQVRUUklCVVRFO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzU5XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0aWYgKHJoc1swXSA9PSBcImNvbW1lbnRcIikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IE5vZGVUZXN0KE5vZGVUZXN0LkNPTU1FTlQsIHVuZGVmaW5lZCk7XHJcblx0XHR9IGVsc2UgaWYgKHJoc1swXSA9PSBcInRleHRcIikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IE5vZGVUZXN0KE5vZGVUZXN0LlRFWFQsIHVuZGVmaW5lZCk7XHJcblx0XHR9IGVsc2UgaWYgKHJoc1swXSA9PSBcInByb2Nlc3NpbmctaW5zdHJ1Y3Rpb25cIikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IE5vZGVUZXN0KE5vZGVUZXN0LlBJLCB1bmRlZmluZWQpO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJub2RlXCIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBOb2RlVGVzdChOb2RlVGVzdC5OT0RFLCB1bmRlZmluZWQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBOb2RlVGVzdCgtMSwgdW5kZWZpbmVkKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s2MF0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgTm9kZVRlc3QoTm9kZVRlc3QuUEksIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNjFdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gcmhzWzFdO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzYzXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmhzWzFdLmFic29sdXRlID0gdHJ1ZTtcclxuXHRcdHJoc1sxXS5zdGVwcy51bnNoaWZ0KG5ldyBTdGVwKFN0ZXAuREVTQ0VOREFOVE9SU0VMRiwgbmV3IE5vZGVUZXN0KE5vZGVUZXN0Lk5PREUsIHVuZGVmaW5lZCksIFtdKSk7XHJcblx0XHRyZXR1cm4gcmhzWzFdO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzY0XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmhzWzBdLnN0ZXBzLnB1c2gobmV3IFN0ZXAoU3RlcC5ERVNDRU5EQU5UT1JTRUxGLCBuZXcgTm9kZVRlc3QoTm9kZVRlc3QuTk9ERSwgdW5kZWZpbmVkKSwgW10pKTtcclxuXHRcdHJoc1swXS5zdGVwcy5wdXNoKHJoc1syXSk7XHJcblx0XHRyZXR1cm4gcmhzWzBdO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzY1XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBTdGVwKFN0ZXAuU0VMRiwgbmV3IE5vZGVUZXN0KE5vZGVUZXN0Lk5PREUsIHVuZGVmaW5lZCksIFtdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s2Nl0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgU3RlcChTdGVwLlBBUkVOVCwgbmV3IE5vZGVUZXN0KE5vZGVUZXN0Lk5PREUsIHVuZGVmaW5lZCksIFtdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s2N10gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgVmFyaWFibGVSZWZlcmVuY2UocmhzWzFdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s2OF0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgTm9kZVRlc3QoTm9kZVRlc3QuTkFNRVRFU1RBTlksIHVuZGVmaW5lZCk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNjldID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHR2YXIgcHJlZml4ID0gcmhzWzBdLnN1YnN0cmluZygwLCByaHNbMF0uaW5kZXhPZihcIjpcIikpO1xyXG5cdFx0cmV0dXJuIG5ldyBOb2RlVGVzdChOb2RlVGVzdC5OQU1FVEVTVFBSRUZJWEFOWSwgcHJlZml4KTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s3MF0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgTm9kZVRlc3QoTm9kZVRlc3QuTkFNRVRFU1RRTkFNRSwgcmhzWzBdKTtcclxuXHR9O1xyXG59O1xyXG5cclxuWFBhdGhQYXJzZXIuYWN0aW9uVGFibGUgPSBbXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgcyAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciAgciAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgcnJycnIgICAgICAgICAgICAgICBcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwicnMgIHJycnJycnJyIHMgIHNzc3NzcnJycnJyICBycnMgcnMgXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgICAgICAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciByciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiICBzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyAgICAgICBcIixcclxuXHRcIiBzICAgICAgICAgICBzICBzc3NzcyAgICAgICAgICBzICBzIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciAgciAgXCIsXHJcblx0XCJhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcInIgICAgICAgcyAgICAgICAgICAgICAgICAgICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgICAgIHNyICAgICAgICAgICAgICAgICAgICByciAgciAgXCIsXHJcblx0XCJyICAgcyAgcnIgICAgICAgICAgICBzICAgICAgIHJyICByICBcIixcclxuXHRcInIgICByc3NyciAgICAgICAgICAgIHJzcyAgICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJyICAgICAgICAgICAgcnJyc3MgICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnJzc3MgICAgICAgICBycnJyciAgIHJyICByICBcIixcclxuXHRcInIgICBycnJycnJyciAgICAgICAgIHJycnJyICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJycnJyICAgICAgICAgcnJycnJzICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnJycnIgICAgICAgICBycnJycnIgIHJyICByICBcIixcclxuXHRcInIgICBycnJycnJyciAgICAgICAgIHJycnJyciAgcnIgIHIgIFwiLFxyXG5cdFwiciAgc3JycnJycnJyICAgICAgICAgcnJycnJycyByciBzciAgXCIsXHJcblx0XCJyICBzcnJycnJycnIgICAgICAgICBycnJycnJzIHJyICByICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciByciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcInIgICBycnJycnJyciAgICAgICAgIHJycnJyciAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJycnJyICAgICAgICAgcnJycnJyICByciAgciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyICByICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgIHIgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgIHNzc3NzICAgICAgICAgICAgICAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHNyICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgIHIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciByciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyAgICAgIFwiLFxyXG5cdFwiciAgc3JycnJycnJyICAgICAgICAgcnJycnJycyByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnJycnIgICAgICAgICBycnJyciAgIHJyICByICBcIixcclxuXHRcIiAgICAgICAgICAgICAgcyAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgcnJycnIgICAgICAgICAgICAgICBcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzcyBzICBzc1wiLFxyXG5cdFwiciAgc3JycnJycnJyICAgICAgICAgcnJycnJycyByciAgciAgXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICAgIHNzICBzICBzc1wiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgcyAgICAgICAgICAgcyAgc3Nzc3MgICAgICAgICAgcyAgcyBcIixcclxuXHRcIiBzICAgICAgICAgICBzICBzc3NzcyAgICAgICAgICBzICBzIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciByciAgXCIsXHJcblx0XCIgcyAgICAgICAgICAgcyAgc3Nzc3MgICAgICAgICAgcyAgcyBcIixcclxuXHRcIiBzICAgICAgICAgICBzICBzc3NzcyAgICAgICAgICBzICBzIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciBzciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHNyICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgIHIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciByciAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgICAgICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciByciAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJyICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBycyAgICAgXCIsXHJcblx0XCJyICAgICAgc3IgICAgICAgICAgICAgICAgICAgIHJyICByICBcIixcclxuXHRcInIgICBzICByciAgICAgICAgICAgIHMgICAgICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJzc3JyICAgICAgICAgICAgcnNzICAgICByciAgciAgXCIsXHJcblx0XCJyICAgcnNzcnIgICAgICAgICAgICByc3MgICAgIHJyICByICBcIixcclxuXHRcInIgICBycnJyciAgICAgICAgICAgIHJycnNzICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJyICAgICAgICAgICAgcnJyc3MgICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnIgICAgICAgICAgICBycnJzcyAgIHJyICByICBcIixcclxuXHRcInIgICBycnJyciAgICAgICAgICAgIHJycnNzICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJyc3NzICAgICAgICAgcnJycnIgICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnJzc3MgICAgICAgICBycnJyciAgIHJyICByICBcIixcclxuXHRcInIgICBycnJycnJyciAgICAgICAgIHJycnJyICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJycnJyICAgICAgICAgcnJycnIgICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnJycnIgICAgICAgICBycnJyciAgIHJyICByICBcIixcclxuXHRcInIgICBycnJycnJyciAgICAgICAgIHJycnJyciAgcnIgIHIgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICBcIixcclxuXHRcInIgIHNycnJycnJyciAgICAgICAgIHJycnJycnMgcnIgIHIgIFwiLFxyXG5cdFwiciAgc3JycnJycnJyICAgICAgICAgcnJycnJycyByciAgciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyICByICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgIHIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciAgciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyICByICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciByciAgXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICByICAgICAgXCJcclxuXTtcclxuXHJcblhQYXRoUGFyc2VyLmFjdGlvblRhYmxlTnVtYmVyID0gW1xyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgIEogICAgICAgICAgICAgICAgICBcIixcclxuXHRcImEgIGFhYWFhYWFhYSAgICAgICAgIGFhYWFhYWEgYWEgIGEgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgIFlZWVlZICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIksxICBLS0tLS0tLSyAuICArKikoJ0tLS0tLSyAgS0sjIEtcXFwiIFwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgTiAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPICAgICAgIFwiLFxyXG5cdFwiZSAgZWVlZWVlZWVlICAgICAgICAgZWVlZWVlZSBlZSBlZSAgXCIsXHJcblx0XCJmICBmZmZmZmZmZmYgICAgICAgICBmZmZmZmZmIGZmIGZmICBcIixcclxuXHRcImQgIGRkZGRkZGRkZCAgICAgICAgIGRkZGRkZGQgZGQgZGQgIFwiLFxyXG5cdFwiQiAgQkJCQkJCQkJCICAgICAgICAgQkJCQkJCQiBCQiBCQiAgXCIsXHJcblx0XCJBICBBQUFBQUFBQUEgICAgICAgICBBQUFBQUFBIEFBIEFBICBcIixcclxuXHRcIiAgUCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgIFEgICAgICAgXCIsXHJcblx0XCIgMSAgICAgICAgICAgLiAgKyopKCcgICAgICAgICAgIyAgXFxcIiBcIixcclxuXHRcImIgIGJiYmJiYmJiYiAgICAgICAgIGJiYmJiYmIgYmIgIGIgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIhICAgICAgIFMgICAgICAgICAgICAgICAgICAgICEhICAhICBcIixcclxuXHRcIlxcXCIgICAgICBUXFxcIiAgICAgICAgICAgICAgICAgICAgXFxcIlxcXCIgIFxcXCIgIFwiLFxyXG5cdFwiJCAgIFYgICQkICAgICAgICAgICAgVSAgICAgICAkJCAgJCAgXCIsXHJcblx0XCImICAgJlpZJiYgICAgICAgICAgICAmWFcgICAgICYmICAmICBcIixcclxuXHRcIikgICApKSkpKSAgICAgICAgICAgICkpKVxcXFxbICAgKSkgICkgIFwiLFxyXG5cdFwiLiAgIC4uLi4uX15dICAgICAgICAgLi4uLi4gICAuLiAgLiAgXCIsXHJcblx0XCIxICAgMTExMTExMTEgICAgICAgICAxMTExMSAgIDExICAxICBcIixcclxuXHRcIjUgICA1NTU1NTU1NSAgICAgICAgIDU1NTU1YCAgNTUgIDUgIFwiLFxyXG5cdFwiNyAgIDc3Nzc3Nzc3ICAgICAgICAgNzc3Nzc3ICA3NyAgNyAgXCIsXHJcblx0XCI5ICAgOTk5OTk5OTkgICAgICAgICA5OTk5OTkgIDk5ICA5ICBcIixcclxuXHRcIjogIGM6Ojo6Ojo6OiAgICAgICAgIDo6Ojo6OmIgOjogYTogIFwiLFxyXG5cdFwiSSAgZklJSUlJSUlJICAgICAgICAgSUlJSUlJZSBJSSAgSSAgXCIsXHJcblx0XCI9ICA9PT09PT09PT0gICAgICAgICA9PT09PT09ID09ID09ICBcIixcclxuXHRcIj8gID8/Pz8/Pz8/PyAgICAgICAgID8/Pz8/Pz8gPz8gPz8gIFwiLFxyXG5cdFwiQyAgQ0NDQ0NDQ0NDICAgICAgICAgQ0NDQ0NDQyBDQyBDQyAgXCIsXHJcblx0XCJKICAgSkpKSkpKSkogICAgICAgICBKSkpKSkogIEpKICBKICBcIixcclxuXHRcIk0gICBNTU1NTU1NTSAgICAgICAgIE1NTU1NTSAgTU0gIE0gIFwiLFxyXG5cdFwiTiAgTk5OTk5OTk5OICAgICAgICAgTk5OTk5OTiBOTiAgTiAgXCIsXHJcblx0XCJQICBQUFBQUFBQUFAgICAgICAgICBQUFBQUFBQIFBQICBQICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICArKikoJyAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiUiAgUlJSUlJSUlJSICAgICAgICAgUlJSUlJSUiBSUiBhUiAgXCIsXHJcblx0XCJVICBVVVVVVVVVVVUgICAgICAgICBVVVVVVVVVIFVVICBVICBcIixcclxuXHRcIlogIFpaWlpaWlpaWiAgICAgICAgIFpaWlpaWlogWlogWlogIFwiLFxyXG5cdFwiYyAgY2NjY2NjY2NjICAgICAgICAgY2NjY2NjYyBjYyBjYyAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogICAgICBcIixcclxuXHRcIkwgIGZMTExMTExMTCAgICAgICAgIExMTExMTGUgTEwgIEwgIFwiLFxyXG5cdFwiNiAgIDY2NjY2NjY2ICAgICAgICAgNjY2NjYgICA2NiAgNiAgXCIsXHJcblx0XCIgICAgICAgICAgICAgIGsgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbCAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgIFhYWFhYICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJG0gIyAgXFxcIiFcIixcclxuXHRcIl8gIGZfX19fX19fXyAgICAgICAgIF9fX19fX2UgX18gIF8gIFwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgICAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiIDEgICAgICAgICAgIC4gICsqKSgnICAgICAgICAgICMgIFxcXCIgXCIsXHJcblx0XCIgMSAgICAgICAgICAgLiAgKyopKCcgICAgICAgICAgIyAgXFxcIiBcIixcclxuXHRcIj4gID4+Pj4+Pj4+PiAgICAgICAgID4+Pj4+Pj4gPj4gPj4gIFwiLFxyXG5cdFwiIDEgICAgICAgICAgIC4gICsqKSgnICAgICAgICAgICMgIFxcXCIgXCIsXHJcblx0XCIgMSAgICAgICAgICAgLiAgKyopKCcgICAgICAgICAgIyAgXFxcIiBcIixcclxuXHRcIlEgIFFRUVFRUVFRUSAgICAgICAgIFFRUVFRUVEgUVEgYVEgIFwiLFxyXG5cdFwiViAgVlZWVlZWVlZWICAgICAgICAgVlZWVlZWViBWViBhViAgXCIsXHJcblx0XCJUICBUVFRUVFRUVFQgICAgICAgICBUVFRUVFRUIFRUICBUICBcIixcclxuXHRcIkAgIEBAQEBAQEBAQCAgICAgICAgIEBAQEBAQEAgQEAgQEAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXHg4NyAgICAgIFwiLFxyXG5cdFwiWyAgW1tbW1tbW1tbICAgICAgICAgW1tbW1tbWyBbWyBbWyAgXCIsXHJcblx0XCJEICBEREREREREREQgICAgICAgICBEREREREREIEREIEREICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSEggICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXHg4OCAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGXFx4ODkgICAgIFwiLFxyXG5cdFwiIyAgICAgIFQjICAgICAgICAgICAgICAgICAgICAjIyAgIyAgXCIsXHJcblx0XCIlICAgViAgJSUgICAgICAgICAgICBVICAgICAgICUlICAlICBcIixcclxuXHRcIicgICAnWlknJyAgICAgICAgICAgICdYVyAgICAgJycgICcgIFwiLFxyXG5cdFwiKCAgIChaWSgoICAgICAgICAgICAgKFhXICAgICAoKCAgKCAgXCIsXHJcblx0XCIrICAgKysrKysgICAgICAgICAgICArKytcXFxcWyAgICsrICArICBcIixcclxuXHRcIiogICAqKioqKiAgICAgICAgICAgICoqKlxcXFxbICAgKiogICogIFwiLFxyXG5cdFwiLSAgIC0tLS0tICAgICAgICAgICAgLS0tXFxcXFsgICAtLSAgLSAgXCIsXHJcblx0XCIsICAgLCwsLCwgICAgICAgICAgICAsLCxcXFxcWyAgICwsICAsICBcIixcclxuXHRcIjAgICAwMDAwMF9eXSAgICAgICAgIDAwMDAwICAgMDAgIDAgIFwiLFxyXG5cdFwiLyAgIC8vLy8vX15dICAgICAgICAgLy8vLy8gICAvLyAgLyAgXCIsXHJcblx0XCIyICAgMjIyMjIyMjIgICAgICAgICAyMjIyMiAgIDIyICAyICBcIixcclxuXHRcIjMgICAzMzMzMzMzMyAgICAgICAgIDMzMzMzICAgMzMgIDMgIFwiLFxyXG5cdFwiNCAgIDQ0NDQ0NDQ0ICAgICAgICAgNDQ0NDQgICA0NCAgNCAgXCIsXHJcblx0XCI4ICAgODg4ODg4ODggICAgICAgICA4ODg4ODggIDg4ICA4ICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF4gIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFx4OGEgIFwiLFxyXG5cdFwiOyAgZjs7Ozs7Ozs7ICAgICAgICAgOzs7Ozs7ZSA7OyAgOyAgXCIsXHJcblx0XCI8ICBmPDw8PDw8PDwgICAgICAgICA8PDw8PDxlIDw8ICA8ICBcIixcclxuXHRcIk8gIE9PT09PT09PTyAgICAgICAgIE9PT09PT08gT08gIE8gIFwiLFxyXG5cdFwiYCAgYGBgYGBgYGBgICAgICAgICAgYGBgYGBgYCBgYCAgYCAgXCIsXHJcblx0XCJTICBTU1NTU1NTU1MgICAgICAgICBTU1NTU1NTIFNTICBTICBcIixcclxuXHRcIlcgIFdXV1dXV1dXVyAgICAgICAgIFdXV1dXV1cgV1cgIFcgIFwiLFxyXG5cdFwiXFxcXCAgXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcICAgICAgICAgXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCBcXFxcXFxcXCBcXFxcXFxcXCAgXCIsXHJcblx0XCJFICBFRUVFRUVFRUUgICAgICAgICBFRUVFRUVFIEVFIEVFICBcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiXSAgXV1dXV1dXV1dICAgICAgICAgXV1dXV1dXSBdXSBdXSAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEcgICAgICBcIlxyXG5dO1xyXG5cclxuWFBhdGhQYXJzZXIuZ290b1RhYmxlID0gW1xyXG5cdFwiMzQ1Njc4OTo7PD0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIkw0NTY3ODk6Ozw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICAgICAgICAgICBNICAgICAgICBFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgIE47PD0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgIFMgICAgICAgIEVGR0ggSUogXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgIGUgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICBoICBKIFwiLFxyXG5cdFwiICAgICAgICAgICAgICBpICAgICAgICAgIGogICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIm80NTY3ODk6Ozw9Pj9AIEFCcHFDREVGR0ggSUogXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICByNjc4OTo7PD0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIiAgIHM3ODk6Ozw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICAgdDg5Ojs8PT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgIHU4OTo7PD0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIiAgICAgdjk6Ozw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICAgIHc5Ojs8PT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgICB4OTo7PD0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIiAgICAgeTk6Ozw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICAgICB6Ojs8PT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgezo7PD0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIiAgICAgICB8Ozw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICAgICAgfTs8PT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgIH47PD0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIiAgICAgICAgIFxceDdmPT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiXFx4ODA0NTY3ODk6Ozw9Pj9AIEFCICBDREVGR0ggSUpcXHg4MVwiLFxyXG5cdFwiICAgICAgICAgICAgXFx4ODIgICAgICAgIEVGR0ggSUogXCIsXHJcblx0XCIgICAgICAgICAgICBcXHg4MyAgICAgICAgRUZHSCBJSiBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICBcXHg4NCBHSCBJSiBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgIFxceDg1IEdIIElKIFwiLFxyXG5cdFwiICAgICAgICAgICAgICBpICAgICAgICAgIFxceDg2ICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgIGkgICAgICAgICAgXFx4ODcgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwibzQ1Njc4OTo7PD0+P0AgQUJcXHg4Y3FDREVGR0ggSUogXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxyXG5dO1xyXG5cclxuWFBhdGhQYXJzZXIucHJvZHVjdGlvbnMgPSBbXHJcblx0WzEsIDEsIDJdLFxyXG5cdFsyLCAxLCAzXSxcclxuXHRbMywgMSwgNF0sXHJcblx0WzMsIDMsIDMsIC05LCA0XSxcclxuXHRbNCwgMSwgNV0sXHJcblx0WzQsIDMsIDQsIC04LCA1XSxcclxuXHRbNSwgMSwgNl0sXHJcblx0WzUsIDMsIDUsIC0yMiwgNl0sXHJcblx0WzUsIDMsIDUsIC01LCA2XSxcclxuXHRbNiwgMSwgN10sXHJcblx0WzYsIDMsIDYsIC0yMywgN10sXHJcblx0WzYsIDMsIDYsIC0yNCwgN10sXHJcblx0WzYsIDMsIDYsIC02LCA3XSxcclxuXHRbNiwgMywgNiwgLTcsIDddLFxyXG5cdFs3LCAxLCA4XSxcclxuXHRbNywgMywgNywgLTI1LCA4XSxcclxuXHRbNywgMywgNywgLTI2LCA4XSxcclxuXHRbOCwgMSwgOV0sXHJcblx0WzgsIDMsIDgsIC0xMiwgOV0sXHJcblx0WzgsIDMsIDgsIC0xMSwgOV0sXHJcblx0WzgsIDMsIDgsIC0xMCwgOV0sXHJcblx0WzksIDEsIDEwXSxcclxuXHRbOSwgMiwgLTI2LCA5XSxcclxuXHRbMTAsIDEsIDExXSxcclxuXHRbMTAsIDMsIDEwLCAtMjcsIDExXSxcclxuXHRbMTEsIDEsIDEyXSxcclxuXHRbMTEsIDEsIDEzXSxcclxuXHRbMTEsIDMsIDEzLCAtMjgsIDE0XSxcclxuXHRbMTEsIDMsIDEzLCAtNCwgMTRdLFxyXG5cdFsxMywgMSwgMTVdLFxyXG5cdFsxMywgMiwgMTMsIDE2XSxcclxuXHRbMTUsIDEsIDE3XSxcclxuXHRbMTUsIDMsIC0yOSwgMiwgLTMwXSxcclxuXHRbMTUsIDEsIC0xNV0sXHJcblx0WzE1LCAxLCAtMTZdLFxyXG5cdFsxNSwgMSwgMThdLFxyXG5cdFsxOCwgMywgLTEzLCAtMjksIC0zMF0sXHJcblx0WzE4LCA0LCAtMTMsIC0yOSwgMTksIC0zMF0sXHJcblx0WzE5LCAxLCAyMF0sXHJcblx0WzE5LCAzLCAyMCwgLTMxLCAxOV0sXHJcblx0WzIwLCAxLCAyXSxcclxuXHRbMTIsIDEsIDE0XSxcclxuXHRbMTIsIDEsIDIxXSxcclxuXHRbMjEsIDEsIC0yOF0sXHJcblx0WzIxLCAyLCAtMjgsIDE0XSxcclxuXHRbMjEsIDEsIDIyXSxcclxuXHRbMTQsIDEsIDIzXSxcclxuXHRbMTQsIDMsIDE0LCAtMjgsIDIzXSxcclxuXHRbMTQsIDEsIDI0XSxcclxuXHRbMjMsIDIsIDI1LCAyNl0sXHJcblx0WzIzLCAxLCAyNl0sXHJcblx0WzIzLCAzLCAyNSwgMjYsIDI3XSxcclxuXHRbMjMsIDIsIDI2LCAyN10sXHJcblx0WzIzLCAxLCAyOF0sXHJcblx0WzI3LCAxLCAxNl0sXHJcblx0WzI3LCAyLCAxNiwgMjddLFxyXG5cdFsyNSwgMiwgLTE0LCAtM10sXHJcblx0WzI1LCAxLCAtMzJdLFxyXG5cdFsyNiwgMSwgMjldLFxyXG5cdFsyNiwgMywgLTIwLCAtMjksIC0zMF0sXHJcblx0WzI2LCA0LCAtMjEsIC0yOSwgLTE1LCAtMzBdLFxyXG5cdFsxNiwgMywgLTMzLCAzMCwgLTM0XSxcclxuXHRbMzAsIDEsIDJdLFxyXG5cdFsyMiwgMiwgLTQsIDE0XSxcclxuXHRbMjQsIDMsIDE0LCAtNCwgMjNdLFxyXG5cdFsyOCwgMSwgLTM1XSxcclxuXHRbMjgsIDEsIC0yXSxcclxuXHRbMTcsIDIsIC0zNiwgLTE4XSxcclxuXHRbMjksIDEsIC0xN10sXHJcblx0WzI5LCAxLCAtMTldLFxyXG5cdFsyOSwgMSwgLTE4XVxyXG5dO1xyXG5cclxuWFBhdGhQYXJzZXIuRE9VQkxFRE9UID0gMjtcclxuWFBhdGhQYXJzZXIuRE9VQkxFQ09MT04gPSAzO1xyXG5YUGF0aFBhcnNlci5ET1VCTEVTTEFTSCA9IDQ7XHJcblhQYXRoUGFyc2VyLk5PVEVRVUFMID0gNTtcclxuWFBhdGhQYXJzZXIuTEVTU1RIQU5PUkVRVUFMID0gNjtcclxuWFBhdGhQYXJzZXIuR1JFQVRFUlRIQU5PUkVRVUFMID0gNztcclxuWFBhdGhQYXJzZXIuQU5EID0gODtcclxuWFBhdGhQYXJzZXIuT1IgPSA5O1xyXG5YUGF0aFBhcnNlci5NT0QgPSAxMDtcclxuWFBhdGhQYXJzZXIuRElWID0gMTE7XHJcblhQYXRoUGFyc2VyLk1VTFRJUExZT1BFUkFUT1IgPSAxMjtcclxuWFBhdGhQYXJzZXIuRlVOQ1RJT05OQU1FID0gMTM7XHJcblhQYXRoUGFyc2VyLkFYSVNOQU1FID0gMTQ7XHJcblhQYXRoUGFyc2VyLkxJVEVSQUwgPSAxNTtcclxuWFBhdGhQYXJzZXIuTlVNQkVSID0gMTY7XHJcblhQYXRoUGFyc2VyLkFTVEVSSVNLTkFNRVRFU1QgPSAxNztcclxuWFBhdGhQYXJzZXIuUU5BTUUgPSAxODtcclxuWFBhdGhQYXJzZXIuTkNOQU1FQ09MT05BU1RFUklTSyA9IDE5O1xyXG5YUGF0aFBhcnNlci5OT0RFVFlQRSA9IDIwO1xyXG5YUGF0aFBhcnNlci5QUk9DRVNTSU5HSU5TVFJVQ1RJT05XSVRITElURVJBTCA9IDIxO1xyXG5YUGF0aFBhcnNlci5FUVVBTFMgPSAyMjtcclxuWFBhdGhQYXJzZXIuTEVTU1RIQU4gPSAyMztcclxuWFBhdGhQYXJzZXIuR1JFQVRFUlRIQU4gPSAyNDtcclxuWFBhdGhQYXJzZXIuUExVUyA9IDI1O1xyXG5YUGF0aFBhcnNlci5NSU5VUyA9IDI2O1xyXG5YUGF0aFBhcnNlci5CQVIgPSAyNztcclxuWFBhdGhQYXJzZXIuU0xBU0ggPSAyODtcclxuWFBhdGhQYXJzZXIuTEVGVFBBUkVOVEhFU0lTID0gMjk7XHJcblhQYXRoUGFyc2VyLlJJR0hUUEFSRU5USEVTSVMgPSAzMDtcclxuWFBhdGhQYXJzZXIuQ09NTUEgPSAzMTtcclxuWFBhdGhQYXJzZXIuQVQgPSAzMjtcclxuWFBhdGhQYXJzZXIuTEVGVEJSQUNLRVQgPSAzMztcclxuWFBhdGhQYXJzZXIuUklHSFRCUkFDS0VUID0gMzQ7XHJcblhQYXRoUGFyc2VyLkRPVCA9IDM1O1xyXG5YUGF0aFBhcnNlci5ET0xMQVIgPSAzNjtcclxuXHJcblhQYXRoUGFyc2VyLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uKHMxKSB7XHJcblx0dmFyIHR5cGVzID0gW107XHJcblx0dmFyIHZhbHVlcyA9IFtdO1xyXG5cdHZhciBzID0gczEgKyAnXFwwJztcclxuXHJcblx0dmFyIHBvcyA9IDA7XHJcblx0dmFyIGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0d2hpbGUgKDEpIHtcclxuXHRcdHdoaWxlIChjID09ICcgJyB8fCBjID09ICdcXHQnIHx8IGMgPT0gJ1xccicgfHwgYyA9PSAnXFxuJykge1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGMgPT0gJ1xcMCcgfHwgcG9zID49IHMubGVuZ3RoKSB7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjID09ICcoJykge1xyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkxFRlRQQVJFTlRIRVNJUyk7XHJcblx0XHRcdHZhbHVlcy5wdXNoKGMpO1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHRcdGlmIChjID09ICcpJykge1xyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLlJJR0hUUEFSRU5USEVTSVMpO1xyXG5cdFx0XHR2YWx1ZXMucHVzaChjKTtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblx0XHRpZiAoYyA9PSAnWycpIHtcclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5MRUZUQlJBQ0tFVCk7XHJcblx0XHRcdHZhbHVlcy5wdXNoKGMpO1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHRcdGlmIChjID09ICddJykge1xyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLlJJR0hUQlJBQ0tFVCk7XHJcblx0XHRcdHZhbHVlcy5wdXNoKGMpO1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHRcdGlmIChjID09ICdAJykge1xyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkFUKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goYyk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGMgPT0gJywnKSB7XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuQ09NTUEpO1xyXG5cdFx0XHR2YWx1ZXMucHVzaChjKTtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblx0XHRpZiAoYyA9PSAnfCcpIHtcclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5CQVIpO1xyXG5cdFx0XHR2YWx1ZXMucHVzaChjKTtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblx0XHRpZiAoYyA9PSAnKycpIHtcclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5QTFVTKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goYyk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGMgPT0gJy0nKSB7XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuTUlOVVMpO1xyXG5cdFx0XHR2YWx1ZXMucHVzaChjKTtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblx0XHRpZiAoYyA9PSAnPScpIHtcclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5FUVVBTFMpO1xyXG5cdFx0XHR2YWx1ZXMucHVzaChjKTtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblx0XHRpZiAoYyA9PSAnJCcpIHtcclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5ET0xMQVIpO1xyXG5cdFx0XHR2YWx1ZXMucHVzaChjKTtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGMgPT0gJy4nKSB7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGlmIChjID09ICcuJykge1xyXG5cdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuRE9VQkxFRE9UKTtcclxuXHRcdFx0XHR2YWx1ZXMucHVzaChcIi4uXCIpO1xyXG5cdFx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGMgPj0gJzAnICYmIGMgPD0gJzknKSB7XHJcblx0XHRcdFx0dmFyIG51bWJlciA9IFwiLlwiICsgYztcclxuXHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRcdHdoaWxlIChjID49ICcwJyAmJiBjIDw9ICc5Jykge1xyXG5cdFx0XHRcdFx0bnVtYmVyICs9IGM7XHJcblx0XHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLk5VTUJFUik7XHJcblx0XHRcdFx0dmFsdWVzLnB1c2gobnVtYmVyKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkRPVCk7XHJcblx0XHRcdHZhbHVlcy5wdXNoKCcuJyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjID09ICdcXCcnIHx8IGMgPT0gJ1wiJykge1xyXG5cdFx0XHR2YXIgZGVsaW1pdGVyID0gYztcclxuXHRcdFx0dmFyIGxpdGVyYWwgPSBcIlwiO1xyXG5cdFx0XHR3aGlsZSAoKGMgPSBzLmNoYXJBdChwb3MrKykpICE9IGRlbGltaXRlcikge1xyXG5cdFx0XHRcdGxpdGVyYWwgKz0gYztcclxuXHRcdFx0fVxyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkxJVEVSQUwpO1xyXG5cdFx0XHR2YWx1ZXMucHVzaChsaXRlcmFsKTtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGMgPj0gJzAnICYmIGMgPD0gJzknKSB7XHJcblx0XHRcdHZhciBudW1iZXIgPSBjO1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHR3aGlsZSAoYyA+PSAnMCcgJiYgYyA8PSAnOScpIHtcclxuXHRcdFx0XHRudW1iZXIgKz0gYztcclxuXHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChjID09ICcuJykge1xyXG5cdFx0XHRcdGlmIChzLmNoYXJBdChwb3MpID49ICcwJyAmJiBzLmNoYXJBdChwb3MpIDw9ICc5Jykge1xyXG5cdFx0XHRcdFx0bnVtYmVyICs9IGM7XHJcblx0XHRcdFx0XHRudW1iZXIgKz0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHRcdHdoaWxlIChjID49ICcwJyAmJiBjIDw9ICc5Jykge1xyXG5cdFx0XHRcdFx0XHRudW1iZXIgKz0gYztcclxuXHRcdFx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5OVU1CRVIpO1xyXG5cdFx0XHR2YWx1ZXMucHVzaChudW1iZXIpO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYyA9PSAnKicpIHtcclxuXHRcdFx0aWYgKHR5cGVzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHR2YXIgbGFzdCA9IHR5cGVzW3R5cGVzLmxlbmd0aCAtIDFdO1xyXG5cdFx0XHRcdGlmIChsYXN0ICE9IFhQYXRoUGFyc2VyLkFUXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuRE9VQkxFQ09MT05cclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5MRUZUUEFSRU5USEVTSVNcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5MRUZUQlJBQ0tFVFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkFORFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLk9SXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTU9EXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuRElWXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTVVMVElQTFlPUEVSQVRPUlxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLlNMQVNIXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuRE9VQkxFU0xBU0hcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5CQVJcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5QTFVTXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTUlOVVNcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5FUVVBTFNcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5OT1RFUVVBTFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkxFU1NUSEFOXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTEVTU1RIQU5PUkVRVUFMXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuR1JFQVRFUlRIQU5cclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5HUkVBVEVSVEhBTk9SRVFVQUwpIHtcclxuXHRcdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuTVVMVElQTFlPUEVSQVRPUik7XHJcblx0XHRcdFx0XHR2YWx1ZXMucHVzaChjKTtcclxuXHRcdFx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5BU1RFUklTS05BTUVURVNUKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goYyk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjID09ICc6Jykge1xyXG5cdFx0XHRpZiAocy5jaGFyQXQocG9zKSA9PSAnOicpIHtcclxuXHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkRPVUJMRUNPTE9OKTtcclxuXHRcdFx0XHR2YWx1ZXMucHVzaChcIjo6XCIpO1xyXG5cdFx0XHRcdHBvcysrO1xyXG5cdFx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYyA9PSAnLycpIHtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0aWYgKGMgPT0gJy8nKSB7XHJcblx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5ET1VCTEVTTEFTSCk7XHJcblx0XHRcdFx0dmFsdWVzLnB1c2goXCIvL1wiKTtcclxuXHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuU0xBU0gpO1xyXG5cdFx0XHR2YWx1ZXMucHVzaCgnLycpO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYyA9PSAnIScpIHtcclxuXHRcdFx0aWYgKHMuY2hhckF0KHBvcykgPT0gJz0nKSB7XHJcblx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5OT1RFUVVBTCk7XHJcblx0XHRcdFx0dmFsdWVzLnB1c2goXCIhPVwiKTtcclxuXHRcdFx0XHRwb3MrKztcclxuXHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGMgPT0gJzwnKSB7XHJcblx0XHRcdGlmIChzLmNoYXJBdChwb3MpID09ICc9Jykge1xyXG5cdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuTEVTU1RIQU5PUkVRVUFMKTtcclxuXHRcdFx0XHR2YWx1ZXMucHVzaChcIjw9XCIpO1xyXG5cdFx0XHRcdHBvcysrO1xyXG5cdFx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5MRVNTVEhBTik7XHJcblx0XHRcdHZhbHVlcy5wdXNoKCc8Jyk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjID09ICc+Jykge1xyXG5cdFx0XHRpZiAocy5jaGFyQXQocG9zKSA9PSAnPScpIHtcclxuXHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkdSRUFURVJUSEFOT1JFUVVBTCk7XHJcblx0XHRcdFx0dmFsdWVzLnB1c2goXCI+PVwiKTtcclxuXHRcdFx0XHRwb3MrKztcclxuXHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuR1JFQVRFUlRIQU4pO1xyXG5cdFx0XHR2YWx1ZXMucHVzaCgnPicpO1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYyA9PSAnXycgfHwgVXRpbGl0aWVzLmlzTGV0dGVyKGMuY2hhckNvZGVBdCgwKSkpIHtcclxuXHRcdFx0dmFyIG5hbWUgPSBjO1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHR3aGlsZSAoVXRpbGl0aWVzLmlzTkNOYW1lQ2hhcihjLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0XHRcdFx0bmFtZSArPSBjO1xyXG5cdFx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHR5cGVzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHR2YXIgbGFzdCA9IHR5cGVzW3R5cGVzLmxlbmd0aCAtIDFdO1xyXG5cdFx0XHRcdGlmIChsYXN0ICE9IFhQYXRoUGFyc2VyLkFUXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuRE9VQkxFQ09MT05cclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5MRUZUUEFSRU5USEVTSVNcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5MRUZUQlJBQ0tFVFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkFORFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLk9SXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTU9EXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuRElWXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTVVMVElQTFlPUEVSQVRPUlxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLlNMQVNIXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuRE9VQkxFU0xBU0hcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5CQVJcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5QTFVTXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTUlOVVNcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5FUVVBTFNcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5OT1RFUVVBTFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkxFU1NUSEFOXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTEVTU1RIQU5PUkVRVUFMXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuR1JFQVRFUlRIQU5cclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5HUkVBVEVSVEhBTk9SRVFVQUwpIHtcclxuXHRcdFx0XHRcdGlmIChuYW1lID09IFwiYW5kXCIpIHtcclxuXHRcdFx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5BTkQpO1xyXG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaChuYW1lKTtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAobmFtZSA9PSBcIm9yXCIpIHtcclxuXHRcdFx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5PUik7XHJcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKG5hbWUpO1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChuYW1lID09IFwibW9kXCIpIHtcclxuXHRcdFx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5NT0QpO1xyXG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaChuYW1lKTtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAobmFtZSA9PSBcImRpdlwiKSB7XHJcblx0XHRcdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuRElWKTtcclxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2gobmFtZSk7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoYyA9PSAnOicpIHtcclxuXHRcdFx0XHRpZiAocy5jaGFyQXQocG9zKSA9PSAnKicpIHtcclxuXHRcdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuTkNOQU1FQ09MT05BU1RFUklTSyk7XHJcblx0XHRcdFx0XHR2YWx1ZXMucHVzaChuYW1lICsgXCI6KlwiKTtcclxuXHRcdFx0XHRcdHBvcysrO1xyXG5cdFx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAocy5jaGFyQXQocG9zKSA9PSAnXycgfHwgVXRpbGl0aWVzLmlzTGV0dGVyKHMuY2hhckNvZGVBdChwb3MpKSkge1xyXG5cdFx0XHRcdFx0bmFtZSArPSAnOic7XHJcblx0XHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRcdFx0d2hpbGUgKFV0aWxpdGllcy5pc05DTmFtZUNoYXIoYy5jaGFyQ29kZUF0KDApKSkge1xyXG5cdFx0XHRcdFx0XHRuYW1lICs9IGM7XHJcblx0XHRcdFx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoYyA9PSAnKCcpIHtcclxuXHRcdFx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5GVU5DVElPTk5BTUUpO1xyXG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaChuYW1lKTtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLlFOQU1FKTtcclxuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKG5hbWUpO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChzLmNoYXJBdChwb3MpID09ICc6Jykge1xyXG5cdFx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5BWElTTkFNRSk7XHJcblx0XHRcdFx0XHR2YWx1ZXMucHVzaChuYW1lKTtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoYyA9PSAnKCcpIHtcclxuXHRcdFx0XHRpZiAobmFtZSA9PSBcImNvbW1lbnRcIiB8fCBuYW1lID09IFwidGV4dFwiIHx8IG5hbWUgPT0gXCJub2RlXCIpIHtcclxuXHRcdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuTk9ERVRZUEUpO1xyXG5cdFx0XHRcdFx0dmFsdWVzLnB1c2gobmFtZSk7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKG5hbWUgPT0gXCJwcm9jZXNzaW5nLWluc3RydWN0aW9uXCIpIHtcclxuXHRcdFx0XHRcdGlmIChzLmNoYXJBdChwb3MpID09ICcpJykge1xyXG5cdFx0XHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLk5PREVUWVBFKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuUFJPQ0VTU0lOR0lOU1RSVUNUSU9OV0lUSExJVEVSQUwpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dmFsdWVzLnB1c2gobmFtZSk7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5GVU5DVElPTk5BTUUpO1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKG5hbWUpO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuUU5BTUUpO1xyXG5cdFx0XHR2YWx1ZXMucHVzaChuYW1lKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgXCIgKyBjKTtcclxuXHR9XHJcblx0dHlwZXMucHVzaCgxKTtcclxuXHR2YWx1ZXMucHVzaChcIltFT0ZdXCIpO1xyXG5cdHJldHVybiBbdHlwZXMsIHZhbHVlc107XHJcbn07XHJcblxyXG5YUGF0aFBhcnNlci5TSElGVCA9ICdzJztcclxuWFBhdGhQYXJzZXIuUkVEVUNFID0gJ3InO1xyXG5YUGF0aFBhcnNlci5BQ0NFUFQgPSAnYSc7XHJcblxyXG5YUGF0aFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihzKSB7XHJcblx0dmFyIHR5cGVzO1xyXG5cdHZhciB2YWx1ZXM7XHJcblx0dmFyIHJlcyA9IHRoaXMudG9rZW5pemUocyk7XHJcblx0aWYgKHJlcyA9PSB1bmRlZmluZWQpIHtcclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG5cdHR5cGVzID0gcmVzWzBdO1xyXG5cdHZhbHVlcyA9IHJlc1sxXTtcclxuXHR2YXIgdG9rZW5Qb3MgPSAwO1xyXG5cdHZhciBzdGF0ZSA9IFtdO1xyXG5cdHZhciB0b2tlblR5cGUgPSBbXTtcclxuXHR2YXIgdG9rZW5WYWx1ZSA9IFtdO1xyXG5cdHZhciBzO1xyXG5cdHZhciBhO1xyXG5cdHZhciB0O1xyXG5cclxuXHRzdGF0ZS5wdXNoKDApO1xyXG5cdHRva2VuVHlwZS5wdXNoKDEpO1xyXG5cdHRva2VuVmFsdWUucHVzaChcIl9TXCIpO1xyXG5cclxuXHRhID0gdHlwZXNbdG9rZW5Qb3NdO1xyXG5cdHQgPSB2YWx1ZXNbdG9rZW5Qb3MrK107XHJcblx0d2hpbGUgKDEpIHtcclxuXHRcdHMgPSBzdGF0ZVtzdGF0ZS5sZW5ndGggLSAxXTtcclxuXHRcdHN3aXRjaCAoWFBhdGhQYXJzZXIuYWN0aW9uVGFibGVbc10uY2hhckF0KGEgLSAxKSkge1xyXG5cdFx0XHRjYXNlIFhQYXRoUGFyc2VyLlNISUZUOlxyXG5cdFx0XHRcdHRva2VuVHlwZS5wdXNoKC1hKTtcclxuXHRcdFx0XHR0b2tlblZhbHVlLnB1c2godCk7XHJcblx0XHRcdFx0c3RhdGUucHVzaChYUGF0aFBhcnNlci5hY3Rpb25UYWJsZU51bWJlcltzXS5jaGFyQ29kZUF0KGEgLSAxKSAtIDMyKTtcclxuXHRcdFx0XHRhID0gdHlwZXNbdG9rZW5Qb3NdO1xyXG5cdFx0XHRcdHQgPSB2YWx1ZXNbdG9rZW5Qb3MrK107XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgWFBhdGhQYXJzZXIuUkVEVUNFOlxyXG5cdFx0XHRcdHZhciBudW0gPSBYUGF0aFBhcnNlci5wcm9kdWN0aW9uc1tYUGF0aFBhcnNlci5hY3Rpb25UYWJsZU51bWJlcltzXS5jaGFyQ29kZUF0KGEgLSAxKSAtIDMyXVsxXTtcclxuXHRcdFx0XHR2YXIgcmhzID0gW107XHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xyXG5cdFx0XHRcdFx0dG9rZW5UeXBlLnBvcCgpO1xyXG5cdFx0XHRcdFx0cmhzLnVuc2hpZnQodG9rZW5WYWx1ZS5wb3AoKSk7XHJcblx0XHRcdFx0XHRzdGF0ZS5wb3AoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIHNfID0gc3RhdGVbc3RhdGUubGVuZ3RoIC0gMV07XHJcblx0XHRcdFx0dG9rZW5UeXBlLnB1c2goWFBhdGhQYXJzZXIucHJvZHVjdGlvbnNbWFBhdGhQYXJzZXIuYWN0aW9uVGFibGVOdW1iZXJbc10uY2hhckNvZGVBdChhIC0gMSkgLSAzMl1bMF0pO1xyXG5cdFx0XHRcdGlmICh0aGlzLnJlZHVjZUFjdGlvbnNbWFBhdGhQYXJzZXIuYWN0aW9uVGFibGVOdW1iZXJbc10uY2hhckNvZGVBdChhIC0gMSkgLSAzMl0gPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHR0b2tlblZhbHVlLnB1c2gocmhzWzBdKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dG9rZW5WYWx1ZS5wdXNoKHRoaXMucmVkdWNlQWN0aW9uc1tYUGF0aFBhcnNlci5hY3Rpb25UYWJsZU51bWJlcltzXS5jaGFyQ29kZUF0KGEgLSAxKSAtIDMyXShyaHMpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0c3RhdGUucHVzaChYUGF0aFBhcnNlci5nb3RvVGFibGVbc19dLmNoYXJDb2RlQXQoWFBhdGhQYXJzZXIucHJvZHVjdGlvbnNbWFBhdGhQYXJzZXIuYWN0aW9uVGFibGVOdW1iZXJbc10uY2hhckNvZGVBdChhIC0gMSkgLSAzMl1bMF0gLSAyKSAtIDMzKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBYUGF0aFBhcnNlci5BQ0NFUFQ6XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBYUGF0aCh0b2tlblZhbHVlLnBvcCgpKTtcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJYUGF0aCBwYXJzZSBlcnJvclwiKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG4vLyBYUGF0aCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblhQYXRoLnByb3RvdHlwZSA9IG5ldyBPYmplY3QoKTtcclxuWFBhdGgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWFBhdGg7XHJcblhQYXRoLnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gWFBhdGgoZSkge1xyXG5cdHRoaXMuZXhwcmVzc2lvbiA9IGU7XHJcbn1cclxuXHJcblhQYXRoLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmV4cHJlc3Npb24udG9TdHJpbmcoKTtcclxufTtcclxuXHJcblhQYXRoLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRjLmNvbnRleHROb2RlID0gYy5leHByZXNzaW9uQ29udGV4dE5vZGU7XHJcblx0Yy5jb250ZXh0U2l6ZSA9IDE7XHJcblx0Yy5jb250ZXh0UG9zaXRpb24gPSAxO1xyXG5cdGMuY2FzZUluc2Vuc2l0aXZlID0gZmFsc2U7XHJcblx0aWYgKGMuY29udGV4dE5vZGUgIT0gbnVsbCkge1xyXG5cdFx0dmFyIGRvYyA9IGMuY29udGV4dE5vZGU7XHJcblx0XHRpZiAoZG9jLm5vZGVUeXBlICE9IDkgLypOb2RlLkRPQ1VNRU5UX05PREUqLykge1xyXG5cdFx0XHRkb2MgPSBkb2Mub3duZXJEb2N1bWVudDtcclxuXHRcdH1cclxuXHRcdHRyeSB7XHJcblx0XHRcdGMuY2FzZUluc2Vuc2l0aXZlID0gZG9jLmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJIVE1MXCIsIFwiMi4wXCIpO1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRjLmNhc2VJbnNlbnNpdGl2ZSA9IHRydWU7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUoYyk7XHJcbn07XHJcblxyXG5YUGF0aC5YTUxfTkFNRVNQQUNFX1VSSSA9IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCI7XHJcblhQYXRoLlhNTE5TX05BTUVTUEFDRV9VUkkgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvXCI7XHJcblxyXG4vLyBFeHByZXNzaW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbkV4cHJlc3Npb24ucHJvdG90eXBlID0gbmV3IE9iamVjdCgpO1xyXG5FeHByZXNzaW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV4cHJlc3Npb247XHJcbkV4cHJlc3Npb24uc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBFeHByZXNzaW9uKCkge1xyXG59XHJcblxyXG5FeHByZXNzaW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XHJcbn07XHJcblxyXG5FeHByZXNzaW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIjxFeHByZXNzaW9uPlwiO1xyXG59O1xyXG5cclxuRXhwcmVzc2lvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGV2YWx1YXRlIGV4cHJlc3Npb24uXCIpO1xyXG59O1xyXG5cclxuLy8gVW5hcnlPcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5VbmFyeU9wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXhwcmVzc2lvbigpO1xyXG5VbmFyeU9wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVbmFyeU9wZXJhdGlvbjtcclxuVW5hcnlPcGVyYXRpb24uc3VwZXJjbGFzcyA9IEV4cHJlc3Npb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gVW5hcnlPcGVyYXRpb24ocmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQocmhzKTtcclxuXHR9XHJcbn1cclxuXHJcblVuYXJ5T3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0dGhpcy5yaHMgPSByaHM7XHJcbn07XHJcblxyXG4vLyBVbmFyeU1pbnVzT3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblVuYXJ5TWludXNPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IFVuYXJ5T3BlcmF0aW9uKCk7XHJcblVuYXJ5TWludXNPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVW5hcnlNaW51c09wZXJhdGlvbjtcclxuVW5hcnlNaW51c09wZXJhdGlvbi5zdXBlcmNsYXNzID0gVW5hcnlPcGVyYXRpb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gVW5hcnlNaW51c09wZXJhdGlvbihyaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChyaHMpO1xyXG5cdH1cclxufVxyXG5cclxuVW5hcnlNaW51c09wZXJhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFVuYXJ5TWludXNPcGVyYXRpb24uc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgcmhzKTtcclxufTtcclxuXHJcblVuYXJ5TWludXNPcGVyYXRpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiB0aGlzLnJocy5ldmFsdWF0ZShjKS5udW1iZXIoKS5uZWdhdGUoKTtcclxufTtcclxuXHJcblVuYXJ5TWludXNPcGVyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiLVwiICsgdGhpcy5yaHMudG9TdHJpbmcoKTtcclxufTtcclxuXHJcbi8vIEJpbmFyeU9wZXJhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBFeHByZXNzaW9uKCk7XHJcbkJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCaW5hcnlPcGVyYXRpb247XHJcbkJpbmFyeU9wZXJhdGlvbi5zdXBlcmNsYXNzID0gRXhwcmVzc2lvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBCaW5hcnlPcGVyYXRpb24obGhzLCByaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChsaHMsIHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5CaW5hcnlPcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihsaHMsIHJocykge1xyXG5cdHRoaXMubGhzID0gbGhzO1xyXG5cdHRoaXMucmhzID0gcmhzO1xyXG59O1xyXG5cclxuLy8gT3JPcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5Pck9wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgQmluYXJ5T3BlcmF0aW9uKCk7XHJcbk9yT3BlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9yT3BlcmF0aW9uO1xyXG5Pck9wZXJhdGlvbi5zdXBlcmNsYXNzID0gQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIE9yT3BlcmF0aW9uKGxocywgcmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQobGhzLCByaHMpO1xyXG5cdH1cclxufVxyXG5cclxuT3JPcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihsaHMsIHJocykge1xyXG5cdE9yT3BlcmF0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIGxocywgcmhzKTtcclxufTtcclxuXHJcbk9yT3BlcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIihcIiArIHRoaXMubGhzLnRvU3RyaW5nKCkgKyBcIiBvciBcIiArIHRoaXMucmhzLnRvU3RyaW5nKCkgKyBcIilcIjtcclxufTtcclxuXHJcbk9yT3BlcmF0aW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHR2YXIgYiA9IHRoaXMubGhzLmV2YWx1YXRlKGMpLmJvb2woKTtcclxuXHRpZiAoYi5ib29sZWFuVmFsdWUoKSkge1xyXG5cdFx0cmV0dXJuIGI7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLnJocy5ldmFsdWF0ZShjKS5ib29sKCk7XHJcbn07XHJcblxyXG4vLyBBbmRPcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbkFuZE9wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgQmluYXJ5T3BlcmF0aW9uKCk7XHJcbkFuZE9wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBbmRPcGVyYXRpb247XHJcbkFuZE9wZXJhdGlvbi5zdXBlcmNsYXNzID0gQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIEFuZE9wZXJhdGlvbihsaHMsIHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGxocywgcmhzKTtcclxuXHR9XHJcbn1cclxuXHJcbkFuZE9wZXJhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XHJcblx0QW5kT3BlcmF0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIGxocywgcmhzKTtcclxufTtcclxuXHJcbkFuZE9wZXJhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCIoXCIgKyB0aGlzLmxocy50b1N0cmluZygpICsgXCIgYW5kIFwiICsgdGhpcy5yaHMudG9TdHJpbmcoKSArIFwiKVwiO1xyXG59O1xyXG5cclxuQW5kT3BlcmF0aW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHR2YXIgYiA9IHRoaXMubGhzLmV2YWx1YXRlKGMpLmJvb2woKTtcclxuXHRpZiAoIWIuYm9vbGVhblZhbHVlKCkpIHtcclxuXHRcdHJldHVybiBiO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5yaHMuZXZhbHVhdGUoYykuYm9vbCgpO1xyXG59O1xyXG5cclxuLy8gRXF1YWxzT3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5FcXVhbHNPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEJpbmFyeU9wZXJhdGlvbigpO1xyXG5FcXVhbHNPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXF1YWxzT3BlcmF0aW9uO1xyXG5FcXVhbHNPcGVyYXRpb24uc3VwZXJjbGFzcyA9IEJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBFcXVhbHNPcGVyYXRpb24obGhzLCByaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChsaHMsIHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5FcXVhbHNPcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihsaHMsIHJocykge1xyXG5cdEVxdWFsc09wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBsaHMsIHJocyk7XHJcbn07XHJcblxyXG5FcXVhbHNPcGVyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiKFwiICsgdGhpcy5saHMudG9TdHJpbmcoKSArIFwiID0gXCIgKyB0aGlzLnJocy50b1N0cmluZygpICsgXCIpXCI7XHJcbn07XHJcblxyXG5FcXVhbHNPcGVyYXRpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiB0aGlzLmxocy5ldmFsdWF0ZShjKS5lcXVhbHModGhpcy5yaHMuZXZhbHVhdGUoYykpO1xyXG59O1xyXG5cclxuLy8gTm90RXF1YWxPcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5Ob3RFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgQmluYXJ5T3BlcmF0aW9uKCk7XHJcbk5vdEVxdWFsT3BlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5vdEVxdWFsT3BlcmF0aW9uO1xyXG5Ob3RFcXVhbE9wZXJhdGlvbi5zdXBlcmNsYXNzID0gQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIE5vdEVxdWFsT3BlcmF0aW9uKGxocywgcmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQobGhzLCByaHMpO1xyXG5cdH1cclxufVxyXG5cclxuTm90RXF1YWxPcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihsaHMsIHJocykge1xyXG5cdE5vdEVxdWFsT3BlcmF0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIGxocywgcmhzKTtcclxufTtcclxuXHJcbk5vdEVxdWFsT3BlcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIihcIiArIHRoaXMubGhzLnRvU3RyaW5nKCkgKyBcIiAhPSBcIiArIHRoaXMucmhzLnRvU3RyaW5nKCkgKyBcIilcIjtcclxufTtcclxuXHJcbk5vdEVxdWFsT3BlcmF0aW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcy5saHMuZXZhbHVhdGUoYykubm90ZXF1YWwodGhpcy5yaHMuZXZhbHVhdGUoYykpO1xyXG59O1xyXG5cclxuLy8gTGVzc1RoYW5PcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5MZXNzVGhhbk9wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgQmluYXJ5T3BlcmF0aW9uKCk7XHJcbkxlc3NUaGFuT3BlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExlc3NUaGFuT3BlcmF0aW9uO1xyXG5MZXNzVGhhbk9wZXJhdGlvbi5zdXBlcmNsYXNzID0gQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIExlc3NUaGFuT3BlcmF0aW9uKGxocywgcmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQobGhzLCByaHMpO1xyXG5cdH1cclxufVxyXG5cclxuTGVzc1RoYW5PcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihsaHMsIHJocykge1xyXG5cdExlc3NUaGFuT3BlcmF0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIGxocywgcmhzKTtcclxufTtcclxuXHJcbkxlc3NUaGFuT3BlcmF0aW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcy5saHMuZXZhbHVhdGUoYykubGVzc3RoYW4odGhpcy5yaHMuZXZhbHVhdGUoYykpO1xyXG59O1xyXG5cclxuTGVzc1RoYW5PcGVyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiKFwiICsgdGhpcy5saHMudG9TdHJpbmcoKSArIFwiIDwgXCIgKyB0aGlzLnJocy50b1N0cmluZygpICsgXCIpXCI7XHJcbn07XHJcblxyXG4vLyBHcmVhdGVyVGhhbk9wZXJhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbkdyZWF0ZXJUaGFuT3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBCaW5hcnlPcGVyYXRpb24oKTtcclxuR3JlYXRlclRoYW5PcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR3JlYXRlclRoYW5PcGVyYXRpb247XHJcbkdyZWF0ZXJUaGFuT3BlcmF0aW9uLnN1cGVyY2xhc3MgPSBCaW5hcnlPcGVyYXRpb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gR3JlYXRlclRoYW5PcGVyYXRpb24obGhzLCByaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChsaHMsIHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5HcmVhdGVyVGhhbk9wZXJhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XHJcblx0R3JlYXRlclRoYW5PcGVyYXRpb24uc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbGhzLCByaHMpO1xyXG59O1xyXG5cclxuR3JlYXRlclRoYW5PcGVyYXRpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiB0aGlzLmxocy5ldmFsdWF0ZShjKS5ncmVhdGVydGhhbih0aGlzLnJocy5ldmFsdWF0ZShjKSk7XHJcbn07XHJcblxyXG5HcmVhdGVyVGhhbk9wZXJhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCIoXCIgKyB0aGlzLmxocy50b1N0cmluZygpICsgXCIgPiBcIiArIHRoaXMucmhzLnRvU3RyaW5nKCkgKyBcIilcIjtcclxufTtcclxuXHJcbi8vIExlc3NUaGFuT3JFcXVhbE9wZXJhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuTGVzc1RoYW5PckVxdWFsT3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBCaW5hcnlPcGVyYXRpb24oKTtcclxuTGVzc1RoYW5PckVxdWFsT3BlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExlc3NUaGFuT3JFcXVhbE9wZXJhdGlvbjtcclxuTGVzc1RoYW5PckVxdWFsT3BlcmF0aW9uLnN1cGVyY2xhc3MgPSBCaW5hcnlPcGVyYXRpb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gTGVzc1RoYW5PckVxdWFsT3BlcmF0aW9uKGxocywgcmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQobGhzLCByaHMpO1xyXG5cdH1cclxufVxyXG5cclxuTGVzc1RoYW5PckVxdWFsT3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHRMZXNzVGhhbk9yRXF1YWxPcGVyYXRpb24uc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbGhzLCByaHMpO1xyXG59O1xyXG5cclxuTGVzc1RoYW5PckVxdWFsT3BlcmF0aW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcy5saHMuZXZhbHVhdGUoYykubGVzc3RoYW5vcmVxdWFsKHRoaXMucmhzLmV2YWx1YXRlKGMpKTtcclxufTtcclxuXHJcbkxlc3NUaGFuT3JFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCIoXCIgKyB0aGlzLmxocy50b1N0cmluZygpICsgXCIgPD0gXCIgKyB0aGlzLnJocy50b1N0cmluZygpICsgXCIpXCI7XHJcbn07XHJcblxyXG4vLyBHcmVhdGVyVGhhbk9yRXF1YWxPcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbkdyZWF0ZXJUaGFuT3JFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgQmluYXJ5T3BlcmF0aW9uKCk7XHJcbkdyZWF0ZXJUaGFuT3JFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHcmVhdGVyVGhhbk9yRXF1YWxPcGVyYXRpb247XHJcbkdyZWF0ZXJUaGFuT3JFcXVhbE9wZXJhdGlvbi5zdXBlcmNsYXNzID0gQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIEdyZWF0ZXJUaGFuT3JFcXVhbE9wZXJhdGlvbihsaHMsIHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGxocywgcmhzKTtcclxuXHR9XHJcbn1cclxuXHJcbkdyZWF0ZXJUaGFuT3JFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XHJcblx0R3JlYXRlclRoYW5PckVxdWFsT3BlcmF0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIGxocywgcmhzKTtcclxufTtcclxuXHJcbkdyZWF0ZXJUaGFuT3JFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXMubGhzLmV2YWx1YXRlKGMpLmdyZWF0ZXJ0aGFub3JlcXVhbCh0aGlzLnJocy5ldmFsdWF0ZShjKSk7XHJcbn07XHJcblxyXG5HcmVhdGVyVGhhbk9yRXF1YWxPcGVyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiKFwiICsgdGhpcy5saHMudG9TdHJpbmcoKSArIFwiID49IFwiICsgdGhpcy5yaHMudG9TdHJpbmcoKSArIFwiKVwiO1xyXG59O1xyXG5cclxuLy8gUGx1c09wZXJhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5QbHVzT3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBCaW5hcnlPcGVyYXRpb24oKTtcclxuUGx1c09wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbHVzT3BlcmF0aW9uO1xyXG5QbHVzT3BlcmF0aW9uLnN1cGVyY2xhc3MgPSBCaW5hcnlPcGVyYXRpb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gUGx1c09wZXJhdGlvbihsaHMsIHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGxocywgcmhzKTtcclxuXHR9XHJcbn1cclxuXHJcblBsdXNPcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihsaHMsIHJocykge1xyXG5cdFBsdXNPcGVyYXRpb24uc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbGhzLCByaHMpO1xyXG59O1xyXG5cclxuUGx1c09wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXMubGhzLmV2YWx1YXRlKGMpLm51bWJlcigpLnBsdXModGhpcy5yaHMuZXZhbHVhdGUoYykubnVtYmVyKCkpO1xyXG59O1xyXG5cclxuUGx1c09wZXJhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCIoXCIgKyB0aGlzLmxocy50b1N0cmluZygpICsgXCIgKyBcIiArIHRoaXMucmhzLnRvU3RyaW5nKCkgKyBcIilcIjtcclxufTtcclxuXHJcbi8vIE1pbnVzT3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuTWludXNPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEJpbmFyeU9wZXJhdGlvbigpO1xyXG5NaW51c09wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNaW51c09wZXJhdGlvbjtcclxuTWludXNPcGVyYXRpb24uc3VwZXJjbGFzcyA9IEJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBNaW51c09wZXJhdGlvbihsaHMsIHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGxocywgcmhzKTtcclxuXHR9XHJcbn1cclxuXHJcbk1pbnVzT3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHRNaW51c09wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBsaHMsIHJocyk7XHJcbn07XHJcblxyXG5NaW51c09wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXMubGhzLmV2YWx1YXRlKGMpLm51bWJlcigpLm1pbnVzKHRoaXMucmhzLmV2YWx1YXRlKGMpLm51bWJlcigpKTtcclxufTtcclxuXHJcbk1pbnVzT3BlcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIihcIiArIHRoaXMubGhzLnRvU3RyaW5nKCkgKyBcIiAtIFwiICsgdGhpcy5yaHMudG9TdHJpbmcoKSArIFwiKVwiO1xyXG59O1xyXG5cclxuLy8gTXVsdGlwbHlPcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5NdWx0aXBseU9wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgQmluYXJ5T3BlcmF0aW9uKCk7XHJcbk11bHRpcGx5T3BlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE11bHRpcGx5T3BlcmF0aW9uO1xyXG5NdWx0aXBseU9wZXJhdGlvbi5zdXBlcmNsYXNzID0gQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIE11bHRpcGx5T3BlcmF0aW9uKGxocywgcmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQobGhzLCByaHMpO1xyXG5cdH1cclxufVxyXG5cclxuTXVsdGlwbHlPcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihsaHMsIHJocykge1xyXG5cdE11bHRpcGx5T3BlcmF0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIGxocywgcmhzKTtcclxufTtcclxuXHJcbk11bHRpcGx5T3BlcmF0aW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcy5saHMuZXZhbHVhdGUoYykubnVtYmVyKCkubXVsdGlwbHkodGhpcy5yaHMuZXZhbHVhdGUoYykubnVtYmVyKCkpO1xyXG59O1xyXG5cclxuTXVsdGlwbHlPcGVyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiKFwiICsgdGhpcy5saHMudG9TdHJpbmcoKSArIFwiICogXCIgKyB0aGlzLnJocy50b1N0cmluZygpICsgXCIpXCI7XHJcbn07XHJcblxyXG4vLyBEaXZPcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbkRpdk9wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgQmluYXJ5T3BlcmF0aW9uKCk7XHJcbkRpdk9wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEaXZPcGVyYXRpb247XHJcbkRpdk9wZXJhdGlvbi5zdXBlcmNsYXNzID0gQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIERpdk9wZXJhdGlvbihsaHMsIHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGxocywgcmhzKTtcclxuXHR9XHJcbn1cclxuXHJcbkRpdk9wZXJhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XHJcblx0RGl2T3BlcmF0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIGxocywgcmhzKTtcclxufTtcclxuXHJcbkRpdk9wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXMubGhzLmV2YWx1YXRlKGMpLm51bWJlcigpLmRpdih0aGlzLnJocy5ldmFsdWF0ZShjKS5udW1iZXIoKSk7XHJcbn07XHJcblxyXG5EaXZPcGVyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiKFwiICsgdGhpcy5saHMudG9TdHJpbmcoKSArIFwiIGRpdiBcIiArIHRoaXMucmhzLnRvU3RyaW5nKCkgKyBcIilcIjtcclxufTtcclxuXHJcbi8vIE1vZE9wZXJhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuTW9kT3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBCaW5hcnlPcGVyYXRpb24oKTtcclxuTW9kT3BlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1vZE9wZXJhdGlvbjtcclxuTW9kT3BlcmF0aW9uLnN1cGVyY2xhc3MgPSBCaW5hcnlPcGVyYXRpb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gTW9kT3BlcmF0aW9uKGxocywgcmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQobGhzLCByaHMpO1xyXG5cdH1cclxufVxyXG5cclxuTW9kT3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHRNb2RPcGVyYXRpb24uc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbGhzLCByaHMpO1xyXG59O1xyXG5cclxuTW9kT3BlcmF0aW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcy5saHMuZXZhbHVhdGUoYykubnVtYmVyKCkubW9kKHRoaXMucmhzLmV2YWx1YXRlKGMpLm51bWJlcigpKTtcclxufTtcclxuXHJcbk1vZE9wZXJhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCIoXCIgKyB0aGlzLmxocy50b1N0cmluZygpICsgXCIgbW9kIFwiICsgdGhpcy5yaHMudG9TdHJpbmcoKSArIFwiKVwiO1xyXG59O1xyXG5cclxuLy8gQmFyT3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5CYXJPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEJpbmFyeU9wZXJhdGlvbigpO1xyXG5CYXJPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmFyT3BlcmF0aW9uO1xyXG5CYXJPcGVyYXRpb24uc3VwZXJjbGFzcyA9IEJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBCYXJPcGVyYXRpb24obGhzLCByaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChsaHMsIHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5CYXJPcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihsaHMsIHJocykge1xyXG5cdEJhck9wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBsaHMsIHJocyk7XHJcbn07XHJcblxyXG5CYXJPcGVyYXRpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiB0aGlzLmxocy5ldmFsdWF0ZShjKS5ub2Rlc2V0KCkudW5pb24odGhpcy5yaHMuZXZhbHVhdGUoYykubm9kZXNldCgpKTtcclxufTtcclxuXHJcbkJhck9wZXJhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5saHMudG9TdHJpbmcoKSArIFwiIHwgXCIgKyB0aGlzLnJocy50b1N0cmluZygpO1xyXG59O1xyXG5cclxuLy8gUGF0aEV4cHIgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5QYXRoRXhwci5wcm90b3R5cGUgPSBuZXcgRXhwcmVzc2lvbigpO1xyXG5QYXRoRXhwci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXRoRXhwcjtcclxuUGF0aEV4cHIuc3VwZXJjbGFzcyA9IEV4cHJlc3Npb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gUGF0aEV4cHIoZmlsdGVyLCBmaWx0ZXJQcmVkcywgbG9jcGF0aCkge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGZpbHRlciwgZmlsdGVyUHJlZHMsIGxvY3BhdGgpO1xyXG5cdH1cclxufVxyXG5cclxuUGF0aEV4cHIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihmaWx0ZXIsIGZpbHRlclByZWRzLCBsb2NwYXRoKSB7XHJcblx0UGF0aEV4cHIuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcyk7XHJcblx0dGhpcy5maWx0ZXIgPSBmaWx0ZXI7XHJcblx0dGhpcy5maWx0ZXJQcmVkaWNhdGVzID0gZmlsdGVyUHJlZHM7XHJcblx0dGhpcy5sb2NhdGlvblBhdGggPSBsb2NwYXRoO1xyXG59O1xyXG5cclxuUGF0aEV4cHIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHZhciBub2RlcztcclxuXHR2YXIgeHBjID0gbmV3IFhQYXRoQ29udGV4dCgpO1xyXG5cdHhwYy52YXJpYWJsZVJlc29sdmVyID0gYy52YXJpYWJsZVJlc29sdmVyO1xyXG5cdHhwYy5mdW5jdGlvblJlc29sdmVyID0gYy5mdW5jdGlvblJlc29sdmVyO1xyXG5cdHhwYy5uYW1lc3BhY2VSZXNvbHZlciA9IGMubmFtZXNwYWNlUmVzb2x2ZXI7XHJcblx0eHBjLmV4cHJlc3Npb25Db250ZXh0Tm9kZSA9IGMuZXhwcmVzc2lvbkNvbnRleHROb2RlO1xyXG5cdHhwYy52aXJ0dWFsUm9vdCA9IGMudmlydHVhbFJvb3Q7XHJcblx0eHBjLmNhc2VJbnNlbnNpdGl2ZSA9IGMuY2FzZUluc2Vuc2l0aXZlO1xyXG5cdGlmICh0aGlzLmZpbHRlciA9PSBudWxsKSB7XHJcblx0XHRub2RlcyA9IFsgYy5jb250ZXh0Tm9kZSBdO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgbnMgPSB0aGlzLmZpbHRlci5ldmFsdWF0ZShjKTtcclxuXHRcdGlmICghVXRpbGl0aWVzLmluc3RhbmNlX29mKG5zLCBYTm9kZVNldCkpIHtcclxuXHRcdFx0aWYgKHRoaXMuZmlsdGVyUHJlZGljYXRlcyAhPSBudWxsICYmIHRoaXMuZmlsdGVyUHJlZGljYXRlcy5sZW5ndGggPiAwIHx8IHRoaXMubG9jYXRpb25QYXRoICE9IG51bGwpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXRoIGV4cHJlc3Npb24gZmlsdGVyIG11c3QgZXZhbHVhdGUgdG8gYSBub2RzZXQgaWYgcHJlZGljYXRlcyBvciBsb2NhdGlvbiBwYXRoIGFyZSB1c2VkXCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBucztcclxuXHRcdH1cclxuXHRcdG5vZGVzID0gbnMudG9BcnJheSgpO1xyXG5cdFx0aWYgKHRoaXMuZmlsdGVyUHJlZGljYXRlcyAhPSBudWxsKSB7XHJcblx0XHRcdC8vIGFwcGx5IGVhY2ggb2YgdGhlIHByZWRpY2F0ZXMgaW4gdHVyblxyXG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuZmlsdGVyUHJlZGljYXRlcy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHZhciBwcmVkID0gdGhpcy5maWx0ZXJQcmVkaWNhdGVzW2pdO1xyXG5cdFx0XHRcdHZhciBuZXdOb2RlcyA9IFtdO1xyXG5cdFx0XHRcdHhwYy5jb250ZXh0U2l6ZSA9IG5vZGVzLmxlbmd0aDtcclxuXHRcdFx0XHRmb3IgKHhwYy5jb250ZXh0UG9zaXRpb24gPSAxOyB4cGMuY29udGV4dFBvc2l0aW9uIDw9IHhwYy5jb250ZXh0U2l6ZTsgeHBjLmNvbnRleHRQb3NpdGlvbisrKSB7XHJcblx0XHRcdFx0XHR4cGMuY29udGV4dE5vZGUgPSBub2Rlc1t4cGMuY29udGV4dFBvc2l0aW9uIC0gMV07XHJcblx0XHRcdFx0XHRpZiAodGhpcy5wcmVkaWNhdGVNYXRjaGVzKHByZWQsIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0bmV3Tm9kZXMucHVzaCh4cGMuY29udGV4dE5vZGUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRub2RlcyA9IG5ld05vZGVzO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmICh0aGlzLmxvY2F0aW9uUGF0aCAhPSBudWxsKSB7XHJcblx0XHRpZiAodGhpcy5sb2NhdGlvblBhdGguYWJzb2x1dGUpIHtcclxuXHRcdFx0aWYgKG5vZGVzWzBdLm5vZGVUeXBlICE9IDkgLypOb2RlLkRPQ1VNRU5UX05PREUqLykge1xyXG5cdFx0XHRcdGlmICh4cGMudmlydHVhbFJvb3QgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0bm9kZXMgPSBbIHhwYy52aXJ0dWFsUm9vdCBdO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZiAobm9kZXNbMF0ub3duZXJEb2N1bWVudCA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdC8vIElFIDUuNSBkb2Vzbid0IGhhdmUgb3duZXJEb2N1bWVudD9cclxuXHRcdFx0XHRcdFx0dmFyIG4gPSBub2Rlc1swXTtcclxuXHRcdFx0XHRcdFx0d2hpbGUgKG4ucGFyZW50Tm9kZSAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0biA9IG4ucGFyZW50Tm9kZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRub2RlcyA9IFsgbiBdO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0bm9kZXMgPSBbIG5vZGVzWzBdLm93bmVyRG9jdW1lbnQgXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bm9kZXMgPSBbIG5vZGVzWzBdIF07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sb2NhdGlvblBhdGguc3RlcHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIHN0ZXAgPSB0aGlzLmxvY2F0aW9uUGF0aC5zdGVwc1tpXTtcclxuXHRcdFx0dmFyIG5ld05vZGVzID0gW107XHJcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHR4cGMuY29udGV4dE5vZGUgPSBub2Rlc1tqXTtcclxuXHRcdFx0XHRzd2l0Y2ggKHN0ZXAuYXhpcykge1xyXG5cdFx0XHRcdFx0Y2FzZSBTdGVwLkFOQ0VTVE9SOlxyXG5cdFx0XHRcdFx0XHQvLyBsb29rIGF0IGFsbCB0aGUgYW5jZXN0b3Igbm9kZXNcclxuXHRcdFx0XHRcdFx0aWYgKHhwYy5jb250ZXh0Tm9kZSA9PT0geHBjLnZpcnR1YWxSb290KSB7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0dmFyIG07XHJcblx0XHRcdFx0XHRcdGlmICh4cGMuY29udGV4dE5vZGUubm9kZVR5cGUgPT0gMiAvKk5vZGUuQVRUUklCVVRFX05PREUqLykge1xyXG5cdFx0XHRcdFx0XHRcdG0gPSB0aGlzLmdldE93bmVyRWxlbWVudCh4cGMuY29udGV4dE5vZGUpO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdG0gPSB4cGMuY29udGV4dE5vZGUucGFyZW50Tm9kZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR3aGlsZSAobSAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKHN0ZXAubm9kZVRlc3QubWF0Y2hlcyhtLCB4cGMpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRuZXdOb2Rlcy5wdXNoKG0pO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRpZiAobSA9PT0geHBjLnZpcnR1YWxSb290KSB7XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0bSA9IG0ucGFyZW50Tm9kZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFN0ZXAuQU5DRVNUT1JPUlNFTEY6XHJcblx0XHRcdFx0XHRcdC8vIGxvb2sgYXQgYWxsIHRoZSBhbmNlc3RvciBub2RlcyBhbmQgdGhlIGN1cnJlbnQgbm9kZVxyXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBtID0geHBjLmNvbnRleHROb2RlOyBtICE9IG51bGw7IG0gPSBtLm5vZGVUeXBlID09IDIgLypOb2RlLkFUVFJJQlVURV9OT0RFKi8gPyB0aGlzLmdldE93bmVyRWxlbWVudChtKSA6IG0ucGFyZW50Tm9kZSkge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChzdGVwLm5vZGVUZXN0Lm1hdGNoZXMobSwgeHBjKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0bmV3Tm9kZXMucHVzaChtKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0aWYgKG0gPT09IHhwYy52aXJ0dWFsUm9vdCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgU3RlcC5BVFRSSUJVVEU6XHJcblx0XHRcdFx0XHRcdC8vIGxvb2sgYXQgdGhlIGF0dHJpYnV0ZXNcclxuXHRcdFx0XHRcdFx0dmFyIG5ubSA9IHhwYy5jb250ZXh0Tm9kZS5hdHRyaWJ1dGVzO1xyXG5cdFx0XHRcdFx0XHRpZiAobm5tICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IG5ubS5sZW5ndGg7IGsrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIG0gPSBubm0uaXRlbShrKTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmIChzdGVwLm5vZGVUZXN0Lm1hdGNoZXMobSwgeHBjKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdOb2Rlcy5wdXNoKG0pO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFN0ZXAuQ0hJTEQ6XHJcblx0XHRcdFx0XHRcdC8vIGxvb2sgYXQgYWxsIGNoaWxkIGVsZW1lbnRzXHJcblx0XHRcdFx0XHRcdGZvciAodmFyIG0gPSB4cGMuY29udGV4dE5vZGUuZmlyc3RDaGlsZDsgbSAhPSBudWxsOyBtID0gbS5uZXh0U2libGluZykge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChzdGVwLm5vZGVUZXN0Lm1hdGNoZXMobSwgeHBjKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0bmV3Tm9kZXMucHVzaChtKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBTdGVwLkRFU0NFTkRBTlQ6XHJcblx0XHRcdFx0XHRcdC8vIGxvb2sgYXQgYWxsIGRlc2NlbmRhbnQgbm9kZXNcclxuXHRcdFx0XHRcdFx0dmFyIHN0ID0gWyB4cGMuY29udGV4dE5vZGUuZmlyc3RDaGlsZCBdO1xyXG5cdFx0XHRcdFx0XHR3aGlsZSAoc3QubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIG0gPSBzdC5wb3AoKTsgbSAhPSBudWxsOyApIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmIChzdGVwLm5vZGVUZXN0Lm1hdGNoZXMobSwgeHBjKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdOb2Rlcy5wdXNoKG0pO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKG0uZmlyc3RDaGlsZCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHN0LnB1c2gobS5uZXh0U2libGluZyk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG0gPSBtLmZpcnN0Q2hpbGQ7XHJcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRtID0gbS5uZXh0U2libGluZztcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBTdGVwLkRFU0NFTkRBTlRPUlNFTEY6XHJcblx0XHRcdFx0XHRcdC8vIGxvb2sgYXQgc2VsZlxyXG5cdFx0XHRcdFx0XHRpZiAoc3RlcC5ub2RlVGVzdC5tYXRjaGVzKHhwYy5jb250ZXh0Tm9kZSwgeHBjKSkge1xyXG5cdFx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2goeHBjLmNvbnRleHROb2RlKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHQvLyBsb29rIGF0IGFsbCBkZXNjZW5kYW50IG5vZGVzXHJcblx0XHRcdFx0XHRcdHZhciBzdCA9IFsgeHBjLmNvbnRleHROb2RlLmZpcnN0Q2hpbGQgXTtcclxuXHRcdFx0XHRcdFx0d2hpbGUgKHN0Lmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBtID0gc3QucG9wKCk7IG0gIT0gbnVsbDsgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoc3RlcC5ub2RlVGVzdC5tYXRjaGVzKG0sIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3Tm9kZXMucHVzaChtKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdGlmIChtLmZpcnN0Q2hpbGQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRzdC5wdXNoKG0ubmV4dFNpYmxpbmcpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRtID0gbS5maXJzdENoaWxkO1xyXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bSA9IG0ubmV4dFNpYmxpbmc7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgU3RlcC5GT0xMT1dJTkc6XHJcblx0XHRcdFx0XHRcdGlmICh4cGMuY29udGV4dE5vZGUgPT09IHhwYy52aXJ0dWFsUm9vdCkge1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHZhciBzdCA9IFtdO1xyXG5cdFx0XHRcdFx0XHRpZiAoeHBjLmNvbnRleHROb2RlLmZpcnN0Q2hpbGQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdHN0LnVuc2hpZnQoeHBjLmNvbnRleHROb2RlLmZpcnN0Q2hpbGQpO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdHN0LnVuc2hpZnQoeHBjLmNvbnRleHROb2RlLm5leHRTaWJsaW5nKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBtID0geHBjLmNvbnRleHROb2RlLnBhcmVudE5vZGU7IG0gIT0gbnVsbCAmJiBtLm5vZGVUeXBlICE9IDkgLypOb2RlLkRPQ1VNRU5UX05PREUqLyAmJiBtICE9PSB4cGMudmlydHVhbFJvb3Q7IG0gPSBtLnBhcmVudE5vZGUpIHtcclxuXHRcdFx0XHRcdFx0XHRzdC51bnNoaWZ0KG0ubmV4dFNpYmxpbmcpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGRvIHtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBtID0gc3QucG9wKCk7IG0gIT0gbnVsbDsgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoc3RlcC5ub2RlVGVzdC5tYXRjaGVzKG0sIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3Tm9kZXMucHVzaChtKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdGlmIChtLmZpcnN0Q2hpbGQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRzdC5wdXNoKG0ubmV4dFNpYmxpbmcpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRtID0gbS5maXJzdENoaWxkO1xyXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bSA9IG0ubmV4dFNpYmxpbmc7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9IHdoaWxlIChzdC5sZW5ndGggPiAwKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBTdGVwLkZPTExPV0lOR1NJQkxJTkc6XHJcblx0XHRcdFx0XHRcdGlmICh4cGMuY29udGV4dE5vZGUgPT09IHhwYy52aXJ0dWFsUm9vdCkge1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGZvciAodmFyIG0gPSB4cGMuY29udGV4dE5vZGUubmV4dFNpYmxpbmc7IG0gIT0gbnVsbDsgbSA9IG0ubmV4dFNpYmxpbmcpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoc3RlcC5ub2RlVGVzdC5tYXRjaGVzKG0sIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2gobSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgU3RlcC5OQU1FU1BBQ0U6XHJcblx0XHRcdFx0XHRcdHZhciBuID0ge307XHJcblx0XHRcdFx0XHRcdGlmICh4cGMuY29udGV4dE5vZGUubm9kZVR5cGUgPT0gMSAvKk5vZGUuRUxFTUVOVF9OT0RFKi8pIHtcclxuXHRcdFx0XHRcdFx0XHRuW1wieG1sXCJdID0gWFBhdGguWE1MX05BTUVTUEFDRV9VUkk7XHJcblx0XHRcdFx0XHRcdFx0bltcInhtbG5zXCJdID0gWFBhdGguWE1MTlNfTkFNRVNQQUNFX1VSSTtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBtID0geHBjLmNvbnRleHROb2RlOyBtICE9IG51bGwgJiYgbS5ub2RlVHlwZSA9PSAxIC8qTm9kZS5FTEVNRU5UX05PREUqLzsgbSA9IG0ucGFyZW50Tm9kZSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBtLmF0dHJpYnV0ZXMubGVuZ3RoOyBrKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGF0dHIgPSBtLmF0dHJpYnV0ZXMuaXRlbShrKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIG5tID0gU3RyaW5nKGF0dHIubmFtZSk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChubSA9PSBcInhtbG5zXCIpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAobltcIlwiXSA9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5bXCJcIl0gPSBhdHRyLnZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChubS5sZW5ndGggPiA2ICYmIG5tLnN1YnN0cmluZygwLCA2KSA9PSBcInhtbG5zOlwiKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHByZSA9IG5tLnN1YnN0cmluZyg2LCBubS5sZW5ndGgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChuW3ByZV0gPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuW3ByZV0gPSBhdHRyLnZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBwcmUgaW4gbikge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIG5zbiA9IG5ldyBOYW1lc3BhY2VOb2RlKHByZSwgbltwcmVdLCB4cGMuY29udGV4dE5vZGUpO1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHN0ZXAubm9kZVRlc3QubWF0Y2hlcyhuc24sIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3Tm9kZXMucHVzaChuc24pO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFN0ZXAuUEFSRU5UOlxyXG5cdFx0XHRcdFx0XHRtID0gbnVsbDtcclxuXHRcdFx0XHRcdFx0aWYgKHhwYy5jb250ZXh0Tm9kZSAhPT0geHBjLnZpcnR1YWxSb290KSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKHhwYy5jb250ZXh0Tm9kZS5ub2RlVHlwZSA9PSAyIC8qTm9kZS5BVFRSSUJVVEVfTk9ERSovKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRtID0gdGhpcy5nZXRPd25lckVsZW1lbnQoeHBjLmNvbnRleHROb2RlKTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0bSA9IHhwYy5jb250ZXh0Tm9kZS5wYXJlbnROb2RlO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZiAobSAhPSBudWxsICYmIHN0ZXAubm9kZVRlc3QubWF0Y2hlcyhtLCB4cGMpKSB7XHJcblx0XHRcdFx0XHRcdFx0bmV3Tm9kZXMucHVzaChtKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFN0ZXAuUFJFQ0VESU5HOlxyXG5cdFx0XHRcdFx0XHR2YXIgc3Q7XHJcblx0XHRcdFx0XHRcdGlmICh4cGMudmlydHVhbFJvb3QgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdHN0ID0gWyB4cGMudmlydHVhbFJvb3QgXTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRzdCA9IHhwYy5jb250ZXh0Tm9kZS5ub2RlVHlwZSA9PSA5IC8qTm9kZS5ET0NVTUVOVF9OT0RFKi9cclxuXHRcdFx0XHRcdFx0XHRcdD8gWyB4cGMuY29udGV4dE5vZGUgXVxyXG5cdFx0XHRcdFx0XHRcdFx0OiBbIHhwYy5jb250ZXh0Tm9kZS5vd25lckRvY3VtZW50IF07XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0b3V0ZXI6IHdoaWxlIChzdC5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgbSA9IHN0LnBvcCgpOyBtICE9IG51bGw7ICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKG0gPT0geHBjLmNvbnRleHROb2RlKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrIG91dGVyO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHN0ZXAubm9kZVRlc3QubWF0Y2hlcyhtLCB4cGMpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG5ld05vZGVzLnVuc2hpZnQobSk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAobS5maXJzdENoaWxkICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0c3QucHVzaChtLm5leHRTaWJsaW5nKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bSA9IG0uZmlyc3RDaGlsZDtcclxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG0gPSBtLm5leHRTaWJsaW5nO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFN0ZXAuUFJFQ0VESU5HU0lCTElORzpcclxuXHRcdFx0XHRcdFx0aWYgKHhwYy5jb250ZXh0Tm9kZSA9PT0geHBjLnZpcnR1YWxSb290KSB7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgbSA9IHhwYy5jb250ZXh0Tm9kZS5wcmV2aW91c1NpYmxpbmc7IG0gIT0gbnVsbDsgbSA9IG0ucHJldmlvdXNTaWJsaW5nKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKHN0ZXAubm9kZVRlc3QubWF0Y2hlcyhtLCB4cGMpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRuZXdOb2Rlcy5wdXNoKG0pO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFN0ZXAuU0VMRjpcclxuXHRcdFx0XHRcdFx0aWYgKHN0ZXAubm9kZVRlc3QubWF0Y2hlcyh4cGMuY29udGV4dE5vZGUsIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRuZXdOb2Rlcy5wdXNoKHhwYy5jb250ZXh0Tm9kZSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0bm9kZXMgPSBuZXdOb2RlcztcclxuXHRcdFx0Ly8gYXBwbHkgZWFjaCBvZiB0aGUgcHJlZGljYXRlcyBpbiB0dXJuXHJcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgc3RlcC5wcmVkaWNhdGVzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0dmFyIHByZWQgPSBzdGVwLnByZWRpY2F0ZXNbal07XHJcblx0XHRcdFx0dmFyIG5ld05vZGVzID0gW107XHJcblx0XHRcdFx0eHBjLmNvbnRleHRTaXplID0gbm9kZXMubGVuZ3RoO1xyXG5cdFx0XHRcdGZvciAoeHBjLmNvbnRleHRQb3NpdGlvbiA9IDE7IHhwYy5jb250ZXh0UG9zaXRpb24gPD0geHBjLmNvbnRleHRTaXplOyB4cGMuY29udGV4dFBvc2l0aW9uKyspIHtcclxuXHRcdFx0XHRcdHhwYy5jb250ZXh0Tm9kZSA9IG5vZGVzW3hwYy5jb250ZXh0UG9zaXRpb24gLSAxXTtcclxuXHRcdFx0XHRcdGlmICh0aGlzLnByZWRpY2F0ZU1hdGNoZXMocHJlZCwgeHBjKSkge1xyXG5cdFx0XHRcdFx0XHRuZXdOb2Rlcy5wdXNoKHhwYy5jb250ZXh0Tm9kZSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRub2RlcyA9IG5ld05vZGVzO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdHZhciBucyA9IG5ldyBYTm9kZVNldCgpO1xyXG5cdG5zLmFkZEFycmF5KG5vZGVzKTtcclxuXHRyZXR1cm4gbnM7XHJcbn07XHJcblxyXG5QYXRoRXhwci5wcm90b3R5cGUucHJlZGljYXRlTWF0Y2hlcyA9IGZ1bmN0aW9uKHByZWQsIGMpIHtcclxuXHR2YXIgcmVzID0gcHJlZC5ldmFsdWF0ZShjKTtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHJlcywgWE51bWJlcikpIHtcclxuXHRcdHJldHVybiBjLmNvbnRleHRQb3NpdGlvbiA9PSByZXMubnVtYmVyVmFsdWUoKTtcclxuXHR9XHJcblx0cmV0dXJuIHJlcy5ib29sZWFuVmFsdWUoKTtcclxufTtcclxuXHJcblBhdGhFeHByLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdGlmICh0aGlzLmZpbHRlciAhPSB1bmRlZmluZWQpIHtcclxuXHRcdHZhciBzID0gdGhpcy5maWx0ZXIudG9TdHJpbmcoKTtcclxuXHRcdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YodGhpcy5maWx0ZXIsIFhTdHJpbmcpKSB7XHJcblx0XHRcdHMgPSBcIidcIiArIHMgKyBcIidcIjtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLmZpbHRlclByZWRpY2F0ZXMgIT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5maWx0ZXJQcmVkaWNhdGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0cyA9IHMgKyBcIltcIiArIHRoaXMuZmlsdGVyUHJlZGljYXRlc1tpXS50b1N0cmluZygpICsgXCJdXCI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLmxvY2F0aW9uUGF0aCAhPSB1bmRlZmluZWQpIHtcclxuXHRcdFx0aWYgKCF0aGlzLmxvY2F0aW9uUGF0aC5hYnNvbHV0ZSkge1xyXG5cdFx0XHRcdHMgKz0gXCIvXCI7XHJcblx0XHRcdH1cclxuXHRcdFx0cyArPSB0aGlzLmxvY2F0aW9uUGF0aC50b1N0cmluZygpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHM7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLmxvY2F0aW9uUGF0aC50b1N0cmluZygpO1xyXG59O1xyXG5cclxuUGF0aEV4cHIucHJvdG90eXBlLmdldE93bmVyRWxlbWVudCA9IGZ1bmN0aW9uKG4pIHtcclxuXHQvLyBET00gMiBoYXMgb3duZXJFbGVtZW50XHJcblx0aWYgKG4ub3duZXJFbGVtZW50KSB7XHJcblx0XHRyZXR1cm4gbi5vd25lckVsZW1lbnQ7XHJcblx0fVxyXG5cdC8vIERPTSAxIEludGVybmV0IEV4cGxvcmVyIGNhbiB1c2Ugc2VsZWN0U2luZ2xlTm9kZSAoaXJvbmljYWxseSlcclxuXHR0cnkge1xyXG5cdFx0aWYgKG4uc2VsZWN0U2luZ2xlTm9kZSkge1xyXG5cdFx0XHRyZXR1cm4gbi5zZWxlY3RTaW5nbGVOb2RlKFwiLi5cIik7XHJcblx0XHR9XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdH1cclxuXHQvLyBPdGhlciBET00gMSBpbXBsZW1lbnRhdGlvbnMgbXVzdCB1c2UgdGhpcyBlZ3JlZ2lvdXMgc2VhcmNoXHJcblx0dmFyIGRvYyA9IG4ubm9kZVR5cGUgPT0gOSAvKk5vZGUuRE9DVU1FTlRfTk9ERSovXHJcblx0XHRcdD8gblxyXG5cdFx0XHQ6IG4ub3duZXJEb2N1bWVudDtcclxuXHR2YXIgZWx0cyA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIik7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbHRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgZWx0ID0gZWx0cy5pdGVtKGkpO1xyXG5cdFx0dmFyIG5ubSA9IGVsdC5hdHRyaWJ1dGVzO1xyXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBubm0ubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0dmFyIGFuID0gbm5tLml0ZW0oaik7XHJcblx0XHRcdGlmIChhbiA9PT0gbikge1xyXG5cdFx0XHRcdHJldHVybiBlbHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG4vLyBMb2NhdGlvblBhdGggLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbkxvY2F0aW9uUGF0aC5wcm90b3R5cGUgPSBuZXcgT2JqZWN0KCk7XHJcbkxvY2F0aW9uUGF0aC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2NhdGlvblBhdGg7XHJcbkxvY2F0aW9uUGF0aC5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIExvY2F0aW9uUGF0aChhYnMsIHN0ZXBzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQoYWJzLCBzdGVwcyk7XHJcblx0fVxyXG59XHJcblxyXG5Mb2NhdGlvblBhdGgucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihhYnMsIHN0ZXBzKSB7XHJcblx0dGhpcy5hYnNvbHV0ZSA9IGFicztcclxuXHR0aGlzLnN0ZXBzID0gc3RlcHM7XHJcbn07XHJcblxyXG5Mb2NhdGlvblBhdGgucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIHM7XHJcblx0aWYgKHRoaXMuYWJzb2x1dGUpIHtcclxuXHRcdHMgPSBcIi9cIjtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cyA9IFwiXCI7XHJcblx0fVxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdGVwcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKGkgIT0gMCkge1xyXG5cdFx0XHRzICs9IFwiL1wiO1xyXG5cdFx0fVxyXG5cdFx0cyArPSB0aGlzLnN0ZXBzW2ldLnRvU3RyaW5nKCk7XHJcblx0fVxyXG5cdHJldHVybiBzO1xyXG59O1xyXG5cclxuLy8gU3RlcCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5TdGVwLnByb3RvdHlwZSA9IG5ldyBPYmplY3QoKTtcclxuU3RlcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdGVwO1xyXG5TdGVwLnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gU3RlcChheGlzLCBub2RldGVzdCwgcHJlZHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChheGlzLCBub2RldGVzdCwgcHJlZHMpO1xyXG5cdH1cclxufVxyXG5cclxuU3RlcC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGF4aXMsIG5vZGV0ZXN0LCBwcmVkcykge1xyXG5cdHRoaXMuYXhpcyA9IGF4aXM7XHJcblx0dGhpcy5ub2RlVGVzdCA9IG5vZGV0ZXN0O1xyXG5cdHRoaXMucHJlZGljYXRlcyA9IHByZWRzO1xyXG59O1xyXG5cclxuU3RlcC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgcztcclxuXHRzd2l0Y2ggKHRoaXMuYXhpcykge1xyXG5cdFx0Y2FzZSBTdGVwLkFOQ0VTVE9SOlxyXG5cdFx0XHRzID0gXCJhbmNlc3RvclwiO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgU3RlcC5BTkNFU1RPUk9SU0VMRjpcclxuXHRcdFx0cyA9IFwiYW5jZXN0b3Itb3Itc2VsZlwiO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgU3RlcC5BVFRSSUJVVEU6XHJcblx0XHRcdHMgPSBcImF0dHJpYnV0ZVwiO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgU3RlcC5DSElMRDpcclxuXHRcdFx0cyA9IFwiY2hpbGRcIjtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIFN0ZXAuREVTQ0VOREFOVDpcclxuXHRcdFx0cyA9IFwiZGVzY2VuZGFudFwiO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgU3RlcC5ERVNDRU5EQU5UT1JTRUxGOlxyXG5cdFx0XHRzID0gXCJkZXNjZW5kYW50LW9yLXNlbGZcIjtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIFN0ZXAuRk9MTE9XSU5HOlxyXG5cdFx0XHRzID0gXCJmb2xsb3dpbmdcIjtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIFN0ZXAuRk9MTE9XSU5HU0lCTElORzpcclxuXHRcdFx0cyA9IFwiZm9sbG93aW5nLXNpYmxpbmdcIjtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIFN0ZXAuTkFNRVNQQUNFOlxyXG5cdFx0XHRzID0gXCJuYW1lc3BhY2VcIjtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIFN0ZXAuUEFSRU5UOlxyXG5cdFx0XHRzID0gXCJwYXJlbnRcIjtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIFN0ZXAuUFJFQ0VESU5HOlxyXG5cdFx0XHRzID0gXCJwcmVjZWRpbmdcIjtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIFN0ZXAuUFJFQ0VESU5HU0lCTElORzpcclxuXHRcdFx0cyA9IFwicHJlY2VkaW5nLXNpYmxpbmdcIjtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIFN0ZXAuU0VMRjpcclxuXHRcdFx0cyA9IFwic2VsZlwiO1xyXG5cdFx0XHRicmVhaztcclxuXHR9XHJcblx0cyArPSBcIjo6XCI7XHJcblx0cyArPSB0aGlzLm5vZGVUZXN0LnRvU3RyaW5nKCk7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByZWRpY2F0ZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHMgKz0gXCJbXCIgKyB0aGlzLnByZWRpY2F0ZXNbaV0udG9TdHJpbmcoKSArIFwiXVwiO1xyXG5cdH1cclxuXHRyZXR1cm4gcztcclxufTtcclxuXHJcblN0ZXAuQU5DRVNUT1IgPSAwO1xyXG5TdGVwLkFOQ0VTVE9ST1JTRUxGID0gMTtcclxuU3RlcC5BVFRSSUJVVEUgPSAyO1xyXG5TdGVwLkNISUxEID0gMztcclxuU3RlcC5ERVNDRU5EQU5UID0gNDtcclxuU3RlcC5ERVNDRU5EQU5UT1JTRUxGID0gNTtcclxuU3RlcC5GT0xMT1dJTkcgPSA2O1xyXG5TdGVwLkZPTExPV0lOR1NJQkxJTkcgPSA3O1xyXG5TdGVwLk5BTUVTUEFDRSA9IDg7XHJcblN0ZXAuUEFSRU5UID0gOTtcclxuU3RlcC5QUkVDRURJTkcgPSAxMDtcclxuU3RlcC5QUkVDRURJTkdTSUJMSU5HID0gMTE7XHJcblN0ZXAuU0VMRiA9IDEyO1xyXG5cclxuLy8gTm9kZVRlc3QgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5Ob2RlVGVzdC5wcm90b3R5cGUgPSBuZXcgT2JqZWN0KCk7XHJcbk5vZGVUZXN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5vZGVUZXN0O1xyXG5Ob2RlVGVzdC5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIE5vZGVUZXN0KHR5cGUsIHZhbHVlKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQodHlwZSwgdmFsdWUpO1xyXG5cdH1cclxufVxyXG5cclxuTm9kZVRlc3QucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbih0eXBlLCB2YWx1ZSkge1xyXG5cdHRoaXMudHlwZSA9IHR5cGU7XHJcblx0dGhpcy52YWx1ZSA9IHZhbHVlO1xyXG59O1xyXG5cclxuTm9kZVRlc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0c3dpdGNoICh0aGlzLnR5cGUpIHtcclxuXHRcdGNhc2UgTm9kZVRlc3QuTkFNRVRFU1RBTlk6XHJcblx0XHRcdHJldHVybiBcIipcIjtcclxuXHRcdGNhc2UgTm9kZVRlc3QuTkFNRVRFU1RQUkVGSVhBTlk6XHJcblx0XHRcdHJldHVybiB0aGlzLnZhbHVlICsgXCI6KlwiO1xyXG5cdFx0Y2FzZSBOb2RlVGVzdC5OQU1FVEVTVFJFU09MVkVEQU5ZOlxyXG5cdFx0XHRyZXR1cm4gXCJ7XCIgKyB0aGlzLnZhbHVlICsgXCJ9KlwiO1xyXG5cdFx0Y2FzZSBOb2RlVGVzdC5OQU1FVEVTVFFOQU1FOlxyXG5cdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcclxuXHRcdGNhc2UgTm9kZVRlc3QuTkFNRVRFU1RSRVNPTFZFRE5BTUU6XHJcblx0XHRcdHJldHVybiBcIntcIiArIHRoaXMubmFtZXNwYWNlVVJJICsgXCJ9XCIgKyB0aGlzLnZhbHVlO1xyXG5cdFx0Y2FzZSBOb2RlVGVzdC5DT01NRU5UOlxyXG5cdFx0XHRyZXR1cm4gXCJjb21tZW50KClcIjtcclxuXHRcdGNhc2UgTm9kZVRlc3QuVEVYVDpcclxuXHRcdFx0cmV0dXJuIFwidGV4dCgpXCI7XHJcblx0XHRjYXNlIE5vZGVUZXN0LlBJOlxyXG5cdFx0XHRpZiAodGhpcy52YWx1ZSAhPSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRyZXR1cm4gXCJwcm9jZXNzaW5nLWluc3RydWN0aW9uKFxcXCJcIiArIHRoaXMudmFsdWUgKyBcIlxcXCIpXCI7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIFwicHJvY2Vzc2luZy1pbnN0cnVjdGlvbigpXCI7XHJcblx0XHRjYXNlIE5vZGVUZXN0Lk5PREU6XHJcblx0XHRcdHJldHVybiBcIm5vZGUoKVwiO1xyXG5cdH1cclxuXHRyZXR1cm4gXCI8dW5rbm93biBub2RldGVzdCB0eXBlPlwiO1xyXG59O1xyXG5cclxuTm9kZVRlc3QucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbihuLCB4cGMpIHtcclxuXHRzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG5cdFx0Y2FzZSBOb2RlVGVzdC5OQU1FVEVTVEFOWTpcclxuXHRcdFx0aWYgKG4ubm9kZVR5cGUgPT0gMiAvKk5vZGUuQVRUUklCVVRFX05PREUqL1xyXG5cdFx0XHRcdFx0fHwgbi5ub2RlVHlwZSA9PSAxIC8qTm9kZS5FTEVNRU5UX05PREUqL1xyXG5cdFx0XHRcdFx0fHwgbi5ub2RlVHlwZSA9PSBYUGF0aE5hbWVzcGFjZS5YUEFUSF9OQU1FU1BBQ0VfTk9ERSkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdGNhc2UgTm9kZVRlc3QuTkFNRVRFU1RQUkVGSVhBTlk6XHJcblx0XHRcdGlmICgobi5ub2RlVHlwZSA9PSAyIC8qTm9kZS5BVFRSSUJVVEVfTk9ERSovIHx8IG4ubm9kZVR5cGUgPT0gMSAvKk5vZGUuRUxFTUVOVF9OT0RFKi8pKSB7XHJcblx0XHRcdFx0dmFyIG5zID0geHBjLm5hbWVzcGFjZVJlc29sdmVyLmdldE5hbWVzcGFjZSh0aGlzLnZhbHVlLCB4cGMuZXhwcmVzc2lvbkNvbnRleHROb2RlKTtcclxuXHRcdFx0XHRpZiAobnMgPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgUU5hbWUgXCIgKyB0aGlzLnZhbHVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIG5zID09IChuLm5hbWVzcGFjZVVSSSB8fCAnJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0Y2FzZSBOb2RlVGVzdC5OQU1FVEVTVFFOQU1FOlxyXG5cdFx0XHRpZiAobi5ub2RlVHlwZSA9PSAyIC8qTm9kZS5BVFRSSUJVVEVfTk9ERSovXHJcblx0XHRcdFx0XHR8fCBuLm5vZGVUeXBlID09IDEgLypOb2RlLkVMRU1FTlRfTk9ERSovXHJcblx0XHRcdFx0XHR8fCBuLm5vZGVUeXBlID09IFhQYXRoTmFtZXNwYWNlLlhQQVRIX05BTUVTUEFDRV9OT0RFKSB7XHJcblx0XHRcdFx0dmFyIHRlc3QgPSBVdGlsaXRpZXMucmVzb2x2ZVFOYW1lKHRoaXMudmFsdWUsIHhwYy5uYW1lc3BhY2VSZXNvbHZlciwgeHBjLmV4cHJlc3Npb25Db250ZXh0Tm9kZSwgZmFsc2UpO1xyXG5cdFx0XHRcdGlmICh0ZXN0WzBdID09IG51bGwpIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIFFOYW1lIFwiICsgdGhpcy52YWx1ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRlc3RbMF0gPSBTdHJpbmcodGVzdFswXSk7XHJcblx0XHRcdFx0dGVzdFsxXSA9IFN0cmluZyh0ZXN0WzFdKTtcclxuXHRcdFx0XHRpZiAodGVzdFswXSA9PSBcIlwiKSB7XHJcblx0XHRcdFx0XHR0ZXN0WzBdID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIG5vZGUgPSBbbi5uYW1lc3BhY2VVUkkgfHwgJycsIG4ubG9jYWxOYW1lXTtcclxuXHRcdFx0XHRub2RlWzBdID0gU3RyaW5nKG5vZGVbMF0pO1xyXG5cdFx0XHRcdG5vZGVbMV0gPSBTdHJpbmcobm9kZVsxXSk7XHJcblx0XHRcdFx0aWYgKG5vZGVbMF0gPT0gXCJcIikge1xyXG5cdFx0XHRcdFx0bm9kZVswXSA9IG51bGw7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICh4cGMuY2FzZUluc2Vuc2l0aXZlKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGVzdFswXSA9PSBub2RlWzBdICYmIFN0cmluZyh0ZXN0WzFdKS50b0xvd2VyQ2FzZSgpID09IFN0cmluZyhub2RlWzFdKS50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gdGVzdFswXSA9PSBub2RlWzBdICYmIHRlc3RbMV0gPT0gbm9kZVsxXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRjYXNlIE5vZGVUZXN0LkNPTU1FTlQ6XHJcblx0XHRcdHJldHVybiBuLm5vZGVUeXBlID09IDggLypOb2RlLkNPTU1FTlRfTk9ERSovO1xyXG5cdFx0Y2FzZSBOb2RlVGVzdC5URVhUOlxyXG5cdFx0XHRyZXR1cm4gbi5ub2RlVHlwZSA9PSAzIC8qTm9kZS5URVhUX05PREUqLyB8fCBuLm5vZGVUeXBlID09IDQgLypOb2RlLkNEQVRBX1NFQ1RJT05fTk9ERSovO1xyXG5cdFx0Y2FzZSBOb2RlVGVzdC5QSTpcclxuXHRcdFx0cmV0dXJuIG4ubm9kZVR5cGUgPT0gNyAvKk5vZGUuUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFKi9cclxuXHRcdFx0XHQmJiAodGhpcy52YWx1ZSA9PSBudWxsIHx8IG4ubm9kZU5hbWUgPT0gdGhpcy52YWx1ZSk7XHJcblx0XHRjYXNlIE5vZGVUZXN0Lk5PREU6XHJcblx0XHRcdHJldHVybiBuLm5vZGVUeXBlID09IDkgLypOb2RlLkRPQ1VNRU5UX05PREUqL1xyXG5cdFx0XHRcdHx8IG4ubm9kZVR5cGUgPT0gMSAvKk5vZGUuRUxFTUVOVF9OT0RFKi9cclxuXHRcdFx0XHR8fCBuLm5vZGVUeXBlID09IDIgLypOb2RlLkFUVFJJQlVURV9OT0RFKi9cclxuXHRcdFx0XHR8fCBuLm5vZGVUeXBlID09IDMgLypOb2RlLlRFWFRfTk9ERSovXHJcblx0XHRcdFx0fHwgbi5ub2RlVHlwZSA9PSA0IC8qTm9kZS5DREFUQV9TRUNUSU9OX05PREUqL1xyXG5cdFx0XHRcdHx8IG4ubm9kZVR5cGUgPT0gOCAvKk5vZGUuQ09NTUVOVF9OT0RFKi9cclxuXHRcdFx0XHR8fCBuLm5vZGVUeXBlID09IDcgLypOb2RlLlBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERSovO1xyXG5cdH1cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5Ob2RlVGVzdC5OQU1FVEVTVEFOWSA9IDA7XHJcbk5vZGVUZXN0Lk5BTUVURVNUUFJFRklYQU5ZID0gMTtcclxuTm9kZVRlc3QuTkFNRVRFU1RRTkFNRSA9IDI7XHJcbk5vZGVUZXN0LkNPTU1FTlQgPSAzO1xyXG5Ob2RlVGVzdC5URVhUID0gNDtcclxuTm9kZVRlc3QuUEkgPSA1O1xyXG5Ob2RlVGVzdC5OT0RFID0gNjtcclxuXHJcbi8vIFZhcmlhYmxlUmVmZXJlbmNlIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuVmFyaWFibGVSZWZlcmVuY2UucHJvdG90eXBlID0gbmV3IEV4cHJlc3Npb24oKTtcclxuVmFyaWFibGVSZWZlcmVuY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVmFyaWFibGVSZWZlcmVuY2U7XHJcblZhcmlhYmxlUmVmZXJlbmNlLnN1cGVyY2xhc3MgPSBFeHByZXNzaW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFZhcmlhYmxlUmVmZXJlbmNlKHYpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdCh2KTtcclxuXHR9XHJcbn1cclxuXHJcblZhcmlhYmxlUmVmZXJlbmNlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24odikge1xyXG5cdHRoaXMudmFyaWFibGUgPSB2O1xyXG59O1xyXG5cclxuVmFyaWFibGVSZWZlcmVuY2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiJFwiICsgdGhpcy52YXJpYWJsZTtcclxufTtcclxuXHJcblZhcmlhYmxlUmVmZXJlbmNlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gYy52YXJpYWJsZVJlc29sdmVyLmdldFZhcmlhYmxlKHRoaXMudmFyaWFibGUsIGMpO1xyXG59O1xyXG5cclxuLy8gRnVuY3Rpb25DYWxsIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5GdW5jdGlvbkNhbGwucHJvdG90eXBlID0gbmV3IEV4cHJlc3Npb24oKTtcclxuRnVuY3Rpb25DYWxsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZ1bmN0aW9uQ2FsbDtcclxuRnVuY3Rpb25DYWxsLnN1cGVyY2xhc3MgPSBFeHByZXNzaW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIEZ1bmN0aW9uQ2FsbChmbiwgYXJncykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGZuLCBhcmdzKTtcclxuXHR9XHJcbn1cclxuXHJcbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGZuLCBhcmdzKSB7XHJcblx0dGhpcy5mdW5jdGlvbk5hbWUgPSBmbjtcclxuXHR0aGlzLmFyZ3VtZW50cyA9IGFyZ3M7XHJcbn07XHJcblxyXG5GdW5jdGlvbkNhbGwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIHMgPSB0aGlzLmZ1bmN0aW9uTmFtZSArIFwiKFwiO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChpID4gMCkge1xyXG5cdFx0XHRzICs9IFwiLCBcIjtcclxuXHRcdH1cclxuXHRcdHMgKz0gdGhpcy5hcmd1bWVudHNbaV0udG9TdHJpbmcoKTtcclxuXHR9XHJcblx0cmV0dXJuIHMgKyBcIilcIjtcclxufTtcclxuXHJcbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0dmFyIGYgPSBjLmZ1bmN0aW9uUmVzb2x2ZXIuZ2V0RnVuY3Rpb24odGhpcy5mdW5jdGlvbk5hbWUsIGMpO1xyXG5cdGlmIChmID09IHVuZGVmaW5lZCkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBmdW5jdGlvbiBcIiArIHRoaXMuZnVuY3Rpb25OYW1lKTtcclxuXHR9XHJcblx0dmFyIGEgPSBbY10uY29uY2F0KHRoaXMuYXJndW1lbnRzKTtcclxuXHRyZXR1cm4gZi5hcHBseShjLmZ1bmN0aW9uUmVzb2x2ZXIudGhpc0FyZywgYSk7XHJcbn07XHJcblxyXG4vLyBYU3RyaW5nIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblhTdHJpbmcucHJvdG90eXBlID0gbmV3IEV4cHJlc3Npb24oKTtcclxuWFN0cmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBYU3RyaW5nO1xyXG5YU3RyaW5nLnN1cGVyY2xhc3MgPSBFeHByZXNzaW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFhTdHJpbmcocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KHMpO1xyXG5cdH1cclxufVxyXG5cclxuWFN0cmluZy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHMpIHtcclxuXHR0aGlzLnN0ciA9IHM7XHJcbn07XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLnN0cjtcclxufTtcclxuXHJcblhTdHJpbmcucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuWFN0cmluZy5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5udW1iZXIgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIodGhpcy5zdHIpO1xyXG59O1xyXG5cclxuWFN0cmluZy5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4odGhpcy5zdHIpO1xyXG59O1xyXG5cclxuWFN0cmluZy5wcm90b3R5cGUubm9kZXNldCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IHN0cmluZyB0byBub2Rlc2V0XCIpO1xyXG59O1xyXG5cclxuWFN0cmluZy5wcm90b3R5cGUuc3RyaW5nVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5zdHI7XHJcbn07XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5udW1iZXJWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLm51bWJlcigpLm51bWJlclZhbHVlKCk7XHJcbn07XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5ib29sZWFuVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5ib29sKCkuYm9vbGVhblZhbHVlKCk7XHJcbn07XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYQm9vbGVhbikpIHtcclxuXHRcdHJldHVybiB0aGlzLmJvb2woKS5lcXVhbHMocik7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE51bWJlcikpIHtcclxuXHRcdHJldHVybiB0aGlzLm51bWJlcigpLmVxdWFscyhyKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTm9kZVNldCkpIHtcclxuXHRcdHJldHVybiByLmNvbXBhcmVXaXRoU3RyaW5nKHRoaXMsIE9wZXJhdG9ycy5lcXVhbHMpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHRoaXMuc3RyID09IHIuc3RyKTtcclxufTtcclxuXHJcblhTdHJpbmcucHJvdG90eXBlLm5vdGVxdWFsID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWEJvb2xlYW4pKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5ib29sKCkubm90ZXF1YWwocik7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE51bWJlcikpIHtcclxuXHRcdHJldHVybiB0aGlzLm51bWJlcigpLm5vdGVxdWFsKHIpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhTdHJpbmcodGhpcywgT3BlcmF0b3JzLm5vdGVxdWFsKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbih0aGlzLnN0ciAhPSByLnN0cik7XHJcbn07XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5sZXNzdGhhbiA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhOdW1iZXIodGhpcy5udW1iZXIoKSwgT3BlcmF0b3JzLmdyZWF0ZXJ0aGFub3JlcXVhbCk7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLm51bWJlcigpLmxlc3N0aGFuKHIubnVtYmVyKCkpO1xyXG59O1xyXG5cclxuWFN0cmluZy5wcm90b3R5cGUuZ3JlYXRlcnRoYW4gPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTm9kZVNldCkpIHtcclxuXHRcdHJldHVybiByLmNvbXBhcmVXaXRoTnVtYmVyKHRoaXMubnVtYmVyKCksIE9wZXJhdG9ycy5sZXNzdGhhbm9yZXF1YWwpO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5udW1iZXIoKS5ncmVhdGVydGhhbihyLm51bWJlcigpKTtcclxufTtcclxuXHJcblhTdHJpbmcucHJvdG90eXBlLmxlc3N0aGFub3JlcXVhbCA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhOdW1iZXIodGhpcy5udW1iZXIoKSwgT3BlcmF0b3JzLmdyZWF0ZXJ0aGFuKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMubnVtYmVyKCkubGVzc3RoYW5vcmVxdWFsKHIubnVtYmVyKCkpO1xyXG59O1xyXG5cclxuWFN0cmluZy5wcm90b3R5cGUuZ3JlYXRlcnRoYW5vcmVxdWFsID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aE51bWJlcih0aGlzLm51bWJlcigpLCBPcGVyYXRvcnMubGVzc3RoYW4pO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5udW1iZXIoKS5ncmVhdGVydGhhbm9yZXF1YWwoci5udW1iZXIoKSk7XHJcbn07XHJcblxyXG4vLyBYTnVtYmVyIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblhOdW1iZXIucHJvdG90eXBlID0gbmV3IEV4cHJlc3Npb24oKTtcclxuWE51bWJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBYTnVtYmVyO1xyXG5YTnVtYmVyLnN1cGVyY2xhc3MgPSBFeHByZXNzaW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFhOdW1iZXIobikge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KG4pO1xyXG5cdH1cclxufVxyXG5cclxuWE51bWJlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKG4pIHtcclxuXHR0aGlzLm51bSA9IE51bWJlcihuKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMubnVtO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFhTdHJpbmcodGhpcy5udW0pO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUubnVtYmVyID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbih0aGlzLm51bSk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5ub2Rlc2V0ID0gZnVuY3Rpb24oKSB7XHJcblx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnZlcnQgbnVtYmVyIHRvIG5vZGVzZXRcIik7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5zdHJpbmdWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLnN0cmluZygpLnN0cmluZ1ZhbHVlKCk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5udW1iZXJWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLm51bTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLmJvb2xlYW5WYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmJvb2woKS5ib29sZWFuVmFsdWUoKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgWE51bWJlcigtdGhpcy5udW0pO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWEJvb2xlYW4pKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5ib29sKCkuZXF1YWxzKHIpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhTdHJpbmcpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lcXVhbHMoci5udW1iZXIoKSk7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aE51bWJlcih0aGlzLCBPcGVyYXRvcnMuZXF1YWxzKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbih0aGlzLm51bSA9PSByLm51bSk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5ub3RlcXVhbCA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhCb29sZWFuKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuYm9vbCgpLm5vdGVxdWFsKHIpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhTdHJpbmcpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5ub3RlcXVhbChyLm51bWJlcigpKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTm9kZVNldCkpIHtcclxuXHRcdHJldHVybiByLmNvbXBhcmVXaXRoTnVtYmVyKHRoaXMsIE9wZXJhdG9ycy5ub3RlcXVhbCk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4odGhpcy5udW0gIT0gci5udW0pO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUubGVzc3RoYW4gPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTm9kZVNldCkpIHtcclxuXHRcdHJldHVybiByLmNvbXBhcmVXaXRoTnVtYmVyKHRoaXMsIE9wZXJhdG9ycy5ncmVhdGVydGhhbm9yZXF1YWwpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhCb29sZWFuKSB8fCBVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWFN0cmluZykpIHtcclxuXHRcdHJldHVybiB0aGlzLmxlc3N0aGFuKHIubnVtYmVyKCkpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHRoaXMubnVtIDwgci5udW0pO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUuZ3JlYXRlcnRoYW4gPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTm9kZVNldCkpIHtcclxuXHRcdHJldHVybiByLmNvbXBhcmVXaXRoTnVtYmVyKHRoaXMsIE9wZXJhdG9ycy5sZXNzdGhhbm9yZXF1YWwpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhCb29sZWFuKSB8fCBVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWFN0cmluZykpIHtcclxuXHRcdHJldHVybiB0aGlzLmdyZWF0ZXJ0aGFuKHIubnVtYmVyKCkpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHRoaXMubnVtID4gci5udW0pO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUubGVzc3RoYW5vcmVxdWFsID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aE51bWJlcih0aGlzLCBPcGVyYXRvcnMuZ3JlYXRlcnRoYW4pO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhCb29sZWFuKSB8fCBVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWFN0cmluZykpIHtcclxuXHRcdHJldHVybiB0aGlzLmxlc3N0aGFub3JlcXVhbChyLm51bWJlcigpKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbih0aGlzLm51bSA8PSByLm51bSk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5ncmVhdGVydGhhbm9yZXF1YWwgPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTm9kZVNldCkpIHtcclxuXHRcdHJldHVybiByLmNvbXBhcmVXaXRoTnVtYmVyKHRoaXMsIE9wZXJhdG9ycy5sZXNzdGhhbik7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWEJvb2xlYW4pIHx8IFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYU3RyaW5nKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ3JlYXRlcnRoYW5vcmVxdWFsKHIubnVtYmVyKCkpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHRoaXMubnVtID49IHIubnVtKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLnBsdXMgPSBmdW5jdGlvbihyKSB7XHJcblx0cmV0dXJuIG5ldyBYTnVtYmVyKHRoaXMubnVtICsgci5udW0pO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUubWludXMgPSBmdW5jdGlvbihyKSB7XHJcblx0cmV0dXJuIG5ldyBYTnVtYmVyKHRoaXMubnVtIC0gci5udW0pO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbihyKSB7XHJcblx0cmV0dXJuIG5ldyBYTnVtYmVyKHRoaXMubnVtICogci5udW0pO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24ocikge1xyXG5cdHJldHVybiBuZXcgWE51bWJlcih0aGlzLm51bSAvIHIubnVtKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uKHIpIHtcclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIodGhpcy5udW0gJSByLm51bSk7XHJcbn07XHJcblxyXG4vLyBYQm9vbGVhbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblhCb29sZWFuLnByb3RvdHlwZSA9IG5ldyBFeHByZXNzaW9uKCk7XHJcblhCb29sZWFuLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhCb29sZWFuO1xyXG5YQm9vbGVhbi5zdXBlcmNsYXNzID0gRXhwcmVzc2lvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBYQm9vbGVhbihiKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQoYik7XHJcblx0fVxyXG59XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGIpIHtcclxuXHR0aGlzLmIgPSBCb29sZWFuKGIpO1xyXG59O1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuYi50b1N0cmluZygpO1xyXG59O1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgWFN0cmluZyh0aGlzLmIpO1xyXG59O1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLm51bWJlciA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgWE51bWJlcih0aGlzLmIpO1xyXG59O1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblhCb29sZWFuLnByb3RvdHlwZS5ub2Rlc2V0ID0gZnVuY3Rpb24oKSB7XHJcblx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnZlcnQgYm9vbGVhbiB0byBub2Rlc2V0XCIpO1xyXG59O1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLnN0cmluZ1ZhbHVlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuc3RyaW5nKCkuc3RyaW5nVmFsdWUoKTtcclxufTtcclxuXHJcblhCb29sZWFuLnByb3RvdHlwZS5udW1iZXJWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLm51bSgpLm51bWJlclZhbHVlKCk7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUuYm9vbGVhblZhbHVlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuYjtcclxufTtcclxuXHJcblhCb29sZWFuLnByb3RvdHlwZS5ub3QgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKCF0aGlzLmIpO1xyXG59O1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhTdHJpbmcpIHx8IFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTnVtYmVyKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZXF1YWxzKHIuYm9vbCgpKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTm9kZVNldCkpIHtcclxuXHRcdHJldHVybiByLmNvbXBhcmVXaXRoQm9vbGVhbih0aGlzLCBPcGVyYXRvcnMuZXF1YWxzKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbih0aGlzLmIgPT0gci5iKTtcclxufTtcclxuXHJcblhCb29sZWFuLnByb3RvdHlwZS5ub3RlcXVhbCA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhTdHJpbmcpIHx8IFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTnVtYmVyKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMubm90ZXF1YWwoci5ib29sKCkpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhCb29sZWFuKHRoaXMsIE9wZXJhdG9ycy5ub3RlcXVhbCk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4odGhpcy5iICE9IHIuYik7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUubGVzc3RoYW4gPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTm9kZVNldCkpIHtcclxuXHRcdHJldHVybiByLmNvbXBhcmVXaXRoTnVtYmVyKHRoaXMubnVtYmVyKCksIE9wZXJhdG9ycy5ncmVhdGVydGhhbm9yZXF1YWwpO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5udW1iZXIoKS5sZXNzdGhhbihyLm51bWJlcigpKTtcclxufTtcclxuXHJcblhCb29sZWFuLnByb3RvdHlwZS5ncmVhdGVydGhhbiA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhOdW1iZXIodGhpcy5udW1iZXIoKSwgT3BlcmF0b3JzLmxlc3N0aGFub3JlcXVhbCk7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLm51bWJlcigpLmdyZWF0ZXJ0aGFuKHIubnVtYmVyKCkpO1xyXG59O1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLmxlc3N0aGFub3JlcXVhbCA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhOdW1iZXIodGhpcy5udW1iZXIoKSwgT3BlcmF0b3JzLmdyZWF0ZXJ0aGFuKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMubnVtYmVyKCkubGVzc3RoYW5vcmVxdWFsKHIubnVtYmVyKCkpO1xyXG59O1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLmdyZWF0ZXJ0aGFub3JlcXVhbCA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhOdW1iZXIodGhpcy5udW1iZXIoKSwgT3BlcmF0b3JzLmxlc3N0aGFuKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMubnVtYmVyKCkuZ3JlYXRlcnRoYW5vcmVxdWFsKHIubnVtYmVyKCkpO1xyXG59O1xyXG5cclxuLy8gQVZMVHJlZSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5BVkxUcmVlLnByb3RvdHlwZSA9IG5ldyBPYmplY3QoKTtcclxuQVZMVHJlZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBVkxUcmVlO1xyXG5BVkxUcmVlLnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gQVZMVHJlZShuKSB7XHJcblx0dGhpcy5pbml0KG4pO1xyXG59XHJcblxyXG5BVkxUcmVlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obikge1xyXG5cdHRoaXMubGVmdCA9IG51bGw7XHJcbiAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcclxuXHR0aGlzLm5vZGUgPSBuO1xyXG5cdHRoaXMuZGVwdGggPSAxO1xyXG59O1xyXG5cclxuQVZMVHJlZS5wcm90b3R5cGUuYmFsYW5jZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGxkZXB0aCA9IHRoaXMubGVmdCAgPT0gbnVsbCA/IDAgOiB0aGlzLmxlZnQuZGVwdGg7XHJcbiAgICB2YXIgcmRlcHRoID0gdGhpcy5yaWdodCA9PSBudWxsID8gMCA6IHRoaXMucmlnaHQuZGVwdGg7XHJcblxyXG5cdGlmIChsZGVwdGggPiByZGVwdGggKyAxKSB7XHJcbiAgICAgICAgLy8gTFIgb3IgTEwgcm90YXRpb25cclxuICAgICAgICB2YXIgbGxkZXB0aCA9IHRoaXMubGVmdC5sZWZ0ICA9PSBudWxsID8gMCA6IHRoaXMubGVmdC5sZWZ0LmRlcHRoO1xyXG4gICAgICAgIHZhciBscmRlcHRoID0gdGhpcy5sZWZ0LnJpZ2h0ID09IG51bGwgPyAwIDogdGhpcy5sZWZ0LnJpZ2h0LmRlcHRoO1xyXG5cclxuICAgICAgICBpZiAobGxkZXB0aCA8IGxyZGVwdGgpIHtcclxuICAgICAgICAgICAgLy8gTFIgcm90YXRpb24gY29uc2lzdHMgb2YgYSBSUiByb3RhdGlvbiBvZiB0aGUgbGVmdCBjaGlsZFxyXG4gICAgICAgICAgICB0aGlzLmxlZnQucm90YXRlUlIoKTtcclxuICAgICAgICAgICAgLy8gcGx1cyBhIExMIHJvdGF0aW9uIG9mIHRoaXMgbm9kZSwgd2hpY2ggaGFwcGVucyBhbnl3YXlcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yb3RhdGVMTCgpO1xyXG4gICAgfSBlbHNlIGlmIChsZGVwdGggKyAxIDwgcmRlcHRoKSB7XHJcbiAgICAgICAgLy8gUlIgb3IgUkwgcm9yYXJpb25cclxuXHRcdHZhciBycmRlcHRoID0gdGhpcy5yaWdodC5yaWdodCA9PSBudWxsID8gMCA6IHRoaXMucmlnaHQucmlnaHQuZGVwdGg7XHJcblx0XHR2YXIgcmxkZXB0aCA9IHRoaXMucmlnaHQubGVmdCAgPT0gbnVsbCA/IDAgOiB0aGlzLnJpZ2h0LmxlZnQuZGVwdGg7XHJcblxyXG4gICAgICAgIGlmIChybGRlcHRoID4gcnJkZXB0aCkge1xyXG4gICAgICAgICAgICAvLyBSUiByb3RhdGlvbiBjb25zaXN0cyBvZiBhIExMIHJvdGF0aW9uIG9mIHRoZSByaWdodCBjaGlsZFxyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0LnJvdGF0ZUxMKCk7XHJcbiAgICAgICAgICAgIC8vIHBsdXMgYSBSUiByb3RhdGlvbiBvZiB0aGlzIG5vZGUsIHdoaWNoIGhhcHBlbnMgYW55d2F5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucm90YXRlUlIoKTtcclxuICAgIH1cclxufTtcclxuXHJcbkFWTFRyZWUucHJvdG90eXBlLnJvdGF0ZUxMID0gZnVuY3Rpb24oKSB7XHJcbiAgICAvLyB0aGUgbGVmdCBzaWRlIGlzIHRvbyBsb25nID0+IHJvdGF0ZSBmcm9tIHRoZSBsZWZ0IChfbm90XyBsZWZ0d2FyZHMpXHJcbiAgICB2YXIgbm9kZUJlZm9yZSA9IHRoaXMubm9kZTtcclxuICAgIHZhciByaWdodEJlZm9yZSA9IHRoaXMucmlnaHQ7XHJcbiAgICB0aGlzLm5vZGUgPSB0aGlzLmxlZnQubm9kZTtcclxuICAgIHRoaXMucmlnaHQgPSB0aGlzLmxlZnQ7XHJcbiAgICB0aGlzLmxlZnQgPSB0aGlzLmxlZnQubGVmdDtcclxuICAgIHRoaXMucmlnaHQubGVmdCA9IHRoaXMucmlnaHQucmlnaHQ7XHJcbiAgICB0aGlzLnJpZ2h0LnJpZ2h0ID0gcmlnaHRCZWZvcmU7XHJcbiAgICB0aGlzLnJpZ2h0Lm5vZGUgPSBub2RlQmVmb3JlO1xyXG4gICAgdGhpcy5yaWdodC51cGRhdGVJbk5ld0xvY2F0aW9uKCk7XHJcbiAgICB0aGlzLnVwZGF0ZUluTmV3TG9jYXRpb24oKTtcclxufTtcclxuXHJcbkFWTFRyZWUucHJvdG90eXBlLnJvdGF0ZVJSID0gZnVuY3Rpb24oKSB7XHJcbiAgICAvLyB0aGUgcmlnaHQgc2lkZSBpcyB0b28gbG9uZyA9PiByb3RhdGUgZnJvbSB0aGUgcmlnaHQgKF9ub3RfIHJpZ2h0d2FyZHMpXHJcbiAgICB2YXIgbm9kZUJlZm9yZSA9IHRoaXMubm9kZTtcclxuICAgIHZhciBsZWZ0QmVmb3JlID0gdGhpcy5sZWZ0O1xyXG4gICAgdGhpcy5ub2RlID0gdGhpcy5yaWdodC5ub2RlO1xyXG4gICAgdGhpcy5sZWZ0ID0gdGhpcy5yaWdodDtcclxuICAgIHRoaXMucmlnaHQgPSB0aGlzLnJpZ2h0LnJpZ2h0O1xyXG4gICAgdGhpcy5sZWZ0LnJpZ2h0ID0gdGhpcy5sZWZ0LmxlZnQ7XHJcbiAgICB0aGlzLmxlZnQubGVmdCA9IGxlZnRCZWZvcmU7XHJcbiAgICB0aGlzLmxlZnQubm9kZSA9IG5vZGVCZWZvcmU7XHJcbiAgICB0aGlzLmxlZnQudXBkYXRlSW5OZXdMb2NhdGlvbigpO1xyXG4gICAgdGhpcy51cGRhdGVJbk5ld0xvY2F0aW9uKCk7XHJcbn07XHJcblxyXG5BVkxUcmVlLnByb3RvdHlwZS51cGRhdGVJbk5ld0xvY2F0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmdldERlcHRoRnJvbUNoaWxkcmVuKCk7XHJcbn07XHJcblxyXG5BVkxUcmVlLnByb3RvdHlwZS5nZXREZXB0aEZyb21DaGlsZHJlbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5kZXB0aCA9IHRoaXMubm9kZSA9PSBudWxsID8gMCA6IDE7XHJcbiAgICBpZiAodGhpcy5sZWZ0ICE9IG51bGwpIHtcclxuICAgICAgICB0aGlzLmRlcHRoID0gdGhpcy5sZWZ0LmRlcHRoICsgMTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnJpZ2h0ICE9IG51bGwgJiYgdGhpcy5kZXB0aCA8PSB0aGlzLnJpZ2h0LmRlcHRoKSB7XHJcbiAgICAgICAgdGhpcy5kZXB0aCA9IHRoaXMucmlnaHQuZGVwdGggKyAxO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQVZMVHJlZS5wcm90b3R5cGUub3JkZXIgPSBmdW5jdGlvbihuMSwgbjIpIHtcclxuXHRpZiAobjEgPT09IG4yKSB7XHJcblx0XHRyZXR1cm4gMDtcclxuXHR9XHJcblx0dmFyIGQxID0gMDtcclxuXHR2YXIgZDIgPSAwO1xyXG5cdGZvciAodmFyIG0xID0gbjE7IG0xICE9IG51bGw7IG0xID0gbTEucGFyZW50Tm9kZSkge1xyXG5cdFx0ZDErKztcclxuXHR9XHJcblx0Zm9yICh2YXIgbTIgPSBuMjsgbTIgIT0gbnVsbDsgbTIgPSBtMi5wYXJlbnROb2RlKSB7XHJcblx0XHRkMisrO1xyXG5cdH1cclxuXHRpZiAoZDEgPiBkMikge1xyXG5cdFx0d2hpbGUgKGQxID4gZDIpIHtcclxuXHRcdFx0bjEgPSBuMS5wYXJlbnROb2RlO1xyXG5cdFx0XHRkMS0tO1xyXG5cdFx0fVxyXG5cdFx0aWYgKG4xID09IG4yKSB7XHJcblx0XHRcdHJldHVybiAxO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAoZDIgPiBkMSkge1xyXG5cdFx0d2hpbGUgKGQyID4gZDEpIHtcclxuXHRcdFx0bjIgPSBuMi5wYXJlbnROb2RlO1xyXG5cdFx0XHRkMi0tO1xyXG5cdFx0fVxyXG5cdFx0aWYgKG4xID09IG4yKSB7XHJcblx0XHRcdHJldHVybiAtMTtcclxuXHRcdH1cclxuXHR9XHJcblx0d2hpbGUgKG4xLnBhcmVudE5vZGUgIT0gbjIucGFyZW50Tm9kZSkge1xyXG5cdFx0bjEgPSBuMS5wYXJlbnROb2RlO1xyXG5cdFx0bjIgPSBuMi5wYXJlbnROb2RlO1xyXG5cdH1cclxuXHR3aGlsZSAobjEucHJldmlvdXNTaWJsaW5nICE9IG51bGwgJiYgbjIucHJldmlvdXNTaWJsaW5nICE9IG51bGwpIHtcclxuXHRcdG4xID0gbjEucHJldmlvdXNTaWJsaW5nO1xyXG5cdFx0bjIgPSBuMi5wcmV2aW91c1NpYmxpbmc7XHJcblx0fVxyXG5cdGlmIChuMS5wcmV2aW91c1NpYmxpbmcgPT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIC0xO1xyXG5cdH1cclxuXHRyZXR1cm4gMTtcclxufTtcclxuXHJcbkFWTFRyZWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG4pICB7XHJcblx0aWYgKG4gPT09IHRoaXMubm9kZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcblx0dmFyIG8gPSB0aGlzLm9yZGVyKG4sIHRoaXMubm9kZSk7XHJcblxyXG4gICAgdmFyIHJldCA9IGZhbHNlO1xyXG4gICAgaWYgKG8gPT0gLTEpIHtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbmV3IEFWTFRyZWUobik7XHJcbiAgICAgICAgICAgIHJldCA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0ID0gdGhpcy5sZWZ0LmFkZChuKTtcclxuICAgICAgICAgICAgaWYgKHJldCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iYWxhbmNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG8gPT0gMSkge1xyXG4gICAgICAgIGlmICh0aGlzLnJpZ2h0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5yaWdodCA9IG5ldyBBVkxUcmVlKG4pO1xyXG4gICAgICAgICAgICByZXQgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldCA9IHRoaXMucmlnaHQuYWRkKG4pO1xyXG4gICAgICAgICAgICBpZiAocmV0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhbGFuY2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAocmV0KSB7XHJcbiAgICAgICAgdGhpcy5nZXREZXB0aEZyb21DaGlsZHJlbigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufTtcclxuXHJcbi8vIFhOb2RlU2V0IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlID0gbmV3IEV4cHJlc3Npb24oKTtcclxuWE5vZGVTZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWE5vZGVTZXQ7XHJcblhOb2RlU2V0LnN1cGVyY2xhc3MgPSBFeHByZXNzaW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFhOb2RlU2V0KCkge1xyXG5cdHRoaXMuaW5pdCgpO1xyXG59XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMudHJlZSA9IG51bGw7XHJcblx0dGhpcy5zaXplID0gMDtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBwID0gdGhpcy5maXJzdCgpO1xyXG5cdGlmIChwID09IG51bGwpIHtcclxuXHRcdHJldHVybiBcIlwiO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5zdHJpbmdGb3JOb2RlKHApO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgWFN0cmluZyh0aGlzLnRvU3RyaW5nKCkpO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLnN0cmluZ1ZhbHVlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5udW1iZXIgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIodGhpcy5zdHJpbmcoKSk7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUubnVtYmVyVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gTnVtYmVyKHRoaXMuc3RyaW5nKCkpO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHRoaXMudHJlZSAhPSBudWxsKTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5ib29sZWFuVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy50cmVlICE9IG51bGw7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUubm9kZXNldCA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLnN0cmluZ0Zvck5vZGUgPSBmdW5jdGlvbihuKSB7XHJcblx0aWYgKG4ubm9kZVR5cGUgPT0gOSAvKk5vZGUuRE9DVU1FTlRfTk9ERSovKSB7XHJcblx0XHRuID0gbi5kb2N1bWVudEVsZW1lbnQ7XHJcblx0fVxyXG5cdGlmIChuLm5vZGVUeXBlID09IDEgLypOb2RlLkVMRU1FTlRfTk9ERSovKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdHJpbmdGb3JOb2RlUmVjKG4pO1xyXG5cdH1cclxuXHRpZiAobi5pc05hbWVzcGFjZU5vZGUpIHtcclxuXHRcdHJldHVybiBuLm5hbWVzcGFjZTtcclxuXHR9XHJcblx0cmV0dXJuIG4ubm9kZVZhbHVlO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLnN0cmluZ0Zvck5vZGVSZWMgPSBmdW5jdGlvbihuKSB7XHJcblx0dmFyIHMgPSBcIlwiO1xyXG5cdGZvciAodmFyIG4yID0gbi5maXJzdENoaWxkOyBuMiAhPSBudWxsOyBuMiA9IG4yLm5leHRTaWJsaW5nKSB7XHJcblx0XHRpZiAobjIubm9kZVR5cGUgPT0gMyAvKk5vZGUuVEVYVF9OT0RFKi8pIHtcclxuXHRcdFx0cyArPSBuMi5ub2RlVmFsdWU7XHJcblx0XHR9IGVsc2UgaWYgKG4yLm5vZGVUeXBlID09IDEgLypOb2RlLkVMRU1FTlRfTk9ERSovKSB7XHJcblx0XHRcdHMgKz0gdGhpcy5zdHJpbmdGb3JOb2RlUmVjKG4yKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHM7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgcCA9IHRoaXMudHJlZTtcclxuXHRpZiAocCA9PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0d2hpbGUgKHAubGVmdCAhPSBudWxsKSB7XHJcblx0XHRwID0gcC5sZWZ0O1xyXG5cdH1cclxuXHRyZXR1cm4gcC5ub2RlO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG4pIHtcclxuICAgIHZhciBhZGRlZDtcclxuICAgIGlmICh0aGlzLnRyZWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMudHJlZSA9IG5ldyBBVkxUcmVlKG4pO1xyXG4gICAgICAgIGFkZGVkID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWRkZWQgPSB0aGlzLnRyZWUuYWRkKG4pO1xyXG4gICAgfVxyXG4gICAgaWYgKGFkZGVkKSB7XHJcbiAgICAgICAgdGhpcy5zaXplKys7XHJcbiAgICB9XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuYWRkQXJyYXkgPSBmdW5jdGlvbihucykge1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHRoaXMuYWRkKG5zW2ldKTtcclxuXHR9XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBhID0gW107XHJcblx0dGhpcy50b0FycmF5UmVjKHRoaXMudHJlZSwgYSk7XHJcblx0cmV0dXJuIGE7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUudG9BcnJheVJlYyA9IGZ1bmN0aW9uKHQsIGEpIHtcclxuXHRpZiAodCAhPSBudWxsKSB7XHJcblx0XHR0aGlzLnRvQXJyYXlSZWModC5sZWZ0LCBhKTtcclxuXHRcdGEucHVzaCh0Lm5vZGUpO1xyXG5cdFx0dGhpcy50b0FycmF5UmVjKHQucmlnaHQsIGEpO1xyXG5cdH1cclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5jb21wYXJlV2l0aFN0cmluZyA9IGZ1bmN0aW9uKHIsIG8pIHtcclxuXHR2YXIgYSA9IHRoaXMudG9BcnJheSgpO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIG4gPSBhW2ldO1xyXG5cdFx0dmFyIGwgPSBuZXcgWFN0cmluZyh0aGlzLnN0cmluZ0Zvck5vZGUobikpO1xyXG5cdFx0dmFyIHJlcyA9IG8obCwgcik7XHJcblx0XHRpZiAocmVzLmJvb2xlYW5WYWx1ZSgpKSB7XHJcblx0XHRcdHJldHVybiByZXM7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4oZmFsc2UpO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLmNvbXBhcmVXaXRoTnVtYmVyID0gZnVuY3Rpb24ociwgbykge1xyXG5cdHZhciBhID0gdGhpcy50b0FycmF5KCk7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgbiA9IGFbaV07XHJcblx0XHR2YXIgbCA9IG5ldyBYTnVtYmVyKHRoaXMuc3RyaW5nRm9yTm9kZShuKSk7XHJcblx0XHR2YXIgcmVzID0gbyhsLCByKTtcclxuXHRcdGlmIChyZXMuYm9vbGVhblZhbHVlKCkpIHtcclxuXHRcdFx0cmV0dXJuIHJlcztcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbihmYWxzZSk7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuY29tcGFyZVdpdGhCb29sZWFuID0gZnVuY3Rpb24ociwgbykge1xyXG5cdHJldHVybiBvKHRoaXMuYm9vbCgpLCByKTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5jb21wYXJlV2l0aE5vZGVTZXQgPSBmdW5jdGlvbihyLCBvKSB7XHJcblx0dmFyIGEgPSB0aGlzLnRvQXJyYXkoKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBuID0gYVtpXTtcclxuXHRcdHZhciBsID0gbmV3IFhTdHJpbmcodGhpcy5zdHJpbmdGb3JOb2RlKG4pKTtcclxuXHRcdHZhciBiID0gci50b0FycmF5KCk7XHJcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGIubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0dmFyIG4yID0gYltqXTtcclxuXHRcdFx0dmFyIHIgPSBuZXcgWFN0cmluZyh0aGlzLnN0cmluZ0Zvck5vZGUobjIpKTtcclxuXHRcdFx0dmFyIHJlcyA9IG8obCwgcik7XHJcblx0XHRcdGlmIChyZXMuYm9vbGVhblZhbHVlKCkpIHtcclxuXHRcdFx0XHRyZXR1cm4gcmVzO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4oZmFsc2UpO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhTdHJpbmcpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aFN0cmluZyhyLCBPcGVyYXRvcnMuZXF1YWxzKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTnVtYmVyKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOdW1iZXIociwgT3BlcmF0b3JzLmVxdWFscyk7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWEJvb2xlYW4pKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aEJvb2xlYW4ociwgT3BlcmF0b3JzLmVxdWFscyk7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoTm9kZVNldChyLCBPcGVyYXRvcnMuZXF1YWxzKTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5ub3RlcXVhbCA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhTdHJpbmcpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aFN0cmluZyhyLCBPcGVyYXRvcnMubm90ZXF1YWwpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOdW1iZXIpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE51bWJlcihyLCBPcGVyYXRvcnMubm90ZXF1YWwpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhCb29sZWFuKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhCb29sZWFuKHIsIE9wZXJhdG9ycy5ub3RlcXVhbCk7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoTm9kZVNldChyLCBPcGVyYXRvcnMubm90ZXF1YWwpO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLmxlc3N0aGFuID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWFN0cmluZykpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoTnVtYmVyKHIubnVtYmVyKCksIE9wZXJhdG9ycy5sZXNzdGhhbik7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE51bWJlcikpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoTnVtYmVyKHIsIE9wZXJhdG9ycy5sZXNzdGhhbik7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWEJvb2xlYW4pKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aEJvb2xlYW4ociwgT3BlcmF0b3JzLmxlc3N0aGFuKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOb2RlU2V0KHIsIE9wZXJhdG9ycy5sZXNzdGhhbik7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuZ3JlYXRlcnRoYW4gPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYU3RyaW5nKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOdW1iZXIoci5udW1iZXIoKSwgT3BlcmF0b3JzLmdyZWF0ZXJ0aGFuKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTnVtYmVyKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOdW1iZXIociwgT3BlcmF0b3JzLmdyZWF0ZXJ0aGFuKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYQm9vbGVhbikpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoQm9vbGVhbihyLCBPcGVyYXRvcnMuZ3JlYXRlcnRoYW4pO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE5vZGVTZXQociwgT3BlcmF0b3JzLmdyZWF0ZXJ0aGFuKTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5sZXNzdGhhbm9yZXF1YWwgPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYU3RyaW5nKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOdW1iZXIoci5udW1iZXIoKSwgT3BlcmF0b3JzLmxlc3N0aGFub3JlcXVhbCk7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE51bWJlcikpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoTnVtYmVyKHIsIE9wZXJhdG9ycy5sZXNzdGhhbm9yZXF1YWwpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhCb29sZWFuKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhCb29sZWFuKHIsIE9wZXJhdG9ycy5sZXNzdGhhbm9yZXF1YWwpO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE5vZGVTZXQociwgT3BlcmF0b3JzLmxlc3N0aGFub3JlcXVhbCk7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuZ3JlYXRlcnRoYW5vcmVxdWFsID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWFN0cmluZykpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoTnVtYmVyKHIubnVtYmVyKCksIE9wZXJhdG9ycy5ncmVhdGVydGhhbm9yZXF1YWwpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOdW1iZXIpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE51bWJlcihyLCBPcGVyYXRvcnMuZ3JlYXRlcnRoYW5vcmVxdWFsKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYQm9vbGVhbikpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoQm9vbGVhbihyLCBPcGVyYXRvcnMuZ3JlYXRlcnRoYW5vcmVxdWFsKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOb2RlU2V0KHIsIE9wZXJhdG9ycy5ncmVhdGVydGhhbm9yZXF1YWwpO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLnVuaW9uID0gZnVuY3Rpb24ocikge1xyXG5cdHZhciBucyA9IG5ldyBYTm9kZVNldCgpO1xyXG5cdG5zLnRyZWUgPSB0aGlzLnRyZWU7XHJcblx0bnMuc2l6ZSA9IHRoaXMuc2l6ZTtcclxuXHRucy5hZGRBcnJheShyLnRvQXJyYXkoKSk7XHJcblx0cmV0dXJuIG5zO1xyXG59O1xyXG5cclxuLy8gWFBhdGhOYW1lc3BhY2UgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5YUGF0aE5hbWVzcGFjZS5wcm90b3R5cGUgPSBuZXcgT2JqZWN0KCk7XHJcblhQYXRoTmFtZXNwYWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhQYXRoTmFtZXNwYWNlO1xyXG5YUGF0aE5hbWVzcGFjZS5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFhQYXRoTmFtZXNwYWNlKHByZSwgbnMsIHApIHtcclxuXHR0aGlzLmlzWFBhdGhOYW1lc3BhY2UgPSB0cnVlO1xyXG5cdHRoaXMub3duZXJEb2N1bWVudCA9IHAub3duZXJEb2N1bWVudDtcclxuXHR0aGlzLm5vZGVOYW1lID0gXCIjbmFtZXNwYWNlXCI7XHJcblx0dGhpcy5wcmVmaXggPSBwcmU7XHJcblx0dGhpcy5sb2NhbE5hbWUgPSBwcmU7XHJcblx0dGhpcy5uYW1lc3BhY2VVUkkgPSBucztcclxuXHR0aGlzLm5vZGVWYWx1ZSA9IG5zO1xyXG5cdHRoaXMub3duZXJFbGVtZW50ID0gcDtcclxuXHR0aGlzLm5vZGVUeXBlID0gWFBhdGhOYW1lc3BhY2UuWFBBVEhfTkFNRVNQQUNFX05PREU7XHJcbn1cclxuXHJcblhQYXRoTmFtZXNwYWNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcInsgXFxcIlwiICsgdGhpcy5wcmVmaXggKyBcIlxcXCIsIFxcXCJcIiArIHRoaXMubmFtZXNwYWNlVVJJICsgXCJcXFwiIH1cIjtcclxufTtcclxuXHJcbi8vIE9wZXJhdG9ycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxudmFyIE9wZXJhdG9ycyA9IG5ldyBPYmplY3QoKTtcclxuXHJcbk9wZXJhdG9ycy5lcXVhbHMgPSBmdW5jdGlvbihsLCByKSB7XHJcblx0cmV0dXJuIGwuZXF1YWxzKHIpO1xyXG59O1xyXG5cclxuT3BlcmF0b3JzLm5vdGVxdWFsID0gZnVuY3Rpb24obCwgcikge1xyXG5cdHJldHVybiBsLm5vdGVxdWFsKHIpO1xyXG59O1xyXG5cclxuT3BlcmF0b3JzLmxlc3N0aGFuID0gZnVuY3Rpb24obCwgcikge1xyXG5cdHJldHVybiBsLmxlc3N0aGFuKHIpO1xyXG59O1xyXG5cclxuT3BlcmF0b3JzLmdyZWF0ZXJ0aGFuID0gZnVuY3Rpb24obCwgcikge1xyXG5cdHJldHVybiBsLmdyZWF0ZXJ0aGFuKHIpO1xyXG59O1xyXG5cclxuT3BlcmF0b3JzLmxlc3N0aGFub3JlcXVhbCA9IGZ1bmN0aW9uKGwsIHIpIHtcclxuXHRyZXR1cm4gbC5sZXNzdGhhbm9yZXF1YWwocik7XHJcbn07XHJcblxyXG5PcGVyYXRvcnMuZ3JlYXRlcnRoYW5vcmVxdWFsID0gZnVuY3Rpb24obCwgcikge1xyXG5cdHJldHVybiBsLmdyZWF0ZXJ0aGFub3JlcXVhbChyKTtcclxufTtcclxuXHJcbi8vIFhQYXRoQ29udGV4dCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuWFBhdGhDb250ZXh0LnByb3RvdHlwZSA9IG5ldyBPYmplY3QoKTtcclxuWFBhdGhDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhQYXRoQ29udGV4dDtcclxuWFBhdGhDb250ZXh0LnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gWFBhdGhDb250ZXh0KHZyLCBuciwgZnIpIHtcclxuXHR0aGlzLnZhcmlhYmxlUmVzb2x2ZXIgPSB2ciAhPSBudWxsID8gdnIgOiBuZXcgVmFyaWFibGVSZXNvbHZlcigpO1xyXG5cdHRoaXMubmFtZXNwYWNlUmVzb2x2ZXIgPSBuciAhPSBudWxsID8gbnIgOiBuZXcgTmFtZXNwYWNlUmVzb2x2ZXIoKTtcclxuXHR0aGlzLmZ1bmN0aW9uUmVzb2x2ZXIgPSBmciAhPSBudWxsID8gZnIgOiBuZXcgRnVuY3Rpb25SZXNvbHZlcigpO1xyXG59XHJcblxyXG4vLyBWYXJpYWJsZVJlc29sdmVyIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblZhcmlhYmxlUmVzb2x2ZXIucHJvdG90eXBlID0gbmV3IE9iamVjdCgpO1xyXG5WYXJpYWJsZVJlc29sdmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFZhcmlhYmxlUmVzb2x2ZXI7XHJcblZhcmlhYmxlUmVzb2x2ZXIuc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBWYXJpYWJsZVJlc29sdmVyKCkge1xyXG59XHJcblxyXG5WYXJpYWJsZVJlc29sdmVyLnByb3RvdHlwZS5nZXRWYXJpYWJsZSA9IGZ1bmN0aW9uKHZuLCBjKSB7XHJcblx0dmFyIHBhcnRzID0gVXRpbGl0aWVzLnNwbGl0UU5hbWUodm4pO1xyXG5cdGlmIChwYXJ0c1swXSAhPSBudWxsKSB7XHJcblx0XHRwYXJ0c1swXSA9IGMubmFtZXNwYWNlUmVzb2x2ZXIuZ2V0TmFtZXNwYWNlKHBhcnRzWzBdLCBjLmV4cHJlc3Npb25Db250ZXh0Tm9kZSk7XHJcbiAgICAgICAgaWYgKHBhcnRzWzBdID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgUU5hbWUgXCIgKyBmbik7XHJcbiAgICAgICAgfVxyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5nZXRWYXJpYWJsZVdpdGhOYW1lKHBhcnRzWzBdLCBwYXJ0c1sxXSwgYy5leHByZXNzaW9uQ29udGV4dE5vZGUpO1xyXG59O1xyXG5cclxuVmFyaWFibGVSZXNvbHZlci5wcm90b3R5cGUuZ2V0VmFyaWFibGVXaXRoTmFtZSA9IGZ1bmN0aW9uKG5zLCBsbiwgYykge1xyXG5cdHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuLy8gRnVuY3Rpb25SZXNvbHZlciAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5GdW5jdGlvblJlc29sdmVyLnByb3RvdHlwZSA9IG5ldyBPYmplY3QoKTtcclxuRnVuY3Rpb25SZXNvbHZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGdW5jdGlvblJlc29sdmVyO1xyXG5GdW5jdGlvblJlc29sdmVyLnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gRnVuY3Rpb25SZXNvbHZlcih0aGlzQXJnKSB7XHJcblx0dGhpcy50aGlzQXJnID0gdGhpc0FyZyAhPSBudWxsID8gdGhpc0FyZyA6IEZ1bmN0aW9ucztcclxuXHR0aGlzLmZ1bmN0aW9ucyA9IG5ldyBPYmplY3QoKTtcclxuXHR0aGlzLmFkZFN0YW5kYXJkRnVuY3Rpb25zKCk7XHJcbn1cclxuXHJcbkZ1bmN0aW9uUmVzb2x2ZXIucHJvdG90eXBlLmFkZFN0YW5kYXJkRnVuY3Rpb25zID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fWxhc3RcIl0gPSBGdW5jdGlvbnMubGFzdDtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9cG9zaXRpb25cIl0gPSBGdW5jdGlvbnMucG9zaXRpb247XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fWNvdW50XCJdID0gRnVuY3Rpb25zLmNvdW50O1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31pZFwiXSA9IEZ1bmN0aW9ucy5pZDtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9bG9jYWwtbmFtZVwiXSA9IEZ1bmN0aW9ucy5sb2NhbE5hbWU7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fW5hbWVzcGFjZS11cmlcIl0gPSBGdW5jdGlvbnMubmFtZXNwYWNlVVJJO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31uYW1lXCJdID0gRnVuY3Rpb25zLm5hbWU7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fXN0cmluZ1wiXSA9IEZ1bmN0aW9ucy5zdHJpbmc7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fWNvbmNhdFwiXSA9IEZ1bmN0aW9ucy5jb25jYXQ7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fXN0YXJ0cy13aXRoXCJdID0gRnVuY3Rpb25zLnN0YXJ0c1dpdGg7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fWNvbnRhaW5zXCJdID0gRnVuY3Rpb25zLmNvbnRhaW5zO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31zdWJzdHJpbmctYmVmb3JlXCJdID0gRnVuY3Rpb25zLnN1YnN0cmluZ0JlZm9yZTtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9c3Vic3RyaW5nLWFmdGVyXCJdID0gRnVuY3Rpb25zLnN1YnN0cmluZ0FmdGVyO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31zdWJzdHJpbmdcIl0gPSBGdW5jdGlvbnMuc3Vic3RyaW5nO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31zdHJpbmctbGVuZ3RoXCJdID0gRnVuY3Rpb25zLnN0cmluZ0xlbmd0aDtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9bm9ybWFsaXplLXNwYWNlXCJdID0gRnVuY3Rpb25zLm5vcm1hbGl6ZVNwYWNlO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie310cmFuc2xhdGVcIl0gPSBGdW5jdGlvbnMudHJhbnNsYXRlO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31ib29sZWFuXCJdID0gRnVuY3Rpb25zLmJvb2xlYW5fO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31ub3RcIl0gPSBGdW5jdGlvbnMubm90O1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie310cnVlXCJdID0gRnVuY3Rpb25zLnRydWVfO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31mYWxzZVwiXSA9IEZ1bmN0aW9ucy5mYWxzZV87XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fWxhbmdcIl0gPSBGdW5jdGlvbnMubGFuZztcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9bnVtYmVyXCJdID0gRnVuY3Rpb25zLm51bWJlcjtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9c3VtXCJdID0gRnVuY3Rpb25zLnN1bTtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9Zmxvb3JcIl0gPSBGdW5jdGlvbnMuZmxvb3I7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fWNlaWxpbmdcIl0gPSBGdW5jdGlvbnMuY2VpbGluZztcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9cm91bmRcIl0gPSBGdW5jdGlvbnMucm91bmQ7XHJcbn07XHJcblxyXG5GdW5jdGlvblJlc29sdmVyLnByb3RvdHlwZS5hZGRGdW5jdGlvbiA9IGZ1bmN0aW9uKG5zLCBsbiwgZikge1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie1wiICsgbnMgKyBcIn1cIiArIGxuXSA9IGY7XHJcbn07XHJcblxyXG5GdW5jdGlvblJlc29sdmVyLnByb3RvdHlwZS5nZXRGdW5jdGlvbiA9IGZ1bmN0aW9uKGZuLCBjKSB7XHJcblx0dmFyIHBhcnRzID0gVXRpbGl0aWVzLnJlc29sdmVRTmFtZShmbiwgYy5uYW1lc3BhY2VSZXNvbHZlciwgYy5jb250ZXh0Tm9kZSwgZmFsc2UpO1xyXG4gICAgaWYgKHBhcnRzWzBdID09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBRTmFtZSBcIiArIGZuKTtcclxuICAgIH1cclxuXHRyZXR1cm4gdGhpcy5nZXRGdW5jdGlvbldpdGhOYW1lKHBhcnRzWzBdLCBwYXJ0c1sxXSwgYy5jb250ZXh0Tm9kZSk7XHJcbn07XHJcblxyXG5GdW5jdGlvblJlc29sdmVyLnByb3RvdHlwZS5nZXRGdW5jdGlvbldpdGhOYW1lID0gZnVuY3Rpb24obnMsIGxuLCBjKSB7XHJcblx0cmV0dXJuIHRoaXMuZnVuY3Rpb25zW1wie1wiICsgbnMgKyBcIn1cIiArIGxuXTtcclxufTtcclxuXHJcbi8vIE5hbWVzcGFjZVJlc29sdmVyIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuTmFtZXNwYWNlUmVzb2x2ZXIucHJvdG90eXBlID0gbmV3IE9iamVjdCgpO1xyXG5OYW1lc3BhY2VSZXNvbHZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOYW1lc3BhY2VSZXNvbHZlcjtcclxuTmFtZXNwYWNlUmVzb2x2ZXIuc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBOYW1lc3BhY2VSZXNvbHZlcigpIHtcclxufVxyXG5cclxuTmFtZXNwYWNlUmVzb2x2ZXIucHJvdG90eXBlLmdldE5hbWVzcGFjZSA9IGZ1bmN0aW9uKHByZWZpeCwgbikge1xyXG5cdGlmIChwcmVmaXggPT0gXCJ4bWxcIikge1xyXG5cdFx0cmV0dXJuIFhQYXRoLlhNTF9OQU1FU1BBQ0VfVVJJO1xyXG5cdH0gZWxzZSBpZiAocHJlZml4ID09IFwieG1sbnNcIikge1xyXG5cdFx0cmV0dXJuIFhQYXRoLlhNTE5TX05BTUVTUEFDRV9VUkk7XHJcblx0fVxyXG5cdGlmIChuLm5vZGVUeXBlID09IDkgLypOb2RlLkRPQ1VNRU5UX05PREUqLykge1xyXG5cdFx0biA9IG4uZG9jdW1lbnRFbGVtZW50O1xyXG5cdH0gZWxzZSBpZiAobi5ub2RlVHlwZSA9PSAyIC8qTm9kZS5BVFRSSUJVVEVfTk9ERSovKSB7XHJcblx0XHRuID0gUGF0aEV4cHIucHJvdG90eXBlLmdldE93bmVyRWxlbWVudChuKTtcclxuXHR9IGVsc2UgaWYgKG4ubm9kZVR5cGUgIT0gMSAvKk5vZGUuRUxFTUVOVF9OT0RFKi8pIHtcclxuXHRcdG4gPSBuLnBhcmVudE5vZGU7XHJcblx0fVxyXG5cdHdoaWxlIChuICE9IG51bGwgJiYgbi5ub2RlVHlwZSA9PSAxIC8qTm9kZS5FTEVNRU5UX05PREUqLykge1xyXG5cdFx0dmFyIG5ubSA9IG4uYXR0cmlidXRlcztcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbm5tLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBhID0gbm5tLml0ZW0oaSk7XHJcblx0XHRcdHZhciBhbmFtZSA9IGEubm9kZU5hbWU7XHJcblx0XHRcdGlmIChhbmFtZSA9PSBcInhtbG5zXCIgJiYgcHJlZml4ID09IFwiXCJcclxuXHRcdFx0XHRcdHx8IGFuYW1lID09IFwieG1sbnM6XCIgKyBwcmVmaXgpIHtcclxuXHRcdFx0XHRyZXR1cm4gU3RyaW5nKGEubm9kZVZhbHVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0biA9IG4ucGFyZW50Tm9kZTtcclxuXHR9XHJcblx0cmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG4vLyBGdW5jdGlvbnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbkZ1bmN0aW9ucyA9IG5ldyBPYmplY3QoKTtcclxuXHJcbkZ1bmN0aW9ucy5sYXN0ID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gbGFzdCBleHBlY3RzICgpXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIoYy5jb250ZXh0U2l6ZSk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMucG9zaXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAxKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBwb3NpdGlvbiBleHBlY3RzICgpXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIoYy5jb250ZXh0UG9zaXRpb24pO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLmNvdW50ID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0dmFyIG5zO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIgfHwgIVV0aWxpdGllcy5pbnN0YW5jZV9vZihucyA9IGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKSwgWE5vZGVTZXQpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBjb3VudCBleHBlY3RzIChub2RlLXNldClcIik7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWE51bWJlcihucy5zaXplKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5pZCA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdHZhciBpZDtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBpZCBleHBlY3RzIChvYmplY3QpXCIpO1xyXG5cdH1cclxuXHRpZCA9IGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKTtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKGlkLCBYTm9kZVNldCkpIHtcclxuXHRcdGlkID0gaWQudG9BcnJheSgpLmpvaW4oXCIgXCIpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRpZCA9IGlkLnN0cmluZ1ZhbHVlKCk7XHJcblx0fVxyXG5cdHZhciBpZHMgPSBpZC5zcGxpdCgvW1xceDBkXFx4MGFcXHgwOVxceDIwXSsvKTtcclxuXHR2YXIgY291bnQgPSAwO1xyXG5cdHZhciBucyA9IG5ldyBYTm9kZVNldCgpO1xyXG5cdHZhciBkb2MgPSBjLmNvbnRleHROb2RlLm5vZGVUeXBlID09IDkgLypOb2RlLkRPQ1VNRU5UX05PREUqL1xyXG5cdFx0XHQ/IGMuY29udGV4dE5vZGVcclxuXHRcdFx0OiBjLmNvbnRleHROb2RlLm93bmVyRG9jdW1lbnQ7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBuO1xyXG5cdFx0aWYgKGRvYy5nZXRFbGVtZW50QnlJZCkge1xyXG5cdFx0XHRuID0gZG9jLmdldEVsZW1lbnRCeUlkKGlkc1tpXSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRuID0gVXRpbGl0aWVzLmdldEVsZW1lbnRCeUlkKGRvYywgaWRzW2ldKTtcclxuXHRcdH1cclxuXHRcdGlmIChuICE9IG51bGwpIHtcclxuXHRcdFx0bnMuYWRkKG4pO1xyXG5cdFx0XHRjb3VudCsrO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gbnM7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMubG9jYWxOYW1lID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0dmFyIG47XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xyXG5cdFx0biA9IGMuY29udGV4dE5vZGU7XHJcblx0fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcclxuXHRcdG4gPSBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykuZmlyc3QoKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gbG9jYWwtbmFtZSBleHBlY3RzIChub2RlLXNldD8pXCIpO1xyXG5cdH1cclxuXHRpZiAobiA9PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gbmV3IFhTdHJpbmcoXCJcIik7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWFN0cmluZyhuLmxvY2FsTmFtZSA/IG4ubG9jYWxOYW1lIDogbi5iYXNlTmFtZSk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMubmFtZXNwYWNlVVJJID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0dmFyIG47XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xyXG5cdFx0biA9IGMuY29udGV4dE5vZGU7XHJcblx0fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcclxuXHRcdG4gPSBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykuZmlyc3QoKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gbmFtZXNwYWNlLXVyaSBleHBlY3RzIChub2RlLXNldD8pXCIpO1xyXG5cdH1cclxuXHRpZiAobiA9PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gbmV3IFhTdHJpbmcoXCJcIik7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWFN0cmluZyhuLm5hbWVzcGFjZVVSSSk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMubmFtZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdHZhciBuO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcclxuXHRcdG4gPSBjLmNvbnRleHROb2RlO1xyXG5cdH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XHJcblx0XHRuID0gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLmZpcnN0KCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIG5hbWUgZXhwZWN0cyAobm9kZS1zZXQ/KVwiKTtcclxuXHR9XHJcblx0aWYgKG4gPT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIG5ldyBYU3RyaW5nKFwiXCIpO1xyXG5cdH1cclxuXHRpZiAobi5ub2RlVHlwZSA9PSAxIC8qTm9kZS5FTEVNRU5UX05PREUqLyB8fCBuLm5vZGVUeXBlID09IDIgLypOb2RlLkFUVFJJQlVURV9OT0RFKi8pIHtcclxuXHRcdHJldHVybiBuZXcgWFN0cmluZyhuLm5vZGVOYW1lKTtcclxuXHR9IGVsc2UgaWYgKG4ubG9jYWxOYW1lID09IG51bGwpIHtcclxuXHRcdHJldHVybiBuZXcgWFN0cmluZyhcIlwiKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIG5ldyBYU3RyaW5nKG4ubG9jYWxOYW1lKTtcclxuXHR9XHJcbn07XHJcblxyXG5GdW5jdGlvbnMuc3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xyXG5cdFx0cmV0dXJuIFhOb2RlU2V0LnByb3RvdHlwZS5zdHJpbmdGb3JOb2RlKGMuY29udGV4dE5vZGUpO1xyXG5cdH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XHJcblx0XHRyZXR1cm4gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLnN0cmluZygpO1xyXG5cdH1cclxuXHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBzdHJpbmcgZXhwZWN0cyAob2JqZWN0PylcIik7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMuY29uY2F0ID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBjb25jYXQgZXhwZWN0cyAoc3RyaW5nLCBzdHJpbmcsIHN0cmluZyopXCIpO1xyXG5cdH1cclxuXHR2YXIgcyA9IFwiXCI7XHJcblx0Zm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHMgKz0gYXJndW1lbnRzW2ldLmV2YWx1YXRlKGMpLnN0cmluZ1ZhbHVlKCk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWFN0cmluZyhzKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5zdGFydHNXaXRoID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMykge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gc3RhcnRzV2l0aCBleHBlY3RzIChzdHJpbmcsIHN0cmluZylcIik7XHJcblx0fVxyXG5cdHZhciBzMSA9IGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdHZhciBzMiA9IGFyZ3VtZW50c1syXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4oczEuc3Vic3RyaW5nKDAsIHMyLmxlbmd0aCkgPT0gczIpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLmNvbnRhaW5zID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMykge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gY29udGFpbnMgZXhwZWN0cyAoc3RyaW5nLCBzdHJpbmcpXCIpO1xyXG5cdH1cclxuXHR2YXIgczEgPSBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykuc3RyaW5nVmFsdWUoKTtcclxuXHR2YXIgczIgPSBhcmd1bWVudHNbMl0uZXZhbHVhdGUoYykuc3RyaW5nVmFsdWUoKTtcclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHMxLmluZGV4T2YoczIpICE9IC0xKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5zdWJzdHJpbmdCZWZvcmUgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAzKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBzdWJzdHJpbmctYmVmb3JlIGV4cGVjdHMgKHN0cmluZywgc3RyaW5nKVwiKTtcclxuXHR9XHJcblx0dmFyIHMxID0gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLnN0cmluZ1ZhbHVlKCk7XHJcblx0dmFyIHMyID0gYXJndW1lbnRzWzJdLmV2YWx1YXRlKGMpLnN0cmluZ1ZhbHVlKCk7XHJcblx0cmV0dXJuIG5ldyBYU3RyaW5nKHMxLnN1YnN0cmluZygwLCBzMS5pbmRleE9mKHMyKSkpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLnN1YnN0cmluZ0FmdGVyID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMykge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gc3Vic3RyaW5nLWFmdGVyIGV4cGVjdHMgKHN0cmluZywgc3RyaW5nKVwiKTtcclxuXHR9XHJcblx0dmFyIHMxID0gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLnN0cmluZ1ZhbHVlKCk7XHJcblx0dmFyIHMyID0gYXJndW1lbnRzWzJdLmV2YWx1YXRlKGMpLnN0cmluZ1ZhbHVlKCk7XHJcblx0aWYgKHMyLmxlbmd0aCA9PSAwKSB7XHJcblx0XHRyZXR1cm4gbmV3IFhTdHJpbmcoczEpO1xyXG5cdH1cclxuXHR2YXIgaSA9IHMxLmluZGV4T2YoczIpO1xyXG5cdGlmIChpID09IC0xKSB7XHJcblx0XHRyZXR1cm4gbmV3IFhTdHJpbmcoXCJcIik7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWFN0cmluZyhzMS5zdWJzdHJpbmcoczEuaW5kZXhPZihzMikgKyAxKSk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMuc3Vic3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0aWYgKCEoYXJndW1lbnRzLmxlbmd0aCA9PSAzIHx8IGFyZ3VtZW50cy5sZW5ndGggPT0gNCkpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIHN1YnN0cmluZyBleHBlY3RzIChzdHJpbmcsIG51bWJlciwgbnVtYmVyPylcIik7XHJcblx0fVxyXG5cdHZhciBzID0gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLnN0cmluZ1ZhbHVlKCk7XHJcblx0dmFyIG4xID0gTWF0aC5yb3VuZChhcmd1bWVudHNbMl0uZXZhbHVhdGUoYykubnVtYmVyVmFsdWUoKSkgLSAxO1xyXG5cdHZhciBuMiA9IGFyZ3VtZW50cy5sZW5ndGggPT0gNCA/IG4xICsgTWF0aC5yb3VuZChhcmd1bWVudHNbM10uZXZhbHVhdGUoYykubnVtYmVyVmFsdWUoKSkgOiB1bmRlZmluZWQ7XHJcblx0cmV0dXJuIG5ldyBYU3RyaW5nKHMuc3Vic3RyaW5nKG4xLCBuMikpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLnN0cmluZ0xlbmd0aCA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdHZhciBzO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcclxuXHRcdHMgPSBYTm9kZVNldC5wcm90b3R5cGUuc3RyaW5nRm9yTm9kZShjLmNvbnRleHROb2RlKTtcclxuXHR9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xyXG5cdFx0cyA9IGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBzdHJpbmctbGVuZ3RoIGV4cGVjdHMgKHN0cmluZz8pXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIocy5sZW5ndGgpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLm5vcm1hbGl6ZVNwYWNlID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0dmFyIHM7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xyXG5cdFx0cyA9IFhOb2RlU2V0LnByb3RvdHlwZS5zdHJpbmdGb3JOb2RlKGMuY29udGV4dE5vZGUpO1xyXG5cdH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XHJcblx0XHRzID0gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLnN0cmluZ1ZhbHVlKCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIG5vcm1hbGl6ZS1zcGFjZSBleHBlY3RzIChzdHJpbmc/KVwiKTtcclxuXHR9XHJcblx0dmFyIGkgPSAwO1xyXG5cdHZhciBqID0gcy5sZW5ndGggLSAxO1xyXG5cdHdoaWxlIChVdGlsaXRpZXMuaXNTcGFjZShzLmNoYXJDb2RlQXQoaikpKSB7XHJcblx0XHRqLS07XHJcblx0fVxyXG5cdHZhciB0ID0gXCJcIjtcclxuXHR3aGlsZSAoaSA8PSBqICYmIFV0aWxpdGllcy5pc1NwYWNlKHMuY2hhckNvZGVBdChpKSkpIHtcclxuXHRcdGkrKztcclxuXHR9XHJcblx0d2hpbGUgKGkgPD0gaikge1xyXG5cdFx0aWYgKFV0aWxpdGllcy5pc1NwYWNlKHMuY2hhckNvZGVBdChpKSkpIHtcclxuXHRcdFx0dCArPSBcIiBcIjtcclxuXHRcdFx0d2hpbGUgKGkgPD0gaiAmJiBVdGlsaXRpZXMuaXNTcGFjZShzLmNoYXJDb2RlQXQoaSkpKSB7XHJcblx0XHRcdFx0aSsrO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0ICs9IHMuY2hhckF0KGkpO1xyXG5cdFx0XHRpKys7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWFN0cmluZyh0KTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy50cmFuc2xhdGUgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSA0KSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiB0cmFuc2xhdGUgZXhwZWN0cyAoc3RyaW5nLCBzdHJpbmcsIHN0cmluZylcIik7XHJcblx0fVxyXG5cdHZhciBzMSA9IGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdHZhciBzMiA9IGFyZ3VtZW50c1syXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdHZhciBzMyA9IGFyZ3VtZW50c1szXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdHZhciBtYXAgPSBbXTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHMyLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaiA9IHMyLmNoYXJDb2RlQXQoaSk7XHJcblx0XHRpZiAobWFwW2pdID09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR2YXIgayA9IGkgPiBzMy5sZW5ndGggPyBcIlwiIDogczMuY2hhckF0KGkpO1xyXG5cdFx0XHRtYXBbal0gPSBrO1xyXG5cdFx0fVxyXG5cdH1cclxuXHR2YXIgdCA9IFwiXCI7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzMS5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGMgPSBzMS5jaGFyQ29kZUF0KGkpO1xyXG5cdFx0dmFyIHIgPSBtYXBbY107XHJcblx0XHRpZiAociA9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dCArPSBzMS5jaGFyQXQoaSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0ICs9IHI7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWFN0cmluZyh0KTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5ib29sZWFuXyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGJvb2xlYW4gZXhwZWN0cyAob2JqZWN0KVwiKTtcclxuXHR9XHJcblx0cmV0dXJuIGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5ib29sKCk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMubm90ID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMikge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gbm90IGV4cGVjdHMgKG9iamVjdClcIik7XHJcblx0fVxyXG5cdHJldHVybiBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykuYm9vbCgpLm5vdCgpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLnRydWVfID0gZnVuY3Rpb24oKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gdHJ1ZSBleHBlY3RzICgpXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHRydWUpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLmZhbHNlXyA9IGZ1bmN0aW9uKCkge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGZhbHNlIGV4cGVjdHMgKClcIik7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4oZmFsc2UpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLmxhbmcgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBsYW5nIGV4cGVjdHMgKHN0cmluZylcIik7XHJcblx0fVxyXG5cdHZhciBsYW5nO1xyXG5cdGZvciAodmFyIG4gPSBjLmNvbnRleHROb2RlOyBuICE9IG51bGwgJiYgbi5ub2RlVHlwZSAhPSA5IC8qTm9kZS5ET0NVTUVOVF9OT0RFKi87IG4gPSBuLnBhcmVudE5vZGUpIHtcclxuXHRcdHZhciBhID0gbi5nZXRBdHRyaWJ1dGVOUyhYUGF0aC5YTUxfTkFNRVNQQUNFX1VSSSwgXCJsYW5nXCIpO1xyXG5cdFx0aWYgKGEgIT0gbnVsbCkge1xyXG5cdFx0XHRsYW5nID0gU3RyaW5nKGEpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGxhbmcgPT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIG5ldyBYQm9vbGVhbihmYWxzZSk7XHJcblx0fVxyXG5cdHZhciBzID0gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLnN0cmluZ1ZhbHVlKCk7XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbihsYW5nLnN1YnN0cmluZygwLCBzLmxlbmd0aCkgPT0gc1xyXG5cdFx0XHRcdCYmIChsYW5nLmxlbmd0aCA9PSBzLmxlbmd0aCB8fCBsYW5nLmNoYXJBdChzLmxlbmd0aCkgPT0gJy0nKSk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMubnVtYmVyID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0aWYgKCEoYXJndW1lbnRzLmxlbmd0aCA9PSAxIHx8IGFyZ3VtZW50cy5sZW5ndGggPT0gMikpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIG51bWJlciBleHBlY3RzIChvYmplY3Q/KVwiKTtcclxuXHR9XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xyXG5cdFx0cmV0dXJuIG5ldyBYTnVtYmVyKFhOb2RlU2V0LnByb3RvdHlwZS5zdHJpbmdGb3JOb2RlKGMuY29udGV4dE5vZGUpKTtcclxuXHR9XHJcblx0cmV0dXJuIGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5udW1iZXIoKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5zdW0gPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHR2YXIgbnM7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMiB8fCAhVXRpbGl0aWVzLmluc3RhbmNlX29mKChucyA9IGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKSksIFhOb2RlU2V0KSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gc3VtIGV4cGVjdHMgKG5vZGUtc2V0KVwiKTtcclxuXHR9XHJcblx0bnMgPSBucy50b0FycmF5KCk7XHJcblx0dmFyIG4gPSAwO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdG4gKz0gbmV3IFhOdW1iZXIoWE5vZGVTZXQucHJvdG90eXBlLnN0cmluZ0Zvck5vZGUobnNbaV0pKS5udW1iZXJWYWx1ZSgpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIobik7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMuZmxvb3IgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBmbG9vciBleHBlY3RzIChudW1iZXIpXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIoTWF0aC5mbG9vcihhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykubnVtYmVyVmFsdWUoKSkpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLmNlaWxpbmcgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBjZWlsaW5nIGV4cGVjdHMgKG51bWJlcilcIik7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWE51bWJlcihNYXRoLmNlaWwoYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLm51bWJlclZhbHVlKCkpKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5yb3VuZCA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIHJvdW5kIGV4cGVjdHMgKG51bWJlcilcIik7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWE51bWJlcihNYXRoLnJvdW5kKGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5udW1iZXJWYWx1ZSgpKSk7XHJcbn07XHJcblxyXG4vLyBVdGlsaXRpZXMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblV0aWxpdGllcyA9IG5ldyBPYmplY3QoKTtcclxuXHJcblV0aWxpdGllcy5zcGxpdFFOYW1lID0gZnVuY3Rpb24ocW4pIHtcclxuXHR2YXIgaSA9IHFuLmluZGV4T2YoXCI6XCIpO1xyXG5cdGlmIChpID09IC0xKSB7XHJcblx0XHRyZXR1cm4gWyBudWxsLCBxbiBdO1xyXG5cdH1cclxuXHRyZXR1cm4gWyBxbi5zdWJzdHJpbmcoMCwgaSksIHFuLnN1YnN0cmluZyhpICsgMSkgXTtcclxufTtcclxuXHJcblV0aWxpdGllcy5yZXNvbHZlUU5hbWUgPSBmdW5jdGlvbihxbiwgbnIsIG4sIHVzZURlZmF1bHQpIHtcclxuXHR2YXIgcGFydHMgPSBVdGlsaXRpZXMuc3BsaXRRTmFtZShxbik7XHJcblx0aWYgKHBhcnRzWzBdICE9IG51bGwpIHtcclxuXHRcdHBhcnRzWzBdID0gbnIuZ2V0TmFtZXNwYWNlKHBhcnRzWzBdLCBuKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0aWYgKHVzZURlZmF1bHQpIHtcclxuXHRcdFx0cGFydHNbMF0gPSBuci5nZXROYW1lc3BhY2UoXCJcIiwgbik7XHJcblx0XHRcdGlmIChwYXJ0c1swXSA9PSBudWxsKSB7XHJcblx0XHRcdFx0cGFydHNbMF0gPSBcIlwiO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRwYXJ0c1swXSA9IFwiXCI7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBwYXJ0cztcclxufTtcclxuXHJcblV0aWxpdGllcy5pc1NwYWNlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiBjID09IDB4OSB8fCBjID09IDB4ZCB8fCBjID09IDB4YSB8fCBjID09IDB4MjA7XHJcbn07XHJcblxyXG5VdGlsaXRpZXMuaXNMZXR0ZXIgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIGMgPj0gMHgwMDQxICYmIGMgPD0gMHgwMDVBIHx8XHJcblx0XHRjID49IDB4MDA2MSAmJiBjIDw9IDB4MDA3QSB8fFxyXG5cdFx0YyA+PSAweDAwQzAgJiYgYyA8PSAweDAwRDYgfHxcclxuXHRcdGMgPj0gMHgwMEQ4ICYmIGMgPD0gMHgwMEY2IHx8XHJcblx0XHRjID49IDB4MDBGOCAmJiBjIDw9IDB4MDBGRiB8fFxyXG5cdFx0YyA+PSAweDAxMDAgJiYgYyA8PSAweDAxMzEgfHxcclxuXHRcdGMgPj0gMHgwMTM0ICYmIGMgPD0gMHgwMTNFIHx8XHJcblx0XHRjID49IDB4MDE0MSAmJiBjIDw9IDB4MDE0OCB8fFxyXG5cdFx0YyA+PSAweDAxNEEgJiYgYyA8PSAweDAxN0UgfHxcclxuXHRcdGMgPj0gMHgwMTgwICYmIGMgPD0gMHgwMUMzIHx8XHJcblx0XHRjID49IDB4MDFDRCAmJiBjIDw9IDB4MDFGMCB8fFxyXG5cdFx0YyA+PSAweDAxRjQgJiYgYyA8PSAweDAxRjUgfHxcclxuXHRcdGMgPj0gMHgwMUZBICYmIGMgPD0gMHgwMjE3IHx8XHJcblx0XHRjID49IDB4MDI1MCAmJiBjIDw9IDB4MDJBOCB8fFxyXG5cdFx0YyA+PSAweDAyQkIgJiYgYyA8PSAweDAyQzEgfHxcclxuXHRcdGMgPT0gMHgwMzg2IHx8XHJcblx0XHRjID49IDB4MDM4OCAmJiBjIDw9IDB4MDM4QSB8fFxyXG5cdFx0YyA9PSAweDAzOEMgfHxcclxuXHRcdGMgPj0gMHgwMzhFICYmIGMgPD0gMHgwM0ExIHx8XHJcblx0XHRjID49IDB4MDNBMyAmJiBjIDw9IDB4MDNDRSB8fFxyXG5cdFx0YyA+PSAweDAzRDAgJiYgYyA8PSAweDAzRDYgfHxcclxuXHRcdGMgPT0gMHgwM0RBIHx8XHJcblx0XHRjID09IDB4MDNEQyB8fFxyXG5cdFx0YyA9PSAweDAzREUgfHxcclxuXHRcdGMgPT0gMHgwM0UwIHx8XHJcblx0XHRjID49IDB4MDNFMiAmJiBjIDw9IDB4MDNGMyB8fFxyXG5cdFx0YyA+PSAweDA0MDEgJiYgYyA8PSAweDA0MEMgfHxcclxuXHRcdGMgPj0gMHgwNDBFICYmIGMgPD0gMHgwNDRGIHx8XHJcblx0XHRjID49IDB4MDQ1MSAmJiBjIDw9IDB4MDQ1QyB8fFxyXG5cdFx0YyA+PSAweDA0NUUgJiYgYyA8PSAweDA0ODEgfHxcclxuXHRcdGMgPj0gMHgwNDkwICYmIGMgPD0gMHgwNEM0IHx8XHJcblx0XHRjID49IDB4MDRDNyAmJiBjIDw9IDB4MDRDOCB8fFxyXG5cdFx0YyA+PSAweDA0Q0IgJiYgYyA8PSAweDA0Q0MgfHxcclxuXHRcdGMgPj0gMHgwNEQwICYmIGMgPD0gMHgwNEVCIHx8XHJcblx0XHRjID49IDB4MDRFRSAmJiBjIDw9IDB4MDRGNSB8fFxyXG5cdFx0YyA+PSAweDA0RjggJiYgYyA8PSAweDA0RjkgfHxcclxuXHRcdGMgPj0gMHgwNTMxICYmIGMgPD0gMHgwNTU2IHx8XHJcblx0XHRjID09IDB4MDU1OSB8fFxyXG5cdFx0YyA+PSAweDA1NjEgJiYgYyA8PSAweDA1ODYgfHxcclxuXHRcdGMgPj0gMHgwNUQwICYmIGMgPD0gMHgwNUVBIHx8XHJcblx0XHRjID49IDB4MDVGMCAmJiBjIDw9IDB4MDVGMiB8fFxyXG5cdFx0YyA+PSAweDA2MjEgJiYgYyA8PSAweDA2M0EgfHxcclxuXHRcdGMgPj0gMHgwNjQxICYmIGMgPD0gMHgwNjRBIHx8XHJcblx0XHRjID49IDB4MDY3MSAmJiBjIDw9IDB4MDZCNyB8fFxyXG5cdFx0YyA+PSAweDA2QkEgJiYgYyA8PSAweDA2QkUgfHxcclxuXHRcdGMgPj0gMHgwNkMwICYmIGMgPD0gMHgwNkNFIHx8XHJcblx0XHRjID49IDB4MDZEMCAmJiBjIDw9IDB4MDZEMyB8fFxyXG5cdFx0YyA9PSAweDA2RDUgfHxcclxuXHRcdGMgPj0gMHgwNkU1ICYmIGMgPD0gMHgwNkU2IHx8XHJcblx0XHRjID49IDB4MDkwNSAmJiBjIDw9IDB4MDkzOSB8fFxyXG5cdFx0YyA9PSAweDA5M0QgfHxcclxuXHRcdGMgPj0gMHgwOTU4ICYmIGMgPD0gMHgwOTYxIHx8XHJcblx0XHRjID49IDB4MDk4NSAmJiBjIDw9IDB4MDk4QyB8fFxyXG5cdFx0YyA+PSAweDA5OEYgJiYgYyA8PSAweDA5OTAgfHxcclxuXHRcdGMgPj0gMHgwOTkzICYmIGMgPD0gMHgwOUE4IHx8XHJcblx0XHRjID49IDB4MDlBQSAmJiBjIDw9IDB4MDlCMCB8fFxyXG5cdFx0YyA9PSAweDA5QjIgfHxcclxuXHRcdGMgPj0gMHgwOUI2ICYmIGMgPD0gMHgwOUI5IHx8XHJcblx0XHRjID49IDB4MDlEQyAmJiBjIDw9IDB4MDlERCB8fFxyXG5cdFx0YyA+PSAweDA5REYgJiYgYyA8PSAweDA5RTEgfHxcclxuXHRcdGMgPj0gMHgwOUYwICYmIGMgPD0gMHgwOUYxIHx8XHJcblx0XHRjID49IDB4MEEwNSAmJiBjIDw9IDB4MEEwQSB8fFxyXG5cdFx0YyA+PSAweDBBMEYgJiYgYyA8PSAweDBBMTAgfHxcclxuXHRcdGMgPj0gMHgwQTEzICYmIGMgPD0gMHgwQTI4IHx8XHJcblx0XHRjID49IDB4MEEyQSAmJiBjIDw9IDB4MEEzMCB8fFxyXG5cdFx0YyA+PSAweDBBMzIgJiYgYyA8PSAweDBBMzMgfHxcclxuXHRcdGMgPj0gMHgwQTM1ICYmIGMgPD0gMHgwQTM2IHx8XHJcblx0XHRjID49IDB4MEEzOCAmJiBjIDw9IDB4MEEzOSB8fFxyXG5cdFx0YyA+PSAweDBBNTkgJiYgYyA8PSAweDBBNUMgfHxcclxuXHRcdGMgPT0gMHgwQTVFIHx8XHJcblx0XHRjID49IDB4MEE3MiAmJiBjIDw9IDB4MEE3NCB8fFxyXG5cdFx0YyA+PSAweDBBODUgJiYgYyA8PSAweDBBOEIgfHxcclxuXHRcdGMgPT0gMHgwQThEIHx8XHJcblx0XHRjID49IDB4MEE4RiAmJiBjIDw9IDB4MEE5MSB8fFxyXG5cdFx0YyA+PSAweDBBOTMgJiYgYyA8PSAweDBBQTggfHxcclxuXHRcdGMgPj0gMHgwQUFBICYmIGMgPD0gMHgwQUIwIHx8XHJcblx0XHRjID49IDB4MEFCMiAmJiBjIDw9IDB4MEFCMyB8fFxyXG5cdFx0YyA+PSAweDBBQjUgJiYgYyA8PSAweDBBQjkgfHxcclxuXHRcdGMgPT0gMHgwQUJEIHx8XHJcblx0XHRjID09IDB4MEFFMCB8fFxyXG5cdFx0YyA+PSAweDBCMDUgJiYgYyA8PSAweDBCMEMgfHxcclxuXHRcdGMgPj0gMHgwQjBGICYmIGMgPD0gMHgwQjEwIHx8XHJcblx0XHRjID49IDB4MEIxMyAmJiBjIDw9IDB4MEIyOCB8fFxyXG5cdFx0YyA+PSAweDBCMkEgJiYgYyA8PSAweDBCMzAgfHxcclxuXHRcdGMgPj0gMHgwQjMyICYmIGMgPD0gMHgwQjMzIHx8XHJcblx0XHRjID49IDB4MEIzNiAmJiBjIDw9IDB4MEIzOSB8fFxyXG5cdFx0YyA9PSAweDBCM0QgfHxcclxuXHRcdGMgPj0gMHgwQjVDICYmIGMgPD0gMHgwQjVEIHx8XHJcblx0XHRjID49IDB4MEI1RiAmJiBjIDw9IDB4MEI2MSB8fFxyXG5cdFx0YyA+PSAweDBCODUgJiYgYyA8PSAweDBCOEEgfHxcclxuXHRcdGMgPj0gMHgwQjhFICYmIGMgPD0gMHgwQjkwIHx8XHJcblx0XHRjID49IDB4MEI5MiAmJiBjIDw9IDB4MEI5NSB8fFxyXG5cdFx0YyA+PSAweDBCOTkgJiYgYyA8PSAweDBCOUEgfHxcclxuXHRcdGMgPT0gMHgwQjlDIHx8XHJcblx0XHRjID49IDB4MEI5RSAmJiBjIDw9IDB4MEI5RiB8fFxyXG5cdFx0YyA+PSAweDBCQTMgJiYgYyA8PSAweDBCQTQgfHxcclxuXHRcdGMgPj0gMHgwQkE4ICYmIGMgPD0gMHgwQkFBIHx8XHJcblx0XHRjID49IDB4MEJBRSAmJiBjIDw9IDB4MEJCNSB8fFxyXG5cdFx0YyA+PSAweDBCQjcgJiYgYyA8PSAweDBCQjkgfHxcclxuXHRcdGMgPj0gMHgwQzA1ICYmIGMgPD0gMHgwQzBDIHx8XHJcblx0XHRjID49IDB4MEMwRSAmJiBjIDw9IDB4MEMxMCB8fFxyXG5cdFx0YyA+PSAweDBDMTIgJiYgYyA8PSAweDBDMjggfHxcclxuXHRcdGMgPj0gMHgwQzJBICYmIGMgPD0gMHgwQzMzIHx8XHJcblx0XHRjID49IDB4MEMzNSAmJiBjIDw9IDB4MEMzOSB8fFxyXG5cdFx0YyA+PSAweDBDNjAgJiYgYyA8PSAweDBDNjEgfHxcclxuXHRcdGMgPj0gMHgwQzg1ICYmIGMgPD0gMHgwQzhDIHx8XHJcblx0XHRjID49IDB4MEM4RSAmJiBjIDw9IDB4MEM5MCB8fFxyXG5cdFx0YyA+PSAweDBDOTIgJiYgYyA8PSAweDBDQTggfHxcclxuXHRcdGMgPj0gMHgwQ0FBICYmIGMgPD0gMHgwQ0IzIHx8XHJcblx0XHRjID49IDB4MENCNSAmJiBjIDw9IDB4MENCOSB8fFxyXG5cdFx0YyA9PSAweDBDREUgfHxcclxuXHRcdGMgPj0gMHgwQ0UwICYmIGMgPD0gMHgwQ0UxIHx8XHJcblx0XHRjID49IDB4MEQwNSAmJiBjIDw9IDB4MEQwQyB8fFxyXG5cdFx0YyA+PSAweDBEMEUgJiYgYyA8PSAweDBEMTAgfHxcclxuXHRcdGMgPj0gMHgwRDEyICYmIGMgPD0gMHgwRDI4IHx8XHJcblx0XHRjID49IDB4MEQyQSAmJiBjIDw9IDB4MEQzOSB8fFxyXG5cdFx0YyA+PSAweDBENjAgJiYgYyA8PSAweDBENjEgfHxcclxuXHRcdGMgPj0gMHgwRTAxICYmIGMgPD0gMHgwRTJFIHx8XHJcblx0XHRjID09IDB4MEUzMCB8fFxyXG5cdFx0YyA+PSAweDBFMzIgJiYgYyA8PSAweDBFMzMgfHxcclxuXHRcdGMgPj0gMHgwRTQwICYmIGMgPD0gMHgwRTQ1IHx8XHJcblx0XHRjID49IDB4MEU4MSAmJiBjIDw9IDB4MEU4MiB8fFxyXG5cdFx0YyA9PSAweDBFODQgfHxcclxuXHRcdGMgPj0gMHgwRTg3ICYmIGMgPD0gMHgwRTg4IHx8XHJcblx0XHRjID09IDB4MEU4QSB8fFxyXG5cdFx0YyA9PSAweDBFOEQgfHxcclxuXHRcdGMgPj0gMHgwRTk0ICYmIGMgPD0gMHgwRTk3IHx8XHJcblx0XHRjID49IDB4MEU5OSAmJiBjIDw9IDB4MEU5RiB8fFxyXG5cdFx0YyA+PSAweDBFQTEgJiYgYyA8PSAweDBFQTMgfHxcclxuXHRcdGMgPT0gMHgwRUE1IHx8XHJcblx0XHRjID09IDB4MEVBNyB8fFxyXG5cdFx0YyA+PSAweDBFQUEgJiYgYyA8PSAweDBFQUIgfHxcclxuXHRcdGMgPj0gMHgwRUFEICYmIGMgPD0gMHgwRUFFIHx8XHJcblx0XHRjID09IDB4MEVCMCB8fFxyXG5cdFx0YyA+PSAweDBFQjIgJiYgYyA8PSAweDBFQjMgfHxcclxuXHRcdGMgPT0gMHgwRUJEIHx8XHJcblx0XHRjID49IDB4MEVDMCAmJiBjIDw9IDB4MEVDNCB8fFxyXG5cdFx0YyA+PSAweDBGNDAgJiYgYyA8PSAweDBGNDcgfHxcclxuXHRcdGMgPj0gMHgwRjQ5ICYmIGMgPD0gMHgwRjY5IHx8XHJcblx0XHRjID49IDB4MTBBMCAmJiBjIDw9IDB4MTBDNSB8fFxyXG5cdFx0YyA+PSAweDEwRDAgJiYgYyA8PSAweDEwRjYgfHxcclxuXHRcdGMgPT0gMHgxMTAwIHx8XHJcblx0XHRjID49IDB4MTEwMiAmJiBjIDw9IDB4MTEwMyB8fFxyXG5cdFx0YyA+PSAweDExMDUgJiYgYyA8PSAweDExMDcgfHxcclxuXHRcdGMgPT0gMHgxMTA5IHx8XHJcblx0XHRjID49IDB4MTEwQiAmJiBjIDw9IDB4MTEwQyB8fFxyXG5cdFx0YyA+PSAweDExMEUgJiYgYyA8PSAweDExMTIgfHxcclxuXHRcdGMgPT0gMHgxMTNDIHx8XHJcblx0XHRjID09IDB4MTEzRSB8fFxyXG5cdFx0YyA9PSAweDExNDAgfHxcclxuXHRcdGMgPT0gMHgxMTRDIHx8XHJcblx0XHRjID09IDB4MTE0RSB8fFxyXG5cdFx0YyA9PSAweDExNTAgfHxcclxuXHRcdGMgPj0gMHgxMTU0ICYmIGMgPD0gMHgxMTU1IHx8XHJcblx0XHRjID09IDB4MTE1OSB8fFxyXG5cdFx0YyA+PSAweDExNUYgJiYgYyA8PSAweDExNjEgfHxcclxuXHRcdGMgPT0gMHgxMTYzIHx8XHJcblx0XHRjID09IDB4MTE2NSB8fFxyXG5cdFx0YyA9PSAweDExNjcgfHxcclxuXHRcdGMgPT0gMHgxMTY5IHx8XHJcblx0XHRjID49IDB4MTE2RCAmJiBjIDw9IDB4MTE2RSB8fFxyXG5cdFx0YyA+PSAweDExNzIgJiYgYyA8PSAweDExNzMgfHxcclxuXHRcdGMgPT0gMHgxMTc1IHx8XHJcblx0XHRjID09IDB4MTE5RSB8fFxyXG5cdFx0YyA9PSAweDExQTggfHxcclxuXHRcdGMgPT0gMHgxMUFCIHx8XHJcblx0XHRjID49IDB4MTFBRSAmJiBjIDw9IDB4MTFBRiB8fFxyXG5cdFx0YyA+PSAweDExQjcgJiYgYyA8PSAweDExQjggfHxcclxuXHRcdGMgPT0gMHgxMUJBIHx8XHJcblx0XHRjID49IDB4MTFCQyAmJiBjIDw9IDB4MTFDMiB8fFxyXG5cdFx0YyA9PSAweDExRUIgfHxcclxuXHRcdGMgPT0gMHgxMUYwIHx8XHJcblx0XHRjID09IDB4MTFGOSB8fFxyXG5cdFx0YyA+PSAweDFFMDAgJiYgYyA8PSAweDFFOUIgfHxcclxuXHRcdGMgPj0gMHgxRUEwICYmIGMgPD0gMHgxRUY5IHx8XHJcblx0XHRjID49IDB4MUYwMCAmJiBjIDw9IDB4MUYxNSB8fFxyXG5cdFx0YyA+PSAweDFGMTggJiYgYyA8PSAweDFGMUQgfHxcclxuXHRcdGMgPj0gMHgxRjIwICYmIGMgPD0gMHgxRjQ1IHx8XHJcblx0XHRjID49IDB4MUY0OCAmJiBjIDw9IDB4MUY0RCB8fFxyXG5cdFx0YyA+PSAweDFGNTAgJiYgYyA8PSAweDFGNTcgfHxcclxuXHRcdGMgPT0gMHgxRjU5IHx8XHJcblx0XHRjID09IDB4MUY1QiB8fFxyXG5cdFx0YyA9PSAweDFGNUQgfHxcclxuXHRcdGMgPj0gMHgxRjVGICYmIGMgPD0gMHgxRjdEIHx8XHJcblx0XHRjID49IDB4MUY4MCAmJiBjIDw9IDB4MUZCNCB8fFxyXG5cdFx0YyA+PSAweDFGQjYgJiYgYyA8PSAweDFGQkMgfHxcclxuXHRcdGMgPT0gMHgxRkJFIHx8XHJcblx0XHRjID49IDB4MUZDMiAmJiBjIDw9IDB4MUZDNCB8fFxyXG5cdFx0YyA+PSAweDFGQzYgJiYgYyA8PSAweDFGQ0MgfHxcclxuXHRcdGMgPj0gMHgxRkQwICYmIGMgPD0gMHgxRkQzIHx8XHJcblx0XHRjID49IDB4MUZENiAmJiBjIDw9IDB4MUZEQiB8fFxyXG5cdFx0YyA+PSAweDFGRTAgJiYgYyA8PSAweDFGRUMgfHxcclxuXHRcdGMgPj0gMHgxRkYyICYmIGMgPD0gMHgxRkY0IHx8XHJcblx0XHRjID49IDB4MUZGNiAmJiBjIDw9IDB4MUZGQyB8fFxyXG5cdFx0YyA9PSAweDIxMjYgfHxcclxuXHRcdGMgPj0gMHgyMTJBICYmIGMgPD0gMHgyMTJCIHx8XHJcblx0XHRjID09IDB4MjEyRSB8fFxyXG5cdFx0YyA+PSAweDIxODAgJiYgYyA8PSAweDIxODIgfHxcclxuXHRcdGMgPj0gMHgzMDQxICYmIGMgPD0gMHgzMDk0IHx8XHJcblx0XHRjID49IDB4MzBBMSAmJiBjIDw9IDB4MzBGQSB8fFxyXG5cdFx0YyA+PSAweDMxMDUgJiYgYyA8PSAweDMxMkMgfHxcclxuXHRcdGMgPj0gMHhBQzAwICYmIGMgPD0gMHhEN0EzIHx8XHJcblx0XHRjID49IDB4NEUwMCAmJiBjIDw9IDB4OUZBNSB8fFxyXG5cdFx0YyA9PSAweDMwMDcgfHxcclxuXHRcdGMgPj0gMHgzMDIxICYmIGMgPD0gMHgzMDI5O1xyXG59O1xyXG5cclxuVXRpbGl0aWVzLmlzTkNOYW1lQ2hhciA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gYyA+PSAweDAwMzAgJiYgYyA8PSAweDAwMzlcclxuXHRcdHx8IGMgPj0gMHgwNjYwICYmIGMgPD0gMHgwNjY5XHJcblx0XHR8fCBjID49IDB4MDZGMCAmJiBjIDw9IDB4MDZGOVxyXG5cdFx0fHwgYyA+PSAweDA5NjYgJiYgYyA8PSAweDA5NkZcclxuXHRcdHx8IGMgPj0gMHgwOUU2ICYmIGMgPD0gMHgwOUVGXHJcblx0XHR8fCBjID49IDB4MEE2NiAmJiBjIDw9IDB4MEE2RlxyXG5cdFx0fHwgYyA+PSAweDBBRTYgJiYgYyA8PSAweDBBRUZcclxuXHRcdHx8IGMgPj0gMHgwQjY2ICYmIGMgPD0gMHgwQjZGXHJcblx0XHR8fCBjID49IDB4MEJFNyAmJiBjIDw9IDB4MEJFRlxyXG5cdFx0fHwgYyA+PSAweDBDNjYgJiYgYyA8PSAweDBDNkZcclxuXHRcdHx8IGMgPj0gMHgwQ0U2ICYmIGMgPD0gMHgwQ0VGXHJcblx0XHR8fCBjID49IDB4MEQ2NiAmJiBjIDw9IDB4MEQ2RlxyXG5cdFx0fHwgYyA+PSAweDBFNTAgJiYgYyA8PSAweDBFNTlcclxuXHRcdHx8IGMgPj0gMHgwRUQwICYmIGMgPD0gMHgwRUQ5XHJcblx0XHR8fCBjID49IDB4MEYyMCAmJiBjIDw9IDB4MEYyOVxyXG5cdFx0fHwgYyA9PSAweDAwMkVcclxuXHRcdHx8IGMgPT0gMHgwMDJEXHJcblx0XHR8fCBjID09IDB4MDA1RlxyXG5cdFx0fHwgVXRpbGl0aWVzLmlzTGV0dGVyKGMpXHJcblx0XHR8fCBjID49IDB4MDMwMCAmJiBjIDw9IDB4MDM0NVxyXG5cdFx0fHwgYyA+PSAweDAzNjAgJiYgYyA8PSAweDAzNjFcclxuXHRcdHx8IGMgPj0gMHgwNDgzICYmIGMgPD0gMHgwNDg2XHJcblx0XHR8fCBjID49IDB4MDU5MSAmJiBjIDw9IDB4MDVBMVxyXG5cdFx0fHwgYyA+PSAweDA1QTMgJiYgYyA8PSAweDA1QjlcclxuXHRcdHx8IGMgPj0gMHgwNUJCICYmIGMgPD0gMHgwNUJEXHJcblx0XHR8fCBjID09IDB4MDVCRlxyXG5cdFx0fHwgYyA+PSAweDA1QzEgJiYgYyA8PSAweDA1QzJcclxuXHRcdHx8IGMgPT0gMHgwNUM0XHJcblx0XHR8fCBjID49IDB4MDY0QiAmJiBjIDw9IDB4MDY1MlxyXG5cdFx0fHwgYyA9PSAweDA2NzBcclxuXHRcdHx8IGMgPj0gMHgwNkQ2ICYmIGMgPD0gMHgwNkRDXHJcblx0XHR8fCBjID49IDB4MDZERCAmJiBjIDw9IDB4MDZERlxyXG5cdFx0fHwgYyA+PSAweDA2RTAgJiYgYyA8PSAweDA2RTRcclxuXHRcdHx8IGMgPj0gMHgwNkU3ICYmIGMgPD0gMHgwNkU4XHJcblx0XHR8fCBjID49IDB4MDZFQSAmJiBjIDw9IDB4MDZFRFxyXG5cdFx0fHwgYyA+PSAweDA5MDEgJiYgYyA8PSAweDA5MDNcclxuXHRcdHx8IGMgPT0gMHgwOTNDXHJcblx0XHR8fCBjID49IDB4MDkzRSAmJiBjIDw9IDB4MDk0Q1xyXG5cdFx0fHwgYyA9PSAweDA5NERcclxuXHRcdHx8IGMgPj0gMHgwOTUxICYmIGMgPD0gMHgwOTU0XHJcblx0XHR8fCBjID49IDB4MDk2MiAmJiBjIDw9IDB4MDk2M1xyXG5cdFx0fHwgYyA+PSAweDA5ODEgJiYgYyA8PSAweDA5ODNcclxuXHRcdHx8IGMgPT0gMHgwOUJDXHJcblx0XHR8fCBjID09IDB4MDlCRVxyXG5cdFx0fHwgYyA9PSAweDA5QkZcclxuXHRcdHx8IGMgPj0gMHgwOUMwICYmIGMgPD0gMHgwOUM0XHJcblx0XHR8fCBjID49IDB4MDlDNyAmJiBjIDw9IDB4MDlDOFxyXG5cdFx0fHwgYyA+PSAweDA5Q0IgJiYgYyA8PSAweDA5Q0RcclxuXHRcdHx8IGMgPT0gMHgwOUQ3XHJcblx0XHR8fCBjID49IDB4MDlFMiAmJiBjIDw9IDB4MDlFM1xyXG5cdFx0fHwgYyA9PSAweDBBMDJcclxuXHRcdHx8IGMgPT0gMHgwQTNDXHJcblx0XHR8fCBjID09IDB4MEEzRVxyXG5cdFx0fHwgYyA9PSAweDBBM0ZcclxuXHRcdHx8IGMgPj0gMHgwQTQwICYmIGMgPD0gMHgwQTQyXHJcblx0XHR8fCBjID49IDB4MEE0NyAmJiBjIDw9IDB4MEE0OFxyXG5cdFx0fHwgYyA+PSAweDBBNEIgJiYgYyA8PSAweDBBNERcclxuXHRcdHx8IGMgPj0gMHgwQTcwICYmIGMgPD0gMHgwQTcxXHJcblx0XHR8fCBjID49IDB4MEE4MSAmJiBjIDw9IDB4MEE4M1xyXG5cdFx0fHwgYyA9PSAweDBBQkNcclxuXHRcdHx8IGMgPj0gMHgwQUJFICYmIGMgPD0gMHgwQUM1XHJcblx0XHR8fCBjID49IDB4MEFDNyAmJiBjIDw9IDB4MEFDOVxyXG5cdFx0fHwgYyA+PSAweDBBQ0IgJiYgYyA8PSAweDBBQ0RcclxuXHRcdHx8IGMgPj0gMHgwQjAxICYmIGMgPD0gMHgwQjAzXHJcblx0XHR8fCBjID09IDB4MEIzQ1xyXG5cdFx0fHwgYyA+PSAweDBCM0UgJiYgYyA8PSAweDBCNDNcclxuXHRcdHx8IGMgPj0gMHgwQjQ3ICYmIGMgPD0gMHgwQjQ4XHJcblx0XHR8fCBjID49IDB4MEI0QiAmJiBjIDw9IDB4MEI0RFxyXG5cdFx0fHwgYyA+PSAweDBCNTYgJiYgYyA8PSAweDBCNTdcclxuXHRcdHx8IGMgPj0gMHgwQjgyICYmIGMgPD0gMHgwQjgzXHJcblx0XHR8fCBjID49IDB4MEJCRSAmJiBjIDw9IDB4MEJDMlxyXG5cdFx0fHwgYyA+PSAweDBCQzYgJiYgYyA8PSAweDBCQzhcclxuXHRcdHx8IGMgPj0gMHgwQkNBICYmIGMgPD0gMHgwQkNEXHJcblx0XHR8fCBjID09IDB4MEJEN1xyXG5cdFx0fHwgYyA+PSAweDBDMDEgJiYgYyA8PSAweDBDMDNcclxuXHRcdHx8IGMgPj0gMHgwQzNFICYmIGMgPD0gMHgwQzQ0XHJcblx0XHR8fCBjID49IDB4MEM0NiAmJiBjIDw9IDB4MEM0OFxyXG5cdFx0fHwgYyA+PSAweDBDNEEgJiYgYyA8PSAweDBDNERcclxuXHRcdHx8IGMgPj0gMHgwQzU1ICYmIGMgPD0gMHgwQzU2XHJcblx0XHR8fCBjID49IDB4MEM4MiAmJiBjIDw9IDB4MEM4M1xyXG5cdFx0fHwgYyA+PSAweDBDQkUgJiYgYyA8PSAweDBDQzRcclxuXHRcdHx8IGMgPj0gMHgwQ0M2ICYmIGMgPD0gMHgwQ0M4XHJcblx0XHR8fCBjID49IDB4MENDQSAmJiBjIDw9IDB4MENDRFxyXG5cdFx0fHwgYyA+PSAweDBDRDUgJiYgYyA8PSAweDBDRDZcclxuXHRcdHx8IGMgPj0gMHgwRDAyICYmIGMgPD0gMHgwRDAzXHJcblx0XHR8fCBjID49IDB4MEQzRSAmJiBjIDw9IDB4MEQ0M1xyXG5cdFx0fHwgYyA+PSAweDBENDYgJiYgYyA8PSAweDBENDhcclxuXHRcdHx8IGMgPj0gMHgwRDRBICYmIGMgPD0gMHgwRDREXHJcblx0XHR8fCBjID09IDB4MEQ1N1xyXG5cdFx0fHwgYyA9PSAweDBFMzFcclxuXHRcdHx8IGMgPj0gMHgwRTM0ICYmIGMgPD0gMHgwRTNBXHJcblx0XHR8fCBjID49IDB4MEU0NyAmJiBjIDw9IDB4MEU0RVxyXG5cdFx0fHwgYyA9PSAweDBFQjFcclxuXHRcdHx8IGMgPj0gMHgwRUI0ICYmIGMgPD0gMHgwRUI5XHJcblx0XHR8fCBjID49IDB4MEVCQiAmJiBjIDw9IDB4MEVCQ1xyXG5cdFx0fHwgYyA+PSAweDBFQzggJiYgYyA8PSAweDBFQ0RcclxuXHRcdHx8IGMgPj0gMHgwRjE4ICYmIGMgPD0gMHgwRjE5XHJcblx0XHR8fCBjID09IDB4MEYzNVxyXG5cdFx0fHwgYyA9PSAweDBGMzdcclxuXHRcdHx8IGMgPT0gMHgwRjM5XHJcblx0XHR8fCBjID09IDB4MEYzRVxyXG5cdFx0fHwgYyA9PSAweDBGM0ZcclxuXHRcdHx8IGMgPj0gMHgwRjcxICYmIGMgPD0gMHgwRjg0XHJcblx0XHR8fCBjID49IDB4MEY4NiAmJiBjIDw9IDB4MEY4QlxyXG5cdFx0fHwgYyA+PSAweDBGOTAgJiYgYyA8PSAweDBGOTVcclxuXHRcdHx8IGMgPT0gMHgwRjk3XHJcblx0XHR8fCBjID49IDB4MEY5OSAmJiBjIDw9IDB4MEZBRFxyXG5cdFx0fHwgYyA+PSAweDBGQjEgJiYgYyA8PSAweDBGQjdcclxuXHRcdHx8IGMgPT0gMHgwRkI5XHJcblx0XHR8fCBjID49IDB4MjBEMCAmJiBjIDw9IDB4MjBEQ1xyXG5cdFx0fHwgYyA9PSAweDIwRTFcclxuXHRcdHx8IGMgPj0gMHgzMDJBICYmIGMgPD0gMHgzMDJGXHJcblx0XHR8fCBjID09IDB4MzA5OVxyXG5cdFx0fHwgYyA9PSAweDMwOUFcclxuXHRcdHx8IGMgPT0gMHgwMEI3XHJcblx0XHR8fCBjID09IDB4MDJEMFxyXG5cdFx0fHwgYyA9PSAweDAyRDFcclxuXHRcdHx8IGMgPT0gMHgwMzg3XHJcblx0XHR8fCBjID09IDB4MDY0MFxyXG5cdFx0fHwgYyA9PSAweDBFNDZcclxuXHRcdHx8IGMgPT0gMHgwRUM2XHJcblx0XHR8fCBjID09IDB4MzAwNVxyXG5cdFx0fHwgYyA+PSAweDMwMzEgJiYgYyA8PSAweDMwMzVcclxuXHRcdHx8IGMgPj0gMHgzMDlEICYmIGMgPD0gMHgzMDlFXHJcblx0XHR8fCBjID49IDB4MzBGQyAmJiBjIDw9IDB4MzBGRTtcclxufTtcclxuXHJcblV0aWxpdGllcy5jb2FsZXNjZVRleHQgPSBmdW5jdGlvbihuKSB7XHJcblx0Zm9yICh2YXIgbSA9IG4uZmlyc3RDaGlsZDsgbSAhPSBudWxsOyBtID0gbS5uZXh0U2libGluZykge1xyXG5cdFx0aWYgKG0ubm9kZVR5cGUgPT0gMyAvKk5vZGUuVEVYVF9OT0RFKi8gfHwgbS5ub2RlVHlwZSA9PSA0IC8qTm9kZS5DREFUQV9TRUNUSU9OX05PREUqLykge1xyXG5cdFx0XHR2YXIgcyA9IG0ubm9kZVZhbHVlO1xyXG5cdFx0XHR2YXIgZmlyc3QgPSBtO1xyXG5cdFx0XHRtID0gbS5uZXh0U2libGluZztcclxuXHRcdFx0d2hpbGUgKG0gIT0gbnVsbCAmJiAobS5ub2RlVHlwZSA9PSAzIC8qTm9kZS5URVhUX05PREUqLyB8fCBtLm5vZGVUeXBlID09IDQgLypOb2RlLkNEQVRBX1NFQ1RJT05fTk9ERSovKSkge1xyXG5cdFx0XHRcdHMgKz0gbS5ub2RlVmFsdWU7XHJcblx0XHRcdFx0dmFyIGRlbCA9IG07XHJcblx0XHRcdFx0bSA9IG0ubmV4dFNpYmxpbmc7XHJcblx0XHRcdFx0ZGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGVsKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoZmlyc3Qubm9kZVR5cGUgPT0gNCAvKk5vZGUuQ0RBVEFfU0VDVElPTl9OT0RFKi8pIHtcclxuXHRcdFx0XHR2YXIgcCA9IGZpcnN0LnBhcmVudE5vZGU7XHJcblx0XHRcdFx0aWYgKGZpcnN0Lm5leHRTaWJsaW5nID09IG51bGwpIHtcclxuXHRcdFx0XHRcdHAucmVtb3ZlQ2hpbGQoZmlyc3QpO1xyXG5cdFx0XHRcdFx0cC5hcHBlbmRDaGlsZChwLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocykpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgbmV4dCA9IGZpcnN0Lm5leHRTaWJsaW5nO1xyXG5cdFx0XHRcdFx0cC5yZW1vdmVDaGlsZChmaXJzdCk7XHJcblx0XHRcdFx0XHRwLmluc2VydEJlZm9yZShwLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocyksIG5leHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRmaXJzdC5ub2RlVmFsdWUgPSBzO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChtID09IG51bGwpIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChtLm5vZGVUeXBlID09IDEgLypOb2RlLkVMRU1FTlRfTk9ERSovKSB7XHJcblx0XHRcdFV0aWxpdGllcy5jb2FsZXNjZVRleHQobSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuVXRpbGl0aWVzLmluc3RhbmNlX29mID0gZnVuY3Rpb24obywgYykge1xyXG5cdHdoaWxlIChvICE9IG51bGwpIHtcclxuXHRcdGlmIChvLmNvbnN0cnVjdG9yID09PSBjKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKG8gPT09IE9iamVjdCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRvID0gby5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzO1xyXG5cdH1cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5VdGlsaXRpZXMuZ2V0RWxlbWVudEJ5SWQgPSBmdW5jdGlvbihuLCBpZCkge1xyXG5cdC8vIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGNoZWNrIHRoZSBEVEQgdG8gY2hlY2sgZm9yIGFjdHVhbFxyXG5cdC8vIGF0dHJpYnV0ZXMgb2YgdHlwZSBJRCwgc28gdGhpcyBtYXkgYmUgYSBiaXQgd3JvbmcuXHJcblx0aWYgKG4ubm9kZVR5cGUgPT0gMSAvKk5vZGUuRUxFTUVOVF9OT0RFKi8pIHtcclxuXHRcdGlmIChuLmdldEF0dHJpYnV0ZShcImlkXCIpID09IGlkXHJcblx0XHRcdFx0fHwgbi5nZXRBdHRyaWJ1dGVOUyhudWxsLCBcImlkXCIpID09IGlkKSB7XHJcblx0XHRcdHJldHVybiBuO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRmb3IgKHZhciBtID0gbi5maXJzdENoaWxkOyBtICE9IG51bGw7IG0gPSBtLm5leHRTaWJsaW5nKSB7XHJcblx0XHR2YXIgcmVzID0gVXRpbGl0aWVzLmdldEVsZW1lbnRCeUlkKG0sIGlkKTtcclxuXHRcdGlmIChyZXMgIT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gcmVzO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8vIFhQYXRoRXhjZXB0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuWFBhdGhFeGNlcHRpb24ucHJvdG90eXBlID0ge307XHJcblhQYXRoRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhQYXRoRXhjZXB0aW9uO1xyXG5YUGF0aEV4Y2VwdGlvbi5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFhQYXRoRXhjZXB0aW9uKGMsIGUpIHtcclxuXHR0aGlzLmNvZGUgPSBjO1xyXG5cdHRoaXMuZXhjZXB0aW9uID0gZTtcclxufVxyXG5cclxuWFBhdGhFeGNlcHRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIG1zZyA9IHRoaXMuZXhjZXB0aW9uID8gXCI6IFwiICsgdGhpcy5leGNlcHRpb24udG9TdHJpbmcoKSA6IFwiXCI7XHJcblx0c3dpdGNoICh0aGlzLmNvZGUpIHtcclxuXHRcdGNhc2UgWFBhdGhFeGNlcHRpb24uSU5WQUxJRF9FWFBSRVNTSU9OX0VSUjpcclxuXHRcdFx0cmV0dXJuIFwiSW52YWxpZCBleHByZXNzaW9uXCIgKyBtc2c7XHJcblx0XHRjYXNlIFhQYXRoRXhjZXB0aW9uLlRZUEVfRVJSOlxyXG5cdFx0XHRyZXR1cm4gXCJUeXBlIGVycm9yXCIgKyBtc2c7XHJcblx0fVxyXG59O1xyXG5cclxuWFBhdGhFeGNlcHRpb24uSU5WQUxJRF9FWFBSRVNTSU9OX0VSUiA9IDUxO1xyXG5YUGF0aEV4Y2VwdGlvbi5UWVBFX0VSUiA9IDUyO1xyXG5cclxuLy8gWFBhdGhFeHByZXNzaW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5YUGF0aEV4cHJlc3Npb24ucHJvdG90eXBlID0ge307XHJcblhQYXRoRXhwcmVzc2lvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBYUGF0aEV4cHJlc3Npb247XHJcblhQYXRoRXhwcmVzc2lvbi5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFhQYXRoRXhwcmVzc2lvbihlLCByLCBwKSB7XHJcblx0dGhpcy54cGF0aCA9IHAucGFyc2UoZSk7XHJcblx0dGhpcy5jb250ZXh0ID0gbmV3IFhQYXRoQ29udGV4dCgpO1xyXG5cdHRoaXMuY29udGV4dC5uYW1lc3BhY2VSZXNvbHZlciA9IG5ldyBYUGF0aE5TUmVzb2x2ZXJXcmFwcGVyKHIpO1xyXG59XHJcblxyXG5YUGF0aEV4cHJlc3Npb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24obiwgdCwgcmVzKSB7XHJcblx0dGhpcy5jb250ZXh0LmV4cHJlc3Npb25Db250ZXh0Tm9kZSA9IG47XHJcblx0dmFyIHJlc3VsdCA9IHRoaXMueHBhdGguZXZhbHVhdGUodGhpcy5jb250ZXh0KTtcclxuXHRyZXR1cm4gbmV3IFhQYXRoUmVzdWx0KHJlc3VsdCwgdCk7XHJcbn1cclxuXHJcbi8vIFhQYXRoTlNSZXNvbHZlcldyYXBwZXIgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuWFBhdGhOU1Jlc29sdmVyV3JhcHBlci5wcm90b3R5cGUgPSB7fTtcclxuWFBhdGhOU1Jlc29sdmVyV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBYUGF0aE5TUmVzb2x2ZXJXcmFwcGVyO1xyXG5YUGF0aE5TUmVzb2x2ZXJXcmFwcGVyLnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gWFBhdGhOU1Jlc29sdmVyV3JhcHBlcihyKSB7XHJcblx0dGhpcy54cGF0aE5TUmVzb2x2ZXIgPSByO1xyXG59XHJcblxyXG5YUGF0aE5TUmVzb2x2ZXJXcmFwcGVyLnByb3RvdHlwZS5nZXROYW1lc3BhY2UgPSBmdW5jdGlvbihwcmVmaXgsIG4pIHtcclxuICAgIGlmICh0aGlzLnhwYXRoTlNSZXNvbHZlciA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblx0cmV0dXJuIHRoaXMueHBhdGhOU1Jlc29sdmVyLmxvb2t1cE5hbWVzcGFjZVVSSShwcmVmaXgpO1xyXG59O1xyXG5cclxuLy8gTm9kZVhQYXRoTlNSZXNvbHZlciAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5Ob2RlWFBhdGhOU1Jlc29sdmVyLnByb3RvdHlwZSA9IHt9O1xyXG5Ob2RlWFBhdGhOU1Jlc29sdmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5vZGVYUGF0aE5TUmVzb2x2ZXI7XHJcbk5vZGVYUGF0aE5TUmVzb2x2ZXIuc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBOb2RlWFBhdGhOU1Jlc29sdmVyKG4pIHtcclxuXHR0aGlzLm5vZGUgPSBuO1xyXG5cdHRoaXMubmFtZXNwYWNlUmVzb2x2ZXIgPSBuZXcgTmFtZXNwYWNlUmVzb2x2ZXIoKTtcclxufVxyXG5cclxuTm9kZVhQYXRoTlNSZXNvbHZlci5wcm90b3R5cGUubG9va3VwTmFtZXNwYWNlVVJJID0gZnVuY3Rpb24ocHJlZml4KSB7XHJcblx0cmV0dXJuIHRoaXMubmFtZXNwYWNlUmVzb2x2ZXIuZ2V0TmFtZXNwYWNlKHByZWZpeCwgdGhpcy5ub2RlKTtcclxufTtcclxuXHJcbi8vIFhQYXRoUmVzdWx0IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuWFBhdGhSZXN1bHQucHJvdG90eXBlID0ge307XHJcblhQYXRoUmVzdWx0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhQYXRoUmVzdWx0O1xyXG5YUGF0aFJlc3VsdC5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFhQYXRoUmVzdWx0KHYsIHQpIHtcclxuXHRpZiAodCA9PSBYUGF0aFJlc3VsdC5BTllfVFlQRSkge1xyXG5cdFx0aWYgKHYuY29uc3RydWN0b3IgPT09IFhTdHJpbmcpIHtcclxuXHRcdFx0dCA9IFhQYXRoUmVzdWx0LlNUUklOR19UWVBFO1xyXG5cdFx0fSBlbHNlIGlmICh2LmNvbnN0cnVjdG9yID09PSBYTnVtYmVyKSB7XHJcblx0XHRcdHQgPSBYUGF0aFJlc3VsdC5OVU1CRVJfVFlQRTtcclxuXHRcdH0gZWxzZSBpZiAodi5jb25zdHJ1Y3RvciA9PT0gWEJvb2xlYW4pIHtcclxuXHRcdFx0dCA9IFhQYXRoUmVzdWx0LkJPT0xFQU5fVFlQRTtcclxuXHRcdH0gZWxzZSBpZiAodi5jb25zdHJ1Y3RvciA9PT0gWE5vZGVTZXQpIHtcclxuXHRcdFx0dCA9IFhQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX0lURVJBVE9SX1RZUEU7XHJcblx0XHR9XHJcblx0fVxyXG5cdHRoaXMucmVzdWx0VHlwZSA9IHQ7XHJcblx0c3dpdGNoICh0KSB7XHJcblx0XHRjYXNlIFhQYXRoUmVzdWx0Lk5VTUJFUl9UWVBFOlxyXG5cdFx0XHR0aGlzLm51bWJlclZhbHVlID0gdi5udW1iZXJWYWx1ZSgpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHRjYXNlIFhQYXRoUmVzdWx0LlNUUklOR19UWVBFOlxyXG5cdFx0XHR0aGlzLnN0cmluZ1ZhbHVlID0gdi5zdHJpbmdWYWx1ZSgpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHRjYXNlIFhQYXRoUmVzdWx0LkJPT0xFQU5fVFlQRTpcclxuXHRcdFx0dGhpcy5ib29sZWFuVmFsdWUgPSB2LmJvb2xlYW5WYWx1ZSgpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHRjYXNlIFhQYXRoUmVzdWx0LkFOWV9VTk9SREVSRURfTk9ERV9UWVBFOlxyXG5cdFx0Y2FzZSBYUGF0aFJlc3VsdC5GSVJTVF9PUkRFUkVEX05PREVfVFlQRTpcclxuXHRcdFx0aWYgKHYuY29uc3RydWN0b3IgPT09IFhOb2RlU2V0KSB7XHJcblx0XHRcdFx0dGhpcy5zaW5nbGVOb2RlVmFsdWUgPSB2LmZpcnN0KCk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBYUGF0aFJlc3VsdC5VTk9SREVSRURfTk9ERV9JVEVSQVRPUl9UWVBFOlxyXG5cdFx0Y2FzZSBYUGF0aFJlc3VsdC5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRTpcclxuXHRcdFx0aWYgKHYuY29uc3RydWN0b3IgPT09IFhOb2RlU2V0KSB7XHJcblx0XHRcdFx0dGhpcy5pbnZhbGlkSXRlcmF0b3JTdGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRcdHRoaXMubm9kZXMgPSB2LnRvQXJyYXkoKTtcclxuXHRcdFx0XHR0aGlzLml0ZXJhdG9ySW5kZXggPSAwO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgWFBhdGhSZXN1bHQuVU5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRTpcclxuXHRcdGNhc2UgWFBhdGhSZXN1bHQuT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEU6XHJcblx0XHRcdGlmICh2LmNvbnN0cnVjdG9yID09PSBYTm9kZVNldCkge1xyXG5cdFx0XHRcdHRoaXMubm9kZXMgPSB2LnRvQXJyYXkoKTtcclxuXHRcdFx0XHR0aGlzLnNuYXBzaG90TGVuZ3RoID0gdGhpcy5ub2Rlcy5sZW5ndGg7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdGJyZWFrO1xyXG5cdH1cclxuXHR0aHJvdyBuZXcgWFBhdGhFeGNlcHRpb24oWFBhdGhFeGNlcHRpb24uVFlQRV9FUlIpO1xyXG59O1xyXG5cclxuWFBhdGhSZXN1bHQucHJvdG90eXBlLml0ZXJhdGVOZXh0ID0gZnVuY3Rpb24oKSB7XHJcblx0aWYgKHRoaXMucmVzdWx0VHlwZSAhPSBYUGF0aFJlc3VsdC5VTk9SREVSRURfTk9ERV9JVEVSQVRPUl9UWVBFXHJcblx0XHRcdCYmIHRoaXMucmVzdWx0VHlwZSAhPSBYUGF0aFJlc3VsdC5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRSkge1xyXG5cdFx0dGhyb3cgbmV3IFhQYXRoRXhjZXB0aW9uKFhQYXRoRXhjZXB0aW9uLlRZUEVfRVJSKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMubm9kZXNbdGhpcy5pdGVyYXRvckluZGV4KytdO1xyXG59O1xyXG5cclxuWFBhdGhSZXN1bHQucHJvdG90eXBlLnNuYXBzaG90SXRlbSA9IGZ1bmN0aW9uKGkpIHtcclxuXHRpZiAodGhpcy5yZXN1bHRUeXBlICE9IFhQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEVcclxuXHRcdFx0JiYgdGhpcy5yZXN1bHRUeXBlICE9IFhQYXRoUmVzdWx0Lk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFKSB7XHJcblx0XHR0aHJvdyBuZXcgWFBhdGhFeGNlcHRpb24oWFBhdGhFeGNlcHRpb24uVFlQRV9FUlIpO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5ub2Rlc1tpXTtcclxufTtcclxuXHJcblhQYXRoUmVzdWx0LkFOWV9UWVBFID0gMDtcclxuWFBhdGhSZXN1bHQuTlVNQkVSX1RZUEUgPSAxO1xyXG5YUGF0aFJlc3VsdC5TVFJJTkdfVFlQRSA9IDI7XHJcblhQYXRoUmVzdWx0LkJPT0xFQU5fVFlQRSA9IDM7XHJcblhQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX0lURVJBVE9SX1RZUEUgPSA0O1xyXG5YUGF0aFJlc3VsdC5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRSA9IDU7XHJcblhQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEUgPSA2O1xyXG5YUGF0aFJlc3VsdC5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRSA9IDc7XHJcblhQYXRoUmVzdWx0LkFOWV9VTk9SREVSRURfTk9ERV9UWVBFID0gODtcclxuWFBhdGhSZXN1bHQuRklSU1RfT1JERVJFRF9OT0RFX1RZUEUgPSA5O1xyXG5cclxuLy8gRE9NIDMgWFBhdGggc3VwcG9ydCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5mdW5jdGlvbiBpbnN0YWxsRE9NM1hQYXRoU3VwcG9ydChkb2MsIHApIHtcclxuXHRkb2MuY3JlYXRlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGUsIHIpIHtcclxuXHRcdHRyeSB7XHJcblx0XHRcdHJldHVybiBuZXcgWFBhdGhFeHByZXNzaW9uKGUsIHIsIHApO1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgWFBhdGhFeGNlcHRpb24oWFBhdGhFeGNlcHRpb24uSU5WQUxJRF9FWFBSRVNTSU9OX0VSUiwgZSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHRkb2MuY3JlYXRlTlNSZXNvbHZlciA9IGZ1bmN0aW9uKG4pIHtcclxuXHRcdHJldHVybiBuZXcgTm9kZVhQYXRoTlNSZXNvbHZlcihuKTtcclxuXHR9O1xyXG5cdGRvYy5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGUsIGNuLCByLCB0LCByZXMpIHtcclxuXHRcdGlmICh0IDwgMCB8fCB0ID4gOSkge1xyXG5cdFx0XHR0aHJvdyB7IGNvZGU6IDAsIHRvU3RyaW5nOiBmdW5jdGlvbigpIHsgcmV0dXJuIFwiUmVxdWVzdCB0eXBlIG5vdCBzdXBwb3J0ZWRcIjsgfSB9O1xyXG5cdFx0fVxyXG4gICAgICAgIHJldHVybiBkb2MuY3JlYXRlRXhwcmVzc2lvbihlLCByLCBwKS5ldmFsdWF0ZShjbiwgdCwgcmVzKTtcclxuXHR9O1xyXG59O1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vLyBJbnN0YWxsIERPTSAzIFhQYXRoIHN1cHBvcnQgZm9yIHRoZSBjdXJyZW50IGRvY3VtZW50LlxyXG50cnkge1xyXG5cdHZhciBzaG91bGRJbnN0YWxsID0gdHJ1ZTtcclxuXHR0cnkge1xyXG5cdFx0aWYgKGRvY3VtZW50LmltcGxlbWVudGF0aW9uXHJcblx0XHRcdFx0JiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZVxyXG5cdFx0XHRcdCYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJYUGF0aFwiLCBudWxsKSkge1xyXG5cdFx0XHRzaG91bGRJbnN0YWxsID0gZmFsc2U7XHJcblx0XHR9XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdH1cclxuXHRpZiAoc2hvdWxkSW5zdGFsbCkge1xyXG5cdFx0aW5zdGFsbERPTTNYUGF0aFN1cHBvcnQoZG9jdW1lbnQsIG5ldyBYUGF0aFBhcnNlcigpKTtcclxuXHR9XHJcbn0gY2F0Y2ggKGUpIHtcclxufVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIGV4cG9ydHMgZm9yIG5vZGUuanNcclxuXHJcbmluc3RhbGxET00zWFBhdGhTdXBwb3J0KGV4cG9ydHMsIG5ldyBYUGF0aFBhcnNlcigpKTtcclxuXHJcbmV4cG9ydHMuWFBhdGhSZXN1bHQgPSBYUGF0aFJlc3VsdDtcclxuXHJcbi8vIGhlbHBlclxyXG5leHBvcnRzLnNlbGVjdCA9IGZ1bmN0aW9uKGUsIGRvYywgc2luZ2xlKSB7XHJcblx0cmV0dXJuIGV4cG9ydHMuc2VsZWN0V2l0aFJlc29sdmVyKGUsIGRvYywgbnVsbCwgc2luZ2xlKTtcclxufTtcclxuXHJcbmV4cG9ydHMudXNlTmFtZXNwYWNlcyA9IGZ1bmN0aW9uKG1hcHBpbmdzKSB7XHJcblx0dmFyIHJlc29sdmVyID0ge1xyXG5cdFx0bWFwcGluZ3M6IG1hcHBpbmdzIHx8IHt9LFxyXG5cdFx0bG9va3VwTmFtZXNwYWNlVVJJOiBmdW5jdGlvbihwcmVmaXgpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMubWFwcGluZ3NbcHJlZml4XTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24oZSwgZG9jLCBzaW5nbGUpIHtcclxuXHRcdHJldHVybiBleHBvcnRzLnNlbGVjdFdpdGhSZXNvbHZlcihlLCBkb2MsIHJlc29sdmVyLCBzaW5nbGUpO1xyXG5cdH07XHJcbn07XHJcblxyXG5leHBvcnRzLnNlbGVjdFdpdGhSZXNvbHZlciA9IGZ1bmN0aW9uKGUsIGRvYywgcmVzb2x2ZXIsIHNpbmdsZSkge1xyXG5cdHZhciBleHByZXNzaW9uID0gbmV3IFhQYXRoRXhwcmVzc2lvbihlLCByZXNvbHZlciwgbmV3IFhQYXRoUGFyc2VyKCkpO1xyXG5cdHZhciB0eXBlID0gWFBhdGhSZXN1bHQuQU5ZX1RZUEU7XHJcblxyXG5cdHZhciByZXN1bHQgPSBleHByZXNzaW9uLmV2YWx1YXRlKGRvYywgdHlwZSwgbnVsbCk7XHJcblxyXG5cdGlmIChyZXN1bHQucmVzdWx0VHlwZSA9PSBYUGF0aFJlc3VsdC5TVFJJTkdfVFlQRSkge1xyXG5cdFx0cmVzdWx0ID0gcmVzdWx0LnN0cmluZ1ZhbHVlO1xyXG5cdH1cclxuXHRlbHNlIGlmIChyZXN1bHQucmVzdWx0VHlwZSA9PSBYUGF0aFJlc3VsdC5OVU1CRVJfVFlQRSkge1xyXG5cdFx0cmVzdWx0ID0gcmVzdWx0Lm51bWJlclZhbHVlO1xyXG5cdH1cclxuXHRlbHNlIGlmIChyZXN1bHQucmVzdWx0VHlwZSA9PSBYUGF0aFJlc3VsdC5CT09MRUFOX1RZUEUpIHtcclxuXHRcdHJlc3VsdCA9IHJlc3VsdC5ib29sZWFuVmFsdWU7XHJcblx0fVxyXG5cdGVsc2Uge1xyXG5cdFx0cmVzdWx0ID0gcmVzdWx0Lm5vZGVzO1xyXG5cdFx0aWYgKHNpbmdsZSkge1xyXG5cdFx0XHRyZXN1bHQgPSByZXN1bHRbMF07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuZXhwb3J0cy5zZWxlY3QxID0gZnVuY3Rpb24oZSwgZG9jKSB7XHJcblx0cmV0dXJuIGV4cG9ydHMuc2VsZWN0KGUsIGRvYywgdHJ1ZSk7XHJcbn07XHJcblxyXG4vLyBlbmQgbm9uLW5vZGUgd3JhcHBlclxyXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogeHBhdGgpO1xyXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSAwO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVtaXR0ZXIuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gMTtcbiAgZWxzZVxuICAgIHJldCA9IGVtaXR0ZXIuX2V2ZW50c1t0eXBlXS5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMuRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4vbGliL0Rpc3BhdGNoZXInKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRGlzcGF0Y2hlclxuICogXG4gKiBAcHJldmVudE11bmdlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgX3ByZWZpeCA9ICdJRF8nO1xuXG4vKipcbiAqIERpc3BhdGNoZXIgaXMgdXNlZCB0byBicm9hZGNhc3QgcGF5bG9hZHMgdG8gcmVnaXN0ZXJlZCBjYWxsYmFja3MuIFRoaXMgaXNcbiAqIGRpZmZlcmVudCBmcm9tIGdlbmVyaWMgcHViLXN1YiBzeXN0ZW1zIGluIHR3byB3YXlzOlxuICpcbiAqICAgMSkgQ2FsbGJhY2tzIGFyZSBub3Qgc3Vic2NyaWJlZCB0byBwYXJ0aWN1bGFyIGV2ZW50cy4gRXZlcnkgcGF5bG9hZCBpc1xuICogICAgICBkaXNwYXRjaGVkIHRvIGV2ZXJ5IHJlZ2lzdGVyZWQgY2FsbGJhY2suXG4gKiAgIDIpIENhbGxiYWNrcyBjYW4gYmUgZGVmZXJyZWQgaW4gd2hvbGUgb3IgcGFydCB1bnRpbCBvdGhlciBjYWxsYmFja3MgaGF2ZVxuICogICAgICBiZWVuIGV4ZWN1dGVkLlxuICpcbiAqIEZvciBleGFtcGxlLCBjb25zaWRlciB0aGlzIGh5cG90aGV0aWNhbCBmbGlnaHQgZGVzdGluYXRpb24gZm9ybSwgd2hpY2hcbiAqIHNlbGVjdHMgYSBkZWZhdWx0IGNpdHkgd2hlbiBhIGNvdW50cnkgaXMgc2VsZWN0ZWQ6XG4gKlxuICogICB2YXIgZmxpZ2h0RGlzcGF0Y2hlciA9IG5ldyBEaXNwYXRjaGVyKCk7XG4gKlxuICogICAvLyBLZWVwcyB0cmFjayBvZiB3aGljaCBjb3VudHJ5IGlzIHNlbGVjdGVkXG4gKiAgIHZhciBDb3VudHJ5U3RvcmUgPSB7Y291bnRyeTogbnVsbH07XG4gKlxuICogICAvLyBLZWVwcyB0cmFjayBvZiB3aGljaCBjaXR5IGlzIHNlbGVjdGVkXG4gKiAgIHZhciBDaXR5U3RvcmUgPSB7Y2l0eTogbnVsbH07XG4gKlxuICogICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgYmFzZSBmbGlnaHQgcHJpY2Ugb2YgdGhlIHNlbGVjdGVkIGNpdHlcbiAqICAgdmFyIEZsaWdodFByaWNlU3RvcmUgPSB7cHJpY2U6IG51bGx9XG4gKlxuICogV2hlbiBhIHVzZXIgY2hhbmdlcyB0aGUgc2VsZWN0ZWQgY2l0eSwgd2UgZGlzcGF0Y2ggdGhlIHBheWxvYWQ6XG4gKlxuICogICBmbGlnaHREaXNwYXRjaGVyLmRpc3BhdGNoKHtcbiAqICAgICBhY3Rpb25UeXBlOiAnY2l0eS11cGRhdGUnLFxuICogICAgIHNlbGVjdGVkQ2l0eTogJ3BhcmlzJ1xuICogICB9KTtcbiAqXG4gKiBUaGlzIHBheWxvYWQgaXMgZGlnZXN0ZWQgYnkgYENpdHlTdG9yZWA6XG4gKlxuICogICBmbGlnaHREaXNwYXRjaGVyLnJlZ2lzdGVyKGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAqICAgICBpZiAocGF5bG9hZC5hY3Rpb25UeXBlID09PSAnY2l0eS11cGRhdGUnKSB7XG4gKiAgICAgICBDaXR5U3RvcmUuY2l0eSA9IHBheWxvYWQuc2VsZWN0ZWRDaXR5O1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogV2hlbiB0aGUgdXNlciBzZWxlY3RzIGEgY291bnRyeSwgd2UgZGlzcGF0Y2ggdGhlIHBheWxvYWQ6XG4gKlxuICogICBmbGlnaHREaXNwYXRjaGVyLmRpc3BhdGNoKHtcbiAqICAgICBhY3Rpb25UeXBlOiAnY291bnRyeS11cGRhdGUnLFxuICogICAgIHNlbGVjdGVkQ291bnRyeTogJ2F1c3RyYWxpYSdcbiAqICAgfSk7XG4gKlxuICogVGhpcyBwYXlsb2FkIGlzIGRpZ2VzdGVkIGJ5IGJvdGggc3RvcmVzOlxuICpcbiAqICAgQ291bnRyeVN0b3JlLmRpc3BhdGNoVG9rZW4gPSBmbGlnaHREaXNwYXRjaGVyLnJlZ2lzdGVyKGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAqICAgICBpZiAocGF5bG9hZC5hY3Rpb25UeXBlID09PSAnY291bnRyeS11cGRhdGUnKSB7XG4gKiAgICAgICBDb3VudHJ5U3RvcmUuY291bnRyeSA9IHBheWxvYWQuc2VsZWN0ZWRDb3VudHJ5O1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogV2hlbiB0aGUgY2FsbGJhY2sgdG8gdXBkYXRlIGBDb3VudHJ5U3RvcmVgIGlzIHJlZ2lzdGVyZWQsIHdlIHNhdmUgYSByZWZlcmVuY2VcbiAqIHRvIHRoZSByZXR1cm5lZCB0b2tlbi4gVXNpbmcgdGhpcyB0b2tlbiB3aXRoIGB3YWl0Rm9yKClgLCB3ZSBjYW4gZ3VhcmFudGVlXG4gKiB0aGF0IGBDb3VudHJ5U3RvcmVgIGlzIHVwZGF0ZWQgYmVmb3JlIHRoZSBjYWxsYmFjayB0aGF0IHVwZGF0ZXMgYENpdHlTdG9yZWBcbiAqIG5lZWRzIHRvIHF1ZXJ5IGl0cyBkYXRhLlxuICpcbiAqICAgQ2l0eVN0b3JlLmRpc3BhdGNoVG9rZW4gPSBmbGlnaHREaXNwYXRjaGVyLnJlZ2lzdGVyKGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAqICAgICBpZiAocGF5bG9hZC5hY3Rpb25UeXBlID09PSAnY291bnRyeS11cGRhdGUnKSB7XG4gKiAgICAgICAvLyBgQ291bnRyeVN0b3JlLmNvdW50cnlgIG1heSBub3QgYmUgdXBkYXRlZC5cbiAqICAgICAgIGZsaWdodERpc3BhdGNoZXIud2FpdEZvcihbQ291bnRyeVN0b3JlLmRpc3BhdGNoVG9rZW5dKTtcbiAqICAgICAgIC8vIGBDb3VudHJ5U3RvcmUuY291bnRyeWAgaXMgbm93IGd1YXJhbnRlZWQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiAgICAgICAvLyBTZWxlY3QgdGhlIGRlZmF1bHQgY2l0eSBmb3IgdGhlIG5ldyBjb3VudHJ5XG4gKiAgICAgICBDaXR5U3RvcmUuY2l0eSA9IGdldERlZmF1bHRDaXR5Rm9yQ291bnRyeShDb3VudHJ5U3RvcmUuY291bnRyeSk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBUaGUgdXNhZ2Ugb2YgYHdhaXRGb3IoKWAgY2FuIGJlIGNoYWluZWQsIGZvciBleGFtcGxlOlxuICpcbiAqICAgRmxpZ2h0UHJpY2VTdG9yZS5kaXNwYXRjaFRva2VuID1cbiAqICAgICBmbGlnaHREaXNwYXRjaGVyLnJlZ2lzdGVyKGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAqICAgICAgIHN3aXRjaCAocGF5bG9hZC5hY3Rpb25UeXBlKSB7XG4gKiAgICAgICAgIGNhc2UgJ2NvdW50cnktdXBkYXRlJzpcbiAqICAgICAgICAgY2FzZSAnY2l0eS11cGRhdGUnOlxuICogICAgICAgICAgIGZsaWdodERpc3BhdGNoZXIud2FpdEZvcihbQ2l0eVN0b3JlLmRpc3BhdGNoVG9rZW5dKTtcbiAqICAgICAgICAgICBGbGlnaHRQcmljZVN0b3JlLnByaWNlID1cbiAqICAgICAgICAgICAgIGdldEZsaWdodFByaWNlU3RvcmUoQ291bnRyeVN0b3JlLmNvdW50cnksIENpdHlTdG9yZS5jaXR5KTtcbiAqICAgICAgICAgICBicmVhaztcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFRoZSBgY291bnRyeS11cGRhdGVgIHBheWxvYWQgd2lsbCBiZSBndWFyYW50ZWVkIHRvIGludm9rZSB0aGUgc3RvcmVzJ1xuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MgaW4gb3JkZXI6IGBDb3VudHJ5U3RvcmVgLCBgQ2l0eVN0b3JlYCwgdGhlblxuICogYEZsaWdodFByaWNlU3RvcmVgLlxuICovXG5cbnZhciBEaXNwYXRjaGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGlzcGF0Y2hlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGlzcGF0Y2hlcik7XG5cbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICB0aGlzLl9pc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgdGhpcy5faXNIYW5kbGVkID0ge307XG4gICAgdGhpcy5faXNQZW5kaW5nID0ge307XG4gICAgdGhpcy5fbGFzdElEID0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdpdGggZXZlcnkgZGlzcGF0Y2hlZCBwYXlsb2FkLiBSZXR1cm5zXG4gICAqIGEgdG9rZW4gdGhhdCBjYW4gYmUgdXNlZCB3aXRoIGB3YWl0Rm9yKClgLlxuICAgKi9cblxuICBEaXNwYXRjaGVyLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGNhbGxiYWNrKSB7XG4gICAgdmFyIGlkID0gX3ByZWZpeCArIHRoaXMuX2xhc3RJRCsrO1xuICAgIHRoaXMuX2NhbGxiYWNrc1tpZF0gPSBjYWxsYmFjaztcbiAgICByZXR1cm4gaWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjYWxsYmFjayBiYXNlZCBvbiBpdHMgdG9rZW4uXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyKGlkKSB7XG4gICAgIXRoaXMuX2NhbGxiYWNrc1tpZF0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGlzcGF0Y2hlci51bnJlZ2lzdGVyKC4uLik6IGAlc2AgZG9lcyBub3QgbWFwIHRvIGEgcmVnaXN0ZXJlZCBjYWxsYmFjay4nLCBpZCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbaWRdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgdGhlIGNhbGxiYWNrcyBzcGVjaWZpZWQgdG8gYmUgaW52b2tlZCBiZWZvcmUgY29udGludWluZyBleGVjdXRpb25cbiAgICogb2YgdGhlIGN1cnJlbnQgY2FsbGJhY2suIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIHVzZWQgYnkgYSBjYWxsYmFjayBpblxuICAgKiByZXNwb25zZSB0byBhIGRpc3BhdGNoZWQgcGF5bG9hZC5cbiAgICovXG5cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUud2FpdEZvciA9IGZ1bmN0aW9uIHdhaXRGb3IoaWRzKSB7XG4gICAgIXRoaXMuX2lzRGlzcGF0Y2hpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGlzcGF0Y2hlci53YWl0Rm9yKC4uLik6IE11c3QgYmUgaW52b2tlZCB3aGlsZSBkaXNwYXRjaGluZy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGlkcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIHZhciBpZCA9IGlkc1tpaV07XG4gICAgICBpZiAodGhpcy5faXNQZW5kaW5nW2lkXSkge1xuICAgICAgICAhdGhpcy5faXNIYW5kbGVkW2lkXSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdEaXNwYXRjaGVyLndhaXRGb3IoLi4uKTogQ2lyY3VsYXIgZGVwZW5kZW5jeSBkZXRlY3RlZCB3aGlsZSAnICsgJ3dhaXRpbmcgZm9yIGAlc2AuJywgaWQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAhdGhpcy5fY2FsbGJhY2tzW2lkXSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdEaXNwYXRjaGVyLndhaXRGb3IoLi4uKTogYCVzYCBkb2VzIG5vdCBtYXAgdG8gYSByZWdpc3RlcmVkIGNhbGxiYWNrLicsIGlkKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9pbnZva2VDYWxsYmFjayhpZCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgcGF5bG9hZCB0byBhbGwgcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gZGlzcGF0Y2gocGF5bG9hZCkge1xuICAgICEhdGhpcy5faXNEaXNwYXRjaGluZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdEaXNwYXRjaC5kaXNwYXRjaCguLi4pOiBDYW5ub3QgZGlzcGF0Y2ggaW4gdGhlIG1pZGRsZSBvZiBhIGRpc3BhdGNoLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdGFydERpc3BhdGNoaW5nKHBheWxvYWQpO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzUGVuZGluZ1tpZF0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnZva2VDYWxsYmFjayhpZCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX3N0b3BEaXNwYXRjaGluZygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSXMgdGhpcyBEaXNwYXRjaGVyIGN1cnJlbnRseSBkaXNwYXRjaGluZy5cbiAgICovXG5cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUuaXNEaXNwYXRjaGluZyA9IGZ1bmN0aW9uIGlzRGlzcGF0Y2hpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzRGlzcGF0Y2hpbmc7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGwgdGhlIGNhbGxiYWNrIHN0b3JlZCB3aXRoIHRoZSBnaXZlbiBpZC4gQWxzbyBkbyBzb21lIGludGVybmFsXG4gICAqIGJvb2trZWVwaW5nLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUuX2ludm9rZUNhbGxiYWNrID0gZnVuY3Rpb24gX2ludm9rZUNhbGxiYWNrKGlkKSB7XG4gICAgdGhpcy5faXNQZW5kaW5nW2lkXSA9IHRydWU7XG4gICAgdGhpcy5fY2FsbGJhY2tzW2lkXSh0aGlzLl9wZW5kaW5nUGF5bG9hZCk7XG4gICAgdGhpcy5faXNIYW5kbGVkW2lkXSA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB1cCBib29ra2VlcGluZyBuZWVkZWQgd2hlbiBkaXNwYXRjaGluZy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLl9zdGFydERpc3BhdGNoaW5nID0gZnVuY3Rpb24gX3N0YXJ0RGlzcGF0Y2hpbmcocGF5bG9hZCkge1xuICAgIGZvciAodmFyIGlkIGluIHRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgdGhpcy5faXNQZW5kaW5nW2lkXSA9IGZhbHNlO1xuICAgICAgdGhpcy5faXNIYW5kbGVkW2lkXSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9wZW5kaW5nUGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgdGhpcy5faXNEaXNwYXRjaGluZyA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFyIGJvb2trZWVwaW5nIHVzZWQgZm9yIGRpc3BhdGNoaW5nLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUuX3N0b3BEaXNwYXRjaGluZyA9IGZ1bmN0aW9uIF9zdG9wRGlzcGF0Y2hpbmcoKSB7XG4gICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdQYXlsb2FkO1xuICAgIHRoaXMuX2lzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgfTtcblxuICByZXR1cm4gRGlzcGF0Y2hlcjtcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzcGF0Y2hlcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaW52YXJpYW50XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdJbnZhcmlhbnQgVmlvbGF0aW9uOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDsiLCIvKiFcbiAqIG5vZGUtY2FsZW5kYXJcbiAqIENvcHlyaWdodChjKSAyMDEzIEFybWluIFRhbXphcmlhbiA8dGFtemFyaWFuMTk4OUBnbWFpbC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgX0RBWVNfSU5fTU9OVEggPSBbMCwgMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG4gICAgdmFyIF9EQVlTX0JFRk9SRV9NT05USCA9IFstMSwgMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBjbGRyID0gcmVxdWlyZShcImNsZHJcIik7XG4gICAgfVxuICAgIGNhdGNoKGVycikge1xuICAgICAgY2xkciA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdCB0aGUgcHJvdmlkZWQgd2Vla2RheSBpbmRleCBmcm9tIHRoZSBKYXZhc2NyaXB0IGluZGV4IHNjaGVtZVxuICAgICAqIChTVU49MCwgTU9OPTEsIC4uLikgdG8gdGhlIFB5dGhvbiBzY2hlbWUgKE1PTj0wLCBUVUU9MSwgLi4uKVxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2FkanVzdFdlZWtkYXkod2Vla2RheSkge1xuICAgICAgcmV0dXJuIHdlZWtkYXkgPiAwID8gd2Vla2RheSAtIDEgOiA2XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB3aWRlIG9yIGFiYnJldmlhdGVkIGRheSBuYW1lcyBmb3IgYSBzcGVjaWZpZWQgbG9jYWxlLlxuICAgICAqIElmIGNsZHIgaXMgbm90IGluc3RhbGxlZCB2YWx1ZXMgZGVmYXVsdCB0byB0aGF0IGZvciBsb2NhbGUgZW5fVVMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFiYnJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbG9jYWxlXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2V4dHJhY3RMb2NhbGVEYXlzKGFiYnIsIGxvY2FsZSkge1xuICAgICAgc2hvcnQgPSB0eXBlb2YoYWJicikgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IGFiYnI7XG5cbiAgICAgIGlmKGFiYnIpIHtcbiAgICAgICAgcmV0dXJuIGNsZHIgPyBjbGRyLmV4dHJhY3REYXlOYW1lcyhsb2NhbGUpLmZvcm1hdC5hYmJyZXZpYXRlZCA6IFsnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnLCAnU3VuJ107XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNsZHIgPyBjbGRyLmV4dHJhY3REYXlOYW1lcyhsb2NhbGUpLmZvcm1hdC53aWRlIDogWydNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5JywgJ1N1bmRheSddO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgd2lkZSBvciBhYmJyZXZpYXRlZCBtb250aCBuYW1lcyBmb3IgYSBzcGVjaWZpZWQgbG9jYWxlLlxuICAgICAqIElmIGNsZHIgaXMgbm90IGluc3RhbGxlZCB2YWx1ZXMgZGVmYXVsdCB0byB0aGF0IGZvciBsb2NhbGUgZW5fVVMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFiYnJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbG9jYWxlXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2V4dHJhY3RMb2NhbGVNb250aHMoYWJiciwgbG9jYWxlKSB7XG4gICAgICBzaG9ydCA9IHR5cGVvZihhYmJyKSA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogYWJicjtcblxuICAgICAgdmFyIG1vbnRocyA9IFtdXG4gICAgICBpZihhYmJyKSB7XG4gICAgICAgIG1vbnRocyA9IGNsZHIgPyBjbGRyLmV4dHJhY3RNb250aE5hbWVzKGxvY2FsZSkuZm9ybWF0LmFiYnJldmlhdGVkIDogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1vbnRocyA9IGNsZHIgPyBjbGRyLmV4dHJhY3RNb250aE5hbWVzKGxvY2FsZSkuZm9ybWF0LndpZGUgOiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXTtcbiAgICAgIH1cblxuICAgICAgbW9udGhzLnVuc2hpZnQoJycpO1xuICAgICAgcmV0dXJuIG1vbnRocztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgb3JkaW5hbCB0aW1lIGZyb20gZ2l2ZW4geWVhciwgbW9udGgsIGRheSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geWVhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtb250aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXlcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfdG9vcmRpbmFsKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgICAgIHZhciBkYXlzX2JlZm9yZV95ZWFyID0gKCh5ZWFyIC0gMSkgKiAzNjUpICsgTWF0aC5mbG9vcigoeWVhciAtIDEpIC8gNCkgLSBNYXRoLmZsb29yKCh5ZWFyIC0gMSkgLyAxMDApICsgTWF0aC5mbG9vcigoeWVhciAtIDEpIC8gNDAwKTtcbiAgICAgIHZhciBkYXlzX2JlZm9yZV9tb250aCA9IF9EQVlTX0JFRk9SRV9NT05USFttb250aF0gKyAobW9udGggPiAyICYmIGlzbGVhcCh5ZWFyKSA/IDEgOiAwKTtcbiAgICAgIHJldHVybiAoZGF5c19iZWZvcmVfeWVhciArIGRheXNfYmVmb3JlX21vbnRoICsgZGF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdHJ1ZSBmb3IgbGVhcCB5ZWFycywgZmFsc2UgZm9yIG5vbi1sZWFwIHllYXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXJcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzbGVhcCh5ZWFyKSB7XG4gICAgICByZXR1cm4geWVhciAlIDQgPT09IDAgJiYgKHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBudW1iZXIgb2YgbGVhcCB5ZWFycyBpbiByYW5nZSBbeTEsIHkyKS5cbiAgICAgKiBBc3N1bWVzIHkxIDw9IHkyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkyXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsZWFwZGF5cyh5MSwgeTIpIHtcbiAgICAgIHkxLS07XG4gICAgICB5Mi0tO1xuICAgICAgcmV0dXJuIChNYXRoLmZsb29yKHkyLzQpIC0gTWF0aC5mbG9vcih5MS80KSkgLSAoTWF0aC5mbG9vcih5Mi8xMDApIC0gTWF0aC5mbG9vcih5MS8xMDApKSArIChNYXRoLmZsb29yKHkyLzQwMCkgLSBNYXRoLmZsb29yKHkxLzQwMCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gc3RhcnRpbmcgd2Vla2RheSAoMC02IH4gTW9uLVN1bikgYW5kIG51bWJlciBvZiBkYXlzICgyOC0zMSkgZm9yXG4gICAgICogeWVhciwgbW9udGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geWVhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtb250aFxuICAgICAqIEB0aHJvd3Mge0lsbGVnYWxNb250aEVycm9yfSBJZiB0aGUgcHJvdmlkZWQgbW9udGggaXMgaW52YWxpZC5cbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vbnRocmFuZ2UoeWVhciwgbW9udGgpIHtcbiAgICAgIGlmKG1vbnRoIDwgMSB8fCBtb250aCA+IDEyKSB7XG4gICAgICAgIHRocm93IG5ldyBJbGxlZ2FsTW9udGhFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF5MSA9IHdlZWtkYXkoeWVhciwgbW9udGgsIDEpO1xuICAgICAgdmFyIG5kYXlzID0gX0RBWVNfSU5fTU9OVEhbbW9udGhdICsgKG1vbnRoID09PSAyICYmIGlzbGVhcCh5ZWFyKSk7XG5cbiAgICAgIHJldHVybiBbZGF5MSwgbmRheXNdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsb2NhbGUgZm9yIHVzZSBpbiBleHRyYWN0aW5nIG1vbnRoIGFuZCB3ZWVrZGF5IG5hbWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxvY2FsZVxuICAgICAqIEB0aHJvd3Mge0lsbGVnYWxMb2NhbGVFcnJvcn0gSWYgdGhlIHByb3ZpZGVkIGxvY2FsZSBpcyBpbnZhbGlkLlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0bG9jYWxlKGxvY2FsZSkge1xuICAgICAgbG9jYWxlID0gdHlwZW9mKGxvY2FsZSkgPT09IFwidW5kZWZpbmVkXCIgPyBcImVuX1VTXCIgOiBsb2NhbGU7XG5cbiAgICAgIGlmKChjbGRyICYmIChjbGRyLmxvY2FsZUlkcy5pbmRleE9mKGxvY2FsZS5yZXBsYWNlKC8tL2csICdfJykudG9Mb3dlckNhc2UoKSkgPT09IC0xKSkgfHwgKCFjbGRyICYmICgobG9jYWxlLnJlcGxhY2UoLy0vZywgJ18nKS50b0xvd2VyQ2FzZSgpICE9PSBcImVuX3VzXCIpKSkpIHtcbiAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsTG9jYWxlRXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kYXlfbmFtZSAgID0gX2V4dHJhY3RMb2NhbGVEYXlzKGZhbHNlLCBsb2NhbGUpO1xuICAgICAgdGhpcy5kYXlfYWJiciAgID0gX2V4dHJhY3RMb2NhbGVEYXlzKHRydWUsIGxvY2FsZSk7XG4gICAgICB0aGlzLm1vbnRoX25hbWUgPSBfZXh0cmFjdExvY2FsZU1vbnRocyhmYWxzZSwgbG9jYWxlKTtcbiAgICAgIHRoaXMubW9udGhfYWJiciA9IF9leHRyYWN0TG9jYWxlTW9udGhzKHRydWUsIGxvY2FsZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAgKiBVbnJlbGF0ZWQgYnV0IGhhbmR5IGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBVbml4IHRpbWVzdGFtcCBmcm9tIEdNVC5cbiAgICAgICpcbiAgICAgICogQHBhcmFtIHtBcnJheX0gdHVwbGVcbiAgICAgICogQHRocm93cyB7SWxsZWdhbE1vbnRoRXJyb3J9IElmIHRoZSBwcm92aWRlZCBtb250aCBlbGVtZW50IGlzIGludmFsaWQuXG4gICAgICAqIEB0aHJvd3Mge0lsbGVnYWxEYXlFcnJvcn0gSWYgdGhlIHByb3ZpZGVkIGRheSBlbGVtZW50IGlzIGludmFsaWQuXG4gICAgICAqIEBhcGkgcHVibGljXG4gICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWVnbSh0aW1lZ210KSB7XG4gICAgICB2YXIgeWVhciAgID0gdGltZWdtdFswXTtcbiAgICAgIHZhciBtb250aCAgPSB0aW1lZ210WzFdO1xuICAgICAgdmFyIGRheSAgICA9IHRpbWVnbXRbMl07XG4gICAgICB2YXIgaG91ciAgID0gdGltZWdtdFszXTtcbiAgICAgIHZhciBtaW51dGUgPSB0aW1lZ210WzRdO1xuICAgICAgdmFyIHNlY29uZCA9IHRpbWVnbXRbNV07XG5cbiAgICAgIGlmKG1vbnRoIDwgMSB8fCBtb250aCA+IDEyKSB7XG4gICAgICAgIHRocm93IG5ldyBJbGxlZ2FsTW9udGhFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICBpZihkYXkgPCAxIHx8IGRheSA+IChfREFZU19JTl9NT05USFttb250aF0gKyAobW9udGggPT09IDIgJiYgaXNsZWFwKHllYXIpKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxEYXlFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICBpZihob3VyIDwgMCB8fCBob3VyID4gMjMgfHwgbWludXRlIDwgMCB8fCBtaW51dGUgPiA1OSB8fCBzZWNvbmQgPCAwIHx8IHNlY29uZCA+IDU5KSB7XG4gICAgICAgIHRocm93IG5ldyBJbGxlZ2FsVGltZUVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXlzID0gX3Rvb3JkaW5hbCh5ZWFyLCBtb250aCwgMSkgLSA3MTkxNjMgKyBkYXkgLSAxO1xuICAgICAgdmFyIGhvdXJzID0gKGRheXMgKiAyNCkgKyBob3VyO1xuICAgICAgdmFyIG1pbnV0ZXMgPSAoaG91cnMgKiA2MCkgKyBtaW51dGU7XG4gICAgICB2YXIgc2Vjb25kcyA9IChtaW51dGVzICogNjApICsgc2Vjb25kO1xuXG4gICAgICByZXR1cm4gc2Vjb25kcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gd2Vla2RheSAoMC02IH4gTW9uLVN1bikgZm9yIHllYXIgKDE5NzAtLi4uKSwgbW9udGggKDEtMTIpLFxuICAgICAqIGRheSAoMS0zMSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geWVhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtb250aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXlcbiAgICAgKiBAdGhyb3dzIHtJbGxlZ2FsTW9udGhFcnJvcn0gSWYgdGhlIHByb3ZpZGVkIG1vbnRoIGVsZW1lbnQgaXMgaW52YWxpZC5cbiAgICAgKiBAdGhyb3dzIHtJbGxlZ2FsRGF5RXJyb3J9IElmIHRoZSBwcm92aWRlZCBkYXkgZWxlbWVudCBpcyBpbnZhbGlkLlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2Vla2RheSh5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgICBpZihtb250aCA8IDEgfHwgbW9udGggPiAxMikge1xuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbE1vbnRoRXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgaWYoZGF5IDwgMSB8fCBkYXkgPiAoX0RBWVNfSU5fTU9OVEhbbW9udGhdICsgKG1vbnRoID09PSAyICYmIGlzbGVhcCh5ZWFyKSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBJbGxlZ2FsRGF5RXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSk7XG4gICAgICByZXR1cm4gX2FkanVzdFdlZWtkYXkoZGF0ZS5nZXREYXkoKSk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQmFzZSBjYWxlbmRhciBjbGFzcy4gVGhpcyBjbGFzcyBkb2Vzbid0IGRvIGFueSBmb3JtYXR0aW5nLiBJdCBzaW1wbHlcbiAgICAgKiBwcm92aWRlcyBkYXRhIHRvIHN1YmNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZmlyc3R3ZWVrZGF5XG4gICAgICogQHRocm93cyB7SWxsZWdhbFdlZWtkYXlFcnJvcn0gSWYgdGhlIHByb3ZpZGVkIGZpcnN0d2Vla2RheSBpcyBpbnZhbGlkLlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2FsZW5kYXIoZmlyc3R3ZWVrZGF5KSB7XG4gICAgICB0aGlzLl9maXJzdHdlZWtkYXkgPSB0eXBlb2YoZmlyc3R3ZWVrZGF5KSA9PT0gXCJ1bmRlZmluZWRcIiA/IDAgOiBmaXJzdHdlZWtkYXk7XG5cbiAgICAgIGlmKGZpcnN0d2Vla2RheSA8IDAgfHwgZmlyc3R3ZWVrZGF5ID4gNikge1xuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbFdlZWtkYXlFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vbmVkYXkgPSAxMDAwICogNjAgKiA2MCAqIDI0O1xuICAgICAgdGhpcy5fb25laG91ciA9IDEwMDAgKiA2MCAqIDYwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHRVQtZXIgZm9yIGZpcnN0d2Vla2RheVxuICAgICAqXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0Zmlyc3R3ZWVrZGF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyc3R3ZWVrZGF5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTRVQtZXIgZm9yIGZpcnN0d2Vla2RheVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZpcnN0d2Vla2RheVxuICAgICAqIEB0aHJvd3Mge0lsbGVnYWxXZWVrZGF5RXJyb3J9IElmIHRoZSBwcm92aWRlZCBmaXJzdHdlZWtkYXkgaXMgaW52YWxpZC5cbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5zZXRmaXJzdHdlZWtkYXkgPSBmdW5jdGlvbihmaXJzdHdlZWtkYXkpIHtcbiAgICAgIGlmKGZpcnN0d2Vla2RheSA8IDAgfHwgZmlyc3R3ZWVrZGF5ID4gNikge1xuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbFdlZWtkYXlFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9maXJzdHdlZWtkYXkgPSBmaXJzdHdlZWtkYXk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBmb3Igb25lIHdlZWsgb2Ygd2Vla2RheSBudW1iZXJzIHN0YXJ0aW5nIHdpdGggdGhlXG4gICAgICogY29uZmlndXJlZCBmaXJzdCBvbmUuXG4gICAgICpcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pdGVyd2Vla2RheXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB3ZWVrZGF5cyA9IFtdO1xuICAgICAgZm9yKHZhciBpID0gdGhpcy5fZmlyc3R3ZWVrZGF5OyBpIDwgdGhpcy5fZmlyc3R3ZWVrZGF5ICsgNzsgaSsrKSB7XG4gICAgICAgIHdlZWtkYXlzLnB1c2goaSAlIDcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gd2Vla2RheXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBmb3Igb25lIG1vbnRoLiBUaGUgYXJyYXkgd2lsbCBjb250YWluIERhdGVcbiAgICAgKiB2YWx1ZXMgYW5kIHdpbGwgYWx3YXlzIGl0ZXJhdGUgdGhyb3VnaCBjb21wbGV0ZSB3ZWVrcywgc28gaXQgd2lsbCB5aWVsZFxuICAgICAqIGRhdGVzIG91dHNpZGUgdGhlIHNwZWNpZmllZCBtb250aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1vbnRoXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pdGVybW9udGhkYXRlcyA9IGZ1bmN0aW9uKHllYXIsIG1vbnRoKSB7XG4gICAgICBpZihtb250aCA8IDEgfHwgbW9udGggPiAxMikge1xuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbE1vbnRoRXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIDEpO1xuICAgICAgdmFyIGRheSA9IF9hZGp1c3RXZWVrZGF5KGRhdGUuZ2V0RGF5KCkpO1xuICAgICAgdmFyIGRheXMgPSAoZGF5IC0gdGhpcy5fZmlyc3R3ZWVrZGF5KSAgPj0gMCA/IChkYXkgLSB0aGlzLl9maXJzdHdlZWtkYXkpICUgNyA6IDcgKyAoZGF5IC0gdGhpcy5fZmlyc3R3ZWVrZGF5KTtcblxuICAgICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpIC0gKGRheXMgKiB0aGlzLl9vbmVkYXkpKTtcblxuICAgICAgdmFyIGRhdGVzID0gW107XG4gICAgICB3aGlsZSh0cnVlKSB7XG4gICAgICAgIGRhdGVzLnB1c2gobmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpKTtcblxuICAgICAgICB2YXIgY3VycmVudERhdGUgPSBkYXRlLmdldERhdGUoKTtcbiAgICAgICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgdGhpcy5fb25lZGF5KTtcblxuICAgICAgICAvLyBIYWNrIHRvIGFjY291bnQgZm9yIERTVFxuICAgICAgICB3aGlsZShkYXRlLmdldERhdGUoKSA9PT0gY3VycmVudERhdGUpIHtcbiAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyB0aGlzLl9vbmVob3VyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGRhdGUuZ2V0TW9udGgoKSAhPT0gbW9udGggLSAxICYmIF9hZGp1c3RXZWVrZGF5KGRhdGUuZ2V0RGF5KCkpID09PSB0aGlzLl9maXJzdHdlZWtkYXkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0ZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMaWtlIGl0ZXJtb250aGRhdGVzKCksIGJ1dCB3aWxsIHlpZWxkIGRheSBudW1iZXJzLiBGb3IgZGF5cyBvdXRzaWRlXG4gICAgICogdGhlIHNwZWNpZmllZCBtb250aCB0aGUgZGF5IG51bWJlciBpcyAwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbW9udGhcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pdGVybW9udGhkYXlzID0gZnVuY3Rpb24oeWVhciwgbW9udGgpIHtcbiAgICAgIHJldHVybiB0aGlzLml0ZXJtb250aGRhdGVzKHllYXIsIG1vbnRoKS5tYXAoZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICByZXR1cm4gdmFsdWUuZ2V0TW9udGgoKSA9PT0gbW9udGggLSAxID8gdmFsdWUuZ2V0RGF0ZSgpIDogMDtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMaWtlIGl0ZXJtb250aGRhdGVzKCksIGJ1dCB3aWxsIHlpZWxkIFtkYXkgbnVtYmVyLCB3ZWVrZGF5IG51bWJlcl1cbiAgICAgKiBhcnJheXMuIEZvciBkYXlzIG91dHNpZGUgdGhlIHNwZWNpZmllZCBtb250aCB0aGUgZGF5IG51bWJlciBpcyAwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbW9udGhcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pdGVybW9udGhkYXlzMiA9IGZ1bmN0aW9uKHllYXIsIG1vbnRoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pdGVybW9udGhkYXRlcyh5ZWFyLCBtb250aCkubWFwKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmdldE1vbnRoKCkgPT09IG1vbnRoIC0gMSA/IFt2YWx1ZS5nZXREYXRlKCksIF9hZGp1c3RXZWVrZGF5KHZhbHVlLmdldERheSgpKV0gOiBbMCwgX2FkanVzdFdlZWtkYXkodmFsdWUuZ2V0RGF5KCkpXTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBtYXRyaXggKGFycmF5IG9mIGFycmF5KSByZXByZXNlbnRpbmcgYSBtb250aCdzIGNhbGVuZGFyLlxuICAgICAqIEVhY2ggcm93IHJlcHJlc2VudHMgYSB3ZWVrOyB3ZWVrIGVudHJpZXMgYXJlIERhdGUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbW9udGhcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5tb250aGRhdGVzY2FsZW5kYXIgPSBmdW5jdGlvbih5ZWFyLCBtb250aCkge1xuICAgICAgdmFyIGRheXMgPSBbXTtcbiAgICAgIGRhdGVzID0gdGhpcy5pdGVybW9udGhkYXRlcyh5ZWFyLCBtb250aCk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGF0ZXMubGVuZ3RoOyBpICs9IDcpIHtcbiAgICAgICAgZGF5cy5wdXNoKGRhdGVzLnNsaWNlKGksIGkgKyA3KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBtYXRyaXggcmVwcmVzZW50aW5nIGEgbW9udGgncyBjYWxlbmRhci5cbiAgICAgKiBFYWNoIHJvdyByZXByZXNlbnRzIGEgd2VlazsgZGF5cyBvdXRzaWRlIHRoaXMgbW9udGggYXJlIHplcm8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geWVhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtb250aFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm1vbnRoZGF5c2NhbGVuZGFyID0gZnVuY3Rpb24oeWVhciwgbW9udGgpIHtcbiAgICAgIHZhciBkYXlzID0gW107XG4gICAgICBkYXRlcyA9IHRoaXMuaXRlcm1vbnRoZGF5cyh5ZWFyLCBtb250aCk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGF0ZXMubGVuZ3RoOyBpICs9IDcpIHtcbiAgICAgICAgZGF5cy5wdXNoKGRhdGVzLnNsaWNlKGksIGkgKyA3KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBtYXRyaXggcmVwcmVzZW50aW5nIGEgbW9udGgncyBjYWxlbmRhci5cbiAgICAgKiBFYWNoIHJvdyByZXByZXNlbnRzIGEgd2Vlazsgd2VlayBlbnRyaWVzIGFyZVxuICAgICAqIFtkYXkgbnVtYmVyLCB3ZWVrZGF5IG51bWJlcl0gYXJyYXlzLiBEYXkgbnVtYmVycyBvdXRzaWRlIHRoaXMgbW9udGhcbiAgICAgKiBhcmUgemVyby5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1vbnRoXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBDYWxlbmRhci5wcm90b3R5cGUubW9udGhkYXlzMmNhbGVuZGFyID0gZnVuY3Rpb24oeWVhciwgbW9udGgpIHtcbiAgICAgIHZhciBkYXlzID0gW107XG4gICAgICBkYXRlcyA9IHRoaXMuaXRlcm1vbnRoZGF5czIoeWVhciwgbW9udGgpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGRhdGVzLmxlbmd0aDsgaSArPSA3KSB7XG4gICAgICAgIGRheXMucHVzaChkYXRlcy5zbGljZShpLCBpICsgNykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF5cztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkYXRhIGZvciB0aGUgc3BlY2lmaWVkIHllYXIgcmVhZHkgZm9yIGZvcm1hdHRpbmcuIFRoZSByZXR1cm5cbiAgICAgKiB2YWx1ZSBpcyBhbiBhcnJheSBvZiBtb250aCByb3dzLiBFYWNoIG1vbnRoIHJvdyBjb250YWlucyB1cCB0byB3aWR0aCBtb250aHMuXG4gICAgICogRWFjaCBtb250aCBjb250YWlucyBiZXR3ZWVuIDQgYW5kIDYgd2Vla3MgYW5kIGVhY2ggd2VlayBjb250YWlucyAxLTdcbiAgICAgKiBkYXlzLiBEYXlzIGFyZSBEYXRlIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geWVhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnllYXJkYXRlc2NhbGVuZGFyID0gZnVuY3Rpb24oeWVhciwgd2lkdGgpIHtcbiAgICAgIHdpZHRoID0gdHlwZW9mKHdpZHRoKSA9PT0gXCJ1bmRlZmluZWRcIiA/IDMgOiB3aWR0aDtcblxuICAgICAgdmFyIG1vbnRocyA9IFtdO1xuICAgICAgZm9yKHZhciBtb250aCA9IDE7IG1vbnRoIDw9IDEyOyBtb250aCsrKSB7XG4gICAgICAgIG1vbnRocy5wdXNoKHRoaXMubW9udGhkYXRlc2NhbGVuZGFyKHllYXIsIG1vbnRoKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByb3dzID0gW107XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbW9udGhzLmxlbmd0aDsgaSArPSB3aWR0aCkge1xuICAgICAgICByb3dzLnB1c2gobW9udGhzLnNsaWNlKGksIGkgKyB3aWR0aCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCB5ZWFyIHJlYWR5IGZvciBmb3JtYXR0aW5nIChzaW1pbGFyIHRvXG4gICAgICogeWVhcmRhdGVzY2FsZW5kYXIoKSkuIEVudHJpZXMgaW4gdGhlIHdlZWsgYXJyYXlzIGFyZSBkYXkgbnVtYmVycy5cbiAgICAgKiBEYXkgbnVtYmVycyBvdXRzaWRlIHRoaXMgbW9udGggYXJlIHplcm8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geWVhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnllYXJkYXlzY2FsZW5kYXIgPSBmdW5jdGlvbih5ZWFyLCB3aWR0aCkge1xuICAgICAgd2lkdGggPSB0eXBlb2Yod2lkdGgpID09PSBcInVuZGVmaW5lZFwiID8gMyA6IHdpZHRoO1xuXG4gICAgICB2YXIgbW9udGhzID0gW107XG4gICAgICBmb3IodmFyIG1vbnRoID0gMTsgbW9udGggPD0gMTI7IG1vbnRoKyspIHtcbiAgICAgICAgbW9udGhzLnB1c2godGhpcy5tb250aGRheXNjYWxlbmRhcih5ZWFyLCBtb250aCkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcm93cyA9IFtdO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1vbnRocy5sZW5ndGg7IGkgKz0gd2lkdGgpIHtcbiAgICAgICAgcm93cy5wdXNoKG1vbnRocy5zbGljZShpLCBpICsgd2lkdGgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3dzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRhdGEgZm9yIHRoZSBzcGVjaWZpZWQgeWVhciByZWFkeSBmb3IgZm9ybWF0dGluZyAoc2ltaWxhciB0b1xuICAgICAqIHllYXJkYXRlc2NhbGVuZGFyKCkpLiBFbnRyaWVzIGluIHRoZSB3ZWVrIGFycmF5cyBhcmVcbiAgICAgKiBbZGF5IG51bWJlciwgd2Vla2RheSBudW1iZXJdIGFycmF5cy4gRGF5IG51bWJlcnMgb3V0c2lkZSB0aGlzIG1vbnRoIGFyZVxuICAgICAqIHplcm8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geWVhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnllYXJkYXlzMmNhbGVuZGFyID0gZnVuY3Rpb24oeWVhciwgd2lkdGgpIHtcbiAgICAgIHdpZHRoID0gdHlwZW9mKHdpZHRoKSA9PT0gXCJ1bmRlZmluZWRcIiA/IDMgOiB3aWR0aDtcblxuICAgICAgdmFyIG1vbnRocyA9IFtdO1xuICAgICAgZm9yKHZhciBtb250aCA9IDE7IG1vbnRoIDw9IDEyOyBtb250aCsrKSB7XG4gICAgICAgIG1vbnRocy5wdXNoKHRoaXMubW9udGhkYXlzMmNhbGVuZGFyKHllYXIsIG1vbnRoKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByb3dzID0gW107XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbW9udGhzLmxlbmd0aDsgaSArPSB3aWR0aCkge1xuICAgICAgICByb3dzLnB1c2gobW9udGhzLnNsaWNlKGksIGkgKyB3aWR0aCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGluZGljYXRpbmcgYSBub25leGlzdGVudCBvciB1bnN1cHBvcnRlZCBsb2NhbGUgc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIElsbGVnYWxMb2NhbGVFcnJvcihtZXNzYWdlKSB7XG4gICAgICB0aGlzLm5hbWUgPSBcIklsbGVnYWxMb2NhbGVFcnJvclwiO1xuICAgICAgdGhpcy5tZXNzYWdlID0gdHlwZW9mKG1lc3NhZ2UpID09PSBcInVuZGVmaW5lZFwiID8gXCJJbnZhbGlkIGxvY2FsZSBzcGVjaWZpZWQuXCIgOiBtZXNzYWdlO1xuICAgIH07XG4gICAgSWxsZWdhbExvY2FsZUVycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICAgIElsbGVnYWxMb2NhbGVFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbGxlZ2FsTG9jYWxlRXJyb3I7XG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBpbmRpY2F0aW5nIGEgZGF5IGluZGV4IHNwZWNpZmllZCBvdXRzaWRlIG9mIHRoZSB2YWxpZCByYW5nZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbGxlZ2FsRGF5RXJyb3IobWVzc2FnZSkge1xuICAgICAgdGhpcy5uYW1lID0gXCJJbGxlZ2FsRGF5RXJyb3JcIjtcbiAgICAgIHRoaXMubWVzc2FnZSA9IHR5cGVvZihtZXNzYWdlKSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwiSW52YWxpZCBkYXkgc3BlY2lmaWVkLlwiIDogbWVzc2FnZTtcbiAgICB9O1xuICAgIElsbGVnYWxEYXlFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgICBJbGxlZ2FsRGF5RXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSWxsZWdhbERheUVycm9yO1xuXG4gICAgLyoqXG4gICAgICogRXJyb3IgaW5kaWNhdGluZyBhIG1vbnRoIGluZGV4IHNwZWNpZmllZCBvdXRzaWRlIG9mIHRoZSBleHBlY3RlZCByYW5nZSAoMS0xMiB+IEphbi1EZWMpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIElsbGVnYWxNb250aEVycm9yKG1lc3NhZ2UpIHtcbiAgICAgIHRoaXMubmFtZSA9IFwiSWxsZWdhbE1vbnRoRXJyb3JcIjtcbiAgICAgIHRoaXMubWVzc2FnZSA9IHR5cGVvZihtZXNzYWdlKSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwiSW52YWxpZCBtb250aCBzcGVjaWZpZWQuXCIgOiBtZXNzYWdlO1xuICAgIH07XG4gICAgSWxsZWdhbE1vbnRoRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gICAgSWxsZWdhbE1vbnRoRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSWxsZWdhbE1vbnRoRXJyb3I7XG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBpbmRpY2F0aW5nIGEgdGltZSBlbGVtZW50IGlzIG91dHNpZGUgb2YgdGhlIHZhbGlkIHJhbmdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIElsbGVnYWxUaW1lRXJyb3IobWVzc2FnZSkge1xuICAgICAgdGhpcy5uYW1lID0gXCJJbGxlZ2FsVGltZUVycm9yXCI7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSB0eXBlb2YobWVzc2FnZSkgPT09IFwidW5kZWZpbmVkXCIgPyBcIkludmFsaWQgdGltZSBlbGVtZW50IHNwZWNpZmllZC5cIiA6IG1lc3NhZ2U7XG4gICAgfTtcbiAgICBJbGxlZ2FsVGltZUVycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICAgIElsbGVnYWxUaW1lRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSWxsZWdhbFRpbWVFcnJvcjtcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGluZGljYXRpbmcgYSB3ZWVrZGF5IGluZGV4IHNwZWNpZmllZCBvdXRzaWRlIG9mIHRoZSBleHBlY3RlZCByYW5nZSAoMC02IH4gTW9uLVN1bikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgZnVuY3Rpb24gSWxsZWdhbFdlZWtkYXlFcnJvcihtZXNzYWdlKSB7XG4gICAgICB0aGlzLm5hbWUgPSBcIklsbGVnYWxXZWVrZGF5RXJyb3JcIjtcbiAgICAgIHRoaXMubWVzc2FnZSA9IHR5cGVvZihtZXNzYWdlKSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwiSW52YWxpZCB3ZWVrZGF5IHNwZWNpZmllZC5cIiA6IG1lc3NhZ2U7XG4gICAgfTtcbiAgICBJbGxlZ2FsV2Vla2RheUVycm9yIC5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgICBJbGxlZ2FsV2Vla2RheUVycm9yIC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbGxlZ2FsV2Vla2RheUVycm9yIDtcblxuICAgIC8vIGV4cG9ydCBvZiBwYWNrYWdlLWxpa2Ugb2JqZWN0IHdpdGggZXhwbGljaXQgcHVibGljIEFQSVxuICAgIHZhciBjYWxlbmRhciA9IGZ1bmN0aW9uKCkge307XG5cbiAgICBjYWxlbmRhci5pc2xlYXAgICAgID0gaXNsZWFwO1xuICAgIGNhbGVuZGFyLmxlYXBkYXlzICAgPSBsZWFwZGF5cztcbiAgICBjYWxlbmRhci5tb250aHJhbmdlID0gbW9udGhyYW5nZTtcbiAgICBjYWxlbmRhci53ZWVrZGF5ICAgID0gd2Vla2RheTtcbiAgICBjYWxlbmRhci5zZXRsb2NhbGUgID0gc2V0bG9jYWxlO1xuICAgIGNhbGVuZGFyLnRpbWVnbSAgICAgPSB0aW1lZ207XG4gICAgY2FsZW5kYXIuQ2FsZW5kYXIgICA9IENhbGVuZGFyO1xuXG4gICAgY2FsZW5kYXIuSWxsZWdhbExvY2FsZUVycm9yICA9IElsbGVnYWxMb2NhbGVFcnJvcjtcbiAgICBjYWxlbmRhci5JbGxlZ2FsRGF5RXJyb3IgICAgID0gSWxsZWdhbERheUVycm9yO1xuICAgIGNhbGVuZGFyLklsbGVnYWxNb250aEVycm9yICAgPSBJbGxlZ2FsTW9udGhFcnJvcjtcbiAgICBjYWxlbmRhci5JbGxlZ2FsVGltZUVycm9yICAgID0gSWxsZWdhbFRpbWVFcnJvcjtcbiAgICBjYWxlbmRhci5JbGxlZ2FsV2Vla2RheUVycm9yID0gSWxsZWdhbFdlZWtkYXlFcnJvcjtcblxuICAgIGNhbGVuZGFyLk1PTkRBWSAgICAgPSAwO1xuICAgIGNhbGVuZGFyLlRVRVNEQVkgICAgPSAxO1xuICAgIGNhbGVuZGFyLldFRE5FU0RBWSAgPSAyO1xuICAgIGNhbGVuZGFyLlRIVVJTREFZICAgPSAzO1xuICAgIGNhbGVuZGFyLkZSSURBWSAgICAgPSA0O1xuICAgIGNhbGVuZGFyLlNBVFVSREFZICAgPSA1O1xuICAgIGNhbGVuZGFyLlNVTkRBWSAgICAgPSA2O1xuXG4gICAgY2FsZW5kYXIuSkFOVUFSWSAgICA9ICAxO1xuICAgIGNhbGVuZGFyLkZFQlJVQVJZICAgPSAgMjtcbiAgICBjYWxlbmRhci5NQVJDSCAgICAgID0gIDM7XG4gICAgY2FsZW5kYXIuQVBSSUwgICAgICA9ICA0O1xuICAgIGNhbGVuZGFyLk1BWSAgICAgICAgPSAgNTtcbiAgICBjYWxlbmRhci5KVU5FICAgICAgID0gIDY7XG4gICAgY2FsZW5kYXIuSlVMWSAgICAgICA9ICA3O1xuICAgIGNhbGVuZGFyLkFVR1VTVCAgICAgPSAgODtcbiAgICBjYWxlbmRhci5TRVBURU1CRVIgID0gIDk7XG4gICAgY2FsZW5kYXIuT0NUT0JFUiAgICA9IDEwO1xuICAgIGNhbGVuZGFyLk5PVkVNQkVSICAgPSAxMTtcbiAgICBjYWxlbmRhci5ERUNFTUJFUiAgID0gMTI7XG5cbiAgICBjYWxlbmRhci5zZXRsb2NhbGUoKTtcblxuICAgIC8vIEluaXRpYWxpemF0aW9uIG1ldGhvZG9sb2d5IGFuZCBub0NvbmZsaWN0IGNvdXJ0ZXN5IG5vZGUtdXVpZDpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZFxuXG4gICAgdmFyIF9nbG9iYWwgPSB0aGlzO1xuXG4gICAgLy8gUHVibGlzaCBhcyBub2RlLmpzIG1vZHVsZVxuICAgIGlmICh0eXBlb2YobW9kdWxlKSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBjYWxlbmRhcjtcbiAgICB9XG5cbiAgICAvLyBQdWJsaXNoIGFzIGdsb2JhbCAoaW4gYnJvd3NlcnMpXG4gICAgZWxzZSB7XG4gICAgICB2YXIgX3ByZXZpb3VzUm9vdCA9IF9nbG9iYWwuY2FsZW5kYXI7XG5cbiAgICAgIC8qKlxuICAgICAgICAqIFJlc2V0IGdsb2JhbCAnY2FsZW5kYXInIHZhcmlhYmxlXG4gICAgICAgICpcbiAgICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICAqL1xuICAgICAgY2FsZW5kYXIubm9jb25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBfZ2xvYmFsLmNhbGVuZGFyID0gX3ByZXZpb3VzUm9vdDtcbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyO1xuICAgICAgfTtcblxuICAgICAgX2dsb2JhbC5jYWxlbmRhciA9IGNhbGVuZGFyO1xuICAgIH1cblxufSkuY2FsbCh0aGlzKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBPYmplY3QuYXNzaWduXG4gKi9cblxuLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5hc3NpZ25cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2VzKSB7XG4gIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gdGFyZ2V0IGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICB9XG5cbiAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZm9yICh2YXIgbmV4dEluZGV4ID0gMTsgbmV4dEluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgbmV4dEluZGV4KyspIHtcbiAgICB2YXIgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tuZXh0SW5kZXhdO1xuICAgIGlmIChuZXh0U291cmNlID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBmcm9tID0gT2JqZWN0KG5leHRTb3VyY2UpO1xuXG4gICAgLy8gV2UgZG9uJ3QgY3VycmVudGx5IHN1cHBvcnQgYWNjZXNzb3JzIG5vciBwcm94aWVzLiBUaGVyZWZvcmUgdGhpc1xuICAgIC8vIGNvcHkgY2Fubm90IHRocm93LiBJZiB3ZSBldmVyIHN1cHBvcnRlZCB0aGlzIHRoZW4gd2UgbXVzdCBoYW5kbGVcbiAgICAvLyBleGNlcHRpb25zIGFuZCBzaWRlLWVmZmVjdHMuIFdlIGRvbid0IHN1cHBvcnQgc3ltYm9scyBzbyB0aGV5IHdvbid0XG4gICAgLy8gYmUgdHJhbnNmZXJyZWQuXG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuICAgICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ247XG4iLCJ2YXIgQXBwRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4vRGlzcGF0Y2hlci5qcycpO1xudmFyIGFwcENvbnN0YW50cyA9IHJlcXVpcmUoJy4vQ29uc3RhbnRzLmpzJyk7XG5cbnZhciBwbGFubmVyQWN0aW9ucyA9IHtcbiAgbmV3TW9udGg6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgQXBwRGlzcGF0Y2hlci5oYW5kbGVWaWV3QWN0aW9uKHtcbiAgICAgIGFjdGlvblR5cGU6IGFwcENvbnN0YW50cy5ORVdfTU9OVEgsXG4gICAgICBkYXRhOiBkYXRlXG4gICAgfSk7XG4gIH0sXG4gIGZpbmRNb250aDogZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgIEFwcERpc3BhdGNoZXIuaGFuZGxlVmlld0FjdGlvbih7XG4gICAgICBhY3Rpb25UeXBlOiBhcHBDb25zdGFudHMuRklORF9NT05USCxcbiAgICAgIGRhdGE6IGRpcmVjdGlvblxuICAgIH0pO1xuICB9LFxuICBzZWxlY3RlZERheTogZnVuY3Rpb24gKGRheU51bSkge1xuICAgIEFwcERpc3BhdGNoZXIuaGFuZGxlVmlld0FjdGlvbih7XG4gICAgICBhY3Rpb25UeXBlOiBhcHBDb25zdGFudHMuU0VMRUNURURfREFZLFxuICAgICAgZGF0YTogZGF5TnVtXG4gICAgfSk7XG4gIH0sXG4gIGFkZEV2ZW50czogZnVuY3Rpb24gKGV2dCkge1xuICAgIEFwcERpc3BhdGNoZXIuaGFuZGxlVmlld0FjdGlvbih7XG4gICAgICBhY3Rpb25UeXBlOiBhcHBDb25zdGFudHMuQUREX0VWRU5UUyxcbiAgICAgIGRhdGE6IGV2dFxuICAgIH0pO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBsYW5uZXJBY3Rpb25zO1xuIiwidmFyIGFwcENvbnN0YW50cyA9IHtcbiAgTkVXX01PTlRIOiAnTkVXX01PTlRIJyxcbiAgRklORF9NT05USDogJ0ZJTkRfTU9OVEgnLFxuICBTRUxFQ1RFRF9EQVk6ICdTRUxFQ1RFRF9EQVknLFxuICBBRERfRVZFTlRTOiAnQUREX0VWRU5UUydcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwQ29uc3RhbnRzO1xuIiwidmFyIERpc3BhdGNoZXIgPSByZXF1aXJlKCdmbHV4JykuRGlzcGF0Y2hlcjtcbnZhciBBcHBEaXNwYXRjaGVyID0gbmV3IERpc3BhdGNoZXIoKTtcblxuQXBwRGlzcGF0Y2hlci5oYW5kbGVWaWV3QWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uKSB7XG4gIHRoaXMuZGlzcGF0Y2goe1xuICAgIHNvdXJjZTogJ1ZJRVdfQUNUSU9OJyxcbiAgICBhY3Rpb246IGFjdGlvblxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBcHBEaXNwYXRjaGVyO1xuIiwidmFyIG1vbnRoQ29udmVyc2lvbiA9IHtcbiAgSmFuIDogWzEsICdKYW51YXJ5J10sXG4gIEZlYiA6IFsyLCAnRmVicnVhcnknXSxcbiAgTWFyIDogWzMsICdNYXJjaCddLFxuICBBcHIgOiBbNCwgJ0FwcmlsJ10sXG4gIE1heSA6IFs1LCAnTWF5J10sXG4gIEp1biA6IFs2LCAnSnVuZSddLFxuICBKdWwgOiBbNywgJ0p1bHknXSxcbiAgQXVnIDogWzgsICdBdWd1c3QnXSxcbiAgU2VwIDogWzksICdTZXB0ZW1iZXInXSxcbiAgT2N0IDogWzEwLCAnT2N0b2JlciddLFxuICBOb3YgOiBbMTEsICdOb3ZlbWJlciddLFxuICBEZWMgOiBbMTIsICdEZWNlbWJlciddLFxuICAxIDogJ0phbicsXG4gIDIgOiAnRmViJyxcbiAgMyA6ICdNYXInLFxuICA0IDogJ0FwcicsXG4gIDUgOiAnTWF5JyxcbiAgNiA6ICdKdW4nLFxuICA3IDogJ0p1bCcsXG4gIDggOiAnQXVnJyxcbiAgOSA6ICdTZXAnLFxuICAxMCA6ICdPY3QnLFxuICAxMSA6ICdOb3YnLFxuICAxMiA6ICdEZWMnLFxufVxuXG52YXIgbW9udGhBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtb24gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdtb250aEdyaWQnKVswXS5jbGFzc0xpc3Q7XG4gIG1vbi5hZGQoJ2FuaW1hdGVkJywgJ3pvb21JbicpO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IG1vbi5yZW1vdmUoJ2FuaW1hdGVkJywgJ3pvb21JbicpIH0sIDEwMDApO1xufVxuXG52YXIgc29ydGVkRXZlbnRzID0gZnVuY3Rpb24gKGV2dDEsIGV2dDIpIHtcbiAgcmV0dXJuIHBhcnNlSW50KGV2dDEudGltZS5zdGFydCkgLSBwYXJzZUludChldnQyLnRpbWUuc3RhcnQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbW9udGhDb252ZXJzaW9uOiBtb250aENvbnZlcnNpb24sXG4gIG1vbnRoQW5pbWF0aW9uOiBtb250aEFuaW1hdGlvbixcbiAgc29ydGVkRXZlbnRzOiBzb3J0ZWRFdmVudHNcbn1cbiIsInZhciBEYXkgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2PlxuICAgICAgICB7XG4gICAgICAgICB0aGlzLnByb3BzLmN1cnJlbnRNb250aC5pdGVtcy5ldmVudHNbcGFyc2VJbnQodGhpcy5wcm9wcy5kYXkpXVxuICAgICAgICAgPyB0aGlzLnByb3BzLmN1cnJlbnRNb250aC5pdGVtcy5ldmVudHNbcGFyc2VJbnQodGhpcy5wcm9wcy5kYXkpXS5tYXAoZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgcmV0dXJuIDxwPntldnQudGl0bGV9PC9wPlxuICAgICAgICAgICB9KVxuICAgICAgICAgOiBudWxsXG4gICAgICAgIH1cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBEYXk7XG4iLCJ2YXIgRXZlbnRzID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJhbmltYXRlZCB6b29tSW5cIj5cbiAgICAgICAgPGgxPllvdXIgRXZlbnRzPC9oMT5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudHM7XG4iLCJ2YXIgRGF5ID0gcmVxdWlyZSgnLi9EYXkuanN4Jyk7XG5cbnZhciBNb250aCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiAoXG4gICAgICA8c2VjdGlvbj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYWxlbmRhckhlYWRlclwiPlxuICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiYnRuIGJ0bi1wcmltYXJ5XCIgb25DbGljaz17dGhpcy5wcm9wcy5oYW5kbGVycy5kaXNwbGF5TW9udGh9PkJhY2s8L2J1dHRvbj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vbnRoTmFtZVwiPlxuICAgICAgICAgICAgPGgxPnt0aGlzLnByb3BzLmN1cnJlbnRNb250aC5uYW1lfTwvaDE+XG4gICAgICAgICAgICA8aDQ+e3RoaXMucHJvcHMuY3VycmVudE1vbnRoLnllYXJ9PC9oND5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cImJ0biBidG4tcHJpbWFyeVwiIG9uQ2xpY2s9e3RoaXMucHJvcHMuaGFuZGxlcnMuZGlzcGxheU1vbnRofT5Gb3J3YXJkPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8dGFibGUgY2xhc3NOYW1lPVwibW9udGhHcmlkIHRhYmxlLWJvcmRlcmVkXCI+XG4gICAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICA8dGg+U3VuZGF5PC90aD4gPHRoPk1vbmRheTwvdGg+IDx0aD5UdWVzZGF5PC90aD4gPHRoPldlZG5lc2RheTwvdGg+IDx0aD5UaHVyc2RheTwvdGg+IDx0aD5GcmlkYXk8L3RoPiA8dGg+U2F0dXJkYXk8L3RoPlxuICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICA8L3RoZWFkPlxuICAgICAgICAgIDx0Ym9keT5cbiAgICAgICAgICAgIHt0aGlzLnByb3BzLmN1cnJlbnRNb250aC5tb250aE1hdHJpeC5tYXAoZnVuY3Rpb24od2Vlaykge1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDx0ciBrZXk9e3dlZWt9PlxuICAgICAgICAgICAgICAgICAge3dlZWsubWFwKGZ1bmN0aW9uKGRheSwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5ID09IHBhcnNlSW50KHRoaXMucHJvcHMuY3VycmVudE1vbnRoLnNlbGVjdGVkRGF5KVxuICAgICAgICAgICAgICAgICAgICAgID8gPHRkIGNsYXNzTmFtZT1cInNlbGVjdGVkRGF5XCIga2V5PXtpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPGI+PHA+e2RheX08L3A+PC9iPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8RGF5IGRheT17ZGF5fSBjdXJyZW50TW9udGg9e3RoaXMucHJvcHMuY3VycmVudE1vbnRofSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICA6IDx0ZCBvbkNsaWNrPXt0aGlzLnByb3BzLmhhbmRsZXJzLnNlbGVjdGVkRGF5LmJpbmQodGhpcywgZGF5KX0ga2V5PXtpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPGI+PHA+e2RheX08L3A+PC9iPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8RGF5IGRheT17ZGF5fSBjdXJyZW50TW9udGg9e3RoaXMucHJvcHMuY3VycmVudE1vbnRofSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgIH0sdGhpcyl9XG4gICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sdGhpcyl9XG4gICAgICAgICAgPC90Ym9keT5cbiAgICAgICAgPC90YWJsZT5cbiAgICAgIDwvc2VjdGlvbj5cbiAgICApO1xuICB9XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vbnRoO1xuIiwidmFyIE1vbnRoID0gcmVxdWlyZSgnLi9tb250aC5qc3gnKTtcbnZhciBTZWxlY3RlZERheSA9IHJlcXVpcmUoJy4vc2VsZWN0ZWREYXkuanN4Jyk7XG52YXIgVGFza01hbmFnZXIgPSByZXF1aXJlKCcuL3Rhc2tNYW5hZ2VyLmpzeCcpO1xudmFyIHBsYW5uZXJTdG9yZSA9IHJlcXVpcmUoJy4uL3N0b3Jlcy9wbGFubmVyU3RvcmUuanMnKTtcbnZhciBwbGFubmVyQWN0aW9ucyA9IHJlcXVpcmUoJy4uL0FjdGlvbi5qcycpO1xudmFyIG1vbnRoQW5pbWF0aW9uID0gcmVxdWlyZSgnLi4vYXNzZXRzL2NhbGVuZGFyQ29udmVyc2lvbnMnKS5tb250aEFuaW1hdGlvbjtcblxudmFyIFBsYW5uZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkudG9TdHJpbmcoKS5zcGxpdCgnICcpO1xuICAgIHBsYW5uZXJBY3Rpb25zLm5ld01vbnRoKFtub3dbMV0sIG5vd1szXSwgbm93WzJdXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnRNb250aDogcGxhbm5lclN0b3JlLmdldEN1cnJlbnRNb250aCgpLFxuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBwbGFubmVyU3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIodGhpcy5fb25DaGFuZ2UpO1xuICB9LFxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gKCkge1xuICAgIHBsYW5uZXJTdG9yZS5yZW1vdmVDaGFuZ2VMaXN0ZW5lcih0aGlzLl9vbkNoYW5nZSk7XG4gIH0sXG4gIGhhbmRsZXJzOiB7XG4gICAgc2VsZWN0ZWREYXk6ICBmdW5jdGlvbiAoZGF5KSB7XG4gICAgICBwbGFubmVyQWN0aW9ucy5zZWxlY3RlZERheShkYXkpO1xuICAgIH0sXG4gICAgZGlzcGxheU1vbnRoOiBmdW5jdGlvbiAoZSkge1xuICAgICAgbW9udGhBbmltYXRpb24oKTtcbiAgICAgIGUudGFyZ2V0LmlubmVySFRNTCA9PSAnRm9yd2FyZCcgPyBwbGFubmVyQWN0aW9ucy5maW5kTW9udGgodHJ1ZSkgOiBwbGFubmVyQWN0aW9ucy5maW5kTW9udGgoZmFsc2UpO1xuICAgIH0sXG4gICAgYWRkRXZlbnRzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgcGxhbm5lckFjdGlvbnMuYWRkRXZlbnRzKGUpO1xuICAgIH1cbiAgfSxcbiAgX29uQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjdXJyZW50TW9udGg6IHBsYW5uZXJTdG9yZS5nZXRDdXJyZW50TW9udGgoKVxuICAgIH0pXG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYW5pbWF0ZWQgem9vbUluIGNvbnRhaW5lci1mbHVpZFwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvdyB0ZXh0LWNlbnRlclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLW1kLThcIj5cbiAgICAgICAgICAgIDxNb250aCBjdXJyZW50TW9udGg9e3RoaXMuc3RhdGUuY3VycmVudE1vbnRofSBoYW5kbGVycz17dGhpcy5oYW5kbGVyc30gLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1tZC00XCI+XG4gICAgICAgICAgICA8VGFza01hbmFnZXIgY3VycmVudE1vbnRoPXt0aGlzLnN0YXRlLmN1cnJlbnRNb250aH0gYWRkRXZlbnRzPXt0aGlzLmhhbmRsZXJzLmFkZEV2ZW50c30gLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbn0pO1xuXG5cblJlYWN0LnJlbmRlcig8UGxhbm5lciAvPiwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcCcpKTtcbiIsInZhciBTZWxlY3RlZERheSA9IFJlYWN0LmNyZWF0ZUNsYXNzICh7XG4gIGhhbmRsZVN1Ym1pdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmb3JtID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoJ25ld0V2ZW50Jyk7XG4gICAgdGhpcy5wcm9wcy5hZGRFdmVudHMoe1xuICAgICAgZGF5OiB0aGlzLnByb3BzLmN1cnJlbnRNb250aC5zZWxlY3RlZERheSwgdGltZToge3N0YXJ0OiBmb3JtWzFdLnZhbHVlLCBlbmQ6IGZvcm1bMl0udmFsdWV9LCB0aXRsZTogZm9ybVswXS52YWx1ZSwgZGVzY3JpcHRpb246IGZvcm1bM10udmFsdWVcbiAgICB9KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcm0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvcm1baV0udmFsdWUgPSBudWxsO1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYW5pbWF0ZWQgem9vbUluIHNlbGVjdGVkRGF5SGVhZGVyXCI+XG4gICAgICAgIDxoND5BZGQgRXZlbnQ8L2g0PlxuICAgICAgICA8Zm9ybT5cbiAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBwbGFjZWhvbGRlcj1cIlRpdGxlXCIgbmFtZT1cIm5ld0V2ZW50XCI+PC9pbnB1dD5cbiAgICAgICAgICA8aW5wdXQgdHlwZT1cInRpbWVcIiBwbGFjZWhvbGRlcj1cIlN0YXJ0XCIgbmFtZT1cIm5ld0V2ZW50XCI+PC9pbnB1dD5cbiAgICAgICAgICA8aW5wdXQgdHlwZT1cInRpbWVcIiBwbGFjZWhvbGRlcj1cIkVuZFwiIG5hbWU9XCJuZXdFdmVudFwiPjwvaW5wdXQ+XG4gICAgICAgICAgPHRleHRhcmVhIGRlZmF1bHRWYWx1ZT1cIkRlc2NyaXB0aW9uXCIgbmFtZT1cIm5ld0V2ZW50XCI+PC90ZXh0YXJlYT5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJnbHlwaGljb24gZ2x5cGhpY29uLXBsdXMtc2lnblwiIG9uQ2xpY2s9e3RoaXMuaGFuZGxlU3VibWl0fT48L3NwYW4+XG4gICAgICAgIDwvZm9ybT5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxuXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdGVkRGF5XG4iLCJ2YXIgU2VsZWN0ZWREYXkgPSByZXF1aXJlKCcuL3NlbGVjdGVkRGF5LmpzeCcpO1xudmFyIEV2ZW50cyA9IHJlcXVpcmUoJy4vZXZlbnRzLmpzeCcpO1xuXG52YXIgVGFza01hbmFnZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGVUb2dnbGU6IHRydWUsXG4gICAgICBldmVudHNUb2dnbGU6IGZhbHNlLFxuICAgICAgdG9Eb1RvZ2dsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGhhbmRsZXJzOiB7XG4gICAgZGF0ZVRvZ2dsZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGRhdGVUb2dnbGU6IHRoaXMuc3RhdGUuZGF0ZVRvZ2dsZSA/IHRoaXMuc3RhdGUuZGF0ZVRvZ2dsZSA9IGZhbHNlIDogdGhpcy5zdGF0ZS5kYXRlVG9nZ2xlID0gdHJ1ZVxuICAgICAgfSlcbiAgICB9LFxuICAgIGV2ZW50c1RvZ2dsZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGV2ZW50c1RvZ2dsZTogdGhpcy5zdGF0ZS5ldmVudHNUb2dnbGUgPyB0aGlzLnN0YXRlLmV2ZW50c1RvZ2dsZSA9IGZhbHNlIDogdGhpcy5zdGF0ZS5ldmVudHNUb2dnbGUgPSB0cnVlXG4gICAgICB9KVxuICAgIH0sXG4gICAgdG9Eb1RvZ2dsZTogZnVuY3Rpb24gKCkge1xuXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPHNlY3Rpb24+XG4gICAgICAgIDxoMSBjbGFzc05hbWU9XCJ0YXNrSGVhZGVyXCI+VGFzayBNYW5hZ2VyPC9oMT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0YXNrQ29udGFpbmVyXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0YXNrU2VjdGlvblwiPlxuICAgICAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLmhhbmRsZXJzLmRhdGVUb2dnbGUuYmluZCh0aGlzKX0+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17XCJ0YXNrSWNvbiBnbHlwaGljb24gZ2x5cGhpY29uLXRyaWFuZ2xlLVwiICsgKHRoaXMuc3RhdGUuZGF0ZVRvZ2dsZSA/IFwiYm90dG9tXCIgOiBcInJpZ2h0XCIpfT48L3NwYW4+XG4gICAgICAgICAgICAgIDxoMz57dGhpcy5wcm9wcy5jdXJyZW50TW9udGgubmFtZSArXCIgXCIrIHRoaXMucHJvcHMuY3VycmVudE1vbnRoLnNlbGVjdGVkRGF5ICtcIiwgXCIrIHRoaXMucHJvcHMuY3VycmVudE1vbnRoLnllYXJ9PC9oMz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAge3RoaXMuc3RhdGUuZGF0ZVRvZ2dsZSA/IDxTZWxlY3RlZERheSBjdXJyZW50TW9udGg9e3RoaXMucHJvcHMuY3VycmVudE1vbnRofSBhZGRFdmVudHM9e3RoaXMucHJvcHMuYWRkRXZlbnRzfSAvPiA6IG51bGx9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0YXNrU2VjdGlvblwiPlxuICAgICAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLmhhbmRsZXJzLmV2ZW50c1RvZ2dsZS5iaW5kKHRoaXMpfT5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtcInRhc2tJY29uIGdseXBoaWNvbiBnbHlwaGljb24tdHJpYW5nbGUtXCIgKyAodGhpcy5zdGF0ZS5ldmVudHNUb2dnbGUgPyBcImJvdHRvbVwiIDogXCJyaWdodFwiKX0+PC9zcGFuPlxuICAgICAgICAgICAgICA8aDM+RXZlbnRzPC9oMz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAge3RoaXMuc3RhdGUuZXZlbnRzVG9nZ2xlID8gPEV2ZW50cyBjdXJyZW50TW9udGg9e3RoaXMucHJvcHMuY3VycmVudE1vbnRofS8+IDogbnVsbH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRhc2tTZWN0aW9uXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0YXNrSWNvbiBnbHlwaGljb24gZ2x5cGhpY29uLXRyaWFuZ2xlLXJpZ2h0XCI+PC9zcGFuPlxuICAgICAgICAgICAgPGgzPlRvRG8nczwvaDM+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9zZWN0aW9uPlxuICAgIClcbiAgfVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBUYXNrTWFuYWdlcjtcbiIsInZhciBBcHBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vRGlzcGF0Y2hlci5qcycpO1xudmFyIGFwcENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL0NvbnN0YW50cy5qcycpO1xudmFyIG9iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9PYmplY3QuYXNzaWduJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGNhbGVuZGFyID0gcmVxdWlyZSgnbm9kZS1jYWxlbmRhcicpO1xudmFyIGFzc2V0cyA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9jYWxlbmRhckNvbnZlcnNpb25zJyk7XG5cbnZhciBDSEFOR0VfRVZFTlQgPSAnY2hhbmdlJztcblxudmFyIHllYXJzID0ge307XG52YXIgY3VycmVudCA9IHt9O1xuXG5mdW5jdGlvbiBNb250aChkYXRlKSB7XG4gIHRoaXMubmFtZSA9IGFzc2V0cy5tb250aENvbnZlcnNpb25bZGF0ZVswXV1bMV07XG4gIHRoaXMubW9udGhLZXkgPSBhc3NldHMubW9udGhDb252ZXJzaW9uW2RhdGVbMF1dWzBdO1xuICB0aGlzLnllYXIgPSBwYXJzZUludChkYXRlWzFdKTtcbiAgdGhpcy5tb250aE1hdHJpeCA9IGRhdGU7XG4gIHRoaXMuc2VsZWN0ZWREYXkgPSBkYXRlWzJdIHx8IDE7XG4gIHRoaXMuaXRlbXMgPSB7XG4gICAgZXZlbnRzOiB7fSxcbiAgICB0b2Rvczoge31cbiAgfTtcbn1cblxuTW9udGgucHJvdG90eXBlLm5ld01vbnRoID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm1vbnRoTWF0cml4ID0gbmV3IGNhbGVuZGFyLkNhbGVuZGFyKGNhbGVuZGFyLlNVTkRBWSkubW9udGhkYXlzY2FsZW5kYXIodGhpcy5tb250aE1hdHJpeFsxXSwgYXNzZXRzLm1vbnRoQ29udmVyc2lvblt0aGlzLm1vbnRoTWF0cml4WzBdXVswXSk7XG59O1xuXG52YXIgbmV3TW9udGggPSBmdW5jdGlvbiAoZGF0ZSkge1xuICBjdXJyZW50ID0gbmV3IE1vbnRoKGRhdGUpO1xuICBjdXJyZW50Lm5ld01vbnRoKCk7XG4gIHllYXJzW2N1cnJlbnQueWVhcl0gPyB5ZWFyc1tjdXJyZW50LnllYXJdLnB1c2goY3VycmVudCkgOiB5ZWFyc1tjdXJyZW50LnllYXJdID0gW2N1cnJlbnRdO1xufVxuXG52YXIgZmluZE1vbnRoID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICBpZihkaXJlY3Rpb24pXG4gICAgY3VycmVudC5tb250aEtleSArMSA8IDEzID8gbmV3Q3VycmVudCA9IFtjdXJyZW50Lm1vbnRoS2V5ICsxLCBjdXJyZW50LnllYXJdIDogbmV3Q3VycmVudCA9IFsxLCBjdXJyZW50LnllYXIgKzFdO1xuICBlbHNlXG4gICAgY3VycmVudC5tb250aEtleSAtMSA+IDAgPyBuZXdDdXJyZW50ID0gW2N1cnJlbnQubW9udGhLZXkgLTEsIGN1cnJlbnQueWVhcl0gOiBuZXdDdXJyZW50ID0gWzEyLCBjdXJyZW50LnllYXIgLTFdO1xuICBpZih5ZWFyc1tuZXdDdXJyZW50WzFdXSl7XG4gICAgdmFyIGNoZWNrZXIgPSB5ZWFyc1tuZXdDdXJyZW50WzFdXS5maWx0ZXIoZnVuY3Rpb24gKG1vbikge1xuICAgICAgaWYobW9uLm1vbnRoS2V5ID09PSBuZXdDdXJyZW50WzBdKVxuICAgICAgICByZXR1cm4gbW9uO1xuICAgIH0pXG4gICAgY2hlY2tlci5sZW5ndGggPiAwID8gY3VycmVudCA9IGNoZWNrZXJbMF0gOiBuZXdNb250aChbYXNzZXRzLm1vbnRoQ29udmVyc2lvbltuZXdDdXJyZW50WzBdXSwgbmV3Q3VycmVudFsxXV0pO1xuICB9IGVsc2Uge1xuICAgIG5ld01vbnRoKFthc3NldHMubW9udGhDb252ZXJzaW9uW25ld0N1cnJlbnRbMF1dLCBuZXdDdXJyZW50WzFdXSk7XG4gIH1cbn1cblxudmFyIHNlbGVjdGVkRGF5ID0gZnVuY3Rpb24gKGRheU51bSkge1xuICBjdXJyZW50LnNlbGVjdGVkRGF5ID0gZGF5TnVtO1xufVxuXG52YXIgYWRkRXZlbnRzID0gZnVuY3Rpb24gKGV2dCkge1xuICBjdXJyZW50Lml0ZW1zLmV2ZW50c1tldnQuZGF5XSA/IGN1cnJlbnQuaXRlbXMuZXZlbnRzW2V2dC5kYXldLnB1c2goZXZ0KSA6IGN1cnJlbnQuaXRlbXMuZXZlbnRzW2V2dC5kYXldID0gW2V2dF07XG4gIGN1cnJlbnQuaXRlbXMuZXZlbnRzW2V2dC5kYXldLnNvcnQoYXNzZXRzLnNvcnRlZEV2ZW50cyk7ICBcbn1cblxudmFyIHBsYW5uZXJTdG9yZSA9IG9iamVjdEFzc2lnbih7fSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSwge1xuICBhZGRDaGFuZ2VMaXN0ZW5lcjogZnVuY3Rpb24gKGNiKSB7XG4gICAgdGhpcy5vbihDSEFOR0VfRVZFTlQsIGNiKTtcbiAgfSxcbiAgcmVtb3ZlQ2hhbmdlTGlzdGVuZXI6IGZ1bmN0aW9uIChjYikge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoQ0hBTkdFX0VWRU5ULCBjYik7XG4gIH0sXG4gIGdldEN1cnJlbnRNb250aDogZnVuY3Rpb24gKCkge1xuICAgIGNvbnNvbGUubG9nKHllYXJzLCBjdXJyZW50KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxufSk7XG5cbkFwcERpc3BhdGNoZXIucmVnaXN0ZXIoZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgdmFyIGFjdGlvbiA9IHBheWxvYWQuYWN0aW9uO1xuICBzd2l0Y2goYWN0aW9uLmFjdGlvblR5cGUpe1xuICAgIGNhc2UgYXBwQ29uc3RhbnRzLk5FV19NT05USDpcbiAgICAgIG5ld01vbnRoKGFjdGlvbi5kYXRhKTtcbiAgICAgIHBsYW5uZXJTdG9yZS5lbWl0KENIQU5HRV9FVkVOVCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFwcENvbnN0YW50cy5GSU5EX01PTlRIOlxuICAgICAgZmluZE1vbnRoKGFjdGlvbi5kYXRhKTtcbiAgICAgIHBsYW5uZXJTdG9yZS5lbWl0KENIQU5HRV9FVkVOVCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFwcENvbnN0YW50cy5TRUxFQ1RFRF9EQVk6XG4gICAgICBzZWxlY3RlZERheShhY3Rpb24uZGF0YSk7XG4gICAgICBwbGFubmVyU3RvcmUuZW1pdChDSEFOR0VfRVZFTlQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhcHBDb25zdGFudHMuQUREX0VWRU5UUzpcbiAgICAgIGFkZEV2ZW50cyhhY3Rpb24uZGF0YSk7XG4gICAgICBwbGFubmVyU3RvcmUuZW1pdChDSEFOR0VfRVZFTlQpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGxhbm5lclN0b3JlO1xuIl19
